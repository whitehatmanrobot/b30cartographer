pci )
        _pci->MarkOutOfDate();
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------

void CCI::MarkUpToDate()
{
    if ( 0 != _pci )
        _pci->MarkUpToDate();
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
NTSTATUS CCI::CiState(CIF_STATE & state)
{
    if ( 0 != _pci )
        return _pci->CiState(state);

    AssertOnNotFound(STATUS_NOT_FOUND);
    return STATUS_NOT_FOUND;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCI::BackupCiData
//
//  Synopsis:   Backups Content Index data using the storage provided.
//
//  Arguments:  [storage]         - Destination storage.
//              [fFull]           - In/Out Set to TRUE if a full save is needed
//              On output, set to TRUE if a full save was done because CI
//              decided to do a FULL save.
//              [xEnumWorkids]    - On output, will have the workid enumerator.
//              [progressTracker] - Progress feedback and out-of-band abort
//              signalling.
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CCI::BackupCiData( PStorage & storage,
                         BOOL & fFull,
                         XInterface<ICiEnumWorkids> & xEnumWorkids,
                         PSaveProgressTracker & progressTracker )
{
    SCODE sc = CI_E_INVALID_STATE;

    if ( 0 != _pci )
    {
        sc = _pci->BackupCiData( storage, fFull, xEnumWorkids, progressTracker );
        if ( !SUCCEEDED(sc) )
        {
            //
            // Cleanup any partially created files.
            //
            storage.DeleteAllCiFiles();
        }
    }

    return sc;
}

NTSTATUS CCI::IndexSize( ULONG & mbIndex )
{
    if ( 0 != _pci )
    {
        _pci->IndexSize( mbIndex );
        return S_OK;
    }

    AssertOnNotFound(STATUS_NOT_FOUND);
    mbIndex = 0;
    return STATUS_NOT_FOUND;
}

NTSTATUS CCI::IsLowOnDiskSpace( BOOL & fLow )
{
    if ( 0 != _pci )
    {
        fLow = _pci->IsLowOnDiskSpace();
        return S_OK;
    }

    AssertOnNotFound(STATUS_NOT_FOUND);
    fLow = FALSE;
    return STATUS_NOT_FOUND;
}

NTSTATUS CCI::VerifyIfLowOnDiskSpace( BOOL & fLow )
{
    if ( 0 != _pci )
    {
        fLow = _pci->VerifyIfLowOnDiskSpace();
        return S_OK;
    }

    AssertOnNotFound(STATUS_NOT_FOUND);
    fLow = FALSE;
    return STATUS_NOT_FOUND;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::Query, public
//
//  Synopsis:   Resolves a free-text query.
//
//  Effects:    Parses a free text query and creates a tree of cursors to
//              resolve the query.
//
//  Arguments:  [pRst]   -- Pointer to tree of query restriction(s)
//              [pFlags] -- Holds information about the status of the query
//              [cPartitions] -- The number of partitions in aPartID.
//              [aPartID] -- Array of partitionIDs specifying partitions
//                          to be searched.
//              [cPendingUpdates] -- The number of pending updates that
//                          should be allowed before using enumeration on
//                          property queries.
//              [cMaxNodes] -- Maximum query expansion.
//
//  Requires:   All partitions in aPartID are valid.
//
//  Returns:    A cursor to iterate over the results
//
//  Modifies:   pFlags may be modified to reflect the status of the query
//
//  History:    19-Sep-91   BartoszM    Created.
//
//----------------------------------------------------------------------------

CCursor* CCI::Query( CRestriction const * pRst,
                     ULONG* pFlags,
                     UINT cPartitions,
                     PARTITIONID aPartID[],
                     ULONG cPendingUpdates,
                     ULONG cMaxNodes )
{
    if ( _pci )
        return _pci->Query( pRst,
                            pFlags,
                            cPartitions,
                            aPartID,
                            cPendingUpdates,
                            cMaxNodes );
    return 0;
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
NTSTATUS CCI::Dismount()
{
    if ( 0 != _pci )
    {
        _pci->Dismount();
        _xPropMapper.Free();
        return S_OK;
    }

    return STATUS_NOT_FOUND;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::FilterReady, public
//
//  Synopsis:   Retrieves list of documents to be filtered.  Blocks thread if
//              resources are not available or if there are no documents to
//              be filtered.
//
//  Arguments:  [docBuffer] -- (in, out) buffer for paths and properties of
//                             documents to be filtered.
//              [cwc] -- (in) count of BYTES in docBuffer
//              [cMaxDocs] -- (in) the maximum number of docs that can be
//                            filtered at once by the filter daemon.
//
//  History:    18-Apr-93   AmyA           Created.
//              21-Jan-97   SrikantS       Changed to BYTE buffers for framework
//
//----------------------------------------------------------------------------

SCODE CCI::FilterReady ( BYTE * docBuffer, ULONG & cb, ULONG cMaxDocs )
{
    if ( 0 != _pci )
        return( _pci->FilterReady( docBuffer, cb, cMaxDocs ) );

    AssertOnNotFound(STATUS_NOT_FOUND);
    return STATUS_NOT_FOUND;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::FilterDataReady, public
//
//  Synopsis:   Adds the contents of entry buffer to the current word list.
//
//  Returns:    Whether the word list is full
//
//  Arguments:  [pEntryBuf] -- pointer to data to be added to word list
//              [cb] -- count of bytes in buffer
//
//  History:    22-Mar-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE CCI::FilterDataReady( const BYTE * pEntryBuf, ULONG cb )
{
    Win4Assert( _pci );

    if ( 0 != _pci )
        return( _pci->FilterDataReady( pEntryBuf, cb ) );

    AssertOnNotFound(STATUS_NOT_FOUND);
    return(STATUS_NOT_FOUND);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::FilterMore, public
//
//  Synopsis:   Commits the current word list and initializes a new one.
//
//  Arguments:  [aStatus] -- array of STATUS for the resource manager
//              [count] -- count for array
//
//  History:    03-May-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE CCI::FilterMore( const STATUS * aStatus, ULONG count )
{
    if ( 0 != _pci )
        return( _pci->FilterMore( aStatus, count ) );

    AssertOnNotFound(STATUS_NOT_FOUND);
    return(STATUS_NOT_FOUND);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::FilterDone, public
//
//  Synopsis:   Commits the current word list.
//
//  Arguments:  [aStatus] -- array of STATUS for the resource manager
//              [count] -- count for array
//
//  History:    22-Mar-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE CCI::FilterDone( const STATUS * aStatus, ULONG count )
{
    if ( 0 != _pci )
        return( _pci->FilterDone( aStatus, count ) );

    AssertOnNotFound(STATUS_NOT_FOUND);
    return(STATUS_NOT_FOUND);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::FPSToPROPID, public
//
//  Synopsis:   Converts FULLPROPSPEC property to PROPID
//
//  Arguments:  [fps] -- FULLPROPSPEC representation of property
//              [pid] -- PROPID written here on success
//
//  Returns:    S_OK on success
//
//  History:    29-Dec-1997  KyleP      Created.
//
//----------------------------------------------------------------------------

SCODE CCI::FPSToPROPID( CFullPropSpec const & fps, PROPID & pid )
{
    if ( 0 != _pci )
        return _pci->FPSToPROPID( fps, pid );

    AssertOnNotFound(STATUS_NOT_FOUND);
    return(STATUS_NOT_FOUND);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCI::GetFilterProxy
//
//  Synopsis:   Returns the pointer of the filter proxy for use in
//              in-process filtering.
//
//  History:    2-13-97   srikants   Created
//
//----------------------------------------------------------------------------

CiProxy * CCI::GetFilterProxy()
{
    Win4Assert( _pci );
    if ( 0 != _pci )
    {
        return( &(_pci->GetFilterProxy()) );
    }
    else
    {
        return 0;
    }
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
NTSTATUS CCI::ForceMerge( PARTITIONID partid, CI_MERGE_TYPE mt )
{
    if ( _pci )
       return _pci->ForceMerge( partid, mt );

    return(STATUS_NOT_FOUND);
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
NTSTATUS CCI::AbortMerge( PARTITIONID partid )
{
    if ( _pci )
        return _pci->AbortMerge( partid );

    return(STATUS_NOT_FOUND);
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void  CCI::CreatePartition(PARTITIONID partID)
{
    if ( _pci )
        _pci->CreatePartition ( partID );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void  CCI::DestroyPartition(PARTITIONID partID)
{
    if ( _pci )
        _pci->DestroyPartition ( partID );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void  CCI::MergePartitions(PARTITIONID partDest,
                 PARTITIONID partSrc)
{
    if ( _pci )
        _pci->MergePartitions(partDest, partSrc);
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
class CBufScanner
{
public:
    CBufScanner ( int cb, BYTE UNALIGNED * buf )
    {
        _buf = buf;
        _end = &buf[cb];
        _cur = buf;
    }

    ULONG GetUlong()
    {
        ULONG x = 0;
        if (_end - _cur >= sizeof(ULONG))
        {
            x = *((ULONG UNALIGNED *)_cur );
            _cur += sizeof(ULONG);
        }
        return(x);
    }
private:
    BYTE UNALIGNED * _buf;
    BYTE UNALIGNED * _end;
    BYTE UNALIGNED * _cur;
};

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void  CCI::BackDoor ( int cb, BYTE* buf )
{
    ULONG u = 0;

    if ( buf == 0 || cb < sizeof(ULONG) )
    {
        ciDebugOut ((DEB_ITRACE, "BACKDOOR: cb = %d buf = %x\n", cb, buf ));
        return;
    }

    //
    // Is CI mounted?  If not, don't do anything.
    //
    if (0 == _pci)
        THROW(CException(STATUS_NOT_FOUND));

    CBufScanner bufScan ( cb, buf );
    CiCommand cmd = (CiCommand) bufScan.GetUlong();

    switch (cmd)
    {
    case CiQuery:
        break;
    case CiUpdate:
        break;
    case CiDelete:
        break;
    case CiPartCreate:
        break;
    case CiPartDelete:
        break;
    case CiPartMerge:
        break;
    case CiPendingUpdates:
        *((unsigned *)buf) = _pci->CountPendingUpdates();
        break;
    case CiInfoLevel:
#if CIDBG == 1
        u = bufScan.GetUlong();
        ciDebugOut ((DEB_ITRACE, "Info level %lx, new %lx\n", ciInfoLevel, u ));
        ciInfoLevel = u; //bufScan.GetUlong();
#endif // CIDBG == 1
        break;
    case CiDumpIndex:
    {
#if (CIDBG == 1)
        FILE * pf = fopen( (char *) ULongToPtr( bufScan.GetUlong() ), "w" );
        INDEXID iid = (INDEXID)bufScan.GetUlong();
        ULONG fSummaryOnly = bufScan.GetUlong();

        if ( pf && _pci )
        {
            _pci->DumpIndexes( pf, iid, fSummaryOnly );
            fclose( pf );
        }
#endif // CIDBG == 1
    }
        break;
#if CIDBG == 1
    case CiDumpWorkId:
    {
        _pci->DumpWorkId( buf, cb );
        break;
    }
#endif
    default:
        ciDebugOut ((DEB_ERROR, "BACKDOOR: Unknown Command %d\n", cmd ));
        break;
    }
}

#if CIDBG == 1

ULONG CCI::SetInfoLevel ( ULONG level )
{
    ULONG tmp = ciInfoLevel;
    ciInfoLevel = level;
    return tmp;
}

#endif // CIDBG == 1

//+---------------------------------------------------------------------------
//
//  Member:      CCI::KeyToId, public
//
//  Synopsis:    Maps from a key to an id.
//
//  Arguments:   [pkey] -- pointer to the key to be mapped to ULONG
//
//  Returns:     key id - a ULONG
//
//  History:     03-Nov-93   w-Patg      Created.
//
//----------------------------------------------------------------------------
ULONG CCI::KeyToId( CKey const * pkey )
{
    if ( 0 != _pci )
    {
        return _pci->KeyToId( pkey );
    }
    else
        return(kidInvalid);
}

//+---------------------------------------------------------------------------
//
//  Member:      CCI::IdToKey, public
//
//  Synopsis:    Maps from an id to a key.
//
//  Arguments:   [ulKid] -- key id to be mapped to a key
//               [rkey] -- reference to the returned key
//
//  Returns:     void
//
//  History:     03-Nov-93   w-Patg      Created.
//
//----------------------------------------------------------------------------
void CCI::IdToKey( ULONG ulKid, CKey & rkey )
{
    if ( 0 != _pci )
        _pci->IdToKey( ulKid, rkey );
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline void CCI::SetPartition( PARTITIONID PartId )
{
    if ( 0 != _pci )
    {
        _pci->SetPartition( PartId );
    }
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline PARTITIONID CCI::GetPartition() const
{
    if ( 0 != _pci )
    {
        return _pci->GetPartition();
    }
    else
        return( partidInvalid );
}


//+---------------------------------------------------------------------------
//
//  Member:      CCI::Create, public
//
//  Synopsis:    Sets up a new content index.  If there is a partially deleted
//               one, it deletes it if there are no outstanding queries.
//
//  Returns:     [STATUS_SUCCESS] -- a new content index was created
//               [CI_CORRUPT_DATABASE]  -- CI corrupt, rescan required
//               [ERROR_ALREADY_EXISTS] -- catalog already exists
//               [ERROR_BUSY]     -- one or more queries are outstanding on
//                                   the partially deleted content index
//
//  History:     16-Aug-94  DwightKr    Created
//
//----------------------------------------------------------------------------
SCODE CCI::Create( ICiCDocStore * pICiCDocStore,
                   CI_STARTUP_INFO const & startupInfo,
                   CCiFrameworkParams & params,
                   XInterface<CIndexNotificationTable> & xIndexNotifTable )
{
    CLock lock( _mutex );

    if ( (0 != _pci) && (!_pci->IsEmpty()) && (_pci->GetQueryCount() != 0) )
    {
#if CIDBG==1
        if ( 0 != _pci )
            ciDebugOut ((DEB_ERROR, "Can not create a new content index because one already exists\n" ));
        if ( !_pci->IsEmpty() )
            ciDebugOut ((DEB_ERROR, "Can not create a new content index because the current one is not empty\n" ));
        if ( _pci->GetQueryCount() != 0 )
            ciDebugOut ((DEB_ERROR, "Can not create a new content index because query are outstanding on the current index\n" ));
#endif   // CIDBG==1

        return ERROR_ALREADY_EXISTS;
    }


    CContentIndex * pciNew = 0;
    CContentIndex * pciOld = _pci;

    NTSTATUS    status = STATUS_SUCCESS;

    CTransaction xact;

    TRY
    {
        pciNew = new CContentIndex( _storage,
                                    params,
                                    pICiCDocStore,
                                    startupInfo,
                                    _xPropMapper.GetPointer(),
                                    xact,
                                    xIndexNotifTable );
    }
    CATCH( CException, e )
    {
        status = e.GetErrorCode();

        ciDebugOut(( DEB_ERROR, "No content index found\n" ));

        if ( STATUS_NO_MEMORY == e.GetErrorCode() ||
             STATUS_INSUFFICIENT_RESOURCES == e.GetErrorCode() )
        {
            ciDebugOut(( DEB_ERROR, "**** CI Low On Resources **** \n" ));
        }
        else if ( CI_CORRUPT_DATABASE == e.GetErrorCode() ||
                  CI_CORRUPT_CATALOG == e.GetErrorCode()  ||
                  STATUS_NOT_FOUND == e.GetErrorCode() )
        {
            AssertOnNotFound(e.GetErrorCode());
            ciDebugOut(( DEB_ERROR,
                "**** INCONSISTENCY IN CI. NEED COMPLETE RESCAN ****\n"));
            status = CI_CORRUPT_DATABASE;
        }
        else
        {
            ciDebugOut(( DEB_ERROR,
                "**** Error Code 0x%X ****\n", e.GetErrorCode() ));
        }
    }
    END_CATCH

    if ( STATUS_SUCCESS == status )
    {
        xact.Commit();

        //
        //  If there is anyone using the old index, we assume they will be
        //  done with it in 15 seconds.  If they are not, they get an error
        //  telling them the CI disappeared from under them.

        _pci = pciNew;

        if ( pciOld )
        {
            Sleep(15 * 1000);
            delete pciOld;
            pciOld = 0;
        }
    }

    return status;
}


//+---------------------------------------------------------------------------
//
//  Member:      CCI::Empty, public
//
//  Synopsis:    Deletes all persistent structures from the content index.
//
//  History:     16-Aug-94  DwightKr    Created
//
//----------------------------------------------------------------------------
void CCI::Empty()
{
    CLock lock( _mutex );

    if ( 0 != _pci )
    {
        _pci->Empty();
        Win4Assert ( _pci->IsEmpty() );

        if ( _pci->GetQueryCount() == 0 )
        {
            delete _pci;
            _pci = 0;
        }
    }
    else
    {
        ciDebugOut(( DEB_ITRACE, "Disabling CI without CI mounted\n" ));
        _storage.DeleteAllCiFiles();
    }
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
NTSTATUS CCI::MarkCorruptIndex()
{
    if ( _pci )
        return _pci->MarkCorruptIndex();

    return(STATUS_NOT_FOUND);
}

#if 0
//+---------------------------------------------------------------------------
//
//  Member:      CCI::FilterPidRemapper, public
//
//  Synopsis:    Maps a pidMapper into a array of real pids
//
//  Arguments:   [pbBuffer] - serialized pidMap buffer
//               [cbBuffer] - size of the serialized buffer in bytes
//               [aPids] - resulting array of real pids
//               [cPids] - number of valid entries in the pidRemapArray
//
//  Returns:     STATUS_SUCCESS
//               STATUS_BUFFER_TOO_SMALL - pidRemapArray to small
//
//  History:     01-Mar-95  DwightKr    Created
//
//  Note:        The pbBuffer must be used before the aPids is written
//               since they may point to the same address.
//----------------------------------------------------------------------------
NTSTATUS CCI::FilterPidRemapper( BYTE * pbBuffer,
                                 unsigned cbBuffer,
                                 PROPID * aPids,
                                 unsigned & cPids )
{

    if ( 0 == _pci )
        return CI_E_SHUTDOWN;

    CMemDeSerStream pidMapDeSerStream( pbBuffer, cbBuffer );
    CPidMapper   pidMap( pidMapDeSerStream );

    //
    //  We're finished with pbBuffer, it is therefore safe to use aPids
    //

    //
    //  If the output buffer is too small, then return an appropriate error
    //
    if ( cPids < pidMap.Count() )
    {
        cPids = pidMap.Count();
        return STATUS_BUFFER_TOO_SMALL;
    }

    CSimplePidRemapper pidRemap;

    _pci->PidMapToPidRemap( pidMap, pidRemap );

    Win4Assert( pidMap.Count() == pidRemap.GetCount() );
    cPids = pidMap.Count();

    RtlCopyMemory( aPids, pidRemap.GetPropidArray(), cPids * sizeof PROPID );

    return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\compress.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       COMPRESS.CXX
//
//  Contents:   Compressor/Decompressor of data
//
//  Classes:    CCompress, CDecompress
//
//  History:    12-Jun-91   BartoszM    Created
//              20-Jun-91   reviewed
//              07-Aug-91   BartoszM    Introduced Blocks
//              28-May-92   KyleP       Added compression.
//              09-Dec-97   dlee        Added PROPID and LZ compression
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "compress.hxx"

const BYTE pidId2Byte = 0x00; // next 2 bytes is the PROPID
const BYTE pidId4Byte = 0xff; // next 4 bytes is the PROPID

const flagKeyPrefix      = 0x1f;  // mask; 0x1f if prefix len stored later
const flagKeyCompressed  = 0x20;  // 1 == unicode compressed, 0 == not
const flagKeyZeroFirst   = 0x40;  // 1 == compressed & put zeros first
const flagKeyPidContents = 0x80;  // 1 == pidContents, 0 == pid stored

template<class T> BOOL isOdd(T value) { return  0 != (value & 1); }

//+-------------------------------------------------------------------------
//
//  Member:     CBlock::GetFirstKey, public
//
//  Effects:    Stores the first key of the block in [key]
//
//  Arguments:  [key] -- Key buffer to be filled in.
//
//  Requires:   A key must start on this block.
//
//  History:    28-May-92 KyleP     Crated
//
//--------------------------------------------------------------------------

void CBlock::GetFirstKey( CKeyBuf& key )
{
    DeCompress();

    unsigned off = _offFirstKey;
    Win4Assert( off != offInvalid );

    BYTE flags = _pData[off++];

    Win4Assert( 0 == ( flags & flagKeyPrefix ) );

    unsigned cbSuffix = _pData[ off++ ];

    BYTE * pbKey = key.GetWritableBuf();

    if ( 0 != ( flags & flagKeyCompressed ) )
    {
        Win4Assert( 0 != ( flags & flagKeyZeroFirst ) );

        unsigned cbKey = 1 + cbSuffix * 2;
        key.SetCount( cbKey );

        *pbKey++ = STRING_KEY;
        for ( unsigned i = 0; i < cbSuffix; i++ )
        {
            *pbKey++ = 0;
            *pbKey++ = _pData[ off++ ];
        }
    }
    else
    {
        key.SetCount( cbSuffix );
        memcpy( pbKey, _pData + off, cbSuffix );
        off += cbSuffix;
    }

    if ( 0 != ( flags & flagKeyPidContents ) )
    {
        key.SetPid( pidContents );
    }
    else
    {
        BYTE pidInfo = *(_pData+off);
        off++;

        PROPID pid;

        if ( pidId2Byte == pidInfo )
        {
            USHORT usPid;
            LoadUSHORT( _pData + off, usPid );
            pid = usPid ;
        }
        else if ( pidId4Byte == pidInfo )
            LoadULONG( _pData + off, pid );
        else if ( pidInfo > pidIdMaxSmallPid )
            pid = pidInfo - pidIdMaxSmallPid + pidNewPidBase - 1;
        else
            pid = pidInfo;

        Win4Assert( pid != pidAll );

        key.SetPid ( pid );
    }
} //GetFirstKey

// wordlist compression is now good enough that rtl doesn't give us much
// given its cost including the 32k scratch pad and 3% total cpu overhead.

#define CI_COMPRESS_SORT_BLOCKS 0

#if CI_COMPRESS_SORT_BLOCKS

    // prevent multiple simultaneous compressions / decompressions

    CStaticMutexSem g_mtxCompression;
    BYTE g_CompressionWorkspace[ 32784 ]; // don't ask

#endif //CI_COMPRESS_SORT_BLOCKS

//+-------------------------------------------------------------------------
//
//  Function:   DeCompress
//
//  Effects:    Decompresses the buffer
//
//  History:    4-Dec-97 dlee     Crated
//
//--------------------------------------------------------------------------

void CBlock::DeCompress()
{
#if CI_COMPRESS_SORT_BLOCKS

    CLock lock( g_mtxCompression );

    if ( !_fCompressed )
        return;

    //
    // Alpha decompress touches bytes up to a quadword byte boundary
    // beyond what it should.  This is a feature.
    //

    XArray<BYTE> aOut( AlignBlock( _cbInUse, sizeof LONGLONG ) );
    ULONG cbOut = 0;

    NTSTATUS s = RtlDecompressBuffer( COMPRESSION_FORMAT_LZNT1,
                                      aOut.GetPointer(),
                                      (ULONG) _cbInUse,
                                      _pData,
                                      (ULONG) _cbCompressed,
                                      &cbOut );

    if ( NT_ERROR( s ) )
    {
        ciDebugOut(( DEB_WARN, "failed to decompress 0x%x CBlock: 0x%x, cbOut: 0x%x\n",
                     this, s, cbOut ));
        Win4Assert( FALSE );
        THROW( CException( s ) );
    }

    ciDebugOut(( DEB_ITRACE, "decompressed from %d to %d\n",
                 (ULONG) _cbCompressed, (ULONG) _cbInUse ));

    Win4Assert( cbOut == _cbInUse );

    _fCompressed = FALSE;
    delete [] _pData;
    _pData = aOut.Acquire();

#else

    Win4Assert( !_fCompressed  );

#endif
} //DeCompress

//+-------------------------------------------------------------------------
//
//  Function:   Compress
//
//  Effects:    Creates a new, smaller block from an old block
//
//  History:    4-Dec-97 dlee     Crated
//
//--------------------------------------------------------------------------

#if CIDBG == 1

    ULONG g_cbUnCompressedTotal = 0;
    ULONG g_cbUnCompressed = 0;
    ULONG g_cbCompressed = 0;

#endif // CIDBG == 1

void CBlock::Compress()
{
    Win4Assert( !_fCompressed  );

#if CI_COMPRESS_SORT_BLOCKS

    #if CIDBG == 1

        // Assert the workspace is big enough

        ULONG cbWork = 0, cbFragment;

        RtlGetCompressionWorkSpaceSize( COMPRESSION_FORMAT_LZNT1,
                                        &cbWork,
                                        &cbFragment );

        // cbWork is 32784 on current builds

        Win4Assert( cbWork <= sizeof g_CompressionWorkspace );

    #endif // CIDBG == 1

    // Compress the data since it may not be needed for a long time.

    LONGLONG aOut[ cbInitialBlock / sizeof LONGLONG ];
    ULONG cbOut = 0;

    CLock lock( g_mtxCompression );

    NTSTATUS s = RtlCompressBuffer( COMPRESSION_FORMAT_LZNT1,
                                    _pData,
                                    _cbInUse,
                                    (BYTE *) aOut,
                                    sizeof aOut,
                                    cbInitialBlock,
                                    &cbOut,
                                    g_CompressionWorkspace );

    //
    // ignore failures to compress -- leave it uncompressed
    //

    if ( NT_SUCCESS( s ) && ( cbOut < _cbInUse ) )
    {
        BYTE * pNew = new BYTE[ cbOut ];
        RtlCopyMemory( pNew, aOut, cbOut );
        delete [] _pData;
        _pData = pNew;
        Win4Assert( cbOut <= 0xffff );
        _cbCompressed = (USHORT) cbOut;
        _fCompressed = TRUE;

        ciDebugOut(( DEB_ITRACE, "shrink block %d to %d\n",
                     (ULONG) _cbInUse, (ULONG) _cbCompressed ));

        #if CIDBG == 1

            g_cbUnCompressedTotal += cbInitialBlock;
            g_cbUnCompressed += _cbInUse;
            g_cbCompressed += _cbCompressed;

        #endif // CIDBG == 1
    }
    else if ( NT_ERROR( s ) )
    {
        ciDebugOut(( DEB_WARN, "didn't compress: 0x%x\n", s ));
    }

#else

    // Make the buffer as big as it needs to be

    #if CIDBG == 1

        g_cbUnCompressedTotal += cbInitialBlock;
        g_cbUnCompressed += _cbInUse;

    #endif // CIDBG == 1

    XArray<BYTE> aTmp( _cbInUse );

    RtlCopyMemory( aTmp.GetPointer(), _pData, _cbInUse );
    delete [] _pData;
    _pData = aTmp.Acquire();

#endif

    //
    // pitch the memory out of the working set
    //

    VirtualUnlock( _pData, _fCompressed ? _cbCompressed : _cbInUse );
} //Compress

//+-------------------------------------------------------------------------
//
//  Member:     CBlock::CompressList, public
//
//  Effects:    Shrinks blocks in the list, saving memory
//
//  History:    4-Dec-97 dlee     Crated
//
//--------------------------------------------------------------------------

void CBlock::CompressList()
{
    CBlock * pCur = this;

    while ( 0 != pCur )
    {
        pCur->Compress();
        pCur = pCur->_pNext;
    }
} //CompressList

//+---------------------------------------------------------------------------
//
// Member:      CCompress::CCompress, public
//
// Synopsis:    initialize data
//
// Arguments:   [fMultipleWid] -- TRUE if > 1 WorkId will be stored.
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       One step construction.
//
//----------------------------------------------------------------------------

CCompress::CCompress ()
: _cKeyBlock( 0 ),
  _widCount( 0 ),
  _occCount( 0 ),
  _pWidCount( 0 ),
  _pOccCount( 0 )
{
    _block = new CBlock;
    _buf   = _block->Buffer();
    _cur   = _buf;

    _lastKey.SetCount( 0 );             // No prefix from previous key.
}

//+---------------------------------------------------------------------------
//
// Member:      CCompress::GetFirstBlock, public
//
// Synopsis:    stores first entry and initializes cursors
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

CBlock * CCompress::GetFirstBlock()
{
    return _block;
}

//+---------------------------------------------------------------------------
//
// Member:      CCompress::~CCompress, public
//
// Synopsis:    write last wid and occ counts
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Restructured. Added compression.
//
//----------------------------------------------------------------------------

CCompress::~CCompress()
{
    IPutOccCount();
    IPutWidCount();

    _block->_cbInUse = (USHORT)(_cur - _buf);
}

//+---------------------------------------------------------------------------
//
// Member:      CCompress::PutKey, public
//
// Synopsis:    store compressed key
//
// Arguments:   [cb] - size of key
//              [buf] - key buffer
//              [pid] - property id
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Restructured. Added compression.
//
//----------------------------------------------------------------------------

void CCompress::PutKey ( unsigned cb, const BYTE* buf, PROPID pid )
{
    ciAssert ( cb != 0 );

    IPutWidCount();
    IPutKey( cb, buf, pid );
    IAllocWidCount();
}

//+---------------------------------------------------------------------------
//
// Member:      CCompress::PutWid, public
//
// Synopsis:    store compressed work id
//
// Arguments:   [wid] - work id
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Restructured. Added compression.
//
//----------------------------------------------------------------------------

void CCompress::PutWid ( WORKID wid )
{
    ciAssert( wid > 0 && wid < 256 ); // Has to fit in a byte
    ciAssert( _widCount < 255 );      // Has to fit in a byte

    IPutOccCount();
    IPutWid( wid );
    IAllocOccCount();
}

//+---------------------------------------------------------------------------
//
// Member:      CCompress::PutOcc, public
//
// Synopsis:    store compressed occurrence
//
// Arguments:   [occ] - occurrence
//
// History:     12-Jun-91   BartoszM    Created
//              20-May-92   KyleP       Occurrence compression
//              28-May-92   KyleP       Restructured. Added compression.
//
//----------------------------------------------------------------------------

void CCompress::PutOcc ( OCCURRENCE occ )
{
    IPutOcc( occ );
}

//+---------------------------------------------------------------------------
//
// Member:      CCompress::AllocNewBlock, private
//
// Synopsis:    Allocate and link in new block
//
// History:     07-Aug-91   BartoszM    Created
//
//----------------------------------------------------------------------------

void CCompress::AllocNewBlock ()
{
    // ciDebugOut (( DEB_ITRACE, "Compress:: Alloc new block\n" ));
    _block->_cbInUse = (USHORT)(_cur - _buf);
    _block->_pNext = new CBlock;
    _block = _block->_pNext;
    _buf   = _block->_pData;
    _cur   = _buf;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCompress::IPutWidCount, private
//
//  Synopsis:   Backpatches the workid count.
//
//  History:    28-May-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CCompress::IPutWidCount()
{
    if ( _pWidCount )
        *_pWidCount = (BYTE)_widCount;

    _widCount = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCompress::IPutKey, private
//
//  Synopsis:   Stores a key.
//
//  Arguments:  [cb]  -- Count in bytes of [buf]
//              [buf] -- Key.
//              [pid] -- Property ID.
//
//  History:    28-May-92 KyleP     Created
//
//  Notes:      Format for a key is:
//                 1 BYTE  -- flags, prefix byte count if < 0xf
//                 1 BYTE  -- # bytes prefix (from previous key) (optional)
//                 1 BYTE  -- # bytes suffix (from this key)
//                 n BYTE  -- The suffix (possibly Unicode compressed)
//                 1-5 bytes -- Property Id. (if not pidContents)
//
//--------------------------------------------------------------------------

void CCompress::IPutKey( unsigned cb, BYTE const * buf, PROPID pid )
{
    //
    // Calculate the common prefix from the previous key.
    //

    UINT mincb = __min( _lastKey.Count(), cb );

    UINT cPrefix;

    for ( cPrefix = 0;
          (cPrefix < mincb) &&
          ((_lastKey.GetBuf())[cPrefix] == buf[cPrefix]);
          cPrefix++)
        continue;

    UINT cSuffix = cb - cPrefix;

    memcpy( _lastKey.GetWritableBuf() + cPrefix, buf + cPrefix, cSuffix );
    _lastKey.SetCount( cb );
    _lastKey.SetPid( pid );

    //
    // Out of space?
    //

    if ( !KeyWillFit ( cSuffix ) )
        AllocNewBlock();

    if ( _block->_offFirstKey == offInvalid )
    {
        BackPatch ( (unsigned)(_cur - _buf) );
        cPrefix = 0;
        cSuffix = cb;
    }

    // See if the prefix length can be stored in the flag byte

    BYTE flags = ( cPrefix < flagKeyPrefix ) ? cPrefix : flagKeyPrefix;

    // pidContents is stored as a bit flag

    if ( pidContents == pid )
        flags |= flagKeyPidContents;

    // Check if the key can be Unicode compressed.

    BOOL fCompressible = FALSE;
    BYTE abCompressed[ MAXKEYSIZE / 2 ];
    unsigned cbCompressed = 0;

    if ( STRING_KEY == *buf )
    {
        Win4Assert( isOdd( cPrefix ) != isOdd( cSuffix ) );

        BYTE const * pbCompressCheck = buf;
        unsigned cSuffixTmp = cSuffix;

        if ( 0 == cPrefix )
        {
            pbCompressCheck++;
            cSuffixTmp--;
        }
        else
        {
            pbCompressCheck += cPrefix;
        }

        BYTE const * pbCheck = pbCompressCheck;
        BYTE const * pbAfter = buf + cb;
        fCompressible = TRUE;

        if ( isOdd( cSuffixTmp ) )
        {
            while ( pbCheck < pbAfter )
            {
                abCompressed[ cbCompressed++ ] = *pbCheck++;

                if ( pbCheck < pbAfter )
                {
                    if ( 0 != *pbCheck )
                    {
                        fCompressible = FALSE;
                        break;
                    }
                    else
                        pbCheck++;
                }
            }
        }
        else
        {
            while ( pbCheck < pbAfter )
            {
                if ( 0 != *pbCheck )
                {
                    fCompressible = FALSE;
                    break;
                }

                abCompressed[ cbCompressed++ ] = * ( pbCheck + 1 );
                pbCheck += 2;
            }

            if ( fCompressible )
                flags |= flagKeyZeroFirst;
        }

        if ( fCompressible )
            flags |= flagKeyCompressed;
    }

    // Store the flags

    *_cur++ = flags;

    // Store the prefix length if it didn't fit in the flags field

    if ( cPrefix >= flagKeyPrefix )
        *_cur++ = (BYTE) cPrefix;

    //
    // Store the key.
    //

    if ( fCompressible )
    {
        *_cur++ = (BYTE) cbCompressed;
        memcpy( _cur, abCompressed, cbCompressed );
        _cur += cbCompressed;
    }
    else
    {
        *_cur++ = (BYTE) cSuffix;
        memcpy( _cur, buf + cPrefix, cSuffix );
        _cur += cSuffix;
    }

    //
    // store the pid in 1, 3, or 5 bytes
    // note: pids 0 and 0xff are reserved as markers
    //
    // pids 1 - 0x40 are stored as is in 1 byte
    // pids 0x1000 to 0x10bd are stored as 1 byte 0x41 to 0xfe
    // other pids < 0x10000 are stored as pidID2Byte followed by 2 bytes
    // pids >= 0x10000 are stored as pidID4Byte followed by 4 bytes
    //

    Win4Assert( pidAll != pid );

    if ( pidContents != pid )
    {
        if ( pid <= pidIdMaxSmallPid )
        {
            *_cur++ = (BYTE) pid;
        }
        else if ( ( pid >= pidNewPidBase ) &&
                  ( pid < ( pidNewPidBase + 0xfd - pidIdMaxSmallPid ) ) )
        {
            *_cur++ = (BYTE) ( pid - pidNewPidBase + pidIdMaxSmallPid + 1 );
        }
        else if ( pid < 0x10000 )
        {
            // 1 byte id plus 2 bytes of pid

            *_cur++ = pidId2Byte;
            _cur += StoreUSHORT( _cur, (USHORT) pid );
        }
        else
        {
            // 1 byte id plus 4 bytes of pid

            *_cur++ = pidId4Byte;
            _cur += StoreULONG( _cur, pid );
        }
    }
} //IPutKey

//+-------------------------------------------------------------------------
//
//  Member:     CCompress::IAllocWidCount, private
//
//  Synopsis:   Allocates space for WorkId count.
//
//  History:    28-May-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CCompress::IAllocWidCount()
{
    //
    // space for wid count
    // Note: the actual BYTE space has been pre-reserved in PutKey -- there
    // is room for the wid, so we don't have to check and AllocNewBlock.
    //

    Win4Assert( WidWillFit() );

    _pWidCount = _cur;
    _cur++;
    _lastWid = widInvalid;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCompress::IPutWid, private
//
//  Synopsis:   Stores a WorkId
//
//  Arguments:  [wid] -- WorkId
//
//  History:    28-May-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CCompress::IPutWid( WORKID wid )
{
    _widCount++;

    if ( ! WidAndOccCountWillFit() )
        AllocNewBlock();

    _lastWid  = wid;
    *_cur = BYTE( wid );
    _cur++;
}

//+---------------------------------------------------------------------------
//
// Member:      CCompress::IPutOccCount, public
//
// Synopsis:    Write previous occurrence count and allocate new one.
//
// History:     20-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

void CCompress::IPutOccCount()
{
    //
    // Write previous occurence count
    //

    if ( _pOccCount )
        StoreUINT( _pOccCount, _occCount );

    _occCount = 0;
    _lastOcc  = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CCompress::IAllocOccCount, private
//
//  Synopsis:   Allocates space for occurrence count.
//
//  History:    28-May-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CCompress::IAllocOccCount()
{
    //
    // Allocate space for new occ count.  Note that for the many-wid
    // compressor this has been pre-reserved and will succeed.
    //

    if ( ! OccCountWillFit() )
        AllocNewBlock();

    _pOccCount = _cur;
    _cur += sizeof (unsigned);
}

//+-------------------------------------------------------------------------
//
//  Member:     CCompress::IPutOcc, private
//
//  Synopsis:   Stores an occurrence delta
//
//  Arguments:  [occ] -- Occurrence
//
//  History:    28-May-92 KyleP     Created
//
//  Notes:      Format for an occurrence delta is:
//
//                 delta <= 255   --  Store as BYTE
//                 delta <= 65535 --  Store as 0 BYTE + 2 BYTES
//                 delta >  65535 --  Store as 3 0 BYTES + 4 BYTES
//
//--------------------------------------------------------------------------

void CCompress::IPutOcc( OCCURRENCE occ )
{
    _occCount++;
    OCCURRENCE occDelta = occ - _lastOcc;
    _lastOcc = occ;

    ciAssert( occDelta != 0 );

    if ( !OccWillFit( occDelta ) )
        AllocNewBlock();

    if ( occDelta <= (1 << 8) - 1 )
    {
        *_cur = BYTE( occDelta );
        _cur++;
    }
    else if ( occDelta <= (1 << 16) - 1 )
    {
        ciAssert( sizeof( USHORT ) == 2 );
        *_cur++ = 0;
        _cur += StoreUSHORT( _cur, (USHORT)occDelta );
    }
    else
    {
        ciAssert( sizeof( ULONG ) == 4 );

        *_cur++ = 0;
        _cur += StoreUSHORT( _cur, 0 );
        _cur += StoreULONG( _cur, occDelta );
    }
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidCompress::PutKey, public
//
// Synopsis:    store compressed key
//
// Arguments:   [cb] - size of key
//              [buf] - key buffer
//              [pid] - property id
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

void COneWidCompress::PutKey ( unsigned cb, const BYTE* buf, PROPID pid )
{
    ciAssert ( cb != 0 );

    IPutOccCount();
    IPutKey( cb, buf, pid );
    IAllocOccCount();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidCompress::PutWid, public
//
// Synopsis:    store compressed work id
//
// Arguments:   [wid] - work id
//
// History:     28-May-92   KyleP       Created
//
// Notes:       Storing a work id is an illegal operation for the one
//              wid compressor.  This method can actually disappear in
//              the retail version.
//
//----------------------------------------------------------------------------

#if CIDBG == 1

void COneWidCompress::PutWid ( WORKID )
{
    ciAssert( FALSE );
}

#endif // CIDBG == 1

//+---------------------------------------------------------------------------
//
// Member:      COneWidCompress::PutOcc, public
//
// Synopsis:    store compressed occurrence
//
// Arguments:   [occ] - occurrence
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

void COneWidCompress::PutOcc ( OCCURRENCE occ )
{
    IPutOcc( occ );
}

//+-------------------------------------------------------------------------
//
//  Member:     CDecompress::Init, public
//
//  Synopsis:   Initialize decompressor.
//
//  Effects:    Loads the first Key, WorkId, etc. in the block.
//
//  Arguments:  [block] -- Block to decompress.
//
//  Requires:   A key must start in [block].
//
//  History:    28-May-92 KyleP     Created
//
//  Notes:      CDecompress needs a two stage construction because we
//              don't know at cursor creation time what block will be
//              decompressed yet we want the decompressor inside the
//              cursor (e.g. no pointer)
//
//--------------------------------------------------------------------------

void CDecompress::Init ( CBlock* block )
{
    block->DeCompress();

    _block = block;
    _buf = _block->_pData;
    _cbInUse = _block->_cbInUse;
    ciAssert ( _block->_offFirstKey != offInvalid );

    _cur = _buf + _block->_offFirstKey;

    LoadKey();
    LoadWidCount();
    LoadWid();
    LoadOccCount();
    LoadOcc();
}

//+---------------------------------------------------------------------------
//
// Member:      CDecompress::GetNextKey, public
//
// Synopsis:    Advance to next key, cache it, and return it
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Added compression. Restructured.
//
//----------------------------------------------------------------------------

const CKeyBuf* CDecompress::GetNextKey()
{
    if ( !KeyExists() )
        return 0;

    //
    // skip remaining work id's
    //

    while ( NextWorkId() != widInvalid )
        continue;     // Null body

    LoadKey();

    if ( KeyExists() )
    {
        LoadWidCount();
        LoadWid();
        LoadOccCount();
        LoadOcc();
    }

    return GetKey();
}

//+---------------------------------------------------------------------------
//
// Member:      CDecompress::NextWorkId, public
//
// Synopsis:    Advance to next work id, cache it, and return it
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Added compression. Restructured.
//
//----------------------------------------------------------------------------

WORKID CDecompress::NextWorkId()
{
    ciAssert ( KeyExists() );

    //
    // Skip the remaining occurrences
    //

    while ( NextOccurrence() != OCC_INVALID ); // Null body

    if ( _widCountLeft == 0 )
    {
        _curWid = widInvalid;
        _curOcc = OCC_INVALID;
    }
    else
    {
        LoadWid();
        LoadOccCount();
        LoadOcc();
    }

    return _curWid;
}

void CDecompress::RatioFinished (ULONG& denom, ULONG& num)
{
    denom = _widCount;
    Win4Assert ( _widCount >= _widCountLeft );
    num = _widCount - _widCountLeft;
}


//+---------------------------------------------------------------------------
//
// Member:      CDecompress::NextOccurrence, public
//
// Synopsis:    Advance to next occurrence, return it
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Added compression. Restructured.
//
//----------------------------------------------------------------------------

OCCURRENCE CDecompress::NextOccurrence()
{
    ciAssert ( KeyExists() );

    if ( _occCountLeft == 0 )
        _curOcc = OCC_INVALID;
    else
        LoadOcc();

    return _curOcc;
}

//+---------------------------------------------------------------------------
//
// Member:      CDecompress::LoadNextBlock, private
//
// Synopsis:    Follow link to next block
//
// History:     07-Aug-91   BartoszM    Created
//
//----------------------------------------------------------------------------

BOOL CDecompress::LoadNextBlock ()
{
    //
    // don't recompress _block here -- other queries or merges may be
    // using the block, and there is no refcount.
    //

    if ( _block->_pNext == 0 )
    {
        _curKey.SetCount(0);
        return FALSE;
    }

    _block = _block->_pNext;

    _block->DeCompress();

    _buf = _block->_pData;
    _cbInUse = _block->_cbInUse;
    _cur = _buf;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Member:      CDecompress::LoadKey, private
//
// Synopsis:    Cache key wid and occurrence under cursor
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Added compression. Restructured.
//
// Notes:       End of block can be either before the beginning
//              of the key or after wid count.
//
//----------------------------------------------------------------------------
void CDecompress::LoadKey()
{
    if ( EndBlock() && !LoadNextBlock() )
        return;

    BYTE flags = *_cur++;

    UINT cPrefix = ( flagKeyPrefix & flags );
    if ( flagKeyPrefix == cPrefix )
        cPrefix = *_cur++;

    UINT cSuffix = *_cur++;
    BYTE * pbKey = _curKey.GetWritableBuf() + cPrefix;
    UINT cbKey = cPrefix;

    if ( 0 != ( flagKeyCompressed & flags ) )
    {
        cbKey += cSuffix * 2;

        if ( 0 == cPrefix )
        {
            cbKey++;
            *pbKey++ = STRING_KEY;
        }

        BOOL fZeroFirst = ( 0 != ( flags & flagKeyZeroFirst ) );

        if ( !fZeroFirst )
        {
            *pbKey++ = *_cur++;
            cbKey--;
            cSuffix--;
        }

        Win4Assert( isOdd( cbKey ) );

        for ( unsigned i = 0; i < cSuffix; i++ )
        {
            *pbKey++ = 0;
            *pbKey++ = *_cur++;
        }

    }
    else
    {
        memcpy( pbKey, _cur, cSuffix );
        _cur += cSuffix;
        cbKey += cSuffix;
    }

    _curKey.SetCount( cbKey );

    if ( 0 != ( flags & flagKeyPidContents ) )
    {
        _curKey.SetPid( pidContents );
    }
    else
    {
        BYTE pidInfo = *_cur++;

        PROPID pid;

        if ( pidId2Byte == pidInfo )
        {
            USHORT usPid;
            _cur += LoadUSHORT( _cur, usPid );
            pid = usPid;
        }
        else if ( pidId4Byte == pidInfo )
            _cur += LoadULONG( _cur, pid );
        else if ( pidInfo > pidIdMaxSmallPid )
            pid = pidInfo - pidIdMaxSmallPid + pidNewPidBase - 1;
        else
            pid = pidInfo;

        Win4Assert( pid != pidAll );

        _curKey.SetPid( pid );
    }
} //LoadKey

//+-------------------------------------------------------------------------
//
//  Member:     CDecompress::LoadWidCount, private
//
//  Synopsis:   Loads workid count.
//
//  History:    28-May-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CDecompress::LoadWidCount()
{
    if ( EndBlock() )
        LoadNextBlock();

    _widCount = *_cur;
    _widCountLeft = _widCount;
    _cur++;
}

//+---------------------------------------------------------------------------
//
// Member:      CDecompress::LoadWid, private
//
// Synopsis:    Cache work id and occurrence under cursor
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Added compression. Restructured.
//
//----------------------------------------------------------------------------

void CDecompress::LoadWid ()
{
    if ( EndBlock() )
        LoadNextBlock();

    ciAssert ( KeyExists() );

    _curWid = *_cur;
    _cur++;
    _widCountLeft--;
}

//+---------------------------------------------------------------------------
//
// Member:      CDeCompress::LoadOccCount, private
//
// Synopsis:    Cache occurrence count under cursor
//
// History:     21-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

void CDecompress::LoadOccCount()
{
    if ( EndBlock() )
        LoadNextBlock();

    ciAssert ( KeyExists() );

    _cur += LoadUINT( _cur, _occCount );

    _occCountLeft = _occCount;
    _curOcc = 0;
}

//+---------------------------------------------------------------------------
//
// Member:      CDeCompress::LoadOcc, private
//
// Synopsis:    Cache occurrence under cursor
//
// Requires:    valid occurrence under the cursor
//
// History:     12-Jun-91   BartoszM    Created
//              28-May-92   KyleP       Added compression. Restructured.
//
//----------------------------------------------------------------------------

void CDecompress::LoadOcc()
{
    if ( EndBlock() )
        LoadNextBlock();

    ciAssert ( KeyExists() );

    OCCURRENCE occDelta;

    occDelta = *_cur++;

    if ( occDelta == 0 )
    {
        _cur += LoadUSHORT( _cur, (USHORT &)occDelta );

        if ( occDelta == 0 )
        {
            _cur += LoadULONG( _cur, occDelta );
        }
    }

    _curOcc += occDelta;
    _occCountLeft--;
}

//+-------------------------------------------------------------------------
//
//  Member:     COneWidDecompress::Init, public
//
//  Synopsis:   Initialize decompressor.
//
//  Effects:    Loads the first Key, Occurrence, etc. in the block.
//
//  Arguments:  [block] -- Block to decompress.
//
//  Requires:   A key must start in [block].
//
//  History:    28-May-92 KyleP     Created
//
//  Notes:      CDecompress needs a two stage construction because we
//              don't know at cursor creation time what block will be
//              decompressed yet we want the decompressor inside the
//              cursor (e.g. no pointer)
//
//--------------------------------------------------------------------------

void COneWidDecompress::Init ( CBlock* block )
{
    block->DeCompress();

    _block = block;
    _buf = _block->_pData;
    _cbInUse = _block->_cbInUse;
    ciAssert ( _block->_offFirstKey != offInvalid );

    _cur = _buf + _block->_offFirstKey;

    LoadKey();
    LoadOccCount();
    LoadOcc();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidDecompress::GetNextKey, public
//
// Synopsis:    Advance to next key, cache it, and return it
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

const CKeyBuf* COneWidDecompress::GetNextKey()
{
    if ( !KeyExists() )
        return 0;

    //
    // skip remaining occurrences
    //

    while ( NextOccurrence() != OCC_INVALID );     // Null body

    LoadKey();

    if ( KeyExists() )
    {
        LoadOccCount();
        LoadOcc();
    }

    return GetKey();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidDecompress::NextWorkId, public
//
// Synopsis:    Advance to next work id, cache it, and return it
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

WORKID COneWidDecompress::NextWorkId()
{
    ciAssert( FALSE );

    return( widInvalid );
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidDecompress::NextOccurrence, public
//
// Synopsis:    Advance to next occurrence, return it
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

OCCURRENCE COneWidDecompress::NextOccurrence()
{
    ciAssert ( KeyExists() );

    if ( _occCountLeft == 0 )
        _curOcc = OCC_INVALID;
    else
        LoadOcc ();

    return _curOcc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\changes.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       CHANGES.CXX
//
//  Contents:   Table of changes
//
//  Classes:    CChange CPartQueue
//
//  History:    29-Mar-91       BartoszM        Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <glbconst.hxx>

#include "indxact.hxx"
#include "changes.hxx"

#define CI_PRIORITY_INVALID CI_PRIORITIES

//+---------------------------------------------------------------------------
//
//  Member:     CChange::CChange, public
//
//  Arguments:  [storage] -- physical storage
//
//  History:    29-Mar-91       BartoszM        Created
//
//----------------------------------------------------------------------------

CChange::CChange (
    WORKID wid,
    PStorage& storage,
    CCiFrameworkParams & frmwrkParams ) :
    _frmwrkParams( frmwrkParams ),
    _queue( wid, storage, PStorage::ePrimChangeLog, frmwrkParams ),
    _secQueue( wid, storage, PStorage::eSecChangeLog, frmwrkParams )
{

    Win4Assert( sizeof(FILETIME) == sizeof(LONGLONG) );
    GetSystemTimeAsFileTime( (FILETIME *) &_ftLast );
}


//+---------------------------------------------------------------------------
//
//  Member:     CChange::LokEmpty, public
//
//  Synopsis:   Initializes changes object so it looks new/empty
//
//  Notes:      ResMan LOCKED
//
//  History:    15-Nov-94   DwightKr    Created
//
//----------------------------------------------------------------------------

void CChange::LokEmpty()
{
    _queue.LokEmpty();

    _secQueue.LokEmpty();
}


//+---------------------------------------------------------------------------
//
//  Member:     CChange::LokCompact, public
//
//  Synopsis:   Frees memory not currently in use.
//
//  Notes:      ResMan LOCKED
//
//  History:    19-May-92       BartoszM        Created
//
//----------------------------------------------------------------------------

void CChange::LokCompact()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CChange::LokGetPendingUpdates
//
//  Synopsis:   Like QueryPendingUpdates, but doesn't remove documents from
//              queue, and doesn't require a transaction (no deserialization).
//
//  Arguments:  [aWid] -- Workids returned here.
//              [cWid] -- INPUT:  Maximum number of entries to fetch.
//                        OUTPUT: Number of entries fetched.
//
//  Returns:    TRUE if all change entries were processed.
//
//  History:    15-Nov-94        KyleP           Created
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

BOOL CChange::LokGetPendingUpdates( WORKID * aWid, unsigned & cWid )
{
    if ( _queue.IsEmpty() && _secQueue.IsEmpty() )
    {
        cWid = 0;
        return TRUE;
    }
    else
    {
        const unsigned cMax = cWid;

        unsigned cPrim = 0; // count of wids from primary
        unsigned cSec = 0;  // count of wids from secondary

        BOOL fSuccess = TRUE;

        if ( !_queue.IsEmpty() )
        {
            cPrim = cMax;
            fSuccess = _queue.Get(aWid, cPrim);
        }

        if ( fSuccess && !_secQueue.IsEmpty() )
        {
            Win4Assert( cPrim <= cMax );
            cSec = cMax-cPrim;
            fSuccess = _secQueue.Get( aWid+cPrim, cSec );
        }

        Win4Assert( cPrim + cSec <= cMax );
        cWid = cPrim+cSec;
        return fSuccess;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChange::LokQueryPendingUpdates
//
//  Synopsis:   Checks update queues, returns list of documents
//
//  Arguments:  [xact] -- transaction
//              [maxDocs] -- maximum # of updates acceptable
//              [docList] -- (returned) list of documents,
//                        initially empty.
//
//  Returns:    An array of document descriptors (or NULL)
//
//  History:    25-Sept-91       BartoszM        Created
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CChange::LokQueryPendingUpdates (
    CChangeTrans & xact,
    unsigned maxDocs,
    CDocList& docList )
{
    ciDebugOut (( DEB_ITRACE, "Query Pending Updates\n" ));

    if ( !_queue.IsEmpty() )
    {
        _queue.Extract( xact, maxDocs, docList );
    }
    else
    {
        docList.LokSetCount(0);
        return;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChange::LokDone, public
//
//  Synopsis:   After creating a volatile index marks
//              entries in table done. Stores actual index id.
//
//  Arguments:  [xact] -- transaction
//              [iid]  -- index id
//              [docList] -- array of document descriptors
//
//  History:    26-Apr-91       BartoszM        Created
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CChange::LokDone ( CChangeTrans & xact, INDEXID iid, CDocList& docList )
{
    ciDebugOut (( DEB_ITRACE, "Changes: Done\n" ));
    int cDoc = docList.Count();

    //
    // Look for PENDING or PREEMPTED documents, which must be reindexed.
    //
    for ( int i = 0; i < cDoc; i++ )
    {
        STATUS status = docList.Status(i);
        if ( status == PREEMPTED || status == PENDING )
        {
            _queue.Append( xact,
                           docList.Wid(i),
                           docList.Usn(i),
                           docList.VolumeId(i),
                           CI_UPDATE_OBJ,
                           docList.Retries(i),
                           docList.SecQRetries(i)
                         );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChange::LokRemoveIndexes, public
//
//  Synopsis:   Remove entries from the table after volatile indexes
//              have been merged away.
//
//  Arguments:  [cIndexes] -- count of index ids
//              [aIndexIds] -- array of index ids
//
//  History:    26-Apr-91       BartoszM        Created
//              14-May-91       BartoszM        Implemented
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CChange::LokRemoveIndexes (
    CTransaction& xact,
    unsigned cIndexes,
    INDEXID aIndexIds[] )
{
    ciDebugOut (( DEB_ITRACE, "Changes: Remove Indexes\n" ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CChange::LokAddToSecQueue
//
//  Synopsis:   Adds the document to the secondary change queue.
//
//  Arguments:  [xact]         -- Change transaction
//              [wid]          -- Workid
//              [volumeId]     -- Volume id
//              [cSecQRetries] -- Sec Q Retry Count
//
//  History:    5-08-96   srikants   Created
//
//----------------------------------------------------------------------------

void CChange::LokAddToSecQueue( CChangeTrans & xact, WORKID wid, VOLUMEID volumeId, ULONG cSecQRetries )
{
    USN usn = 0;
    ULONG action = CI_UPDATE_OBJ;

    ciDebugOut(( DEB_TRACE,
                 "Refiling wid %d (0x%X) to secondary queue\n", wid, wid ));

    SCODE sc = _secQueue.Append( xact,
                                 wid,
                                 usn,
                                 volumeId,
                                 action,
                                 1,          // retries (reset for sharing viol)
                                 cSecQRetries
                               );

    if ( S_OK != sc )
    {
        ciDebugOut(( DEB_ERROR, "LokAddToSecQueue returned 0x%X\n", sc ));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChange::LokRefileSecQueue
//
//  Synopsis:   Moves items from seconday queue to primary queue
//
//  Arguments:  [xact] - Change transaction
//
//  History:    5-08-96   srikants   Created
//
//----------------------------------------------------------------------------

void CChange::LokRefileSecQueue( CChangeTrans & xact )
{

    // convert the retry interval from minutes into 100s of nano seconds
    const LONGLONG eXferInterval =
        _frmwrkParams.GetFilterRetryInterval() * 60 * 1000 * 10000;

    LONGLONG  ftNow;
    GetSystemTimeAsFileTime( (FILETIME *) &ftNow );

    LONGLONG llDelta = ftNow - _ftLast;

    if ( llDelta > 0 && !_secQueue.IsEmpty() )
    {
        if ( llDelta < eXferInterval )
            return;

        CDocList    docList;

        while ( !_secQueue.IsEmpty() )
        {

            docList.LokClear();

            _secQueue.Extract( xact, CI_MAX_DOCS_IN_WORDLIST, docList );

            for ( unsigned i = 0; i < docList.Count(); i++ )
            {
                ciDebugOut(( DEB_TRACE,
                    "Transferring wid %d (0x%X) from secondary to primary queue\n",
                             docList.Wid(i),
                             docList.Wid(i) ));

                _queue.Append ( xact,
                                docList.Wid(i),
                                docList.Usn(i),
                                docList.VolumeId(i),
                                CI_UPDATE_OBJ,
                                docList.Retries(i),
                                docList.SecQRetries(i) );
            }
        }
        _secQueue.LokEmpty();
    }

    _ftLast = ftNow;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\changlog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       CHANGLOG.CXX
//
//  Contents:   Methods to make DocQueue persistent
//
//  Classes:    CDocQueue
//
//  History:    08-Feb-91   DwightKr    Created
//              24-Feb-97   SitaramR    Push filtering
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rcstxact.hxx>
#include <rcstrmit.hxx>
#include <pstore.hxx>
#include <pfilter.hxx>
#include <cifailte.hxx>
#include <imprsnat.hxx>

#include "changlog.hxx"
#include "fresh.hxx"
#include "resman.hxx"
#include "notxact.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   CDocChunk::UpdateMaxUsn
//
//  Synopsis:   Updates the max usn flushed info
//
//  Arguments:  [aUsnFlushInfo] -- Array of usn info to be updated
//
//  History:    05-07-97     SitaramR   Created
//
//----------------------------------------------------------------------------

void CDocChunk::UpdateMaxUsn( CCountedDynArray<CUsnFlushInfo> & aUsnFlushInfo )
{
   for ( unsigned i=0;
         i<cDocInChunk && _aNotify[i].Wid() != widInvalid;
         i++ )
   {
      USN usn = _aNotify[i].Usn();
      VOLUMEID volumeId = _aNotify[i].VolumeId();
      if ( volumeId != CI_VOLID_USN_NOT_ENABLED && usn != 0 )
      {
         //
         // Usn flush info is needed only for ntfs 5 volumes that have a
         // non-default volume id. Also, a usn of 0 indicates a refiled
         // document and so it need not be processed.
         //

         BOOL fFound = FALSE;
         for ( unsigned j=0; j<aUsnFlushInfo.Count(); j++ )
         {
            if ( aUsnFlushInfo[j]->VolumeId() == volumeId )
            {
                //
                // Usn's need not be monotonic because there can be notifications from
                // different scopes on same usn volume
                //
                if ( usn > aUsnFlushInfo[j]->UsnHighest() )
                    aUsnFlushInfo[j]->SetUsnHighest( usn );

                fFound = TRUE;
            }
         }

         if ( !fFound )
         {
            CUsnFlushInfo *pUsnInfo = new CUsnFlushInfo( volumeId, usn );
            XPtr<CUsnFlushInfo> xUsnInfo( pUsnInfo );
            aUsnFlushInfo.Add( pUsnInfo, aUsnFlushInfo.Count() );
            xUsnInfo.Acquire();
         }
      }
   }
}


//+---------------------------------------------------------------------------
//
//  Function:   AcquireAndAppend
//
//  Synopsis:   Acquire the chunks from the given "newList" and append these
//              chunks to the current list.
//
//  Arguments:  [newList] -- List to acquire from.
//
//  History:    5-26-94   srikants   Created
//
//  Notes:      The newList will be emptied.
//
//----------------------------------------------------------------------------

void CChunkList::AcquireAndAppend( CChunkList & newList )
{
    while ( !newList.IsEmpty() )
    {
        CDocChunk * pChunk = newList.Pop();
        Win4Assert( pChunk );
        Append( pChunk );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   Constructor
//
//  Synopsis:   Constructs the CChangeLog class by figuring out the number of
//              chunks present in the change log.
//
//  Arguments:  [widChangeLog] -- Workid of changlog
//              [storage]      -- Storage
//              [type]         -- Primary or secondary changlog type
//
//  History:    5-26-94   srikants   Created
//              2-24-97   SitaramR   Push filtering
//
//----------------------------------------------------------------------------

CChangeLog::CChangeLog( WORKID widChangeLog,
                        PStorage & storage,
                        PStorage::EChangeLogType type )
    : _sigChangeLog(eSigChangeLog),
      _pResManager( 0 ),
      _widChangeLog(widChangeLog),
      _storage(storage),
      _type(type),
      _PersDocQueue(_storage.QueryChangeLog(_widChangeLog,type)),
      _oChunkToRead(0),
      _cChunksAvail(0),
      _cChunksTotal(0),
      _fUpdatesEnabled( FALSE ),
      _fPushFiltering( FALSE )
{
    Win4Assert( IsPrimary() || IsSecondary() );
}

//+---------------------------------------------------------------------------
//
//  Function:   Destructor
//
//  History:    8-Nov-94    DwightKr    Created
//
//----------------------------------------------------------------------------
CChangeLog::~CChangeLog()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   LokVerifyConsistency
//
//  History:    12-15-94   srikants   Created
//
//----------------------------------------------------------------------------

#if CIDBG==1

void CChangeLog::LokVerifyConsistency()
{


    PRcovStorageObj & persDocQueue = *_PersDocQueue;
    CRcovStorageHdr & hdr = persDocQueue.GetHeader();
    Win4Assert( _cChunksAvail + _oChunkToRead == _cChunksTotal );

    ULONG ulDataSize = hdr.GetUserDataSize( hdr.GetPrimary() );
    ULONG cTotPrim = ulDataSize / (sizeof(CDocNotification) * cDocInChunk + CRcovStrmIter::SizeofChecksum());
    ULONG cPersTotalRec = hdr.GetCount( hdr.GetPrimary() );

    Win4Assert( cPersTotalRec == cTotPrim );
    Win4Assert( cPersTotalRec * (cDocInChunk * sizeof(CDocNotification) + CRcovStrmIter::SizeofChecksum()) == ulDataSize);
    Win4Assert((ulDataSize % (sizeof(CDocNotification) * cDocInChunk + CRcovStrmIter::SizeofChecksum())) == 0);

    ULONG cTotBackup = hdr.GetCount( hdr.GetBackup() );
    Win4Assert( 0 == _cChunksTotal || _cChunksTotal == cTotPrim );
}

#else

inline void CChangeLog::LokVerifyConsistency(){}

#endif


//+---------------------------------------------------------------------------
//
//  Function:   LokEmpty, public
//
//  Synopsis:   Initializes the change log by empting it and setting status
//              to eCIDiskFullScan
//
//  History:    15-Nov-94    DwightKr    Created
//
//----------------------------------------------------------------------------
void CChangeLog::LokEmpty()
{

    CImpersonateSystem impersonate;

    PRcovStorageObj & persDocQueue = *_PersDocQueue;
    CRcovStrmWriteTrans xact( persDocQueue );

    persDocQueue.GetHeader().SetCount(persDocQueue.GetHeader().GetBackup(), 0);

    xact.Empty();

    xact.Commit();

    _oChunkToRead = 0;
    _cChunksAvail = 0;
    _cChunksTotal = 0;

    LokVerifyConsistency();
}

//+---------------------------------------------------------------------------
//
//  Function:   InitSize
//
//  Synopsis:   Initializes the size of the change log by reading in the
//              size information from the change log header.
//
//  History:    May-26-94   srikants    Rewrite and move from CDocQueue
//              Nov-08-94   DwightKr    Added dirty flag set on startup
//
//----------------------------------------------------------------------------

void CChangeLog::InitSize()
{
    ULONG ulDataSize = 0;

    //
    //  Two copies of the content scan data must fit into the recoverable
    //  stream header in the user-data section.  Verify that we haven't
    //  grown too large.
    //

    CImpersonateSystem impersonate;

    PRcovStorageObj & persDocQueue = *_PersDocQueue;
    CRcovStorageHdr & hdr = persDocQueue.GetHeader();

    persDocQueue.VerifyConsistency();

    //
    // Do a read transaction to complete any in-complete transactions.
    //
    {
        CRcovStrmReadTrans xact( persDocQueue );
    }

    //
    //  Determine the # of records in the persistent log and do some
    //  consistency checks.
    //
    ulDataSize = hdr.GetUserDataSize( hdr.GetPrimary() );
    ULONG cRecords = hdr.GetCount( hdr.GetPrimary() );
    ULONG cTotRecord = ulDataSize / (sizeof(CDocNotification) * cDocInChunk + CRcovStrmIter::SizeofChecksum());

    //
    //  If the number of records in the file is not the same as the
    //  number of records in the header, we have an inconsistancy.
    //
    if ( cRecords != cTotRecord )
    {
        Win4Assert( !"Corrupt changelog" );
        _storage.ReportCorruptComponent( L"ChangeLog2" );

        THROW( CException( CI_CORRUPT_DATABASE ) );
    }


    _oChunkToRead = 0;
    _cChunksAvail = cTotRecord;
    _cChunksTotal = _cChunksAvail;
}


//+---------------------------------------------------------------------------
//
//  Function:   DeSerialize
//
//  Synopsis:   Reads the specified number of chunks from the change log and
//              appends them to the list passed.
//
//  Arguments:  [list]          --  List to append to.
//              [cChunksToRead] --  Number of chunks to read.
//
//  Returns:    Number of chunks read.
//
//  History:    5-26-94   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CChangeLog::DeSerialize( CChunkList & list, ULONG cChunksToRead )
{

    CImpersonateSystem impersonate;

    CChunkList  newChunks;

    Win4Assert( cChunksToRead <= _cChunksAvail );
    cChunksToRead = min (cChunksToRead, _cChunksAvail);

    PRcovStorageObj & persDocQueue = _PersDocQueue.Get();
    CRcovStorageHdr & hdr = persDocQueue.GetHeader();

    //
    // We seem to be losing writes for the header stream. Just check the
    // consistency before reading the data from disk.
    //
    LokVerifyConsistency();

    {
        //  Begin transaction
        CRcovStrmReadTrans xact( persDocQueue );
        CRcovStrmReadIter iter( xact, cDocInChunk * sizeof(CDocNotification) );

        iter.Seek( _oChunkToRead );

        for ( unsigned i=0; i < cChunksToRead ; i++ )
        {
            CDocChunk *pChunk = new CDocChunk;

            iter.GetRec( pChunk->GetArray() );

            newChunks.Append(pChunk);
        }
    }  // End-Transaction

    Win4Assert( newChunks.Count() == cChunksToRead );

    //
    // Acquire the newly created list and append it to the existing list.
    //
    list.AcquireAndAppend(newChunks);

    //
    // Update the internal state.
    //
    _oChunkToRead += cChunksToRead;
    _cChunksAvail -= cChunksToRead;

    if ( _cChunksAvail + _oChunkToRead != _cChunksTotal )
    {
        Win4Assert( ! "Data Corruption && ChangeLog::_cChunksAvail + _oChunktoRead != _cChunksTotal" );
        _storage.ReportCorruptComponent( L"ChangeLog3" );
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    LokVerifyConsistency();

    return(cChunksToRead);
}

//+---------------------------------------------------------------------------
//
//  Function:   Serialize
//
//  Synopsis:   Serializes the given list of CDocChunks to the disk.
//
//  Arguments:  [listToSerialize] -- The list to be serialized
//              [aUsnFlushInfo]   -- Usn flush info returned here
//
//  Returns:    Number of chunks serialized.
//
//  History:    5-26-94   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CChangeLog::Serialize( CChunkList & listToSerialize,
                             CCountedDynArray<CUsnFlushInfo> & aUsnFlushInfo )
{
    CImpersonateSystem impersonate;

    unsigned cRecords = 0;

    USN updateUSN = 0;

    CRcovStorageHdr & hdr = _PersDocQueue.Get().GetHeader();

    LokVerifyConsistency();

    {
        //
        // Begin Transaction
        //
        // STACKSTACK
        //
        XPtr<CRcovStrmAppendTrans>  xTrans( new CRcovStrmAppendTrans( _PersDocQueue.Get() ) );

        CRcovStrmAppendIter iter( xTrans.GetReference(), cDocInChunk * sizeof(CDocNotification) );

        for ( CDocChunk * pChunk = listToSerialize.GetFirst() ;
              0 != pChunk;
              pChunk = pChunk->GetNext() )
        {
            pChunk->UpdateMaxUsn( aUsnFlushInfo );
            iter.AppendRec( pChunk->GetArray() );
            cRecords++;
        }

        xTrans->Commit();
    }   // EndTransaction

    ciDebugOut( (DEB_ITRACE, "SerializeRange: %d records serialized to disk\n", cRecords) );
    _cChunksAvail += cRecords;
    _cChunksTotal += cRecords;

    //
    // Extra level of consistency checking for the lengths and record
    // counts in the on-disk version vs. in-memory values.
    //
    ULONG ulDataSize = hdr.GetUserDataSize( hdr.GetPrimary() );
    ULONG cTotRecord = ulDataSize / (sizeof(CDocNotification) * cDocInChunk + CRcovStrmIter::SizeofChecksum());
    ULONG cRecCount  = hdr.GetCount( hdr.GetPrimary() );

    if ( (cTotRecord != cRecCount) ||
         ((ulDataSize % (sizeof(CDocNotification) * cDocInChunk + CRcovStrmIter::SizeofChecksum())) != 0) ||
         (_cChunksTotal != cTotRecord) ||
         (_oChunkToRead + _cChunksAvail != cTotRecord) )
    {
        ciDebugOut(( DEB_ERROR,
                     "cTotRecord %d, cRecCount %d, ulDataSize %d\n"
                     "sizeof(CDocNotifications) %d, CRcovStrmIter::SizeofChecksum() %d\n"
                     "cDocInChunk %d, _cChunksTotal %d, cTotRecord %d\n"
                     "_oChunkToRead %d, _cChunksAvail %d\n",
                     cTotRecord, cRecCount, ulDataSize,
                     sizeof(CDocNotification), CRcovStrmIter::SizeofChecksum(),
                     cDocInChunk, _cChunksTotal, cTotRecord,
                     _oChunkToRead, _cChunksAvail ));

        Win4Assert( "Data Corruption" && cTotRecord == cRecCount);
        Win4Assert( "Data Corruption" && (ulDataSize % (sizeof(CDocNotification) * cDocInChunk + CRcovStrmIter::SizeofChecksum())) == 0);
        Win4Assert( "Data Corruption" && _cChunksTotal == cTotRecord );
        Win4Assert( "Data Corruption" && _oChunkToRead + _cChunksAvail == _cChunksTotal );

        _storage.ReportCorruptComponent( L"ChangeLog5" );
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }


    ciDebugOut(( DEB_ITRACE,
                 "Serialize: cRecords=%d  ulDataSize/sizeof(record)=%d\n",
                 cRecCount, cTotRecord ));

    return cRecords;
} //Serialize

//+---------------------------------------------------------------------------
//
//  Function:   LokDeleteWIDsInPersistentIndexes
//
//  Synopsis:   This method computes the number of chunks that can be
//              deleted from the front of the changelog and truncates the
//              log appropriately.
//
//              All documents that have been filtered and successfully made
//              into a persistent index need not be filtered after restart.
//              This method iterates over the filtered chunks from the front
//              of the log and when it detects a document that has not yet
//              made it into a persistent index, it stops the iteration and
//              truncates the log upto such a chunk ( not including the chunk
//              that had a document in a volatile index ).
//
//  Arguments:  [cFilteredChunks]  -- Number of chunks that have been
//                                    filtered.
//              [freshTestLatest]  -- Latest freshTest
//              [freshTestAtMerge] -- Fresh test snapshoted at time of shadow
//                                    merge (can be same as freshTestLatest)
//              [docList]          -- Resman's Doc list
//              [notifTrans]       -- Notification transaction
//
//  Returns:    The number of chunks that have been truncated from the
//              front.
//
//  History:    5-27-94      SrikantS   Created
//              2-24-97      SitaramR   Push filtering
//
//----------------------------------------------------------------------------

ULONG CChangeLog::LokDeleteWIDsInPersistentIndexes( ULONG cFilteredChunks,
                                                    CFreshTest & freshTestLatest,
                                                    CFreshTest & freshTestAtMerge,
                                                    CDocList & docList,
                                                    CNotificationTransaction & notifTrans )
{
    CImpersonateSystem impersonate;

    //
    // Create the recoverable storage object.
    //
    PRcovStorageObj & persDocQueue = _PersDocQueue.Get();
    CRcovStorageHdr & hdr = persDocQueue.GetHeader();

    ULONG ulDataSize = hdr.GetUserDataSize( hdr.GetPrimary() );
    ULONG cTotRecord = 0;

    LokVerifyConsistency();

#if CIDBG == 1
    ULONG cPersTotalRec = hdr.GetCount( hdr.GetPrimary() );
    Win4Assert( cPersTotalRec >= cFilteredChunks );
#endif


    ULONG cRecord = 0;
    BOOL  fDocInPersIndex = TRUE;

    {   //  Begin Transaction

        CRcovStrmReadTrans xact( persDocQueue );
        CRcovStrmReadIter  iter( xact, cDocInChunk * sizeof(CDocNotification) );

        cTotRecord = iter.UserRecordCount( ulDataSize );

        CDocChunk Chunk;

        //
        // Determine the first chunk in the filtered set which has a document
        // that nas not made it to a persistent index.
        //
        while ( fDocInPersIndex && ( cRecord < cFilteredChunks ) )
        {
            //
            // Read the next chunk from the change log.
            //
            iter.GetRec( Chunk.GetArray() );

            //
            // Determine if all the documents in this chunk have made it to
            // persistent indexes or not.
            //
            for ( ULONG oRetrieve = 0; oRetrieve < cDocInChunk; oRetrieve++ )
            {
                CDocNotification * pRetrieve = Chunk.GetDoc(oRetrieve);

                WORKID wid = pRetrieve->Wid();
                USN usn = pRetrieve->Usn();

                if ( wid == widInvalid
                     || ( _fPushFiltering && _pResManager->LokIsWidAborted( wid, usn ) ) )
                {
                    //
                    // An invalid wid means that the changlog did not have enough
                    // entries to fill Chunk and hence the remaining entries were set
                    // to widinvalid. AbortedWid means that the wid was
                    // aborted during filtering and not refiled. Hence we don't
                    // have to check whether this wid made it to the persistent index
                    // or not.
                    //
                    continue;
                }

                if ( IsWidInDocList( wid, docList ) )
                {
                    //
                    // If the wid is in the doclist then it means that it
                    // did not necessarily make it to the persistent index.
                    //
                    fDocInPersIndex = FALSE;
                    break;
                }

                if ( pRetrieve->IsDeletion() )
                {
                    //
                    // For deletions, check if the wid is in iidDeleted using
                    // freshTestAtMerge. iidDeleted is the index for both deletions
                    // in wordlists and persistent indexes, and so by using the
                    // frest test at merge we can be sure that we are doing the
                    // proper check. Also, check if the wid is in iidInvalid,
                    // because after a master merge all wids (even deleted ones)
                    // will be in iidInvalid. Also, check if the wid is in a persistent
                    // index. This is for the case of delete followed by an add of the
                    // same wid. Note: since iidDeleted1, iidDeleted2, iidInvalid pass the
                    // IsPersistent test, all the above tests can be simplified to just
                    // checking for IsPersistent index.
                    //

                    INDEXID  iid = freshTestAtMerge.Find( wid );
                    CIndexId IndexID ( iid );

                    if ( !IndexID.IsPersistent() )
                    {
                        fDocInPersIndex = FALSE;
                        break;
                    }
                }
                else
                {
                    //
                    // Add or modify case. We use frestTestLatest because if the
                    // wid is in the wordlist and an earlier version of the same
                    // wid in a persistent index, then we'll assume that the wid
                    // has not yet made it to the persistent index. Master index
                    // is iidinvalid, which is a persistent index.
                    //
                    INDEXID  iid = freshTestLatest.Find( wid );

                    if ( iid == iidDeleted1 || iid == iidDeleted2 )
                    {
                        //
                        // An add/modify may actually be a deletion that was requeued as modify. For
                        // deletions we should use freshTestAtMerge as described above.
                        //
                        iid = freshTestAtMerge.Find( wid );

                        if ( iid != iidDeleted1 && iid != iidDeleted2 )
                        {
                            fDocInPersIndex = FALSE;
                            break;
                        }
                    }
                    else
                    {
                        CIndexId IndexID ( iid );

                        if ( !IndexID.IsPersistent() )
                        {
                            //
                            // Wid is in a wordlist
                            //
                            fDocInPersIndex = FALSE;
                            break;
                        }
                    }
                }   // if/else( pRetrieve->IsDeletion() )

            }   // for loop

            if ( cDocInChunk == oRetrieve )
            {
                //
                // All the documents in this chunk are in persistent
                // indexes. These can be deleted from the change log,
                // and the documents are added to the commited list
                // used in the push/simple filtering model, or they are
                // added to the aborted list used in push/simple filtering
                // model.
                //
                Win4Assert( fDocInPersIndex );

                if ( _fPushFiltering )
                {
                    for ( ULONG iDoc = 0; iDoc < cDocInChunk; iDoc++ )
                    {
                        CDocNotification * pDoc = Chunk.GetDoc(iDoc);

                        if ( pDoc->Wid() != widInvalid )
                        {
                            //
                            // An invalid wid means that the changlog did not have enough
                            // entries to fill Chunk and hence the remaining entries were set
                            // to widinvalid. Hence an invalid wid can be ignored.
                            //

                            if ( _pResManager->LokIsWidAborted( pDoc->Wid(), pDoc->Usn() ) )
                            {
                                //
                                // Needs to be removed from the aborted wids list
                                //
                                notifTrans.RemoveAbortedWid( pDoc->Wid(), pDoc->Usn() );
                            }
                            else
                            {
                                //
                                // Needs to be added to the committed wids list
                                //
                                notifTrans.AddCommittedWid( pDoc->Wid() );
                            }
                        }
                    }
                }

                cRecord++;
            }

        }   // while loop
    }   // End transaction

    ciDebugOut( (DEB_ITRACE, "Truncating %d of %d record(s) from persistent changelog\n", cRecord, cTotRecord) );

    if (cRecord > 0)
    {
        //
        // Shrink the change log stream from the front by "cRecord" amount.
        //
        CRcovStrmMDTrans xact(
                               persDocQueue,
                               CRcovStrmMDTrans::mdopFrontShrink,
                               cRecord * (cDocInChunk * sizeof(CDocNotification) + CRcovStrmIter::SizeofChecksum())
                             );

        cTotRecord -= cRecord;
        hdr.SetCount( hdr.GetBackup(), cTotRecord);
        xact.Commit();

        //
        // Commit wids in push filtering model. This needs to be done after the CRcovSTrmMDTrans
        // because it should be done only if that transaction is successfully committed
        //
        notifTrans.Commit();
    }

    //
    // Update the internal state of offset.
    //
    Win4Assert( cRecord <= _oChunkToRead );
    _oChunkToRead -= cRecord;
    _cChunksTotal -= cRecord;

    LokVerifyConsistency();

    return(cRecord);
}


//+---------------------------------------------------------------------------
//
//  Function:   LokDisableUpdates
//
//  Synopsis:   Disable further updates to changelog
//
//  History:    12-15-94   srikants   Created
//               2-24-97   SitaramR   Push filtering
//
//----------------------------------------------------------------------------

void CChangeLog::LokDisableUpdates()
{
    _fUpdatesEnabled = FALSE;

    if ( !_fPushFiltering )
    {
        //
        // In pull (i.e. not push) filtering, reset the in-memory part of
        // changlog
        //
        _cChunksTotal = _cChunksAvail = _oChunkToRead = 0;
        LokVerifyConsistency();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LokEnableUpdates
//
//  Synopsis:   Enables updates to changelog
//
//  Arguments:  [fFirstTimeUpdatesAreEnabled]  -- Is this being called for the
//                                                first time ?
//
//  History:    12-15-94   srikants   Created
//               2-24-97   SitaramR   Push filtering
//
//----------------------------------------------------------------------------
void CChangeLog::LokEnableUpdates( BOOL fFirstTimeUpdatesAreEnabled )
{
    _fUpdatesEnabled = TRUE;

    if ( fFirstTimeUpdatesAreEnabled || !_fPushFiltering )
    {
        //
        // In pull (i.e. not push) filtering, initialize the in-memory part
        // of changlog. Also, if EnableUpdates is being called for the first time,
        // then initialize the in-memory  datastructure (i.e. do the
        // initialization in the case of push filtering also).
        //
        InitSize();
        LokVerifyConsistency();
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetResman
//
//  Synopsis:   Initializes ptr to resman
//
//  Arguments:  [pResManager]    -- Resource manager
//              [fPushFiltering] -- Using push model of filtering ?
//
//  History:    12-15-94   srikants   Created
//
//----------------------------------------------------------------------------

void CChangeLog::SetResMan( CResManager * pResManager, BOOL fPushFiltering )
{
    _pResManager = pResManager;
    _fPushFiltering = fPushFiltering;

    if ( fPushFiltering )
    {
        //
        // In push filtering, nuke the changelog because on shutdown all
        // client notifications are aborted, and it's the clients
        // responsibility to re-notify us after startup
        //
        CImpersonateSystem impersonate;

        PRcovStorageObj & persDocQueue = *_PersDocQueue;
        CRcovStrmWriteTrans xact( persDocQueue );

        persDocQueue.GetHeader().SetCount(persDocQueue.GetHeader().GetBackup(), 0);

        xact.Empty();
        xact.Commit();

        Win4Assert( _oChunkToRead == 0 );
        Win4Assert( _cChunksAvail == 0 );
        Win4Assert( _cChunksTotal == 0 );
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   IsWidInDocList
//
//  Synopsis:   Check if the given wid is in the doc list
//
//  Arguments:  [wid]     -- Workid to check
//              [docList] -- Doclist
//
//  History:    24-Feb-97       SitaramR       Created
//
//  Notes:      Use simple sequential search because there are atmost 16
//              wids in docList
//
//----------------------------------------------------------------------------

BOOL CChangeLog::IsWidInDocList( WORKID wid, CDocList & docList )
{
    for ( unsigned i=0; i<docList.Count(); i++ )
    {
        if ( docList.Wid(i) == wid )
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\dirtree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       DIRTREE.CXX
//
//  Contents:   Directory Tree
//
//  Classes:    CDirTree
//
//  History:    13-Aug-91   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <misc.hxx>
#include <dirtree.hxx>

void CDirTree::Init ( unsigned count )
{
    //
    //  If we are rebuilding the directory tree, cleanup the old one
    //
    if (_count != 0)
    {
        delete _pKeys;
        _pKeys = new CKeyArray(1);
    }

    ciAssert ( count > 0 );
    _count = count;

    // How many binary digits are needed
    // to represent numbers from 0 to _count-1?

    if ( _count > 1 )
        _digits = Log2 ( _count - 1 );
    else
        _digits = 0;

    _firstLeaf = 1 << _digits;
}

void CDirTree::Init ( CKeyArray& keys, unsigned count )
{
    Init ( count );
    for ( unsigned n = 1; n < count; n++)
    {
        ciAssert ( keys.Get(n).Pid() != pidAll );
        _pKeys->Add ( Index(n), keys.Get(n) );
    }
    Done ( n );
}

void CDirTree::Add ( unsigned i, const CKeyBuf& key )
{
    // skip the zerot'th key
    if ( i == 0 )
        return;

    ciAssert ( &key != 0 );
    ciAssert ( key.Pid() != pidAll );

    _pKeys->Add ( Index(i), key);
}

unsigned CDirTree::Seek ( const CKey& key ) const
{
    ciDebugOut (( DEB_PDIR, "CDirTree::Seek %.*ws pid %d\n",
        key.StrLen(), key.GetStr(), key.Pid() ));

    //----------------------------------------------------
    // Notice: Make sure that pidAll is smaller
    // than any other legal PID. If the search key
    // has pidAll we want to be positioned at the beginning
    // of the range.
    //----------------------------------------------------

    ciAssert ( pidAll == 0 );

    for ( unsigned i = 1; i < _firstLeaf; )
    {
        ciDebugOut (( DEB_PDIR, "\tCompare with %.*ws pid %d  ",
          _pKeys->Get(i).StrLen(), _pKeys->Get(i).GetStr(), _pKeys->Get(i).Pid() ));

        if ( key.Compare(_pKeys->Get(i)) < 0 )
        {
            ciDebugOut (( DEB_PDIR, "too big\n" ));
            i = 2 * i;
        }
        else
        {
            ciDebugOut (( DEB_PDIR, "too small or equal\n" ));
            i = 2 * i + 1;
        }
    }

    return i - _firstLeaf;
}

// Decompose idx = (1, 2^digits - 1) in the following form
// idx = i * 2^n, where i is odd
// n counts the number of trailing zeros,
// i has (digits - n) digits
//
// level = digits - n
// is the level of the tree (root is level 1)
//
// i / 2 is the node number within this level
// it has (level-1) digits

unsigned CDirTree::Index( unsigned idx )
{
    ciAssert (idx != 0);

    unsigned i = idx;
    unsigned n = 0;

    while ( (i & 1) == 0 )
    {
        i >>= 1;
        n++;
    }

    // n = number of trailing 0's
    // i is odd

    idx = (1 << (_digits - n - 1)) + (i >> 1);

    ciAssert ( idx < _firstLeaf );

    return idx;
}

void CDirTree::Done( unsigned i )
{
    //
    // This can be very expensive, since each key will allocate
    // > 250 bytes and fill them with 0xff.  But it's too late to do anything
    // about it since the definition of max key is defined now that we've
    // shipped.
    //

    for ( ; i < _firstLeaf; i++ )
        _pKeys->FillMax(Index(i));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\doclist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       DOCLIST.CXX
//
//  Contents:   Work ID, Property ID list
//
//  Classes:    CDocItem, CDocList
//
//  History:    11-Nov-91   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <doclist.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDocList::WidMax, public
//
//  Synopsis:   Returns the maximum WORKID of the document list
//
//  History:    07-May-93   AmyA        Created.
//
//  Notes:      Checks to make sure the array is sorted if CIDBG==1.
//
//----------------------------------------------------------------------------

WORKID CDocList::WidMax() const
{
    Win4Assert( _count > 0 );

#if CIDBG == 1   // check to make sure array is sorted
    for( unsigned i=0; i<_count; i++ )
    {
        if ( i < _count - 1 )
            ciAssert( _array[i].wid < _array[i+1].wid );
        ciAssert( _array[i].wid > 0 && _array[i].wid < widInvalid );
    }
#endif // CIDBG == 1

    return _array[_count-1].wid;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDocList::LokSortOnWid, public
//
//  Synopsis:   Sorts the WorkId with an insertion sort
//
//  History:    23-Mar-93   AmyA        Borrowed from sort.cxx
//
//---------------------------------------------------------------------------

void CDocList::LokSortOnWid()
{
    if(_count <= 1)        // nothing to sort
        return;

    // loop from through all elements
    for(unsigned j = 1; j < _count; j++)
    {
        CDocItem entry = _array[j];

        // go backwards from j-1 shifting up keys greater than 'key'
        for ( int i = j - 1; i >= 0 && _array[i].wid > entry.wid; i-- )
        {
            _array[i+1] = _array[i];
        }
        // found key less than or equal 'key' or hit the beginning (i == -1)
        // insert key in the hole
        _array[i+1] = entry;
    }

#if CIDBG==1
    //
    // Assert that there are no duplicate wids in the buffer.
    //
    for ( unsigned iSrc = 1; iSrc < _count; iSrc++ )
    {
        Win4Assert( _array[iSrc-1].wid != _array[iSrc].wid );    
    }
#endif  // CIDBG==1

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\filtman.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999.
//
//  File:       FILTMAN.CXX
//
//  Contents:   Filter Manager
//
//  Classes:    CFilterManager
//
//  History:    03-Jan-95    BartoszM    Created from parts of CResMan
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciole.hxx>
#include <cievtmsg.h>
#include <fdaemon.hxx>
#include <cifailte.hxx>

#include "filtman.hxx"
#include "resman.hxx"
#include "fltstate.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CFilterAgent::CFilterAgent, public
//
//  Synopsis:   Initialize the agent, register it with ResMan
//
//  History:    05-Jan-95   BartoszM    Created
//
//----------------------------------------------------------------------------

CFilterAgent::CFilterAgent (CFilterManager& filterMan, CResManager& resman )
:   _sigFilterAgent(eSigFilterAgent),
    _resman (resman),
    _filterMan (filterMan),
    _eventUpdate(FALSE), // start reset
    _fStopFilter(FALSE)
{
    _resman.RegisterFilterAgent (this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterAgent::~CFilterAgent, public
//
//  Synopsis:   Stop filtering
//
//  History:    05-Jan-95   BartoszM    Created
//
//----------------------------------------------------------------------------
CFilterAgent::~CFilterAgent ()
{
    if ( !_fStopFilter )
    {
        StopFiltering();
    }
}

void CFilterAgent::StopFiltering()
{
    CLock lock(_mutex);
    _fStopFilter = TRUE;
    _eventUpdate.Set();
}
//+---------------------------------------------------------------------------
//
//  Member:     CFilterAgent::FilterThread, public
//
//  Synopsis:   Entry point for the thread responsible
//              for filtering
//
//  History:    05-Jan-95   BartoszM    Created
//
//----------------------------------------------------------------------------
DWORD WINAPI CFilterAgent::FilterThread( void* p )
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   PutToSleep
//
//  Synopsis:   Resets the update event unless filtering is stopped
//
//  History:    Feb-08-95   BartoszM    Created
//
//----------------------------------------------------------------------------
BOOL CFilterAgent::PutToSleep ()
{
    CLock lock(_mutex);

    if (_fStopFilter)
        return FALSE;

    _eventUpdate.Reset();
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   LokWakeUp
//
//  Synopsis:   Completes an asynchronous pending I/O request, if any.
//
//  History:    19-Nov-94   DwightKr    Moved into a method
//
//  Notes:      If a corrupt content scan is detected, this routine
//              will persistently record the event to disk.  This may not
//              throw.
//
//----------------------------------------------------------------------------
void CFilterAgent::LokWakeUp ()
{
    _eventUpdate.Set();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterAgent::LokCancel, public
//
//  Synopsis:   Cancel any connections to the CI Filter service.
//
//  History:    09-Jan-95   BartoszM    Created
//
//----------------------------------------------------------------------------
void CFilterAgent::LokCancel ()
{
    _eventUpdate.Set();   // wake up
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::CFilterManager, public
//
//  Arguments:  [resman] -- resource manager
//
//  Requires:   resman to be fully constructed
//
//  History:    03-Jan-95    BartoszM    Created
//
//----------------------------------------------------------------------------

CFilterManager::CFilterManager(CResManager& resman)
:   _sigFiltMan(eSigFiltMan),
    _resman (resman),
    _docList(resman.GetDocList()),
#pragma warning( disable : 4355 )       // this used in base initialization
    _filterAgent (*this, resman ),
#pragma warning( default : 4355 )
    _fPushFiltering( resman.FPushFiltering() ),
    _LastResourceStatus( TRUE )
{
    LARGE_INTEGER CurrentTime;
    NtQuerySystemTime( &CurrentTime );
    _LastResourceCheck = CurrentTime.QuadPart;

    _fWaitOnNoDocs = FALSE;
}

NTSTATUS CFilterManager::Dismount()
{
    _filterAgent.StopFiltering();
    return STATUS_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupPartialWordList
//
//  Synopsis:   If there is any previous wordlist, it will cleanup the
//              wordlist by considering all the documents as failed with
//              FILTER_EXCEPTION.  If the retry count has exceeded the
//              maximum for a document, it will be considered as UNFILTERED
//              and marked accordingly in the wordlist.
//
//              This handling is necessary to deal with the case of a
//              repeatedly failing filter daemon on a document and to limit
//              the number of retries. Just refiling the documents will
//              lead to infinite looping.
//
//  History:    6-16-94   srikants   Separated from FilterReady for making
//                                   kernel mode call Asynchronous.
//
//----------------------------------------------------------------------------

void CFilterManager::CleanupPartialWordList()
{
    if ( !_pWordList.IsNull() )
    {
        //
        // We have to consider the filtering failed due to a problem in
        // the filter daemon and mark ALL these documents as FAILED.
        //
        ciDebugOut(( DEB_WARN,
                  "CFilterManager::CleanupPartialWordList. "
                  "Partially complete wordlist committed.\n" ));

        Win4Assert( 0 != _docList.Count() );

        STATUS  aStatus[CI_MAX_DOCS_IN_WORDLIST];
        for ( unsigned i = 0; i < _docList.Count(); i++ )
        {
            aStatus[i] = FILTER_EXCEPTION;
        }

        FilterDone( aStatus, _docList.Count() );

        Win4Assert( _pWordList.IsNull() );
        Win4Assert( 0 == _docList.Count() );
    }
    else
    {
        Win4Assert( 0 == _docList.Count() );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FilterReady
//
//  Synopsis:   User mode (down level) filter ready handler. The main
//              difference from the kernel mode one is that the caller
//              is made to WAIT for an event in this call where as in the
//              kernel mode call, it will be returned STATUS_PENDING if there
//              are no documents.
//
//  Arguments:  [docBuffer] -- <see above>
//              [cb]        --
//              [cMaxDocs]  --
//
//  History:    6-16-94   srikants   For user-mode synchronous call.
//
//----------------------------------------------------------------------------

SCODE CFilterManager::FilterReady ( BYTE * docBuffer,
                                    ULONG & cb,
                                    ULONG cMaxDocs )
{
    CleanupPartialWordList();
    SCODE scode = S_OK;

    ULONG cbMax = cb;

    TRY
    {
        ciDebugOut(( DEB_ITRACE, "# CFilterManager::FilterReady.\n" ));
        Win4Assert( _docList.Count() == 0 );

        ULONG cDocs = 0;
        CGetFilterDocsState stateInfo;

        // loop until there are enough resources to filter and there are documents
        // to filter.
        do
        {
            //
            // Have at least reasonable confidence that there is
            // enough free memory to build the wordlist.  The minimum
            // free space and sleep time are parameterized by size
            // and sleep respectively.
            //

            BOOL fRetry = FALSE;

            Win4Assert( _pWordList.IsNull() );
            Win4Assert( _docList.Count() == 0 );

            cb = 0;

            BOOL fGoodTimeToFilter = FALSE;

            _resman.SampleUserActivity();

            // =================================================
            {
                CPriLock lock(_resman.GetMutex());
                fGoodTimeToFilter = LokIsGoodTimeToFilter();
            }
            // ==================================================

            if ( fGoodTimeToFilter )
                fGoodTimeToFilter = IsGoodTimeToFilter();  // Don't call this under lock.

            if ( !fGoodTimeToFilter )
            {
                ciDebugOut(( DEB_ITRACE, "Not a good time to filter.\n" ));
            }

            //
            // If the disk is getting full, don't give any more documents to
            // be filtered.
            //
            if ( fGoodTimeToFilter )
                fRetry = _resman.GetFilterDocs ( cMaxDocs, cDocs, stateInfo );



            if ( 0 == cDocs  )
            {
                if (!_filterAgent.PutToSleep())
                    return CI_E_SHUTDOWN;

                if ( fRetry )
                    continue;

                // otherwise wait
                ciDebugOut (( DEB_ITRACE, "\t|Waiting For Event\n" ));
                _filterAgent.Wait( fGoodTimeToFilter ?
                  INFINITE :
                  _resman.GetRegParams().GetLowResourceSleep() * 1000 );
                stateInfo.Reset();
                ciDebugOut (( DEB_ITRACE, "\t|Wakeup!\n" ));

                _fWaitOnNoDocs = FALSE;
            }
            else
            {
                cb = cbMax;
                _resman.FillDocBuffer( docBuffer, cb, cDocs, stateInfo );
                if ( cb > cbMax )
                {
                    // we need more space
                    Win4Assert ( 0 == cDocs );
                    break;
                }
            }
        } while ( cDocs == 0 );

        // There are documents to filter

        ciFAILTEST(STATUS_NO_MEMORY);

        if ( cb <= cbMax )
        {
            Win4Assert( _docList.Count() != 0 );

            NewWordList();
        }
    }
    CATCH( CException, e )
    {
        scode = e.GetErrorCode();

        if ( 0 != _docList.Count() )
        {
            //
            // We need to  add these documents back to the change log
            // so that they will get filtered later.
            //
            Win4Assert( _pWordList.IsNull() );

            //
            // Lock will be obtained by NoFailReFile before mucking with
            // the doclist.
            //
            if (!_resman.NoFailReFile ( _resman.GetDocList() ))
                scode = STATUS_CANCELLED;
        }
    }
    END_CATCH

    _fWaitOnNoDocs = FALSE;
    return scode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::LokIsGoodTimeToFilter
//
//  Synopsis:   Checks to see if this is a good time to filter.
//
//  Returns:    TRUE if okay to filter now.
//              FALSE o/w
//
//  History:    4-12-96   srikants   Made a version for user space.
//
//----------------------------------------------------------------------------

BOOL CFilterManager::LokIsGoodTimeToFilter()
{
    //
    //  If a content scan is required, setup the returned
    //  status.
    //
    if ( _resman.IsEmpty() )
    {
        //
        // The content index is being emptied. Don't give any
        // more documents to daemon.
        //
        return FALSE;
    }
    else if ( _resman.IsLowOnDiskSpace() )
    {
        //
        // Check if the disk status has improved and ask the
        // merge thread to do any book-keeping work.
        //
        if ( !_resman.LokCheckLowOnDiskSpace() )
            _resman.LokWakeupMergeThread();

        return FALSE;
    }
    else if ( _resman.LokCheckWordlistQuotas() )
    {
        //
        // We're already at our limit, so it's not a good idea to create more.
        //

        _resman.LokWakeupMergeThread();

        return FALSE;
    }
    else if ( _resman.LokIsScanNeeded() )
    {
        //
        // A scan is needed if we either lost an update or we are corrupt.
        //
        _resman.LokWakeupMergeThread();
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::IsGoodTimeToFilter
//
//  Synopsis:   Checks to see if this is a good time to filter.
//
//  Returns:    TRUE if okay to filter now.
//              FALSE o/w
//
//  History:    12-Apr-96   srikants   Made a version for user space.
//              10-Dec-97   KyleP      Make NoLok version
//
//----------------------------------------------------------------------------

BOOL CFilterManager::IsGoodTimeToFilter()
{
    //
    // Don't do any work until the system has booted
    //

    if ( GetTickCount() < _resman.GetRegParams().GetStartupDelay() )
        return FALSE;

    LARGE_INTEGER CurrentTime;

    NTSTATUS Status = NtQuerySystemTime( &CurrentTime );

    if ( NT_SUCCESS(Status) )
    {
        // Check user activity at 5 s. intervals
        if ( CurrentTime.QuadPart - _LastResourceCheck > 5 * 10000000i64 )
        {
            if ( _resman.IsUserActive(FALSE) )
            {
                //
                // If someone is typing on the keyboard, don't get in the way.
                //

                _LastResourceStatus = FALSE;
                _resman.ReportFilteringState( CIF_STATE_USER_ACTIVE );
                return _LastResourceStatus;
            }
        }

        ULONG ulDelay = _LastResourceStatus ?
                  _resman.GetRegParams().GetWordlistResourceCheckInterval() :
                  _resman.GetRegParams().GetLowResourceSleep();

        if ( CurrentTime.QuadPart - _LastResourceCheck > ulDelay * 10000000i64 )
        {
            _LastResourceCheck = CurrentTime.QuadPart;

            DWORD dwFilterState;

            if ( _resman.IsMemoryLow() )
            {
                //
                // If we're low on memory, don't eat up more with word lists
                //

                _LastResourceStatus = FALSE;
                dwFilterState = CIF_STATE_LOW_MEMORY;
            }
            else if ( _resman.IsBatteryLow() )
            {
                _LastResourceStatus = FALSE;
                dwFilterState = CIF_STATE_BATTERY_POWER;
            }
            else if ( _resman.IsIoHigh() )
            {
                //
                // If someone else is doing a lot of I/O, then we shouldn't add
                // to the problem.
                //

                _LastResourceStatus = FALSE;
                dwFilterState = CIF_STATE_HIGH_IO;
            }
            else if ( _resman.IsUserActive(TRUE) )
            {
                //
                // If someone is typing on the keyboard, don't get in the way.
                // This check is done after the Hi I/O check because the user
                // activity is sampled over 5 seconds there.
                //

                _LastResourceStatus = FALSE;
                dwFilterState = CIF_STATE_USER_ACTIVE;
            }
            else
            {
                _LastResourceStatus = TRUE;
                dwFilterState = 0;
            }

            _resman.ReportFilteringState( dwFilterState );
        }
    }

    return _LastResourceStatus;
}

#pragma warning( disable : 4756 )       // overflow in constant arithmetic

//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::FilterDataReady, public
//
//  Synopsis:   Adds the contents of entryBuf to the current Word List.
//
//  Returns:    Whether the word list is full.
//
//  Arguments:  [pEntryBuf] -- pointer to data to be added to Word List
//              [cb] -- count of bytes in buffer
//
//  History:    22-Mar-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE CFilterManager::FilterDataReady( const BYTE * pEntryBuf, ULONG cb )
{
    if ( _pWordList.IsNull() )
    {
        ciDebugOut(( DEB_WARN,
                     "CFilterManager::FilterDataReady. No wordlist active.\n" ));
        return FDAEMON_E_NOWORDLIST;
    }

    ciDebugOut(( DEB_ITRACE, "# CFilterManager::FilterDataReady.\n" ));
    SCODE sc = S_OK;

    TRY
    {
        _resman.SampleUserActivity();

        while (!_pWordList->MakeChunk( pEntryBuf, cb ))
            continue;

        if ( _pWordList->Size() >= _resman.GetRegParams().GetMaxWordlistSize() )
        {
            ciDebugOut (( DEB_ITRACE, "CFilterManager::FilterDataReady -- Wordlist full\n" ));
            sc = FDAEMON_W_WORDLISTFULL;
        }

        if ( _resman.IsMemoryLow() )
        {
            ciDebugOut (( DEB_ITRACE, "CFilterManager::FilterDataReady -- Running low on memory\n" ));
            sc = FDAEMON_W_WORDLISTFULL;

            //
            // Try forcing a merge to free things up.
            //

            _resman.ForceMerge( partidInvalid, CI_ANY_MERGE );
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Exception 0x%x caught during filtering. "
                     "Rescheduling/aborting documents for filtering.\n",
                     e.GetErrorCode() ));
        if ( e.GetErrorCode() == STATUS_INSUFFICIENT_RESOURCES )
            sc = FDAEMON_E_LOWRESOURCE;
        else
            sc = FDAEMON_E_FATALERROR;

#if CIDBG == 1
        for ( unsigned cWid = 0; cWid < _docList.Count(); cWid++ )
        {
            ciDebugOut(( DEB_ITRACE,
                         "Reschedule/aborting filtering of wid %d\n",
                         _docList.Wid(cWid) ));
        }
#endif // CIDBG == 1

        _pWordList.Delete();

        //
        // No refiling in push filtering, hence abort wids. Refile docList
        // in pull filtering.
        //
        if ( _fPushFiltering )
            _resman.NoFailAbortWidsInDocList();
        else
            _resman.NoFailReFile( _resman.GetDocList() );

        ciDebugOut(( DEB_ITRACE,
                     "CFilterManager::FilterDataReady "
                     "deleting wordlist and clearing doclist\n" ));
    }
    END_CATCH

    if ( sc == FDAEMON_E_LOWRESOURCE )
        _resman.NoFailFreeResources();

#if CIDBG==1
    {
        CPriLock   lock(_resman.GetMutex());
        Win4Assert( 0 == _docList.Count() && _pWordList.IsNull() ||
                    0 != _docList.Count() && !_pWordList.IsNull() );
    }
#endif  // CIDBG == 1

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::FilterDone, public
//
//  Synopsis:   Commits the current wordlist.
//
//  Arguments:  [aStatus] -- array of STATUS for current document list
//              [count] -- count for array
//
//  History:    22-Mar-93   AmyA        Created from MakeWordList
//
//----------------------------------------------------------------------------

SCODE CFilterManager::FilterDone( const STATUS * aStatus, ULONG count )
{
    if ( _pWordList.IsNull() )
    {
        Win4Assert( 0 == _docList.Count() );

        ciDebugOut(( DEB_WARN,
                     "CFilterManager::FilterDone. No wordlist active.\n" ));

        return( FDAEMON_E_NOWORDLIST );
    }

    ciDebugOut(( DEB_ITRACE, "# CFilterManager::FilterDone.\n" ));
    _resman.SampleUserActivity();

    // add statuses to _docList

    unsigned cDocuments = _docList.Count();
    Win4Assert( cDocuments <= count );

    for ( unsigned i = 0; i < cDocuments; i++ )
    {
        //
        // Note - we are modifying the status on the _docList in resman
        // without obtaining the resman lock. This is okay as we need a lock
        // only to protect the count in doclist.
        // Note: retries are 1-based, so the first filter attempt is 1.
        //
        if ( _docList.Retries(i) > _resman.GetRegParams().GetFilterRetries() )
        {
            _resman.GetDocList().SetStatus( i, TOO_MANY_RETRIES );
        }
        else if ( CI_SHARING_VIOLATION == aStatus[i] &&
                  _docList.SecQRetries(i) >= _resman.GetRegParams().GetSecQFilterRetries() )
        {
            // Documents are put in sec Q only in case of sharing violation.
            // Hence the above check. 

            ciDebugOut(( DEB_IWARN, "TOO_MANY_SECQ_RETRIES Doc Wid = %ld, SecQRetries = %d\n",
                         _docList.Wid(i),
                         _docList.SecQRetries(i) ));
            _resman.GetDocList().SetStatus( i, TOO_MANY_SECQ_RETRIES );
        }
        else if ( _docList.Status(i) != DELETED)
        {
            if ( _pWordList->IsEmpty() &&
                 ( WL_IGNORE != aStatus[i] &&
                   WL_NULL != aStatus[i] )
                   && CI_SHARING_VIOLATION != aStatus[i] )
            {

                if ( CI_NOT_REACHABLE == aStatus[i] )
                {
                    ciDebugOut (( DEB_WARN, "Wid %ld is UNREACHABLE\n",
                                  _docList.Wid(i) ));

                    _resman.GetDocList().SetStatus( i, TOO_MANY_RETRIES );
                    _resman.MarkUnReachable( _docList.Wid(i) );
                }
                else
                {
                    //
                    // If the wordlist is emtpy, it means the filter did not
                    // give us any data but still called FilterDone. We should
                    // treat all the documents as "exceptions".
                    //

                    ciDebugOut (( DEB_IWARN, "setting %d'th document"
                                  " with wid %ld, status %d to exception status\n",
                                  i, _docList.Wid(i), aStatus[i] ));

                    //
                    // Okay not to obtain the lock - only modifying the status.
                    //
                    _resman.GetDocList().SetStatus( i, FILTER_EXCEPTION );
                }


            }
            else
            {
                _resman.GetDocList().SetStatus( i, aStatus[i] );
            }
        }
    }


    PARTITIONID partid = _docList.PartId();
    INDEXID iid = _pWordList->GetId();

    SCODE sc = 0;
    BOOL fRetryFailures = FALSE;
    BOOL fDone = TRUE;          // This is so FilterMore doesn't
                                // get messed up.  Eventually, FilterDone
                                // should be split into FilterDone and
                                // CommitWordList.


    {
        //=============================================
        CPriLock lock ( _resman.GetMutex() );
        //  Resman is under lock till the end of block
        //=============================================


        if ( _resman.IsEmpty() )             // Content index empty
        {
            _resman.GetDocList().LokClear();
            return STATUS_CANCELLED;
        }

        // Special cases:
        // 1. partition has been deleted
        //    - entries in changes and fresh have been removed
        //    - delete wordlist and return
        // 2. wordlist is empty
        //    - delete wordlist
        //    - update changes
        // 3. no available index id's
        //    - put docList back into changes
        //    - delete word list
        //    - force merge
        // 4. no success statuses
        //    - delete word list

        iid = _resman.LokMakeWordlistId (partid);

        if (iid == iidInvalid)
        {
            ciDebugOut (( DEB_IWARN, "Invalid partition, Deleting wordlist\n" ));

            _pWordList.Delete();
            _resman.GetDocList().LokClear();

            return( FDAEMON_E_PARTITIONDELETED );
        }

        ciDebugOut (( DEB_ITRACE, "CFilterManager::FilterDone "
                            "new wordlist id %lx\n", iid ));


        Win4Assert( iid != iidInvalid );

        _pWordList->SetId ( iid );

        BOOL successes = FALSE;
        for ( unsigned iDoc = 0; iDoc < cDocuments; iDoc++ )
        {
            switch ( _docList.Status(iDoc) )
            {
                case TOO_MANY_RETRIES:
                case TOO_MANY_SECQ_RETRIES:
                    if ( !fRetryFailures )
                    {
                        //
                        // Save the state of the retry failures in the retry
                        // fail list before they are overwritten.
                        //
                        _retryFailList = _docList;
                        fRetryFailures = TRUE;
                    }
                    // NOTE: fall through
                case TOO_MANY_BLOCKS_TO_FILTER:
                    successes = TRUE;
                    _pWordList->MarkWidUnfiltered(iDoc);
                    _resman.GetDocList().SetStatus( iDoc, SUCCESS );
                    break;

                case SUCCESS:
                    _resman.IncrementFilteredDocumentCount();
                    successes = TRUE;
                    break;

                case CI_SHARING_VIOLATION:
                    //
                    // If push filtering, abort the wid. If pull filtering,
                    // add the wid to the sec queue so that filtering can be
                    // re-attempted later.
                    //
                    if ( _fPushFiltering )
                        _resman.NoFailAbortWid( _docList.Wid(iDoc), _docList.Usn(iDoc) );
                    else
                    {
                        _resman.GetDocList().LokIncrementSecQRetryCount(iDoc);
                        _resman.LokAddToSecQueue( partid,
                                                  _docList.Wid(iDoc),
                                                  _docList.VolumeId( iDoc ),
                                                  _docList.SecQRetries( iDoc ) );
                    }

                    _resman.GetDocList().SetStatus( iDoc, WL_NULL );

                    // WL_NULL is returned when the filter deliberately does
                    // not return any data.  Like DELETED, but we need to also
                    // delete any existing data in the index.
                case WL_NULL:
                    _pWordList->DeleteWidData(iDoc);
                    // NOTE: fall through
                case DELETED:
                    successes = TRUE;
                    break;

                case WL_IGNORE:
                    _pWordList->DeleteWidData(iDoc);
                    if ( iDoc == cDocuments - 1 )
                    {
                        ciDebugOut (( DEB_ITRACE, ">> Not all filtered\n" ));
                        fDone = FALSE;
                    }
                    break;

                case PENDING:
                    Win4Assert( !"Ci Daemon Still returning Pending" );
                    //
                    // NOTE: Fall through is deliberate - should remove PENDING
                    // when we find out we don't need it.
                    //
                case PREEMPTED:
                    //
                    // NOTE: Fall through is deliberate.
                    //
                default:
                    ciDebugOut (( DEB_ITRACE,"++++ %d'th document"
                                  " with fake wid %d and wid %ld failed: status %d\n",
                                  iDoc, iDocToFakeWid(iDoc),
                                  _docList.Wid(iDoc), _docList.Status(iDoc) ));


                    //
                    // something went wrong during filtering.  Delete all data
                    // associated with this workid.
                    //
                    _resman.GetDocList().LokIncrementRetryCount(iDoc);
                    _pWordList->DeleteWidData(iDoc);

                    Win4Assert( _docList.Retries(iDoc) <= (_resman.GetRegParams().GetFilterRetries()+1) );

                    //
                    //  If push filtering abort the wid. If pull filtering add it back
                    //  to the change log for re-filtering at a later time.
                    //
                    if ( _fPushFiltering )
                        _resman.NoFailAbortWid( _docList.Wid(iDoc), _docList.Usn(iDoc) );
                    else
                        _resman.LokReFileDocument( partid,
                                                   _docList.Wid(iDoc),
                                                   _docList.Usn(iDoc),
                                                   _docList.VolumeId(iDoc),
                                                   _docList.Retries(iDoc),
                                                   _docList.SecQRetries(iDoc) );

                    break;
            }

        }

        if ( !successes )   // only invalid data in word list
        {
            ciDebugOut (( DEB_ITRACE, "CFilterManager::FilterDone "
                            "deleting wordlist with invalid data\n" ));
            _pWordList.Delete();

            sc = FDAEMON_W_EMPTYWORDLIST;
        }
        else if ( !_resman.LokTransferWordlist ( _pWordList ) )
        {
            //
            // If push filtering, abort all wids. If pull filtering,
            // refile all wids.
            //
            if ( _fPushFiltering)
                _resman.NoFailAbortWidsInDocList();
            else
                _resman.NoFailReFile( _resman.GetDocList() );

            _pWordList.Delete();

            return( FDAEMON_E_WORDLISTCOMMITFAILED );
        }

        if ( fDone && (WL_IGNORE != aStatus[cDocuments-1]) )
        {
            ciDebugOut (( DEB_ITRACE, "CFilterManager::FilterDone "
                        "clearing doclist\n" ));
            _resman.GetDocList().LokClear();
        }

        _resman.LokUpdateCounters();        // Update # filtred documents
    }
    //==========================================

    //
    // Notification of failed docs cannot be done under lock.
    //
    if ( fRetryFailures )
    {
        for ( unsigned iDoc = 0; iDoc < cDocuments; iDoc++ )
        {
            if ( ( _retryFailList.Status(iDoc) == TOO_MANY_RETRIES ||
                   _retryFailList.Status(iDoc) == TOO_MANY_SECQ_RETRIES ) &&
                 CI_NOT_REACHABLE != aStatus[iDoc] )
                _resman.ReportFilterFailure (_retryFailList.Wid(iDoc));
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::StoreValue
//
//  Synopsis:   Store a property value.
//
//  Arguments:  [widFake]   -- Fake wid of object.
//              [prop]      -- Property descriptor
//              [var]       -- Value
//              [fCanStore] -- Returns TRUE if this is a storable property
//
//  History:    21-Dec-95   KyleP       Created
//
//----------------------------------------------------------------------------

SCODE CFilterManager::FilterStoreValue( WORKID widFake,
                                        CFullPropSpec const & ps,
                                        CStorageVariant const & var,
                                        BOOL & fCanStore )
{
    fCanStore = FALSE;

    Win4Assert( widFake > 0 );

    if ( widFake <= 0 )
        return STATUS_INVALID_PARAMETER;

    widFake = FakeWidToIndex( widFake );

    if ( widFake >= _docList.Count() )
        return STATUS_INVALID_PARAMETER;

    return _resman.StoreValue( _docList.Wid( widFake ), ps, var, fCanStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::StoreSecurity
//
//  Synopsis:   Store a file's security descriptor.
//
//  Arguments:  [widFake]   -- Fake wid of object.
//              [pSD]       -- pointer to security descriptor
//              [cbSD]      -- size in bytes of pSD
//              [fCanStore] -- Returns TRUE if storae succeeded
//
//  Notes:      Used only for downlevel index
//
//  History:    21-Dec-95   KyleP       Created
//
//----------------------------------------------------------------------------

SCODE CFilterManager::FilterStoreSecurity( WORKID widFake,
                                           PSECURITY_DESCRIPTOR pSD,
                                           ULONG cbSD,
                                           BOOL & fCanStore )
{
    fCanStore = FALSE;

    Win4Assert( widFake > 0 );

    if ( widFake <= 0 )
        return STATUS_INVALID_PARAMETER;

    widFake = FakeWidToIndex( widFake );

    if ( widFake >= _docList.Count() )
        return STATUS_INVALID_PARAMETER;

    fCanStore = _resman.StoreSecurity( _docList.Wid( widFake ), pSD, cbSD );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::FPSToPROPID, public
//
//  Synopsis:   Converts FULLPROPSPEC property to PROPID
//
//  Arguments:  [fps] -- FULLPROPSPEC representation of property
//              [pid] -- PROPID written here on success
//
//  Returns:    S_OK on success
//
//  History:    29-Dec-1997  KyleP      Created.
//
//----------------------------------------------------------------------------

SCODE CFilterManager::FPSToPROPID( CFullPropSpec const & fps, PROPID & pid )
{
    return _resman.FPSToPROPID( fps, pid );
}

#pragma warning( default : 4756 )       // overflow in constant arithmetic


//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::FilterMore, public
//
//  Synopsis:   Commits the current wordlist and creates a new one.
//
//  Arguments:  [aStatus] -- array of STATUS for the current document list
//              [count] -- count for array
//
//  History:    03-May-93   AmyA        Created.
//
//----------------------------------------------------------------------------

SCODE CFilterManager::FilterMore( const STATUS * aStatus, ULONG count )
{
    ciDebugOut (( DEB_ITRACE, "# CFilterManager::FilterMore\n" ));
    if ( _pWordList.IsNull() )
    {
        ciDebugOut(( DEB_WARN,
                     "FilterMore: No wordlist active.\n" ));
        return( FDAEMON_E_NOWORDLIST );
    }

    SCODE sc = FilterDone( aStatus, count );    // Commits Word List

    if ( SUCCEEDED(sc) )                        // No problems occured
    {
        // _docList may have been cleared for an error condition.
        ciDebugOut (( DEB_ITRACE, "CFilterManager::FilterMore "
                    "_docList.Count() = %d\n", _docList.Count() ));

        TRY
        {
            ciFAILTEST(STATUS_NO_MEMORY);
            if ( _docList.Count() != 0 )
                NewWordList();                         // Creates New Word List
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();

            Win4Assert( _pWordList.IsNull() );

            //
            // If push filtering, abort wids. In pull filtering add these documents
            // back to the change log so that they will get filtered later.
            //
            if ( _fPushFiltering )
                _resman.NoFailAbortWidsInDocList();
            else
            {
                if (!_resman.NoFailReFile ( _resman.GetDocList() ))
                    sc = STATUS_CANCELLED;
            }
        }
        END_CATCH
    }

#if CIDBG==1
        {
            CPriLock   lock(_resman.GetMutex());
            Win4Assert( 0 == _docList.Count() && _pWordList.IsNull() ||
                        0 != _docList.Count() && !_pWordList.IsNull() );
        }
#endif  // CIDBG == 1

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterManager::NewWordList, public
//
//  Synopsis:   Creates word list
//
//  History:    08-Apr-91   BartoszM    Created
//              24-Nov-92   KyleP       Retry pending documents
//              22-Mar-93   AmyA        Split into NewWordList and
//                                      CommitWordList
//
//----------------------------------------------------------------------------
void CFilterManager::NewWordList()
{
    unsigned cDocuments = _docList.Count();
    Win4Assert ( cDocuments != 0 );
    PARTITIONID partid = _docList.PartId();


    WORKID widMax = _docList.WidMax();
    CIndexId iid ( iidInvalid, partid );

    ciDebugOut (( DEB_ITRACE, "NewWordlist. Temporary iid %lx\n", iid ));

    _pWordList.Initialize ( iid, widMax );

    // initialize the wid translation table

    for ( unsigned i = 0; i < cDocuments; i++ )
        _pWordList->AddWid( _docList.Wid(i), _docList.VolumeId(i) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\dqueue.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       DQUEUE.CXX
//
//  Contents:   Document queue
//
//  Classes:    CDocQueue
//              CExtractDocs
//
//  History:    29-Mar-91   BartoszM    Created
//              13-Sep-93   BartoszM    Split from changes
//              11-Oct-93   BartoszM    Rewrote
//              24-Feb-97   SitaramR    Push filtering
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <doclist.hxx>
#include <cifailte.hxx>

#include "dqueue.hxx"
#include "resman.hxx"



//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::CheckInvariants
//
//  Synopsis:   Check that the doc queue is internally self-consistent
//
//----------------------------------------------------------------------------

void CDocQueue::CheckInvariants ( char * pTag ) const
{
#if DBG
    Win4Assert( _state == eUseSerializedList ||
                _state == eUseUnSerializedList );

    Win4Assert( _oAppend <= cDocInChunk &&
                _oRetrieve <= cDocInChunk );

    if (_cDocuments == 0)
    {
        Win4Assert( _oAppend == _oRetrieve );

        Win4Assert( _unserializedList.IsEmpty() ||
                    (_pFirstUnFiltered != 0 &&
                     0 == _pFirstUnFiltered->GetNext()) );

        Win4Assert( _changeLog.IsEmpty() );

        Win4Assert( _serializedList.IsEmpty() ||
                    _pFirstUnFiltered != 0 );
    }
    else
    {
        Win4Assert( ! _unserializedList.IsEmpty() ||
                    ! _serializedList.IsEmpty() ||
                    ! _changeLog.IsEmpty() );

        if ( _pFirstUnFiltered &&
             0 ==  _pFirstUnFiltered->GetNext() &&
             CDocQueue::eUseUnSerializedList == _state )
        {
            Win4Assert( _cDocuments == (_oAppend - _oRetrieve) );
        }
    }

    if (_oAppend < cDocInChunk)
    {
        Win4Assert( ! _unserializedList.IsEmpty() );
    }
    if (_oRetrieve < cDocInChunk)
    {
        Win4Assert( _pFirstUnFiltered != 0 );
    }
#endif // DBG
}


//+---------------------------------------------------------------------------
//
//  Class:      CExtractDocs
//
//  Purpose:    A class to "extract" documents from the CDocQueue in a
//              transactioned fashion. If there is a failure while extracting
//              the documents, the state of the CDocQueue will be left in
//              such a way that it will appear no documents have been taken out
//              of the CDocQueue.
//
//  History:    5-16-94   srikants   Created
//
//  Notes:      When we extract documents out of the CDocQueue, we may have
//              to deserialize from the disk if the in-memory queue gets used
//              up. There is a possibility that this may fail and in such a
//              case an exception will be thrown. If we have already taken out
//              some of the documents, these documents may never get filtered
//              again. To prevent this situation, we use a "transactioned
//              extract" provided by this class.
//
//----------------------------------------------------------------------------

class CExtractDocs
{
public:

    inline CExtractDocs( CDocQueue & docQueue, CDocList & docList );
    inline ~CExtractDocs();
    BOOL IsEmpty() const
    {
        Win4Assert( _cDocsRetrieved <= _cDocsTotal );
        return _cDocsRetrieved == _cDocsTotal;
    }
    inline void Retrieve( WORKID & wid,
                          USN & usn,
                          VOLUMEID& volumeId,
                          ULONG & action,
                          ULONG & cRetries,
                          ULONG & cSecQRetries );
    void Commit() { _fCommit = TRUE; }

private:

    BOOL IsEndOfCurrentChunk()
    {
        Win4Assert( _oRetrieve <= cDocInChunk );
        return( _oRetrieve == cDocInChunk );
    }

    CDocQueue &     _docQueue;
    CDocList  &     _docList;
    BOOL            _fCommit;

    CDocQueue::ERetrieveState _state;       // Current state of retrieval.

    ULONG           _oRetrieve;             // Offset in the first unfiltered
                                            // chunk to retrieve.
    CDocChunk*      _pFirstUnFiltered;      // Ptr to first unfiltered chk

    const unsigned &_cDocsTotal;            // # of documents left.
    unsigned        _cDocsRetrieved;        // # of documents retrieved.
    unsigned        _cFilteredChunks;       // # of filtered chunks.


};


//+---------------------------------------------------------------------------
//
//  Function:   CExtractDocs::CExtractDocs
//
//  Synopsis:   Constructor
//
//  History:    5-23-94   srikants   Created
//
//----------------------------------------------------------------------------

inline CExtractDocs::CExtractDocs( CDocQueue & docQueue, CDocList & docList )
    : _docQueue(docQueue),
      _docList(docList),
      _fCommit(FALSE),
      _state( docQueue._state ),
      _oRetrieve( docQueue._oRetrieve),
      _pFirstUnFiltered( docQueue._pFirstUnFiltered ),
      _cDocsTotal( docQueue._cDocuments ),
      _cDocsRetrieved(0),
      _cFilteredChunks( docQueue._cFilteredChunks )
{
    docQueue.CheckInvariants("CExtractDocs ctor");
}


//+---------------------------------------------------------------------------
//
//  Function:   CExtractDocs::CExtractDocs
//
//  Synopsis:   Destructor
//
//  History:    5-23-94   srikants   Created
//
//----------------------------------------------------------------------------

inline CExtractDocs::~CExtractDocs()
{
    _docQueue.CheckInvariants("CExtractDocs pre-dtor");
    if ( _fCommit )
    {
        _docQueue._oRetrieve = _oRetrieve;
        _docQueue._pFirstUnFiltered = _pFirstUnFiltered;
        _docQueue._cDocuments -= _cDocsRetrieved;
        _docQueue._cFilteredChunks = _cFilteredChunks;
        _docQueue._state = _state;

        //
        // Release the memory for filtered chunks that are
        // serialized.
        //
        CDocChunk * pTemp = _state == CDocQueue::eUseSerializedList ?
                            _pFirstUnFiltered : 0;

        _docQueue._serializedList.DestroyUpto( pTemp );

    }
    else
    {
        _docList.LokClear();
    }

    _docQueue.CheckInvariants("CExtractDocs post-dtor");
#if DBG
    if ( _pFirstUnFiltered &&
         0 ==  _pFirstUnFiltered->GetNext() &&
         CDocQueue::eUseUnSerializedList == _state )
    {
        Win4Assert( _docQueue._cDocuments ==
                    (_docQueue._oAppend - _docQueue._oRetrieve) );

    }
#endif // DBG
}

//+---------------------------------------------------------------------------
//
//  Member:     CExtractDocs::Retrieve
//
//  Synopsis:   Retrieves a single document from the docqueue. It has been
//              assumed that the docQueue is not empty when this method is
//              called.
//
//  Arguments:  [wid]          --  Output - Wid of the document
//              [usn]          --  Output - USN of the document
//              [volumeId]     --  Output - Volume id of the document
//              [action]       --  Output - Action performed on the document
//              [cRetries]     --  Output - Number of filtering retries.
//              [cSecQRetries] --  Output - Number of Secondary Q filtering retries.
//
//  History:    5-26-94   srikants   Created
//
//----------------------------------------------------------------------------

inline void CExtractDocs::Retrieve( WORKID & wid,
                                    USN & usn,
                                    VOLUMEID& volumeId,
                                    ULONG & action,
                                    ULONG & cRetries,
                                    ULONG & cSecQRetries )
{
    _docQueue.CheckInvariants("CExtractDocs::Retrieve pre");

    Win4Assert( !IsEmpty() );
    Win4Assert( 0 != _pFirstUnFiltered );

    if ( IsEndOfCurrentChunk() )
    {
        if ( CDocQueue::eUseSerializedList == _state )
        {
            //
            // We are currently retrieving from the serialized list.
            // Check to see if there is another chunk in the serialized
            // list that can be used next.
            //
            if ( 0 != _pFirstUnFiltered->GetNext() )
            {
                _pFirstUnFiltered = _pFirstUnFiltered->GetNext();
            }
            else if ( _docQueue._changeLog.IsEmpty() )
            {
                //
                // The change log doesn't have any archived chunks to be
                // read. In this case, the unserialized list cannot be
                // empty.
                //
                Win4Assert( !_docQueue._unserializedList.IsEmpty() );
                _pFirstUnFiltered = _docQueue._unserializedList.GetFirst();
                _state = CDocQueue::eUseUnSerializedList;
            }
            else
            {
                //
                // DeSerialize from the change log.
                //
                _docQueue.DeSerialize();
                _pFirstUnFiltered = _pFirstUnFiltered->GetNext();
            }

        }
        else
        {
            //
            // The state is UseUnSerializedList.
            //
            Win4Assert( 0 != _pFirstUnFiltered->GetNext() );
            _pFirstUnFiltered = _pFirstUnFiltered->GetNext();
        }

        _oRetrieve = 0;
        Win4Assert( 0 != _pFirstUnFiltered );
    }

    CDocNotification * pRetrieve = _pFirstUnFiltered->GetDoc( _oRetrieve );

    wid          = pRetrieve->Wid();
    usn          = pRetrieve->Usn();
    volumeId     = pRetrieve->VolumeId();
    action       = pRetrieve->Action() & ~CI_SCAN_UPDATE;
    cRetries     = pRetrieve->Retries();
    cSecQRetries = pRetrieve->SecQRetries();

    _oRetrieve++;
    _cDocsRetrieved++;

    if ( IsEndOfCurrentChunk() )
    {
        _cFilteredChunks++;
    }

    if ( CDocQueue::eUseUnSerializedList == _state &&
         0 == _pFirstUnFiltered->GetNext() )
    {
        Win4Assert( (_cDocsTotal - _cDocsRetrieved) ==
                    (_docQueue._oAppend - _oRetrieve) );
    }

    Win4Assert( _cDocsRetrieved <= _cDocsTotal  );
    Win4Assert( _oRetrieve <= cDocInChunk );

    Win4Assert( _docQueue._changeLog.AvailChunkCount() * cDocInChunk <=
                (_cDocsTotal-_cDocsRetrieved) );

    _docQueue.CheckInvariants("CExtractDocs::Retrieve post");
} //Retrieve

//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::CDocQueue
//
//  Synopsis:   Initializes queue
//
//  Arguments:  [widChangeLog] -- Workid of changlog
//              [storage]      -- Storage
//              [type]         -- Type of change log -- Primary or Secondary
//              [frmwrkParams] -- Framework parameters
//
//  History:    11-Oct-93       BartoszM        Created
//              10-Feb-94       DwightKr        Added code to load from disk
//
//----------------------------------------------------------------------------

CDocQueue::CDocQueue( WORKID widChangeLog,
                      PStorage & storage,
                      PStorage::EChangeLogType type,
                      CCiFrameworkParams & frmwrkParams ) :
    _frmwrkParams( frmwrkParams ),
    _sigDocQueue(eSigDocQueue),
    _changeLog( widChangeLog, storage, type ),
    _pResManager(0)
{
    LokInit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::LokInit
//
//  Synopsis:   Initializes the doc queue members. Also, deserializes chunks
//              from the changelog if it is not empty.
//
//  History:    27-Dec-94       SrikantS        Moved from ~ctor
//
//----------------------------------------------------------------------------

void CDocQueue::LokInit()
{
    _state = eUseSerializedList;
    _oAppend = _oRetrieve = cDocInChunk;
    _pFirstUnFiltered = 0;
    _cFilteredChunks = 0;
    _cRefiledDocs = 0;
    _cDocuments = 0;

    if ( !_changeLog.IsEmpty() )
    {
        _cDocuments = _changeLog.AvailChunkCount() * cDocInChunk;

        ULONG nChunksToRead = min( _frmwrkParams.GetMaxQueueChunks() / 2,
                                   _changeLog.AvailChunkCount() );

        ULONG nChunksRead =  _changeLog.DeSerialize( _serializedList,
                                                     nChunksToRead );
        Win4Assert( nChunksRead == nChunksToRead );

        _pFirstUnFiltered = _serializedList.GetFirst();
        Win4Assert( 0 != _pFirstUnFiltered );
        _oRetrieve = 0;
    }
    CheckInvariants("LokInit post");
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::~CDocQueue, public
//
//  History:    11-Oct-93       BartoszM        Created
//              10-Feb-94       DwightKr        Added code to save to disk
//
//----------------------------------------------------------------------------

CDocQueue::~CDocQueue()
{
    CheckInvariants("CDocQueue dtor");

    ciDebugOut (( DEB_ITRACE, "CDocQueue\n" ));

    //
    // _cRefiledDocs may be non-zero, but that isn't a problem, since
    // the updates are still sitting on disk.  They are likely here
    // because FilterReady got an exception from WorkIdToPath() as CI
    // is shutting down, and the docs were refiled.
    //
    //
    // Win4Assert( 0 == _cRefiledDocs );
    //
}


//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::LokCleanup
//
//  Synopsis:   Cleans up the private data members.
//
//  History:    27-Dec-94       SrikantS        Moved from ~ctor
//
//----------------------------------------------------------------------------
void CDocQueue::LokCleanup()
{
    CheckInvariants("LokCleanup");
    _serializedList.DestroyUpto( 0 );
    _unserializedList.DestroyUpto( 0 );
    _cDocuments = _cFilteredChunks = 0;
    _oAppend = _oRetrieve = cDocInChunk;
    _pFirstUnFiltered = 0;
    _cRefiledDocs = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::LokEmpty, public
//
//  History:    15-Nov-94   DwightKr    Created
//
//----------------------------------------------------------------------------
void CDocQueue::LokEmpty()
{
    LokCleanup();
    _changeLog.LokEmpty();
}


//+---------------------------------------------------------------------------
//
//  Function:   LokDismount
//
//  Synopsis:   Prepares for the dismount by serializing the changelog.
//
//  History:    6-20-94   srikants   Created
//
//  Notes:      This routine should not throw, since we may be looping
//              to dismount multiple partitions on a single volume.
//              This avoids an outer TRY/CATCH block, and we really can't
//              do anything to correct a failed dismount.
//
//----------------------------------------------------------------------------
NTSTATUS CDocQueue::LokDismount( CChangeTrans & xact )
{
    NTSTATUS status = STATUS_SUCCESS;

    TRY
    {

#ifdef CI_FAILTEST
        NTSTATUS failstatus = STATUS_NO_MEMORY ;
        ciFAILTEST( failstatus  );
#endif // CI_FAILTEST

        if ( _changeLog.AreUpdatesEnabled() )
        {
            if ( 0 != _cRefiledDocs )
                LokAppendRefiledDocs( xact );

            if ( !_unserializedList.IsEmpty() )
            {
                Serialize(0);
            }
        }
    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                     "ChangeLog could not be written out due to error 0x%X\n",
                     e.GetErrorCode() ));

        status = e.GetErrorCode();
    }
    END_CATCH

    //
    // Even if the dismount failed, we must clean up our internal
    // data structures.
    //
    LokCleanup();

    //
    // Should not accept any more update notifications.
    //
    _changeLog.LokDisableUpdates();

    return status;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::Append, public
//
//  Synopsis:   Appends documents to the queue
//
//  Arguments:  [wid]          -- work id
//              [usn]          -- update sequence number
//              [volumeId]     -- volume id
//              [action]       -- update/delete
//              [cRetries]     -- number of retries on this item
//              [cSecQRetries] -- number of Sec Q retries on this item
//
//  History:    11-Oct-93       BartoszM        Created
//
//  Notes:      The RESMAN lock was taken before this method was called.
//
//----------------------------------------------------------------------------
SCODE CDocQueue::Append ( CChangeTrans & xact,
                          WORKID wid,
                          USN usn,
                          VOLUMEID volumeId,
                          ULONG action,
                          ULONG cRetries,
                          ULONG cSecQRetries )
{
    CheckInvariants("Append pre");

    // The first try is 1.  The first retry is 2

    Win4Assert( cRetries <= ( _frmwrkParams.GetFilterRetries() + 1 ) );
    Win4Assert( 0 != cRetries );
    
    // check for corrupted values, either wid is invalid or action must make sense
    Win4Assert( wid == widInvalid ||
                (action & CI_UPDATE_OBJ) != 0 ||
                (action & CI_UPDATE_PROPS) != 0 ||
                (action & CI_DELETE_OBJ) != 0 );

    Win4Assert( 0 != wid );

    Win4Assert( ((wid & 0x80000000) == 0) || (wid == widInvalid) );

    //
    // If we have disabled updates, then don't bother saving this
    // filter request. If updates are disabled, we will schedule an
    // EnableUpdates at a later time to discover all of the lost updates.
    // In push filtering, there is no internal refiling and so any appends
    // are always from client.
    // In pull filtering, the in-memory part of changelog is cleaned up,
    // and the in-memory part of changelog is re-initialized on startup.
    // Hence appends can be ignored for both push and pull filtering
    // when _fUpdatesEnabled is false.
    //
    if ( !_changeLog.AreUpdatesEnabled() )
        return CI_E_UPDATES_DISABLED;

    //
    // Check if the current append chunk is full.
    //
    if ( IsAppendChunkFull() )
    {
        //
        // Before allocating a new one, see if we have exceeded the
        // threshold of maximum chunks in memory and serialize
        // the list appropriately.
        //
        ULONG cTotal = _serializedList.Count() + _unserializedList.Count();

        ULONG MaxQueueChunks = _frmwrkParams.GetMaxQueueChunks();

        ciDebugOut(( DEB_ITRACE, "ctotal %d, maxqueuechunks %d\n",
                     cTotal, MaxQueueChunks ));

        if ( cTotal >= MaxQueueChunks )
        {
            Serialize( MaxQueueChunks / 2 );
        }

        //
        // Allocate a new chunk and append to the unserialized list.
        //
        CDocChunk * pChunk = new CDocChunk();
        _unserializedList.Append( pChunk );
        _oAppend = 0;
    }

    //
    //  OPTIMIZATION to avoid processing the same wid (eg temp files)
    //  in the same chunk.
    //
    //  Insert this record so that it overwrites the first entry with the
    //  same WID within this chunk.  This results in the extraction procedure
    //  to process the WID with the last STATUS received in this chunk.
    //
    CDocChunk * pLastChunk = _unserializedList.GetLast();
    Win4Assert( 0 != pLastChunk );
    CDocNotification * pAppend = pLastChunk->GetDoc( _oAppend );
    pAppend->Set ( wid, usn, volumeId, action, cRetries, cSecQRetries );

    CDocNotification * pRec;

    //
    //  A special case exists if we are have inserted a record into the chunk
    //  from which we are extracting records.  We need to search from the
    //  current read point forward, rather than from the start of the chunk.
    //
    if ( _pFirstUnFiltered == pLastChunk )
    {
        //
        // Note that if _oRetrieve is cDocInChunk, then we would have
        // created a new chunk and _pFirstUnFiltered would not be same
        // as pLastChunk.
        //
        pRec = pLastChunk->GetDoc(_oRetrieve); // Starting search location
    }
    else
    {
        pRec = pLastChunk->GetDoc(0);          // Starting search location
    }

    //
    // Since we have added the current wid as a sentinel value, it is
    // guaranteed to terminate.
    //
    while (pRec->Wid() != wid )
       pRec++;

    if (pRec == pAppend)          //  This will be true 99% of the time
    {
       _oAppend++;
       _cDocuments++;
    }
    else                           // Overwrite the WID found
    {
       Win4Assert( wid == pRec->Wid() );
       pRec->Set ( wid, usn, volumeId, action, cRetries, cSecQRetries );
    }

    if ( 0 == _pFirstUnFiltered )
    {
        _pFirstUnFiltered = pLastChunk;
        _state = eUseUnSerializedList;
        _oRetrieve = 0;
        Win4Assert( _cDocuments == 1 && _oAppend == 1 );
    }

    if ( pLastChunk == _pFirstUnFiltered )
    {
        Win4Assert( _cDocuments == (_oAppend - _oRetrieve) );
    }

    Win4Assert( _changeLog.AvailChunkCount() * cDocInChunk <= _cDocuments );

#ifdef CI_FAILTEST
        ciFAILTEST( STATUS_DISK_FULL  );
#endif // CI_FAILTEST

    CheckInvariants("Append post");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::Get
//
//  Synopsis:   Get top of the queue.  Items are not removed from the queue.
//
//  Arguments:  [aWid]  -- Array of wids
//              [cWid]  -- Count of wids in array, updated on return
//
//  Returns:    TRUE if all items in the queue were returned.
//
//  History:    23-May-94       SrikantS        Created
//
//----------------------------------------------------------------------------

BOOL CDocQueue::Get( WORKID * aWid, unsigned & cWid )
{
    CheckInvariants("Get");

    //
    // We can't refile w/o a transaction, so just return FALSE,
    // and if there are too many we won't bother to return any.
    //

    if ( (0 != _cRefiledDocs) ||
         (_cDocuments > cWid) ||
         !_changeLog.AreUpdatesEnabled() )
    {
        cWid = 0;
        return( FALSE );
    }

    //
    // Get documents from in-memory list
    //

    CDocChunk * pChunk = _pFirstUnFiltered;
    Win4Assert( 0 != _pFirstUnFiltered || 0 == _cDocuments );

    unsigned iDocInChunk = _oRetrieve;

    for ( cWid = 0; cWid < _cDocuments; cWid++ )
    {
        if ( iDocInChunk == cDocInChunk )
        {
            pChunk = pChunk->GetNext();
            iDocInChunk = 0;

            if ( 0 == pChunk )
                break;
        }

        aWid[cWid] = pChunk->GetDoc(iDocInChunk)->Wid();
        iDocInChunk++;
    }

    //
    // We may not have got all the documents.  This occurs when we're using
    // the serialized list and don't have all the documents available in
    // memory.  (We do try to keep a reasonable number of docs in memory)
    //

    return ( cWid == _cDocuments );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::Extract, public
//
//  Synopsis:   Extract top of the queue
//
//  Arguments:  [xact]    -- transaction
//              [maxDocs] -- size of doclist
//              [docList] -- doc list to be filled. It will NOT have any
//                           duplicate WID entries. The last entry for a wid
//                           will supercede all other entries before it.
//
//  History:    11-Oct-93       BartoszM        Created
//              16-May-94       SrikantS        Modified to make it a
//                                              transaction.
//
//  Notes:      This function must be called under resman lock.
//
//----------------------------------------------------------------------------
void CDocQueue::Extract( CChangeTrans & xact,
                         unsigned maxDocs,
                         CDocList & docList)
{
    CheckInvariants("Extract pre");

    //
    // If there are any documents that got requeued due to a failure
    // after they were extracted, we must append to the list before
    // extracting the documents.
    //
    if ( 0 != _cRefiledDocs )
    {
        LokAppendRefiledDocs( xact );
    }


    //
    // If we are not saving updates, then don't return any docs to
    // filter.
    //
    if ( !_changeLog.AreUpdatesEnabled() )
    {
        docList.LokSetCount(0);
        return;
    }

    //
    // BeginTransaction
    //
    CExtractDocs    extractDocs( *this, docList );

    unsigned i = 0;
    while ( (i < maxDocs) && !extractDocs.IsEmpty() )
    {
        WORKID   wid;
        USN      usn;
        VOLUMEID volumeId;
        ULONG    action;
        ULONG    cRetries;
        ULONG    cSecQRetries;

        extractDocs.Retrieve( wid, usn, volumeId, action, cRetries, cSecQRetries );

        if (widInvalid != wid)
        {
            //
            // If the wid already exists in the doclist, we should overwrite
            // that with this one. The last entry in the changelog for the
            // same wid always wins.
            //

            //
            // This is currently an N^2 algorithm.  See if there
            // is a better algorithm if it shows up in profiling.  It hasn't
            // in the past.  Note that there will only be 16 items here
            // so the algorithm choice doesn't matter too much.
            //

            for ( unsigned j = 0; j < i; j++ )
            {
                if ( docList.Wid(j) == wid )
                    break;
            }

            // check for corrupted values
            Win4Assert( action == CI_UPDATE_OBJ ||
                        action == CI_UPDATE_PROPS ||
                        action == CI_DELETE_OBJ );

            docList.Set( j,
                         wid,
                         usn,
                         volumeId,
                         (action == CI_DELETE_OBJ) ? DELETED : PENDING,
                         cRetries,
                         cSecQRetries
                       );

            if ( j == i )
            {
                // New Wid. Increment the count of entries
                i++;
            }
            else
            {
                ciDebugOut(( DEB_PENDING | DEB_ITRACE,
                             "Duplicate wid=0x%X overwritten by action=0x%X\n",
                             wid, action ));
            }
        }
    }

    CheckInvariants("Extract pre-commit");
    docList.LokSetCount(i);
    extractDocs.Commit();   // EndTransaction
    CheckInvariants("Extract post");
} //Extract

//+---------------------------------------------------------------------------
//
//  Function:   MoveToSerializedList
//
//  Synopsis:   Skips the chunks in the listToCompact in the change log and
//              appends them to the _serializedList, up to the maximum
//              permitted by the "nMaxChunksInMem" parameter.  This will
//              prevent un-necessarily reading the serialized chunks that are
//              already in memory.
//
//              The rest of the chunks are deleted and will have to be
//              de-serialized at a later time because they cannot be held in
//              memory now.
//
//  Effects:    The listToCompact will be emptied when this returns.
//
//  Arguments:  [listToCompact] -- The list which needs to be compacted.
//              [nChunksToMove] -- Maximum number of chunks that must be
//                                 left in memory (suggested).
//
//  History:    6-06-94   srikants   Created
//
//----------------------------------------------------------------------------

void CDocQueue::MoveToSerializedList( CChunkList & listToCompact,
                                      ULONG nChunksToMove )
{
    //
    // Until the count in the serializedlist is less than the
    // maximum allowed, we transfer from the listToCompact
    // to the serialized list.
    //
    while ( ( nChunksToMove > 0 ) &&
            (0 != listToCompact.GetFirst()) )
    {
        CDocChunk * pChunk = listToCompact.Pop();
        Win4Assert( 0 != pChunk );
        _serializedList.Append(pChunk);
        _changeLog.SkipChunk();
        nChunksToMove--;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SerializeInLHS
//
//  Synopsis:   Serializes the unserialized chunks when we are retrieving
//              from the "Left Hand Side" of the change log, ie, in the
//              "eUseSerializedList" state.
//
//  Effects:    The unserializedList is emptied and appropriate number of
//              chunks appended to the end of the serialized list.
//
//  Arguments:  [nMaxChunksInMem] --   Suggested maximum number of chunks that
//                                     must be left in memory after doing the
//                                     serialization.
//              [aUsnFlushInfo]   --   Usn flush info is returned here
//
//  History:    6-06-94   srikants   Created
//
//----------------------------------------------------------------------------

void CDocQueue::SerializeInLHS( ULONG nMaxChunksInMem,
                                CCountedDynArray<CUsnFlushInfo> & aUsnFlushInfo )
{
    CheckInvariants("SerializeInLHS pre");

    Win4Assert( eUseSerializedList == _state );
    Win4Assert( _pFirstUnFiltered == _serializedList.GetFirst() );

    //
    // Delete all the filtered chunks.
    //

    ULONG   cChunkInLogBefore = _changeLog.AvailChunkCount();
    _changeLog.Serialize( _unserializedList, aUsnFlushInfo );

    ULONG nChunksToMove = 0;
    if ( _serializedList.Count() < nMaxChunksInMem )
    {
        nChunksToMove = nMaxChunksInMem - _serializedList.Count();
    }

    CChunkList listToCompact;
    listToCompact.AcquireAndAppend( _unserializedList );

    if ( 0 == cChunkInLogBefore  )
    {
        //
        // We can move as much of the listToCompact to the serialized
        // list as possible.
        //
        MoveToSerializedList( listToCompact, nChunksToMove );
    }
    else
    {
        //
        // Optimization - instead of deleting the unserialized list and
        // then reading them, we will see if we can fit the unserialized list
        // chunks in memory without having to exceed the memory threshold.
        //
        if ( cChunkInLogBefore < nChunksToMove )
        {
            //
            // We have to deserialize the change log because chunks
            // have to be consumed in the FIFO order strictly.
            // Since there can be a failure while doing the deserialization,
            // we must not leave the docqueue in an inconsistent
            // state - the unSerializedList must be empty.
            //
            _changeLog.DeSerialize( _serializedList, cChunkInLogBefore );
            nChunksToMove -= cChunkInLogBefore;
            MoveToSerializedList( listToCompact, nChunksToMove );
        }

    }

    Win4Assert( _unserializedList.IsEmpty() );

    //
    // After we serialize, we must start using a new chunk for doing
    // appends.
    //
    Win4Assert( _oAppend <= cDocInChunk );
    _cDocuments += (cDocInChunk-_oAppend);
    _oAppend = cDocInChunk;

    Win4Assert( (_oAppend - _oRetrieve) == (_cDocuments % cDocInChunk) ||
                ((_oAppend - _oRetrieve) == cDocInChunk &&
                (_cDocuments % cDocInChunk) == 0) );
    Win4Assert( _changeLog.AvailChunkCount() * cDocInChunk <= _cDocuments );
    Win4Assert( 0 != _pFirstUnFiltered || 0 == _cDocuments );

    CheckInvariants("SerializeInLHS post");
}

//+---------------------------------------------------------------------------
//
//  Function:   SerializeInRHS
//
//  Synopsis:   Serializes the un-serialized list when we are retrieving
//              from the "Right Hand Side" of the change-log, ie, we are
//              in the "eUseUnSerializedList" state.
//
//  Effects:    The _unSerializedList will be emptied and appropriate
//              number of chunks appended to the _serializedList.
//
//  Arguments:  [nChunksToMove] --  Maximum number of chunks permitted
//                                  in memory (suggested).
//              [aUsnFlushInfo] --  Usn flush info is returned here
//
//  History:    6-06-94   srikants   Created
//
//----------------------------------------------------------------------------

inline void CDocQueue::SerializeInRHS( ULONG nChunksToMove,
                                       CCountedDynArray<CUsnFlushInfo> & aUsnFlushInfo )
{
    CheckInvariants("SerializeInRHS pre");

    //
    // We are using the unserialized list. The change log must be
    // empty and the serialized list must also be empty.
    //
    Win4Assert( eUseUnSerializedList == _state );
    Win4Assert( _changeLog.IsEmpty() );
    Win4Assert( _serializedList.IsEmpty() );

    //
    // Write the unserialized list to disk and keep as much of
    // it as possible.
    //
    _changeLog.Serialize( _unserializedList, aUsnFlushInfo );

    //
    // Skip up to the _pFirstUnFiltered and delete them.
    //
    while ( _unserializedList.GetFirst() != _pFirstUnFiltered )
    {
        CDocChunk * pDelete = _unserializedList.Pop();
        delete pDelete;
        _changeLog.SkipChunk();
    }

    //
    // Keep as much of the remaining unserialized list in memory
    // as possible.
    //
    CChunkList listToCompact;
    listToCompact.AcquireAndAppend( _unserializedList );
    BOOL fInLastChunk = FALSE;

    if ( 0 != _pFirstUnFiltered )
    {
        //
        // We MUST have at least one chunk (the _pFirstUnFiltered) in memory.
        //
        Win4Assert( listToCompact.GetFirst() == _pFirstUnFiltered );
        nChunksToMove = max(nChunksToMove, 1);
        fInLastChunk = _pFirstUnFiltered == listToCompact.GetLast();
    }

    MoveToSerializedList( listToCompact, nChunksToMove );

    _state = eUseSerializedList;

    //
    // After we serialize, we must start using a new chunk for doing
    // appends.
    //
    Win4Assert( _oAppend <= cDocInChunk );
    if ( fInLastChunk && (_oAppend == _oRetrieve) )
    {
        //
        // We have filtered all the documents. After serialization, we will
        // start using a new chunk for appending new documents. We should
        // consider this chunk fully filtered.
        //
        Win4Assert( 0 == _cDocuments );
        _serializedList.DestroyUpto(0);
        if ( cDocInChunk != _oRetrieve )
        {
            //
            // The filtered chunk count should be incremented because we have
            // skipped a few documents in the current chunk without filtering
            // but have considered them to be filtered.
            //
            _cFilteredChunks++;
        }
        _oAppend = _oRetrieve = cDocInChunk;
        _pFirstUnFiltered = 0;
    }
    else
    {
        _cDocuments += (cDocInChunk-_oAppend);
        _oAppend = cDocInChunk;

        Win4Assert( _changeLog.AvailChunkCount() * cDocInChunk <= _cDocuments );
    }

    Win4Assert( (_oAppend - _oRetrieve) == (_cDocuments % cDocInChunk) ||
                ((_oAppend - _oRetrieve) == cDocInChunk &&
                (_cDocuments % cDocInChunk) == 0) );
    Win4Assert( 0 != _pFirstUnFiltered || 0 == _cDocuments );
    CheckInvariants("SerializeInRHS post");
}

//+---------------------------------------------------------------------------
//
//  Function:   Serialize
//
//  Synopsis:   Serializes the _unSerialized list to disk, moves some of the
//              chunks (as permitted nChunksToMove) to the _serializedList
//              and frees up the remaining chunks.
//
//  Arguments:  [nChunksToMove] -- Suggested maximum number of chunks in
//                                 memory.
//
//  History:    6-06-94   srikants   Created
//
//----------------------------------------------------------------------------

void CDocQueue::Serialize( ULONG nMaxChunksInMem )
{
    CheckInvariants("Serialize pre");
    //
    // Get the current system time which will be used as the flush time
    //
    FILETIME ftFlush;
    GetSystemTimeAsFileTime( &ftFlush );

    CCountedDynArray<CUsnFlushInfo> aUsnFlushInfo;

    if ( eUseSerializedList == _state )
    {
        //
        // Delete the serialized list up to the first unfiltered chunk.
        //
        _serializedList.DestroyUpto( _pFirstUnFiltered );
        SerializeInLHS( nMaxChunksInMem, aUsnFlushInfo );
    }
    else
    {
#if DBG
        if ( _oRetrieve != cDocInChunk )
        {
            Win4Assert( _pFirstUnFiltered != 0 );
            Win4Assert( _pFirstUnFiltered != _serializedList.GetFirst() );
        }
#endif // DBG

        //
        // We don't need any of the chunks in the serialized list to be
        // in memory.
        //
        _serializedList.DestroyUpto( 0 );
        SerializeInRHS( nMaxChunksInMem, aUsnFlushInfo );
    }

    Win4Assert( _pResManager );

    if ( _changeLog.IsPrimary() )
        _pResManager->NotifyFlush( ftFlush,
                                   aUsnFlushInfo.Count(),
                                   (USN_FLUSH_INFO **) aUsnFlushInfo.GetPointer() );

    Win4Assert( _unserializedList.IsEmpty() );
    CheckInvariants("Serialize post");
}

//+---------------------------------------------------------------------------
//
//  Function:   DeSerialize
//
//  Synopsis:   Reads the appropriate number of serialized chunks from
//              change log into memory.
//
//  History:    6-01-94   srikants   Redesigned.
//
//----------------------------------------------------------------------------

void CDocQueue::DeSerialize()
{
    CheckInvariants("DeSerialize pre");

    Win4Assert( eUseSerializedList == _state );
    Win4Assert( !_changeLog.IsEmpty() );

    //
    // Delete all the filtered chunks.
    //
    _serializedList.DestroyUpto( _pFirstUnFiltered );

    //
    // First figure out how many chunks can be deserialized.
    //
    ULONG MaxQueueChunks = _frmwrkParams.GetMaxQueueChunks();
    ULONG nChunksToRead = min( MaxQueueChunks / 2,
                               _changeLog.AvailChunkCount() );

    ULONG nChunksInMem = _serializedList.Count() + _unserializedList.Count();
    const ULONG nMaxChunksInMem = MaxQueueChunks / 2;

    if ( nChunksToRead + nChunksInMem > nMaxChunksInMem )
    {

        //
        // If we go ahead and de-serialize nChunksToRead, we will exceed
        // the maximum threshold. We will first serialize the
        // un-serialized documents and free up some memory.
        //

        if ( 0 != _unserializedList.Count() )
        {
            //
            // Get the current system time which will be used as the flush time
            //
            FILETIME ftFlush;
            GetSystemTimeAsFileTime( &ftFlush );

            CCountedDynArray<CUsnFlushInfo> aUsnFlushInfo;

            ULONG nChunksToLeave = nMaxChunksInMem - nChunksToRead;
            SerializeInLHS( nChunksToLeave, aUsnFlushInfo );

            Win4Assert( _pResManager );

            if ( _changeLog.IsPrimary() )
                _pResManager->NotifyFlush( ftFlush,
                                           aUsnFlushInfo.Count(),
                                           (USN_FLUSH_INFO **) aUsnFlushInfo.GetPointer() );
        }

        Win4Assert( _unserializedList.Count() == 0 );
        nChunksInMem = _serializedList.Count();
        if ( nChunksInMem >= nMaxChunksInMem )
        {
            //
            // This is the special case where the number of docs in CDocList
            // is > the MaxQueueChunks and this is to allow progress.
            //
            ciDebugOut(( DEB_ITRACE,
                "CDocQueue: Too many chunks in memory: %d\n", nChunksInMem ));
            nChunksToRead = 1;
        }
        else
        {
            nChunksToRead = min( nChunksToRead,
                                 nMaxChunksInMem-nChunksInMem );
        }
    }

    Win4Assert( nChunksToRead > 0 );
    _changeLog.DeSerialize( _serializedList, nChunksToRead );
    _state = eUseSerializedList;

    CheckInvariants("DeSerialize post");
}

//+---------------------------------------------------------------------------
//
//  Function:   LokDeleteWIDsInPersistentIndexes
//
//  Synopsis:   Deletes the workIds that have been filtered and have already
//              made it into a persistent index. This causes the change log
//              to be shrinked from the front.
//
//  Arguments:  [xact]             -- Change transaction to use
//              [freshTestLatest]  -- Latest freshTest
//              [freshTestAtMerge] -- Fresh test snapshoted at time of shadow
//                                    merge (can be same as freshTestLatest)
//              [docList]          -- Doc list
//              [notifTrans]       -- Notification transaction
//
//  Algorithm:  Documents are always processed in the FIFO order in the
//              change log. If a document is not successfully filtered, it
//              is appened as a new entry to the change log. If the order
//              in change log is say A, B, C, D .. then if D has made it into
//              persistent index, we can be sure that either all of A, B
//              and C have made it into persistent index or they have been
//              re-added to the change log. In either case, it is fine to
//              delete up to D.
//
//  History:    6-01-94      srikants    Created
//              24-Feb-97    SitaramR    Push filtering
//
//----------------------------------------------------------------------------

void CDocQueue::LokDeleteWIDsInPersistentIndexes( CChangeTrans & xact,
                                                  CFreshTest & freshTestLatest,
                                                  CFreshTest & freshTestAtMerge,
                                                  CDocList & docList,
                                                  CNotificationTransaction & notifTrans )
{
    CheckInvariants("LokDeleteWIDsInPersistentIndexes pre");

    //
    // First serialize everything and leave at most MAX_QUEUE_CHUNKS in
    // memory.  Serialization is necessary to make sure that the docs which
    // were re-added due to filter failures are persistently recorded in
    // the change log.
    //
    Serialize( _frmwrkParams.GetMaxQueueChunks() );

    ULONG  cChunksTruncated =
        _changeLog.LokDeleteWIDsInPersistentIndexes( _cFilteredChunks,
                                                     freshTestLatest,
                                                     freshTestAtMerge,
                                                     docList,
                                                     notifTrans );

    Win4Assert( cChunksTruncated <= _cFilteredChunks );
    _cFilteredChunks -= cChunksTruncated;
    CheckInvariants("LokDeleteWIDsInPersistentIndexes post");
}

//+---------------------------------------------------------------------------
//
//  Function:   LokRefileDocs
//
//  Synopsis:   Refiles the documents with the change list. This method
//              is called to add documents that could not be successfully
//              filtered back to the change list.
//
//  Arguments:  [docList] -- Contains the documents to be added back to
//              the change list.
//
//  Algorithm:  All documents with status != WL_IGNORE will be added back
//              to the change list. If the status is DELETED, then it will
//              be considered to be a deleted document. O/W, it will be
//              treated as a "Update".
//
//  History:    10-24-94      srikants     Created
//              24-Feb-97     SitaramR     Push filtering
//
//  Notes:      When this method is called, there must be no outstanding
//              documents to be refiled. DocQueue can deal with at most one
//              outstanding set of refiled documents.
//
//----------------------------------------------------------------------------

void CDocQueue::LokRefileDocs( const CDocList & docList )
{
    CheckInvariants("LokRefileDocs pre");
    Win4Assert( 0 == _cRefiledDocs );
    Win4Assert( docList.Count() <= CI_MAX_DOCS_IN_WORDLIST );

    for ( unsigned i = 0 ; i < docList.Count(); i++ )
    {
        //
        // If the document has already made into a wordlist, DON'T
        // refile it. The current code has potential for infinite looping
        // behavior. We must NEVER refile a "deleted" document. Consider
        // the following sequence for a document
        //
        //  ---------------------------------------------
        //  | chunk1     |     chunk2     |     refiled |
        //  ---------------------------------------------
        //  |  D1        |       U2       |        ?    |
        //  ---------------------------------------------

        //  The document got deleted and then recreated. If we refile D1
        //  as a deletion, the U2 will be superceded by the deletion.
        //  Instead, we will just mark the refiled deletion as an update.
        //  If the document is not recreated when we go to filter it,
        //  the "Wid->Path" will fail and will then be considered (correctly)
        //  as a deletion. O/W, we will filter it as an update.
        //

        _aRefiledDocs[_cRefiledDocs].Set( docList.Wid(i),
                                          0,        // 0 usn for refiled docs
                                          docList.VolumeId(i),
                                          CI_UPDATE_OBJ,
                                          docList.Retries(i),
                                          docList.SecQRetries(i)
                                         );
        _cRefiledDocs++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LokAppendRefiledDocs
//
//  Synopsis:   Appends the documents in the refiled set to the change list.
//
//  Arguments:  [xact] -- Transaction for this operation
//
//  History:    10-24-94   srikants   Created
//
//----------------------------------------------------------------------------

void CDocQueue::LokAppendRefiledDocs( CChangeTrans & xact )
{
    CheckInvariants("LokAppendRefiledDocs pre");

    //
    // If the refiled doclist is not empty, we must append those
    // documents.
    //
    const unsigned cDocsToRefile = _cRefiledDocs;
    _cRefiledDocs = 0;

    for ( unsigned i = 0; i < cDocsToRefile ; i++ )
    {
        const CDocNotification & docInfo = _aRefiledDocs[i];

        ciDebugOut(( DEB_ITRACE,
                     "CDocQueue: Refiling WID: 0x%X Action: %d\n",
                     docInfo.Wid(),
                     docInfo.Action() ));

        Win4Assert( docInfo.Usn() == 0 );

        Append( xact,
                docInfo.Wid(),
                docInfo.Usn(),
                docInfo.VolumeId(),
                docInfo.Action(),
                docInfo.Retries(),
                docInfo.SecQRetries() );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::LokDisableUpdates
//
//  Synopsis:   Disables further updates
//
//  History:    27-Dec-94       SrikantS        Created
//              24-Feb-97       SitaramR        Push filtering
//
//----------------------------------------------------------------------------
void CDocQueue::LokDisableUpdates()
{
    if ( !_changeLog.FPushFiltering() )
    {
        //
        // In pull (i.e. not push) filtering, clean up the in-memory datastructure
        // because they will be re-notified by the client when updates are
        // enabled
        //
        LokCleanup();
    }

    _changeLog.LokDisableUpdates();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::LokEnableUpdate
//
//  Synopsis:   Enables updates and change log processing.
//
//  Arguments:  [fFirstTimeUpdatesAreEnabled]  -- Is this being called for the
//                                                first time ?
//
//  History:    27-Dec-94       SrikantS        Created
//              24-Feb-97       SitaramR        Push filtering
//
//----------------------------------------------------------------------------
void CDocQueue::LokEnableUpdates( BOOL fFirstTimeUpdatesAreEnabled )
{
    _changeLog.LokEnableUpdates( fFirstTimeUpdatesAreEnabled );

    if ( fFirstTimeUpdatesAreEnabled || !_changeLog.FPushFiltering() )
    {
        //
        // In pull (i.e. not push) filtering, re-initialize the in-memory
        // datastructure from the persistent changlog. Also, if EnableUpdates is
        // being called for the first time, then initialize the in-memory
        // datastructure (i.e. do it in the case of push filtering also).
        //
        LokInit();
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CDocQueue::LokFlushUpdates
//
//  Synopsis:   Serializes the changlog
//
//  History:    27-Jun-97       SitaramR        Created
//
//----------------------------------------------------------------------------

void CDocQueue::LokFlushUpdates()
{
    Serialize( _frmwrkParams.GetMaxQueueChunks() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\freshcur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2001.
//
//  File:   FRESHCUR.CXX
//
//  Contents:   Fresh Cursor
//
//  Classes:    CFreshCursor
//
//  History:    16-May-91   BartoszM    Created.
//              28-Feb-92   AmyA        Added HitCount()
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "freshcur.hxx"
#include "fresh.hxx"
#include "fretest.hxx"
#include "resman.hxx"
#include "indsnap.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CFreshCursor::LoadWorkId, private
//
//  Synopsis:   Load current wid and occurrence
//
//  History:    16-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

__forceinline void CFreshCursor::LoadWorkId ()
{
    _wid = _cur->WorkId();

    if ( widInvalid == _wid )
        return;

    _iid = _cur->IndexId();
    _pid = _cur->Pid();

    while ( _indSnap.GetFresh()->IsCorrectIndex( _iid, _wid ) ==
            CFreshTest::Invalid )
    {
        _wid = _cur->NextWorkId();

        if ( widInvalid == _wid )
            return;

        _iid = _cur->IndexId();
    }

    _pid = _cur->Pid();
} //LoadWorkId

//+---------------------------------------------------------------------------
//
//  Member:     CFreshCursor::CFreshCursor, public
//
//  Synopsis:   Create a sursor that merges a number of cursors.
//
//  Arguments:  [cur] -- cursor to be pruned
//
//  History:    16-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

CFreshCursor::CFreshCursor( XCursor & cur, CIndexSnapshot& indSnap )
        : _cur( cur ),
          _indSnap ( indSnap ) // acquire it
{
    LoadWorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreshCursor::WorkIdCount, public
//
//  Synopsis:   return wid count
//
//  Expects:    cursor positioned after key
//
//  History:    21-Jun-91   BartoszM    Created
//              15-Jul-92   KyleP       Call doesn't make sense.
//
//----------------------------------------------------------------------------

ULONG CFreshCursor::WorkIdCount()
{
    ciAssert (( FALSE && "CFreshCursor::WorkIdCount called" ));

    return ( 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreshCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    16-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

WORKID CFreshCursor::WorkId()
{
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreshCursor::NextWorkId, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  Effects:    Changes current IndexId.
//
//  History:    16-May-91   BartoszM    Created
//
//  Notes:      The same work id may be returned multiple times,
//              corresponding to multiple indexes.
//
//----------------------------------------------------------------------------

WORKID       CFreshCursor::NextWorkId()
{
    _cur->NextWorkId();
    LoadWorkId();
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreshCursor::HitCount, public
//
//  Synopsis:   returns the occurrence count
//
//  Returns:    occurrence count for current wid
//
//  History:    28-Feb-92   AmyA        Created
//
//----------------------------------------------------------------------------

ULONG        CFreshCursor::HitCount()
{
    ciAssert( _wid != widInvalid );
    return _cur->HitCount();
}

void CFreshCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    _cur->RatioFinished (denom, num);
    Win4Assert( denom > 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreshCursor::Rank, public
//
//  Synopsis:   returns the rank for _cur
//
//  Returns:    rank for current wid
//
//  History:    14-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

LONG CFreshCursor::Rank()
{
    ciAssert( _wid != widInvalid );

    Win4Assert( _cur->Rank() >= 0 );
    Win4Assert( _cur->Rank() <= MAX_QUERY_RANK );
    return _cur->Rank();
}

//+-------------------------------------------------------------------------
//
//  Member:     CFreshCursor::GetRankVector, public
//
//  Effects:    Returns the weights from a vector cursor.  No effect
//              for non-vector cursors.
//
//  Arguments:  [pulVector] -- Pointer to array of ULONG into which the
//                             vector elements are returned.
//
//  Returns:    The number of elements stored in [pulVector].
//
//  History:    15-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

ULONG CFreshCursor::GetRankVector( LONG * plVector, ULONG cElements )
{
    ciAssert( _wid != widInvalid );

    return( _cur->GetRankVector( plVector, cElements ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\fresh.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       FRESH.CXX
//
//  Contents:   Fresh list
//
//  Classes:    CFresh
//
//  History:    16-May-91   BartoszM    Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <enumstr.hxx>

#include "fresh.hxx"
#include "fretest.hxx"
#include "indxact.hxx"
#include "merge.hxx"
#include "wordlist.hxx"

class CEnumWorkid;

//+---------------------------------------------------------------------------
//
//  Member:     CFresh::CFresh, public
//
//  Synopsis:   Constructor.
//
//  History:    16-May-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CFresh::CFresh ( PStorage& storage, CTransaction& xact, CPartList & partList )
        :  _storage( storage ),
           _persFresh( storage, partList ),
           _master( 0 ),
           _partList( partList )
{
    ULONG count = max( _persFresh.GetPersRecCount(), 100 );

    XPtr<CFreshTest> xMaster( new CFreshTest ( count ) );

    SFreshTable freshTable( xMaster.GetReference() );
    _persFresh.LoadFreshTest( *freshTable );

    _master = xMaster.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFresh::~CFresh, public
//
//  Synopsis:   Destructor.
//
//  History:    16-May-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CFresh::~CFresh ()
{
    delete _master;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokInit, public
//
//  Synopsis:   Empties and re-initializes the fresh test
//
//  History:    15-Nov-94   DwightKr       Created.
//
//----------------------------------------------------------------------------
void CFresh::LokInit()
{
    _persFresh.LokEmpty();

    unsigned count = 100;
    CFreshTest* newFreshTest = new CFreshTest ( count );

    LokCommitMaster( newFreshTest );
}


//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokGetFreshTest, public
//
//  Synopsis:   Creates CFreshTest object
//
//  History:    16-May-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//              FreshTest has to be released
//
//----------------------------------------------------------------------------

CFreshTest* CFresh::LokGetFreshTest()
{
    ciDebugOut (( DEB_ITRACE, ">> get fresh test\n"));
    _master->Reference();
    return _master;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokReleaseFreshTest, public
//
//  Synopsis:   Dereferences CFreshTest object
//
//  History:    16-May-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CFresh::LokReleaseFreshTest( CFreshTest* test )
{
    ciDebugOut (( DEB_ITRACE, "<< release fresh test\n" ));
    if ( test != 0 && test->Dereference() == 0 && test != _master )
    {
        delete test;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokCommitMaster, public
//
//  Synopsis:   Adds a new master fresh test
//
//  History:    16-May-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------
void CFresh::LokCommitMaster ( CFreshTest*  newMaster )
{
    ciDebugOut (( DEB_ITRACE, "Commit new master fresh test\n" ));
    Win4Assert ( newMaster != 0 );
    Win4Assert ( _master != 0 );

    CFreshTest* old = _master;
    _master = newMaster;

    ciDebugOut(( DEB_ITRACE, "New master (0x%x) has %u deletes\n", _master, _master->DeleteCount() ));

    if ( !old->InUse() )
    {
        delete old;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokAddIndex, public
//
//  Synopsis:   Adds new mapping iid <-> documents after filtering
//
//  Arguments:  [xact] -- transaction
//              [iid] -- index id
//              [iidDeleted] -- index id for deleted objects
//              [docList] -- list of wids
//
//  History:    16-May-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CFresh::LokAddIndex ( CIndexTrans& xact,
                           INDEXID iid, INDEXID iidDeleted,
                           CDocList& docList, CWordList const & wordList )
{
    ciDebugOut (( DEB_ITRACE, "Fresh: Adding documents, iid %lx\n", iid ));


    CFreshTest* newMaster = new CFreshTest ( *_master );
    xact.LogFresh ( newMaster );

    unsigned cDocuments = docList.Count();

    for ( unsigned i = 0; i < cDocuments; i++ )
    {
        STATUS status = docList.Status(i);
        if ( status == SUCCESS )
        {
            WORKID wid = docList.Wid(i);
            ciDebugOut (( DEB_FRESH, "Fresh wid %ld, iid %lx\n", wid, iid ));

#if CIDBG==1
            Win4Assert( widInvalid != wid &&
                        wordList.IsWorkIdPresent( wid ) );
#endif  // CIDBG==1

            newMaster->AddReplace ( wid, iid );
        }
        else if ( status == DELETED || status == WL_NULL )
        {
            WORKID wid = docList.Wid(i);
            ciDebugOut (( DEB_FRESH, "Fresh wid %ld deleted \n", wid ));
            newMaster->AddReplaceDelete ( wid, iidDeleted );
        }
        else
        {
            ciDebugOut (( DEB_FRESH,
                          "Fresh wid %ld, not changed. Status 0x%X\n",
                          docList.Wid(i), status ));
#if CIDBG==1
            Win4Assert( !wordList.IsWorkIdPresent( docList.Wid(i)) );
#endif  // CIDBG==1

        }
    }

    newMaster->ModificationsComplete();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokDeleteDocuments, public
//
//  Synopsis:   Mark documents as deleted
//
//  Arguments:  [xact] -- transaction
//              [docList] -- list of wids
//              [iidDeleted] -- index id for deleted objects
//
//  History:    16-May-91   BartoszM       Created.
//              12-Jun-97   KyleP          Track unlogged deletions
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CFresh::LokDeleteDocuments( CIndexTrans& xact,
                                 CDocList& docList,
                                 INDEXID iidDeleted )
{
    ciDebugOut (( DEB_ITRACE, "Fresh: Deleting documents\n" ));

    CFreshTest* newMaster = new CFreshTest ( *_master );
    xact.LogFresh ( newMaster );

    unsigned cDocuments = docList.Count();

    for ( unsigned i = 0; i < cDocuments; i++ )
    {
        if ( docList.Status(i) == DELETED)
        {
            WORKID wid = docList.Wid(i);
            ciDebugOut (( DEB_FRESH, "Fresh wid %ld deleted \n", wid ));
            newMaster->AddReplaceDelete ( wid, iidDeleted );

        }
    }

    newMaster->ModificationsComplete();
}

//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokUpdate, public
//
//  Synopsis:   Replaces old entries with the more recent entries after merge
//
//  Arguments:  [merge]       -- Merge object
//              [xact]        -- Merge transaction
//              [newFreshLog] -- New fresh log
//              [newIid]      -- New index id
//              [cInd]        -- Count of index id's to be replaced
//              [aIidOld]     -- Array of index id's to be replaced
//              [xFreshTestAtMerge]  -- If a new fresh test that was used at
//                                      merge time is created, store in here
//
//  History:    16-May-91   BartoszM       Created.
//              01-Dec-93   DwightKr       Write changes to pers. fresh log
//              04-Oct-94   SrikantS       Support for creating a new fresh
//                                         log after merge.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------
WORKID CFresh::LokUpdate ( CMerge& merge,
                           CMergeTrans& xact,
                           CPersFresh & newFreshLog,
                           INDEXID newIid,
                           int cInd,
                           INDEXID aIidOld[],
                           XPtr<CFreshTest> & xFreshTestAtMerge )
{
    ciDebugOut (( DEB_ITRACE, "Fresh list: updating %d entries\n", cInd ));

    CIdxSubstitution subst (FALSE, newIid, cInd, aIidOld);

    CFreshTest * newMaster = new CFreshTest( *_master, subst );
    xact.LogFresh( newMaster );

    WORKID widNewFreshLog;

    //
    // The new memory fresh test is created by applying the transformtion on
    // the master fresh test.  We should apply the transformation for
    // persistent log on the freshtest used by the merge. If a fresh test is
    // created then we pass ownership to xFreshTestAtMerge, so that
    // LokDeleteWidsInPersistentIndex can use the newly created fresh test.
    //

    // optimization to avoid creating a new fresh test

    if ( _master == merge.GetFresh() )  
    {
        widNewFreshLog = LokBuildNewFreshLog( newMaster, newFreshLog, subst);

        newMaster->DecrementDeleteCount( _master->DeleteCount() );
    }
    else
    {
        xFreshTestAtMerge.Set( new CFreshTest( *(merge.GetFresh()), subst ) );
        widNewFreshLog = LokBuildNewFreshLog( xFreshTestAtMerge.GetPointer(),
                                              newFreshLog,
                                              subst );

        newMaster->DecrementDeleteCount( xFreshTestAtMerge->DeleteCount() );
    }

    newMaster->ModificationsComplete();

    xact.LogNewFreshLog( newMaster, widNewFreshLog );

    return widNewFreshLog;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokRemoveIndexes, public
//
//  Synopsis:   Removes indexes from table after master merge
//
//  Arguments:  [xact] -- merge transaction
//              [cInd] -- count of inexes to be removed
//              [aIidOld] -- array of index ids of obsolete indexes
//              [iidOldDeleted] -- old index id for deleted objects
//
//  History:    16-May-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

WORKID CFresh::LokRemoveIndexes( CMergeTrans& xact,
                                 CPersFresh & newFreshLog,
                                 unsigned cInd,
                                 INDEXID aIidOld[],
                                 INDEXID iidOldDeleted )
{

    ciDebugOut (( DEB_ITRACE, "FreshList: Removing indexes\n" ));

    CIdxSubstitution subst (TRUE, iidOldDeleted, cInd, aIidOld);

    XPtr<CFreshTest> xNewMaster( new CFreshTest( *_master, subst ) );

    WORKID widNewFreshLog = LokBuildNewFreshLog( xNewMaster.GetPointer(),
                                                 newFreshLog,
                                                 subst );

    // LogNewFreshLog can't fail, so the acquire is safe to do
    // before the call.

    xNewMaster->ModificationsComplete();

    xact.LogNewFreshLog( xNewMaster.Acquire(), widNewFreshLog );

    return(widNewFreshLog);
}


//+---------------------------------------------------------------------------
//
//  Function:   LokBuildNewFreshLog
//
//  Synopsis:   Builds a new persistent fresh log by combining the existing
//              fresh log and the new fresh test.
//
//  Arguments:  [newFreTest]  -- Input        - the new fresh test.
//              [newFreshLog] -- Input/Output - the new fresh log object.
//              [subst]       -- Index substitution object
//
//  Returns:    ObjectId of the new persistent fresh log created.
//
//  History:    03-Oct-94   srikants   Created
//              11-Jun-97   KyleP      Track unlogged deletions
//
//----------------------------------------------------------------------------

WORKID CFresh::LokBuildNewFreshLog( CFreshTest * newFreTest,
                                    CPersFresh & newFreshLog,
                                    CIdxSubstitution& subst )
{
    SFreshTable freshTable( *newFreTest );
    CFreshTableIter iter( *freshTable );

    //
    // Create a new persistent fresh log.
    //
    WORKID widNewFreshLog = _storage.GetNewObjectIdForFreshLog();
    _storage.InitRcovObj( widNewFreshLog, FALSE );

    PRcovStorageObj *pPersFreshLog = _storage.QueryFreshLog( widNewFreshLog );
    SRcovStorageObj PersFreshLog( pPersFreshLog );

    //
    // Inside kernel, we are guaranteed that a new object has no data in
    // it. In user space, we may be using an object that was not deleted
    // before due to a failure.
    //
    PersFreshLog->InitHeader(_storage.GetStorageVersion());

    newFreshLog.LokCompactLog( PersFreshLog, iter, subst);

    return(widNewFreshLog);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokMakeFreshLogBackup
//
//  Synopsis:   Makes a backup of the current persistent freshlog to the
//              storage provided.
//
//  Arguments:  [storage] - Destination storage.
//              [tracker] - Progress tracker and abort indication.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CFresh::LokMakeFreshLogBackup( PStorage & storage,
                                    PSaveProgressTracker & tracker,
                                    XInterface<ICiEnumWorkids> & xEnumWorkids )
{

    //
    // Create a fresh log with the same name using the storage object
    // provided.
    //

    WORKID widFreshLog  = _storage.GetSpecialItObjectId( itFreshLog );

    ULONG cRec = 0;
    //
    // Scope for physical copy of the object.
    //
    {
        //
        // Open the source fresh log
        //
        PRcovStorageObj *pSrcFreshLog = _storage.QueryFreshLog( widFreshLog );
        SRcovStorageObj xSrcFreshLog( pSrcFreshLog );

        //
        // Create the destination fresh log
        //
        PRcovStorageObj *pDstFreshLog = storage.QueryFreshLog( widFreshLog );
        SRcovStorageObj xDstFreshLog( pDstFreshLog );


        //
        // Copy the contents of the source to the destination.
        //
        CCopyRcovObject copyData( *pDstFreshLog, *pSrcFreshLog );
        NTSTATUS status = copyData.DoIt();
        if ( STATUS_SUCCESS != status )
            THROW( CException( status ) );

        CRcovStorageHdr & hdr = pSrcFreshLog->GetHeader();
        cRec = hdr.GetCount( hdr.GetPrimary() );
    }

    //
    // Get the list of WORKIDs in the persistent freshlog.
    //
    CFreshTest * pFreshTest = new CFreshTest ( max(100,cRec) );
    XPtr<CFreshTest> xFreTest( pFreshTest );

    SFreshTable freshTable( *pFreshTest );

    //
    // The source and destination persistent freshlogs are identical.
    //
    _persFresh.LoadFreshTest( *freshTable );

    //
    // Copy the workids from freshhash entries to the workid enumerator.
    //
    CEnumWorkid * pEnumWorkids = new CEnumWorkid( freshTable->Count() );
    xEnumWorkids.Set( pEnumWorkids );

    for ( CFreshTableIter iter( *freshTable ); !iter.AtEnd(); iter.Advance() )
    {
        pEnumWorkids->Append( iter->WorkId() );
    }

    Win4Assert( cRec == freshTable->Count() );
    ciDebugOut(( DEB_ITRACE, "%d Workids Changed \n", freshTable->Count() ));

}


//+---------------------------------------------------------------------------
//
//  Member:     CFresh::LokEmpty, public
//
//  Synopsis:   Empties/deletes the fresh hash and the fresh log.
//
//  History:    16-Aug-94       DwightKr        Created
//
//----------------------------------------------------------------------------
void CFresh::LokEmpty()
{
    delete _master;         // Delete the fresh test
    _master = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\freshlog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   FRESHLOG.CXX
//
//  Contents:   Fresh persistent log & snapshot
//
//  Classes:    CPersFresh, CPersStream, SPersStream, CPersFreshTrans
//
//  History:    93-Nov-15   DwightKr    Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pstore.hxx>
#include <dynstrm.hxx>
#include <freshlog.hxx>

#include "fresh.hxx"
#include "partlst.hxx"
#include "partn.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CPersFresh::LokEmpty, public
//
//  Synopsis:   Empties the fresh log
//
//  History:    94-Nov-15   DwightKr       Created.
//
//----------------------------------------------------------------------------
void CPersFresh::LokEmpty()
{
    WORKID oidFreshLog = _storage.GetSpecialItObjectId( itFreshLog );
    PRcovStorageObj *pPersFreshLog = _storage.QueryFreshLog( oidFreshLog );
    SRcovStorageObj PersFreshLog( pPersFreshLog );

    CRcovStrmWriteTrans xact( &PersFreshLog );

    PersFreshLog->GetHeader().SetCount(PersFreshLog->GetHeader().GetBackup(), 0);
    xact.Empty();

    xact.Commit();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPersFresh::LoadFreshTest, private
//
//  Synopsis:   Load the persistent log into the freshTable.
//
//  Arguments:  [freshTable] --  freshTable to load from the persistent log
//
//  History:    93-Nov-18   DwightKr       Created.
//
//----------------------------------------------------------------------------
void CPersFresh::LoadFreshTest(CFreshTable & freshTable)
{
    ciDebugOut (( DEB_ITRACE, "Loading persistent log into freshTable.\n" ));

    WORKID widFreshLog = _storage.GetSpecialItObjectId( itFreshLog );
    PRcovStorageObj *pPersFreshLog = _storage.QueryFreshLog( widFreshLog );

    SRcovStorageObj PersFreshLog( pPersFreshLog );

    CRcovStrmReadTrans xact( *pPersFreshLog );
    CRcovStrmReadIter iter( xact, sizeof(CPersRec) );

    while ( !iter.AtEnd() )
    {
        CPersRec PersRec(0,0);

        iter.GetRec( &PersRec );

#if CIDBG==1
        CIndexId iid( PersRec.GetIndexID() );

        Win4Assert( iid.IsPersistent() );

        BOOL fDeleted = iidDeleted1 == PersRec.GetIndexID() ||
                        iidDeleted2 == PersRec.GetIndexID() ;

        if ( !fDeleted )
        {
            //
            // If it is not a deleted index, the index MUST be valid.
            //
            CPartition * partn = _partList.LokGetPartition( iid.PartId() );
            Win4Assert( partn->LokIsPersIndexValid( iid ) );
        }
#endif  // CIDBG==1

        freshTable.AddReplace( PersRec.GetWorkID(), PersRec.GetIndexID() );
    }

    freshTable.ModificationsComplete();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPersFresh::GetPersRecCount
//
//  Synopsis:   Returns the count of the number of entries in the
//              freshlog.
//
//  Returns:    Number fresh entries.
//
//  History:    3-21-97   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CPersFresh::GetPersRecCount()
{
    WORKID widFreshLog = _storage.GetSpecialItObjectId( itFreshLog );
    PRcovStorageObj *pPersFreshLog = _storage.QueryFreshLog( widFreshLog );

    SRcovStorageObj PersFreshLog( pPersFreshLog );

    CRcovStorageHdr & hdr = pPersFreshLog->GetHeader();

    return hdr.GetCount( hdr.GetPrimary() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersFresh::LokCompactLog, public
//
//  Synopsis:   Compacts the freshTable into a persistent stream
//
//  Arguments:  [PersFreshLog] -- persistant log to write data to
//              [iter]  -- iterator to walk though freshTable table
//              [subst] -- index substitution object
//
//  History:    93-Dec-03   DwightKr       Created.
//              94-Sep-07   SrikantS       Corrected the bug by which entries
//                                         in the pers fresh test were lost
//                                         if a doc. is in wordlist.
//
//  Notes:      When we write the freshtest to disk, we must be careful not
//              to lose entries that already exist in the current persistent
//              log but have subsequently ended up in a wordlist. For example,
//              let (wid 20, iid 001) be an entry in the pers fresh test. If
//              the wid now got re-filtered and is in a wordlist iid 1001, we
//              must write (wid 20, iid 001) into the new persistent fresh
//              test. O/W, we will end up with no entry for wid 20 in the
//              fresh test upon a restart and cause "duplicate wid" problem
//              where by a wid will be present in a master index as well as
//              as a shadow index.
//
//----------------------------------------------------------------------------
void CPersFresh::LokCompactLog( SRcovStorageObj & PersFreshLog,
                                CFreshTableIter  & freshIter,
                                CIdxSubstitution& subst)
{
    //
    // Create an in-memory copy the persistent fresh test. This will be
    // used to know the last persistent mapping for a document which
    // has subsequently been filtered and is in a wordlist.
    // 100 is the count guess for the # of entries.
    //

    XPtr<CFreshTest> xFreTestPersist( new CFreshTest( 100 ) );

    //
    // Load the entries from the persistent fresh log in the fresh hash.
    //
    LoadFreshTest( * xFreTestPersist->GetFreshTable() );

    //
    // Replace old index id's in this copy of persistent fresh test
    //
    XPtr<CFreshTest> xFreTestPersistUpdated(
                     new CFreshTest( xFreTestPersist.GetReference(),
                                     subst ) );

    //
    // Create a brand new fresh log and append entries to it.
    //
    CRcovStrmAppendTrans xact( &PersFreshLog );

    //
    // It should be an empty object.
    //
    Win4Assert( PersFreshLog->GetHeader().GetCount(
                                PersFreshLog->GetHeader().GetBackup() ) == 0 );

    CRcovStrmAppendIter appendIter( xact, sizeof(CPersRec) );

    //
    //  freshIter points to the first entry in the freshTable.  If the
    //  freshTable is empty, then we don't need to process anything more
    //  here, as we have an empty stream, which reflects an empty freshTable.
    //
    for ( ; !freshIter.AtEnd(); freshIter.Advance() )
    {
        INDEXID iidCurr = freshIter->IndexId();
        Win4Assert( iidInvalid != iidCurr );
        CIndexId IndexID( iidCurr );

        WORKID  wid = freshIter->WorkId();

        //
        // If there is a wordlist which contains the information for this
        // wid, then we should use any persistent association found in the
        // persistent fresh test for this wid.
        //
        if ( !IndexID.IsPersistent() )
        {
            iidCurr = xFreTestPersistUpdated->Find( wid );
        }

        if ( iidInvalid != iidCurr )
        {

#if CIDBG==1
            CIndexId iidVerify( iidCurr );
            Win4Assert( iidVerify.IsPersistent() );
#endif  // CIDBG

            CPersRec PersRec( wid, iidCurr );
            appendIter.AppendRec( &PersRec );
        }
    }

    xact.Commit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\fretable.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       FRETABLE.CXX
//
//  Contents:   Fresh table
//
//  Classes:    CFreshTable
//
//  History:    15-Oct-91   BartoszM    created
//               5-Dec-97   dlee        rewrote as simple sorted array
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fretable.hxx>

//+-------------------------------------------------------------------------
//
//  Method:     CFreshTable::Add, public
//
//  Synopsis:   Adds an entry to the table
//
//  Arguments:  [wid] -- work id
//              [iid] -- index id
//
//  History:    5-Dec-97   dlee   created
//
//--------------------------------------------------------------------------

void CFreshTable::Add( WORKID wid, INDEXID iid )
{
    //
    // The most typical case is that items arrive sorted.  Use Get() instead
    // of operator [] since Add isn't const.
    //

    ULONG cItems = _aItems.Count();
    ULONG index;

    if ( 0 == cItems )
        index = 0;
    else if ( wid > _aItems.Get( cItems - 1 )._wid )
        index = cItems;
    else
    {
       CSortable<CFreshItem,WORKID> sort( _aItems );

       // duplicates are not expected here

       Win4Assert( !sort.Search( wid ) );

       index = sort.FindInsertionPoint( wid );

       ciDebugOut(( DEB_ITRACE, "insert, count %d index %d\n",
                    cItems, index ));
    }

    CFreshItem itemTmp;
    itemTmp._wid = wid;
    itemTmp._iid = iid;

    _aItems.Insert( itemTmp, index );
} //Add

//+-------------------------------------------------------------------------
//
//  Method:     CFreshTable::AddReplace, public
//
//  Synopsis:   Either updates the iid of an existing item, or adds the item
//
//  Arguments:  [wid] -- work id
//              [iid] -- index id
//
//  History:    5-Dec-97   dlee   created
//
//--------------------------------------------------------------------------

INDEXID CFreshTable::AddReplace( WORKID wid, INDEXID iid )
{
    CFreshItem * p = Find( wid );
    INDEXID iidOld;

    if ( 0 == p )
    {
        iidOld = iidInvalid;
        Add( wid, iid );
    }
    else
    {
        iidOld = p->_iid;
        p->_iid = iid;
    }

    return iidOld;
} //AddReplace

//+-------------------------------------------------------------------------
//
//  Method:     CFreshTable::CFreshTable, public
//
//  Synopsis:   Constructs a fresh table
//
//  Arguments:  [freshTable] -- Table from which a copy is made
//
//  History:    5-Dec-97   dlee   created
//
//--------------------------------------------------------------------------

CFreshTable::CFreshTable(
    CFreshTable & freshTable ) :
    _aItems( freshTable._aItems,
             freshTable._aItems.Count() + CI_MAX_DOCS_IN_WORDLIST )
{
    //
    // the CI_MAX_DOCS_IN_WORDLIST above is a hint that up to 16 items may
    // be added to the test, so that much space should be reserved now.
    //
} //CFreshTable

//+-------------------------------------------------------------------------
//
//  Method:     CFreshTable::CFreshTable, public
//
//  Synopsis:   Constructs a fresh table
//
//  Arguments:  [freshTable] -- Table from which a copy is made
//              [subst]      -- Index substitution object for new table
//
//  History:    5-Dec-97   dlee   created
//
//--------------------------------------------------------------------------

CFreshTable::CFreshTable(
    CFreshTable const &      freshTable,
    CIdxSubstitution const & subst) :
    _aItems( freshTable._aItems.Count() )
{
    for ( unsigned i = 0; i < freshTable._aItems.Count(); i++ )
    {
        CFreshItem const & item = freshTable._aItems[i];

        if (subst.IsMaster())
        {
            // skip old deleted and old indexes

            if ( item._iid != subst.IidOldDeleted() &&
                 !subst.Find( item._iid) )
                Add( item._wid, item._iid );
        }
        else
        {
            // replace source indexes with the new index id

            INDEXID iid = item._iid;

            if ( subst.Find( iid ) )
                iid = subst.IidNew();

            Add( item._wid, iid );
        }
    }
} //CFreshTable

//+-------------------------------------------------------------------------
//
//  Method:     CFreshTable::ModificationsComplete, public
//
//  Synopsis:   Called when updates to the table have completed, so memory
//              usage can be trimmed if possible.
//
//  History:    5-Dec-97   dlee   created
//
//--------------------------------------------------------------------------

void CFreshTable::ModificationsComplete()
{
    // Make sure we're really sorted

    CSortable<CFreshItem,WORKID> sort( _aItems );
    Win4Assert( sort.IsSorted() );

    // save memory if the size is much larger than the count

    if ( _aItems.Size() > ( _aItems.Count() + 100 ) )
        _aItems.Shrink();
} //ModificationsComplete
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\fretest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:   FRETEST.CXX
//
//  Contents:   Fresh test object
//
//  Classes:    CFreshTest
//
//  History:    01-Oct-91   BartoszM    Created.
//              17-Oct-91   BartoszM    Reimplemented using hash table
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "fretest.hxx"
#include "fresh.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CFreshTest::CFreshTest, public
//
//  Arguments:  [size] -- initial # of entries
//
//  History:    08-Oct-91   BartoszM       Created.
//
//----------------------------------------------------------------------------


CFreshTest::CFreshTest ( unsigned size )
        : _refCount(0),
          _freshTable(size),
          _cDeletes( 0 )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreshTest::CFreshTest, public
//
//  Synopsis:   Pseudo copy constructor
//              Substitutes old index id's with new iid
//
//  Arguments:  [freshTest] -- fresh test
//              [subst] -- index subst object
//
//  History:    15-Oct-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CFreshTest::CFreshTest ( CFreshTest& freshTest, CIdxSubstitution& subst)
        : _refCount(0),
          _freshTable ( freshTest._freshTable, subst ),
          _cDeletes( freshTest._cDeletes )
{
}

//+---------------------------------------------------------------------------
//
//  Function:   CFreshTest::CFreshTest
//
//  Synopsis:   Copy ~ctor
//
//  History:    7-19-94   srikants   Created
//
//  Notes:      Having a default copy constructor is dangerous for a
//              unwindable object because it does not get delinked from
//              the exception stack in the absence of an END_CONSTRUCTION
//              macro at the end of the constructor.
//
//----------------------------------------------------------------------------

CFreshTest::CFreshTest( CFreshTest& freshTest )
        : _refCount(0),
          _freshTable(freshTest._freshTable),
          _cDeletes( freshTest._cDeletes )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreshTest::IsCorrectIndex
//
//  Synopsis:   Checks if the index <-> wid pid association is fresh.
//              If entry not found, (wid, pidAll) is tried.
//
//  Arguments:  [iid] -- index id
//              [wid] -- work id
//
//  Returns:    Shadow if (wid) most recent index is iid
//                   or Master if (wid) not found (meaning: master index)
//              Invalid if (wid) has a more recent iid
//                   or the the property has been deleted.
//
//  History:    16-May-91   BartoszM       Created.
//
//  Notes:      When the document is deleted, the entry
//              will contain iidDeleted, wich does not
//              match any valid index id.
//
//----------------------------------------------------------------------------

CFreshTest::IndexSource CFreshTest::IsCorrectIndex ( INDEXID iid,
                                                     WORKID wid )
{
    ciDebugOut (( DEB_FRESH, " -- testing iid %lx <-> wid %ld\n", iid, wid));

    CFreshItem* pEntry = _freshTable.Find ( wid );

    if ( pEntry == 0 )
    {
        #if CIDBG == 1
            CIndexId indexId(iid);
            Win4Assert( indexId.IsPersistent() );
            ciDebugOut (( DEB_FRESH, "fresh entry not found\n" ));
        #endif // CIDBG == 1

        // not found -> must be master index
        return CFreshTest::Master;
    }

    ciDebugOut (( DEB_FRESH, " -- FreshTest found entry\n" ));
    INDEXID iidFresh = pEntry->IndexId();

    if ( iidFresh == iid )
        return CFreshTest::Shadow;

    #if CIDBG == 1
        //
        // If we hit this assert, put this code back in
        //
        if ( iidFresh == iidInvalid )
        {
            Win4Assert( !"Unexpected behavior in FreshTest. email searchdv" );
            ciDebugOut (( DEB_WARN,
                          "FreshTest::found invalid index id\n" ));
            PatchEntry ( pEntry, iid );
            return CFreshTest::Unknown;
        }
    #endif // CIDBG == 1

    ciDebugOut (( DEB_FRESH, " -- FreshTest different iid %lx\n", iidFresh ));

    return CFreshTest::Invalid;
} //IsCorrectIndex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\idle.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:       Idle.cxx
//
//  Contents:   Idle time tracker.
//
//  Classes:    CIdleTime
//
//  History:    15-Nov-95   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "idle.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CIdleTime::CIdleTime, private
//
//  Effects:    Initialize idle time tracker.
//
//  History:    15-Nov-95   KyleP       Created
//
//----------------------------------------------------------------------------

CIdleTime::CIdleTime()
        : _liLastIdleTime( 0 ),
          _liLastTotalTime( 0 ),
          _cProcessors( 0 )
{
    NTSTATUS status = NtQuerySystemInformation(
                            SystemProcessorPerformanceInformation,
                            _aProcessorTime,
                            sizeof(_aProcessorTime),
                            &_cProcessors );

    if ( !NT_ERROR( status ) )
    {
        Win4Assert( _cProcessors % sizeof(_aProcessorTime[0]) == 0 );

        _cProcessors = _cProcessors / sizeof(_aProcessorTime[0]);

        for ( unsigned i = 0; i < _cProcessors; i++ )
        {
            _liLastIdleTime += _aProcessorTime[i].IdleTime.QuadPart;
            _liLastTotalTime += _aProcessorTime[i].KernelTime.QuadPart + _aProcessorTime[i].UserTime.QuadPart;
        }

        //
        // Don't check for overflow.  This will overflow in about
        // 58K years!
        //

        Win4Assert( _liLastIdleTime < 0x0FFFFFFFFFFFFFFF );
        Win4Assert( _liLastTotalTime < 0x0FFFFFFFFFFFFFFF );
    }
    else
    {
        ciDebugOut(( DEB_ERROR, "NtQuerySystemInformation returned 0x%x\n", status ));
        _cProcessors = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIdleTime::PercentIdle, private
//
//  Returns:    Percent idle time since last call to this method.
//
//  History:    15-Nov-95   KyleP       Created
//
//----------------------------------------------------------------------------

unsigned CIdleTime::PercentIdle()
{
    unsigned pctIdle;

    NTSTATUS status = NtQuerySystemInformation (
                            SystemProcessorPerformanceInformation,
                            _aProcessorTime,
                            sizeof(_aProcessorTime[0]) * _cProcessors,
                            0 );

    if ( !NT_ERROR( status ) )
    {
        LONGLONG liIdleTime  = 0;
        LONGLONG liTotalTime = 0;

        for ( unsigned i = 0; i < _cProcessors; i++ )
        {
            liIdleTime  += _aProcessorTime[i].IdleTime.QuadPart;
            liTotalTime += _aProcessorTime[i].KernelTime.QuadPart + _aProcessorTime[i].UserTime.QuadPart;
        }

        Win4Assert( liIdleTime >= _liLastIdleTime );
        Win4Assert( liTotalTime >= _liLastTotalTime );

        pctIdle = (unsigned)((liIdleTime - _liLastIdleTime) * 100 / (1 + liTotalTime - _liLastTotalTime));

        _liLastIdleTime  = liIdleTime;
        _liLastTotalTime = liTotalTime;

        //
        // Don't check for overflow.  This will overflow in about
        // 58K years!
        //

        Win4Assert( _liLastIdleTime < 0x0FFFFFFFFFFFFFFF );
        Win4Assert( _liLastTotalTime < 0x0FFFFFFFFFFFFFFF );
    }
    else
    {
        ciDebugOut(( DEB_ERROR, "NtQuerySystemInformation returned 0x%x\n", status ));
        pctIdle = 0;
    }

    Win4Assert( pctIdle <= 100 );

    return pctIdle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\idxlst.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       IdxLst.cxx
//
//  Contents:   Index list.
//
//  Classes:    CIndexList
//
//  History:    04-Apr-92 BartoszM  Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "idxlst.hxx"
#include "index.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CIndexList::Add, public
//
//  Arguments:  [pIndex] -- index pointer
//
//  History:    04-Apr-91   BartoszM       Created.
//
//  Notes:  It is a circular list, wordlist are forward from the root,
//      persistent indexes, from big to small, backward from
//              the root.
//
//----------------------------------------------------------------------------

void CIndexList::Add ( CIndex* pIndex )
{
    ciDebugOut (( DEB_ITRACE, "IndexList::Add %x\n", pIndex->GetId() ));

    // wordlists to the right
    if ( pIndex->IsWordlist() )
    {
        Push (pIndex);
        _countWl++;
    }
    else
    {
        unsigned size = pIndex->Size();

        // walk the list backwards from root

        for ( CBackIndexIter iter(*this); !AtEnd(iter); BackUp(iter) )
        {
            if ( iter->IsWordlist() || iter->Size() <= size )
            {
                pIndex->InsertAfter(iter.GetIndex());
                _count++;
                _sizeIndex += pIndex->Size();
                return;
            }
        }

        // reached the end
        ciAssert( AtEnd(iter) );
        Push (pIndex);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexList::Remove, public
//
//  Arguments:  [iid] -- index id
//
//  Returns:    pointer to the removed index
//
//  History:    04-Apr-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CIndex* CIndexList::Remove ( INDEXID iid )
{
    ciDebugOut (( DEB_ITRACE, "IndexList::Remove %x\n", iid ));

    if ( IsEmpty() )
        return 0;

    for  ( CForIndexIter iter(*this); !AtEnd(iter); Advance(iter) )
    {
        ciDebugOut((DEB_CAT,"\t%x [%d]\n", iter->GetId(), iter->Size()));

        if ( iter->GetId() == iid )
        {
            iter->Unlink();
            _count--;
            _sizeIndex -= iter->Size();

            Win4Assert( (_count == 0 && _sizeIndex == 0) || (_count > 0 && _sizeIndex > 0) );

            if ( iter->IsWordlist() )
                _countWl--;
            break;
        }
    }

    if ( AtEnd(iter) )
        return( 0 );
    else
        return iter.GetIndex();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\index.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       index.cxx
//
//  Contents:   Methods used by all indexes.
//
//  Classes:    CIndex
//
//  History:    06-Mar-91   KyleP   Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "index.hxx"
#include "stat.hxx"

#if DEVL == 1
#define INPTR pfOut
#define DEB_PRINTF( x ) fprintf x
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CIndex::DebugDump, public
//
//  Synopsis:   Formatted dump of CWordList contents.
//
//  Arguments:  [pfOut] -- File to dump data to.
//
//  Requires:   The AddEntry method cannot be called after DebugDump.
//
//  Derivation: From base class CIndex, Always override in subclasses.
//
//  History:    07-Mar-91   KyleP       Created.
//              27-Oct-93   DwightKr    Increased size of PopularKeys so
//                                      that prop filtering could be tested
//
//  Notes:      This interface should at some point be changed to accept
//              a stream and write the contents of the CWordList to the
//              stream. Since C7 does not yet provide a stream interface
//              I'll just print to stdout (Ugh!);
//
//----------------------------------------------------------------------------

void CIndex::DebugDump(FILE *pfOut, ULONG fSummaryOnly )
{
#if CIDBG == 1
    const CKeyBuf * pkey;

    CKeyCursor * pcur = QueryCursor();

    TRY
    {
        CStat KeyDelta;
        CStat WidCount;
        CStat OccCount;
        CKeyBuf LastKey;

        static ULONG aBucket[] = { 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 64,
                                       96, 128, 192, 256, 284, 512, 768,
                                       1024, 1536, 2048, 3072, 4096, 6144,
                                       8192, 12288, 16384, 24576, 32768 };

        CDistrib WidDistrib( sizeof(aBucket) / sizeof(ULONG),
                             1,
                             aBucket );

        CDistrib OccDistrib( sizeof(aBucket) / sizeof(ULONG),
                             1,
                             aBucket );

        LastKey.SetCount(0);

        CPopularKeys PopularKeys(50);
        CPopularKeys BigOccKeys(50);

        int const cWidsToTrack = 50;
        CPopularKeys widKeys[ cWidsToTrack + 1 ];

        ciDebugOut(( DEB_ITRACE, "Scan on letter: " ));
        WCHAR FirstLetter = '@';

        for (pkey = pcur->GetKey(); pkey != NULL; pkey = pcur->GetNextKey())
        {
            //
            // Calculate the common prefix from the previous key.
            //

            UINT cPrefix;
            UINT mincb = __min( LastKey.Count(), pkey->Count() );

            for ( cPrefix = 0;
                  (cPrefix < mincb) &&
                  ((LastKey.GetBuf())[cPrefix] == pkey->GetBuf()[cPrefix]);
                  cPrefix++ )
                continue;               // NULL body

            UINT cSuffix = pkey->Count() - cPrefix;

            LastKey = *pkey;

            if ( cPrefix > 15 || cSuffix > 15 )
                cSuffix += 3;           // 0 byte + prefix + suffix
            else
                cSuffix += 1;           // prefix/suffix byte

            KeyDelta.Add( cSuffix );
            WidCount.Add( pcur->WorkIdCount() );
            WidDistrib.Add( pcur->WorkIdCount() );

            PopularKeys.Add( *pkey, pcur->WorkIdCount() );

            if ( *(pkey->GetStr()) != FirstLetter )
            {
                FirstLetter = *(pkey->GetStr());
                ciDebugOut (( DEB_NOCOMPNAME | DEB_ITRACE, "%c",
                    FirstLetter ));
            }

            if ( !fSummaryOnly )
            {
                DEB_PRINTF((INPTR, "Key: "));

                DEB_PRINTF((INPTR, "%.*ws  --  ", pkey->StrLen(), pkey->GetStr()));

                DEB_PRINTF((INPTR, " (PID = %lx)", pkey->Pid()));
                DEB_PRINTF((INPTR, " (CWID = %ld)\n", pcur->WorkIdCount()));
            }

            for (WORKID wid = pcur->WorkId();
                    wid != widInvalid;
                    wid = pcur->NextWorkId())
            {
                OccCount.Add( pcur->OccurrenceCount() );
                OccDistrib.Add( pcur->OccurrenceCount() );
                BigOccKeys.Add( *pkey, pcur->OccurrenceCount() );

                if ( wid <= cWidsToTrack )
                    widKeys[wid].Add( *pkey, pcur->Rank() );

                if ( !fSummaryOnly )
                {
                    DEB_PRINTF((INPTR, "    (WID = %lx) ", wid));
                    DEB_PRINTF((INPTR, "(COCC = %ld)\n\t",
                            pcur->OccurrenceCount()));

                    int i = 1;

                    for (OCCURRENCE occ = pcur->Occurrence();
                         occ != OCC_INVALID;
                         occ = pcur->NextOccurrence(), i++ )
                    {
                        DEB_PRINTF((INPTR, " %6ld", occ));
                        if ( i % 10 == 0 )
                        {
                            DEB_PRINTF((INPTR, "\n\t"));
                        }
                    }

                    DEB_PRINTF((INPTR, "\n"));
                }
            }

            if ( !fSummaryOnly )
            {
                DEB_PRINTF((INPTR, "\n"));
            }

        }

        //
        // Print stats
        //

        KeyDelta.Print( pfOut, "Key size", 1, 1 );
        WidCount.Print( pfOut, "Wid count", 0, 1 );
        OccCount.Print( pfOut, "Occ count", 0, 1 );

        DEB_PRINTF(( INPTR, "\nMost popular keys (high work id count):\n\n" ));
        PopularKeys.Print( pfOut );

        DEB_PRINTF(( INPTR, "\nMost popular keys (high occurrence count):\n\n" ));
        BigOccKeys.Print( pfOut );

        DEB_PRINTF(( INPTR, "\n\nWorkid count distribution:\n\n" ));
        WidDistrib.Print( pfOut );
        DEB_PRINTF(( INPTR, "\n\nOccurrence count distribution:\n\n" ));
        OccDistrib.Print( pfOut );

        ciDebugOut (( DEB_NOCOMPNAME | DEB_ITRACE, "\n" ));

        for ( int i = 1; i <= cWidsToTrack; i++ )
        {
            DEB_PRINTF(( INPTR, "\n\nWid %u:\n", i ));
            widKeys[i].Print( pfOut );
        }

    }
    CATCH(CException, e)
    {
        delete pcur;
        RETHROW();
    }
    END_CATCH

    delete pcur;
#endif // CIDBG == 1
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\indsnap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       INDSNAP.CXX
//
//  Contents:   Array of Indexes
//
//  Classes:    CIndexSnapshot
//
//  History:    28-Apr-92   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <orcursor.hxx>

#include "indsnap.hxx"
#include "partn.hxx"
#include "resman.hxx"
#include "mcursor.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::CIndexSnapshot, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [resman] -- reference to the resource manager
//
//  History:    28-Apr-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

CIndexSnapshot::CIndexSnapshot (CResManager& resman)
    :_resman(resman),  _cInd(0), _apIndex(0), _pFreshTest(0)
{
    _resman.ReferenceQuery();
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::CIndexSnapshot, public
//
//  Synopsis:   Copy Constructor
//
//  Arguments:  [src] -- reference to the src CIndexSnapshot to be copied
//
//  History:    28-Apr-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

CIndexSnapshot::CIndexSnapshot (CIndexSnapshot& src )
    :_resman(src._resman), _cInd(src._cInd), _apIndex(src._apIndex),
     _pFreshTest(src._pFreshTest)
{
    _resman.ReferenceQuery();

    // transfer ownership
    src._cInd = 0;
    src._apIndex = 0;
    src._pFreshTest = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::LokInit, public
//
//  Synopsis:   Initializes _pFreshTest and _apIndex (one partition)
//              Used for merges.
//
//  Arguments:  [part] -- partition to retrieve array of indexes from
//              [mt] -- merge type for retrieving array of indexes
//
//  History:    28-Apr-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

// ResMan LOCKED
void CIndexSnapshot::LokInit ( CPartition& part, MergeType mt )
{
    // initialize fresh test

    _pFreshTest = _resman._fresh.LokGetFreshTest();
    _apIndex = part.LokQueryMergeIndexes( _cInd, mt );
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::LokInitForBackup
//
//  Synopsis:   Initializes the _apIndex (one partition) for backing up the
//              indexes.
//
//  Arguments:  [part]  - Partition
//              [fFull] - Set to TRUE if full backup of indexes is required.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CIndexSnapshot::LokInitForBackup ( CPartition& part, BOOL fFull )
{

    // initialize the indexes
    _apIndex = part.LokQueryIndexesForBackup( _cInd, fFull );

}

//+---------------------------------------------------------------------------
//
//  Function:   LokInitFreshTest
//
//  Synopsis:   Initializes _pFreshTest by getting the current fresh test
//              from resman.
//
//  Arguments:  (none)
//
//  History:    9-29-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CIndexSnapshot::LokInitFreshTest()
{
    _pFreshTest = _resman._fresh.LokGetFreshTest();
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::Init, public
//
//  Synopsis:   Initializes _pFreshTest and _apIndex (more than one partition)
//              Used for queries.
//
//  Arguments:  [cPart] -- number of partitions to retrieve indexes from
//              [aPartId] -- array of partitions to retrieve indexes from
//              [cPendingUpdates] -- Look for this many pending changes
//                  per partition.
//              [pFlags] -- (ret arg) flag for status of indexes
//
//  Modifies:   pFlags to reflect status of indexes
//
//  History:    28-Apr-92   BartoszM    Created.
//              08-Sep-92   AmyA        Added pFlags
//              18-Nov-94   KyleP       Add search for pending changes
//
//----------------------------------------------------------------------------

void CIndexSnapshot::Init ( unsigned cPart,
                            PARTITIONID* aPartId,
                            ULONG cPendingUpdates,
                            ULONG* pFlags )
{
    // uses resman lock
    _apIndex = _resman.QueryIndexes ( cPart,
                                      aPartId,
                                      &_pFreshTest,
                                      _cInd,
                                      cPendingUpdates,
                                      &_curPending,
                                      pFlags );

}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::LokRestart, public
//
//  Synopsis:   Initializes _apIndex (one partition) which constitute
//              the master merge set. It does NOT initialize the _pFreshTest
//              as _pFreshTest is initialized when the master merge is
//              restarted.
//
//  Arguments:  [part] -- partition to retrieve array of indexes from
//              [mMergeLog] -- master merge log, contains list of indexes
//                             participating i the current master merge
//
//  History:    08-Apr-94   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CIndexSnapshot::LokRestart ( CPartition& part, PRcovStorageObj & mMergeLog )
{
    _apIndex = part.LokQueryMMergeIndexes( _cInd, mMergeLog );
}


//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::~CIndexSnapshot, public
//
//  Synopsis:   Destructor
//
//  History:    28-Apr-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

CIndexSnapshot::~CIndexSnapshot()
{
    // release old indexes and fresh test (takes lock)
    _resman.ReleaseIndexes ( _cInd, _apIndex, _pFreshTest );

    delete _apIndex;

    _resman.DereferenceQuery();
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::MaxWorkId, public
//
//  Synopsis:   Returns the maximum work id for all indexes in snapshot
//
//  History:    28-Apr-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

WORKID CIndexSnapshot::MaxWorkId()
{
    WORKID widMax = _apIndex[0]->MaxWorkId();

    for ( unsigned i = 1; i < _cInd; i++ )
        if ( _apIndex[i]->MaxWorkId() > widMax )
            widMax = _apIndex[i]->MaxWorkId();

    return(widMax);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::TotalSizeInPages, public
//
//  Synopsis:   Returns the size estimate in CI_PAGE's
//
//  History:    18-Mar-93   BartoszM    Created.
//
//----------------------------------------------------------------------------

unsigned CIndexSnapshot::TotalSizeInPages()
{
    unsigned cpage = 0;
    for ( unsigned i = 0; i < _cInd; i++ )
        cpage += _apIndex[i]->Size();

    return cpage;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::QueryMergeCursor, public
//
//  Synopsis:   Create source cursor for merge
//
//  History:    20-Aug-91   BartoszM    Created.
//              28-Apr-92   BartoszM    Moved from CPersIndex to CIndexSnapshot
//
//----------------------------------------------------------------------------

CKeyCursor * CIndexSnapshot::QueryMergeCursor(const CKey * pKey)
{
    XPtr<CKeyCursor> xRawCursor;

    if ( 1 == _cInd )
    {
        if (0 == pKey)
            xRawCursor.Set( _apIndex[0]->QueryCursor() );
        else
            xRawCursor.Set( _apIndex[0]->QueryKeyCursor( pKey ) );

        if ( !xRawCursor.IsNull() && xRawCursor->GetKey() == 0 )
            xRawCursor.Free();
    }
    else
    {
        CKeyCurStack stkCur;

        for ( UINT i = 0; i < _cInd; i++ )
        {
            XPtr<CKeyCursor> xCur;

            if (0 == pKey)
                xCur.Set( _apIndex[i]->QueryCursor() );
            else
                xCur.Set( _apIndex[i]->QueryKeyCursor( pKey ) );

            if ( !xCur.IsNull() && 0 != xCur->GetKey() )
            {
                stkCur.Push( xCur.GetPointer() );
                xCur.Acquire();
            }
        }

        if ( 0 != stkCur.Count() )
            xRawCursor.Set( new CMergeCursor ( stkCur ) );
    }

    return xRawCursor.Acquire();
} //QueryMergeCursor

//+---------------------------------------------------------------------------
//
//  Member:     CIndexSnapshot::AppendPendingUpdates, public
//
//  Synopsis:   Creates a cursor for pending documents
//
//  History:    7-Oct-98    dlee   Added header; author unknown
//
//----------------------------------------------------------------------------

void CIndexSnapshot::AppendPendingUpdates( XCursor & cur )
{
    if ( _curPending.Count() > 0 )
    {
        if ( !cur.IsNull() )
            _curPending.Push( cur.Acquire() );

        cur.Set( new COrCursor( _curPending.Count(), _curPending ) );
    }
} //AppendPendingUpdates

//+---------------------------------------------------------------------------
//
//  Function:   LokGiveIndexes
//
//  Synopsis:   Transfers the control of the array of indexes to the caller.
//
//  Effects:    _apIndex and _cInd will both be set to 0.
//
//  Arguments:  [cInd] -- On output, will have the count of the number of
//              valid indexes in the returned array of indexes.
//
//  Returns:    array of indexes which belonged to this snapshot.
//
//  History:    9-29-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CIndex ** CIndexSnapshot::LokGiveIndexes( unsigned & cInd )
{
    cInd = _cInd;
    CIndex ** pTemp = _apIndex;
    _cInd = 0;
    _apIndex = 0;
    return( pTemp );
}

//+---------------------------------------------------------------------------
//
//  Function:   LokTakeIndexes
//
//  Synopsis:   Takes control of the indexes from the source snapshot.
//
//  Arguments:  [src] -- Source snapshot.
//
//  History:    9-29-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CIndexSnapshot::LokTakeIndexes( CIndexSnapshot & src )
{
    Win4Assert( 0 == _apIndex && 0 == _cInd );
    _apIndex = src.LokGiveIndexes( _cInd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\indxact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       INDXACT.CXX
//
//  Contents:   Index transactions
//
//  Classes:    CIndexTrans, CChangeTrans
//
//  History:    15-Oct-91   BartoszM    created
//
//  Notes:      All operations are done under ResMan LOCK
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pstore.hxx>

#include "indxact.hxx"
#include "fretest.hxx"
#include "resman.hxx"
#include "changes.hxx"
#include "merge.hxx"
#include "mindex.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CIndexTrans::CIndexTrans, public
//
//  Synopsis:   Start transaction
//
//  Arguments:  [storage] -- physical storage
//              [resman] -- resource manager
//
//  History:    15-Oct-91   BartoszM    created
//
//--------------------------------------------------------------------------

CIndexTrans::CIndexTrans ( CResManager& resman )
:  _resman(resman), _freshTest(0), _fCommit(FALSE)
{
    ciDebugOut (( DEB_ITRACE, ">>>> BEGIN index<<<<" ));
}

void CIndexTrans::LokCommit()
{
    Win4Assert( !_fCommit );
    ciDebugOut (( DEB_ITRACE, ">>>> COMMIT index<<<<" ));

    _resman.LokCommitFresh ( _freshTest );

    _freshTest = 0;
    _fCommit = TRUE;

    CTransaction::Commit();
}

//+---------------------------------------------------------------------------
//
//  Function:   LokCommit
//
//  Synopsis:   COmmit procedure for a master merge.
//
//  Arguments:  [storage]        --  Storage object
//              [widNewFreshLog] --  WorkId of the new fresh log
//
//  History:    10-05-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CIndexTrans::LokCommit( PStorage & storage, WORKID widNewFreshLog )
{
    Win4Assert( widInvalid != widNewFreshLog );

    _resman.LokCommitFresh( _freshTest );
    WORKID widOldFreshLog = storage.GetSpecialItObjectId( itFreshLog );
    Win4Assert( widInvalid != widOldFreshLog );

    storage.RemoveFreshLog( widOldFreshLog );
    storage.SetSpecialItObjectId( itFreshLog, widNewFreshLog );

    _freshTest = 0;
    _fCommit = TRUE;

    CTransaction::Commit();
}



//+-------------------------------------------------------------------------
//
//  Method:     CMergeTrans::CMergeTrans, public
//
//  Synopsis:   Start transaction
//
//  Arguments:  [storage] -- physical storage
//              [resman] -- resource manager
//              [merge] -- merge object
//
//  History:    15-Oct-91   BartoszM    created
//
//--------------------------------------------------------------------------

CMergeTrans::CMergeTrans ( CResManager & resman,
                           PStorage& storage,
                           CMerge& merge )
        : CIndexTrans( resman ),
          _merge(merge),
          _swapped(0),
          _fCommit(FALSE),
          _storage(storage),
          _widNewFreshLog(widInvalid)
{
    ciDebugOut (( DEB_ITRACE, ">>>> BEGIN merge trans <<<<" ));
}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
CMergeTrans::~CMergeTrans ()
{
    if ( !_fCommit )
    {
        ciDebugOut (( DEB_ITRACE, ">>>> ABORT merge<<<<" ));
        _merge.LokRollBack(_swapped);

        if ( widInvalid != _widNewFreshLog )
        {
            _storage.RemoveFreshLog( _widNewFreshLog );
        }
    }

}


//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
void CMergeTrans::LokCommit()
{
    Win4Assert( !_fCommit );
    ciDebugOut (( DEB_ITRACE, ">>>> COMMIT merge<<<<" ));

    _merge.LokZombify(); // old indexes
    _fCommit = TRUE;

    CIndexTrans::LokCommit( _storage, _widNewFreshLog );
}

IMPLEMENT_UNWIND( CMasterMergeTrans );

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
void CMasterMergeTrans::LokCommit()
{
    Win4Assert( _pMasterMergeIndex );

    //
    // Commit the master merge by replacing the master merge index
    // with the new index.
    //

    //
    // Transfer the ownership of the MMerge IndexSnapshot to the merge
    // object from the master merge index.
    //
    _masterMerge.LokTakeIndexes( _pMasterMergeIndex );

    //
    // Replace the CMasterMergeIndex in the partition with the target index
    // as the new master in the partition.
    //
    _pMasterMergeIndex->Zombify();
    _resman.LokReplaceMasterIndex( _pMasterMergeIndex );

    _mergeTrans.LokCommit();
}


//+-------------------------------------------------------------------------
//
//  Method:     CChangeTrans::CChangeTrans, public
//
//  Synopsis:   Start transaction
//
//  Arguments:  [storage] -- physical storage
//              [resman] -- resource manager
//
//  History:    15-Oct-91   BartoszM    created
//
//--------------------------------------------------------------------------

CChangeTrans::CChangeTrans ( CResManager & resman, CPartition* pPart )
: _pPart(pPart), _resman(resman)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CChangeTrans::~CChangeTrans, public
//
//  Synopsis:   Commit or Abort transaction
//
//  History:    15-Oct-91   BartoszM    created
//              19-May-94   SrikantS    Modified to disable updates in
//                                      case of failures.
//              22-Nov-94   DwightKr    Added content scan calls
//
//--------------------------------------------------------------------------

CChangeTrans::~CChangeTrans()
{
    if ( GetStatus() != CTransaction::XActCommit )
    {
        //
        // The change log commit failed, requiring either an incremental
        // update or a full update. This code is executed when an
        // internal corruption is detected or during a low disk situation
        // or if a memory allocation failed. Disable updates in changelog.
        //

        _pPart->LokDisableUpdates();

        //
        // Tell Resman that a scan is needed.
        //
        _resman.SetUpdatesLost( _pPart->GetId() );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CDeletedIIDTrans
//
//  Synopsis:   ~dtor of the CDeletedIIDTrans. If change to deleted iid is
//              logged and the transaction is not committed, it will roll
//              back the change to the deleted iid.
//
//  History:    7-17-95   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDeletedIIDTrans::~CDeletedIIDTrans()
{
    if ( IsRollBackTrans() )
    {
        _resman.RollBackDeletedIIDChange( *this );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\kcurheap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       KCURHEAP.CXX
//
//  Contents:   Implementations for the Cursor Heaps for CMergeCursor,
//              CWlCursor, and CSynCursor.
//
//  History:    20-Jan-92   BartoszM and AmyA  Created
//
//  Notes:      This code was previously located in mcursor.cxx and
//              wlcursor.cxx.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <wcurheap.hxx>

#include "kcurheap.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   KeyLessThan
//
//  Synopsis:   Compares keys in cursors
//
//  Arguments:  [c1] -- cursor 1
//              [c2] -- cursor 2
//
//  History:    06-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

inline BOOL KeyLessThan ( CKeyCursor* c1, CKeyCursor* c2 )
{
    Win4Assert ( c1 != 0 );
    Win4Assert ( c2 != 0 );
    Win4Assert ( c1->GetKey() != 0 );
    Win4Assert ( c2->GetKey() != 0 );
    return ( Compare (c1->GetKey(), c2->GetKey()) < 0);
}

// Implement CKeyHeap, a heap of cursors ordered according to keys

IMP_HEAP ( CKeyHeap, CKeyCursor, KeyLessThan )

// Implement CIdxWidHeap, a heap of cursors ordered according to work id's

IMP_HEAP ( CIdxWidHeap, CKeyCursor, WidLessThan )

// Implement COccHeapofKeyCur, a heap of key cursors ordered according to
// occurrences

IMP_HEAP ( COccHeapOfKeyCur, CKeyCursor, OccLessThan )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\invcur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994-1998.
//
//  File:       InvCur.cxx
//
//  Contents:   'Invalid' cursor.  Cursor over the pidUnfiltered property
//              based on a given widmap.
//
//  Classes:    CUnfilteredCursor
//
//  History:    09-Nov-94       KyleP           Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <widtab.hxx>

#include "invcur.hxx"

static const BYTE abUnfiltered[] = { VT_UI1,
                        (BYTE)(pidUnfiltered >> 24),
                        (BYTE)(pidUnfiltered >> 16),
                        (BYTE)(pidUnfiltered >> 8),
                        (BYTE) pidUnfiltered,
                        0,
                        1 };

CKeyBuf CUnfilteredCursor::_TheUnfilteredKey( pidUnfiltered, abUnfiltered, sizeof(abUnfiltered) );

int CUnfilteredCursor::CompareAgainstUnfilteredKey( CKey const & key )
{
    //
    // Compare not available on CKeyBuf
    //

    return( key.CompareStr( _TheUnfilteredKey ) * -1 );
}


CUnfilteredCursor::CUnfilteredCursor( INDEXID iid, WORKID widMax, CWidTable const & widtab )
        : CKeyCursor( iid, widMax ),
          _widtab( widtab ),
          _iCurrentFakeWid( 0 ),
          _occ( 1 ),
          _fAtEnd( FALSE ),
          _fKeyMoved( FALSE )
{
    NextWorkId();
    
    UpdateWeight();

    Win4Assert( WorkId() != widInvalid );
}

ULONG CUnfilteredCursor::WorkIdCount()
{
    ULONG CUnfiltered = 0;

    for ( unsigned i = 1; i <= _widtab.Count(); i++ )
    {
        if ( !_widtab.IsFiltered(i) && _widtab.IsValid(i) )
            CUnfiltered++;
    }

    return( CUnfiltered );
}

WORKID CUnfilteredCursor::WorkId()
{
    if ( _fAtEnd )
        return( widInvalid );
    else
        return( _widtab.FakeWidToUnfilteredWid( _iCurrentFakeWid ) );
}

void CUnfilteredCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    denom = _widtab.Count();
    num   = min (denom, _iCurrentFakeWid);
}

WORKID CUnfilteredCursor::NextWorkId()
{
    Win4Assert( !_fKeyMoved);

    for ( _iCurrentFakeWid++; _iCurrentFakeWid <= _widtab.Count(); _iCurrentFakeWid++ )
    {
        if ( !_widtab.IsFiltered(_iCurrentFakeWid) && _widtab.IsValid( _iCurrentFakeWid ) )
            break;
    }

    if ( _iCurrentFakeWid > _widtab.Count() )
    {
        _fAtEnd = TRUE;
        _occ = OCC_INVALID;
    }
    else
    {
        Win4Assert( !_fAtEnd );
        _occ = 1;
    }

    return( WorkId() );
}

ULONG CUnfilteredCursor::HitCount()
{
    return( 1 );
}


OCCURRENCE CUnfilteredCursor::Occurrence()
{
    return( _occ );
}

OCCURRENCE CUnfilteredCursor::NextOccurrence()
{
    _occ = OCC_INVALID;

    return( _occ );
}

OCCURRENCE CUnfilteredCursor::MaxOccurrence()
{
    return 1;
}


ULONG CUnfilteredCursor::OccurrenceCount()
{
    Win4Assert( _occ != OCC_INVALID );

    return( 1 );
}

CKeyBuf const * CUnfilteredCursor::GetKey()
{
    if ( _fKeyMoved )
        return( 0 );
    else
        return( &_TheUnfilteredKey );
}

CKeyBuf const * CUnfilteredCursor::GetNextKey()
{
    _fKeyMoved = TRUE;
    _fAtEnd = TRUE;
    _occ = OCC_INVALID;

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\kcurstk.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       kcurstk.cxx
//
//  Contents:   Cursor Stack Classes
//
//  Classes:    CKeyCurStack
//
//  History:    20-Jan-92       AmyA               Created
//              05-Feb-92       BartoszM           Added CCurArray
//              19-Feb-92       AmyA               Added COccCurArray
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <keycur.hxx>
#include <curstk.hxx>

#include "wlcursor.hxx"

CKeyCursor* CKeyCurStack::QueryWlCursor(WORKID widMax)
{
    if (Count() == 0)
        return 0;

    if (Count() == 1)
        return Pop();
    
    return new CWlCursor(Count(), *this, widMax );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\mcursor.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       MCURSOR.CXX
//
//  Contents:   Merge Cursor
//
//  Classes:    CMergeCursor
//
//  History:    06-May-91   BartoszM    Created
//
//     widHeap     keyHeap
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <curstk.hxx>

#include "mcursor.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::CMergeCursor, public
//
//  Synopsis:   Create a cursor that merges a number of cursors.
//
//  Arguments:  [cCursor] -- count of cursors
//              [aCursor] -- array of pointers to cursors
//
//  History:    06-May-91   BartoszM    Created
//              24-Jan-92   AmyA        Modified to take CKeyCurArray as a
//                                      parameter.
//
//  Notes:      The cursors and the array will be deleted by destructor.
//              Leaves widHeap empty.
//
//----------------------------------------------------------------------------

CMergeCursor::CMergeCursor( CKeyCurStack & stkCursor )
: _keyHeap (),
  _widHeap ( stkCursor.Count() )
{
    _widMax = 0; // not valid

    // Two step construction of the heap.
    // We have to make sure that all cursors have a valid key

    int cCursor = stkCursor.Count();
    int count = 0;

    // remove empty cursors.  GetKey() can fail; don't leak cursors.

    for ( int i = 0; i < cCursor; i++ )
    {
        CKeyCursor *pCur = stkCursor.Get( i );

        Win4Assert( 0 != pCur );

        if ( 0 == pCur->GetKey() )
            stkCursor.Free( i );
        else 
            count++;
    }

    XArray<CKeyCursor *> aCursor( count );

    for ( count = 0, i = 0; i < cCursor; i++ )
    {
        CKeyCursor *pCur = stkCursor.Get( i );

        if ( 0 != pCur )
            aCursor[ count++ ] = pCur;
    }

    delete [] stkCursor.AcqStack();
    _keyHeap.MakeHeap ( count, aCursor.Acquire() );

    if ( !_keyHeap.IsEmpty() )
    {
        _iid = _keyHeap.Top()->IndexId();
        _pid = _keyHeap.Top()->Pid();
    }

    ciDebugOut(( DEB_ITRACE, "merge cursor has %d cursors\n", count ));
} //CMergeCursor

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::GetKey, public
//
//  Synopsis:   Get current key.
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      Does not replenish widHeap
//              Current key is defined as:
//              1. cur key of all cursors in widHeap, or,
//              2. if widHeap empty, cur key of Top of key heap
//                 (and cur key of all cursors in keyHeap with
//                  the same cur key).
//
//----------------------------------------------------------------------------

const CKeyBuf * CMergeCursor::GetKey()
{
    if ( _widHeap.IsEmpty() )
    {
        if ( _keyHeap.IsEmpty() )
            return 0;

        return _keyHeap.Top()->GetKey();
    }

    return _widHeap.Top()->GetKey();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      Current wid is defined as:
//              1. Cur wid of Top of widHeap (and cur wid of all
//                 cursors in widHeap with the same wid-- however,
//                 NextWid should not increment the others, since
//                 they correspond to different index id's), or,
//              2. if widHeap empty: replenish it
//
//----------------------------------------------------------------------------

WORKID       CMergeCursor::WorkId()
{
    if ( _widHeap.IsEmpty() && !ReplenishWid() )
        return widInvalid;

    return _widHeap.Top()->WorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::Occurrence, public
//
//  Synopsis:   Get current occurrence.
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      Current occurrence is defined as:
//              1. cur occ of Top of widHeap, or,
//              2. if widHeap empty, replenish it.
//
//----------------------------------------------------------------------------

OCCURRENCE   CMergeCursor::Occurrence()
{
    if ( _widHeap.IsEmpty() && !ReplenishWid() )
        return OCC_INVALID;

    return _widHeap.Top()->Occurrence();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::GetNextKey, public
//
//  Synopsis:   Move to next key
//
//  Returns:    Target key or NULL if no more keys
//
//  History:    06-May-91   BartoszM    Created
//
//  Effects:    Updates _iid _pid to the ones of the keyHeap top
//
//  Notes:      1. Increment and move to keyHeap all cursors
//                 from widHeap, or,
//              2. if widHeap empty, increment and reheap all
//                 cursors in keyHeap with the same cur key
//                 as the Top.
//
//----------------------------------------------------------------------------

const CKeyBuf * CMergeCursor::GetNextKey()
{
    if ( ! _widHeap.IsEmpty() )
    {
        // move widHeap to keyHeap advancing all cursors

        CKeyCursor * cur;
        while ( ( cur = _widHeap.RemoveBottom() ) != 0 )
        {
            if ( cur->GetNextKey() == 0 )
            {
                delete cur;
            }
            else
            {
                _keyHeap.Add ( cur );
            }
        }
    }
    else if ( !_keyHeap.IsEmpty() )
    {
        // widHeap was empty. Advance all cursors
        // with the lowest key.

        CKeyBuf key = *_keyHeap.Top()->GetKey();
        do
        {
            if ( _keyHeap.Top()->GetNextKey() == 0 )
            {
                delete _keyHeap.RemoveTop();
                if ( _keyHeap.IsEmpty () )
                    return 0;
            }
            else
            {
                _keyHeap.Reheap();
            }

        } while ( AreEqual(&key, _keyHeap.Top()->GetKey()) );
    }
    else
        return 0;

    if ( _keyHeap.IsEmpty() )
        return 0;

    CKeyCursor* cur = _keyHeap.Top();
    _pid = cur->Pid();
    _iid = cur->IndexId();
    return cur->GetKey();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::NextWorkId, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  Effects:    Updates _iid to the one of the widHeap top
//
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      The same work id may be returned multiple times,
//              corresponding to multiple indexes.
//              1. Increment Top of widHeap and reheap, or,
//              2. if widHeap empty, replenish it
//
//----------------------------------------------------------------------------

WORKID       CMergeCursor::NextWorkId()
{
    if ( _widHeap.IsEmpty() && !ReplenishWid() )
        return widInvalid;

    _widHeap.Top()->NextWorkId();

    _widHeap.Reheap();

    CKeyCursor* cur = _widHeap.Top();
    _iid = cur->IndexId();
    return cur->WorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::NextOccurrence, public
//
//  Synopsis:   Move to next occurrence
//
//  Returns:    Target occurrence or OCC_INVALID if no more occurrences
//              for current (wid, index id) combination.
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      1. Increment Top of widHeap (do not reheap!), or,
//              2. if widHeap empty, replenish it
//
//----------------------------------------------------------------------------

OCCURRENCE   CMergeCursor::NextOccurrence()
{
    if ( _widHeap.IsEmpty() && !ReplenishWid() )
        return OCC_INVALID;

    return _widHeap.Top()->NextOccurrence();
}


//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::MaxOccurrence
//
//  Synopsis:   Returns max occurrence of current wid
//
//  History:    20-Jun-96   SitaramR    Created
//
//----------------------------------------------------------------------------

OCCURRENCE   CMergeCursor::MaxOccurrence()
{
    if ( _widHeap.IsEmpty() )
        return OCC_INVALID;

    return _widHeap.Top()->MaxOccurrence();
}



//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::WorkIdCount, public
//
//  Synopsis:   return wid count
//
//  History:    21-Jun-91   BartoszM    Created
//
//  Notes:      1. Sum up wid count of all cursors in widHeap, or,
//              2. if widHeap empty, replenish it
//
//----------------------------------------------------------------------------

ULONG CMergeCursor::WorkIdCount()
{
    // Sum up all wid counts for the same key.

    // move all cursors with the same key to wid heap
    if (_widHeap.IsEmpty() && !ReplenishWid())
    {
        return 0;
    }

    int count = _widHeap.Count();
    ULONG widCount = 0;
    CKeyCursor **curVec = _widHeap.GetVector();
    while ( --count >= 0 )
        widCount += curVec[count]->WorkIdCount();
    // ciDebugOut (( DEB_ITRACE, "merge : wid count %ld\n", widCount ));
    return widCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::OccurrenceCount, public
//
//  Synopsis:   return occurrence count
//
//  History:    21-Jun-91   BartoszM    Created
//
//  Notes:      1. Return occ count of Top of widHeap
//                 Occ counts of other cursors with the
//                 same wid do not count! They will
//                 be returned after NextWorkId is called
//              2. if widHeap empty, replenish it
//
//----------------------------------------------------------------------------

ULONG CMergeCursor::OccurrenceCount()
{

    if ( _widHeap.IsEmpty() && !ReplenishWid() )
    {
        return 0;
    }

    return _widHeap.Top()->OccurrenceCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::HitCount, public
//
//  Synopsis:   return occurrence count
//
//  History:    27-Feb-92   AmyA        Created
//
//  Notes:      see notes for OccurrenceCount().
//
//----------------------------------------------------------------------------

ULONG CMergeCursor::HitCount()
{
    return OccurrenceCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeCursor::ReplenishWid, protected
//
//  Synopsis:   Replenish the wid heap
//
//  Returns:    TRUE if successful, FALSE if key heap exhausted
//
//  Effects:    Updates _iid to the ones of the widHeap top
//
//  History:    06-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

BOOL CMergeCursor::ReplenishWid()
{

    if ( _keyHeap.IsEmpty() )
    {
        return FALSE;
    }

    // Move all cursors with the lowest key
    // to widHeap

    CKeyBuf key = *(_keyHeap.Top()->GetKey());
    do {
        CKeyCursor* cur = _keyHeap.RemoveTop();
        _widHeap.Add ( cur );
    } while ( !_keyHeap.IsEmpty()
        && AreEqual( &key, _keyHeap.Top()->GetKey()) );

    _iid = _widHeap.Top()->IndexId();
    return TRUE;
}

//
// Remove RefillStream() and FreeStream() once NTFS supports
// sparse file operations on parts of a file when other parts
// of the file are mapped.  This won't happen any time soon.
//

void CMergeCursor::FreeStream()
{
    ULONG cCursors = _keyHeap.Count();
    CKeyCursor **aCursors = _keyHeap.GetVector();

    ciDebugOut(( DEB_ITRACE, "free key heap has %d cursors\n", cCursors ));

    for ( ULONG i = 0; i < cCursors; i++ )
        aCursors[ i ]->FreeStream();

    cCursors = _widHeap.Count();
    aCursors = _widHeap.GetVector();

    ciDebugOut(( DEB_ITRACE, "free wid heap has %d cursors\n", cCursors ));

    for ( i = 0; i < cCursors; i++ )
        aCursors[ i ]->FreeStream();
} //FreeStream

void CMergeCursor::RefillStream()
{
    ULONG cCursors = _keyHeap.Count();
    CKeyCursor **aCursors = _keyHeap.GetVector();

    ciDebugOut(( DEB_ITRACE, "refill key heap has %d cursors\n", cCursors ));

    for ( ULONG i = 0; i < cCursors; i++ )
        aCursors[ i ]->RefillStream();

    cCursors = _widHeap.Count();
    aCursors = _widHeap.GetVector();

    ciDebugOut(( DEB_ITRACE, "refill wid heap has %d cursors\n", cCursors ));

    for ( i = 0; i < cCursors; i++ )
        aCursors[ i ]->RefillStream();
} //FreeStream
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\lowres.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 2000.
//
//  File:       LowRes.cxx
//
//  Contents:   Default low-resource detection
//
//  Classes:    CLowRes
//              CUserActivityMonitor
//
//  History:    21-Jul-98   KyleP    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <frmutils.hxx>
#include <pageman.hxx>
#include "lowres.hxx"

CLowRes::CLowRes( CCiFrameworkParams & params )
        : _cRefs(1),
          _params( params ),
          _UserMon( )
{
    //
    // Compute pages-per-meg for use in low memory computations.
    //

    SYSTEM_BASIC_INFORMATION Basic;

    NTSTATUS Status = NtQuerySystemInformation( SystemBasicInformation,
                                                &Basic,
                                                sizeof(Basic),
                                                0 );

    if ( SUCCEEDED(Status) )
    {
        _ulPagesPerMeg = 1024*1024 / Basic.PageSize;
        _ulPageSize = Basic.PageSize;
    }
    else
    {
        _ulPagesPerMeg = 1024*1024 / PAGE_SIZE;
        _ulPageSize = PAGE_SIZE;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    21-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CLowRes::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    21-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CLowRes::Release()
{
    Win4Assert( _cRefs > 0 );

    ULONG uTmp = InterlockedDecrement( (long *) &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    21-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CLowRes::QueryInterface( REFIID   riid,
                                                 void  ** ppvObject)
{
    IUnknown *pUnkTemp = 0;
    SCODE sc = S_OK;

    *ppvObject = 0;

    if ( IID_ICiCResourceMonitor == riid )
        pUnkTemp = (IUnknown *)(ICiCResourceMonitor *) this;
    else if ( IID_IUnknown == riid )
        pUnkTemp = (IUnknown *) this;
    else
        sc = E_NOINTERFACE;

    *ppvObject = (void  *) pUnkTemp;

    if( 0 != pUnkTemp )
        pUnkTemp->AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::IsMemoryLow, public
//
//  Returns:    S_OK if memory is low, S_FALSE if it is not.
//
//  History:    21-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE CLowRes::IsMemoryLow()
{
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;

    NTSTATUS Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                                &PerfInfo,
                                                sizeof(PerfInfo),
                                                0 );

    if ( SUCCEEDED(Status) )
    {
        ULONG ulFreeMeg = (PerfInfo.CommitLimit - PerfInfo.CommittedPages) / _ulPagesPerMeg;

        if ( ulFreeMeg < _params.GetMinWordlistMemory() )
            Status = S_OK;
        else
            Status = S_FALSE;
    }
    else
        Status = E_FAIL;

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::IsBatterLow, public
//
//  Returns:    S_OK if battery power is low, S_FALSE if it is not.
//
//  History:    21-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE CLowRes::IsBatteryLow()
{
    SCODE sc = S_OK;

    SYSTEM_POWER_STATUS PowerStatus;

    ULONG ulMinBattery = _params.GetMinWordlistBattery();

    if ( 0 == ulMinBattery )
        sc = S_FALSE;
    else if ( GetSystemPowerStatus( &PowerStatus ) )
    {
        if ( ( AC_LINE_ONLINE == PowerStatus.ACLineStatus ) ||
             ( ( BATTERY_FLAG_UNKNOWN != PowerStatus.BatteryFlag ) &&
               ( 0 == (PowerStatus.BatteryFlag & BATTERY_FLAG_NO_BATTERY) ) &&
               ( BATTERY_PERCENTAGE_UNKNOWN != PowerStatus.BatteryLifePercent ) &&
               ( PowerStatus.BatteryLifePercent > ulMinBattery ) ) )
        {
            sc = S_FALSE;
        }
    }
    else
    {
        ciDebugOut(( DEB_IWARN, "GetSystemPowerStatus returned %u\n", GetLastError() ));
        sc = HRESULT_FROM_WIN32( GetLastError() );
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::IsOnBatterPower, public
//
//  Returns:    S_OK if on battery power is low, S_FALSE if it is not.
//
//  History:    01-Oct-2000  dlee  Created
//
//--------------------------------------------------------------------------

SCODE CLowRes::IsOnBatteryPower()
{
    SCODE sc = S_OK;

    SYSTEM_POWER_STATUS PowerStatus;

    if ( GetSystemPowerStatus( &PowerStatus ) )
    {
        if ( AC_LINE_ONLINE == PowerStatus.ACLineStatus ) 
            sc = S_FALSE;
    }
    else
    {
        ciDebugOut(( DEB_IWARN, "GetSystemPowerStatus returned %u\n", GetLastError() ));
        sc = HRESULT_FROM_WIN32( GetLastError() );
    }

    return sc;
} //IsOnBatteryPower

//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::IsUserActive, public
//
//  Arguments:  [fCheckLongTerm] - TRUE if long-term activity should be checked.
//                                 Otherwise, short-term activity is checked.
//
//  Returns:    S_OK if user is typing or mousing, S_FALSE if it is not.
//
//  History:    29 Jul 1998   AlanW  Created
//
//--------------------------------------------------------------------------

SCODE CLowRes::IsUserActive( BOOL fCheckLongTerm)
{
    const cIdleThreshold = 5;
    SCODE sc = S_OK;
    const ULONG ulIdleDetectInterval = _params.GetWordlistUserIdle() * 1000;

    if ( 0 == ulIdleDetectInterval )
        sc = S_FALSE;
    else if ( fCheckLongTerm )
    {
        if ( _UserMon.GetUserActivity( ulIdleDetectInterval ) <=
               cIdleThreshold )
            sc = S_FALSE;
    }
    else
    {
        if ( _UserMon.GetUserActivity( 500 ) == 0 )
            sc = S_FALSE;
    }

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::SampleUserActivity, public
//
//  Returns:    S_OK
//
//  History:    29 Jul 1998   AlanW  Created
//
//--------------------------------------------------------------------------

SCODE CLowRes::SampleUserActivity()
{
    _UserMon.SampleUserActivity();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CLowRes::IsIoHigh, public
//
//  Returns:    S_OK if system is in a high i/o state, S_FALSE if it is not.
//
//  History:    21-Jul-1998   KyleP  Created
//
//--------------------------------------------------------------------------

SCODE CLowRes::IsIoHigh( BOOL * pfAbort )
{
    //
    // If the user doesn't care about checking IO, don't spend any time here
    //

    if ( 0xffffffff == _params.GetMaxWordlistIo() )
        return S_FALSE;

    unsigned const cSecSample = 5;
    SCODE scRet = S_FALSE;

    SYSTEM_PERFORMANCE_INFORMATION PerfInfo[2];

    NTSTATUS Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                                &PerfInfo[0],
                                                sizeof(PerfInfo),
                                                0 );

    if ( NT_SUCCESS(Status) )
    {
        //
        // Alertable sleep. Sleep for about 5 seconds total in 200ms increments.
        //
        // NOTE:  When it's about time for the tick count to wrap, dwEndTicks
        //        could be less than the initial value of dwSleepTicks, which
        //        simply means that we could misdiagnose whether the machine is
        //        busy about once in 49 days.
        //

        DWORD dwSleepTicks = GetTickCount();
        DWORD dwEndTicks = dwSleepTicks + cSecSample * 1000;
        while ( dwSleepTicks < dwEndTicks )
        {
            if ( *pfAbort )
                break;

            _UserMon.SampleUserActivity();
            DWORD dwCurrentTicks = GetTickCount();
            if ( dwCurrentTicks >= dwEndTicks )
                break;

            dwSleepTicks += 200;
            if ( dwCurrentTicks < dwSleepTicks )
            {
                //Win4Assert( dwSleepTicks - dwCurrentTicks <= 200 );
                Sleep( dwSleepTicks - dwCurrentTicks );
            }
        }

        Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                           &PerfInfo[1],
                                           sizeof(PerfInfo),
                                           0 );

        if ( NT_SUCCESS(Status) )
        {
            Win4Assert( PerfInfo[1].IoReadTransferCount.QuadPart >= PerfInfo[0].IoReadTransferCount.QuadPart );
            Win4Assert( PerfInfo[1].IoWriteTransferCount.QuadPart >= PerfInfo[0].IoWriteTransferCount.QuadPart );
            Win4Assert( PerfInfo[1].IoOtherTransferCount.QuadPart >= PerfInfo[0].IoOtherTransferCount.QuadPart );
            Win4Assert( PerfInfo[1].PageReadCount >= PerfInfo[0].PageReadCount );
            Win4Assert( PerfInfo[1].CacheReadCount >= PerfInfo[0].CacheReadCount );
            Win4Assert( PerfInfo[1].DirtyPagesWriteCount >= PerfInfo[0].DirtyPagesWriteCount );
            Win4Assert( PerfInfo[1].MappedPagesWriteCount >= PerfInfo[0].MappedPagesWriteCount );

            LONGLONG cIo = PerfInfo[1].IoReadTransferCount.QuadPart - PerfInfo[0].IoReadTransferCount.QuadPart;
            cIo +=         PerfInfo[1].IoWriteTransferCount.QuadPart - PerfInfo[0].IoWriteTransferCount.QuadPart;

            //
            // This doesn't work when a Jaz drive is in the system.
            //

            //cIo +=         PerfInfo[1].IoOtherTransferCount.QuadPart - PerfInfo[0].IoOtherTransferCount.QuadPart;

            cIo +=         (PerfInfo[1].PageReadCount - PerfInfo[0].PageReadCount) * _ulPageSize;
            cIo +=         (PerfInfo[1].CacheReadCount - PerfInfo[0].CacheReadCount) * _ulPageSize;
            cIo +=         (PerfInfo[1].DirtyPagesWriteCount - PerfInfo[0].DirtyPagesWriteCount) * _ulPageSize;
            cIo +=         (PerfInfo[1].MappedPagesWriteCount - PerfInfo[0].MappedPagesWriteCount) * _ulPageSize;


            if ( cIo >= _params.GetMaxWordlistIo() * 1024 * cSecSample )
            {
                ciDebugOut(( DEB_ITRACE, "IsIoHigh: %u bytes in %u seconds is HIGH (more than %u bytes/sec)\n",
                             cIo, cSecSample, _params.GetMaxWordlistIo() * 1024 ));
                scRet = S_OK;
            }
        }
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Method:     CUserActivityMonitor::SampleUserActivity, public
//
//  Synopsis:   Check to see if the user has used the keyboard or mouse
//
//  Returns:    - nothing -
//
//  History:    30 Jul 1998   AlanW  Created
//
//--------------------------------------------------------------------------

void CUserActivityMonitor::SampleUserActivity()
{
#if CIDBG == 1
    if ( 0 == _tid )
        _tid = GetCurrentThreadId();
    else
        Win4Assert( GetCurrentThreadId() == _tid );
#endif // CIDBG == 1


    LASTINPUTINFO ii;

    memset(&ii, 0, sizeof(ii));
    ii.cbSize = sizeof(ii);

    GetLastInputInfo( &ii );
    DWORD dwNow = GetTickCount();

    SetInputFlag( ii.dwTime );
    SetSampleFlag( dwNow );

    if (IsBufferEmpty())
    {
        Win4Assert( _iTail == 0 );
        _adwSamples[_iTail++] = _dwLastInputTime = ii.dwTime;
        _adwSamples[_iTail]   = _dwLastSampleTime = dwNow;
        return;
    }

#if CIDBG == 1
    if ( (Ticks(dwNow) - Ticks(_dwLastSampleTime)) > 5000 )
    {
        DWORD dwPeriod = Ticks(dwNow) - Ticks(_dwLastSampleTime);
        ciDebugOut(( DEB_IWARN,
                     "SampleUserActivity, WARNING - freq. too low.  Interval = %u.%03u\n",
                      dwPeriod/1000, dwPeriod%1000 ));
    }
#endif // CIDBG == 1

    if (ii.dwTime == _dwLastInputTime)
    {
        //
        // No input events since last time we looked.  Just overwrite the last
        // sample time with the current one.
        //
        Win4Assert( IsSample( _adwSamples[_iTail] ) );
#if 0 //CIDBG == 1 note: this can mess up ordering of samples in buffer
        if ( _adwSamples[_iTail] != dwNow )
            Add( dwNow );       // always add the sample time for analysis
#else
        _adwSamples[_iTail] = dwNow;
#endif // CIDBG == 1

    }
    else
    {
        Win4Assert( IsSample( _adwSamples[_iTail] ) );

        //  The following could happen if an input event happens between
        //  the calls to GetLastInputInfo and GetTickCount above.
        if ( Ticks( ii.dwTime ) < Ticks( _adwSamples[_iTail] ) )
        {
            _adwSamples[_iTail] = ii.dwTime - 1;
            Win4Assert( IsSample( _adwSamples[_iTail] ) );
        }

        Add( ii.dwTime );
        Add( dwNow );
    }

    _dwLastInputTime = ii.dwTime;
    _dwLastSampleTime = dwNow;
}


//+-------------------------------------------------------------------------
//
//  Method:     CUserActivityMonitor::GetUserActivity, public
//
//  Synopsis:   Return an indication of the activity level of the interactive user.
//
//  Arguments:  [dwTickCount] - number of ticks to consider for activity
//
//  Returns:    ULONG - number of input events detected over the interval
//
//  Notes:      This may behave oddly around the time when the tick count
//              overflows, but since that may just lead to some misdaiganosis
//              for a few minutes every 7 weeks, it's not worth worrying about.
//
//  History:    30 Jul 1998   AlanW  Created
//
//--------------------------------------------------------------------------

ULONG CUserActivityMonitor::GetUserActivity(ULONG dwTickCount)
{
    DWORD dwStart = Ticks(_dwLastSampleTime) - dwTickCount;

    //
    //  If the interval is very short, just return whether any input
    //  has occurred since that time.
    //
    if ( dwTickCount <= 3000 )
    {
        SampleUserActivity();

        if ( Ticks(_dwLastInputTime) <= dwStart)
            return 0;
        else
            return 1;
    }

    //
    //  Quick return if there has been no activity in the interval.
    //
    if ( Ticks(_dwLastInputTime) <= dwStart)
        return 0;

#if CIDBG == 1
    Analyze( 0x1000 );
#endif // CIDBG == 1

    DWORD dwFirstSample = 0;
    BOOL fFullInterval = FALSE;
    ULONG cInputEvent = 0, cTotalEvents = 0;

    for (unsigned i = _iHead; i != _iTail; i = Next(i))
    {
        DWORD dw = _adwSamples[i];
        if (Ticks(dw) < dwStart)
        {
            fFullInterval = TRUE;
            //
            // If an input event and a sample time bracket the start of
            // the interval, we can consider the input event as the first
            // sample because we know that the user gave no input in that time.
            //
            if ( IsInput(dw) &&
                 Ticks(_adwSamples[ Next(i) ]) >= dwStart )
                dwFirstSample = dw;

            continue;
        }
        else if (0 == dwFirstSample)
            dwFirstSample = dw;

        if (IsInput(dw))
            cInputEvent++;
        cTotalEvents++;
    }

#if CIDBG == 1
    if (! fFullInterval)
    {
        ciDebugOut(( DEB_IWARN,
                    "GetUserActivity, WARNING - sampling freq. too high! missed %d\n",
                     dwFirstSample - dwStart ));
    }
    if (2 == cTotalEvents)
    {
        ciDebugOut(( DEB_IWARN, "GetUserActivity, WARNING - sampling frequency too low\n" ));
    }
#endif // CIDBG == 1

    DWORD dwInterval = Ticks(_dwLastSampleTime) - Ticks(dwFirstSample);

    // Scale the results if we don't have samples for 80% of the requested time
    if (dwInterval*100 < dwTickCount*80)
    {
        // Scale the count found to fit the full interval
        ciDebugOut(( DEB_IWARN, "GetUserActivity, need to scale count %u %u\n",
                     dwInterval, dwTickCount ));
        cInputEvent *= dwTickCount;
        if (dwInterval)
            cInputEvent /= dwInterval;
    }
    return cInputEvent;
}

#if CIDBG == 1
inline void PrintTicks( ULONG infolevel, DWORD dwTicks )
{
    ciDebugOut(( infolevel|DEB_NOCOMPNAME, "%3u.%03u", dwTicks/1000, dwTicks%1000 ));
}

#define SHORT_TERM_IDLE 500
#define LONG_TERM_THRESHOLD 20
#define LONG_TERM_INTERVAL (120 * 1000)

#define MID_TERM_THRESHOLD 10
#define MID_TERM_INTERVAL (30 * 1000)

void CUserActivityMonitor::Analyze( ULONG infolevel )
{
    if (_iSnap == _iTail)
        return;

    ciDebugOut(( infolevel, "\t----\n" ));

    for (unsigned i = _iSnap; i != _iTail; i = Next(i))
    {
        DWORD dw1 = _adwSamples[i];
        DWORD dw2 = _adwSamples[Next(i)];

        if (IsInput(dw1))
        {
            ciDebugOut(( infolevel|DEB_NOCOMPNAME, "%u", dw1 ));
        }
        else
        {
            Win4Assert( Ticks(dw1) <= Ticks(dw2) );
            ciDebugOut(( infolevel|DEB_NOCOMPNAME, "\t%u\n", dw1 ));
        }

        if (Next(i) == _iTail)
            ciDebugOut(( infolevel|DEB_NOCOMPNAME, "\t%u\n", dw2 ));
    }

    DWORD dwStart1 = Ticks(_dwLastSampleTime) - MID_TERM_INTERVAL;
    DWORD dwStart2 = Ticks(_dwLastSampleTime) - LONG_TERM_INTERVAL;
    DWORD dwFirstInput = 0;
    DWORD dwIdleTime = 0;
    DWORD dwUnknTime = 0;
    unsigned cInputEvent = 0;
    unsigned cInputQualified1 = 0;
    unsigned cInputQualified2 = 0;
    unsigned cTotalEvent = 0;

    for (i = _iHead; i != _iTail; i = Next(i))
    {
        DWORD dw1 = _adwSamples[i];
        DWORD dw2 = _adwSamples[Next(i)];

        if (IsInput(dw1))
        {
            Win4Assert( Ticks(dw1) <= Ticks(dw2) );
            cInputEvent++;

            if ( IsSample(dw2) )
                dwIdleTime += Ticks(dw2) - Ticks(dw1);

            if (Ticks(dw1) > dwStart1)
                cInputQualified1++;
            if (Ticks(dw1) > dwStart2)
                cInputQualified2++;
        }
        else
        {
            Win4Assert( Ticks(dw1) <= Ticks(dw2) );
            if ( IsSample(dw2) )
                dwIdleTime += Ticks(dw2) - Ticks(dw1);
            else
                dwUnknTime += Ticks(dw2) - Ticks(dw1);
        }

        cTotalEvent++;
    }

    ciDebugOut(( infolevel, "\tTotal time in buffer\t" ));
    PrintTicks( infolevel, Ticks(_dwLastSampleTime) - Ticks(_adwSamples[_iHead]) );

    ciDebugOut(( infolevel|DEB_NOCOMPNAME, "\n\tTime since last snapshot\t" ));
    PrintTicks( infolevel, Ticks(_dwLastSampleTime) - Ticks(_adwSamples[_iSnap]) );

    ciDebugOut(( infolevel|DEB_NOCOMPNAME, "\n\t\tTrue idle time\t" ));
    PrintTicks( infolevel, dwIdleTime );

    ciDebugOut(( infolevel|DEB_NOCOMPNAME, "\n\t\tUnknown time\t" ));
    PrintTicks( infolevel, dwUnknTime );

    ciDebugOut(( infolevel|DEB_NOCOMPNAME, "\n\t\tInput events\t%7d  Qualified\t%d %d\n", cInputEvent, cInputQualified1, cInputQualified2 ));

    if ( (Ticks(_dwLastSampleTime) - Ticks(_dwLastInputTime)) < SHORT_TERM_IDLE )
    {
        ciDebugOut(( infolevel|DEB_NOCOMPNAME,
                    "\t*** Short term criteria\t%3d %3d\n", SHORT_TERM_IDLE,
                    Ticks(_dwLastSampleTime) - Ticks(_dwLastInputTime) ));
    }

    if ( cInputQualified1 >= MID_TERM_THRESHOLD )
    {
        ciDebugOut(( infolevel|DEB_NOCOMPNAME,
                    "\t*** Mid term threshold\t%2d/%3d %3d\n",
                     MID_TERM_THRESHOLD, MID_TERM_INTERVAL,
                     cInputQualified1 ));
    }
    if ( cInputQualified2 >= LONG_TERM_THRESHOLD )
    {
        ciDebugOut(( infolevel|DEB_NOCOMPNAME,
                    "\t*** Long term threshold\t%2d/%3d %3d\n",
                     LONG_TERM_THRESHOLD, LONG_TERM_INTERVAL,
                     cInputQualified2 ));
    }

    _iSnap = _iTail;
}
#endif // CIDBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\keylist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       keylist.cxx
//
//  Contents:   KeyList
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidxtbl.hxx>
#include <pdir.hxx>
#include <cifailte.hxx>

#include "keylist.hxx"
#include "pcomp.hxx"
#include "keyhash.hxx"

//+---------------------------------------------------------------------------
//
// Member:      CKeyList::GetNextIid, public
//
// Synopsis:    Returns the next valid index id for a new keylist.
//
// History:     31-Oct-93   w-PatG       Created.
//
//----------------------------------------------------------------------------

INDEXID CKeyList::GetNextIid ()
{
    CIndexId CurId = GetId();

    if (!CurId.IsPersistent() || CurId.PersId() == MAX_PERS_ID)
        return CIndexId( 1, partidKeyList );
    else
        return CIndexId( CurId.PersId() + 1, partidKeyList );
}

//+-------------------------------------------------------------------------
//
//  Method:     CKeyList::FillRecord
//
//  Synopsis:   Creates index record for keylist
//
//  Arguments:  [record] -- Record to initialize
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

void CKeyList::FillRecord (CIndexRecord& record) const
{
    record._objectId = ObjectId();
    record._iid = GetId();
    record._type = itKeyList;
    record._maxWorkId = MaxWorkId();
}

#ifdef KEYLIST_ENABLED

//+---------------------------------------------------------------------------
//
// Member:     CKeyList::Size, public
//
// Synopsis:   Returns number of pages in Physical Index.
//
// History:    28-Oct-93    w-PatG       Created.
//
//----------------------------------------------------------------------------

unsigned CKeyList::Size() const
{
    if ( _pPhysIndex )
        return _pPhysIndex->PageSize();
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
// Member:     CKeyList::CKeyList, public
//
// Synopsis:   Default Constructor for CKeyList
//
// Effects:    Creates a dummy KeyList
//
// History:    17-Dec-93   w-PatG       Created.
//
// Note:       The first kid/widMax in a keyList is set to 1 here, since
//             kids overlap in memory with pids, and pid 0, & 1 are reserved.
//
//----------------------------------------------------------------------------

CKeyList::CKeyList()
: CIndex( CIndexId( partidKeyList, MAX_PERS_ID + 1), 1, FALSE ),
  _sigKeyList(eSigKeyList),
  _pstorage(0),
  _obj(0),
  _pPhysIndex(0),
  _pPhysHash(0),
  _pDir(0)
{
    ciDebugOut(( DEB_KEYLIST, "Open null keylist\n" ));
}

//+---------------------------------------------------------------------------
//
// Member:     CKeyList::CKeyList, public
//
// Synopsis:   Constructor for CKeyList
//
// Effects:    Initializes KeyList from disk
//
// Arguments:   [id] -- List ID of the key list.
//              [widMax] -- maximum work id
//
// History:     03-Nov-93   w-PatG       Created.
//              17-Feb-94   KyleP        Initial version
//
//----------------------------------------------------------------------------

CKeyList::CKeyList( PStorage & storage, WORKID objectId, INDEXID iid,
                    KEYID kidMax )
        : CIndex( iid, kidMax, FALSE ),
          _sigKeyList(eSigKeyList),
          _pstorage(&storage),
          _obj ( storage.QueryObject(objectId) ),
          _pPhysIndex(0),
          _pPhysHash(0),
          _pDir(0)
{
    ciDebugOut(( DEB_KEYLIST, "Open keylist 0x%x\n", iid ));

    TRY
    {
        //
        // Open the keylist index stream.
        //
        PMmStream * pStream = storage.QueryExistingIndexStream( _obj.GetObj(),
                                        PStorage::eOpenForRead );
        XPtr<PMmStream> sStream( pStream );
        _pPhysIndex = new CPhysIndex ( storage, _obj.GetObj(), objectId,
                                        PStorage::eOpenForRead,
                                        sStream );

        //
        // Open the keylist hash stream.
        //
        pStream  = storage.QueryExistingHashStream( _obj.GetObj(),
                                        PStorage::eOpenForRead );
        sStream.Set( pStream );
        _pPhysHash = new CPhysHash ( storage, _obj.GetObj(), objectId,
                                      PStorage::eOpenForRead,
                                      sStream );

        //
        // Open the directory.
        //
        _pDir = storage.QueryExistingDirectory ( _obj.GetObj(), PStorage::eOpenForRead );
    }
    CATCH ( CException, e )
    {
        delete _pDir;
        delete _pPhysHash;
        delete _pPhysIndex;

        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CWKeyList::CWKeyList, public
//
//  Synopsis:   Create an empty writeable index
//
//  Arguments:  [storage] -- physical storage
//
//  History:    03-Apr-91   BartoszM       Created.
//              17-Feb-93   KyleP          Initial version
//
//----------------------------------------------------------------------------

CWKeyList::CWKeyList ( PStorage & storage, WORKID objectId, INDEXID iid,
                       unsigned size, CKeyList * pOldKeyList )
        : CKeyList( storage, objectId, iid, pOldKeyList->MaxWorkId(), 0 ),
          _sigWKeyList(eSigWKeyList),
          _pOldKeyCursor( 0),
          _pKeyComp( 0 ),
          _ulPage( 0xFFFFFFFF )
{
    ciDebugOut(( DEB_KEYLIST, "Create keylist 0x%x\n", iid ));

    _keyLast.SetCount(0);

    TRY
    {
        //open a physindex size=1
        PMmStream * pStream = storage.QueryNewIndexStream( _obj.GetObj(),
                                        FALSE   // not a master
                                        );
        XPtr<PMmStream> sStream(pStream);
        _pPhysIndex = new CPhysIndex( storage, _obj.GetObj(),
                                       objectId, size, sStream );
        Win4Assert( !sStream );

        pStream = storage.QueryNewHashStream( _obj.GetObj() );
        sStream.Set(pStream);
        _pPhysHash = new CPhysHash ( storage, _obj.GetObj(), objectId, 0,
                                      sStream );
        Win4Assert( !sStream );

        ciFAILTEST( STATUS_DISK_FULL );

        _pDir = storage.QueryNewDirectory ( _obj.GetObj() );

        _pKeyComp = new CKeyComp( *_pPhysIndex, widInvalid, FALSE );
        _pKeyComp->WriteFirstKeyFull();
        _pOldKeyCursor = pOldKeyList->QueryCursor();
    }
    CATCH ( CException, e )
    {
        delete _pKeyComp;

        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Function:   CWKeyList - Ctor
//
//  Synopsis:   A writable key list constructor used when re-starting a
//              paused master merge.
//
//  Effects:
//
//  Arguments:  [storage]     --  Storage object.
//              [objectId]    --  ObjectId of the new key list.
//              [iid]         --  IndexId of the new key list.
//              [pOldKeyList] --  Pointer to the old key list.
//              [splitKey]    --  The last key that is guaranteed to be
//              written to disk in the split key. If none were written,
//              this will be set to "MinKey".
//
//  History:    4-20-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CWKeyList::CWKeyList ( PStorage & storage, WORKID objectId, INDEXID iid,
                       CKeyList * pOldKeyList,
                       CKeyBuf & splitKey,
                       WORKID    widMax )
        : CKeyList( storage, objectId, iid, widMax, 0 ),
          _sigWKeyList(eSigWKeyList),
          _pOldKeyCursor( 0),
          _pKeyComp( 0 ),
          _ulPage( 0xFFFFFFFF )
{
    ciDebugOut(( DEB_KEYLIST, "Restart keylist 0x%x\n", iid ));

    Win4Assert( widMax >= pOldKeyList->MaxWorkId() );
    _keyLast.SetCount(0);

    TRY
    {
        //
        // Open existing IndexStream, HashStream and Directory stream
        // for write access.
        //
        PMmStream * pStream = storage.QueryExistingIndexStream( _obj.GetObj(),
                                       PStorage::eOpenForWrite );
        XPtr<PMmStream> sStream(pStream);
        _pPhysIndex = new CPhysIndex( storage, _obj.GetObj(), objectId,
                                       PStorage::eOpenForWrite,
                                       sStream
                                      );

        pStream = storage.QueryExistingHashStream( _obj.GetObj(),
                                        PStorage::eOpenForWrite );
        sStream.Set( pStream );
        _pPhysHash = new CPhysHash ( storage, _obj.GetObj(), objectId,
                                      PStorage::eOpenForWrite,
                                      sStream
                                    );

        ciFAILTEST( STATUS_DISK_FULL );

        _pDir = storage.QueryExistingDirectory ( _obj.GetObj(),
                                      PStorage::eOpenForWrite
                                      );

        //
        // Restore the existing directory by reading from the beginning
        // upto the split key.
        //

        BitOffset beginBitOff, endBitOff;

        RestoreDirectory( splitKey, beginBitOff, endBitOff );

        //
        // Create a key compressor which can understand partially filled
        // pages and position to write the next key provided.
        //
        _pKeyComp = new CKeyComp( *_pPhysIndex, widInvalid,
                                   endBitOff, beginBitOff,
                                   splitKey,
                                   FALSE    // don't use links
                                  );

        _pKeyComp->WriteFirstKeyFull();

        //
        // Update the used pages count in the index.
        //
        _pPhysIndex->SetUsedPagesCount( endBitOff.Page() + 1 );

        //
        // Set up the existing keylist cursor to position after the
        // split key.
        //
        if ( splitKey.IsMinKey() )
        {
            _pOldKeyCursor = pOldKeyList->QueryCursor();
        }
        else
        {
            CKey Key( splitKey );
            _pOldKeyCursor = (CKeyDeComp *) pOldKeyList->QueryCursor( &Key );
            if ( _pOldKeyCursor )
            {
                CKeyBuf const * pTemp = _pOldKeyCursor->GetKey();
                if ( pTemp && (pTemp->CompareStr( splitKey ) == 0) )
                {
                    _pOldKeyCursor->GetNextKey();
                }
            }
            _keyLast = splitKey;
        }

    }
    CATCH ( CException, e )
    {
        delete _pKeyComp;

        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Function:   RestoreDirectory
//
//  Synopsis:   Restores the directory object from the keys added to the
//              key list in the previous invocation of master merge.
//
//  Effects:
//
//  Arguments:  [splitKey]    --  The key that is known to be successfully
//              writtent to disk.
//              [beginBitOff] --  Output - beginning offset of the split
//              key.
//              [endBitOff]   --  Output - end offset+1 (bit) of the split
//              key. This is the place where the next key should be written.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:      The "Pid" field in the key is used by the keylist as a
//              "KeyId" and it is a monotonically increasing entity. Each
//              key has a unique "KeyId" and so as part of restore, we have
//              to get the last "KeyId" used thus far.
//
//----------------------------------------------------------------------------

void CWKeyList::RestoreDirectory( CKeyBuf   & splitKey,
                    BitOffset & beginBitOff,
                    BitOffset & endBitOff )
{

    Win4Assert( _pDir );
    Win4Assert( _pPhysIndex );

    beginBitOff.Init(0,0);
    endBitOff.Init(0,0);

    // STACKSTACK
    XPtr<CKeyBuf> xKeyLast(new CKeyBuf());  // initialized to min key

    //
    // Remove all keys in the directory after the split key.
    //
    xKeyLast->FillMin();
    _pDir->DeleteKeysAfter( xKeyLast.GetReference() );

    //
    // "MinKey" is a special case and must be dealt with by assuming
    // that no key was written out.
    //
    if ( splitKey.IsMinKey() )
        return;



    CKeyDeComp decomp( *_pDir, GetId() ,
                        *_pPhysIndex, widInvalid,
                        FALSE,   // Don't use links.
                        FALSE    // Don't use directory.
                      );

    const CKeyBuf *  pKey;


#if CIDBG == 1
    xKeyLast->SetPid(pidContents); // arbitrary but not pidAll
#endif

    for ( pKey = decomp.GetKey() ;
          0 != pKey;
          pKey = decomp.GetNextKey(&beginBitOff) )
    {
        if ( pKey->Pid() > _widMax )
        {
            _widMax = pKey->Pid();
        }

        if ( beginBitOff.Page() != _ulPage &&
             !AreEqualStr(pKey, xKeyLast.GetPointer()))
        {
            _ulPage = beginBitOff.Page();
            _pDir->Add ( beginBitOff, *pKey );
        }

        if ( pKey->CompareStr(splitKey) >= 0 )
        {
           ciDebugOut(( DEB_ITRACE, "RestoreDirectory - SplitKey Found \n" ));
           break;
        }

        xKeyLast.GetReference() = *pKey;
    }

    if (  0 != pKey )
    {
        splitKey = *pKey;
    }
    else {
        splitKey = xKeyLast.GetReference();
    }

    decomp.GetOffset( endBitOff );

    //
    // Need to skip the current key cursor until the last key
    //

    ciDebugOut(( DEB_ITRACE, "KeyList - Restart KeyId 0x%x\n", _widMax ));
    ciDebugOut(( DEB_ITRACE, "Keylist Restart split key is '%ws'\n",
                 splitKey.GetStr() ));
    ciDebugOut(( DEB_ITRACE, "Keylist Restart page:offset = 0x%x:0x%x\n",
                 endBitOff.Page(), endBitOff.Offset() ));

}

//+---------------------------------------------------------------------------
//
// Member:     CKeyList::~CKeyList, public
//
// Synopsis:   Destructor
//
// Effects:    Release all memory used by keylist
//
// History:    31-Oct-93   w-PatG       Created.
//             17-Feb-94   KyleP        Initial version
//
//----------------------------------------------------------------------------

CKeyList::~CKeyList()
{
    delete _pDir;
    delete _pPhysHash;
    delete _pPhysIndex;
}

//+-------------------------------------------------------------------------
//
//  Method:     CWKeyList::CWKeyList
//
//  Synopsis:   Dtor for writeable keylist
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CWKeyList::~CWKeyList()
{

    delete _pOldKeyCursor;
    delete _pKeyComp;
}

//+---------------------------------------------------------------------------
//
// Member:      CKeyList::QueryCursor, public
//
// Synopsis:    Create a cursor for the KeyList
//
// Effects:     Creates a cursor
//
// Returns:     A pointer to a CKeyCursor.
//
// History:     31-Oct-93   w-PatG       Created.
//              17-Feb-94   KyleP        Initial version
//
//----------------------------------------------------------------------------

CKeyCursor * CKeyList::QueryCursor()
{
    if(_pPhysIndex == 0)
    {
        return(0);
    }
    else
    {
        BitOffset posKey;
        CKey key;
        key.FillMin();

        CKeyBuf keyInit;
        _pDir->Seek ( key, &keyInit, posKey );

        ciDebugOut (( DEB_ITRACE, "found key %.*ws at %lx:%lx\n",
            keyInit.StrLen(), keyInit.GetStr(),
            posKey.Page(), posKey.Offset() ));

        CKeyDeComp* pCursor = new CKeyDeComp(
            *_pDir, GetId(), *_pPhysIndex, posKey, keyInit, &key, _widMax, FALSE );

        if ( pCursor->GetKey() == 0 )
        {
            delete pCursor;
            pCursor = 0;
        }

        return pCursor;
    }
}

//+---------------------------------------------------------------------------
//
// Member:      CKeyList::QueryCursor, public
//
// Synopsis:    Create a cursor for the KeyList
//
// Effects:     Creates a cursor
//
// Arguments:   [pkey] -- Key to search for
//
// Returns:     A pointer to a CKeyCursor.
//
// History:     31-Oct-93   w-PatG       Created.
//
//----------------------------------------------------------------------------

COccCursor * CKeyList::QueryCursor( CKey const * pkey,
                                    BOOL isRange,
                                    ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    if(_pPhysIndex == 0)
        return( 0 );
    if (isRange)
    {
        CKey keyEnd;
        keyEnd.FillMax (*pkey);
        return QueryRangeCursor (pkey, &keyEnd, cMaxNodes );
    }

    cMaxNodes--;

    if ( 0 == cMaxNodes )
    {
        ciDebugOut(( DEB_WARN, "Node limit reached in CKeyList::QueryCursor\n" ));
        THROW( CException( STATUS_TOO_MANY_NODES ) );
    }

    BitOffset posKey;
    CKeyBuf keyInit;
    _pDir->Seek ( *pkey, &keyInit, posKey );

    ciDebugOut (( DEB_KEYLIST, "found key %.*ws at %lx:%lx\n",
                  keyInit.StrLen(), keyInit.GetStr(),
                  posKey.Page(), posKey.Offset() ));

    CKeyDeComp* pCursor = new CKeyDeComp(
        *_pDir, GetId(), *_pPhysIndex, posKey, keyInit, pkey, _widMax, FALSE );

    if ( pCursor->GetKey() == 0 )
    {
        delete pCursor;
        pCursor = 0;
    }

    return pCursor;
}

//+-------------------------------------------------------------------------
//
//  Method:     CKeyList::QueryRangeCursor
//
//  Synopsis:   Not (yet) implemented for KeyList
//
//  Arguments:  [pkeyBegin] -- Beginning of range
//              [pkeyEnd]   -- End of range
//
//  Returns:    Cursor
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

COccCursor * CKeyList::QueryRangeCursor( const CKey * pkeyBegin,
                                         const CKey * pkeyEnd,
                                         ULONG & cMaxNodes )
{
    return( 0 );
}

//+-------------------------------------------------------------------------
//
//  Method:     CKeyList::QuerySynCursor
//
//  Synopsis:   Never implemented for KeyList
//
//  Arguments:  [keyArr]  -- Array of keys to merge
//              [isRange] -- True if ???
//
//  Returns:    Cursor
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

COccCursor * CKeyList::QuerySynCursor( CKeyArray & keyArr,
                                       BOOL isRange,
                                       ULONG & cMaxNodes )
{
    Win4Assert( !"CKeyList::QuerySynCursor -- Illegal call" );
    return( 0 );
}

//+-------------------------------------------------------------------------
//
//  Method:     CKeyList::Close
//
//  Synopsis:   Close persistent resources
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

void CKeyList::Close()
{
    if ( _pDir )
        _pDir->Close();

    if ( _pPhysHash )
        _pPhysHash->Close();

    if ( _pPhysIndex )
        _pPhysIndex->Close();
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyList::Remove, public
//
//  Synopsis:   Remove index from storage
//
//  History:    02-May-91   BartoszM       Created.
//              16-Dec-93   w-PatG         Stolen from pindex.
//              28-Jun-94   SrikantS       Modified it to not throw
//                                         exceptions.
//
//----------------------------------------------------------------------------

void CKeyList::Remove()
{
    if ( _pPhysIndex )
    {
        Close();
        _obj->Close();

        if ( !_pstorage->RemoveObject( ObjectId() ) )
        {
            Win4Assert( !"delete of index failed" );
            ciDebugOut(( DEB_ERROR, "Delete of index %08x failed: %d\n",
                         ObjectId(), GetLastError() ));
        }
    }
}

//+---------------------------------------------------------------------------
//
// Member:      CKeyList::KeyToId, public
//
// Synopsis:    Maps from a key to an id.
//
// Arguments:   [pkey] -- pointer to the key to be mapped to ULONG
//
// Returns:     key id - a ULONG
//
// History:     31-Oct-93   w-PatG       Created.
//              17-Feb-94   KyleP        Initial version
//
// Notes:       KeyToId searches for key in index and returns the pid as
//              the key id (kid).
//
//----------------------------------------------------------------------------

KEYID CKeyList::KeyToId( CKey const * pkey )
{
    //
    // These keys must be just a [normalized] word.  No string/value id in
    // front of them.
    //

    Win4Assert( pkey->Pid() == 0 );

    KEYID kid;

    if(_pPhysIndex == 0)
        kid = kidInvalid;
    else
    {
        BitOffset posKey;
        CKeyBuf keyInit;

        _pDir->Seek ( *pkey, &keyInit, posKey );

        ciDebugOut (( DEB_KEYLIST, "found key %.*ws at %lx:%lx\n",
                      keyInit.StrLen(), keyInit.GetStr(),
                      posKey.Page(), posKey.Offset() ));

        CKeyDeComp cur( *_pDir, GetId(), *_pPhysIndex, posKey, keyInit,
                        pkey, _widMax, FALSE );

        CKeyBuf const * pkey2 = cur.GetKey();

        if ( pkey2 == 0 || pkey->CompareStr( *pkey2 ) != 0 )
        {
            kid = kidInvalid;
        }
        else
        {
            kid = pkey2->Pid();
        }
    }

    ciDebugOut(( DEB_KEYLIST, "Key \"%.*ws\" --> id %d\n",
                 pkey->Count()/sizeof(WCHAR), pkey->GetBuf(),
                 kid ));

    return( kid );
}

//+---------------------------------------------------------------------------
//
// Member:      CKeyList::IdToKey, public
//
// Synopsis:    Maps an id to a key.
//
// Arguments:   [ulKid] -- key id to mapped to a key
//              [rkey]  -- the mapped key
//
// History:     31-Oct-93   w-PatG       Created.
//              17-Feb-94   KyleP        Initial version
//
// Notes:       IdToKey uses the key hash to locate the correct leaf page in
//              the directory, then locates that leaf page and initializes
//              a cursor into the index.  The search then proceeds until a
//              key with the matching key id is located or no more keys are
//              found.
//
//----------------------------------------------------------------------------

BOOL CKeyList::IdToKey( KEYID kid, CKey & rkey )
{
    if ( 0 == _pPhysHash )
        return( FALSE );

    if ( kid == 0 || kid > MaxKeyIdInUse() )
        return( FALSE );

    CRKeyHash KeyHash( *_pPhysHash, _pPhysIndex->PageSize() );

    CKeyBuf keyInit;
    keyInit.FillMin();
    BitOffset posKey;

    KeyHash.Find( kid, posKey );

    CKey key;

    CKeyDeComp cur( *_pDir, GetId(), *_pPhysIndex, posKey,
                    keyInit, &key, _widMax, FALSE );

    for ( CKeyBuf const * pkey = cur.GetKey();
          pkey && pkey->Pid() != kid;
          pkey = cur.GetNextKey() )
        continue;          // Null body


    if ( pkey )
        rkey = *pkey;
    else
    {
        Win4Assert( !"Can't find key!" );
        return( FALSE );
    }

    ciDebugOut(( DEB_KEYLIST, "id %d --> Key \"%.*ws\"\n",
                 kid, pkey->StrLen(), pkey->GetStr() ));

    return( TRUE );
}


//+-------------------------------------------------------------------------
//
//  Method:     CWKeyList::PutKey
//
//  Synopsis:   Store new key in keylist
//
//  Effects:    Copies all old keys <= [pKeyAdd] to keylist and then adds
//              [pkeyAdd] if it does not yet exist.
//
//  Arguments:  [pkeyAdd] -- Key to add
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

KEYID CWKeyList::PutKey( CKeyBuf const * pkeyAdd, BitOffset & bitOff )
{
    Win4Assert( _pKeyComp );

    KEYID kid;

    //
    // Only store content keys.  No value keys.
    //

    if ( *(pkeyAdd->GetBuf()) != STRING_KEY )
        return kidInvalid;

    //
    // Write keys from old keylist that are <= current key.
    //

    if ( _pOldKeyCursor )
        for ( CKeyBuf const * pkey = _pOldKeyCursor->GetKey();
              pkey && pkey->CompareStr(*pkeyAdd) <= 0;
              pkey = _pOldKeyCursor->GetNextKey() )
        {
            ciDebugOut(( DEB_KEYLIST, "Keylist: Copy Key \"%.*ws\" -- keyid = %d\n",
                         pkey->StrLen(), pkey->GetStr(), pkey->Pid() ));

            _keyLast = *pkey;
            _pKeyComp->PutKey( &_keyLast, bitOff );

            if ( bitOff.Page() != _ulPage )
            {
                _ulPage = bitOff.Page();
                _pDir->Add ( bitOff, _keyLast );
            }
        }

    //
    // Write this key?
    //

    if ( _keyLast.CompareStr( *pkeyAdd ) < 0 )
    {
        _keyLast = *pkeyAdd;

        _keyLast.SetPid( GetKeyId() );

        kid = _keyLast.Pid();

        ciDebugOut(( DEB_KEYLIST, "Keylist: Add Key \"%.*ws\" -- keyid = %d\n",
                     _keyLast.StrLen(), _keyLast.GetStr(), _keyLast.Pid() ));

        _pKeyComp->PutKey( &_keyLast, bitOff );

        if ( bitOff.Page() != _ulPage )
        {
            _ulPage = bitOff.Page();
            _pDir->Add ( bitOff, _keyLast );
        }
    }
    else
    {
        kid = _keyLast.Pid();
    }

    return kid;
}

//+-------------------------------------------------------------------------
//
//  Method:     CWKeyList::Done
//
//  Synopsis:   Finish writing keylist + build hash
//
//  Effects:    Copy any remaining keys from old keylist and build hash
//              table.  Reopen for read access.
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

void CWKeyList::Done( BOOL & fAbort )
{
    ciDebugOut(( DEB_KEYLIST, "KeyList::Done\n" ));

    //
    // Write remaining keys from old keylist;
    //

    BitOffset bitOff;

    if ( _pOldKeyCursor )
        for ( CKeyBuf const * pkey = _pOldKeyCursor->GetKey();
              pkey && pkey->Count() > 0 && pkey->CompareStr( _keyLast ) > 0;
              pkey = _pOldKeyCursor->GetNextKey() )
        {
            ciDebugOut(( DEB_KEYLIST, "Keylist: Copy Key \"%.*ws\" -- keyid = %d\n",
                         pkey->StrLen(), pkey->GetStr(), pkey->Pid() ));

            _keyLast = *pkey;
            _pKeyComp->PutKey( &_keyLast, bitOff);

            if ( bitOff.Page() != _ulPage )
            {
                _ulPage = bitOff.Page();
                _pDir->Add ( bitOff, _keyLast );
            }
        }

    //
    // Add sentinel key
    //

    _keyLast.FillMax();
    _keyLast.SetPid(1);
    _pKeyComp->PutKey( &_keyLast, bitOff );

    //
    // Add sentinel key to the directory.
    //
    _pDir->Add( bitOff, _keyLast );

    //
    // Close compressor, decompressor and directory
    //

    delete _pOldKeyCursor;
    _pOldKeyCursor = 0;
    delete _pKeyComp;
    _pKeyComp = 0;

    // STACKSTACK
    XPtr<CKeyBuf> xMaxKey(new CKeyBuf());
    xMaxKey->FillMax();
    _pDir->LokFlushDir(xMaxKey.GetReference());
    _pDir->LokBuildDir(xMaxKey.GetReference());

    //
    // Reopen for read access
    //
    _pPhysIndex->Flush();
    _pPhysIndex->Reopen();

    //
    // Rescan to build hash table
    //

    BuildHash( fAbort );
    _pPhysHash->Flush();
    _pPhysHash->Reopen();

}

//+-------------------------------------------------------------------------
//
//  Method:     CWKeyList::BuildHash
//
//  Synopsis:   Build KeyHash
//
//  History:    17-Feb-1994     KyleP       Created
//              15-Aug-1994     SrikantS    Modified not to use the directory
//                                          iterator
//
//--------------------------------------------------------------------------

void CWKeyList::BuildHash( BOOL & fAbort )
{
    CWKeyHash keyhash( *_pPhysHash, _pPhysIndex->PageSize(), MaxKeyIdInUse() );

#if defined(CI_KEYHASH)

    CKeyDeComp * pcur = (CKeyDeComp *) QueryCursor();
    if ( 0 == pcur )
    {
        return;
    }

    BitOffset hashOff;      // Offset written in the hash table for kids.
    BitOffset keyOff;       // Offset of the current key.
    hashOff.Init(0,0);
    keyOff.Init(0,0);

#if CIDBG==1
    unsigned    cKey = 0;
#endif  // CIDBG==1

    for ( const CKeyBuf * pkey = pcur->GetKey(); 0 != pkey;
          pkey = pcur->GetNextKey( &keyOff ) )
    {
        if ( fAbort )
        {
            fAbort = FALSE;
            THROW( CException( STATUS_TOO_LATE ) );
        }

        //
        // Check if the current key starts on a different page from
        // the previous one. If so, we have to update the offset
        // that is written to the hash stream.
        //
        if ( keyOff.Page() != hashOff.Page() )
        {
            Win4Assert( keyOff.Page() > hashOff.Page() );
            hashOff.Init( keyOff.Page(), keyOff.Offset() );
        }

        keyhash.Add( pkey->Pid(), hashOff );

#if CIDBG==1
            cKey++;
#endif  // CIDBG==1

        ciDebugOut(( DEB_KEYLIST, "Hash: index %d, key %.*ws (kid = %d)\n",
                     hashOff.Page(),
                     pkey->StrLen(),
                     pkey->GetStr(),
                     pkey->Pid() ));
    }


    delete pcur;

#endif  // CI_KEYHASH

}

#else   // !KEYLIST_ENABLED


CKeyList::CKeyList()
: CIndex( CIndexId( partidKeyList, MAX_PERS_ID + 1), 1, FALSE )
{
    ciDebugOut(( DEB_KEYLIST, "Open null keylist\n" ));
}

CKeyList::CKeyList( KEYID kidMax, INDEXID iid )
: CIndex( iid, kidMax, FALSE )
{
}

#endif  // !KEYLIST_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\keyhash.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       KeyHash.cxx
//
//  Contents:   Key hash
//
//  History:    17-Feb-1994     KyleP      Created
//              29-May-1994     DwightKr   Changed hash table to store bit
//                                         offset of first key on page, rather
//                                         than just the page number.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "keyhash.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CKeyHash::CKeyHash
//
//  Synopsis:   Construct keyhash
//
//  Arguments:  [cDirEntry] -- Number of leaf directory nodes
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CKeyHash::CKeyHash( unsigned cDirEntry )
        : _cBitsPerEntry( Size(cDirEntry) )
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CRKeyHash::CRKeyHash
//
//  Synopsis:   Construct keyhash
//
//  Arguments:  [physHash]  -- On disk stream
//              [cDirEntry] -- Number of leaf directory nodes
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CRKeyHash::CRKeyHash( CPhysHash & physHash, unsigned cDirEntry )
        : CKeyHash(cDirEntry),
          _bitstm( physHash )
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CRKeyHash::Find
//
//  Synopsis:   Lookup value for key in hash
//
//  Arguments:  [kid] -- Key id
//
//  Returns:    Bitoffset for [kid]
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

void CRKeyHash::Find( KEYID kid, BitOffset & resultOffset )
{
    BitOffset off = KidToOff(kid);

    _bitstm.Seek( off );

    ULONG ulResult  = _bitstm.GetBits( BitsPerEntry() );
    resultOffset.Init( ulResult >> BITS_IN_CI_PAGE_SIZE,
                       ulResult & CI_PAGE_MASK);


    ciDebugOut(( DEB_KEYLIST, "KeyHash: kid %u --> page,off 0x%x,0x%x\n",
                 kid, resultOffset.Page(), resultOffset.Offset() ));
}

//+-------------------------------------------------------------------------
//
//  Method:     CWKeyHash::CWKeyHash
//
//  Synopsis:   Construct keyhash
//
//  Arguments:  [physHash]  -- On disk stream
//              [cDirEntry] -- Number of leaf directory nodes
//              [kidMax]    -- Number of keys to be stored
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CWKeyHash::CWKeyHash( CPhysHash & physHash, unsigned cDirEntry, KEYID kidMax )
        : CKeyHash(cDirEntry),
          _bitstm( physHash )
{
    //
    // Zero all pages by touching them.
    //

    BitOffset off = KidToOff(kidMax+1);

    ciDebugOut(( DEB_KEYLIST, "KeyHash: Zeroing %d pages\n", off.Page() ));

    for ( ULONG i = 0; i <= off.Page(); i++ )
    {
        physHash.BorrowNewBuffer( i );
        physHash.ReturnBuffer( i );
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CWKeyHash::Add
//
//  Synopsis:   Add mapping for new key
//
//  Arguments:  [kid]    -- Key id
//              [bitOff] -- Directory entry corresponding to [kid]
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

void CWKeyHash::Add( KEYID kid, BitOffset & bitOff )
{
    BitOffset off = KidToOff(kid);
    _bitstm.Seek( off );

    Win4Assert(bitOff.Page() < 0x100000);   // Fits into a 20-bit number
    ULONG ulDirEntry = (bitOff.Page() << BITS_IN_CI_PAGE_SIZE ) | bitOff.Offset();

    _bitstm.OverwriteBits( ulDirEntry, BitsPerEntry() );

    ciDebugOut(( DEB_KEYLIST, "KeyHash: WRITE kid %u = page,offset 0x%x,0x%x\n",
                 kid, bitOff.Page(), bitOff.Offset() ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\merge.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000,
//
//  File:   MERGE.CXX
//
//  Contents:   Merge object
//
//  Classes:    CMerge
//
//  History:    13-Nov-91   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pstore.hxx>
#include <cifailte.hxx>

#include "merge.hxx"
#include "resman.hxx"
#include "partn.hxx"
#include "mindex.hxx"
#include "mmerglog.hxx"
#include "indxact.hxx"

const unsigned TWO_MEGABYTES = 0x200000;

class CStartMergeTrans : public CTransaction
{
public:

    CStartMergeTrans( CMerge & merge ) : _merge(merge)
    {
    }

    ~CStartMergeTrans()
    {
        if ( GetStatus() != CTransaction::XActCommit)
        {
            _merge.LokRollBack();
        }
    }

private:

    CMerge &    _merge;
};

//+---------------------------------------------------------------------------
//
//  Class:      XWid
//
//  Purpose:    Smart Pointer for a workID, destroys it if not acquired
//
//  History:    11-Apr-95      DwightKr     Created
//
//----------------------------------------------------------------------------

class XWid
{
public:
    XWid(WORKID wid, PStorage & storage) : _wid(wid), _storage(storage)
    {
    }

   ~XWid()
    {
        if (widInvalid != _wid)
            _storage.RemoveObject( _wid );
    }

    WORKID Acquire()
    {
        WORKID wid=_wid;
        _wid=widInvalid;
        return wid;
    }

private:
    WORKID     _wid;
    PStorage & _storage;
};

//+---------------------------------------------------------------------------
//
//  Member:     CMerge::CMerge, public
//
//  Synopsis:   Initializes resources to 0
//
//  Arguments:  [resman] -- resource manager
//              [partid] -- partition id
//              [mt]     -- merge type
//
//  History:    13-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------


CMerge::CMerge ( CResManager& resman, PARTITIONID partid, MergeType mt )
:   _partid(partid),
    _resman(resman),
    _pPart(0),
    _iidNew(iidInvalid),
    _widNewIndex(widInvalid),
    _mt(mt),
    _indSnap(resman),
    _pIndexNew(0),
    _aIidOld(0),
    _cIidOld(0)
{
}


//+---------------------------------------------------------------------------
//
//  Function:   LokSetup
//
//  Synopsis:   Common setup for shadow merge as well as master merge.
//              Creates the index snapshot for merge and a wid for the
//              new index.
//
//  History:    8-30-94   srikants  Moved from LokGrabResources as part of
//                                  separating CMerge from CMasterMerge.
//
//----------------------------------------------------------------------------

void CMerge::LokSetup( BOOL fIsMasterMerge )
{
    Win4Assert( mtAnnealing == _mt || mtShadow == _mt || mtMaster == _mt
                || mtIncrBackup == _mt || mtDeletes == _mt );

    // in case this merge was forced
    _resman.LokClearForceMerge();

    // Get the partition
    _pPart = _resman.LokGetPartition(_partid);

    // Create unique persisten index id
    _iidNew = _pPart->LokMakePersId();

    if ( _iidNew == iidInvalid )
    {
        ciDebugOut (( DEB_ITRACE, "Out of persistent index id's\n" ));

        // No real problem.  We'll retry merging later once a query frees
        // up some indexes.

        THROW ( CException ( CI_OUT_OF_INDEX_IDS ));
    }

    ciFAILTEST( STATUS_NO_MEMORY );

    // Initialize source indexes

    _indSnap.LokInit( *_pPart, _mt );

    if (_indSnap.Count() == 0)
    {
        return;
    }

    USN usnMin = 0x100000000i64;

    // allocate and initialize array of index id's
    _cIidOld = _indSnap.Count();
    _aIidOld = new INDEXID [_cIidOld];

    for ( unsigned i = 0; i < _cIidOld; i++ )
    {
        _aIidOld[i] = _indSnap.GetId(i);
        if ( _indSnap.GetUsn(i) < usnMin)
        {
            usnMin = _indSnap.GetUsn(i);
        }
    }

    // create empty persistent index
    PStorage::EDefaultStrmType strmType =
            fIsMasterMerge ? PStorage::eSparseIndex : PStorage::eNonSparseIndex;

    _widNewIndex  = _resman._storage.CreateObjectId( _iidNew, strmType );
} //LokSetup

//+---------------------------------------------------------------------------
//
//  Member:     CMerge::LokGrabResources, public
//
//  Synopsis:   Initializes all the resources needed to merge
//
//  History:    13-Nov-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CMerge::LokGrabResources( )
{
    Win4Assert( mtAnnealing == _mt || mtShadow == _mt || mtIncrBackup == _mt ||
                mtDeletes == _mt );

    // =================================================
    CStartMergeTrans xact( *this );

    LokSetup( FALSE );

    if (_indSnap.Count() == 0)
    {
        _pPart->FreeIndexId( _iidNew );
        return;
    }

    // a piece of heuristics
    unsigned size = _indSnap.TotalSizeInPages();

    ciFAILTEST(STATUS_NO_MEMORY);

    Win4Assert( 0 == _pIndexNew );

    _pIndexNew = new CPersIndex( _resman._storage,
                                 _widNewIndex,
                                 _iidNew,
                                 size,
                                 CDiskIndex::eShadow );

    ciFAILTEST(STATUS_NO_MEMORY);

    xact.Commit();
    // =================================================
} //LokGrabResources

//+---------------------------------------------------------------------------
//
//  Member:     CMerge::~CMerge, public
//
//  Synopsis:   Frees resources no longer needed
//              (whether merge was successful or not)
//
//  History:    13-Nov-91   BartoszM       Created.
//
//  Notes:      ResMan NOT LOCKED
//
//----------------------------------------------------------------------------
CMerge::~CMerge()
{
    Win4Assert( 0 == _pIndexNew );

    delete _aIidOld;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMerge::LokRollBack, public
//
//  Synopsis:   Puts back old indexes into partition, removes
//              the new index. Deletes the new index from storage,
//              Frees the new index id.
//
//  Arguments:  [swapped] -- number of old indexes removed from partition
//
//  History:    13-Nov-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CMerge::LokRollBack( unsigned swapped )
{
    ciDebugOut (( DEB_ITRACE, "Merge::RollBack\n" ));

    if ( swapped != 0 )
    {
        for ( unsigned i=0; i < swapped; i++ )
            _pPart->AddIndex ( _indSnap.Get(i) );

        if ( swapped == _indSnap.Count() )
            _pPart->LokRemoveIndex ( _iidNew );
    }

    if ( 0 != _pIndexNew )
    {
        // Delete from storage
        _pIndexNew->Remove();
        delete _pIndexNew;
        _pIndexNew = 0;
    }
    else if ( widInvalid != _widNewIndex )
    {
        //
        // This can happen if the new index creation fails after
        // the wid has been allocated. The wid must be deleted.
        //
        _resman._storage.RemoveObject( _widNewIndex );
    }

    if ( _iidNew != iidInvalid )
        _pPart->FreeIndexId ( _iidNew );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMerge::LokZombify, public
//
//  Synopsis:   Deletes old indexes (they are still in use
//              until the destructor of Merge frees them)
//
//  History:    13-Nov-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CMerge::LokZombify()
{
    for ( unsigned i = 0; i < _indSnap.Count(); i++ )
    {
        CIndex* pIndex = _indSnap.Get(i);
        if ( pIndex != 0 )
        {
            pIndex->Zombify();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CMerge::Do, public
//
//  Synopsis:   Do the merge
//
//  Arguments:  [mergeProgress] reference to location where % merge complete
//              can be stored to update perfmon counters
//
//  Signals:    CException
//
//  History:    13-Nov-91   BartoszM       Created.
//
//  Notes:      ResMan NOT LOCKED
//
//----------------------------------------------------------------------------

void CMerge::Do(CCiFrmPerfCounter & mergeProgress)
{
    _pIndexNew->Merge ( _indSnap,
                        *_pPart,
                        mergeProgress,
                        FALSE    // no relevant words computation
                      );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMerge::LokStoreRestartResources, private
//
//  Synopsis:   Persistently stores resources needed to restart a master merge.
//
//  History:    04-Apr-94   DwightKr       Created.
//              23-Aug-94   SrikantS       Moved from CMerge.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------
void CMasterMerge::LokStoreRestartResources( CDeletedIIDTrans & delIIDTrans )
{
    {
        PRcovStorageObj *pPersMMergeLog = _resman._storage.QueryMMergeLog(_widMasterLog);
        SRcovStorageObj PersMMergeLog( pPersMMergeLog);

        //
        // Inside kernel, we are guaranteed that a new object has no data in
        // it. In user space, we may be using an object that was not deleted
        // before due to a failure.
        //
        PersMMergeLog->InitHeader(_resman.GetStorageVersion());    // reset the header contents

        CNewMMergeLog newMMergeLog(*pPersMMergeLog);

        unsigned cIndOld = LokCountOld();
        INDEXID* aIidOld = LokGetIidList();

        for (unsigned i=0; i<cIndOld; i++)
        {
            CIndexId    iid(aIidOld[i]);
            newMMergeLog.AddPersistentIndex( iid );
        }

        newMMergeLog.SetIndexWidMax( _indSnap.MaxWorkId() );
        newMMergeLog.SetKeyListWidMax( _resman._sKeyList->MaxWorkId() );

        newMMergeLog.Commit();
        newMMergeLog.DoCommit();
    }

    //
    //  Add new index & master log to index list
    //
    //
    CIndexRecord record;

    record._objectId  = _widNewIndex;
    record._iid       = _iidNew;
    record._type      = itNewMaster;
    record._maxWorkId = 0;

    //
    // The index snap shot belongs to the Partition object after the
    // merge information has been committed in the index table.
    // Since a memory allocation could fail, we must allocate the
    // necessary memory before committing the start of master merge.
    //
    CIndexSnapshot * pMergeIndSnap = new CIndexSnapshot( _resman );
    SIndexSnapshot   sMergeIndSnap( pMergeIndSnap );
    sMergeIndSnap->LokTakeIndexes( _indSnap );

    ciFAILTEST( STATUS_NO_MEMORY );

    //
    // Commit the beginning of a new master merge in the index table.
    //
    _resman._idxTab->AddMMergeObjects( _pPart->GetId(),
                                        record,
                                       _widMasterLog,
                                       _widKeyList,
                                       delIIDTrans.GetOldDelIID(),
                                       delIIDTrans.GetNewDelIID()
                                     );

    //
    // Commit the starting of a new master merge by storing the
    // wids and iids in-memory.
    //
    delIIDTrans.Commit();

    _resman._storage.SetSpecialItObjectId( itMMKeyList, _widKeyList );

    _pPart->SetMMergeObjectIds( _widMasterLog,
                                _widNewIndex,
                                _widCurrentMaster
                              );

    _pPart->RegisterId( _iidNew );
    _pPart->SetNewMasterIid( _iidNew );

    //
    // Mark all the indexes participating in the master merge in memory
    // to prevent them from being used for another shadow merge.
    //
    unsigned cInd;
    CIndex** apIndex = sMergeIndSnap->LokGetIndexes( cInd );
    for ( unsigned i = 0; i < cInd; i++ )
    {
        apIndex[i]->SetInMasterMerge();
    }

    //
    // Transfer the ownership of the merge index snapshot to the partition
    // object. The ownership will be taken over by the MasterMergeIndex
    // when it is created.  Once the beginning of a master merge is
    // committed, the index snapshot MUST survive until it completes.
    // Until a CMasterMergeIndex is created, the partition object will be
    // the owner of this index snapshot.
    //
    _pPart->TakeMMergeIndSnap( sMergeIndSnap.Acquire() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CMerge::LokLoadRestartResources
//
//  Synopsis:   Loads restart resources needed to restart a master merge.
//
//  History:    04-Apr-94   DwightKr       Created.
//              23-Aug-94   SrikantS       Moved from CMerge.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------
void CMasterMerge::LokLoadRestartResources()
{

    // in case this merge was forced
    _resman.LokClearForceMerge();
    _pPart  = _resman.LokGetPartition(_partid);
    _mt     = mtMaster;
    _fSoftAbort = TRUE;     // if there is a failure, only a soft abort
                            // must be done.


    // =================================================
    CStartMergeTrans   xact( *this );

#ifdef KEYLIST_ENABLED
    _widKeyList = _resman._storage.GetSpecialItObjectId( itMMKeyList );
    Win4Assert( widInvalid != _widKeyList );
#endif  // !KEYLIST_ENABLED

    _pPart->GetMMergeObjectIds( _widMasterLog,
                                _widNewIndex,
                                _widCurrentMaster
                              );



    //
    //  Restore the list of index participating in this merge into the indSnap
    //  object.
    //
    {
        PRcovStorageObj *pLog   = _resman._storage.QueryMMergeLog(_widMasterLog);
        SRcovStorageObj SLog(pLog);

        //
        // Since this is a restarted master merge, there is no need to
        // get the merge indexes. Just get a fresh test.
        //
        _indSnap.LokInitFreshTest();

        {

            //
            // Create the key list which was being built along with the index.
            //
            XPtr<CMMergeLog> xMMergeLog( new CMMergeLog( *pLog ) );

            //
            // We should use the minimum key of key list and index split
            // keys as the split key for the key list.
            //
            CKeyBuf *   pKeyLstSplitKey = new CKeyBuf();
            SKeyBuf     sKeyLstSplitKey(pKeyLstSplitKey);
            BitOffset   beginBitOff;
            BitOffset   endBitOff;

            CKeyBuf *   pIdxSplitKey = new CKeyBuf();
            SKeyBuf     sIdxSplitKey(pIdxSplitKey);

            xMMergeLog->GetKeyListSplitKeyInfo( *pKeyLstSplitKey,
                                                beginBitOff,
                                                endBitOff );

            xMMergeLog->GetIdxSplitKeyInfo( *pIdxSplitKey,
                                             beginBitOff,
                                             endBitOff );

            if ( pIdxSplitKey->IsMinKey() ||
                 pKeyLstSplitKey->Compare( *pIdxSplitKey ) > 0 )
            {
                *pKeyLstSplitKey = *pIdxSplitKey;
            }


            INDEXID iidNew = _resman._sKeyList->GetNextIid();


            #ifdef KEYLIST_ENABLED

            _widKeyList = iidNew;

            _pNewKeyList = new CWKeyList( _resman._storage,
                                           _widKeyList,
                                           iidNew,
                                           _resman._sKeyList.GetPointer(),
                                           *pKeyLstSplitKey,
                                           xMMergeLog->GetKeyListWidMax() );
            #else   // KEYLIST_ENABLED

            _pNewKeyList = new CWKeyList( 0, iidNew );

            #endif  // !KEYLIST_ENABLED

        }
    }

    //
    // Create or get the target master index.
    //
    CMasterMergeIndex * pIndexNew = LokCreateOrFindNewMaster();

    Win4Assert( 0 == _indSnap.Count() );
    CIndexSnapshot & indSnap = pIndexNew->LokGetIndSnap();
    Win4Assert( 0 != &indSnap );

    //
    // allocate and initialize array of index id's
    //
    _cIidOld = indSnap.Count();
    _aIidOld = new INDEXID [_cIidOld];
    for ( unsigned i = 0; i < _cIidOld; i++ )
    {
        _aIidOld[i] = indSnap.GetId(i);
    }

    xact.Commit();
    // =================================================
}


//+---------------------------------------------------------------------------
//
//  Member:     CMasterMerge::LokGrabResources, public
//
//  Synopsis:   Initializes all the resources needed to merge
//
//  History:    13-Nov-91   BartoszM       Created.
//              23-Aug-94   SrikantS       ReWrote for CMasterMerge.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CMasterMerge::LokGrabResources( CDeletedIIDTrans & delIIDTrans )
{
    Win4Assert( mtMaster == _mt );

    // =================================================
    CStartMergeTrans   xact( *this );

    LokSetup( TRUE );

    if (_indSnap.Count() == 0)
    {
        return;
    }

    Win4Assert( !_fSoftAbort );

    {
        WORKID widDummy;
        _pPart->GetMMergeObjectIds(widDummy, widDummy, _widCurrentMaster);

        INDEXID iidNewKeyList = _resman._sKeyList->GetNextIid();

        //
        // For down-level, the ObjectId for logs like the master merge log,
        // change log, etc are formed by concatenating the "it" value to
        // the partition-id.
        //
        CIndexId iidMMLog( itMMLog, _partid );
        _widMasterLog = (INDEXID) iidMMLog;
        XWid xWidMasterLog( _widMasterLog, _resman._storage );

#ifdef KEYLIST_ENABLED
        _widKeyList = (INDEXID) iidNewKeyList;
        XWid xWidKeyList( _widKeyList, _resman._storage );
#endif  // KEYLIST_ENABLED

        _resman._storage.InitRcovObj(_widMasterLog, FALSE);

        //
        // Ideally, this should be the order of steps:
        // 1. Create the KeyList and the New Master Index
        // 2. Store the master merge state.
        //
        // However, OFS imposes an ordering on the opening of objects.
        // We cannot open the IndexTable object for write access when
        // we have other ci objects (like an index or keylist) opened
        // for write access in the same thread.
        //
        // Because of this restriction, we have to update the index table
        // first which means we must be able to tolerate failures after
        // we have committed the start of a master merge in the index
        // table.
        //

        {
#ifdef KEYLIST_ENABLED
            //
            // We don't want the creation of key list to fail after
            // we have created the index and hash streams and before
            // we have created the directory stream. So, first try to
            // create the entire key list object and if it succeeds we
            // don't have to deal with a partially constructed key list.
            //

            CWKeyList * pNewKeyList = new CWKeyList ( _resman._storage,
                                        _widKeyList,
                                        iidNewKeyList,
                                        _resman._sKeyList->Size(),
                                        _resman._sKeyList.GetPointer() );  //approx of size
            //
            // We must delete is here. O/W inversion of priority levels
            // will cause a deadlock in OFS.
            //
            delete pNewKeyList;
#endif  // KEYLIST_ENABLED

            //
            // Pre-Create the master index with all the streams to deal
            // with the possibility of failing after committing the start
            // of a master merge but before we succeeded in creating all
            // the streams. On a restart, the master merge index EXPECTS
            // to find all the necessary streams (index/dir).
            //
            // Create the new index with a size of 64k.  This
            // reduces the free disk space required for a master merge to
            // approximately 64k.  We'll be decommiting (shrink from front)
            // the old master index as the merge progress.
            //
            // Note that the initial size is in 4k CI pages.
            //

            unsigned c4kPages = 65536 / 4096; // 16

            ciDebugOut(( DEB_ITRACE,
                         "creating new master index of size 0x%x bytes\n",
                         c4kPages * 4096 ));

            CPersIndex * pIndex = new CPersIndex( _resman._storage,
                                                  _widNewIndex,
                                                  _iidNew,
                                                  c4kPages,
                                                  CDiskIndex::eMaster );

            delete pIndex;
        }

        ciFAILTEST(STATUS_NO_MEMORY);


        //
        // Store the master merge state.
        //
        LokStoreRestartResources( delIIDTrans );

        //
        //  Acquire the master log & keylist wids so that they are NOT deleted
        //  from disk if an exception occurs.  Once LokStoreRestartResources()
        //  completes, any future exceptions should cause the merge to restart
        //  from a 'paused' condition.
        //
        xWidMasterLog.Acquire();

#ifdef KEYLIST_ENABLED
        xWidKeyList.Acquire();
#endif  // KEYLIST_ENABLED

        _fSoftAbort = TRUE;

        ciFAILTEST(STATUS_NO_MEMORY);

        //
        // After this point we are in a master merge and any failure
        // must be tolerated.  Create a new master index. If there is a
        // failure while creating the in-memory structure, it can be created
        // later when merge is re-attempted.
        //
        LokCreateOrFindNewMaster();

        ciFAILTEST(STATUS_NO_MEMORY);

#ifdef KEYLIST_ENABLED
        //
        // Open the pre-created keylist.
        //
        CKeyBuf *   pKeyLstSplitKey = new CKeyBuf();
        SKeyBuf     sKeyLstSplitKey(pKeyLstSplitKey);
        pKeyLstSplitKey->FillMin();
        _pNewKeyList = new CWKeyList ( _resman._storage,
                                        _widKeyList,
                                        iidNewKeyList,
                                        _resman._sKeyList.GetPointer(),
                                        *pKeyLstSplitKey,
                                        _resman._sKeyList->MaxWorkId()
                                      );

#else

        _pNewKeyList = new CWKeyList(
                                            0,
                                            iidNewKeyList);
#endif  // KEYLIST_ENABLED

    }

    ciFAILTEST(STATUS_NO_MEMORY);

    xact.Commit();
}


void CMasterMerge::Do(CCiFrmPerfCounter & mergeProgress)
{
    CMasterMergeIndex * pIndexNew = (CMasterMergeIndex *)_pIndexNew;
    pIndexNew->Merge (  _pNewKeyList,
                        _indSnap.GetFresh(),
                        *_pPart,
                        mergeProgress,
                        _resman.GetRegParams(),
                        TRUE        // Compute Relevant Words
                       );
}


CMasterMerge::~CMasterMerge()
{
    Win4Assert( 0 == _pNewKeyList );
}

//+---------------------------------------------------------------------------
//
//  Function:   LokRollBack
//
//  Synopsis:   Rollsback a "paused" or "aborted" master merge. A master
//              merge is aborted only if it fails before it has been
//              recorded in the index table. Once the start has been
//              committted, it can only be "paused" and must be restarted
//              later. If _fSoftAbort is TRUE, then we have already committed
//              the start of master merge and should do a soft abort only.
//
//  Arguments:  [swapped] --
//
//  History:    8-30-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CMasterMerge::LokRollBack( unsigned swapped )
{

    if ( _pNewKeyList )
    {

#if KEYLIST_ENABLED
        if ( !_fSoftAbort )
            _pNewKeyList->Remove();
#endif  // KEYLIST_ENABLED

        delete _pNewKeyList;
        _pNewKeyList = 0;
    }

    if ( _fSoftAbort )
    {
        _pIndexNew = 0;
        return;
    }

    //
    // It is not a soft abort. Must completely abort the master merge.
    //
    CMerge::LokRollBack( swapped );
}

//+---------------------------------------------------------------------------
//
//  Function:   LokCreateOrFindNewMaster
//
//  Synopsis:   This routine either "creates" a new CMasterMergeIndex if
//              one doesn't already exist or use an existing one if it
//              already exists in the partition.
//
//  History:    8-30-94   srikants   Moved and adapted from CMerge.
//
//  Notes:
//
//----------------------------------------------------------------------------
CMasterMergeIndex * CMasterMerge::LokCreateOrFindNewMaster()
{
    Win4Assert( 0 == _pIndexNew );

    CPersIndex * pCurrentMasterIndex = _pPart->GetCurrentMasterIndex();
    _iidNew = _pPart->GetNewMasterIid();

    CMasterMergeIndex * pIndexNew = 0;

    if ( 0 != pCurrentMasterIndex &&
         pCurrentMasterIndex->GetId() == _iidNew )
    {
        //
        // The New Master Index already exists and has been given
        // to the partition. We should use that.
        //
        Win4Assert( _pPart->GetOldMasterIndex() != pCurrentMasterIndex );
        _pIndexNew = pCurrentMasterIndex;
        pIndexNew = (CMasterMergeIndex *)_pIndexNew;
    }
    else
    {
        CIndexSnapshot * pMergeIndSnap = _pPart->GetMMergeIndSnap();
        Win4Assert( 0 != pMergeIndSnap );

        //
        // The indexid of the new master index is different from the
        // current master index (if one exists). So, we are restarting
        // a stopped master merge which failed before the new master
        // index was created.
        //
        pIndexNew = new CMasterMergeIndex( _resman._storage,
                                             _widNewIndex,
                                             _iidNew,
                                             pMergeIndSnap->MaxWorkId(),
                                             pCurrentMasterIndex,
                                             _widMasterLog );

        _pIndexNew = pIndexNew;
        pIndexNew->SetMMergeIndSnap( _pPart->AcquireMMergeIndSnap() );

        _pPart->AddIndex ( _pIndexNew );

        if ( 0 != pCurrentMasterIndex )
        {
            _pPart->LokRemoveIndex( pCurrentMasterIndex->GetId() );
            _pPart->SetOldMasterIndex( pCurrentMasterIndex );
        }

        Win4Assert( _pIndexNew->IsMaster() );
        Win4Assert( _pPart->GetCurrentMasterIndex() == _pIndexNew );
    }

    return pIndexNew;
} //LokCreateOrFindNewMaster

//+---------------------------------------------------------------------------
//
//  Function:   LokTakeIndexes
//
//  Synopsis:   Takes ownership of the merge indexes from the
//              CMasterMergeIndex. This is done at the end to complete the
//              commitment of the master merge and the indexsnapshot in the
//              merge object should have all the indexes that participated
//              in the merge.
//
//  Arguments:  [pMaster] -- Pointer to the CMasterMergeIndex.
//
//  History:    9-29-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CMasterMerge::LokTakeIndexes( CMasterMergeIndex * pMaster )
{
    _indSnap.LokTakeIndexes( pMaster->LokGetIndSnap() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\mmerglog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       mmerglog.cxx
//
//  Contents:   Implementation of the master merge log.
//
//  Classes:    CMMergeLog, CNewMMergeLog, CMMergeIdxIter
//
//  Functions:
//
//  History:    3-30-94   srikants   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <eventlog.hxx>

#include "mmerglog.hxx"

IMPL_DYNARRAY_INPLACE(CIndexIdArray, CIndexId );


//+---------------------------------------------------------------------------
//
//  Function:   CMMergeIndexList constructor
//
//  Synopsis:   A dynamic index array.
//
//  Arguments:  [cShadowIndex] --  Initial guess of number of indexes likely
//              to be added to the list.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CMMergeIndexList::CMMergeIndexList( ULONG  cShadowIndex )
:   _aShadowIndex( cShadowIndex ), _cShadowIndex(0), _sigIdxList(sigIdxList)
{
}

//+---------------------------------------------------------------------------
//
//  Function:   GetIndex
//
//  Synopsis:   Given the "offset" into the indexlist(array), it returns
//              the "indexId" in that offset.
//
//  Arguments:  [iid]  -- Output - will have the indexid.
//              [nIdx] -- Offset into the array.
//
//  Returns:    if the specified offset is within the range. FALSE o/w.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CMMergeIndexList::GetIndex( CIndexId & iid, ULONG nIdx )
{
    if ( nIdx >= _cShadowIndex )
    {
        return(FALSE);
    }

    iid = _aShadowIndex.Get(nIdx);
    return(TRUE);
}

void CMMergeIndexList::AddIndex( CIndexId & iid )
{
    _aShadowIndex.Add( iid, _cShadowIndex );
    _cShadowIndex++;
}

//+---------------------------------------------------------------------------
//
//  Function:   Serialize
//
//  Synopsis:   Serializes the index list using the given write transaction.
//
//  Arguments:  [trans] -- Write transaction of which this is part of.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CMMergeIndexList::Serialize( CRcovStrmWriteTrans &  trans )
{
    //
    // First write the signature and the count of shadow indexes.
    //
    ciAssert( _sigIdxList == sigIdxList );
    trans.Empty();

    trans.Append( this, OFFSET(CMMergeIndexList, _aShadowIndex) );

    //
    // Now append the shadow index ids that are participating in the
    // master merge.
    //
    for ( ULONG i = 0; i < _cShadowIndex; i++ )
    {
        CIndexId & iid = _aShadowIndex.Get(i);
        trans.Append( &iid, sizeof(CIndexId) );
    }

}

void CMMergeIndexList::DeSerialize( CRcovStrmReadTrans & trans,
                                    PRcovStorageObj & obj )
{
    //
    // Rewind and read the signature and count of shadow indexes
    // participating in the master merge.
    //
    trans.Seek(0);
    ULONG   cbValid = obj.GetHeader().GetUserDataSize(
                        obj.GetHeader().GetPrimary() );
    ULONG   cbMin = OFFSET(CMMergeIndexList, _aShadowIndex);

    if ( cbValid < cbMin )
    {
        ciDebugOut(( DEB_ERROR,
            "Master Log Size is Invalid - 0x%X\n", cbValid ));

        PStorage & storage = obj.GetStorage();

        Win4Assert( !"Corrupt master merge log" );

        storage.ReportCorruptComponent( L"MMergeIndexList1" );

        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    //
    // Read the signature and the count of shadow indexes participating
    // in the master merge.
    //
    trans.Read( this, OFFSET(CMMergeIndexList, _aShadowIndex) );
    if ( _sigIdxList != sigIdxList )
    {
        ciDebugOut(( DEB_ERROR,
            "Master Log Signature Invalid 0x%X\n", _sigIdxList ));

        PStorage & storage = obj.GetStorage();

        Win4Assert( !"Corrupt master merge log" );

        storage.ReportCorruptComponent( L"MMergeIndexList2" );

        THROW( CException( CI_CORRUPT_DATABASE ) );

    }

    cbMin += sizeof(CIndexId) * _cShadowIndex;
    if ( cbValid < cbMin )
    {
        ciDebugOut(( DEB_ERROR,
            "Master Log Size is Invalid - 0x%X\n", cbValid ));

        PStorage & storage = obj.GetStorage();

        Win4Assert( !"Corrupt master merge log" );

        storage.ReportCorruptComponent( L"MMergeIndexList3" );

        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    for ( ULONG i = 0; i < _cShadowIndex; i++ )
    {
        CIndexId    iid;
        trans.Read( &iid, sizeof(CIndexId) );
        _aShadowIndex.Add(iid, i );
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNewMMergeLog - constructor
//
//  Synopsis:   Constructor for a new master merge log.
//
//  Arguments:  [objMMLog] --  The recoverable storage object for the master
//              merge log.
//
//  History:    4-20-94   srikants   Created
//
//----------------------------------------------------------------------------

CNewMMergeLog::CNewMMergeLog( PRcovStorageObj & objMMLog )
    :_fCommit(FALSE),
     _objMMLog(objMMLog),
     _trans(_objMMLog)
{
}

void CNewMMergeLog::DoCommit()
{
    if ( _fCommit )
    {
        _fCommit = FALSE;   // To prevent cycles if there is a failure in
                            // the process of committing.
        //
        // Write the list of shadow indexes followed by the split key
        //
        _shadowIdxList.Serialize( _trans );
        AppendEmptySplitKeys();

        //
        // Write the header information and commit the transaction.
        //
        WriteHeader();
        _trans.Commit();
    }
}

CNewMMergeLog::~CNewMMergeLog()
{
    if ( _fCommit )
    {
        ciDebugOut(( DEB_ERROR, "aborting committed CNewMMergeLog!\n" ));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   AppendEmptySplitKeys
//
//  Synopsis:   Appends empty split keys for the index list and key list.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CNewMMergeLog::AppendEmptySplitKeys()
{
    CMMergeSplitKey splitKey;
    CKeyBuf key;
    key.FillMin();

    splitKey.SetKey( key );

    ciAssert(
        _objMMLog.GetHeader().GetUserDataSize( _objMMLog.GetHeader().GetBackup() ) ==
        _shadowIdxList.GetValidLength()
            );

    _trans.Append( &splitKey, sizeof CMMergeSplitKey );
    _trans.Append( &splitKey, sizeof CMMergeSplitKey );
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteHeader
//
//  Synopsis:   Writes the header for the new master merge log.
//
//  History:    4-20-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CNewMMergeLog::WriteHeader()
{
    // STACKSTACK
    XPtr<struct CRcovUserHdr> xHdr(new CRcovUserHdr);
    RtlZeroMemory( xHdr.GetPointer(), sizeof(CRcovUserHdr) );

    ciDebugOut(( DEB_ITRACE,
     "Writing Header For New Master Log - cShadowIdx %d - oSplitKey %d\n",
     _shadowIdxList.GetShadowIndexCount(),
     _shadowIdxList.GetValidLength()
             ));
    ciDebugOut(( DEB_ITRACE,
     "WidMax Index 0x%X WidMax KeyList 0x%X\n",
     _widMaxIndex, _widMaxKeyList ));

    CMMergeLogHdr * phdrMMLog = (CMMergeLogHdr *) xHdr.GetPointer();

    phdrMMLog->Init();
    phdrMMLog->SetShadowIndexCount(_shadowIdxList.GetShadowIndexCount());
    phdrMMLog->SetSplitKeyOffset(_shadowIdxList.GetValidLength());
    phdrMMLog->SetKeyListWidMax( _widMaxKeyList );
    phdrMMLog->SetIndexWidMax( _widMaxIndex );

    _objMMLog.GetHeader().SetUserHdr( _objMMLog.GetHeader().GetBackup(),
                                      xHdr.GetReference() );
}

//+---------------------------------------------------------------------------
//
//  Function:   CMMergeLog::CMMergeLog
//
//  Synopsis:   Constructor for an existing master merge log.
//
//  Arguments:  [objMMLog] --  Recoverable storage object for the master
//                             mergelog.
//
//  History:    4-20-94   srikants   Created
//
//----------------------------------------------------------------------------

CMMergeLog::CMMergeLog( PRcovStorageObj & objMMLog )
:   _sigMMergeLog(eSigMMergeLog), _objMMLog(objMMLog)
{
    //
    // Create a read transaction for reading in the master log.
    //

    CRcovStrmReadTrans  trans(_objMMLog);
    
    XPtr<struct CRcovUserHdr> xHdr(new CRcovUserHdr);
    CMMergeLogHdr * phdrMMLog = (CMMergeLogHdr *) xHdr.GetPointer();

    _objMMLog.GetHeader().GetUserHdr( _objMMLog.GetHeader().GetPrimary(),
                                      xHdr.GetReference() );

    _widMaxIndex = phdrMMLog->GetIndexWidMax();
    _widMaxKeyList = phdrMMLog->GetKeyListWidMax();

    ciDebugOut(( DEB_ITRACE,
        "DeSerialize MMLog Hdr - Index Max Wid 0x%X KeyList MaxWid 0x%X\n",
                 _widMaxIndex, _widMaxKeyList ));

    ciDebugOut(( DEB_ITRACE,
        "Seeking to 0x%X bytes to read split key\n",
        phdrMMLog->GetSplitKeyOffset() ));

    //
    // Read the index split key.
    //

    trans.Seek( phdrMMLog->GetSplitKeyOffset() );
    trans.Read( &_idxSplitKey, sizeof(_idxSplitKey) );
    Win4Assert( _idxSplitKey.IsValid() );

    if ( !_idxSplitKey.IsValid() )
    {
        PStorage & storage = objMMLog.GetStorage();
        storage.ReportCorruptComponent( L"MMergeLogSplitKey" );
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    //
    // Read the keylist split key.
    //
    trans.Read(&_keylstSplitKey, sizeof(_keylstSplitKey));
    Win4Assert( _keylstSplitKey.IsValid() );

    if ( !_keylstSplitKey.IsValid() )
    {
        PStorage & storage = objMMLog.GetStorage();
        storage.ReportCorruptComponent( L"MMergeLogKeylstSplitKey" );
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }
} //CMMergeLog

//+---------------------------------------------------------------------------
//
//  Function:   CheckPoint
//
//  Synopsis:   Writes out the state of master merge (as indicated in the
//              master log object) to disk in an atomic fashion.
//
//  History:    4-20-94   srikants   Created
//
//----------------------------------------------------------------------------

void CMMergeLog::CheckPoint()
{
    CRcovStrmWriteTrans  trans(_objMMLog);

    // STACKSTACK
    XPtr<struct CRcovUserHdr> xHdr(new CRcovUserHdr);
    CMMergeLogHdr * phdrMMLog = (CMMergeLogHdr *) xHdr.GetPointer();

    _objMMLog.GetHeader().GetUserHdr( _objMMLog.GetHeader().GetBackup(),
                                      xHdr.GetReference() );

    phdrMMLog->SetIndexWidMax( _widMaxIndex );
    phdrMMLog->SetKeyListWidMax( _widMaxKeyList );

    ciDebugOut(( DEB_ITRACE,
        "Seeking to 0x%X bytes to write split key\n",
        phdrMMLog->GetSplitKeyOffset() ));

    _objMMLog.GetHeader().SetUserHdr( _objMMLog.GetHeader().GetBackup(),
                                      xHdr.GetReference() );

    //
    // Write out the index split key.
    //
    trans.Seek( phdrMMLog->GetSplitKeyOffset() );
    trans.Write( &_idxSplitKey, sizeof(_idxSplitKey) );

    //
    // Write out the keylist split key.
    //
    trans.Write( &_keylstSplitKey, sizeof(_keylstSplitKey) );

    trans.Commit();
}

CMMergeIdxListIter::CMMergeIdxListIter( PRcovStorageObj & objMMLog )
    : _objMMLog(objMMLog),
      _curr(0),
      _trans(_objMMLog)
{
    _shadowIdxList.DeSerialize( _trans, _objMMLog );
}


BOOL CMMergeIdxListIter::Found( CIndexId & iid )
{
    for ( ULONG i = 0; i < _shadowIdxList.GetShadowIndexCount(); i++ )
    {
        CIndexId iidCurr;
        _shadowIdxList.GetIndex( iidCurr , i );
        if ( iid == iidCurr )
        {
            return(TRUE);
        }
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\mindex.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       MINDEX.CXX
//
//  Contents:   Master Index
//
//  Classes:    CMasterMergeIndex, CSplitKeyInfo, CTrackSplitKey
//
//  History:    30-Mar-94       DwightKr        Created stub.
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <pdir.hxx>
#include <fretable.hxx>
#include <rwex.hxx>
#include <pidxtbl.hxx>
#include <cifailte.hxx>
#include <eventlog.hxx>

#include "mindex.hxx"
#include "mcursor.hxx"
#include "fresh.hxx"
#include "fretest.hxx"
#include "indsnap.hxx"
#include "keylist.hxx"
#include "partn.hxx"

unsigned const EIGHT_MEGABYTES = 0x800000;

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::CMasterMergeIndex, public
//
//  Synopsis:   Restore an index from storage
//
//  Arguments:  [storage]      -- physical storage
//              [widNewMaster] -- workid of new master index
//              [iid]          -- indexid of new master index
//              [widMax]       -- largest wid within this index
//              [pCurrentMasterIndex] -- current master index, if any
//              [widMasterLog] -- workid of master log
//              [pMMergeLog]   -- optional mmerge log
//
//  History:    30-Mar-94   DwightKr    Created.
//
//----------------------------------------------------------------------------
CMasterMergeIndex::CMasterMergeIndex( PStorage& storage,
                                      WORKID widNewMaster,
                                      INDEXID iid,
                                      WORKID widMax,
                                      CPersIndex * pCurrentMasterIndex,
                                      WORKID widMasterLog,
                                      CMMergeLog * pMMergeLog ) :
    CDiskIndex( iid, CDiskIndex::eMaster, widMax ),
    _sigMindex(eSigMindex),
    _pCurrentMasterIndex(pCurrentMasterIndex),
    _pTargetMasterIndex(0),
    _pTargetSink(0),
    _widMasterLog(widMasterLog),
    _pCompr(0),
    _pTrackIdxSplitKey(0),
    _ulInitSize(0),
    _ulFirstPageInUse(0),
#ifdef KEYLIST_ENABLED
    _pTrackKeyLstSplitKey(0),
#endif  // KEYLIST_ENABLED
    _pNewKeyList(0),
    _fAbortMerge(FALSE),
    _storage(storage),
    _pRWStore(0),
    _pIndSnap(0),
    _fStateLoaded(FALSE)

{
    TRY
    {
        //
        // The on-disk object MUST be fully constructed by the time we
        // come here.
        //
        _pTargetMasterIndex = new CPersIndex( storage,
                                              widNewMaster,
                                              iid,
                                              widMax,
                                              CDiskIndex::eMaster,
                                              PStorage::eOpenForWrite,
                                              TRUE ); // read in the directory

        _ulInitSize =  _pTargetMasterIndex->GetIndex().PageSize();
        _pTargetMasterIndex->GetIndex().SetPageGrowth( EIGHT_MEGABYTES / CI_PAGE_SIZE );

        if (0 != _pCurrentMasterIndex)
            _pCurrentMasterIndex->MakeShadow();

        if ( _storage.SupportsShrinkFromFront() &&
             0 != pMMergeLog )
        {
            //
            // Reload the master merge state including the split keys, etc.
            // This isn't quick, but it must be done since the target index
            // must be used to resolve queries because the current index
            // may already have been shrunk from the front.
            //

            ReloadMasterMerge( *pMMergeLog );
        }
    }
    CATCH( CException, e )
    {
        if ( 0 != _pCurrentMasterIndex )
            _pCurrentMasterIndex->MakeMaster();

        delete _pTargetMasterIndex;

        SCODE scE = e.GetErrorCode();

        if ( STATUS_INTEGER_DIVIDE_BY_ZERO == scE ||
             STATUS_ACCESS_VIOLATION       == scE ||
             STATUS_IN_PAGE_ERROR          == scE )
        {
            ciDebugOut(( DEB_ERROR,
                         "Corrupt index or directory, caught 0x%x\n", scE ));
            _storage.ReportCorruptComponent( L"MasterMergeReload" );
            THROW( CException( CI_CORRUPT_DATABASE ) );
        }

        RETHROW();
    }
    END_CATCH
} //CMasterMergeIndex

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::~CMasterMergeIndex, public
//
//  Synopsis:   Destructor for master index
//
//  History:    30-Mar-94   DwightKr    Created.
//
//----------------------------------------------------------------------------
CMasterMergeIndex::~CMasterMergeIndex ()
{
    delete _pIndSnap;

    if ( !IsZombie() )
    {
        //
        // We are Dismounting - must delete both.
        //
        delete _pCurrentMasterIndex;
        delete _pTargetMasterIndex;
    }
    else
    {
        //
        // If we are a zombie and being deleted, then some query
        // has responsibility for both the target and current master indexes
        // if they are non-null.
        //
        Win4Assert( !_pTargetMasterIndex  || _pTargetMasterIndex->InUse() );

#if 0

        //
        // We are not dismounting but are being deleted because either
        // the master merge ended or a query ended.
        //
        if ( _pCurrentMasterIndex && !_pCurrentMasterIndex->InUse() )
        {
            //
            // Since the refcount is 0, we have the responsibility to
            // destroy the current master index. This destruction is via
            // a query indexsnap shot which acquired this index while
            // a master merge was going on.
            //
            delete _pCurrentMasterIndex;
        }

        if ( _pTargetMasterIndex &&
             _pTargetMasterIndex->IsZombie() &&
            !_pTargetMasterIndex->InUse() )
        {
            //
            // The target master index is a zombie and it is not in use.
            // We must delete it.  This can happen if there was a query(Q1)
            // in progress at the time Merge(M1) completed. Consider the
            // following sequence of events:
            // 0. Query Q1 starts and ref counts T1(Target Index of M1).
            // 1. M1 completes.
            // 2. A second merge M2 starts. It completes and zombifies
            //    T1
            // 3. Q1 now is completing and so releases T1 whose ref.count
            //    goes to 0. Hence we must delete it.
            //
            delete _pTargetMasterIndex;
        }
#endif  // 0

    }

    CleanupMMergeState();
} //~CMasterMergeIndex

//+---------------------------------------------------------------------------
//
// Member:     CMasterMergeIndex::Fill public
//
// Synopsis:   Returns a record describing the contents of this index.
//
// History:    30-Mar-94    DwightKr       Created.
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::FillRecord ( CIndexRecord& record )
{
    record._objectId  = ObjectId();
    record._iid       = GetId();
    record._type      = itNewMaster;
    record._maxWorkId = MaxWorkId();
}

#if CIDBG == 1

// useful for forcing a master merge to fail due to out of memory

BOOL g_fFailMMOutOfMemory = FALSE;

#endif // CIDBG == 1

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::Merge, public
//
//  Synopsis:   Merge index(es) into a new master index.  This operation may
//              be restarted
//
//  Effects:    Fills the persistent index with data from the input
//              indexes.
//
//  Arguments:  [pNewKeyList]   -- Keylist to merge (master merge only)
//              pFreshTest      -- Fresh test to use for the merge. This
//                                 parameter must only be used - it cannot be
//                                 acquired by this routine.
//              [mergeProgress] -- % merge complete
//              [fGetRW]        -- if TRUE, relevant words are computed
//                                 Currently ignored
//
//  Requires:   The index is initially empty.
//
//  Notes:      Every compressor is transacted.
//
//  History:    15-May-91   KyleP       Use new PutOccurrence() method.
//              16-Apr-91   KyleP       Created.
//              17-Feb-93   KyleP       Merge keylist
//              30-Mar-94   DwightKr    Copied here from CPersIndex, and added
//                                          restart capabilities.
//              19-Apr-94   SrikantS    Split key tracking changes and
//                                          initialization change.
//              01-May-94   DwightKr    Added code to allow for queries during
//                                          master merge.
//              12-May-94   v-dlee      Added relevant word computation
//              29-Sep-94   SrikantS    IndSnap ownership fix.
//              25-Oct-95   DwightKr    Add merge complete measurement
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::Merge(
    CWKeyList *          pNewKeyList,
    CFreshTest *         pFreshTest,
    const CPartition &   partn,
    CCiFrmPerfCounter &  mergeProgress,
    CCiFrameworkParams & frmwrkParams,
    BOOL                 fGetRW )
{
    // Calculate max of all input widMax's

    Win4Assert( 0 != _pIndSnap );

    ciDebugOut(( DEB_ITRACE, "Master merge\n" ));

#if CIDBG == 1
    unsigned cKey = 0;
    //
    // Assert that all the indexes in the snapshot are marked as
    // being in a master merge.
    //
    {
        unsigned cInd;
        CIndex ** apIndex;
        apIndex = _pIndSnap->LokGetIndexes( cInd );
        for ( unsigned i = 0; i < cInd; i++ )
        {
            Win4Assert( apIndex[i]->InMasterMerge() );
        }
    }
#endif

    _pNewKeyList = pNewKeyList;
    Win4Assert( 0 != _pNewKeyList );

    Win4Assert( 0 != pFreshTest );


    WORKID widMax = _pIndSnap->MaxWorkId();
    ciDebugOut (( DEB_ITRACE, "Max work id %ld\n", widMax ));

    if ( MaxWorkId() != widMax )
    {
        Win4Assert( !"WidMax in MasterMergeIndex is Corrupt" );
        _storage.ReportCorruptComponent( L"MasterMergeIndex1" );
        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    //
    //  Create and open the master merge log object so that the splitkeys can
    //  be retrieved and stored.
    //
    PRcovStorageObj *pPersMMergeLog = _storage.QueryMMergeLog(_widMasterLog);
    SRcovStorageObj  PersMMergeLog( pPersMMergeLog );

    ciFAILTEST( STATUS_NO_MEMORY );

    XPtr<CMMergeLog> xMMergeLog( new CMMergeLog( *pPersMMergeLog ) );

    //
    // STACKSTACK - cannot declare it where it is used because this is a
    // big object and we don't want to allocate inside the loop.
    //
    XPtr<CSplitKeyInfo> xSplitKeyInfo( new CSplitKeyInfo() );

    BOOL fReOpenTargetMaster = FALSE;

    TRY
    {
        //
        // Read-ahead on the source indexes results in better merge
        // performance, but slower queries.  Temporarily switch modes.
        //

        CSetReadAhead readAhead( _storage );

        _pIndSnap->SetFreshTest( pFreshTest );

        //
        // Initialize and start/restart the master merge.
        //
        CKeyCursor * pKeySrc = StartMasterMerge( *_pIndSnap,
                                                 xMMergeLog.GetReference(),
                                                 _pNewKeyList );

        unsigned finalIndexSize = _pIndSnap->TotalSizeInPages();
        Win4Assert( finalIndexSize > 0 );
        finalIndexSize = max( 1, finalIndexSize );  // Prevent divide by 0


        mergeProgress.Update( _pTargetMasterIndex->GetIndex().PagesInUse() *
                              100 / finalIndexSize );

        CMergeSourceCursor pCurSrc( pKeySrc );

        BitOffset bitOffIndex;      // BitOffset of a key in the target index

        Win4Assert( 0 != _pCompr );
        _pCompr->GetOffset( bitOffIndex );
        ULONG page;                  // for directory creation.
        if ( bitOffIndex.Offset() == 0 )
            page = bitOffIndex.Page() - 1;
        else
            page = bitOffIndex.Page();

#if CIDBG==1
        GetTargetDir().SetBitOffsetLastAdded( page, bitOffIndex.Offset() );
#endif  // CIDBG==1

        if ( !pCurSrc.IsEmpty() )
        {
            #ifdef RELEVANT_WORDS_ENABLED
                //
                // Determine which wids are in use
                //

                UINT cWids = 0;
                WORKID * pwids = 0;
                SByteArray swids(0);
                {
                    SFreshHash phash( *pFreshTest );
                    cWids = phash->Count();
                    pwids = new WORKID[cWids];
                    swids.Set(pwids);
                    CFreshHashIter freiter(*phash);

                    for (UINT x = 0; !freiter.AtEnd(); freiter.Advance(), x++)
                        pwids[x] = freiter->WorkId();
                }

                _SortULongArray((ULONG *) pwids,cWids);

                ciDebugOut (( DEB_ITRACE,"%d wids, %d through %d\n",
                              cWids,pwids[0],pwids[cWids-1]));
            #endif // RELEVANT_WORDS_ENABLED

            //
            // Everytime we restart a master merge, we must use a brand
            // new split key - we must not use the old key for atomicity and
            // restartability
            //
            _pTrackIdxSplitKey->ClearNewKeyFound();

            #ifdef KEYLIST_ENABLED
            _pTrackKeyLstSplitKey->ClearNewKeyFound();
            #endif // KEYLIST_ENABLED

            BitOffset bitOffKeyLst;

            BitOffset StartBitOffset;               // Starting loc in bitstream
            StartBitOffset.Init(0, 0);
            CKeyBuf *pKeyLast = new CKeyBuf;       // initialized to min key
            SKeyBuf  keyLast(pKeyLast);

#if CIDBG == 1
            keyLast->SetPid(pidContents);           // arbitrary but not pidAll
            WCHAR FirstLetter = '@';
            ciDebugOut (( DEB_ITRACE,"Merging. Merge on letter: "));
#endif

            #ifdef RELEVANT_WORDS_ENABLED
                //
                // Create the relevant word computation object
                //

                CRelevantWord RelWord(pwids,cWids,defRWCount);
                swids.Acquire();
                delete pwids;
                pwids = 0;
            #endif // RELEVANT_WORDS_ENABLED

            //
            //  Get checkpoint interval and convert # Kbytes to bits.
            //
            ULONG MasterMergeCheckpointInterval = frmwrkParams.GetMasterMergeCheckpointInterval() * 8 * 1024;

            ShrinkFromFront( _idxSplitKeyInfo.GetKey() );

            //
            //  For each key found, add it and all wids and occurances to the
            //  new master index.
            //
            for ( const CKeyBuf * pkey = pCurSrc->GetKey();
                  pkey != NULL; pkey = pCurSrc->GetNextKey())
            {

#if CIDBG == 1
                cKey++;

                if ( *(pkey->GetStr()) != FirstLetter )
                {
                    FirstLetter = *(pkey->GetStr());
                    if ( FirstLetter < L'~' )
                        ciDebugOut(( DEB_NOCOMPNAME | DEB_ITRACE | DEB_PENDING, "%c",
                                     FirstLetter ));
                    else
                        ciDebugOut(( DEB_NOCOMPNAME | DEB_ITRACE | DEB_PENDING, "<%04x>",
                                     FirstLetter ));
                }
#endif
                //
                // Don't store empty keys
                //

                WORKID wid = pCurSrc->WorkId();

                if ( wid == widInvalid )
                    continue;

                //
                //  Add the key to the new index.
                //

                _pCompr->PutKey(pkey, pCurSrc->WorkIdCount(), bitOffIndex);

                unsigned cWids = 0;             // Count of wids for current key

                #ifdef RELEVANT_WORDS_ENABLED
                    //
                    // Can this possibly be a relevant word?
                    //
                    BOOL fPossibleRW = ((pkey->Pid() == pidContents) &&
                                        (((CKeyBuf * const) pkey)->IsPossibleRW()));
                #endif // RELEVANT_WORDS_ENABLED

                for ( ;
                      wid != widInvalid;
                      wid = pCurSrc->NextWorkId())
                {

#if CIDBG == 1
                    if ( g_fFailMMOutOfMemory )
                        THROW( CException( E_OUTOFMEMORY ) );
#endif // CIDBG == 1

                    // fresh test

                    CFreshTest::IndexSource is;
                    is = pFreshTest->IsCorrectIndex(pCurSrc->IndexId(),wid);

#if CIDBG==1
                    if ( CFreshTest::Master == is )
                    {
                        Win4Assert( 0 != _pCurrentMasterIndex );

                        if ( pCurSrc->IndexId() != _pCurrentMasterIndex->GetId() )
                            ciDebugOut(( DEB_WARN,
                                         "src iid 0x%x, master iid 0x%x, target iid 0x%x\n",
                                         pCurSrc->IndexId(),
                                         _pCurrentMasterIndex->GetId(),
                                         _pTargetMasterIndex->GetId() ));
                        Win4Assert( pCurSrc->IndexId() ==
                                    _pCurrentMasterIndex->GetId() );
                    }
#endif  // CIDBG==1

                    if ( is != CFreshTest::Invalid )
                    {
                        #ifdef RELEVANT_WORDS_ENABLED
                            if ((is == CFreshTest::Shadow) && fPossibleRW)
                                RelWord.Add(wid,pCurSrc->OccurrenceCount());
                        #endif // RELEVANT_WORDS_ENABLED

                        cWids++;
                        _pCompr->PutWorkId(wid, pCurSrc->MaxOccurrence(), pCurSrc->OccurrenceCount());

                        for (OCCURRENCE occ = pCurSrc->Occurrence();
                                occ != OCC_INVALID;
                                occ = pCurSrc->NextOccurrence())
                        {
                            _pCompr->PutOccurrence(occ);
                        }
                    }
                } // for workid

                //
                // Tell the splitkey object to remember the current position
                // if it is a splitkey candidate.
                //

               _pTrackIdxSplitKey->BeginNewKey( *pkey, bitOffIndex );

#ifdef KEYLIST_ENABLED
                KEYID kid = _pNewKeyList->PutKey( pkey, bitOffKeyLst );

                #ifdef RELEVANT_WORDS_ENABLED
                    //
                    // Compute ranks and possibly add keyid as relevant word
                    // for each wid containing the key
                    //
                    if (kid != kidInvalid && fPossibleRW)
                        RelWord.DoneWithKey(kid,widMax,cWids);
                #endif // RELEVANT_WORDS_ENABLED

               _pTrackKeyLstSplitKey->BeginNewKey( *pkey,
                                                    bitOffKeyLst,
                                                    _pNewKeyList->MaxWorkId() );
#else   // !KEYLIST_ENABLED
                _pNewKeyList->AddKey();
#endif  // !KEYLIST_ENABLED


                //
                // Add directory entry, if necessary
                //

                if ( bitOffIndex.Page() != page )
                {
                     page = bitOffIndex.Page();

                     // Protect the directory and add the key

                     CReleasableLock lock( _mutex,
                                           _storage.SupportsShrinkFromFront() );

                     GetTargetDir().Add( bitOffIndex, *pkey );
                }
                else
                {
#if CIDBG==1
                    Win4Assert (
                        page == GetTargetDir().GetBitOffsetLastAdded().Page()
                               );
#endif  // CIDBG
                }

                *keyLast = *pkey;

                //
                //  There's no point in special abort code.  We have to handle
                //  exceptions anyway.
                //

                ciFAILTEST( STATUS_DISK_FULL );

                if ( _fAbortMerge || partn.IsCleaningUp() )
                {
                    ciDebugOut(( DEB_ITRACE, "Aborting Merge\n" ));

                    _fAbortMerge=FALSE; // for next time around
                    THROW( CException( STATUS_UNSUCCESSFUL ) );
                }

                //
                //  Have we processed & written out MASTER_MERGE_INTERVAL bytes
                //  to disk?  If so, bring them online within the new master index
                //  and remove them from the current master index as follows:
                //
                //      1.  Take a lock to prevent further queries on pages from
                //          the current master index.
                //
                //      2.  Ask the _pNewMasterIndex for the highest key which
                //          has made it do disk on the last page which itself
                //          has also bee flushed to disk.  This key is the
                //          new split key.
                //
                //      3.  Update the directory for the new master index.
                //
                //      4.  Write the split key to the master log.
                //
                //      5.  Shrink from front the current master index upto
                //          but not including the lesser of the last page which
                //          is in use by a query and the number of pages moved
                //          to the new master index.  Can't sff if there
                //          are mapped sections, so free the stream first.
                //
                //      6.  Release the lock
                //
                //

                if ( (bitOffIndex.Delta(StartBitOffset) > MasterMergeCheckpointInterval) &&
                     _pTrackIdxSplitKey->IsNewKeyFound() )
                {
                    //  Step #1
                    CLock lock( _mutex );

                    //
                    // Checkpoint our state to the master merge log.
                    // Step #2
                    //
                    BitOffset flushBitOff;
                    xSplitKeyInfo.GetReference() = _pTrackIdxSplitKey->GetSplitKey( flushBitOff );
                    Win4Assert(
                               CiPageToCommonPage( flushBitOff.Page()) >
                               CiPageToCommonPage( xSplitKeyInfo->GetEndOffset().Page() )
                              );

                    //
                    // Flush all the pages upto and including the "flushBitOff".
                    // This will guarantee that the page containing the split
                    // key will never be touched again.
                    //
                    _pTargetSink->Flush( TRUE );
                    xMMergeLog->SetIdxSplitKeyInfo( xSplitKeyInfo->GetKey(),
                                                    xSplitKeyInfo->GetBeginOffset(),
                                                    xSplitKeyInfo->GetEndOffset() );


                    //
                    //  Step #3
                    //
                    GetTargetDir().LokFlushDir( xSplitKeyInfo->GetKey() );

                    #ifdef KEYLIST_ENABLED
                    //
                    // If we have a split key for the key list, then we should
                    // go ahead and flush it.
                    //
                    const CSplitKeyInfo & keylstSplitKey =
                            _pTrackKeyLstSplitKey->GetSplitKey( flushBitOff );

                    if ( _pTrackKeyLstSplitKey->IsNewKeyFound() )
                    {
                        _pNewKeyList->Flush();

                        xMMergeLog->SetKeyListSplitKeyInfo(
                                        keylstSplitKey.GetKey(),
                                        keylstSplitKey.GetBeginOffset(),
                                        keylstSplitKey.GetEndOffset() );

                        xMMergeLog->SetKeyListWidMax( keylstSplitKey.GetWidMax() );
                        _pTrackKeyLstSplitKey->ClearNewKeyFound();
                    }
                    #else   // !KEYLIST_ENABLED
                    xMMergeLog->SetKeyListWidMax( _pNewKeyList->MaxWorkId() );
                    #endif  // !KEYLIST_ENABLED

                    //  Step #4
                    //
                    xMMergeLog->CheckPoint();

                    //
                    //  Step #4.5
                    //
                    _idxSplitKeyInfo = xSplitKeyInfo.GetReference();

                    //
                    //  Step #5
                    //

                    if ( 0 != _pCurrentMasterIndex )
                    {
                        pCurSrc->FreeStream();
                        ShrinkFromFront( xSplitKeyInfo->GetKey() );
                        pCurSrc->RefillStream();
                    }

                    //
                    // Mark that we have used up this split key.
                    //
                    _pTrackIdxSplitKey->ClearNewKeyFound();


                    //
                    //  Step #6
                    //
                    StartBitOffset = bitOffIndex;

                    //
                    // Update the size in the new master index.
                    //
                    _pTargetMasterIndex->GetIndex().UpdatePageCount( *_pTargetSink );

                    //
                    //  Write the new % complete for the merge
                    //
                    mergeProgress.Update( _pTargetMasterIndex->GetIndex().PagesInUse() *
                                          100 /
                                          finalIndexSize );
                } // checkpoint
            } // for key

            #ifdef RELEVANT_WORDS_ENABLED
                _pRWStore = RelWord.AcquireStore();
                ciDebugOut (( DEB_ITRACE,"grabbing _pRWStore: %lx\n",_pRWStore));
            #endif // RELEVANT_WORDS_ENABLED

            ciDebugOut(( DEB_ITRACE | DEB_PENDING, "%d keys in index\n", cKey ));
        }

        CKeyBuf *pKeyMax = new CKeyBuf;
        SKeyBuf sKeyMax(pKeyMax);
        sKeyMax->FillMax();
        sKeyMax->SetPid(pidContents);

        BOOL fMaxKeyAddedNow = FALSE;
        BitOffset bitOffEnd;

        if ( !_pCompr->IsAtSentinel() )
        {
            // add sentinel key
            _pCompr->PutKey(pKeyMax, 1, bitOffIndex);
            _pCompr->GetOffset( bitOffEnd );
            fMaxKeyAddedNow = TRUE;
        }

        CLock lock( _mutex );

        //
        // Destroy the compressor, etc and clean up the master merge state.
        //

        _pCompr->FreeStream();
        CleanupMMergeState();

        //
        // The compressor must be destroyed before we do the final flush.
        // O/W, the last page (which is being used by the compressor) will
        // not get flushed. We cannot update the directory and the master
        // merge state until the index data is written out to disk.
        //

        _pTargetSink->Flush();

        ciFAILTEST( STATUS_LOG_FILE_FULL );

        if ( fMaxKeyAddedNow )
        {
            if ( page != bitOffIndex.Page() )
            {
                ciDebugOut(( DEB_ITRACE,
                    "Adding max key to directory. Page:0x%X Offset:0x%X\n",
                    bitOffIndex.Page(), bitOffIndex.Offset() ));
                GetTargetDir().Add( bitOffIndex, *pKeyMax );
            }

            GetTargetDir().LokFlushDir( *pKeyMax );
            GetTargetDir().LokBuildDir( *pKeyMax );

            xSplitKeyInfo->SetBeginOffset(bitOffIndex);
            xSplitKeyInfo->SetEndOffset(bitOffEnd);
            xSplitKeyInfo->SetKey( *pKeyMax );

            ciFAILTEST( STATUS_LOG_FILE_FULL );

            xMMergeLog->SetIdxSplitKeyInfo( xSplitKeyInfo->GetKey(),
                                            xSplitKeyInfo->GetBeginOffset(),
                                            xSplitKeyInfo->GetEndOffset() );
            xMMergeLog->CheckPoint();

            ciFAILTEST( STATUS_LOG_FILE_FULL );

            //
            // The in-memory split key information MUST be updated ONLY
            // after the checkpoint to disk is succesfully done.
            //
            _idxSplitKeyInfo = xSplitKeyInfo.GetReference();
        }

        _pTargetSink->ShrinkToFit();
        _pTargetMasterIndex->GetIndex().UpdatePageCount( *_pTargetSink );

        delete _pTargetSink;
        _pTargetSink = 0;

        //
        // No need to reopen the stream as read-only if the stream supports
        // SFF, since we need to leave it as writable for the next master
        // merge anyway.
        //

        if ( !_storage.SupportsShrinkFromFront() )
        {
            fReOpenTargetMaster = TRUE;
            _pTargetMasterIndex->GetIndex().Reopen( FALSE );
            fReOpenTargetMaster = FALSE;
        }

        //
        //   The merge is 100% complete.
        //
        mergeProgress.Update( 100 );
    }
    CATCH( CException, e )
    {
        _pIndSnap->ResetFreshTest();

        //
        // The CMasterMerge object owns the key list. We should 0 it
        // to prevent having dangling references.
        //
        _pNewKeyList = 0;

        CleanupMMergeState();

        delete _pTargetSink;
        _pTargetSink = 0;

        if ( fReOpenTargetMaster )
            _pTargetMasterIndex->GetIndex().Reopen( _storage.SupportsShrinkFromFront() );

        // Really bad errors indicate the index is corrupt.

        SCODE scE = e.GetErrorCode();

        if ( STATUS_INTEGER_DIVIDE_BY_ZERO == scE ||
             STATUS_ACCESS_VIOLATION       == scE ||
             STATUS_IN_PAGE_ERROR          == scE )
        {
            ciDebugOut(( DEB_ERROR,
                         "Corrupt index or directory, caught 0x%x\n", scE ));
            _storage.ReportCorruptComponent( L"MasterMerge" );
            THROW( CException( CI_CORRUPT_DATABASE ) );
        }

        RETHROW();
    }
    END_CATCH

    _pIndSnap->ResetFreshTest();

    _pNewKeyList = 0;

    #ifdef KEYLIST_ENABLED
    pNewKeyList->Done( _fAbortMerge );
    #endif  // KEYLIST_ENABLED

    ciDebugOut(( DEB_ITRACE, "Master merge complete\n" ));
} //Merge


//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::Reload, private
//
//  Synopsis:   Restores the data for the split keys used for during a
//              master merge as well as the index directory.
//
//  History:    25-Apr-94   DwightKr    Copied from StartMasterMerge
//              23-Aug-94   SrikantS    Moved from CMasterMergeIndex
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::ReloadMasterMerge( CMMergeLog & mMergeLog )
{
    Win4Assert( 0 != _pTargetMasterIndex );
    Win4Assert( !_fStateLoaded );

    //
    // Index Split Key tracking variables.
    //
    CKeyBuf * pIdxSplitKey = new CKeyBuf();
    SKeyBuf   idxSplitKey(pIdxSplitKey);
    idxSplitKey->FillMin();

    BitOffset idxBeginBitOff;
    idxBeginBitOff.Init(0,0);
    BitOffset idxEndBitOff;
    idxEndBitOff.Init(0,0);

    mMergeLog.GetIdxSplitKeyInfo( *pIdxSplitKey,
                                  idxBeginBitOff,
                                  idxEndBitOff );

    RestoreIndexDirectory( *pIdxSplitKey, MaxWorkId(), idxEndBitOff );
    ciDebugOut (( DEB_ITRACE, "widMax passed to compressor: %ld\n", MaxWorkId() ));

    _pTargetMasterIndex->GetIndex().SetUsedPagesCount( idxEndBitOff.Page() + 1 );

    _idxSplitKeyInfo.SetBeginOffset(idxBeginBitOff);
    _idxSplitKeyInfo.SetEndOffset(idxEndBitOff);
    _idxSplitKeyInfo.SetKey( *pIdxSplitKey );

    _fStateLoaded = TRUE;
} //ReloadMasterMerge

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::StartMasterMerge, private
//
//  Synopsis:   Initializes the merge cursor used to merge the source
//              indexes.
//
//  Arguments:  [indSnap]     -- array of indexes to be merged
//              [mMergeLog]   -- master merge log
//              [pNewKeyList] -- keyList to update with missing keys
//
//  History:    20-Apr-94   SrikantS    Created
//              25-Apr-94   DwightKr    Moved some functionality to
//                                      ReloadMasterMerge()
//
//----------------------------------------------------------------------------
CKeyCursor *
CMasterMergeIndex::StartMasterMerge( CIndexSnapshot & indSnap,
                                     CMMergeLog & mMergeLog,
                                     CWKeyList * pNewKeyList )
{
    //
    //  Create the target index sink for write access.
    //
    ciFAILTEST( CI_CORRUPT_DATABASE );

    //
    // In user mode, we have to Restore the mastermerge start if it is not
    // already restored.
    //
    if ( !_fStateLoaded )
    {
        ciDebugOut(( DEB_ITRACE, "Reloading MasterMergeState\n" ));
        ReloadMasterMerge( mMergeLog );
    }

    CPhysIndex & idx = _pTargetMasterIndex->GetIndex();
    PMmStream * stream = idx.DupReadWriteStream( PStorage::eOpenForWrite );
    XPtr<PMmStream> sStream(stream);
    _pTargetSink = new CPhysIndex( idx,
                                   PStorage::eOpenForWrite,
                                   sStream );

    _pTargetSink->SetPageGrowth( EIGHT_MEGABYTES / CI_PAGE_SIZE );

    #if CIDBG == 1
    if ( _idxSplitKeyInfo.GetEndOffset().Page() != 0 )
    {
        ULONG * pul = _pTargetSink->BorrowBuffer( _idxSplitKeyInfo.GetEndOffset().Page() );
        Win4Assert( 0 != *pul );
        _pTargetSink->ReturnBuffer( _idxSplitKeyInfo.GetEndOffset().Page() );
    }
    #endif

    //
    // Delete all the keys in the directory after the split key.
    //
    {
        //
        // Must serialize access to the B_Tree when we are making
        // structural modifications to it.
        //
        CLock lock( _mutex );
        GetTargetDir().DeleteKeysAfter( _idxSplitKeyInfo.GetKey() );
    }

    //
    //  If we are restarting a 'paused' master merge, then restore the
    //  persistent decompressor to its previous state.  Else, just
    //  build a decompressor and initialize it state to start at the
    //  front of the physical index.
    //
    Win4Assert( !_pTrackIdxSplitKey );

    ciFAILTEST( STATUS_NO_MEMORY );

   _pTrackIdxSplitKey = new CTrackSplitKey( _idxSplitKeyInfo.GetKey(),
                                            _idxSplitKeyInfo.GetBeginOffset(),
                                            _idxSplitKeyInfo.GetEndOffset() );

    ciFAILTEST( STATUS_NO_MEMORY );
    _pCompr = new CPersComp( *_pTargetSink,
                             MaxWorkId(),
                             _idxSplitKeyInfo.GetEndOffset(),
                             _idxSplitKeyInfo.GetBeginOffset(),
                             _idxSplitKeyInfo.GetKey() );

    _pTargetSink->SetUsedPagesCount( _idxSplitKeyInfo.GetEndOffset().Page() + 1 );

    //
    //  Build the merge cursor and position it at the key just after the
    //  split key.  If a master merge is NOT being restarted, this
    //  positions the merge cursor at the first key.
    //
    ciFAILTEST( STATUS_NO_MEMORY );
    CMergeSourceCursor pCurSrc ( indSnap, &_idxSplitKeyInfo.GetKey() );

    if ( pCurSrc.IsEmpty() )
    {
        ciDebugOut (( DEB_ITRACE, "No merge cursor created\n" ));
        return(0);
    }

    ciDebugOut(( DEB_ITRACE, "widMax passed to compressor: %ld\n",
                 MaxWorkId() ));

    if ( !_idxSplitKeyInfo.GetKey().IsMinKey() )
    {
        Win4Assert( AreEqual(pCurSrc->GetKey(), &_idxSplitKeyInfo.GetKey()) );
        ciFAILTEST( CI_CORRUPT_DATABASE );
        pCurSrc->GetNextKey();
    }

    #ifdef KEYLIST_ENABLED
    //
    // Setup the keylist splitKey tracking variables.
    //
    ciFAILTEST( STATUS_NO_MEMORY );
    CKeyBuf * pKeylstSplitKey = new CKeyBuf();
    SKeyBuf   keylstSplitKey(pKeylstSplitKey);
    keylstSplitKey->FillMin();

    BitOffset keylstBeginBitOff;
    keylstBeginBitOff.Init(0,0);
    BitOffset keylstEndBitOff;
    keylstEndBitOff.Init(0,0);

    mMergeLog.GetKeyListSplitKeyInfo( *pKeylstSplitKey,
                                       keylstBeginBitOff,
                                       keylstEndBitOff );


    //
    // Flag set to TRUE if the keylist split key is > the index list split
    // key.
    //
    BOOL fKLSplitKeyBigger = FALSE;

    if ( _idxSplitKeyInfo.GetKey().IsMinKey() ||
         pKeylstSplitKey->Compare( _idxSplitKeyInfo.GetKey() ) > 0 )
    {
        *pKeylstSplitKey = _idxSplitKeyInfo.GetKey();
        fKLSplitKeyBigger = TRUE;
    }

    Win4Assert( _pTrackIdxSplitKey );
    RestoreKeyListDirectory( _idxSplitKeyInfo.GetKey(),
                             MaxWorkId(),
                              pNewKeyList,
                             *pKeylstSplitKey );

    Win4Assert( !_pTrackKeyLstSplitKey );
    ciFAILTEST( STATUS_NO_MEMORY );
    if ( !fKLSplitKeyBigger )
    {
        _pTrackKeyLstSplitKey = new CTrackSplitKey( *pKeylstSplitKey,
                                                      keylstBeginBitOff,
                                                      keylstEndBitOff
                                                       );
    }
    else
    {
        //
        // Just set it to be the min key with 0,0 .
        //
        _pTrackKeyLstSplitKey = new CTrackSplitKey();
    }

    #endif  // KEYLIST_ENABLED

    return pCurSrc.Acquire();
} //StartMasterMerge

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::CleanupMMergeState, private
//
//  Synopsis:   Free all memory resources used for this master merge.
//
//  History:    20-Apr-94   SrikantS    Created
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::CleanupMMergeState()
{
    //
    // We will create safe pointers instead of calling delete because we
    // want to be able to cope with exceptions thrown in the destructors
    // also.
    //

    #ifdef KEYLIST_ENABLED

        delete _pTrackKeyLstSplitKey;
        _pTrackKeyLstSplitKey = 0;

    #endif // KEYLIST_ENABLED

    delete _pTrackIdxSplitKey;
    _pTrackIdxSplitKey = 0;

    // If the stream is still unflushed in the compressor, it isn't
    // guaranteed to be flushed by this destructor.  This destructor will
    // not fail for any reason including failure to flush, so don't rely
    // on this in success code paths.

    delete _pCompr;
    _pCompr = 0;
} //CleanupMMergeState

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::ShrinkFromFront, private
//
//  Synopsis:   Shrinks the index, from the front, to release the disk
//              associated with the space before the split key.
//
//  Parameters: [keyBuf]    -- contents of last key which can be deleted
//                             from the current master index
//
//  History:    01-Aug-94   DwightKr    Created
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::ShrinkFromFront( const CKeyBuf & keyBuf )
{
    //
    //  If there is no current master index, we have nothing to shrink
    //
    if ( !_pCurrentMasterIndex )
        return;

    //
    //  Locate the page # of the key in the OFS btree which can be used
    //  to locate this splitkey. On a restart, the merge will seek
    //  to the key which is the nearest key less than the split
    //  key stored in the OFS btree.  Hence, we need to get the offset of
    //  the key in the OFS btree which is equal to or less than the splitkey.
    //  This offset is returned by the COfsdir Seek method.
    //
    BitOffset offset;

    _pCurrentMasterIndex->GetDirectory().Seek( keyBuf, 0, offset );

    ULONG ulFirstPageInUse = offset.Page();

    ULONG ulMinPageInCache = MAXULONG;

    if ( _pCurrentMasterIndex->GetIndex().MinPageInUse( ulMinPageInCache ) )
    {
        //
        // The cache has some pages in it and so we must take the minimum
        // of the cache page and the directory.
        //
        Win4Assert( MAXULONG != ulMinPageInCache );
        ulFirstPageInUse = min( ulFirstPageInUse, ulMinPageInCache );
    }
    else
    {
        //
        // The cache is empty implying that there none of the pages from
        // the current master are in use. We must have exhausted all the
        // keys from the current master.
        //
    }

    //
    //  If we can't decommit any pages because they are all in use, then get
    //  out now.
    //
    Win4Assert( ulFirstPageInUse >= _ulFirstPageInUse );
    ULONG numPages = ulFirstPageInUse - _ulFirstPageInUse;
    if ( numPages > 0 )
        _ulFirstPageInUse += _pCurrentMasterIndex->ShrinkFromFront( _ulFirstPageInUse,
                                                                    numPages );
} //ShrinkFromFront

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::QueryCursor, public
//
//  Synopsis:   Return a cursor for the master index during master merge
//
//  Returns:    A new cursor.
//
//  History:    24-Apr-91   KyleP       Created.
//              30-Mar-94   DwightKr    Copied here from CPersIndex
//
//----------------------------------------------------------------------------
CKeyCursor * CMasterMergeIndex::QueryCursor()
{
    CKey key;
    key.FillMin();

    return QueryKeyCursor( &key );
}


//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::QuerySplitCursor, private
//
//  Synopsis:   Return a cursor for the logical master index during master
//              merge
//
//  Returns:    A new cursor.
//
//  History:    30-Mar-94   DwightKr    Created
//
//  Notes:      Three cases of interest can be found during a master merge:
//
//              1.  Master merge for the first time, no 'current master index'
//                  hence we return a null for the cursor to the master index.
//
//              2.  Master merge hasn't written a split key as yet, return a
//                  cursor to decompress the 'current master index'.
//
//              3.  All other cases, build a cursor to decompress and span
//                  both the 'current master index' and the 'new master index.'
//
//----------------------------------------------------------------------------
CKeyCursor * CMasterMergeIndex::QuerySplitCursor(const CKey * pKey)
{
    if ( 0 == _pCurrentMasterIndex )
        return 0;

    // Take the lock if the volume supports shrink from front

    CReleasableLock lock( _mutex, _storage.SupportsShrinkFromFront() );

    if ( _storage.SupportsShrinkFromFront() &&
         !_idxSplitKeyInfo.GetKey().IsMinKey() )
    {

        return new CMPersDeComp( _pCurrentMasterIndex->GetDirectory(),
                                 _pCurrentMasterIndex->GetId(),
                                 _pCurrentMasterIndex->GetIndex(),
                                 _pCurrentMasterIndex->MaxWorkId(),
                                 GetTargetDir(),
                                 GetId(),
                                 _pTargetMasterIndex->GetIndex(),
                                 pKey,
                                 MaxWorkId(),
                                 _idxSplitKeyInfo,
                                 _mutex );
    }
    else
    {
        //
        // Don't use the split cursor. The current master index is valid.
        //

        BitOffset posKey;
        CKeyBuf keyInit;

        _pCurrentMasterIndex->GetDirectory().Seek( *pKey,
                                                   &keyInit,
                                                   posKey );

        return new CPersDeComp( _pCurrentMasterIndex->GetDirectory(),
                                _pCurrentMasterIndex->GetId(),
                                _pCurrentMasterIndex->GetIndex(),
                                posKey,
                                keyInit,
                                pKey,
                                _pCurrentMasterIndex->MaxWorkId() );
    }
} //QuerySplitCursor

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::QueryKeyCursor, public
//
//  Synopsis:   Return a key cursor for the master index when restarting a
//              master merge
//
//  Returns:    A new cursor.
//
//  History:    12-Apr-94   DwightKr    Created.
//
//----------------------------------------------------------------------------
CKeyCursor * CMasterMergeIndex::QueryKeyCursor(const CKey * pKey)
{
    // Take the lock if the volume supports shrink from front

    CReleasableLock lock( _mutex, _storage.SupportsShrinkFromFront() );

    XPtr<CKeyCursor> xCursor( QuerySplitCursor( pKey ) );

    if ( !xCursor.IsNull() && (xCursor->GetKey() == 0) )
        xCursor.Free();

    return xCursor.Acquire();
} //QueryKeyCursor

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::QueryCursor, public
//
//  Synopsis:   Return a cursor for the master index during master merge
//
//  Arguments:  [pkey]      -- Key to initially seek for.
//              [isRange]   -- TRUE for range query
//              [cMaxNodes] -- Max node (key) count
//
//  Returns:    A new cursor.
//
//  History:    24-Apr-91   KyleP       Created.
//              30-Mar-94   DwightKr    Copied here from CPersIndex and
//                                      modified to span multiple masters
//
//----------------------------------------------------------------------------
COccCursor * CMasterMergeIndex::QueryCursor( const CKey * pKey,
                                             BOOL isRange,
                                             ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    if (isRange)
    {
        CKey keyEnd;
        keyEnd.FillMax (*pKey);
        return QueryRangeCursor( pKey, &keyEnd, cMaxNodes );
    }

    if (pKey->Pid() == pidAll)
        return QueryRangeCursor( pKey, pKey, cMaxNodes );

    cMaxNodes--;

    if ( 0 == cMaxNodes )
    {
        ciDebugOut(( DEB_WARN, "Node limit reached in CMasterMergeIndex::QueryCursor.\n" ));
        THROW( CException( STATUS_TOO_MANY_NODES ) );
    }


    XPtr<CKeyCursor> xCursor( QuerySplitCursor( pKey ) );

    if ( ( !xCursor.IsNull() ) &&
         ( xCursor->GetKey() == 0
           || !pKey->MatchPid (*xCursor->GetKey())
           || pKey->CompareStr(*xCursor->GetKey()) != 0 )
       )
    {
        xCursor.Free();
    }

    return xCursor.Acquire();
} //QueryCursor

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::QueryRangeCursor, public
//
//  Synopsis:   Return a range cursor for the master index during master merge
//
//  Arguments:  [pkey]      -- Key at beginning of the range.
//              [pKeyEnd]   -- Key at the end of the range.
//              [cMaxNodes] -- Max node (key) count
//
//  Returns:    A new cursor.
//
//  History:    11-Dec-91   AmyA        Created.
//              31-Jan-92   AmyA        Moved code to CreateRange().
//              30-Mar-94   DwightKr    Copied here from CPersIndex and
//                                      modified to span multiple masters
//
//----------------------------------------------------------------------------
COccCursor * CMasterMergeIndex::QueryRangeCursor( const CKey * pkey,
                                                  const CKey * pKeyEnd,
                                                  ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    COccCurStack curStk;

    // Take the lock if the volume supports shrink from front

    CReleasableLock lock( _mutex, _storage.SupportsShrinkFromFront() );

    CreateRange( curStk, pkey, pKeyEnd, cMaxNodes );

    return curStk.QuerySynCursor( MaxWorkId() );
} //QueryRangeCursor

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::QuerySynCursor, public
//
//  Synopsis:   Return a synonym cursor for master index during master merge
//
//  Arguments:  [keyStk]    -- Stack of keys to be searched for.
//              [isRange]   -- Whether or not this is a range search.
//              [cMaxNodes] -- Max node (key) count
//
//  Returns:    A new cursor.
//
//  History:    31-Jan-92   AmyA        Created.
//              30-Mar-94   DwightKr    Copied here from CPersIndex and
//                                      modified to span multiple masters
//
//----------------------------------------------------------------------------
COccCursor * CMasterMergeIndex::QuerySynCursor( CKeyArray & keyArr,
                                                BOOL isRange,
                                                ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    if ( 0 == _pCurrentMasterIndex )
        return 0;

    COccCurStack curStk;

    int keyCount = keyArr.Count();

    // Take the lock if the volume supports shrink from front

    CReleasableLock lock( _mutex, _storage.SupportsShrinkFromFront() );

    for (int i = 0; i < keyCount; i++)
    {
        CKey& key = keyArr.Get(i);

        if (isRange)
        {
            CKey keyEnd;
            keyEnd.FillMax(key);

            CreateRange( curStk, &key, &keyEnd, cMaxNodes );
        }
        else if ( key.Pid() == pidAll )
        {
            CreateRange ( curStk, &key, &key, cMaxNodes );
        }
        else
        {
            cMaxNodes--;

            if ( 0 == cMaxNodes )
            {
                ciDebugOut(( DEB_WARN, "Node limit reached in CMasterMergeIndex::QuerySynCursor.\n" ));
                THROW( CException( STATUS_TOO_MANY_NODES ) );
            }

            BitOffset posKey;

            if ( _storage.SupportsShrinkFromFront() &&
                 key.CompareStr( _idxSplitKeyInfo.GetKey() ) <= 0 )
                GetTargetDir().Seek ( key, 0, posKey );
            else
                _pCurrentMasterIndex->GetDirectory().Seek ( key, 0, posKey );

            XPtr<CKeyCursor> xCursor( QuerySplitCursor( &key ) );
            curStk.Push( xCursor.GetPointer() );
            xCursor.Acquire();
        }
    }

    return curStk.QuerySynCursor( MaxWorkId() );
} //QuerySynCursor

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::CreateRange, private
//
//  Synopsis:   Adds all cursors with keys between pkey and pKeyEnd to curStk.
//
//  Arguments:  [curStk]    -- CKeyCurStack to add cursors to.
//              [pkey]      -- Key at beginning of range.
//              [pKeyEnd]   -- End of key range.
//              [cMaxNodes] -- Max node (key) count
//
//  History:    31-Jan-92   AmyA        Created.
//              30-Mar-94   DwightKr    Copied here from CPersIndex and
//                                      modified to span multiple masters
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::CreateRange( COccCurStack & curStk,
                                     const CKey * pKeyStart,
                                     const CKey * pKeyEnd,
                                     ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    cMaxNodes--;

    if ( 0 == cMaxNodes )
    {
        ciDebugOut(( DEB_WARN, "Node limit reached in CPersIndex::CreateRange.\n" ));
        THROW( CException( STATUS_TOO_MANY_NODES ) );
    }

    CKeyCursor * pCursor = QuerySplitCursor( pKeyStart );
    if ( !pCursor )
        return;

    XPtr<CCursor> xCursor( pCursor );

    const CKeyBuf * pKeyCurrent = pCursor->GetKey();
    if ( 0 == pKeyCurrent )
        return;

    PROPID pid = pKeyStart->Pid();

    curStk.Push(pCursor);
    xCursor.Acquire();

    ciDebugOut(( DEB_ITRACE, "First key  %.*ws, pid %d\n",
                pKeyCurrent->StrLen(), pKeyCurrent->GetStr(), pKeyCurrent->Pid() ));
    do
    {
        if (pid != pidAll)  // exact pid match
        {
            // skip wrong pids
            while (pid != pKeyCurrent->Pid())
            {
#if CIDBG == 1 //------------------------------------------
                if (pKeyCurrent)
                {
                    ciDebugOut(( DEB_ITRACE, "  skip: %.*ws, pid %d, wid %d\n",
                        pKeyCurrent->StrLen(),
                        pKeyCurrent->GetStr(),
                        pKeyCurrent->Pid(),
                        pCursor->WorkId() ));
                }
                else
                    ciDebugOut(( DEB_ITRACE, "   <NULL> key\n" ));
#endif  //--------------------------------------------------
                pKeyCurrent = pCursor->GetNextKey();
                if (pKeyCurrent == 0
                    || pKeyEnd->CompareStr(*pKeyCurrent) < 0 )
                    break;
            }
            // either pid matches or we have overshot
            // i.e. different pids and current string > end
        }

        if (pKeyCurrent == 0 || !pKeyEnd->MatchPid(*pKeyCurrent)
            || pKeyEnd->CompareStr (*pKeyCurrent) < 0 )
        {
            break;  // <--- LOOP EXIT
        }

        cMaxNodes--;

        if ( 0 == cMaxNodes )
        {
            ciDebugOut(( DEB_WARN, "Node limit reached in CPersIndex::CreateRange.\n" ));
            THROW( CException( STATUS_TOO_MANY_NODES ) );
        }

        // Clone the previous cursor...
        const CKey & key = *pCursor->GetKey();
        pCursor = QuerySplitCursor( &key );
        xCursor.Set( pCursor );

        // Add it to avoid memory leaks if GetNextKey fails

        curStk.Push(pCursor); // may be wrong pid

        xCursor.Acquire();

        // increment the added cursor
        pKeyCurrent = pCursor->GetNextKey();

#if CIDBG == 1
        if (pKeyCurrent)
        {
            ciDebugOut(( DEB_ITRACE, "   %.*ws, wid %d\n",
                pKeyCurrent->StrLen(), pKeyCurrent->GetStr(), pCursor->WorkId() ));
        }
        else
            ciDebugOut(( DEB_ITRACE, "   <NULL> key\n" ));
#endif

    } while ( pKeyCurrent );

    // Since we have one more cursor in curStk than we wanted...
    curStk.DeleteTop();
} //CreateRange

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergeIndex::Remove, public
//
//  Synopsis:   Closes any open streams/indexes associated with this new
//              master index.
//
//  History:    30-Mar-94   DwightKr    Copied here from CPersIndex
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::Remove()
{
    Win4Assert( 0 == _pTargetSink );
    Win4Assert( !InUse() );
    Win4Assert( IsZombie() );
    Win4Assert( !_pTargetMasterIndex->InUse() );
//  Win4Assert( !"If you are emptying ci press go.O/W call Srikants/DwightKr" );
    ciFAILTEST( STATUS_NO_MEMORY );

    _pTargetMasterIndex->Remove();
    delete _pTargetMasterIndex;
    _pTargetMasterIndex = 0;

    if ( _pCurrentMasterIndex && !_pCurrentMasterIndex->InUse() )
    {
        _pCurrentMasterIndex->Remove();
        delete _pCurrentMasterIndex;
        _pCurrentMasterIndex = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCurrentAndTarget
//
//  Synopsis:   Transfers the ownership of the current and target master
//              indexes to the caller.
//
//  Arguments:  [ppCurrent] -- On output, will have the pointer to the
//              current master (if any). NULL o/w
//              [ppTarget]  -- On output, will have the pointer to the
//              target master. Will be non-NULL.
//
//  History:    9-29-94   srikants   Created
//
//  Notes:      This method must be called atmost ONCE during the lifetime
//              of a CMasterMergeIndex. Also, this must be called after
//              this has been zombified and there are no outstanding
//              queries.
//
//----------------------------------------------------------------------------

void CMasterMergeIndex::AcquireCurrentAndTarget(
        CPersIndex ** ppCurrent, CPersIndex ** ppTarget )
{
    Win4Assert( IsZombie() );
    Win4Assert( !InUse() );

    *ppCurrent = _pCurrentMasterIndex;
    *ppTarget = _pTargetMasterIndex;

    _pCurrentMasterIndex = 0;
    _pTargetMasterIndex = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   RestoreIndexDirectory
//
//  Synopsis:   This method restores the "directory" for the new index
//              in a restarted master merge. It scans the index until
//              it sees the split key and adds it to the directory.
//
//  Effects:
//
//  Arguments:  [splitKey]    - The split key of the new master index.
//              [widMax]      - The largest WORKID in the new master index
//              [bitOffStart] - Offset in bits to the end of splitkey
//
//  History:    4-12-94   srikants   Created
//              5-01-94   DwightKr   Split into two functions
//
//  Notes:      Only the index directory needs to be restored when the
//              CMasterMergeIndex object is rebuild during boot time.
//              The keyList directory needs to be rebuild only when
//              actually restarting the master merge.
//
//              Since it may be quite some time after rebooting a system
//              before the master merge restarts, we don't attempt to rebuild
//              the keylist here.
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::RestoreIndexDirectory(
    const CKeyBuf &   idxSplitKey,
    WORKID            widMax,
    const BitOffset & idxBitOffRestart )
{
    Win4Assert( 0 != &GetTargetDir()  );

    if ( idxSplitKey.IsMinKey() )
        return;

    // Seek to the idxSplitKey in the new master index.  Use the directory

    BitOffset posKey;
    CKeyBuf keyInit;
    const CKey key = idxSplitKey;
    GetTargetDir().Seek( idxSplitKey, & keyInit, posKey );

    CPersDeComp Decomp( GetTargetDir(),
                        GetId(),
                        _pTargetMasterIndex->GetIndex(),
                        posKey,
                        keyInit,
                        &key,
                        widMax,
                        TRUE,    // Use Links
                        FALSE ); // no dir

    BitOffset idxBitOff;
    idxBitOff.Init(0,0);
    CKeyBuf keyLast;

#if CIDBG == 1
    ciDebugOut(( DEB_ITRACE, "restoring index directory\n" ));
    keyLast.SetPid(pidContents); // arbitrary but not pidAll
#endif

    for ( const CKeyBuf * pKey = Decomp.GetKey();
          (0 != pKey) ;
          pKey = Decomp.GetNextKey(&idxBitOff) )
    {
        if ( AreEqual(&idxSplitKey, pKey) )
        {
           //
           // Skip over wid-occurences and position to store the next
           // key in the compressor.
           //
           for ( WORKID widSkipped = Decomp.WorkId();
                 widInvalid != widSkipped;
                 widSkipped = Decomp.NextWorkId() )
           {
               // Null Body
           }

           ciDebugOut(( DEB_ITRACE, "RestoreIndexDirectory - SplitKey Found \n" ));
           break;
        }

        keyLast = *pKey;
    }

    //
    // Make a sanity check to confirm that the compressor and the
    // decompressor arrived at the same offset for the next key.
    // It is extremely important that these match - o/w, the resulting
    // index will be in a corrupt and unusable state.
    //
    BitOffset bitOffCurr;
    Decomp.GetOffset( bitOffCurr );

    ciFAILTEST( CI_CORRUPT_DATABASE );

    if ( !idxSplitKey.IsMaxKey() &&
         ( (bitOffCurr.Page() != idxBitOffRestart.Page()) ||
           (bitOffCurr.Offset() != idxBitOffRestart.Offset()) ) )
    {
        ciDebugOut(( DEB_ERROR,
            "Mismatch in computed vs. stored restart offsets\n" ));
        ciDebugOut(( DEB_ERROR,
            "Computed Page:0x%x Offset:0x%x\n",
            bitOffCurr.Page(), bitOffCurr.Offset() ));
        ciDebugOut(( DEB_ERROR,
            "Saved Page:0x%x Offset:0x%x\n",
            idxBitOffRestart.Page(), idxBitOffRestart.Offset() ));
        Win4Assert( !"Corrupt master merge index" );

        _storage.ReportCorruptComponent( L"MasterMergeIndex2" );

        THROW( CException( CI_CORRUPT_DATABASE ) );
    }

    ciDebugOut(( DEB_ITRACE, "Restart split key is '%ws'\n",
                 idxSplitKey.GetStr() ));
    ciDebugOut(( DEB_ITRACE, "Restart page:offset = 0x%x:0x%x\n",
                 idxBitOffRestart.Page(), idxBitOffRestart.Offset() ));

    ciDebugOut(( DEB_ITRACE, "restored index directory\n" ));
} //RestoreIndexDirectory

#ifdef KEYLIST_ENABLED

//+---------------------------------------------------------------------------
//
//  Function:   RestoreKeyListDirectory
//
//  Synopsis:   This method restores the "directory" for the new keylist
//              in a restarted master merge. It scans the index until
//              it sees the split key and adds it to the directory.
//
//  Effects:
//
//  Arguments:  [splitKey]    - The split key of the new master index.
//              [widMax]      - The largest WORKID in the new master index
//              [bitOffStart] - Offset in bits to the end of splitkey
//
//  History:    4-12-94   srikants   Created
//              5-01-94   DwightKr   Moved into this function
//
//  Notes:      It is assumed that the index directory has already been
//              rebuild when the CMasterMergeIndex object was created.  At
//              this point we are restarting a master merge, and the keyList
//              directory is now required.
//
//----------------------------------------------------------------------------
void CMasterMergeIndex::RestoreKeyListDirectory( const CKeyBuf & idxSplitKey,
                                                 WORKID widMax,
                                                 CWKeyList * pKeyList,
                                                 const CKeyBuf & keylstSplitKey
                                               )
{
    Win4Assert( &GetTargetDir() );
    Win4Assert( _pTargetSink );

    if ( idxSplitKey.IsMinKey() )
        return;

    Win4Assert( keylstSplitKey.Compare( idxSplitKey ) <= 0 );

    //
    //  Seek to the keylstSplitKey in the new master index, and add all
    //  subsequent keys found in the new master index to the new keylist
    //  index.  These keys are missing from the keylist and need to be
    //  restored.
    //
    ciFAILTEST( STATUS_NO_MEMORY );
    if ( !GetTargetDir().IsValid() )
    {
        GetTargetDir().LokBuildDir( idxSplitKey );
    }

    BitOffset posKey;

    const CKey splitKeylst = keylstSplitKey;

    // STACKSTACK
    XPtr<CKeyBuf> xKeyInit(new CKeyBuf());

    GetTargetDir().Seek( keylstSplitKey, xKeyInit.GetPointer(), posKey );

    ciFAILTEST( CI_CORRUPT_DATABASE );

    // STACKSTACK
    XPtr<CPersDeComp> xDecomp(
                        new CPersDeComp(  GetTargetDir(), GetId(),
                         _pTargetMasterIndex->GetIndex(), posKey,
                         xKeyInit.GetReference(), &splitKeylst, widMax,
                         TRUE,    // Use Links
                         TRUE     // Use the directory.
                      ) );

    const CKeyBuf * pKey;
    ULONG page = ULONG(-1);
    BitOffset idxBitOff;
    idxBitOff.Init(0,0);

    BitOffset keylstBitOff;

#if CIDBG == 1
    // STACKSTACK
    XPtr<CKeyBuf> xKeyLast(new CKeyBuf());        // initialized to min key

    xKeyLast->SetPid(pidContents); // arbitrary but not pidAll
#endif

    for ( pKey = xDecomp->GetKey();
          (0 != pKey) ;
          pKey = xDecomp->GetNextKey(&idxBitOff) )
    {
        if ( pKeyList && (keylstSplitKey.CompareStr( *pKey ) < 0) )
        {
            //
            // pKey is not present in the key list. It must be
            // added.
            //
            pKeyList->PutKey( pKey, keylstBitOff );

        }

        if ( AreEqual(&idxSplitKey, pKey) )
        {
           //
           // Skip over wid-occurences and position to store the next
           // key in the compressor.
           //
           for ( WORKID widSkipped = xDecomp->WorkId();
                        widInvalid != widSkipped;
                        widSkipped = xDecomp->NextWorkId() )
           {
                    // nothing to do.
           }

           ciDebugOut(( DEB_ITRACE, "RestoreKeyListDirectory - SplitKey Found \n" ));
           break;
        }

#if CIDBG == 1
        xKeyLast.GetReference() = *pKey;
#endif
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::AcquireRelevantWords, public
//
//  Synopsis:   Return relevant word key ids computed at the most recent
//              master merge.  The caller must delete the object returned.
//
//  Returns:    CRWStore *
//
//  History:    25-Apr-94   v-dlee      Created
//
//----------------------------------------------------------------------------

CRWStore * CMasterMergeIndex::AcquireRelevantWords()
{
    CRWStore *p = _pRWStore;

    ciDebugOut (( DEB_ITRACE,"CPersIndex::acquire _pRWStore: %lx\n",_pRWStore));

    _pRWStore = 0;

    return p;
} //AcquireRelevantWords

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::ComputeRelevantWords, public
//
//  Synopsis:   Compute and return relevant word key ids
//
//  Arguments:  [cRows]    -- # of wids in pwid array
//              [cRW]      -- max # of rw keys per wid
//              [pwid]     -- an array of wids in increasing order whose
//                            rw key ids are to be returned
//              [pKeyList] -- keylist to use in translation of keys to ids
//
//  Returns:    CRWStore *
//
//  History:    25-Apr-94   v-dlee      Created
//
//----------------------------------------------------------------------------

CRWStore * CMasterMergeIndex::ComputeRelevantWords(ULONG cRows,ULONG cRW,
                                            WORKID *pwid,CKeyList *pKeyList)
{

    Win4Assert( !" Not Yet Implemented" );

#ifdef RELEVANT_WORDS_ENABLED
    ciDebugOut((DEB_ITRACE,"ComputeRelevantWords top\n"));

    //
    // Get the resources needed to do the computation
    //

    CRelevantWord RelWord(pwid,cRows,cRW);

    CPersIndexCursor indCur(this);
    CKeyListCursor keylCur(pKeyList);


    //
    // Walk through the index and find occurances of keys in the wids
    //
    const CKeyBuf * pKey, * pklKey;

    for (pKey = indCur->GetKey(), pklKey = keylCur->GetKey();
         pKey != 0; pKey = indCur->GetNextKey())
    {
        if (pKey->Pid() == pidContents &&
            ((CKeyBuf * const) pKey)->IsPossibleRW())
        {
            ULONG cWids = 0;

            for (WORKID wid = indCur->WorkId(); wid != widInvalid;
                 wid = indCur->NextWorkId())
            {
                cWids++;
                if (RelWord.isTrackedWid(wid))
                    RelWord.Add(wid,indCur->OccurrenceCount());
            }

            //
            // Walk the keylist until we match it up with where the
            // index cursor is.
            //
            while (pklKey->CompareStr(*pKey) != 0)
                pklKey = keylCur->GetNextKey();

            RelWord.DoneWithKey(pklKey->Pid(),MaxWorkId(),cWids);
        }
    }

    return RelWord.AcquireStore();
#endif // RELEVANT_WORDS_ENABLED

    return(0);

} //ComputeRelevantWords

#endif  // KEYLIST_ENABLED

//+---------------------------------------------------------------------------
//
//  Function:   CTrackSplitKey::CTrackSplitKey
//
//  Synopsis:   The split key tracking constructor. Initializes the object
//              to have "min" keys and offsets are all set to the beginning
//              of the stream.
//
//  Arguments:  [splitKey] -- splitkey being tracked
//              [bitoffBeginSplit] -- bit offset to beginning of split ket
//              [bitoffEndSplit]   -- bit offset to end of splitkey
//
//  History:    4-12-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CTrackSplitKey::CTrackSplitKey( const CKeyBuf & splitKey,
                                const BitOffset & bitoffBeginSplit,
                                const BitOffset & bitoffEndSplit ) :
    _fNewSplitKeyFound(FALSE)
{
    _splitKey2.SetKey( splitKey );
    _splitKey2.SetBeginOffset( bitoffBeginSplit );
    _splitKey2.SetEndOffset( bitoffEndSplit );
}


//+---------------------------------------------------------------------------
//
//  Function:   BeginNewKey
//
//  Synopsis:   This method informs the split key tracker that a new key
//              has been added to the compressor. It will check if the
//              previous key and the current key are landing on a different
//              page and check if a split key has been found.
//
//  Arguments:  [newKey]      --  The new key added to the compressor
//              [beginNewOff] --  Starting offset of the new key. This will
//                                be the end offset of the current key.
//
//  History:    4-19-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CTrackSplitKey::BeginNewKey( const CKeyBuf & newKey,
                                  const BitOffset & beginNewOff,
                                  WORKID widMax )
{
    //
    // beginNewOff is also the end of current key. We have to determine
    // if there is a new split key.
    //
    _currKey.SetEndOffset( beginNewOff );

    if ( CiPageToCommonPage(_currKey.GetEndOffset().Page()) >
         CiPageToCommonPage(_prevKey.GetEndOffset().Page()) )
    {
        //
        // We have a candidate split key in the previous key.
        //
        _splitKey2 = _splitKey1;
        _splitKey1 = _prevKey;
        _fNewSplitKeyFound = !_splitKey2.GetKey().IsMinKey();

#if CIDBG == 1

        if ( IsNewKeyFound() )
        {
            ciDebugOut(( DEB_PCOMP,
                "Split Key Found At Page 0x%X Offset 0x%X\n",
                _splitKey2.GetBeginOffset().Page(),
                _splitKey2.GetBeginOffset().Offset() ));
            ciDebugOut(( DEB_PCOMP,
                "End of Split Key found at page 0x%x offset 0x%x\n",
                _splitKey2.GetEndOffset().Page(),
                _splitKey2.GetEndOffset().Offset() ));

        }

#endif  // CIDBG

    }

    _prevKey = _currKey;

    _currKey.SetKey( newKey );
    _currKey.SetBeginOffset( beginNewOff );
    _currKey.SetWidMax( widMax );
}


//+---------------------------------------------------------------------------
//
//  Function:   CSplitKeyInfo
//
//  Synopsis:   Constructor the CSplitKeyInfo
//
//  Effects:    Initializes the key to be minkey and offsets to 0,0.
//
//  History:    4-19-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CSplitKeyInfo::CSplitKeyInfo()
{
    _start.Init(0,0);
    _end.Init(0,0);
    _key.FillMin();
    _widMax = widInvalid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\notxact.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1991-1997 Microsoft Corporation.
//
// File:        nottran.cxx
//
// Contents:    Transaction object for notifications
//
// Classes:     CNotificationTransaction
//
// History:     24-Feb-97       SitaramR     Created
//
//-------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "notxact.hxx"
#include "resman.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CNotificationTransaction::CNotificationTransaction
//
//  Synopsis:   Constructor
//
//  History:    24-Feb-97     SitaramR       Created
//
//  Notes:      We initialize the array with a fairly size because we don't
//              want a grow to fail due to low memory during the changelog
//              transaction.
//
//----------------------------------------------------------------------------

CNotificationTransaction::CNotificationTransaction( CResManager *pResManager,
                                                    CIndexNotificationTable *pNotifTable )
  : _pResManager( pResManager ),
    _pNotifTable( pNotifTable ),
    _aCommittedWids(256),
    _aAbortedWidsToRemove(100)
{
}


//+-------------------------------------------------------------------------
//
//  Method:     CNotificationTransactoin::~CNotificationTransaction
//
//  Synopsis:   Destructor
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

CNotificationTransaction::~CNotificationTransaction()
{
    if ( GetStatus() == CTransaction::XActCommit )
    {
        //
        // Commit the transaction which means commit the wids in the
        // comitted and remove the wids in the aborted list.
        //

        //
        // Commit outside resman lock to prevent a deadlock with the
        // lock in the notification table.
        //
        if ( _pNotifTable )
            _pNotifTable->CommitWids( _aCommittedWids );

        CLock lock( _pResManager->GetMutex() );
        for ( unsigned i=0; i<_aAbortedWidsToRemove.Count(); i++ )
        {
            _pResManager->LokRemoveAbortedWid( _aAbortedWidsToRemove.Get(i)._wid,
                                               _aAbortedWidsToRemove.Get(i)._usn );
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CNotificationTransaction::AddCommittedWid
//
//  Synopsis:   Adds a wid to the commited list
//
//  Arguments:  [wid]  -- WORKID
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

void CNotificationTransaction::AddCommittedWid( WORKID wid )
{
    Win4Assert( wid != widInvalid );

    _aCommittedWids.Add( wid, _aCommittedWids.Count() );
}


//+-------------------------------------------------------------------------
//
//  Method:     CNotificationTransaction::RemoveAbortedWid
//
//  Synopsis:   Adds a wid to the aborted-wids-to-remove list
//
//  Arguments:  [wid]  -- WORKID
//              [usn]  -- USN
//
//  History:    24-Feb-1997      SitaramR       Created
//
//--------------------------------------------------------------------------

void CNotificationTransaction::RemoveAbortedWid( WORKID wid, USN usn )
{
    Win4Assert( wid != widInvalid );
    Win4Assert( usn > 0 );
    
    CAbortedWidEntry widEntry( wid, usn );

    _aAbortedWidsToRemove.Add( widEntry, _aAbortedWidsToRemove.Count() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\occtable.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1991 - 1996
//
//  File:       occtable.cxx
//
//  Contents:   Occurrence table for wids
//
//  History:    20-June-96   SitaramR     Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <widtab.hxx>

#include "occtable.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CMaxOccTable::PutOcc
//
//  Synopsis:   Puts the max occurrence so far of (wid,pid) into the table
//
//  Arguments:  [wid]  --  Workid
//              [pid]  --  Property id
//              [occ]  --  Occurrence
//
//  History:    20-June-96    SitaramR     Created
//
//----------------------------------------------------------------------------

void CMaxOccTable::PutOcc( WORKID wid, PROPID pid, OCCURRENCE occ )
{
    unsigned iIndex = FakeWidToIndex( wid );

    Win4Assert( iIndex < CI_MAX_DOCS_IN_WORDLIST );

    if ( occ > _aOccArray[iIndex].Get(pid) )
        _aOccArray[iIndex].Set( pid, occ );
}



//+---------------------------------------------------------------------------
//
//  Member:     CMaxOccTable::GetMaxOcc
//
//  Synopsis:   Returns the max occurrence of (wid,pid)
//
//  Arguments:  [wid]  --  Workid
//              [pid]  --  Property id
//
//  History:    20-June-96    SitaramR     Created
//
//----------------------------------------------------------------------------

OCCURRENCE CMaxOccTable::GetMaxOcc( WORKID wid, PROPID pid )
{
    unsigned iIndex = FakeWidToIndex( wid );

    Win4Assert( iIndex < CI_MAX_DOCS_IN_WORDLIST );

    OCCURRENCE occ = _aOccArray[iIndex].Get(pid) / OCCURRENCE_DIVISOR;

    if ( occ == 0 )
        return 1;

    return occ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\occarray.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1991 - 1997
//
//  File:       occarray.cxx
//
//  Contents:   Occurrence array
//
//  Classes:    CSparseOccArray
//
//  History:    20-Jun-96     SitaramR      Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include "occarray.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CSparseOccArray::CSparseOccArray, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [size] -- the size of the initial array.  If no parameter is
//                        passed in, this defaults to OCCARRAY_SIZE.
//
//  History:    1-Dec-97  dlee   created
//
//----------------------------------------------------------------------------

CSparseOccArray::CSparseOccArray(ULONG size)
   : _aPidOcc( size )
{
} //CSparseOccArray

//+---------------------------------------------------------------------------
//
//  Member:     CSparseOccArray::Get, public
//
//  Synopsis:   Returns a reference to the occurrence count for a propid
//
//  Arguments:  [pid] -- Property id
//
//  History:    1-Dec-97  dlee   created
//
//----------------------------------------------------------------------------

OCCURRENCE & CSparseOccArray::Get( ULONG pid )
{
    //
    // Look it up in the array.  Grab the pointer so we don't use the
    // non-const version of operator []
    //

    SPidOcc * pItems = (SPidOcc *) _aPidOcc.GetPointer();
    unsigned cItems = _aPidOcc.Count();

    for ( ULONG i = 0; i < cItems; i++ )
        if ( pid == pItems[i].pid )
            return pItems[i].occ;

    // not found; assume the occurrence count is 1 and add it to the array

    SPidOcc & item = _aPidOcc[ i ];

    item.pid = pid;
    item.occ = 1;

    return item.occ;
} //Get

//+---------------------------------------------------------------------------
//
//  Member:     CSparseOccArray::Set
//
//  Synopsis:   Sets the occurrence for the pid
//
//  Arguments:  [pid] -- Property id
//              [occ] -- Occurrence to set
//
//  History:    1-Dec-97  dlee   created
//
//----------------------------------------------------------------------------

void CSparseOccArray::Set( ULONG pid, OCCURRENCE occ )
{
    Win4Assert( occ > 0 );

    if ( occ > 1 )
    {
        //
        // First try to update an existing entry for the pid
        //

        SPidOcc * pItems = (SPidOcc *) _aPidOcc.GetPointer();
        unsigned cItems = _aPidOcc.Count();

        for ( ULONG i = 0; i < cItems; i++ )
        {
            if ( pid == pItems[i].pid )
            {
                Win4Assert( occ > pItems[i].occ );
                pItems[i].occ = occ;
                return;
            }
        }

        //
        // This is a linear algorithm -- if we hit this assert for normal
        // files rethink the design.
        //

        Win4Assert( i < 500 );

        //
        // Add the new pid
        //

        SPidOcc & item = _aPidOcc[ i ];
        item.pid = pid;
        item.occ = occ;
    }
} //Set
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\partlst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       PARTLST.CXX
//
//  Contents:   Partition list
//
//  Classes:    CPartList
//
//  History:    28-Mar-91   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pstore.hxx>
#include <cifailte.hxx>
#include <eventlog.hxx>

#include "partn.hxx"
#include "partlst.hxx"
#include "ci.hxx"
#include "index.hxx"
#include "idxids.hxx"
#include "mindex.hxx"
#include "resman.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CPartList::CPartList
//
//  Synopsis:   Constructor.
//
//  Effects:    Opens Partitions Table and creates partitions
//
//  Arguments:  [storage] -- physical storage
//              [ciparent] -- parent content index object
//
//  History:    28-Mar-91   BartoszM       Created.
//
//  Notes:      _partArray is a dynamic array of pointers to partitions
//              indexed by partition ID. Null pointers correspond
//              to nonexisting (deleted) partitions.
//
//              Index ID's for a given partition are packed in the table.
//              SHORT_IDX_ID's are of byte size, 255 of them can be
//              packed into a binary table field. The partition
//              will expand them into full index id's by oring
//              in the partition ID.
//
//----------------------------------------------------------------------------

CPartList::CPartList( PStorage& storage,
                      PIndexTable & idxTab,
                      XPtr<CKeyList> & sKeyList,
                      CTransaction& xact,
                      CCiFrameworkParams & frmwrkParams
 ) :  _sigPartList(eSigPartList),
      _frmwrkParams( frmwrkParams ),
      _idxTab(idxTab),
      _partInfoList(_idxTab.QueryBootStrapInfo()),
      _partArray ( _partInfoList->Count()+1 )
{

    CIndex * pIndex = 0;
    CIidStack stkZombie(1);

    Win4Assert( !_partInfoList->IsEmpty() );

    //
    // Create the Partition Array from the PartInfoList.
    //
    CPartInfo * pPartInfo;
    while ( NULL != (pPartInfo = _partInfoList->GetFirst()) )
    {
        PARTITIONID partId = pPartInfo->GetPartId();
        Win4Assert( !IsValid(partId) );
        CPartition * pPart = new
                             CPartition( pPartInfo->GetChangeLogObjectId(),
                                         partId,
                                         storage,
                                         frmwrkParams );
        _partArray.Add( pPart, partId );
        //
        // Set the wids of the objects that are part of a master
        // merge in this partition. If there is no master merge,
        // the wids will be appropriately set to widInvalid.
        //
        pPart->SetMMergeObjectIds( pPartInfo->GetMMergeLog(),
                                   pPartInfo->GetNewMasterIndex(),
                                   pPartInfo->GetCurrMasterIndex() );
        _partInfoList->RemoveFirst();
        delete pPartInfo;
    }

    Win4Assert( _partInfoList->IsEmpty() );

    CIndexIdList    iidsInUse(16);

    CKeyList * pKeyList = 0;

    {
        SIndexTabIter pIdxIter(_idxTab.QueryIterator());

        if ( pIdxIter->Begin() )
        {
            CIndexRecord record;
            while ( pIdxIter->NextRecord ( record ) )
            {

#ifdef CI_FAILTEST
            NTSTATUS status = CI_CORRUPT_DATABASE ;
            ciFAILTEST( status );
#endif // CI_FAILTEST

                pIndex = RestoreIndex ( record, iidsInUse, stkZombie );
                if ( pIndex )
                {
                    PARTITIONID partid = CIndexId ( record.Iid() ).PartId();

                    if (partid == partidKeyList)
                    {
                        pKeyList = (CKeyList *) pIndex;
                        sKeyList.Set( pKeyList );
                    }
                    else
                    {
                        _partArray.Get(partid)->RegisterId(pIndex->GetId());
                        _partArray.Get(partid)->AddIndex ( pIndex );
                    }
                }
            }
        }

        if (pKeyList == 0)
        {

#ifdef CI_FAILTEST
            NTSTATUS status = CI_CORRUPT_DATABASE ;
            ciFAILTEST( status );
#endif // CI_FAILTEST

            pKeyList = new CKeyList();
            sKeyList.Set(pKeyList);
        }
    }   // This block needed to destroy the pIdxIter

    //
    // If there are any zombie indexes, they must be deleted now.
    //
    if ( stkZombie.Count() != 0 )
    {
        ciDebugOut (( DEB_WARN, "%d zombies\n", stkZombie.Count() ));
        do
        {
            CIndexDesc * pDesc = stkZombie.Pop();
            ciDebugOut (( DEB_WARN, "Removing zombie, iid = %x, objid = %x\n",
                        pDesc->Iid(), pDesc->ObjectId() ));

#ifdef CI_FAILTEST
            NTSTATUS status = CI_CORRUPT_DATABASE ;
            ciFAILTEST( status );
#endif // CI_FAILTEST

            _idxTab.RemoveIndex ( pDesc->Iid() );

            if ( !storage.RemoveObject( pDesc->ObjectId() ) )
            {
                Win4Assert( !"delete of index failed" );
                ciDebugOut(( DEB_ERROR, "Delete of index, objid %08x failed\n",
                             pDesc->ObjectId() ));
            }

            delete pDesc;
        }
        while ( stkZombie.Count() != 0);
    }

    //
    // Delete any unreferenced indexes.
    //
    storage.DeleteUnUsedPersIndexes( iidsInUse );

    //
    // Acquire and return the key list to resman.
    //
    Win4Assert( !sKeyList.IsNull() );
}

//+---------------------------------------------------------------------------
//
//  Function:   RestoreMMergeState
//
//  Synopsis:   Restores the state in memory for a stopped master merge.
//
//  History:    7-07-94   srikants   Moved from the constructor and added
//                                   more robustness checks.
//              9-28-94   srikants   Transfer of mastermerge indsnap fix.
//
//  Notes:      This can throw exceptions if the new index cannot be
//              constructed for some reason.
//
//----------------------------------------------------------------------------

void CPartList::RestoreMMergeState( CResManager & resman, PStorage & storage )
{
    for (PARTITIONID partid=0; partid<_partArray.Size(); partid++)
    {
        CPartition * pPart = _partArray.Get(partid);

        if ( (0 != pPart) && (pPart->InMasterMerge()) )
        {
            WORKID widNewMaster;
            WORKID widMasterLog;
            WORKID widCurrentMaster;

            pPart->GetMMergeObjectIds( widMasterLog, widNewMaster, widCurrentMaster);
            CPersIndex * pCurrentMasterIndex = pPart->GetCurrentMasterIndex();

            if ( widInvalid != widCurrentMaster && 0 == pCurrentMasterIndex )
            {
                //
                // MMState indicates that there is a master index but
                // we don't have one now - it must be a corruption.
                //
                Win4Assert( !"Corrupt catalog" );
                storage.ReportCorruptComponent( L"PartitionList1" );

                THROW( CException( CI_CORRUPT_DATABASE ) );
            }

            PRcovStorageObj *pPersMMergeLog = _idxTab.GetStorage().QueryMMergeLog(widMasterLog);
            SRcovStorageObj PersMMergeLog( pPersMMergeLog );

            XPtr<CMMergeLog> xMMergeLog( new CMMergeLog( *pPersMMergeLog ) );

            CMasterMergeIndex * pIndex = 0;

            //
            // Create a snapshot of the merge indexes to be given to the
            // master merge index.
            //
            CIndexSnapshot * pIndSnap = new CIndexSnapshot( resman );
            SIndexSnapshot sIndSnap( pIndSnap );
            pIndSnap->LokRestart( *pPart, *pPersMMergeLog );

#ifdef CI_FAILTEST
            NTSTATUS status = CI_CORRUPT_DATABASE ;
            ciFAILTEST( status );
#endif // CI_FAILTEST

            pIndex = new CMasterMergeIndex( _idxTab.GetStorage(),
                                             widNewMaster,
                                             pPart->GetNewMasterIid(),
                                             xMMergeLog->GetIndexWidMax(),
                                             pCurrentMasterIndex,
                                             widMasterLog,
                                             xMMergeLog.GetPointer() );
            //
            // ===================================================
            //
            // Beginning of no-failure region.

            pIndex->SetMMergeIndSnap( sIndSnap.Acquire() );


            pPart->RegisterId( pIndex->GetId() );
            pPart->AddIndex ( pIndex );

            //
            //  If there is a pCurrentMasterIndex, then the pNewMasterIndex
            //  encapsulates it and it should be invisible to the rest of CI.
            //  Hence remove it from the index list within the partition.
            //
            if ( pCurrentMasterIndex )
            {
                pPart->LokRemoveIndex( pCurrentMasterIndex->GetId() );
                pPart->SetOldMasterIndex( pCurrentMasterIndex );
            }

            //
            // ===================================================
            //
            // End of no-failure region.
        }
    }
}

extern BOOL IsLowResources( SCODE sc );

//+---------------------------------------------------------------------------
//
// Member:      CPartList::RestoreIndex
//
// Synopsis:    Restores the index
//
// Arguments:   [rec]       -
//              [iidsInUse] -
//              [stkZombie] -
//
// History:      07-Jan-99   klam   Created header
//                                  Rethrow if low on disk space
//
//----------------------------------------------------------------------------
CIndex* CPartList::RestoreIndex ( CIndexRecord & rec,
                                  CIndexIdList & iidsInUse,
                                  CIidStack & stkZombie)
{
    PARTITIONID partid = CIndexId ( rec.Iid() ).PartId();
    //for keylist needs, should this be turned into CIndex * pIndex?
    CPersIndex * pIndex = 0;
    CIndexDesc * pdesc;
    CPartition * pPart = 0;

    TRY
    {
        switch ( rec.Type() )
        {
        case itNewMaster:
            pPart = _partArray.Get(partid);
            pPart->SetNewMasterIid( rec.Iid() );

            iidsInUse.Add( rec.Iid(), iidsInUse.Count() );

        break;

        case itMaster:
        case itShadow:

            {
                ciDebugOut (( DEB_ITRACE, "\tRestore %s %x, max wid %d\n",
                    rec.Type() == itMaster ? "MASTER" : "SHADOW",
                    rec.Iid(), rec.MaxWorkId() ));

                iidsInUse.Add( rec.Iid(), iidsInUse.Count() );

                CDiskIndex::EDiskIndexType idxType = rec.Type() == itMaster ?
                                 CDiskIndex::eMaster : CDiskIndex::eShadow;
                pIndex = new CPersIndex (
                                      _idxTab.GetStorage(),
                                       rec.ObjectId(),
                                       rec.Iid(),
                                       rec.MaxWorkId(),
                                       idxType,
                                       PStorage::eOpenForRead,
                                       TRUE);

            }

            break;

        case itZombie:

            ciDebugOut((DEB_ITRACE,
                "Removing zombie index %lx from physical storage\n",
                rec.Iid()));

            pIndex = 0;
            pdesc = new CIndexDesc( rec );
            stkZombie.Push( pdesc );
        break;

        case itPartition:
        break;

        case itDeleted:
            ciDebugOut (( DEB_ITRACE, "Deleted index %lx\n", rec.Iid() ));
        break;

        case itKeyList:
            ciDebugOut (( DEB_ITRACE, "\tRestore keylist %x, max key %d, KeyList\n",
                rec.Iid(), rec.MaxWorkId() ));

#ifdef KEYLIST_ENABLED
            pIndex = (CPersIndex *) new CKeyList ( _idxTab.GetStorage(),
                                                   rec.ObjectId(),
                                                   rec.Iid(),
                                                   rec.MaxWorkId() );

#else
            pIndex = (CPersIndex *) new CKeyList( rec.MaxWorkId(),
                                                 rec.Iid() );
#endif  // KEYLIST_ENABLED

        break;

        case itMMKeyList:
            ciDebugOut(( DEB_ITRACE,
                "MM KeyList Wid 0x%X\n", rec.ObjectId() ));
            _idxTab.GetStorage().SetSpecialItObjectId( itMMKeyList, rec.ObjectId() );
            break;

        }
    }
    CATCH( CException, e )
    {
        delete pIndex;
        pIndex = 0;

        SCODE sc = e.GetErrorCode();

        if ( IsDiskLowError( sc ) || IsLowResources( sc ) )
        {
            ciDebugOut (( DEB_WARN, "CPartlist::RestoreIndex - Out of resources!" ));
            RETHROW ();
        }
        else
        {
            ciDebugOut(( DEB_WARN, "Fatal error %x opening index.  "
                         "Zombifying iid=0x%x, objid=0x%x, type=0x%x\n",
                         sc,
                         rec.Iid(), rec.ObjectId(), rec.Type() ));
            Win4Assert( !"Corrupt catalog" );

            THROW( CException( CI_CORRUPT_DATABASE ) );
        }
    }
    END_CATCH;

    return pIndex;
} //RestoreIndex


//+---------------------------------------------------------------------------
//
//  Member:     CPartList::LokGetPartition, public
//
//  Synopsis:   Converts partition id into partition object
//
//  History:    07-Oct-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CPartition* CPartList::LokGetPartition ( PARTITIONID partid )
{
    if ( partid >= _partArray.Size() )
        THROW ( CException ( CI_INVALID_PARTITION ));

    return _partArray.Get( partid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartList::LokSwapIndexes, public
//
//  Synopsis:   Adds new persistent index to the table
//              and removes old ones
//
//  Arguments:  [indexNew] -- new index
//              [cIidOld] -- count of old indexes
//              [aIidOld] -- array of old index id's
//
//  History:    02-May-91   BartoszM       Created.
//              07-Apr-94   DwightKr       Added code for master index
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CPartList::LokSwapIndexes (
    CMergeTrans& xact,
    PARTITIONID partid,
    CDiskIndex * indexNew,
    CShadowMergeSwapInfo & info
    )
{
    ciDebugOut (( DEB_ITRACE, "CPartList::LokSwapIndexes\n" ));

    CPartition* pPart = LokGetPartition ( partid );

    if ( 0 == indexNew )
        info._recNewIndex._objectId = widInvalid;
    else
    {
        pPart->Swap ( xact, indexNew, info._cIndexOld, info._aIidOld );

        indexNew->FillRecord( info._recNewIndex );

        Win4Assert( ! indexNew->IsMaster() );

        #ifdef CI_FAILTEST
            NTSTATUS status = CI_CORRUPT_DATABASE ;
            ciFAILTEST( status );
        #endif // CI_FAILTEST
    }

    _idxTab.SwapIndexes (info);
}

void CPartList::LokSwapIndexes (
    CMergeTrans& xact,
    PARTITIONID partid,
    CDiskIndex * indexNew,
    CMasterMergeSwapInfo & info,
    CKeyList const * pOldKeyList,
    CKeyList const * pNewKeyList )
{
    ciDebugOut (( DEB_ITRACE, "CPartList::LokSwapIndexes\n" ));

    CPartition* pPart = LokGetPartition ( partid );

    indexNew->FillRecord( info._recNewIndex );

    info._iidOldKeyList = pOldKeyList->GetId();
    pNewKeyList->FillRecord( info._recNewKeyList );

    Win4Assert( indexNew->IsMaster() );

    WORKID widCurrentMaster;
    WORKID widNewMaster;

    pPart->GetMMergeObjectIds( info._widMMLog, widNewMaster, widCurrentMaster );

#ifdef CI_FAILTEST
    NTSTATUS status = CI_CORRUPT_DATABASE ;
    ciFAILTEST( status );
#endif // CI_FAILTEST

    _idxTab.SwapIndexes ( info );

    //
    // At this stage there are no traces of the master merge in persistent
    // storage. The entry for the master merge log has been deleted from
    // the index list. We have to clean up the in-memory data structures
    // to reflect this.
    //

    pPart->Swap ( xact, indexNew, info._cIndexOld, info._aIidOld );
    pPart->SetMMergeObjectIds( widInvalid, widInvalid, widNewMaster );
    pPart->SetOldMasterIndex(0);
    pPart->SetNewMasterIid(CIndexId( iidInvalid, partidInvalid ) );

    //
    // RemoveMMLog cannot throw.
    //
    _idxTab.GetStorage().RemoveMMLog( info._widMMLog );

}

#ifdef KEYLIST_ENABLED
//+-------------------------------------------------------------------------
//
//  Method:     CPartList::LokRemoveKeyList
//
//  Synopsis:   Persistently remove keylist
//
//  Arguments:  [pKeyList] -- Keylist to remove
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

void  CPartList::LokRemoveKeyList ( CKeyList const * pKeyList )
{
    if ( pKeyList->IsPersistent() )
    {

#ifdef CI_FAILTEST
    NTSTATUS status = CI_CORRUPT_DATABASE ;
    ciFAILTEST( status );
#endif // CI_FAILTEST

        CIndexId iid = pKeyList->GetId();
        _idxTab.RemoveIndex ( iid );
    }
}
#endif  // KEYLIST_ENABLED

//+---------------------------------------------------------------------------
//
//  Member:     CPartList::LokRemoveIndex, public
//
//  Synopsis:   Removes index from list
//
//  Arguments:  [iid] -- index id
//
//  History:    02-May-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void  CPartList::LokRemoveIndex ( CIndexId iid )
{
    CPartition* pPart = LokGetPartition ( iid.PartId() );
    ciAssert ( pPart != 0 );

    pPart->FreeIndexId ( iid );

#ifdef CI_FAILTEST
    NTSTATUS status = CI_CORRUPT_DATABASE ;
    ciFAILTEST( status );
#endif // CI_FAILTEST

    if ( iid.IsPersistent() )
        _idxTab.RemoveIndex ( iid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartList::LokWlCount, public
//
//  Synopsis:   Counts the existing word lists
//
//  Returns:    number of word lists
//
//  History:    11-May-93   AmyA           Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

unsigned CPartList::LokWlCount ()
{
    CPartIter iter;
    unsigned count = 0;
    for ( iter.LokInit(*this); !iter.LokAtEnd(); iter.LokAdvance(*this))
        count += iter.LokGet()->WordListCount();

    return count;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartList::LokIndexCount, public
//
//  Synopsis:   Counts the existing persistent indexs
//
//  Returns:    number of indexs
//
//  History:    14-Apr-93   t-joshh           Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

unsigned CPartList::LokIndexCount ()
{
    CPartIter iter;
    unsigned count = 0;
    for ( iter.LokInit(*this); !iter.LokAtEnd(); iter.LokAdvance(*this))
        count += iter.LokGet()->LokIndexCount();

    return count;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartList::LokIndexSize, public
//
//  Synopsis:   Counts the total size occupied by the persistent indexs
//
//  Returns:    size of index
//
//  History:    14-Apr-93   t-joshh           Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

unsigned CPartList::LokIndexSize ()
{
    CPartIter iter;
    unsigned count = 0;
    for ( iter.LokInit(*this); !iter.LokAtEnd(); iter.LokAdvance(*this))
        count += iter.LokGet()->LokIndexSize();

    return count;
}

//+---------------------------------------------------------------------------
//
//  Function:   LokAddIt, public
//
//  Synopsis:   Adds the wid to the index list
//
//  Arguments:  [objectId] -- object ID to add to partition table
//              [it]       --  Index type of the object to be added
//              [partid]   --  Partition id in which to add.
//
//  History:    Nov-16-94   DwightKr   Created
//
//  Notes:      It is assumed that only one of each "it" will be added
//              but no check is made to that effect.
//
//----------------------------------------------------------------------------
void CPartList::LokAddIt( WORKID objectId, IndexType it, PARTITIONID partid )
{
    _idxTab.AddObject( partid, it, objectId );
}


//+---------------------------------------------------------------------------
//
//  Function:   GetChangeLogObjectId, public
//
//  Synopsis:   Returns the change log wid for the partition specified
//
//  Arguments:  [partid] --  Partition id to return change log wid
//
//  History:    16-Aug-94   DwightKr    Created
//
//----------------------------------------------------------------------------
WORKID CPartList::GetChangeLogObjectId( PARTITIONID partid )
{
    WORKID widChangeLog = widInvalid;

    CPartInfo *pPartInfo = _partInfoList->GetPartInfo( partid );
    if ( pPartInfo )
        widChangeLog = pPartInfo->GetChangeLogObjectId();

    return widChangeLog;
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void CPartIter::LokInit(CPartList& partList)
{
    _curPartId = 0;
    _pPart = 0;
    LokAdvance(partList);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPartIter::LokAdvance, public
//
//  Synopsis:   Returns pointer to next partition
//
//  History:    23-Jul-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

void CPartIter::LokAdvance ( CPartList& partList)
{
    ciAssert ( _curPartId != partidInvalid );
    while ( _curPartId <= partList.MaxPartid()
        && !partList.IsValid (_curPartId) )
    {
        _curPartId++;
    }

    if ( !partList.IsValid (_curPartId ) )
    {
        _curPartId = partidInvalid;
        _pPart = 0;
    }
    else
    {
        _pPart = partList.LokGetPartition ( _curPartId );
        ciAssert ( _pPart );
        _curPartId++;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CPartIdIter::LokInit, public
//
//  Synopsis:   Partition iterator
//
//  History:    23-Jul-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

void CPartIdIter::LokInit ( CPartList& partList )
{
    _curPartId = 0;
    LokAdvance(partList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartIdIter::LokAdvance, public
//
//  Synopsis:   Advances to next partition id
//
//  History:    23-Jul-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

void CPartIdIter::LokAdvance( CPartList& partList )
{
    ciAssert ( _curPartId != partidInvalid );

    while ( _curPartId <= partList.MaxPartid()
        && !partList.IsValid (_curPartId) )
    {
        _curPartId++;
    }

    if ( !partList.IsValid (_curPartId ) )
    {
        _curPartId = partidInvalid;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\partn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2001.
//
//  File:   PARTN.CXX
//
//  Contents:   Content Index Partition
//
//  Classes:    CPartition
//
//  History:    22-Mar-91   BartoszM    Created.
//
//  Notes:      Unique index ID is created from byte sized per partition
//              index ID and Partition ID shifted left by 8.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rwex.hxx>
#include <cifailte.hxx>

#include "partn.hxx"
#include "pindex.hxx"
#include "indxact.hxx"
#include "mmerglog.hxx"
#include "mindex.hxx"
#include "resman.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::CPartition, public
//
//  Synopsis:   Constructor for partition
//
//  Arguments:
//              [wid]       -- wid used for the change log
//              [partId]    -- partition id
//              [storage]   -- used to create files
//              [frmwrkParams] -- registry params to use
//
//  History:    3-Apr-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CPartition::CPartition (
    WORKID wid,
    PARTITIONID partID,
    PStorage& storage,
    CCiFrameworkParams & frmwrkParams )
: _sigPartition(eSigPartition),
  _frmwrkParams( frmwrkParams ),
  _id ( partID ), _queryCount(0), _changes( wid, storage, frmwrkParams ),
  _widMasterLog(widInvalid),
  _widNewMaster(widInvalid),
  _widCurrentMaster(widInvalid),
  _widChangeLog(wid),
  _iidNewMasterIndex(CIndexId( iidInvalid, partidInvalid ) ),
  _pRWStore(0),
  _pOldMasterIndex(0),
  _pMMergeIndSnap(0),
  _storage(storage),
  _fCleaningUp(FALSE)
{
    // Fill the set of available index id's
    _setPersIid.Fill();
    _setPersIid.Remove( iidInvalid );

    _wlid =  MAX_PERS_ID + 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::~CPartition, public
//
//  Synopsis:   Destructor for partition
//
//  History:    4-Apr-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CPartition::~CPartition ()
{
    delete _pRWStore;
    delete _pMMergeIndSnap;

    CIndex* pIndex;

    //
    // If a MasterMerge is in progress, the master index has an indexsnap
    // shot with references to participating indexes. That must be deleted
    // first.
    //
    pIndex = GetCurrentMasterIndex();
    if ( 0 != pIndex )
    {
        _idxlst.Remove( pIndex->GetId() );
        delete pIndex;
    }

    while ( (pIndex = _idxlst.RemoveTop()) != 0 )
    {
        delete pIndex;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokEmpty, public
//
//  Synopsis:   Initialize a empty partition
//
//  History:    14-Nov-94   DwightKr       Created.
//
//----------------------------------------------------------------------------
void CPartition::LokEmpty()
{
    _widMasterLog      = widInvalid;
    _widNewMaster      = widInvalid;
    _widCurrentMaster  = widInvalid;
    _iidNewMasterIndex = CIndexId( iidInvalid, partidInvalid );

    delete _pRWStore;
    _pRWStore = NULL;

    _pOldMasterIndex = NULL;

    delete _pMMergeIndSnap;
    _pMMergeIndSnap = NULL;

    _changes.LokEmpty();
}

#define _CompUL(x,y) ((*(x)) > (*(y)) ? 1 : (*(x)) == (*(y)) ? 0 : -1)
#define _SwapUL(x,y) { ULONG _t = *(x); *(x) = *(y); *(y) = _t; }

inline static void _AddRootUL(ULONG x,ULONG n,ULONG *p)
{
    ULONG _x = x;
    ULONG _j = (2 * (_x + 1)) - 1;

    while (_j < n)
    {
        if (((_j + 1) < n) &&
            (_CompUL(p + _j,p + _j + 1) < 0))
            _j++;
        if (_CompUL(p + _x,p + _j) < 0)
        {
            _SwapUL(p + _x,p + _j);
            _x = _j;
            _j = (2 * (_j + 1)) - 1;
        }
        else break;
    }
} //_AddRootUL

void SortULongArray(ULONG *pulItems,ULONG cItems)
{
    if (cItems == 0)
        return;

    long z;

    for (z = (((long) cItems + 1) / 2) - 1; z >= 0; z--)
    {
        _AddRootUL(z,cItems,pulItems);
    }

    for (z = cItems - 1; z != 0; z--)
    {
        _SwapUL(pulItems,pulItems + z);
        _AddRootUL(0,(ULONG) z,pulItems);
    }
} //_SortULongArray

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokQueryMergeIndexes, public
//
//  Arguments:  [count] -- returns count of indexes in the array
//              [mt]    -- type of merge
//
//  Returns:    Array of indexes to be merged
//
//  History:    4-Apr-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

CIndex** CPartition::LokQueryMergeIndexes ( unsigned& count, MergeType mt )
{
    ciDebugOut (( DEB_ITRACE, "Query %s (%d)\n",
                  (mt == mtWordlist) ? "wordlists" : "merge indexes",
                  _idxlst.Count() ));

    int cInd = _idxlst.Count();
    ciDebugOut (( DEB_ITRACE, "  Merge indexes: " ));

    CIndex** indexes = new CIndex* [ cInd ];
    SByteArray sapIndex( indexes );

    unsigned cIndSoFar = 0;

    CForIndexIter iter(_idxlst);

    if ( mtMaster == mt )
    {
        //
        // Don't include wordlists in a master merge. Must use only
        // persistent indexes.
        //
        for ( ; !_idxlst.AtEnd(iter); _idxlst.Advance(iter) )
        {
            CIndexId iid = iter->GetId();
            if ( iid.IsPersistent() && !iter->IsZombie() )
            {
                ciDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "%lx, ",
                             iter->GetId() ));

                iter->Reference();
                indexes[cIndSoFar++] = iter.GetIndex();
            }
        }
    }
    else
    {
        Win4Assert( mtShadow == mt || mtWordlist == mt || mtAnnealing == mt || mtIncrBackup || mtDeletes == mt );

        // Get the sizes of all persistent indexes that might be in the merge

        ULONG aSizes[ MAX_PERS_ID ];
        ULONG cPersistent = 0;

        {
            CForIndexIter iterSize( _idxlst );
    
            for ( ; !_idxlst.AtEnd( iterSize ); _idxlst.Advance( iterSize ) )
            {
                if ( !iterSize->IsMaster() && !iterSize->InMasterMerge() )
                {
                    CIndexId iid = iterSize->GetId();

                    if ( iid.IsPersistent() )
                    {
                        ULONG cp = iterSize->Size();
                        //DbgPrint( "  pers index %d is size %#x pages\n", cPersistent, cp );

                        aSizes[ cPersistent++ ] = cp;
                    }
                }
            }
        }

        // Find the size of the index with 1/3 smaller and 2/3 larger indexes

        ULONG aMedian[ MAX_PERS_ID ];
        RtlCopyMemory( &aMedian, &aSizes, cPersistent * sizeof ULONG );
        SortULongArray( (ULONG *) &aMedian, cPersistent );
        ULONG cpAtOneThird = aMedian[ cPersistent / 3 ];

        // Wordlists come first in the iteration.  Add them all to the merge.
 
        for ( ; !_idxlst.AtEnd(iter); _idxlst.Advance(iter) )
        {
            CIndexId iid = iter->GetId();

            if ( iid.IsPersistent() )
                break;

            ciDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "%lx, ",
                         iter->GetId() ));
            Win4Assert ( !iter->IsZombie() );
            iter->Reference();
            indexes[cIndSoFar++] = iter.GetIndex();
        }

        //
        // If we are doing a shadow merge, we must not have more than the maximum
        // allowed count of indexes - so merge as to have at most that number.
        //

        if ( mtShadow == mt || mtAnnealing == mt || mtIncrBackup == mt || mtDeletes == mt )
        {
            unsigned cMaxRemaining;

            //
            // Count is decremented by 1 to account for the new index that will
            // be created.
            //

            BOOL fAnyPersistent = TRUE;

            if ( mtDeletes == mt )
            {
                cMaxRemaining = _frmwrkParams.GetMaxIndexes() - 1;
            }
            else if ( mtShadow == mt )
            {
                cMaxRemaining = 0;

                // Don't use any persistent indexes in the merge if
                // there are free slots available.

                if ( cPersistent < _frmwrkParams.GetMaxIndexes() )
                    fAnyPersistent = FALSE;
            }
            else if ( mtAnnealing == mt )
            {
                cMaxRemaining = _frmwrkParams.GetMaxIdealIndexes() - 1;
            }
            else
            {
                cMaxRemaining = 0;
            }

            ULONG cSoFar = 0;

            if ( fAnyPersistent )
            {
                while (  !_idxlst.AtEnd(iter) && (cInd - cIndSoFar > cMaxRemaining) )
                {
                    CIndexId iid = iter->GetId();
    
                    ciDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "pers: %lx, ",
                                 iter->GetId() ));
                    Win4Assert ( !iter->IsZombie() );
    
                    if ( !iter->IsMaster() && !iter->InMasterMerge() )
                    {
                        //
                        // We should skip over the master index and indexes
                        // participating in a master merge for a shadow merge.
                        // Also skip indexes > 4 times the size of the 1/3 median.
                        //
    
                        if ( ( mtShadow != mt ) ||
                             ( aSizes[cSoFar] < ( 4 * cpAtOneThird) ) )
                        {
                            iter->Reference();
                            indexes[cIndSoFar++] = iter.GetIndex();
                        }
    
                        cSoFar++;
                    }
                    else
                    {
                        #if DBG==1
                            if ( iter->InMasterMerge() )
                            {
                                ciDebugOut(( DEB_ITRACE,
                                "ShadowMergeSet:Skipping over 0x%X - Already in MMergeSet\n",
                                             iter->GetId() ));
                            }
                        #endif  // DBG==1
                    }
    
                    _idxlst.Advance(iter);
                }
            }
        }
    }

    count = cIndSoFar;
    ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "\n" ));

    sapIndex.Acquire();
    return indexes;
} //LokQueryMergeIndexes

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokQueryIndexesForBackup
//
//  Synopsis:   Snaps persistent indexes for backup. For a full backup, all
//              persistent indexes are returned. For an incremental backup,
//              only the shadow indexes are returned.
//
//  Arguments:  [count] - on output, count of indexes
//              [fFull] - Flag indicating if it is a full backup.
//
//  Returns:    Array of pointers to refcounted indexes.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

CIndex** CPartition::LokQueryIndexesForBackup ( unsigned& count, BOOL fFull )
{
    ciDebugOut (( DEB_ITRACE, "LokQueryIndexesForBackup (%s)\n",
                  fFull ? "Full" : "Incremental" ));

    int cInd = _idxlst.Count();
    ciDebugOut (( DEB_ITRACE, "  Backup indexes: " ));

    CIndex** indexes = new CIndex* [ cInd ];
    SByteArray sapIndex( indexes );

    unsigned cIndSoFar = 0;

    CForIndexIter iter(_idxlst);

    //
    // Don't include wordlists . Must use only persistent indexes.
    //
    for ( ; !_idxlst.AtEnd(iter); _idxlst.Advance(iter) )
    {
        CIndexId iid = iter->GetId();
        if ( iid.IsPersistent() && !iter->IsZombie() )
        {
            if ( !fFull && iter.GetIndex()->IsMaster() )
            {
                //
                // For an incremental backup, skip the master index.
                //
                continue;
            }

            //
            // We should never have an in-progress merge while doing the
            // save.
            //
            Win4Assert( ! iter.GetIndex()->IsMasterMergeIndex() );
            ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "%lx, ",
                          iter->GetId() ));

            iter->Reference();
            indexes[cIndSoFar++] = iter.GetIndex();
        }
    }

    count = cIndSoFar;
    ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "\n" ));

    sapIndex.Acquire();
    return indexes;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokCheckMerge, public
//
//  Synopsis:   Checks if there is need to merge
//
//  Arguments:  [mt] -- type of merge
//  History:    4-Apr-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------
BOOL CPartition::LokCheckMerge( MergeType mt )
{
    if ( mt == mtShadow )
    {
        ciDebugOut (( DEB_ITRACE, "Partition: check shadow merge\n" ));

        if ( _idxlst.CountWlist() >= _frmwrkParams.GetMaxWordlists() )
        {
            ciDebugOut (( DEB_ITRACE | DEB_PENDING,
                          "Shadow merge, reason: wordlists %d >= %d \n",
                          _idxlst.CountWlist(), _frmwrkParams.GetMaxWordlists() ));
            return TRUE;
        }

        if ( LokCheckWordlistMerge() )
        {
            ciDebugOut(( DEB_ITRACE | DEB_PENDING,
                         "Shadow merge, reason: wordlist size > %d\n",
                         _frmwrkParams.GetMinSizeMergeWordlist() ));
            return TRUE;
        }
    }
    else if ( mt == mtAnnealing )
    {
        ciDebugOut (( DEB_ITRACE, "Partition: check annealing merge\n" ));

        if ( _idxlst.Count() > _frmwrkParams.GetMaxIdealIndexes() ||
             _idxlst.CountWlist() > 0 )
        {
            ciDebugOut (( DEB_ITRACE | DEB_PENDING,
                          "Annealing merge, reason: too many indices %d >= %d, %d wordlists \n",
                          _idxlst.Count(), _frmwrkParams.GetMaxIdealIndexes(), _idxlst.CountWlist() ));
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokCheckWordlistMerge, public
//
//  Synopsis:   Checks if there is need to merge due to excessive wordlist
//              memory consumption.
//
//  History:    12-Jan-1999   KyleP         Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

BOOL CPartition::LokCheckWordlistMerge()
{
    unsigned size = 0;

    for ( CForIndexIter iter (_idxlst);
          !_idxlst.AtEnd(iter);
          _idxlst.Advance(iter) )
    {
        CIndexId iid = iter->GetId();

        if ( iid.IsPersistent() )
            break;

        Win4Assert( !iter->IsZombie() );

        size += iter.GetIndex()->Size();
    }

    return ( size > _frmwrkParams.GetMinSizeMergeWordlist() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokGetIndexes, public
//
//  Synopsis:   Returns an array of index pointers
//
//  Arguments:  [cInd] -- count of returned indexes
//
//  History:    07-Oct-91   BartoszM    Created
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

unsigned CPartition::LokGetIndexes ( CIndex** apIndex )
{
    ciDebugOut (( DEB_ITRACE, "CPartition::GetIndexes\n" ));
    if ( _idxlst.Count() == 0 )
        return 0;

    unsigned cInd = 0;
    for (CForIndexIter iter (_idxlst); !_idxlst.AtEnd(iter); _idxlst.Advance(iter))
    {
        Win4Assert ( !iter->IsZombie() );
        iter->Reference();
        apIndex[cInd] = iter.GetIndex();
        cInd++ ;
    }
    return cInd;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokMakeWlstId, public
//
//  Synopsis:   Return unique volatile index id
//
//  History:    12-Apr-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

INDEXID CPartition::LokMakeWlstId ()
{
    Win4Assert ( _wlid > MAX_PERS_ID );
    ULONG hint = _wlid;
    CIndexId iid;

    for(;;)
    {
        iid = CIndexId ( hint, _id );
        for ( CForIndexIter iter = _idxlst;
            !_idxlst.AtEnd(iter);
            _idxlst.Advance(iter) )
        {
            if ( iter->GetId() == iid )
                break;
        }

        hint++;

        // wrap around
        if ( hint >= MAX_VOL_ID )
            hint = MAX_PERS_ID + 1;

        Win4Assert ( hint != _wlid );

        if (_idxlst.AtEnd(iter) )
            break;
    }
    _wlid = hint;
    return iid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokMakePersId, public
//
//  Synopsis:   Return unique persistent index id
//
//  History:    12-Apr-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

INDEXID CPartition::LokMakePersId ()
{
    int piid = _setPersIid.FirstElement();
    if ( piid == EOS )
    {
        Win4Assert ( piid != EOS );
        return iidInvalid;
    }

    _setPersIid.Remove ( piid );

    ciDebugOut (( DEB_ITRACE, "New pers index id %x\n", piid ));

    CIndexId iid ( piid, _id );

#if CIDBG==1
    //
    // There musn't be an index already with the same iid.
    //
    Win4Assert( 0 == LokGetIndex(iid) && "Adding Duplicate Index" );
#endif  // CIDBG==1

    return iid;
}

void CPartition::RegisterId ( CIndexId iid )
{


    int persid = iid.PersId();
    _setPersIid.Remove ( persid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::FreeIndexId, public
//
//  Synopsis:   Recycle index id
//
//  History:    08-Oct-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CPartition::FreeIndexId ( CIndexId iid )
{
    ciDebugOut (( DEB_ITRACE, "Free index id %lx\n", iid ));
    if ( iid.IsPersistent() )
    {
        int persid = iid.PersId();
        _setPersIid.Add ( persid );
    }
}


#if CIDBG==1

CIndex * CPartition::LokGetIndex( CIndexId iid)
{
    CForIndexIter iter(_idxlst);

    for ( ; !_idxlst.AtEnd(iter); _idxlst.Advance(iter) )
    {
        CIndexId iidCurr = iter->GetId();
        if ( iidCurr == iid )
        {
            return iter.GetIndex();
        }
    }

    return 0;
}

#endif  // CIDBG==1

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::AddIndex, public
//
//  Synopsis:   Add a newly created index (wordlist)
//
//  Arguments:  [pIndex] -- index to be added
//
//  History:    26-Apr-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CPartition::AddIndex ( CIndex* pIndex )
{
    ciDebugOut (( DEB_ITRACE, "Partition: Adding index %lx\n", pIndex->GetId() ));

#if CIDBG==1
    //
    // This index must not already exist in the list.
    //
    CIndexId iid = pIndex->GetId();
    Win4Assert( 0 == LokGetIndex( iid ) && "Adding Duplicate Index" );
#endif  // CIDBG==1

    _idxlst.Add ( pIndex );

#ifdef CI_FAILTEST
    NTSTATUS status = CI_CORRUPT_DATABASE ;
    ciFAILTEST( status );
#endif // CI_FAILTEST

}

//+---------------------------------------------------------------------------
//
//  Member:     CPartition::Swap, public
//
//  Synopsis:   Replace old indexes with a new one (after merge)
//              Old indexes are removed from the list
//              and marked 'deleted' for later deletion
//
//  Arguments:  [xact] -- transaction
//              [pIndexNew] -- index to be added
//              [cInd] -- count of indexes to be removed
//              [aiidOld] -- indexes to be removed
//
//  History:    26-Apr-91   BartoszM       Created.
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CPartition::Swap (
    CMergeTrans& xact,
    CIndex * pIndexNew,
    unsigned cInd,
    INDEXID aIidOld[] )
{
    ciDebugOut (( DEB_ITRACE, "Partition: Swap in %lx for \n",
        pIndexNew->GetId() ));

    // Indexes will be deleted when transaction commits

    for ( unsigned i = 0; i < cInd; i++ )
    {
        _idxlst.Remove ( aIidOld[i] );
        xact.LogSwap ();
    }

    //
    //  The master index was added to the index list at the BEGINNING of the
    //  master merge.  Hence we don't need to add it here.
    //
    if ( !pIndexNew->IsMaster() )
    {

#if CIDBG==1
        //
        // This index must not already exist in the list.
        //
        CIndexId iid = pIndexNew->GetId();
        Win4Assert( 0 == LokGetIndex( iid ) && "Adding Duplicate Index" );
#endif  // CIDBG==1

        _idxlst.Add ( pIndexNew );
    }

    _changes.LokRemoveIndexes ( xact, cInd, aIidOld );
}

//+---------------------------------------------------------------------------
//
//  Function:   LokQueryMMergeIndexes
//
//  Synopsis:   Gets the list on indexes participating in the master merge
//              based on the list of indexes stored in the master merge log.
//
//  Arguments:  [count]    --  Will have the number of participating
//              indexes.
//              [objMMLog] --  The Recoverable Storage Object for the master
//              merge log.
//
//  History:    4-01-94   srikants   Created
//
//  Notes:      The indexes are NOT reference counted here because they
//              are expected to have been reference counted during startup.
//
//----------------------------------------------------------------------------

CIndex ** CPartition::LokQueryMMergeIndexes( unsigned & count,
                                        PRcovStorageObj & objMMLog )
{

    //
    // Iterator for the master log.
    //
    CMMergeIdxListIter iterMMLog( objMMLog );
    count = iterMMLog.Count();
    Win4Assert( 0 != count );

    CIndex** indexes = new CIndex* [ count ];
    SByteArray sapIndex(indexes);

    ULONG cIndSoFar = 0;

    for ( CForIndexIter iter(_idxlst) ;
          !_idxlst.AtEnd(iter); _idxlst.Advance(iter) )
    {
        CIndexId iid = iter->GetId();
        if ( iid.IsPersistent() && iterMMLog.Found( iid) )
        {
            ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "%lx, ",
                iter->GetId() ));
            Win4Assert ( !iter->IsZombie() );
            indexes[cIndSoFar++] = iter.GetIndex();
            iter->Reference();
            iter->SetInMasterMerge();
        }

    }

    Win4Assert( cIndSoFar == count );
    sapIndex.Acquire();

    return(indexes);
}

void CPartition::SerializeMMergeIndexes( unsigned count,
        const CIndex * aIndexes[], PRcovStorageObj & objMMLog )
{

    CNewMMergeLog   mmLog ( objMMLog );

    for ( unsigned i = 0; i < count; i++ )
    {
        const CIndex * pIndex = aIndexes[i];
        Win4Assert( pIndex->IsPersistent() );

        CIndexId iid(pIndex->GetId());
        mmLog.AddPersistentIndex( iid );
    }

    mmLog.Commit();

}


//+---------------------------------------------------------------------------
//
//  Member:     CPartition::GetCurrentMasterIndex, public
//
//  Synopsis:   Returns the current master index for this partition.
//
//  History:    13-Apr-94   DwightKr       Created.
//
//----------------------------------------------------------------------------
CPersIndex * CPartition::GetCurrentMasterIndex()
{
    for (CForIndexIter iter(_idxlst);
         !_idxlst.AtEnd(iter);
          _idxlst.Advance(iter)
        )
    {
        if ( iter->IsMaster() )
        {
            Win4Assert( iter->IsPersistent() );
            return (CPersIndex*) iter.GetIndex();
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPartition::LokZombify, public
//
//  Synopsis:   Zombify all indexes, and delete the MMlog, if any.  Ownership
//              of the indexes is transferred to the caller.
//
//  History:    13-Apr-94   DwightKr       Created.
//
//----------------------------------------------------------------------------
CIndex ** CPartition::LokZombify(unsigned & cInd )
{
    //
    //  Get list of current indexes
    //
    CIndex ** paIndex = new CIndex *[ _idxlst.Count() ];
    cInd = LokGetIndexes( paIndex );


    //
    //  Zombify each index, and remove it from the in-memory index list
    //
    for (unsigned i=0; i<cInd; i++)
    {
        paIndex[i]->Zombify();
       _idxlst.Remove( paIndex[i]->GetId() );
    }

    return paIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\pcomp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       PComp.cxx
//
//  Contents:   Persistent index compressor, decompressor
//
//  Classes:    CCoder, CKeyComp, CPersComp
//
//  History:    05-Jul-91       KyleP           Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#pragma optimize( "t", on )

#include "pcomp.hxx"
#include "bitstm.hxx"

const unsigned short NoKey = 0xffff;

const unsigned OccCountBits = 3;        // Bits to initially store for
                                        //  an occurrence count.

const unsigned cPidBits = 4;

//+---------------------------------------------------------------------------
//
//  Member:     CCoder::CCoder, public
//
//  Synopsis:   Creates a coder
//
//  Arguments:  [widMax] -- The maximum workid in this index
//
//  History:    05-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CCoder::CCoder ( WORKID widMax)
:_widMaximum(widMax),
    _wid(0),
    _occ(0)
{
    _key.SetCount(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCoder::CCoder, public
//
//  Synopsis:   Creates a coder
//
//  Arguments:  [widMax] -- The maximum workid in this index
//              [keyInit] -- initial key
//
//  History:    26-Aug-92   BartoszM       Created.
//
//----------------------------------------------------------------------------

CCoder::CCoder ( WORKID widMax, const CKeyBuf& keyInit)
:_widMaximum(widMax),
    _wid(0),
    _occ(0),
    _key(keyInit)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCoder::CCoder, public
//
//  Synopsis:   Copy Constructor
//
//  Arguments:  [coder] -- The original CCoder that is being copied.
//
//  History:    15-Jan-92   AmyA           Created.
//
//----------------------------------------------------------------------------

CCoder::CCoder ( CCoder &coder)
         :_key(coder._key),
          _widMaximum(coder._widMaximum),
          _wid(coder._wid),
          _occ(coder._occ),
          _cbitAverageWid(coder._cbitAverageWid)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CCoder::~CCoder, public
//
//  History:    05-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CCoder::~CCoder ( )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyComp::CKeyComp, public
//
//  Synopsis:   Creates a new (empty) key compressor.
//
//  Arguments:  [phIndex] -- physical index
//
//              [widMax] -- The maximum workid which may be stored via
//                          PutWorkId.
//
//  History:    13-Nov-93   w-PatG       Created.
//
//----------------------------------------------------------------------------

CKeyComp::CKeyComp( CPhysIndex& phIndex,
                    WORKID widMax,
                    BOOL fUseLinks )

:   CCoder( widMax ),
    _sigKeyComp(eSigKeyComp),
    _phIndex(phIndex),
    _bitStream ( phIndex ),
    _fUseLinks( fUseLinks ),
    _bitStreamLink(phIndex),
    _fWriteFirstKeyFull(FALSE)
{
    _bitOffCurKey.Init(0,0);
    _bitOffLastKey.Init(0,0);
}

//+---------------------------------------------------------------------------
//
//  Function:   CKeyComp
//
//  Synopsis:   Constructor used for creating a key compressor during a
//              restarted master merge. It has the ability to open an
//              existing index stream, seek to the specified point after
//              which new keys are to be added and zero-fill fromt the
//              starting point to the end of the page. Subsequent pages
//              are automatically zero-filled when they are loaded.
//
//  Arguments:  [phIndex]        --  The physindex to which new keys are
//              going to be added
//              [widMax]         --  Maximum wid in the index.
//              [bitoffRestart]  --  BitOffset indicating where the new
//              keys will be added.
//              [bitoffSplitKey] --  BitOffset of the last key written
//              successfully to the disk completely. It is assumed that
//              there will be no need to even fix up the forward links.
//              [splitKey]       --  The key which was written last.
//              [fUseLinks]      --  Flag indicating if forward links should
//              be used or not.
//
//  History:    4-10-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CKeyComp::CKeyComp( CPhysIndex& phIndex,
                    WORKID widMax,
                    const BitOffset & bitoffRestart,
                    const BitOffset & bitoffSplitKey,
                    const CKeyBuf & splitKey,
                    BOOL fUseLinks )

:   CCoder( widMax ),
    _sigKeyComp(eSigKeyComp),
    _phIndex(phIndex),
    _bitStream ( phIndex, bitoffRestart, FALSE ),
    _fUseLinks( fUseLinks ),
    _bitStreamLink(phIndex),
    _fWriteFirstKeyFull(FALSE)
{
    //
    // Zero fill everything after the current position to the end of the
    // page.
    //
    ZeroToEndOfPage();

    // Write the signature
    InitSignature();
    _bitOffCurKey.Init(0,0);
    _bitOffLastKey.Init(0,0);

    //
    // Position to the place from where new keys must be written.
    //
#if CIDBG == 1
    BitOffset bitOffCurr;
    GetOffset(bitOffCurr);
    Win4Assert( bitoffRestart.Page() == bitOffCurr.Page() &&
                bitoffRestart.Offset() == bitOffCurr.Offset() );
//    _bitStream.Seek(bitoffRestart);
#endif  // CIDBG

    //
    // If we are restarting and the split key is not the "MinKey"
    // then we must remember the split key as the "previous key".
    // If the split key is "MinKey", then we are starting from
    // beginning.
    //
    _key = splitKey;

    if ( _fUseLinks ) {
        //
        // Initialize the forward link tracker.
        //
        _bitStreamLink.Seek(bitoffSplitKey);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CKeyComp::~CKeyComp, public
//
//  Synopsis:   Destroy a compressor/buffer pair.
//
//  Effects:    The main effect of destroying a compressor is that the
//              associated buffer is also destroyed (presumably storing
//              the data to a persistent medium).
//
//  Signals:    ???
//
//  History:    05-Jul-91   KyleP       Created.
//              13-Nov-93   w-PatG      Converted from CPersComp to CKeyComp
//
//  Notes:      Previous compressor is deleted in PutKey
//
//----------------------------------------------------------------------------

CKeyComp::~CKeyComp()
{
    ciDebugOut (( DEB_PCOMP,"CKeyComp::~CKeyComp() -- Last Key = %.*ws\n",
            _key.StrLen(), _key.GetStr() ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyComp::PutKey, public
//
//  Synopsis:   Starts recording data for a new key.
//
//  Arguments:  [key] -- The new key.
//
//              [bitOff] -- (out) actual bit offset of the key in the index
//
//  History:    05-Jul-91   KyleP       Created.
//              22-Nov-93   w-PatG      Converted from CPersComp.
//
//  Notes:      The structure for each key is:
//                  Prefix/Suffix size
//                  Suffix
//                  Property ID  (Actually the key id)
//
//----------------------------------------------------------------------------

void CKeyComp::PutKey(const CKeyBuf * pkey,
                      BitOffset & bitOffCurKey)
{
    //Debug message broken into two pieces due to use of static buffer
    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,
        "\"%.*ws\"", pkey->StrLen(), pkey->GetStr() ));

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,
        " after \"%.*ws\"", _key.StrLen(), _key.GetStr() ));

    Win4Assert(pkey->Count() != 0 );
    Win4Assert((_key.Count() == 0) || Compare(&_key, pkey) < 0);
    Win4Assert(pkey->Pid() != pidAll);
    Win4Assert(pkey->Pid() != pidInvalid);

    // record the offset now.
    // for use by the directory

    _bitStream.GetOffset ( _bitOffCurKey );
    bitOffCurKey = _bitOffCurKey;

    if ( _fUseLinks )
    {
        // Get offset of previous key (the link stream is there)
        _bitStreamLink.GetOffset (_bitOffLastKey);

        // store the link data
        ULONG DeltaValue = bitOffCurKey.Delta(_bitOffLastKey);
        ciDebugOut (( 0x02000000, "@@@@ Delta : %lu @@@@\n", DeltaValue ));
        // check whether the size of whole persistent index exceed the maximum limit
        if ( DeltaValue >= LINK_MAX_VALUE ) {
           ciDebugOut (( 0x01000000 | DEB_PCOMP | DEB_NOCOMPNAME,
                         "\n@@@@ Key : \"%.*ws\" Exceed the MAX SIZE : %lu\n",
                         _key.StrLen(), _key.GetStr(), DeltaValue ));
           DeltaValue = 0;
        }
        _bitStreamLink.OverwriteBits( DeltaValue, LINK_MAX_BITS );

        // reposition the link stream
        _bitStreamLink.Seek ( bitOffCurKey );

        // save space for the link
        _bitStream.PutBits ( 0, LINK_MAX_BITS );
    }

    //
    //  If we need to write the FIRST key on each page in its entirety,
    //  and we have crossed a page boundary, then set the prefix to 0,
    //  which forces the key to be written in its entirety.
    //
    unsigned  cPrefix = 0;
    if ( _fWriteFirstKeyFull &&
         ( _bitOffCurKey.Page() != _bitOffLastKey.Page()) )
    {
        //
        //  If we're not using links, then we haven't been tracking the
        //  bit offset of the last key.  Do it here.
        //
        if ( !_fUseLinks )
        {
            _bitOffLastKey = _bitOffCurKey;
        }
    }
    else
    {
        unsigned mincb = __min(_key.Count(), pkey->Count());

        for (cPrefix = 0; cPrefix < mincb; cPrefix++)
            if ((_key.GetBuf())[cPrefix] != (pkey->GetBuf())[cPrefix])
                break;
    }

    unsigned  cSuffix = pkey->Count() - cPrefix;

    PutPSSize ( cPrefix, cSuffix );

    //
    // Store the suffix.
    //

    _bitStream.PutBytes( pkey->GetBuf() + cPrefix, cSuffix);

    PutPid ( pkey->Pid() );

    //
    // Copy the piece of key that changed.
    //

    memcpy(_key.GetWritableBuf() + cPrefix, pkey->GetBuf() + cPrefix, cSuffix);
    _key.SetCount( pkey->Count() );
    _key.SetPid ( pkey->Pid() );

}


//+---------------------------------------------------------------------------
//
//  Member:     CKeyComp::IBitCompress, private
//
//  Synopsis:   Compress and store a number.
//
//  Arguments:  [ul] -- Number to store.
//
//              [cbitAverage] -- Minimum number of bits to store.
//
//  Algorithm:  First, store the bottom cbitAverage bits.
//              while there are more bits to store
//                  store a 1 bit indicating more to follow
//                  store the next n bits, where n = 2, 3, 4, ...
//              store a 0 bit indicating end of sequence
//
//  History:    08-Jul-91   KyleP       Created.
//              06-Dec-93   w-PatG      Moved from CPersComp.
//
//----------------------------------------------------------------------------

void CKeyComp::IBitCompress(ULONG ul, unsigned cbitAverage, unsigned bitSize)
{
    //
    // Figure out the size of the 'hole' after the last bits are
    // written out and add 0 bits at the high end so that the
    // last putbits really stores exactly the remaining bits.
    // (Right pad the number)
    //

    int   cbitToStore;
    int   cbitPadding = (int)(bitSize - cbitAverage);

    for (cbitToStore = 2; cbitPadding > 0; cbitToStore++)
        cbitPadding -= cbitToStore;

    Win4Assert(cbitPadding >= -cbitToStore);

    cbitPadding = -cbitPadding;
    bitSize += cbitPadding;

    //
    // Store the bits a dword at a time for efficiency. They are kept
    // in ultmp until they are stored. cbitTmp is the count of valid bits
    // in ulTmp. ibitValid is the highest unstored bit.
    //

    int   ibitValid;
    ULONG ulTmp;
    unsigned  cbitTmp;

    ibitValid = bitSize;
    Win4Assert( (ibitValid - cbitAverage) < ULONG_BITS );
    ulTmp = ul >> (ibitValid - cbitAverage);
    cbitTmp = cbitAverage;

    ibitValid -= cbitAverage;

    bitSize -= cbitAverage;

    //
    // Now store the cbitAverage bits and the
    // remaining bits, 2, 3, 4, ... at a time
    //

    for (cbitToStore = 2; ibitValid > 0; cbitToStore++)
    {
        //
        // If there isn't enough space left in the DWord, then
        // write it out and start a new one.
        //

        if (cbitTmp + cbitToStore + 1 > ULONG_BITS)
        {
            _bitStream.PutBits(ulTmp, cbitTmp);
            ulTmp = 0;
            cbitTmp = 0;
        }

        //
        // Store a continuation bit
        //

        ulTmp = (ulTmp << 1) | 1;
        cbitTmp++;

        //
        // Store the next top 2, 3, ... bits
        //

        Win4Assert( cbitToStore < ULONG_BITS );
        Win4Assert( (ibitValid - cbitToStore) < ULONG_BITS );

        ulTmp = (ulTmp << cbitToStore) |
            (ul >> (ibitValid - cbitToStore)) &
                ~(0xffffffffL << cbitToStore);

        ibitValid -= cbitToStore;
        cbitTmp += cbitToStore;

        Win4Assert(ibitValid >= 0);      // Loop should terminate w/
                                       // ibitValid == 0
    }

    //
    // Write out the final termination bit (0).
    //

    if (cbitTmp == ULONG_BITS)
    {
        _bitStream.PutBits(ulTmp, cbitTmp);
        ulTmp = 0;
        cbitTmp = 0;
    }

    ulTmp <<= 1;

    _bitStream.PutBits(ulTmp, cbitTmp + 1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyComp::PutPSSize, private
//
//  Synopsis:   Writes key prefix and suffix sizes
//
//  Arguments:  [cPrefix] -- size of prefix
//              [cSuffix] -- size of suffix
//
//  History:    06-Nov-91   BartoszM       Created.
//              22-Nov-93   w-PatG         Moved from CPersComp to CKeyComp
//
//  Notes:
//      Store the prefix/suffix size followed by the suffix. If both
//      the prefix and suffix fit in 4 bits each then store each as
//      4 bits, else store a 0 byte followed by a 8 bits each for
//      prefix and suffix.
//
//----------------------------------------------------------------------------

inline void CKeyComp::PutPSSize ( unsigned cPrefix, unsigned cSuffix )
{
    Win4Assert ( cPrefix + cSuffix != 0 );


    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,
        "\n(%d:%d) ", cPrefix, cSuffix ));

    if ((cPrefix <= 0xF) && (cSuffix <= 0xF))
    {
        _bitStream.PutBits((cPrefix << 4) | cSuffix, 8);
    }
    else
    {
        Win4Assert((cPrefix < 256) && (cSuffix < 256));
        Win4Assert(cPrefix + cSuffix <= MAXKEYSIZE );
        _bitStream.PutBits((cPrefix << 8) | cSuffix, 8 + 16);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyComp::PutPid, private
//
//  Synopsis:   Writes Property ID
//
//  Arguments:  [pid] -- property id
//
//  History:    06-Nov-91   BartoszM       Created.
//              22-Nov-93   w-PatG         Moved from CPersComp to CKeyComp
//
//----------------------------------------------------------------------------

inline void CKeyComp::PutPid ( PROPID pid )
{
    //
    // Just store a 0 bit if contents, else
    // a 1 followed by ULONG propid.
    //

    if ( pid == pidContents)
    {
        _bitStream.PutBits(0, 1);
    }
    else
    {
        ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,
            " =PID %d= ", pid ));

        _bitStream.PutBits(1, 1);
        BitCompress ( pid, cPidBits );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::CKeyDeComp, public
//
//  Synopsis:   Creates a new persistent decompressor
//              at the beginning of an index
//
//  Arguments:  [iid] -- index id
//              [phIndex] -- physical index
//              [widMax] -- Maximum workid which may be in the buffer.
//                          This must be the same number was was used
//                          during compression.
//
//  History:    12-Jul-91   KyleP       Created.
//              21-Apr-92   BartoszM    Split into two constructors
//              30-Nov-93   w-PatG      Converted from CPersDeComp
//              10-Apr-94   SrikantS    Adapted to not use the directory
//                                      because it may not exist during a
//                                      restarted master merge.
//
//  Notes:      Some of the arguments passed in may later be deemed to be
//              unnecessary.  Some may be converted to different purposes at a
//              later date.
//----------------------------------------------------------------------------

CKeyDeComp::CKeyDeComp( PDirectory& pDir,
                        INDEXID iid,
                        CPhysIndex& phIndex,
                        WORKID widMax,
                        BOOL fUseLinks,
                        BOOL fUseDir )
: CCoder ( widMax ),
  CKeyCursor (iid, widMax),
  _sigKeyDeComp(eSigKeyDeComp),
  _bitStream ( phIndex ),
  _fUseLinks( fUseLinks ),
  _pDir( pDir ),
  _fUseDir( fUseDir ),
  _fAtSentinel( FALSE ),
  _physIndex ( phIndex )
#if (CIDBG == 1)
 ,_fLastKeyFromDir( FALSE )
#endif
{
    LoadKey();
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::CKeyDeComp, public
//
//  Synopsis:   Creates a new persistent decompressor.
//              positioned at a specified key
//
//  Arguments:  [iid] -- index id
//              [phIndex] -- physical index
//              [keyPos] -- bit offset to key stored in directory
//              [keyInit] -- initial key
//              [pKey]   -- actual key to search for
//              [widMax] -- Maximum workid which may be in the buffer.
//                          This must be the same number was was used
//                          during compression.
//
//  History:    12-Jul-91   KyleP       Created.
//              21-Apr-92   BartoszM    Split into two constructors
//              30-Nov-93   w-PatG      Converted from CPersDeComp
//
//----------------------------------------------------------------------------

CKeyDeComp::CKeyDeComp( PDirectory& pDir,
                        INDEXID iid,
                        CPhysIndex& phIndex,
                        BitOffset& keyPos,
                        const CKeyBuf& keyInit,
                        const CKey* pKey,
                        WORKID widMax,
                        BOOL fUseLinks,
                        BOOL fUseDir  )
: CCoder ( widMax, keyInit ),
  CKeyCursor (iid, widMax),
  _sigKeyDeComp(eSigKeyDeComp),
  _bitStream( phIndex, keyPos ),
  _fUseLinks( fUseLinks ),
  _pDir( pDir ),
  _fUseDir( fUseDir ),
  _fAtSentinel( FALSE ),
  _physIndex ( phIndex )
#if (CIDBG == 1)
 ,_fLastKeyFromDir( FALSE )
#endif
{
    Win4Assert(pKey);

    LoadKey();

    SeekKey( pKey);
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::CKeyDeComp, public
//
//  Synopsis:   Copy Constructor
//
//  Effects:    Copies most of the values in decomp.  Calls copy constructor
//              for CCoder.
//
//  Arguments:  [decomp] -- Original CKeyDeComp to be copied.
//
//  History:    08-Jan-92   AmyA        Created.
//              07-Dec-93   w-PatG      Stole from CPersDeComp.
//
//----------------------------------------------------------------------------

CKeyDeComp::CKeyDeComp(CKeyDeComp & decomp)
  : CCoder (decomp),
    CKeyCursor(decomp),
    _sigKeyDeComp(eSigKeyDeComp),
    _bitStream(decomp._bitStream),
    _fUseLinks( decomp._fUseLinks ),
    _bitOffNextKey(decomp._bitOffNextKey),
    _pDir( decomp._pDir ),
    _fUseDir( decomp._fUseDir ),
    _fAtSentinel( decomp._fAtSentinel ),
    _physIndex(decomp._physIndex)
#if (CIDBG == 1)
   ,_fLastKeyFromDir( decomp._fLastKeyFromDir )
#endif
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::~CKeyDeComp, public
//
//  Synopsis:   Destroy a decompressor/buffer pair.
//
//  Effects:    The main effect of destroying a decompressor is that the
//              associated buffer is also destroyed (presumably storing
//              the data to a persistent medium).
//
//  Signals:    ???
//
//  History:    30-Nov-93   w-PatG       Created.
//
//----------------------------------------------------------------------------

CKeyDeComp::~CKeyDeComp()
{}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::GetKey, public
//
//  Synopsis:   Retrieves the current key.
//
//  Returns:    A pointer to the current key. If at the end of page or
//              end of index, returns null.
//
//  History:    15-Jul-91   KyleP       Created.
//              30-Nov-93   w-PatG      Moved from CPersDeComp.
//
//----------------------------------------------------------------------------

const CKeyBuf * CKeyDeComp::GetKey( BitOffset * pBitOff )
{
    if ( IsAtSentinel() )
        return(0);

    if ( pBitOff )
        GetOffset( *pBitOff );

    return(&_key);
}


const CKeyBuf * CKeyDeComp::GetKey()
{
    if ( IsAtSentinel() )
        return(0);

    return(&_key);
}


//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::GetNextKey, public
//
//  Synopsis:   Retrieve the next key from the content index.
//
//  Arguments:  [pBitOff] -- optional, will have the offset of the beginning
//              of the key.
//
//  Returns:    A pointer to the key, or 0 if end of page/index reached.
//
//  History:    15-Jul-91   KyleP       Created.
//              30-Nov-93   w-PatG      Converted from CPersDeComp.
//              10-Apr-94   SrikantS    Added pBitOff as an optional param.
//
//----------------------------------------------------------------------------

const CKeyBuf * CKeyDeComp::GetNextKey( BitOffset * pBitOff )
{

    if ( _fUseLinks )
    {
        if ( !_bitOffNextKey.Valid() )
        {
           Win4Assert( _fUseDir );
           _pDir.SeekNext( _key, 0, _bitOffNextKey );
           Win4Assert( _bitOffNextKey.Valid() );

           ciDebugOut (( 0x01000000 | DEB_PCOMP | DEB_NOCOMPNAME, "*** Result : Page %lu OffSet %lu\n",
                         _bitOffNextKey.Page(), _bitOffNextKey.Offset() ));
#if (CIDBG == 1)
            _fLastKeyFromDir = TRUE;
#endif // CIDBG == 1

        }
        _bitStream.Seek ( _bitOffNextKey );
    }

    if ( pBitOff )
    {
        _bitStream.GetOffset( *pBitOff );
    }

    LoadKey();

    const CKeyBuf * pkey = GetKey();

    return(pkey);
}

const CKeyBuf * CKeyDeComp::GetNextKey()
{
    return GetNextKey( 0 );
}

void CKeyDeComp::GetOffset( BitOffset & bitOff )
{
    _bitStream.GetOffset( bitOff );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::SeekKey, private
//
//  Synopsis:   Seek in the decompressor
//
//  Arguments:  [pkey] -- Key to search for.
//
//              [op] -- Seek equality operation (EQ, GE, etc.)
//
//  Returns:    A pointer to the key to cursor is actually on. This may
//              be = or > [pkey].
//
//  History:    26-Apr-91       KyleP       Created.
//              25-Aug-92       BartoszM        Moved to CPersDecomp
//              30-Nov-93       w-PatG          Moved to CKeyDeComp
//
//----------------------------------------------------------------------------

const CKeyBuf * CKeyDeComp::SeekKey(const CKey * pKeySearch)
{
    //
    // Find the key >= the specified key.
    //

    const CKeyBuf* pKeyFound = GetKey();

    while (pKeyFound != 0)
    {
        //----------------------------------------------------
        // Notice: Make sure that pidAll is smaller
        // than any other legal PID. If the search key
        // has pidAll we want to be positioned at the beginning
        // of the range.
        //----------------------------------------------------

        Win4Assert ( pidAll == 0 );

        // skip keys less than the search key
        if ( pKeySearch->Compare(*pKeyFound) > 0)
        {
            pKeyFound = GetNextKey();
        }
        else
            break;
    }
    return(pKeyFound);
}

void CPersDeComp::RatioFinished (ULONG& denom, ULONG& num)
{
    denom = _cWid;
    Win4Assert ( _cWid >= _cWidLeft );
    num = _cWid - _cWidLeft;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::BitUnCompress, private
//
//  Synopsis:   Uncompress a number
//
//  Arguments:  [cbitAverage] -- Minimum number of bits to store.
//
//  History:    15-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

__forceinline ULONG CKeyDeComp::BitUnCompress( unsigned cbitAverage)
{
    //
    // Get the initial count plus a stop bit.
    //

    Win4Assert( cbitAverage < ULONG_BITS );


    ULONG ul = _bitStream.GetBits(cbitAverage + 1);

    //
    // Simple case: The number fits in the original cbitAverage bits
    //              (e.g. the stop bit is 0).
    //              No additional processing necessary.
    //
    // Complex:     Retrieve additional components.
    //

    if ((ul & 1) == 0)
        return(ul >> 1);

    return IBitUnCompress ( cbitAverage, ul );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::IBitUnCompress, private
//
//  Synopsis:   Uncompress a number
//
//  Arguments:  [cbitAverage] -- Minimum number of bits to store.
//
//  History:    15-Jul-91   KyleP       Created.
//              06-Dec-93   w-PatG      Moved from CPersDeComp.
//
//----------------------------------------------------------------------------

ULONG CKeyDeComp::IBitUnCompress( unsigned cbitAverage, ULONG ul)
{

    Win4Assert ( ul & 1 );

    int BitsToGetPlus1 = 3;

    do
    {
        //
        // Kill the stop bit.
        //

        ul >>= 1;

        //
        // Get the next component and its stop bit.
        //

        ULONG ulPartial  = _bitStream.GetBits(BitsToGetPlus1);

        Win4Assert( BitsToGetPlus1 < ULONG_BITS );

        ul = (ul << BitsToGetPlus1) | ulPartial;

        BitsToGetPlus1++;
    }
    while (ul & 1);

    ul >>= 1;
    return(ul);
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::LoadKey, private
//
//  Synopsis:   Loads data for the next key.
//
//  Effects:    Reads a key from the current position in _bitStream and
//              sets per key state.
//
//  Signals:    ???
//
//  History:    12-Jul-91   KyleP       Created.
//              06-Dec-93   w-PatG      Modified from CPersDeComp.
//
//----------------------------------------------------------------------------

void CKeyDeComp::LoadKey()
{

    ULONG TmpValue;

    if ( _fUseLinks )
    {
        _bitStream.GetOffset ( _bitOffNextKey );
        TmpValue = _bitStream.GetBits ( LINK_MAX_BITS );
    }

    //
    // Retrieve the prefix/suffix. Assume they are stored in 4 bits each
    // first.
    //

    unsigned cPrefix, cSuffix;

    LoadPSSize ( cPrefix, cSuffix );

    //
    // Load the key itself.
    //

#if CIDBG == 1
    if ( _fLastKeyFromDir )
    {
        //
        // We know what the key should be.  Compute prefix and
        // suffix.  Make sure they match.
        //

        unsigned mincb = __min( _key.Count(), _pDir.GetLastKey().Count() );

        for (unsigned cOldPrefix = 0; cOldPrefix < mincb; cOldPrefix++)
        {
            if ( (_key.GetBuf())[cOldPrefix] !=
                 (_pDir.GetLastKey().GetBuf())[cOldPrefix] )
                break;
        }

        unsigned cOldSuffix = _pDir.GetLastKey().Count() - cOldPrefix;

        if ( (0 != cPrefix) && (cPrefix != cOldPrefix || cSuffix != cOldSuffix) )
        {
            ciDebugOut(( DEB_ERROR, "Corrupt index or directory!\n" ));
            ciDebugOut(( DEB_ERROR, "From index: cPrefix = %d, cSuffix = %d\n",
                         cPrefix, cSuffix ));
            ciDebugOut(( DEB_ERROR, "From directory: cPrefix = %d, cSuffix = %d\n",
                         cOldPrefix, cOldSuffix ));
            Win4Assert( !"Corrupt index or directory" );
        }

        _fLastKeyFromDir = FALSE;
    }
#endif // CIDBG == 1

    if ( 0 == ( cPrefix + cSuffix ) )
    {
        //
        // Disabled asserts prior to widespread Query rollout in NT 5, so
        // that the general NT user is not bothered by this asserts.
        //
        //Win4Assert ( "Data corruption" && cPrefix + cSuffix != 0 );

        PStorage & storage = _physIndex.GetStorage();
        storage.ReportCorruptComponent( L"KeyDecompressor1" );
        THROW( CException( CI_CORRUPT_DATABASE) );
    }

    if ( cPrefix > _key.Count() )
    {
        //
        // Disabled asserts prior to widespread Query rollout in NT 5, so
        // that the general NT user is not bothered by this asserts.
        //
        //Win4Assert ( "Data corruption" && cPrefix <= _key.Count() );

        PStorage & storage = _physIndex.GetStorage();
        storage.ReportCorruptComponent( L"KeyDecompressor2" );
        THROW( CException( CI_CORRUPT_DATABASE) );
    }

    _bitStream.GetBytes(_key.GetWritableBuf() + cPrefix, cSuffix);

    _key.SetCount( cPrefix + cSuffix );

    if ( _key.IsMaxKey() )
    {
        ciDebugOut (( DEB_ITRACE, "\n<<Sentinel key>>\n" ));
        _fAtSentinel = TRUE;
        return;
    }

#if CIDBG == 1

//
// This it to test the directory-index interaction when things go wrong. Don't delete
// this code before talking with Dwight/SrikantS/KyleP.
//
#if 0
    {
        iidDebug = 0x10002;             //  Looking for this index
        WCHAR wcsDebugKey[] = L"TRUE";  //  Looking for this key

        unsigned lenDebug = min( wcslen( wcsDebugKey ), _key.StrLen() );

        //
        // If the key we are looking for is found in the desired index, break and
        // step through the code to see what is going on.
        //
        if ( iidDebug == _iid && 0 == _wcsnicmp( _key.GetStr(), wcsDebugKey , lenDebug ) )
        {
            Win4Assert( !"Only during baby-sitting mode" );
        }

    }
#endif  // 1

#endif  // CIDBG==1
    //
    // Load the property ID.
    //

    //
    // Store a 0 bit if contents, else
    // a 1 followed by ULONG propid.
    //

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,
        "\"%.*ws\" ", _key.StrLen(),_key.GetStr()));

    LoadPid();

    // continue to set _bitOffNextKey
    if ( _fUseLinks )
    {
        if ( TmpValue == 0 )
        {
           // the size of the current index must exceed the
           // max. limit. Use CI Directory to search the next key
           // position
           ciDebugOut (( 0x01000000, "\n*** Key : \"%.*ws\"\n",_key.StrLen(), _key.GetStr() ));
           ciDebugOut (( 0x01000000 | DEB_PCOMP | DEB_NOCOMPNAME, "\n\t*** Start search next key's offset\n" ));
           _bitOffNextKey.SetInvalid();

        }
        else
        {
           _bitOffNextKey += TmpValue;
           ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME, "\n\t$$$ Next key : Page %lu OffSet %lu\n",
                         _bitOffNextKey.Page(), _bitOffNextKey.Offset() ));
        }
    }


}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::LoadPSSize, private
//
//  Synopsis:   Load key prefix and suffix sizes
//
//  Arguments:  [cPrefix] -- (return) prefix size
//              [cSuffix] -- (return) suffix size
//
//  History:    05-Nov-91   BartoszM       Created.
//              30-Nov-93   w-PatG         Moved from CPersDeComp.
//
//----------------------------------------------------------------------------

inline void CKeyDeComp::LoadPSSize ( unsigned& cPrefix, unsigned& cSuffix )
{
    ULONG ul = _bitStream.GetBits(8);

    if (ul != 0)           // 4 bits for prefix and suffix
    {
        cPrefix = (unsigned)ul >> 4;
        cSuffix = (unsigned)ul & 0xF;
    }
    else                   // 8 bits for prefix and suffix
    {
        ul = _bitStream.GetBits(16);

        cPrefix = (unsigned)ul >> 8;
        cSuffix = (unsigned)ul & 0xFF;
    }

    Win4Assert(cPrefix + cSuffix <= MAXKEYSIZE );
    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,
        "\n(%d:%d) ", cPrefix, cSuffix));
}

//+---------------------------------------------------------------------------
//
//  Member:     CKeyDeComp::LoadPid, private
//
//  Synopsis:   Load property id
//
//  History:    05-Nov-91   BartoszM       Created.
//              06-Dec-93   w-PatG         Moved from CPersDeComp.
//
//  Notes:      The Property id is used for different purposes in CKeyDeComp
//              and CPersDeComp.  In CKeyDeComp, a PROPID is actually a key id.
//
//----------------------------------------------------------------------------

__forceinline void CKeyDeComp::LoadPid ()
{
    ULONG ul = _bitStream.GetBits(1);

    if (ul == 0)
    {
        _key.SetPid(pidContents);
    }
    else
    {
        ul = BitUnCompress ( cPidBits );
        _key.SetPid (ul);
    }
#if CIDBG == 1
    if (ul != 0)
        ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME," =PID %d= ", ul ));
#endif
}

//
// Unused, but required for inheritance.
//

OCCURRENCE CKeyDeComp::Occurrence()
{
    Win4Assert( !"CKeyDeComp::Occurrence() -- invalid call" );
    return( 0 );
}

OCCURRENCE CKeyDeComp::NextOccurrence()
{
    Win4Assert( !"CKeyDeComp::NextOccurrence() -- invalid call" );
    return( 0 );
}

ULONG CKeyDeComp::OccurrenceCount()
{
    Win4Assert( !"CKeyDeComp::OccurrenceCount() -- invalid call" );
    return( 0 );
}

OCCURRENCE CKeyDeComp::MaxOccurrence()
{
    Win4Assert( !"CKeyDeComp::MaxOccurrence() -- invalid call" );
    return( 1 );
}



WORKID CKeyDeComp::WorkId()
{
    Win4Assert( !"CKeyDeComp::WorkId() -- invalid call" );
    return( 0 );
}

WORKID CKeyDeComp::NextWorkId()
{
    Win4Assert( !"CKeyDeComp::NextWorkId() -- invalid call" );
    return( 0 );
}

ULONG CKeyDeComp::HitCount()
{
    Win4Assert( !"CKeyDeComp::HitCount() -- invalid call" );
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::CPersComp, public
//
//  Synopsis:   Creates a new (empty) persistent compressor.
//
//  Arguments:  [phIndex] -- physical index
//
//              [widMax] -- The maximum workid which may be stored via
//                          PutWorkId.
//
//  History:    05-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CPersComp::CPersComp(
        CPhysIndex& phIndex,
        WORKID widMax)

:   CKeyComp( phIndex, widMax ),
    _sigPersComp(eSigPersComp),
    _cWidProposed(0),
    _cWidActual(0),
    _bitStreamPatch ( phIndex )
{
#if CIDBG == 1
    _cOccLeft = 0;
#endif // CIDBG == 1
}

//+---------------------------------------------------------------------------
//
//  Function:   CPersComp::CPersComp
//
//  Synopsis:   Constructor for the persistent compressor capable of dealing
//              with a partially constructed index stream during a restarted
//              master merge.
//
//  Arguments:  [phIndex]        -- The physical index being constructed
//              during a restarted master merge.
//              [widMax]         -- Maximum wid for the index.
//              [bitOffRestart]  -- Offset where to restart adding new
//              keys.
//              [bitOffSplitKey] -- Beginning offset of the last key added.
//              If no keys added, set to 0,0.
//              [splitKey]       -- The key last successfully written to
//              disk (split key). If there is no key, set it to "MinKey".
//
//  History:    4-10-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CPersComp::CPersComp(
        CPhysIndex& phIndex,
        WORKID widMax,
        const BitOffset & bitOffRestart,
        const BitOffset & bitOffSplitKey,
        const CKeyBuf & splitKey)

:   CKeyComp( phIndex, widMax, bitOffRestart, bitOffSplitKey, splitKey),
    _sigPersComp(eSigPersComp),
    _cWidProposed(0),
    _cWidActual(0),
    _bitStreamPatch ( phIndex )
{
#if CIDBG == 1
    _cOccLeft = 0;
#endif // CIDBG == 1
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::~CPersComp, public
//
//  Synopsis:   Destroy a compressor/buffer pair.
//
//  Effects:    The main effect of destroying a compressor is that the
//              associated buffer is also destroyed (presumably storing
//              the data to a persistent medium).
//
//  Signals:    ???
//
//  History:    05-Jul-91   KyleP       Created.
//
//  Notes:      Previous compressor is deleted in PutKey
//
//----------------------------------------------------------------------------

CPersComp::~CPersComp()
{
    ciDebugOut (( DEB_PCOMP,"CPersComp::~CPersComp() -- Last Key = %.*ws\n",
            _key.StrLen(), _key.GetStr() ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::PatchWidCount, private
//
//  Synopsis:   Overwrites wid count
//
//  History:    06-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

inline void CPersComp::PatchWidCount ()
{
    if (_cWidProposed <= 15)
    {
        _bitStreamPatch.OverwriteBits(_cWidActual, 4);
    }
    else if (_cWidProposed <= 255)
    {
        _bitStreamPatch.OverwriteBits(_cWidActual, 12);  // 4 0's + 8 bit number
    }
    else
    {
        _bitStreamPatch.OverwriteBits(0, 12);            // 12 0's
        _bitStreamPatch.OverwriteBits(_cWidActual, ULONG_BITS);  // ULONG_BITS bit number
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::PutWidCount, private
//
//  Synopsis:   Writes work id count
//
//  Arguments:  [cWorkId] -- Count of wid's
//
//  History:    06-Nov-91   BartoszM       Created.
//
//  Notes:      Store the workid count. First, store the WID count used for
//      compression. We will store a 4 bit count. If the count is
//      greater than 15 then a 4-bit 0 will be stored followed by an 8 bit
//      count. If the count is greater than 255 then a 12-bit 0 will be
//      stored followed by a ULONG_BITS bit count.
//
//----------------------------------------------------------------------------

inline void CPersComp::PutWidCount ( ULONG cWorkId )
{
    Win4Assert(cWorkId > 0);

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,
        "[%d]", cWorkId ));

    BitOffset off;

    // Position the patch stream at current offset

    _bitStream.GetOffset(off);
    _bitStreamPatch.Seek(off);

    if (cWorkId <= 15)
    {
        _bitStream.PutBits(cWorkId, 4);
    }
    else if (cWorkId <= 255)
    {
        _bitStream.PutBits(cWorkId, 12);    // 4 0's + 8 bit number
    }
    else
    {
        _bitStream.PutBits(0, 12);          // 12 0's
        _bitStream.PutBits(cWorkId, ULONG_BITS);    // ULONG_BITS bit number
    }

    //
    // Store a single bit indicating whether the count is accurrate.
    // Regardless of whether it is accurrate, it is used for encoding.
    //

    _bitStream.PutBits(1, 1);

}

//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::SkipWidCount, private
//
//  Synopsis:   Skips wid count
//
//  History:    06-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

inline void CPersComp::SkipWidCount ()
{
    unsigned posDelta;

    if (_cWidProposed <= 15)
        posDelta = 4;
    else if (_cWidProposed <= 255)
        posDelta = 12;
    else
        posDelta = 12 + ULONG_BITS;

    _bitStreamPatch.SkipBits(posDelta);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::PutKey, public
//
//  Synopsis:   Starts recording data for a new key.
//
//  Arguments:  [key] -- The new key.
//
//              [cWorkId] -- Count of work ids to follow.
//
//              [bitOff] -- (out) actual bit offset of the key in the index
//
//  History:    05-Jul-91   KyleP       Created.
//
//  Notes:      The structure for each key is:
//                  Prefix/Suffix size
//                  Suffix
//                  Property ID
//                  Work ID count
//
//----------------------------------------------------------------------------
void CPersComp::PutKey(const CKeyBuf * pkey,
                       ULONG cWorkId,
                       BitOffset & bitOffCurKey)
{

    Win4Assert(_cOccLeft == 0);
    Win4Assert(cWorkId > 0);

#if 0
    if ( ( _cWidActual == 0 ) && ( _cWidProposed != 0 ) )
    {
        BackSpace();
    }
    else
    {
#endif // 0
        //
        // Set the WorkId count accuracy bit for the previous key (if any).
        // Then reset the workid counter.
        //

        SetCWIDAccuracy();
#if 0
    }
#endif // 0

    CKeyComp::PutKey(pkey, bitOffCurKey);

    //
    // Assume that a cursor just counted a few too many workids.
    // If the final workid count is > _widMaximum that is very bad.
    //

    if ( cWorkId > _widMaximum )
        cWorkId = _widMaximum;

    PutWidCount ( cWorkId );

    //
    // Set up per/workid state
    //

    SetAverageBits ( cWorkId );
    _wid = 0;
    _cWidProposed = cWorkId;
    _cWidActual = 0;

#if CIDBG == 1
    _cOccLeft = 0;
#endif

}

//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::PutWorkId, public
//
//  Synopsis:   Store a new WorkId.
//
//  Arguments:  [wid] -- WorkId
//              [maxOcc] -- Max occurrence of wid
//              [cOccurrence] -- Count of occurrences to follow
//
//  Requires:   [wid] must be larger than the last WorkId stored in
//              the current key.
//
//  Modifies:   The input is added to the new index.
//
//  History:    08-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPersComp::PutWorkId(WORKID wid, OCCURRENCE maxOcc, ULONG cOccurrence)
{
    Win4Assert(wid != widInvalid);
    Win4Assert(wid > 0);
    Win4Assert( wid > _wid );
    Win4Assert( _cbitAverageWid > 0 );
    Win4Assert(wid <= _widMaximum);
    Win4Assert(_cOccLeft == 0);
    Win4Assert( cOccurrence > 0 );

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,"<%d>", wid ));

    //
    // Store the workid delta.
    //

    BitCompress(wid - _wid, _cbitAverageWid);

    //
    // Store the max occurrence
    //
    PutMaxOccurrence( maxOcc );

    //
    // And store the occurrence count.
    //

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,"(%d)", cOccurrence ));

    BitCompress(cOccurrence, OccCountBits);

    //
    // Update state
    //

    _wid = wid;
    _occ = 0;
    _cWidActual++;

#if CIDBG == 1
    _cOccLeft = cOccurrence;
#endif

}




//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::PutMaxOccurrence
//
//  Synopsis:   Writes the max occurrence using the same compression
//              scheme as that for writing widCount
//
//  Arguments:  [maxOcc] -- Max occurrence to write
//
//  History:    20-Jun-96   SitaramR    Created
//
//----------------------------------------------------------------------------

void CPersComp::PutMaxOccurrence( OCCURRENCE maxOcc )
{
    Win4Assert( maxOcc > 0 );

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME, "[%d]", maxOcc ));

    if ( maxOcc <= 15 )
    {
        _bitStream.PutBits( maxOcc, 4 );
    }
    else if ( maxOcc <= 255 )
    {
        _bitStream.PutBits( maxOcc, 12 );            // 4 0's + 8 bit number
    }
    else
    {
        _bitStream.PutBits( 0, 12 );                 // 12 0's
        _bitStream.PutBits( maxOcc, ULONG_BITS );    // ULONG_BITS bit number
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersComp::SetCWIDAccuracy, private
//
//  Effects:    Determines if the originally specified number of WorkIds
//              was accurate, and sets the 'accuracy' bit in the key
//              accordingly.
//
//  Modifies:   The most recent 'accuracy' bit may be changed. This may
//              be in a previous compressor or the current compressor.
//
//  History:    18-Jul-91   KyleP       Created.
//
//  Notes:      The only time additional space is needed is when we have
//              an inaccurate count which cannot be fixed up.
//
//----------------------------------------------------------------------------

void CPersComp::SetCWIDAccuracy()
{
    Win4Assert(_cWidActual <= _widMaximum);

    //
    // If the count was accurrate, then do nothing except delete the
    // previous compressor (if any). If the count is inaccurate, then
    // set the 'accuracy' bit.
    //

    if (_cWidActual != _cWidProposed)
    {

        //
        // Decide if the count can be fixed up without having to shift
        // any previously written data. This can generally be accomplished
        // if the real count is either smaller than the proposed count or
        // not too much larger *and* _cbitAverageWid remains the same.
        //

        Win4Assert ( _cWidActual <= _widMaximum );

        if ( _cWidActual != 0 &&
             _cbitAverageWid == AverageWidBits(_cWidActual) )
        {
//            ciDebugOut (( DEB_PCOMP, "fixed.\n"));

            Win4Assert(_cWidActual < _cWidProposed);

            PatchWidCount ();

        }
        else
        {

            //
            // If we can't fix the count, then just set the 'count invalid' bit.
            // And append a workid delta of 0.
            //

//            ciDebugOut (( DEB_PCOMP, "not fixed.\n"));

            //
            // Read forward over the count.
            //

            SkipWidCount ();

            //
            // And set the count invalid bit
            //

#if CIDBG == 1
            if (_bitStreamPatch.PeekBit() != 1)
            {
                Dump();
                Win4Assert ( _bitStreamPatch.PeekBit() == 1 );
            }
#endif // CIDBG == 1
            _bitStreamPatch.OverwriteBits(0, 1);

            //
            // Store the sentinel workid delta.
            //

            ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME," end "));

            BitCompress(0, _cbitAverageWid);

        }

        _cWidActual = 0;
        _cWidProposed = 0;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::CPersDeComp, public
//
//  Synopsis:   Creates a new persistent decompressor
//              at the beginning of an index
//
//  Arguments:  [iid] -- index id
//              [phIndex] -- physical index
//              [widMax] -- Maximum workid which may be in the buffer.
//                          This must be the same number was was used
//                          during compression.
//              [fUseDir] -- Flag indicating if the directory should be
//              used or not for decompressing. Normally set to FALSE but
//              during an in-progress master merge, we may not have a
//              directory constructed yet.
//
//  History:    12-Jul-91   KyleP       Created.
//              21-Apr-92   BartoszM    Split into two constructors
//              10-Apr=94   SrikantS    Added fUseDir for restarted master
//                                      merge.
//
//----------------------------------------------------------------------------

CPersDeComp::CPersDeComp(
        PDirectory& pDir,
        INDEXID iid,
        CPhysIndex& phIndex,
        WORKID widMax,
        BOOL fUseLinks,
        BOOL fUseDir )
: CKeyDeComp( pDir, iid, phIndex, widMax, fUseLinks, fUseDir ),
  _sigPersDeComp(eSigPersDeComp)
{
    FinishKeyLoad();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::CPersDeComp, public
//
//  Synopsis:   Creates a new persistent decompressor.
//              positioned at a specified key
//
//  Arguments:  [iid] -- index id
//              [phIndex] -- physical index
//              [keyPos] -- bit offset to key stored in directory
//              [keyInit] -- initial key
//              [pKey]   -- actual key to search for
//              [widMax] -- Maximum workid which may be in the buffer.
//                          This must be the same number was was used
//                          during compression.
//              [fUseDir] -- Flag indicating if the directory should be
//              used or not for decompressing. Normally set to FALSE but
//              during an in-progress master merge, we may not have a
//              directory constructed yet.
//
//  History:    12-Jul-91   KyleP       Created.
//              21-Apr-92   BartoszM    Split into two constructors
//              10-Apr=94   SrikantS    Added fUseDir for restarted master
//                                      merge.
//
//----------------------------------------------------------------------------

CPersDeComp::CPersDeComp(
        PDirectory& pDir,
        INDEXID iid,
        CPhysIndex& phIndex,
        BitOffset& keyPos,
        const CKeyBuf& keyInit,
        const CKey* pKey,
        WORKID widMax,
        BOOL  fUseLinks,
        BOOL  fUseDir )
: CKeyDeComp( pDir, iid, phIndex, keyPos, keyInit, pKey, widMax,
              fUseLinks, fUseDir ),
  _sigPersDeComp(eSigPersDeComp),
  _maxOcc(OCC_INVALID)
{
    FinishKeyLoad();
    CKeyCursor::_pid = _key.Pid();
    UpdateWeight();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::CPersDeComp, public
//
//  Synopsis:   Copy Constructor
//
//  Effects:    Copies most of the values in decomp.  Calls copy constructor
//              for CCoder.
//
//  Arguments:  [decomp] -- Original CPersDeComp to be copied.
//
//  History:    08-Jan-92   AmyA        Created.
//
//----------------------------------------------------------------------------

CPersDeComp::CPersDeComp(CPersDeComp & decomp)
  :
    CKeyDeComp (decomp),
    _sigPersDeComp(eSigPersDeComp),
    _cWid(decomp._cWid),
    _cOcc(decomp._cOcc),
    _fcwidAccurate(decomp._fcwidAccurate),
    _cWidLeft(decomp._cWidLeft),
    _cOccLeft(decomp._cOccLeft),
    _maxOcc(OCC_INVALID)
{
    UpdateWeight();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::~CPersDeComp, public
//
//  Synopsis:   Destroy a decompressor/buffer pair.
//
//  Effects:    The main effect of destroying a decompressor is that the
//              associated buffer is also destroyed (presumably storing
//              the data to a persistent medium).
//
//  Signals:    ???
//
//  History:    22-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CPersDeComp::~CPersDeComp()
{}

const CKeyBuf * CPersDeComp::GetNextKey()
{
   return GetNextKey(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::GetNextKey, public
//
//  Synopsis:   Retrieve the next key from the content index.
//
//  Returns:    A pointer to the key, or 0 if end of page/index reached.
//
//  History:    15-Jul-91   KyleP       Created.
//              10-Apr-94   SrikantS    Added pBitOff and the ability to
//                                      decompress without using the dir.
//
//----------------------------------------------------------------------------

const CKeyBuf * CPersDeComp::GetNextKey( BitOffset *pBitOff )
{
    //
    // If we are not using links or
    // we are not using the directory and the offset of next key
    // is invalid, we must skip over the wid/occurrence data and
    // find out the offset of the next key.
    //
    if ( !_fUseLinks || (!_fUseDir && !_bitOffNextKey.Valid()) )
    {
        //
        // Just iterate through any remaining data for this key.
        //

        while (_wid != widInvalid)
        {
            while ( 0 != _cOccLeft )
            {
                BitUnCompress( OccDeltaBits );
                _cOccLeft--;
            }

            LoadWorkId();
        }

        if ( _fUseLinks )
        {
            //
            // We should fill the bitoffset for the next key as
            // the current position in the bitstream.
            //

            Win4Assert( !_fUseDir );
            _bitStream.GetOffset( _bitOffNextKey );
        }
    }

    const CKeyBuf * pkey = CKeyDeComp::GetNextKey( pBitOff );

    if ( pkey )
    {
        FinishKeyLoad();
        CKeyCursor::_pid = pkey->Pid();
        UpdateWeight();
    }

    return pkey;
} //GetNextKey

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::WorkId, public
//
//  Synopsis:   Retrieves the current Work ID
//
//  Returns:    The current WorkId or, if there is none or if at the end
//              of the compressor then returns widInvalid.
//
//  History:    15-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

WORKID CPersDeComp::WorkId()
{
    return(_wid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::NextWorkId, public
//
//  Synopsis:   Retrieve the next workid from the content index.
//
//  Returns:    A pointer to the workid, or widInvalid if end of
//              page/index reached.
//
//  History:    15-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

WORKID CPersDeComp::NextWorkId()
{
    //
    // Just iterate through any remaining data for this WorkId.
    //

    while ( 0 != _cOccLeft )
    {
        BitUnCompress( OccDeltaBits );
        _cOccLeft--;
    }

    // _occ may be invalid and really should be OCC_INVALID, but it doesn't matter

    LoadWorkId();

    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::WorkIdCount, public
//
//  Returns:    The total count of workids for the current key.
//
//  History:    15-Jul-91   KyleP       Created.
//
//  Notes:      Unlike the Get* calls, it is illegal to get a workid count
//              if there is no valid key.
//
//----------------------------------------------------------------------------

ULONG CPersDeComp::WorkIdCount()
{
    Win4Assert( _key.Count() > 0 );

    return(_cWid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::Occurrence, public
//
//  Synopsis:   Retrieves the current occurrence
//
//  Returns:    The current occurrence or, if there is none or if at the end
//              of the compressor then returns OCC_INVALID.
//
//  History:    15-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

OCCURRENCE CPersDeComp::Occurrence()
{
    return(_occ);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::NextOccurrence, public
//
//  Synopsis:   Retrieve the next occurrence from the content index.
//
//  Returns:    A pointer to the occurrence, or OCC_INVALID if end of
//              page/index reached.
//
//  History:    15-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

OCCURRENCE CPersDeComp::NextOccurrence()
{
    LoadOccurrence();

    return _occ;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::OccurrenceCount, public
//
//  Returns:    The total count of occurrences for the current workid.
//
//  History:    15-Jul-91   KyleP       Created.
//
//  Notes:      Unlike the Get* calls, it is illegal to get an occ count
//              if there is no valid workid.
//
//----------------------------------------------------------------------------

ULONG CPersDeComp::OccurrenceCount()
{
    Win4Assert(_wid != widInvalid);

    return(_cOcc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::LoadWidCount, private
//
//  Synopsis:   Loads wid count
//
//  History:    05-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

inline void CPersDeComp::LoadWidCount ()
{
    //
    // Get the WorkId count. Initially assume it is 4 bits, then 8,
    // then ULONG_BITS.
    //

    ULONG ul = _bitStream.GetBits(4);
    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME, "{0x%x}", ul ));

    if (ul == 0)
    {
        ul = _bitStream.GetBits(8);

        if (ul == 0)
        {
            ul = _bitStream.GetBits(ULONG_BITS);
            Win4Assert(ul != 0);
        }
    }

    _cWid = _cWidLeft = ul;

    //
    // Get the bit signifying that the workid count is accurate.
    //

    ul = _bitStream.GetBits(1);

    _fcwidAccurate = ul ? TRUE : FALSE;

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME,
        "[%s%d]", _fcwidAccurate?"":"!", _cWid ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::LoadKey, private
//
//  Synopsis:   Loads data for the next key.
//
//  Effects:    Reads a key from the current position in _bitStream and
//              sets per key state.
//
//  Signals:    ???
//
//  History:    12-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPersDeComp::LoadKey()
{
    CKeyDeComp::LoadKey();
    FinishKeyLoad();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::FinishKeyLoad, private
//
//  Synopsis:   Loads wid count and first wid.  Finishes LoadKey call of
//              CKeyDeComp
//
//  History:    07-Dec-93   w-PatG      Created.
//
//----------------------------------------------------------------------------

void CPersDeComp::FinishKeyLoad()
{
    //Parent class has loaded in a key and id.  Finish the job by loading in
    //a wid count and first wid.

    if ( IsAtSentinel() )
    {
        _wid = widInvalid;
        _occ = OCC_INVALID;
        _maxOcc = OCC_INVALID;
        return;
    }

    LoadWidCount ();
    _wid = 0;

#if CIDBG == 1
    if ( _cWid > _widMaximum )
        ciDebugOut (( DEB_ERROR, "_cWid = %ld, _widMaximum = %ld\n",
            _cWid, _widMaximum ));
#endif
    Win4Assert ( _cWid <= _widMaximum );

    SetAverageBits( _cWid );

    LoadWorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::LoadOccurrence, private
//
//  Synopsis:   Load an occurrence from the bit buffer.
//
//  History:    15-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

__forceinline void CPersDeComp::LoadOccurrence()
{
    if (_cOccLeft == 0)
    {
        _occ = OCC_INVALID;
        return;
    }

    ULONG occDelta = BitUnCompress(OccDeltaBits);

    Win4Assert( occDelta > 0 );

    _occ += occDelta;
    _cOccLeft--;

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME, "%d ", _occ ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::LoadFirstOccurrence, private
//
//  Synopsis:   Load an occurrence from the bit buffer.
//
//  History:    15-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

__forceinline void CPersDeComp::LoadFirstOccurrence()
{
    Win4Assert( 0 != _cOccLeft );

    _occ = BitUnCompress(OccDeltaBits);

    Win4Assert( _occ > 0 );

    _cOccLeft--;

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME, "%d ", _occ ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::LoadMaxOccurrence
//
//  Synopsis:   Load max occurrence from the bit buffer.
//
//  History:    20-Jun-96   SitaramR     Created
//
//----------------------------------------------------------------------------

__forceinline void CPersDeComp::LoadMaxOccurrence()
{
    //
    // Initially assume it is 4 bits, then 8, then ULONG_BITS
    //
    _maxOcc = _bitStream.GetBits(4);

    if ( _maxOcc == 0 )
    {
        _maxOcc = _bitStream.GetBits(8);

        if ( _maxOcc == 0 )
        {
            _maxOcc = _bitStream.GetBits(ULONG_BITS);
            Win4Assert( _maxOcc != 0 );
        }
    }

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME, "{0x%x}", _maxOcc ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersDeComp::LoadWorkId, private
//
//  Synopsis:   Loads data for a WorkId.
//
//  History:    15-Jul-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CPersDeComp::LoadWorkId()
{
    if (_cWidLeft == 0)
    {
        Win4Assert(_fcwidAccurate);
        _wid = widInvalid;
        return;
    }

    ULONG widDelta = BitUnCompress( _cbitAverageWid);

    if (widDelta == 0)
    {
#if CIDBG == 1
        if (_fcwidAccurate)
            Dump();
#endif
        Win4Assert(!_fcwidAccurate);
        _wid = widInvalid;
        return;
    }

    LoadMaxOccurrence();

    ULONG occCount = BitUnCompress( OccCountBits);

    _wid += widDelta;

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME, "<%d>", _wid ));

    Win4Assert(_wid <= _widMaximum);
    _cOcc = _cOccLeft = occCount;
    _cWidLeft--;

    ciDebugOut (( DEB_PCOMP | DEB_NOCOMPNAME, "(%d)", _cOcc ));

    LoadFirstOccurrence();
}


#if DEVL == 1
void CCoder::Dump()
{
#if CIDBG == 1
    ciDebugOut((DEB_ITRACE,
    "CCoder:\n"
    "\t_widMaximum %d\n"
    "\tKey \"%.*ws\"\n"
    "\t_wid %d"
    "\t_occ %d\n"
    "\t_cbitAverageWid %d\n",
        _widMaximum, _key.StrLen(), _key.GetStr(), _wid, _occ, _cbitAverageWid ));
#endif // CIDBG == 1
}

void CKeyComp::Dump()
{
}

void CKeyDeComp::Dump()
{
}

void CPersDeComp::Dump()
{
#if CIDBG == 1
    CCoder::Dump();
    ciDebugOut((DEB_ITRACE,
    "CPersDeComp:\n"
    "\t_cWid %d\n"
    "\t_cOcc %d\n"
    "\t_fcwidAccurate %d"
    "\t_cWidLeft %d\n"
    "\t_cOccLeft %d\n",
        _cWid, _cOcc, _fcwidAccurate, _cWidLeft, _cOccLeft ));
    _bitStream.Dump();
#endif // CIDBG == 1
}

void CPersComp::Dump()
{
#if CIDBG == 1
    CCoder::Dump();
    ciDebugOut((DEB_ITRACE,
    "CPersComp:\n"
    "\t_cWidActual %d\n"
    "\t_cWidProposed %d\n"
    "\t_cOccLeft %d\n",
        _cWidActual, _cWidProposed, _cOccLeft ));
    ciDebugOut((DEB_ITRACE, "BitStream\n" ));
    _bitStream.Dump();
    ciDebugOut((DEB_ITRACE, "BitStreamPatch\n" ));
    _bitStreamPatch.Dump();
#endif // CIDBG == 1
}
#endif // DEVL == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\pendcur.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       pendcur.cxx
//
//  Contents:   CPendingCursor
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "pendcur.hxx"

CPendingCursor::CPendingCursor( XArray<WORKID> & xWid, unsigned cWid )
        : CCursor( iidInvalid ),
          _iWid( 0 ),
          _cWid( cWid ),
          _aWid( xWid.Acquire() )
{
    if( _cWid > 1 )
    {
        // loop from through all elements
        for( unsigned j = 1; j < _cWid; j++ )
        {
            WORKID wid = _aWid[j];

            // go backwards from j-1 shifting up keys greater than 'key'
            for ( int i = j - 1; i >= 0 && _aWid[i] > wid; i-- )
            {
                _aWid[i+1] = _aWid[i];
            }
            // found key less than or equal 'key' or hit the beginning (i == -1)
            // insert key in the hole
            _aWid[i+1] = wid;
        }

        // Remove duplicates
        unsigned iTarget = 0;
        for ( unsigned iSrc = 1; iSrc < _cWid; iSrc++)
        {
            if ( _aWid[iTarget] == _aWid[iSrc] )
                continue;

            // wid's are different
            // copy source to target and update target index.

            iTarget++;
            if ( iTarget != iSrc )
                _aWid[iTarget] = _aWid[iSrc];
        }

        _cWid = iTarget + 1;         // possibly shrink array
    }
}


CPendingCursor::~CPendingCursor()
{
    delete [] _aWid;
}

ULONG CPendingCursor::WorkIdCount()
{
    return( _cWid );
}


WORKID CPendingCursor::WorkId()
{
    if ( _iWid >= _cWid )
        return( widInvalid );
    else
        return( _aWid[_iWid] );
}

WORKID CPendingCursor::NextWorkId()
{
    _iWid++;

    return( WorkId() );
}

ULONG CPendingCursor::HitCount()
{
    return( 1 );
}

LONG CPendingCursor::Rank()
{
    return( MAX_QUERY_RANK );
}

void CPendingCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    denom = _cWid;
    num   = min (_iWid, _cWid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\physidx.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PhysIndex.CXX
//
//  Contents:   FAT Buffer/Index package
//
//  Classes:    CPhysBuffer -- Buffer
//
//  History:    05-Mar-92   KyleP       Created
//              07-Aug-92   KyleP       Kernel implementation
//              21-Apr-93   BartoszM    Rewrote to use memory mapped files
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "physidx.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CPhysIndex::ReOpenStream
//
//  Synopsis:   Reopen for read-only
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

void CPhysIndex::ReOpenStream()
{
    Win4Assert( _stream.IsNull() );
    PStorage::EOpenMode mode = _fWritable ? PStorage::eOpenForWrite :
                                            PStorage::eOpenForRead;

    _stream.Set( _storage.QueryExistingIndexStream ( _obj, mode ) );
}

//+-------------------------------------------------------------------------
//
//  Method:     CPhysHash::ReOpenStream
//
//  Synopsis:   Reopen for read-only
//
//  History:    17-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

void CPhysHash::ReOpenStream()
{
    Win4Assert( _stream.IsNull() );
    _stream.Set( _storage.QueryExistingHashStream ( _obj, PStorage::eOpenForRead ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\pqueue.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       PQueue.cxx
//
//  Purpose:    'Pending' queue.  Queue of pending notifications.
//
//  Classes:    CPendingQueue
//
//  History:    30-Aug-95   KyleP    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "pqueue.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::CPendingQueue, public
//
//  Synopsis:   Constructor
//
//  History:    01-Sep-95   KyleP       Created
//
//----------------------------------------------------------------------------

CPendingQueue::CPendingQueue()
        : _cUnique( 0 ),
          _iBottom( 0 ),
          _iTop( 0 ),
          _cDoc( 16 ),
          _aDoc(0)
{

    _aDoc = new CPendingQueue::CDocItem[_cDoc];
}

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::~CPendingQueue, public
//
//  Synopsis:   Destructor
//
//  History:    01-Sep-95   KyleP       Created
//
//----------------------------------------------------------------------------

CPendingQueue::~CPendingQueue()
{
    Win4Assert( 0 == _iTop );
    delete [] _aDoc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::LokPrepare, public
//
//  Synopsis:   Allocate queue entry (to be filled in later).
//
//  Arguments:  [workid] -- Workid of entry
//
//  Returns:    Unique identifier for this entry.
//
//  History:    01-Sep-95   KyleP       Created
//
//----------------------------------------------------------------------------

unsigned CPendingQueue::LokPrepare( WORKID wid )
{
    //
    // May have to grow the array.  This is a very rare operation.
    //

    if ( _iTop == _cDoc )
    {
        CPendingQueue::CDocItem * pTemp = _aDoc;

#if CIDBG==1
        if ( _iTop >= 128 )
        {
            ciDebugOut(( DEB_WARN,
                        "Too many active threads (0x%X) in cleanup\n", _iTop ));
        }
#endif  // CIDBG==1

        _cDoc *= 2;

        _aDoc = new CPendingQueue::CDocItem[_cDoc];

        RtlCopyMemory( _aDoc, pTemp, _cDoc / 2 * sizeof(_aDoc[0]) );

        delete [] pTemp;
    }

    unsigned iHint = _iTop;

    _aDoc[_iTop].wid = wid;
    _aDoc[_iTop].hint = _cUnique++;
    _aDoc[_iTop].fComplete = FALSE;

    _iTop++;

    return _aDoc[_iTop-1].hint;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::LokComplete, public
//
//  Synopsis:   Fill in pre-reserved queue entry
//
//  Arguments:  [iHint]    -- Unique id of entry.
//              [wid]      -- Workid of entry.
//              [usn]      -- USN.
//              [volumeId] -- Volume id
//              [partid]   -- Partition Id
//              [action]   -- Update/Delete
//
//  Returns:    TRUE if queue was empty except for this entry.  Means this
//              entry wasn't added (and can be processed now).  FALSE means
//              CPendingQueue::Remove must be called directly following return
//              from Complete.
//
//  History:    01-Sep-95   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CPendingQueue::LokComplete( unsigned iHint,
                                 WORKID wid,
                                 USN usn,
                                 VOLUMEID volumeId,
                                 PARTITIONID partid,
                                 ULONG action )
{
    if ( ULONG_MAX == iHint )
    {
        //
        // Special case for scan-update documents. There is no need for
        // preserving order of updates.
        //
        return TRUE;
    }

    Win4Assert( _iBottom == 0 );
    Win4Assert( _iTop > 0 );

    //
    // Special case: If this is the only pending document then don't bother to fill
    //               in the struct, only to pull the values out.  Remember, this is
    //               called from Cleanup.  Speed counts.
    //

    if( _iTop == 1 )
    {
        Win4Assert( _aDoc[0].wid == wid );
        Win4Assert( _aDoc[0].hint == iHint );
        _iTop--;
        return TRUE;
    }

    //
    // The entry may have moved down, but never up the queue.
    //

    for ( unsigned i = 0; _aDoc[i].hint != iHint; i++ )
    {
        Win4Assert( i < _iTop );
        continue;       // NULL body
    }

    Win4Assert( _aDoc[i].wid == wid );
    _aDoc[i].usn = usn;
    _aDoc[i].volumeId = volumeId;
    _aDoc[i].partid = partid;
    _aDoc[i].action = action;
    _aDoc[i].fComplete = TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::LokRemove, public
//
//  Synopsis:   Pop a completed entry from queue.
//
//  Arguments:  [wid]      -- Workid of entry returned here.
//              [usn]      -- USN returned here.
//              [volumeId] -- Volume id
//              [partid] -- Partition Id returned here.
//              [action] -- Update/Delete returned here.
//
//  Returns:    TRUE if an entry was available for removal.  FALSE is queue
//              was empty, or bottom entry was not complete.
//
//  History:    01-Sep-95   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL CPendingQueue::LokRemove( WORKID & wid,
                               USN & usn,
                               VOLUMEID& volumeId,
                               PARTITIONID & partid,
                               ULONG & action )
{
    //
    // All done.  Empty queue.
    //

    if ( _iBottom == _iTop )
    {
        _iBottom = 0;
        _iTop = 0;
        return FALSE;
    }

    //
    // Out of completed entries.
    //

    if ( !_aDoc[_iBottom].fComplete )
    {
        RtlMoveMemory( _aDoc, &_aDoc[_iBottom], (_iTop - _iBottom) * sizeof(_aDoc[0]) );
        _iTop -= _iBottom;
        _iBottom = 0;
        return FALSE;
    }

    //
    // Got something!
    //

    wid = _aDoc[_iBottom].wid;
    usn = _aDoc[_iBottom].usn;
    volumeId =  _aDoc[_iBottom].volumeId;
    partid = _aDoc[_iBottom].partid;
    action = _aDoc[_iBottom].action;
    _iBottom++;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::LokCountCompleted, public
//
//  Returns:    Count of completed entries in queue.
//
//  History:    01-Sep-95   KyleP       Created
//
//----------------------------------------------------------------------------

unsigned CPendingQueue::LokCountCompleted()
{
    Win4Assert( _iBottom == 0 );

    unsigned cComplete = 0;

    for ( unsigned i = 0; i < _iTop; i++ )
    {
        if ( _aDoc[i].fComplete )
            cComplete++;
    }

    return cComplete;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::LokGetCompleted, public
//
//  Synopsis:   Fetch wids of completed entries.
//
//  Arguments:  [awid] -- Wids returned here.
//
//  History:    01-Sep-95   KyleP       Created
//
//  Notes:      Assumes [awid] is big enough to hold CountCompleted() wids.
//
//----------------------------------------------------------------------------

void CPendingQueue::LokGetCompleted( WORKID * awid )
{
    Win4Assert( _iBottom == 0 );

    for ( unsigned i = 0; i < _iTop; i++ )
    {
        if ( _aDoc[i].fComplete )
        {
            *awid = _aDoc[i].wid;
            awid++;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::LokFlushCompletedEntries
//
//  Synopsis:   Flushes any completed entries in the pending queue.
//
//  History:    9-11-95   srikants   Created
//
//  Notes:      Called as a result of an exception while removing the
//              entries.
//
//              The "Incomplete" entries will get cleaned up as part of
//              the "UpdateDocument" calls from cleanup.
//
//----------------------------------------------------------------------------

void CPendingQueue::LokFlushCompletedEntries()
{

    ciDebugOut(( DEB_WARN,
        "CPendingQueue::Flushing Entries _iBottom=0x%X _iTop=0x%X\n",
        _iBottom, _iTop ));

    Win4Assert( 0 == _iBottom || _iBottom <= _iTop );

    while ( _iBottom < _iTop && _aDoc[_iBottom].fComplete )
        _iBottom++;

    if ( _iBottom == _iTop )
    {
        _iBottom = _iTop = 0;
    }
    else
    {
        RtlMoveMemory( _aDoc, &_aDoc[_iBottom], (_iTop - _iBottom) * sizeof(_aDoc[0]) );
        _iTop -= _iBottom;
        _iBottom = 0;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPendingQueue::LokFlushAllEntries
//
//  Synopsis:   Flushes all entries in the pending queue.
//
//  History:    06-10-95    KyleP    Created
//
//  Notes:      Used during restart, after a call to EnableUsnUpdate.
//
//----------------------------------------------------------------------------

void CPendingQueue::LokFlushAllEntries()
{

    ciDebugOut(( DEB_WARN,
        "CPendingQueue::Flushing All Entries _iBottom=0x%X _iTop=0x%X\n",
        _iBottom, _iTop ));

    Win4Assert( 0 == _iBottom || _iBottom < _iTop );

    _iBottom = 0;
    _iTop = 0;
    _cUnique = 0;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\pmcomp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1997.
//
//  File:       PMComp.cxx
//
//  Contents:   Persistent index decompressor using during master merge
//
//  Classes:    CMPersDeComp
//
//  History:    21-Apr-94       DwightKr        Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "mindex.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   CMPersDeComp::CMPersDeComp
//
//  Synopsis:   Constructor for the persistent compressor capable of dealing
//              with two indexes representing the master index. This will
//              allow queries to transparently span both indexes.
//
//  Arguments:  [curDir]    -- directory for the current (old) master index
//              [curIid]    -- index Id of the current (old) master index
//              [curIndex]  -- physical index of the current (old) master index
//              [newDir]    -- directory for the new master index
//              [newIid]    -- index Id of the new master index
//              [pKey]      -- starting key to look for
//              [widMax]    -- maximum workid in the new master index
//              [splitKey]  -- key which seperates current & new master index
//              [mutex]     -- mutex to control access to dirs during merge
//
//  History:    4-10-94   DwightKr   Created
//
//----------------------------------------------------------------------------
CMPersDeComp::CMPersDeComp(
        PDirectory &          curDir,
        INDEXID               curIid,
        CPhysIndex &          curIndex,
        WORKID                curWidMax,
        PDirectory &          newDir,
        INDEXID               newIid,
        CPhysIndex &          newIndex,
        const CKey *          pKey,
        WORKID                newWidMax,
        const CSplitKeyInfo & splitKeyInfo,
        CMutexSem &           mutex ) :
    CKeyCursor(curIid, 0),
    _curDir(curDir),
    _curIid(curIid),
    _curIndex(curIndex),
    _curWidMax(curWidMax),
    _newDir(newDir),
    _newIid(newIid),
    _newIndex(newIndex),
    _newWidMax(newWidMax),
    _splitKeyInfo(splitKeyInfo),
    _pActiveCursor(0),
    _fUseNewIndex(FALSE),
    _mutex(mutex),
    _lastSplitKeyBuf( splitKeyInfo.GetKey() )
{
    //
    // Note that _mutex is currently held when this constructor is called.
    //
    // Determine which index the query should start in.  If the key is
    // less than or equal to the splitkey, start in the new master index.
    // Otherwise start in the current (old) master index.
    //

    BitOffset posKey;
    CKeyBuf keyInit;

    if ( pKey->Compare( _lastSplitKeyBuf ) <= 0 )
    {
        //
        // Save the offset of the splitKey so that the NextKey() operation
        // can quickly determine if we are about to fall off the logical
        // end of the index.
        //

        _newDir.Seek( _lastSplitKeyBuf, 0, _lastSplitKeyOffset );

        ciDebugOut(( DEB_PCOMP,
                     "Constructor: splitkey '%.*ws' offset = 0x%x:0x%x\n",
                     _lastSplitKeyBuf.StrLen(), _lastSplitKeyBuf.GetStr(),
                     _lastSplitKeyOffset.Page(), _lastSplitKeyOffset.Offset() ));

        _fUseNewIndex = TRUE;
        _newDir.Seek( *pKey, &keyInit, posKey );
        _widMax = _newWidMax;
        _pActiveCursor = new CPersDeComp( _newDir, _newIid, _newIndex,
                                          posKey, keyInit,
                                          pKey, _newWidMax);
    }
    else
    {
        _curDir.Seek( *pKey, &keyInit, posKey );
        _widMax = _curWidMax;
        _pActiveCursor = new CPersDeComp( _curDir, _curIid, _curIndex,
                                          posKey, keyInit,
                                          pKey, _curWidMax );
    }

    // Update weights so Rank can be computed

    UpdateWeight();

    ciDebugOut(( DEB_PCOMP, "found key %.*ws at %lx:%lx\n",
                 keyInit.StrLen(), keyInit.GetStr(),
                 posKey.Page(), posKey.Offset() ));
} //CMPersDeComp

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CMPersDeComp::~CMPersDeComp()
{
    delete _pActiveCursor;
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
const CKeyBuf * CMPersDeComp::GetKey()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->GetKey();
}

//+---------------------------------------------------------------------------
//
//  Function:   CMPersDeComp::GetNextKey()
//
//  Synopsis:   Obtains the next key from the logical master index.
//
//  History:    4-10-94   DwightKr   Created
//
//  Notes:      If we are using the new master index, and the current
//              key is the split key, then we have exhausted the new
//              master index, and the GetNextKey() operation should
//              transparently move to the current master index.
//
//              We are comparing BitOffset's here rather than keys
//              because it is simplear and faster.
//
//----------------------------------------------------------------------------

const CKeyBuf * CMPersDeComp::GetNextKey()
{
    Win4Assert( _pActiveCursor );

    //
    // Grab the lock to protect access to split key info and the buffers
    // in the old index (so the master merge doesn't do a checkpoint
    // until after we create a cursor or move the cursor from one page to
    // the next.  This is really expensive.
    //

    CLock lock( _mutex );

    //
    // If we are already using the old master index, then we don't need to
    // check the splitkey since we have already crossed over to the old index.
    //

    if ( !_fUseNewIndex )
        return _pActiveCursor->GetNextKey();

    //
    // We are using the new master index. If we are positioned at the split
    // key, the subsequent nextKey() operation will need to take us to
    // the old index.  Determine if we are about to cross between indexes.
    //

    BitOffset currentKeyOffset;
    _pActiveCursor->GetOffset( currentKeyOffset );

    ciDebugOut(( DEB_PCOMP,
                 "NextKey: splitkey offset = 0x%x:0x%x  currentKeyOffset = 0x%x:0x%x\n",
                 _lastSplitKeyOffset.Page(), _lastSplitKeyOffset.Offset(),
                 currentKeyOffset.Page(), currentKeyOffset.Offset() ));

    if ( _lastSplitKeyOffset > currentKeyOffset )
    {
        const CKeyBuf *p = _pActiveCursor->GetNextKey();

#if CIDBG == 1
        BitOffset boCur;
        _pActiveCursor->GetOffset( boCur );
        ciDebugOut(( DEB_PCOMP,
                     "GetNextKey from new index = %.*ws  offset = 0x%x:0x%x\n",
                     p->StrLen(), p->GetStr(),
                     boCur.Page(), boCur.Offset() ));
#endif // CIDBG == 1

        return p;
    }
    
    //
    // We MAY have crossed over from the new index to the old index.
    // Check to see if the split key has moved to verify.
    //

    if ( !AreEqual( & _lastSplitKeyBuf, & (_splitKeyInfo.GetKey()) ) )
    {
        _lastSplitKeyBuf = _splitKeyInfo.GetKey();
        _newDir.Seek( _lastSplitKeyBuf, 0, _lastSplitKeyOffset );

        //
        // Check to see if we can continue using the new index since
        // the split key has moved.
        //

        if ( _lastSplitKeyOffset > currentKeyOffset )
        {
            ciDebugOut(( DEB_PCOMP, "sticking with new index due to split\n" ));
            return _pActiveCursor->GetNextKey();
        }
    }

    ciDebugOut(( DEB_PCOMP, "switching to old index given split key %.*ws\n",
                 _lastSplitKeyBuf.StrLen(), _lastSplitKeyBuf.GetStr() ));

    //
    // Rebuild the key decompressor to point to the old index on the smallest
    // key >= the split key
    //

    _fUseNewIndex = FALSE;
    delete _pActiveCursor;
    _pActiveCursor = 0;

    BitOffset posKey;
    CKeyBuf keyInit;

    _curDir.Seek( _lastSplitKeyBuf, &keyInit, posKey );

    int iCompare = Compare( &keyInit, &_lastSplitKeyBuf );

    // If the split key isn't in the old index, use the next key

    if ( iCompare < 0 )
        _curDir.SeekNext( _lastSplitKeyBuf, &keyInit, posKey );

    ciDebugOut(( DEB_PCOMP, "found key >= (%d) split key = %.*ws at %lx:%lx\n",
                 iCompare,
                 keyInit.StrLen(), keyInit.GetStr(),
                 posKey.Page(), posKey.Offset() ));

    // If we're out of keys then say so.

    if ( keyInit.IsMaxKey() )
    {
        ciDebugOut(( DEB_WARN, "at the end of the old index...\n" ));
        return 0;
    }

    _widMax = _curWidMax;
    CKey Key( keyInit );

    _pActiveCursor = new CPersDeComp( _curDir, _curIid, _curIndex,
                                      posKey, keyInit,
                                      &Key, _curWidMax );

    return _pActiveCursor->GetNextKey();
} //GetNextKey

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
const CKeyBuf * CMPersDeComp::GetNextKey( BitOffset * pBitOff )
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->GetNextKey( pBitOff );
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
WORKID CMPersDeComp::WorkId()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->WorkId();
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
WORKID CMPersDeComp::NextWorkId()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->NextWorkId();
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
ULONG CMPersDeComp::WorkIdCount()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->WorkIdCount();
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
OCCURRENCE CMPersDeComp::Occurrence()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->Occurrence();
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
OCCURRENCE CMPersDeComp::NextOccurrence()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->NextOccurrence();
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
OCCURRENCE CMPersDeComp::MaxOccurrence()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->MaxOccurrence();
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
ULONG CMPersDeComp::OccurrenceCount()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->OccurrenceCount();
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
ULONG CMPersDeComp::HitCount()
{
    Win4Assert( _pActiveCursor );
    return _pActiveCursor->HitCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\pidxtbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       PIDXTBL.CXX
//
//  Contents:   Partition Index Table
//
//  Classes:    PIndexTable
//
//  History:    16-Feb-94   SrikantS    Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pidxtbl.hxx>
#include <pstore.hxx>
#include <rcstxact.hxx>
#include <rcstrmit.hxx>

#include "prtiflst.hxx"

#define WORKID_CONTENTINDXROOT   0

//+---------------------------------------------------------------------------
//
//  Function:   CreateAndAddIt
//
//  Synopsis:   This methods creates a WID for the specified "it" and
//              adds an entry to the index table. The "iid" is formed
//              by using the partition id and the index type.
//
//  Arguments:  [it]     --  Index Type to be created.
//              [partid] --  Partition Id for the it.
//
//  History:    2-16-94   srikants   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

WORKID PIndexTable::CreateAndAddIt( IndexType it, PARTITIONID partid )
{


    WORKID wid;

    if ( itFreshLog == it )
    {
        wid = GetStorage().GetNewObjectIdForFreshLog();    
    }
    else
    {
        //
        // In Kernel, OFS does not use the iid but in FAT that is used
        // as the wid of the object. So, generating a unique wid for
        // each "it" is by using the parition id and the it.
        //
    
        CIndexId iid(it, partid);
        wid = GetStorage().CreateObjectId( iid, PStorage::eRcovHdr );
    }

    AddObject( partid, it, wid );

    return wid;
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CPartInfo *
PIndexTable::CreateOrGet( SPartInfoList & pList, PARTITIONID partId )
{
    CPartInfo * pPartInfo = pList->GetPartInfo( partId );
    if ( !pPartInfo ) {
        pPartInfo = new CPartInfo( partId );
        pList->Append( pPartInfo );
    }

    return(pPartInfo);

}

//+---------------------------------------------------------------------------
//
//  Function:   QueryBootStrapInfo
//
//  Synopsis:   This method acts as the bootstrap procedure by reading the
//              index table from disk and creating/initializing the
//              "special" index types like the changelog, freshlog, etc.
//
//              It also handles creating the "first" partition entry if
//              none exists.
//
//  History:    2-16-94   srikants   Created
//
//  Notes:      It is upto the caller of the function to destroy the
//              CPartInfoList that is created here.
//
//----------------------------------------------------------------------------

CPartInfoList * PIndexTable::QueryBootStrapInfo()
{
    WORKID  widFreshLog = widInvalid;
    WORKID  widPhraseLat = widInvalid;

    CPartInfoList * pPartInfoList = new CPartInfoList;
    SPartInfoList   pList( pPartInfoList );

    BOOL    fCreatePart = TRUE;

    {
        //
        // Iterate over the index table and form the PartInfoList.
        //

        SIndexTabIter pIdxIter(QueryIterator());
        if ( pIdxIter->Begin() )
        {

            CIndexRecord record;

            while ( pIdxIter->NextRecord ( record ) )
            {
                PARTITIONID partId = CIndexId( record.Iid()).PartId();

                if ( partidInvalid == partId )
                {
                    //
                    // The deleted index ids (iidDeleted1 and iidDeleted2)
                    // both have 0xffff as their partid which is also the
                    // partid invalid. We must treat it as a special case.
                    //
                    if ( itDeleted == record.Type() )
                    {
                        Win4Assert( iidInvalid == _iidDeleted &&
                                    "You have to reformat" );
                        _iidDeleted = record.Iid();
                    }
                    continue;
                }


                //
                // Check if the partition is valid or not.
                //
                CPartInfo * pPartInfo = NULL;
                if ( partId != partidKeyList &&
                     partId != partidFresh1 &&
                     partId != partidFresh2  )
                {
                    pPartInfo = CreateOrGet( pList, partId );
                    Win4Assert( pPartInfo );
                    fCreatePart = FALSE;
                }
                else if ( partidKeyList == partId )
                {
                    continue;
                }

                switch( record.Type() ) {

                case itPartition:
                    break;

                case itChangeLog:

                    pPartInfo->SetChangeLogObjectId(record.ObjectId());
                    break;

                case itMaster:

                    pPartInfo->SetCurrMasterIndex(record.ObjectId());
                    break;

                case itNewMaster:

                    pPartInfo->SetNewMasterIndex(record.ObjectId());
                    break;

                case itMMLog:

                    pPartInfo->SetMMergeLog(record.ObjectId());
                    break;

                case itFreshLog:

                    widFreshLog = record.ObjectId();
                    Win4Assert( widInvalid != widFreshLog );
                    break;

                case itPhraseLat:

                    widPhraseLat = record.ObjectId();
                    Win4Assert( widInvalid != widPhraseLat );
                    break;

                } // of switch
            } // of while
        } // of if
    } // This block necessary to destroy the pIdxIter

    if ( fCreatePart )
    {
        AddPartition( partidDefault );
        CPartInfo * pPartInfo = new CPartInfo( partidDefault );
        pList->Append( pPartInfo );
    }

    //
    // We now have to create any objects that are not created yet.
    //
    BOOL fNewFreshLog = FALSE;
    if ( widInvalid == widFreshLog )
    {
        fNewFreshLog = TRUE;
        widFreshLog = CreateAndAddIt( itFreshLog, partidDefault );
    }

    BOOL fNewPhraseLat = FALSE;
    if ( widInvalid == widPhraseLat )
    {
        fNewPhraseLat = TRUE;
        widPhraseLat = CreateAndAddIt( itPhraseLat, partidDefault );
    }

    if ( _iidDeleted == iidInvalid )
    {
        SetDeletedIndex( iidDeleted1 );
    }

    Win4Assert( widInvalid != widFreshLog );
    Win4Assert( widInvalid != widPhraseLat );
    GetStorage().InitRcovObj( widFreshLog, FALSE ); // other two strms also.
    GetStorage().InitRcovObj( widPhraseLat, TRUE ); // atomic strm only

    GetStorage().SetSpecialItObjectId( itFreshLog,  widFreshLog );
    GetStorage().SetSpecialItObjectId( itPhraseLat, widPhraseLat );

    if ( fNewFreshLog )
    {
        //
        // Inside kernel, we are guaranteed that a new object has no data in
        // it. In user space, we may be using an object that was not deleted
        // before due to a failure.
        //
        PRcovStorageObj * pObj =  GetStorage().QueryFreshLog(widFreshLog);
        XPtr<PRcovStorageObj> xObj(pObj);
        xObj->InitHeader(GetStorage().GetStorageVersion());
    }
    // phrase lattice is not used now

    //
    // For each partition, create/initialize the persistent objects
    // that exist on a per-partition basis. eg. ChangeLog.
    //
    for ( CForPartInfoIter it(*pList); !pList->AtEnd(it); pList->Advance(it) )
    {
        CPartInfo * pPartInfo = it.GetPartInfo();
        Win4Assert( pPartInfo );
        BOOL fNewChangeLog = FALSE;
        if ( widInvalid == pPartInfo->GetChangeLogObjectId() )
        {
            pPartInfo->SetChangeLogObjectId(
                    CreateAndAddIt( itChangeLog, pPartInfo->GetPartId() ));

            fNewChangeLog = TRUE;
        }

        Win4Assert( widInvalid != pPartInfo->GetChangeLogObjectId() );
        GetStorage().InitRcovObj( pPartInfo->GetChangeLogObjectId(), FALSE );

        if ( fNewChangeLog )
        {
            PRcovStorageObj * pObj =
                GetStorage().QueryChangeLog( pPartInfo->GetChangeLogObjectId(),
                                             PStorage::ePrimChangeLog );
            XPtr<PRcovStorageObj> xObj(pObj);
            xObj->InitHeader(GetStorage().GetStorageVersion());
        }
    }

    return pList.Acquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\pindex.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       PINDEX.CXX
//
//  Contents:   Persistent Index
//
//  Classes:    CPersIndex, CMergeSourceCursor
//
//  History:    03-Apr-91       BartoszM        Created stub.
//              20-Apr-94       DwightKr        Moved CMergeSourceCursor here
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pdir.hxx>
#include <pstore.hxx>
#include <pidxtbl.hxx>
#include <rwex.hxx>

#include "pindex.hxx"
#include "pcomp.hxx"
#include "mcursor.hxx"
#include "fresh.hxx"
#include "physidx.hxx"
#include "pcomp.hxx"
#include "fretest.hxx"
#include "indsnap.hxx"
#include "keylist.hxx"
#include "partn.hxx"

unsigned const FOUR_MEGABYTES = 0x400000;

//+---------------------------------------------------------------------------
//
// Member:     CPersIndex::Size, public
//
// Synopsis:   Returns size in pages
//
// History:    22-May-92    BartoszM       Created.
//
//----------------------------------------------------------------------------

unsigned CPersIndex::Size() const
{
    return _xPhysIndex->PageSize();
}

void CPersIndex::FillRecord ( CIndexRecord& record )
{
    record._objectId = ObjectId();
    record._iid = GetId();
    record._type = IsMaster()? itMaster: itShadow;
    record._maxWorkId = MaxWorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::CPersIndex, public
//
//  Synopsis:   Create an empty index
//
//  Arguments:  [id]  -- index id
//              [storage] -- physical storage
//
//  History:    3-Apr-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CPersIndex::CPersIndex(
    PStorage &                 storage,
    WORKID                     objectId,
    INDEXID                    iid,
    unsigned                   c4KPages,
    CDiskIndex::EDiskIndexType idxType ) :
  CDiskIndex( iid, idxType ),
  _sigPersIndex( eSigPersIndex ),
  _storage( storage ),
  _obj( storage.QueryObject( objectId ) ),
  _fAbortMerge( FALSE )
{
    XPtr<PMmStream> sStream( storage.QueryNewIndexStream( _obj.GetObj(),
                             CDiskIndex::eMaster == idxType ) );;
    _xPhysIndex.Set( new CPhysIndex( storage,
                                     _obj.GetObj(),
                                     objectId,
                                     c4KPages,
                                     sStream ) );
    _xPhysIndex->SetPageGrowth( FOUR_MEGABYTES / CI_PAGE_SIZE );
    Win4Assert( 0 == sStream.GetPointer() );

    _xDir.Set( _storage.QueryNewDirectory( _obj.GetObj() ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::CPersIndex, public
//
//  Synopsis:   Restore an index from storage
//
//  Arguments:  [id]        -- index id
//              [storage]   -- physical storage
//              [widMax]    -- max work id
//              [isMaster]  -- Set to TRUE if this is a master index.
//              [fWritable] -- Set to TRUE if various streams should be
//                             opened for Write access.
//              [fReadDir]  -- should the directory be opened for r or r/w
//
//  History:    3-Apr-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CPersIndex::CPersIndex(
        PStorage &                 storage,
        WORKID                     objectId,
        INDEXID                    iid,
        WORKID                     widMax,
        CDiskIndex::EDiskIndexType idxType,
        PStorage::EOpenMode        mode,
        BOOL                       fReadDir ) :
    CDiskIndex( iid, idxType, widMax ),
    _sigPersIndex( eSigPersIndex ),
    _storage( storage ),
    _obj( storage.QueryObject( objectId ) ),
    _fAbortMerge( FALSE )
{
    Win4Assert( PStorage::eOpenForWrite == mode ||
                PStorage::eOpenForRead  == mode );

    PStorage::EOpenMode modeIndex = mode;
 
    //
    // Open master indexes writable so we can shrink them from the front
    //

    if ( CDiskIndex::eMaster == idxType )
        modeIndex = PStorage::eOpenForWrite;

    PMmStream * pStream = storage.QueryExistingIndexStream( _obj.GetObj(),
                                                            modeIndex );
    XPtr<PMmStream> sStream( pStream );
    _xPhysIndex.Set( new CPhysIndex( storage,
                                     _obj.GetObj(),
                                     objectId,
                                     modeIndex,
                                     sStream ) );
    Win4Assert( 0 == sStream.GetPointer() );

    Win4Assert( fReadDir );

    if ( fReadDir )
        _xDir.Set( _storage.QueryExistingDirectory( _obj.GetObj(), mode ) );
    else
        _xDir.Set( _storage.QueryNewDirectory( _obj.GetObj() ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeSourceCursor::CMergeSourceCursor
//
//  Synopsis:   Constructor
//
//  History:    29-Aug-92       BartoszM        Created
//
//----------------------------------------------------------------------------
CMergeSourceCursor::CMergeSourceCursor ( CIndexSnapshot& indSnap,
                                         const CKeyBuf * pKey )
{
    if (0 != pKey)
    {
        CKey SplitKey(*pKey);
        _pCurSrc = indSnap.QueryMergeCursor ( &SplitKey );
    }
    else
    {
        _pCurSrc = indSnap.QueryMergeCursor ();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMergeSourceCursor::~CMergeSourceCursor
//
//  Synopsis:   Destructor
//
//  History:    29-Aug-92       BartoszM        Created
//
//----------------------------------------------------------------------------
CMergeSourceCursor::~CMergeSourceCursor ()
{
    delete _pCurSrc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::Merge, public
//
//  Synopsis:   Merge index(es) into an empty pesistent index.
//
//  Effects:    Fills the persistent index with data from the input
//              indexes.
//              [fresh] is deleted.
//
//  Arguments:  [indSnap]     -- array of indexes to be merged
//              [pNewKeyList] -- Keylist to merge (master merge only)
//              [mergeProgress] -- % merge complete
//
//  Requires:   The index is initially empty.
//
//  Notes:      Every compressor is transacted.
//
//  History:    15-May-91   KyleP       Use new PutOccurrence() method.
//              16-Apr-91   KyleP       Created.
//              17-Feb-93   KyleP       Merge keylist
//              25-Oct-95   DwightKr    Add merge complete measurement
//
//----------------------------------------------------------------------------

void CPersIndex::Merge( CIndexSnapshot& indSnap,
                        const CPartition & partn,
                        CCiFrmPerfCounter & mergeProgress,
                        BOOL fGetRW )
{
    // Calculate max of all input widMaxs

#if CIDBG == 1
    unsigned cKey = 0;
#endif

    WORKID widMax = indSnap.MaxWorkId();

    ciDebugOut (( DEB_ITRACE, "Max work id %ld\n", widMax ));

    SetMaxWorkId ( widMax );

    CFreshTest* pFreshTest = indSnap.GetFresh();

    CKeyBuf keyLast;

    CMergeSourceCursor pCurSrc( indSnap );

    if ( !pCurSrc.IsEmpty() )
    {
        //
        // Read-ahead on the source indexes results in better merge
        // performance, but slower queries.  Temporarily switch modes.
        //

        CSetReadAhead readAhead( _storage );

        CPersComp compr( _xPhysIndex.GetReference(), _widMax );

        ciDebugOut (( DEB_ITRACE, "widMax passed to compressor: %ld\n",
            _widMax ));

        const CKeyBuf * pKey;
        ULONG page = ULONG(-1);
        BitOffset bitOff;

#if CIDBG == 1
        keyLast.SetPid(pidContents); // arbitrary but not pidAll
#endif

#if CIDBG == 1
        WCHAR FirstLetter = '@';
#endif

        mergeProgress.Update( 0 );

        ciDebugOut (( DEB_ITRACE,"Merging. Merge on letter: "));

        for (pKey = pCurSrc->GetKey();
             pKey != NULL; pKey = pCurSrc->GetNextKey())
        {

#if CIDBG == 1
            cKey++;

            if ( *(pKey->GetStr()) != FirstLetter )
            {
                FirstLetter = *(pKey->GetStr());
                if ( FirstLetter < L'~' )
                    ciDebugOut(( DEB_NOCOMPNAME | DEB_ITRACE | DEB_PENDING, "%c",
                                 FirstLetter ));
                else
                    ciDebugOut(( DEB_NOCOMPNAME | DEB_ITRACE | DEB_PENDING, "<%04x>",
                                 FirstLetter ));
            }
#endif
            //
            // Don't store empty keys
            //

            WORKID wid = pCurSrc->WorkId();

            if ( wid == widInvalid )
                continue;

            //
            //  Add the key to the new index.
            //

            // This would later lead to a divide by 0

            Win4Assert( 0 != pCurSrc->WorkIdCount() );

            compr.PutKey(pKey, pCurSrc->WorkIdCount(), bitOff);

            for ( ;
                  wid != widInvalid;
                  wid = pCurSrc->NextWorkId())
            {
                // fresh test

                CFreshTest::IndexSource indexSrc =
                        pFreshTest->IsCorrectIndex (pCurSrc->IndexId(), wid);
                //
                // There should always be an entry for a workid in the fresh
                // test whose data is contained in a wordlist/shadow-index.
                //
                Win4Assert( CFreshTest::Master != indexSrc );

                if ( CFreshTest::Invalid != indexSrc )
                {
                    compr.PutWorkId(wid, pCurSrc->MaxOccurrence(), pCurSrc->OccurrenceCount());

                    for (OCCURRENCE occ = pCurSrc->Occurrence();
                            occ != OCC_INVALID;
                            occ = pCurSrc->NextOccurrence())
                    {
                        compr.PutOccurrence(occ);
                    }
                }
            }

            //
            //  If this key didn't have any wids then we can delete it from
            //  the new index.  Otherwise, track it as a possible splitkey
            //  and update the index as necessary.
            //

            if ( bitOff.Page() != page )
            {
                page = bitOff.Page();
                _xDir->Add ( bitOff, *pKey );
            }
            else
            {
                Win4Assert( page == _xDir->GetBitOffsetLastAdded().Page() );
            }

            keyLast = *pKey;

            //
            // There's no point in special abort code.  We have to handle
            // exceptions anyway.
            //

            if ( _fAbortMerge || partn.IsCleaningUp() )
            {
                ciDebugOut(( DEB_ITRACE, "Aborting Merge\n" ));
                THROW( CException( STATUS_UNSUCCESSFUL ) );
            }

            mergeProgress.Update( _xPhysIndex->PagesInUse() * 100 / _xPhysIndex->PageSize() );
        }

        ciDebugOut(( DEB_ITRACE | DEB_PENDING, "%d keys in index\n", cKey ));

        // add sentinel key
        keyLast.FillMax();
        keyLast.SetPid( pidContents );
        compr.PutKey( &keyLast, 1, bitOff );

        //
        // If the MaxKey is the first key on a page, it must be added
        // to the directory.
        //
        if ( bitOff.Page() != page )
        {
            page = bitOff.Page();
            _xDir->Add ( bitOff, keyLast );
        }
        else
        {
            Win4Assert( page == _xDir->GetBitOffsetLastAdded().Page() );
        }

        mergeProgress.Update( 100 );

        compr.FreeStream();
    } // compr goes out of scope
    else
    {
        ciDebugOut (( DEB_ITRACE, "No merge cursor created\n" ));

        CPersComp compr( _xPhysIndex.GetReference(), _widMax );
        keyLast.FillMax();
        keyLast.SetPid(pidContents);

        BitOffset bitOff;
        compr.PutKey( &keyLast, 1, bitOff );
        compr.FreeStream();
    }

    //
    // Compressor MUST NOT be in scope here.
    //

    keyLast.FillMax();
    _xDir->LokFlushDir( keyLast );
    _xDir->LokBuildDir( keyLast );

    // after compr is dead
    _xPhysIndex->Flush();
    _xPhysIndex->Reopen( FALSE );
} //Merge

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::QueryCursor, public
//
//  Synopsis:   Return a cursor for the whole persistent index.
//
//  Returns:    A new cursor.
//
//  History:    24-Apr-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CKeyCursor * CPersIndex::QueryCursor()
{
    CKey key;
    key.FillMin();

    return QueryKeyCursor( &key );
}


//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::QueryKeyCursor, public
//
//  Synopsis:   Return a key cursor for the shadow index when restarting a
//              master merge
//
//  Returns:    A new cursor.
//
//  History:    12-Apr-94   DwightKr    Created.
//
//----------------------------------------------------------------------------
CKeyCursor * CPersIndex::QueryKeyCursor(const CKey * pKey)
{
    BitOffset posKey;

    CKeyBuf keyInit;

    _xDir->Seek( *pKey, &keyInit, posKey );

    ciDebugOut(( DEB_ITRACE, "found key %.*ws at %lx:%lx\n",
                 keyInit.StrLen(), keyInit.GetStr(),
                 posKey.Page(), posKey.Offset() ));

    XPtr<CPersDeComp> xCursor( new CPersDeComp( _xDir.GetReference(),
                                                GetId(),
                                                _xPhysIndex.GetReference(),
                                                posKey,
                                                keyInit,
                                                pKey,
                                                _widMax ) );

    if ( 0 == xCursor->GetKey() )
        xCursor.Free();

    return xCursor.Acquire();
} //QueryKeyCursor


//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::QueryCursor, public
//
//  Synopsis:   Return a cursor for the persistent index.
//
//  Arguments:  [pKey]      -- Key to initially seek for.
//              [isRange]   -- TRUE for range query
//              [cMaxNodes] -- Max number of nodes to create. Decremented
//                             on return.
//
//  Returns:    A new cursor.
//
//  History:    24-Apr-91   KyleP       Created.
//
//----------------------------------------------------------------------------

COccCursor * CPersIndex::QueryCursor( const CKey * pKey,
                                      BOOL isRange,
                                      ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    if (isRange)
    {
        CKey keyEnd;
        keyEnd.FillMax (*pKey);
        return QueryRangeCursor (pKey, &keyEnd, cMaxNodes);
    }

    if (pKey->Pid() == pidAll)
        return QueryRangeCursor ( pKey, pKey, cMaxNodes );

    cMaxNodes--;

    if ( 0 == cMaxNodes )
    {
        ciDebugOut(( DEB_WARN, "Node limit reached in CPersIndex::QueryCursor.\n" ));
        THROW( CException( STATUS_TOO_MANY_NODES ) );
    }

    BitOffset posKey;

    CKeyBuf keyInit;

    _xDir->Seek( *pKey, &keyInit, posKey );

    ciDebugOut(( DEB_ITRACE, "found key %.*ws at %lx:%lx\n",
                 keyInit.StrLen(), keyInit.GetStr(),
                 posKey.Page(), posKey.Offset() ));

    XPtr<CPersDeComp> xCursor( new CPersDeComp( _xDir.GetReference(),
                                                GetId(),
                                                _xPhysIndex.GetReference(),
                                                posKey,
                                                keyInit,
                                                pKey,
                                                _widMax ) );

    if ( xCursor->GetKey() == 0  || !pKey->MatchPid( *xCursor->GetKey())
        ||  pKey->CompareStr(*xCursor->GetKey()) != 0 )
    {
        xCursor.Free();
    }

    return xCursor.Acquire();
} //QueryCursor

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::QueryRangeCursor, public
//
//  Synopsis:   Return a range cursor for the persistent index.
//
//  Arguments:  [pKey]      -- Key at beginning of the range.
//              [pKeyEnd]   -- Key at the end of the range.
//              [cMaxNodes] -- Max number of nodes to create. Decremented
//                             on return.
//
//  Returns:    A new cursor.
//
//  History:    11-Dec-91   AmyA        Created.
//              31-Jan-92   AmyA        Moved code to CreateRange().
//
//----------------------------------------------------------------------------

COccCursor * CPersIndex::QueryRangeCursor( const CKey * pKey,
                                           const CKey * pKeyEnd,
                                           ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    COccCurStack curStk;

    CreateRange(curStk, pKey, pKeyEnd, cMaxNodes );

    return curStk.QuerySynCursor( MaxWorkId() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::QuerySynCursor, public
//
//  Synopsis:   Return a synonym cursor for the persistent index.
//
//  Arguments:  [keyStk]    -- Stack of keys to be searched for.
//              [isRange]   -- Whether or not this is a range search.
//              [cMaxNodes] -- Max number of nodes to create. Decremented
//                             on return.
//
//  Returns:    A new cursor.
//
//  History:    31-Jan-92   AmyA        Created.
//
//----------------------------------------------------------------------------

COccCursor * CPersIndex::QuerySynCursor( CKeyArray & keyArr,
                                         BOOL isRange,
                                         ULONG & cMaxNodes )
{
    COccCurStack curStk;

    int keyCount = keyArr.Count();

    for (int i = 0; i < keyCount; i++)
    {
        Win4Assert( cMaxNodes > 0 );

        CKey& key = keyArr.Get(i);

        if (isRange)
        {
            CKey keyEnd;
            keyEnd.FillMax(key);

            CreateRange(curStk, &key, &keyEnd, cMaxNodes );
        }
        else if ( key.Pid() == pidAll )
        {
            CreateRange ( curStk, &key, &key, cMaxNodes );
        }
        else
        {
            XPtr<COccCursor> xCursor( QueryCursor( &key, FALSE, cMaxNodes ) );

            if ( !xCursor.IsNull() )
            {
                curStk.Push( xCursor.GetPointer() );
                xCursor.Acquire();
            }
        }
    }

    return(curStk.QuerySynCursor( MaxWorkId()));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::CreateRange, private
//
//  Synopsis:   Adds all cursors with keys between pKey and pKeyEnd to curStk.
//
//  Arguments:  [curStk]    -- CKeyCurStack to add cursors to.
//              [pKey]      -- Key at beginning of range.
//              [pKeyEnd]   -- End of key range.
//              [cMaxNodes] -- Max number of nodes to create. Decremented
//                             on return.
//
//  History:    31-Jan-92   AmyA           Created.
//
//----------------------------------------------------------------------------

void CPersIndex::CreateRange( COccCurStack & curStk,
                              const CKey * pKeyStart,
                              const CKey * pKeyEnd,
                              ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    cMaxNodes--;

    if ( 0 == cMaxNodes )
    {
        ciDebugOut(( DEB_WARN, "Node limit reached in CPersIndex::CreateRange.\n" ));
        THROW( CException( STATUS_TOO_MANY_NODES ) );
    }

    BitOffset posKey;
    CKeyBuf keyInit;

    _xDir->Seek( *pKeyStart, &keyInit, posKey );

    ciDebugOut (( DEB_ITRACE, "CreateRange %.*ws-%.*ws. Dir seek %.*ws, pid %d\n",
        pKeyStart->StrLen(), pKeyStart->GetStr(),
        pKeyEnd->StrLen(), pKeyEnd->GetStr(),
        keyInit.StrLen(), keyInit.GetStr(),
        keyInit.Pid() ));

    CPersDeComp* pCursor = new CPersDeComp( _xDir.GetReference(),
                                            GetId(),
                                            _xPhysIndex.GetReference(),
                                            posKey,
                                            keyInit,
                                            pKeyStart,
                                            _widMax);

    XPtr<CPersDeComp> xCursor( pCursor );

    const CKeyBuf * pKeyCurrent = pCursor->GetKey();
    if ( 0 == pKeyCurrent )
        return;

    PROPID pid = pKeyStart->Pid();

    curStk.Push(pCursor);
    xCursor.Acquire();

    ciDebugOut(( DEB_ITRACE, "First key  %.*ws, pid %d\n",
                pKeyCurrent->StrLen(), pKeyCurrent->GetStr(), pKeyCurrent->Pid() ));

    do
    {
        if (pid != pidAll)  // exact pid match
        {
            // skip wrong pids
            while (pid != pKeyCurrent->Pid())
            {
#if CIDBG == 1 //------------------------------------------
                if (pKeyCurrent)
                {
                    ciDebugOut(( DEB_ITRACE, "  skip: %.*ws, pid %d, wid %d\n",
                        pKeyCurrent->StrLen(),
                        pKeyCurrent->GetStr(),
                        pKeyCurrent->Pid(),
                        pCursor->WorkId() ));
                }
                else
                    ciDebugOut(( DEB_ITRACE, "   <NULL> key\n" ));
#endif  //--------------------------------------------------
                pKeyCurrent = pCursor->GetNextKey();
                if (pKeyCurrent == 0
                    || pKeyEnd->CompareStr(*pKeyCurrent) < 0 )
                    break;
            }
            // either pid matches or we have overshot
            // i.e. different pids and current string > end
        }

        if (pKeyCurrent == 0 || !pKeyEnd->MatchPid (*pKeyCurrent)
            || pKeyEnd->CompareStr (*pKeyCurrent) < 0 )
        {
            break;  // <--- LOOP EXIT
        }

        cMaxNodes--;

        if ( 0 == cMaxNodes )
        {
            ciDebugOut(( DEB_WARN, "Node limit reached in CPersIndex::CreateRange.\n" ));
            THROW( CException( STATUS_TOO_MANY_NODES ) );
        }

        // Clone the previous cursor...

        pCursor = new CPersDeComp(*pCursor);

        xCursor.Set( pCursor );

        // Add it to avoid memory leaks if GetNextKey fails

        curStk.Push(pCursor); // may be wrong pid

        xCursor.Acquire();

        // increment the added cursor

        pKeyCurrent = pCursor->GetNextKey();

#if CIDBG == 1
        if (pKeyCurrent)
        {
            ciDebugOut(( DEB_ITRACE, "   %.*ws, wid %d\n",
                pKeyCurrent->StrLen(), pKeyCurrent->GetStr(), pCursor->WorkId() ));
        }
        else
            ciDebugOut(( DEB_ITRACE, "   <NULL> key\n" ));
#endif

    } while ( pKeyCurrent );

    // Since we have one more cursor in curStk than we wanted...
    curStk.DeleteTop();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::Remove, public
//
//  Synopsis:   Remove index from storage
//
//  History:    02-May-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

void CPersIndex::Remove()
{
    _xPhysIndex->Close();
    _xDir->Close();
    _obj->Close();

    if ( !_storage.RemoveObject( ObjectId() ) )
    {
        DWORD dwError = GetLastError();
        ciDebugOut(( DEB_ERROR, "Delete of index %08x failed: %d\n",
                     ObjectId(), dwError ));
    }
}

#ifdef KEYLIST_ENABLED

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::AcquireRelevantWords, public
//
//  Synopsis:   Return relevant word key ids computed at the most recent
//              master merge.  The caller must delete the object returned.
//
//  Returns:    CRWStore *
//
//  History:    25-Apr-94   v-dlee      Created
//
//----------------------------------------------------------------------------

CRWStore * CPersIndex::AcquireRelevantWords()
{
    CRWStore *p = _pRWStore;

    ciDebugOut (( DEB_ITRACE,"CPersIndex::acquire _pRWStore: %lx\n",_pRWStore));

    _pRWStore = 0;

    return p;
} //AcquireRelevantWords

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::ComputeRelevantWords, public
//
//  Synopsis:   Compute and return relevant word key ids
//
//  Arguments:  [cRows]    -- # of wids in pwid array
//              [cRW]      -- max # of rw keys per wid
//              [pwid]     -- an array of wids in increasing order whose
//                            rw key ids are to be returned
//              [pKeyList] -- keylist to use in translation of keys to ids
//
//  Returns:    CRWStore *
//
//  History:    25-Apr-94   v-dlee      Created
//
//----------------------------------------------------------------------------

CRWStore * CPersIndex::ComputeRelevantWords(ULONG cRows,ULONG cRW,
                                            WORKID *pwid,CKeyList *pKeyList)
{
    ciDebugOut((DEB_ITRACE,"ComputeRelevantWords top\n"));

    //
    // Get the resources needed to do the computation
    //

    CRelevantWord RelWord(pwid,cRows,cRW);

    CPersIndexCursor indCur(this);
    CKeyListCursor keylCur(pKeyList);


    //
    // Walk through the index and find occurances of keys in the wids
    //
    const CKeyBuf * pKey, * pklKey;

    for (pKey = indCur->GetKey(), pklKey = keylCur->GetKey();
         pKey != 0; pKey = indCur->GetNextKey())
    {
        if (pKey->Pid() == pidContents &&
            ((CKeyBuf * const) pKey)->IsPossibleRW())
        {
            ULONG cWids = 0;

            for (WORKID wid = indCur->WorkId(); wid != widInvalid;
                 wid = indCur->NextWorkId())
            {
                cWids++;
                if (RelWord.isTrackedWid(wid))
                    RelWord.Add(wid,indCur->OccurrenceCount());
            }

            //
            // Walk the keylist until we match it up with where the
            // index cursor is.
            //
            while (pklKey->CompareStr(*pKey) != 0)
                pklKey = keylCur->GetNextKey();

            RelWord.DoneWithKey(pklKey->Pid(),MaxWorkId(),cWids);
        }
    }

    return RelWord.AcquireStore();
} //ComputeRelevantWords

#endif  // KEYLIST_ENABLED

//+---------------------------------------------------------------------------
//
//  Member:     CPersIndex::MakeBackupCopy
//
//  Synopsis:   Makes a copy of the index and directory using the storage
//              provided.
//
//  Arguments:  [storage] - Storage
//
//  History:    3-17-97   srikants   Created
//
//----------------------------------------------------------------------------

void CPersIndex::MakeBackupCopy( PStorage & storage,
                                 WORKID wid,
                                 PSaveProgressTracker & tracker )
{
    //
    // Create an index in the destination storage.
    //
    CPersIndex * pDstIndex = new CPersIndex( storage,
                                             wid,
                                             GetId(),
                                             _xPhysIndex->PageSize(),
                                             IsMaster() ? eMaster : eShadow );

    XPtr<CPersIndex> xDstIndex( pDstIndex );

    //
    // Make a backup copy of the stream.
    //
   _xPhysIndex->MakeBackupCopy( pDstIndex->_xPhysIndex.GetReference(),
                                tracker );

    // Make a backup copy of the directory.
    //
    _xDir->MakeBackupCopy( storage, tracker );                                             
}


#if CIDBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     CDiskIndex::VerifyContents, public
//
//  Synopsis:   Walks through an index and thus verifies each key
//
//  History:    28-Oct-94   DwightKr    Created
//
//----------------------------------------------------------------------------
void CDiskIndex::VerifyContents()
{

    //
    // Turn this on when we think we are missing keys.
    //

#if 0

    CKeyCursor *pCursor = QueryCursor();

    if ( pCursor )
    {
        TRY
        {
            ciDebugOut((DEB_ITRACE, "Verifying contents of new index\n"));
            WCHAR FirstLetter = '@';

            for ( const CKeyBuf * pKey = pCursor->GetKey();
                  pKey != NULL; pKey = pCursor->GetNextKey())
            {
                if ( *(pKey->GetStr()) != FirstLetter )
                {
                    FirstLetter = *(pKey->GetStr());
                    if ( FirstLetter < L'~' )
                        ciDebugOut(( DEB_NOCOMPNAME | DEB_ITRACE | DEB_PENDING, "%c",
                                     FirstLetter ));
                    else
                        ciDebugOut(( DEB_NOCOMPNAME | DEB_ITRACE | DEB_PENDING, "<%04x>",
                                     FirstLetter ));
                }
            }

            ciDebugOut(( DEB_NOCOMPNAME | DEB_ITRACE | DEB_PENDING, "\n" ));
        }
        CATCH (CException, e)
        {
            ciDebugOut(( DEB_ERROR, "Error 0x%x while verifying contents of new index\n", e.GetErrorCode() ));
        }
        END_CATCH

        delete pCursor;
    }

#endif  // 0

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\prtiflst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       PRTIFLST.CXX
//
//  Contents:   Partition Information List
//
//  Classes:
//
//  History:    16-Feb-94   SrikantS    Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "prtiflst.hxx"

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CPartInfo::CPartInfo( PARTITIONID partId )
    : _partId(partId)
{
    _widChangeLog       = widInvalid ;
    _widCurrMasterIndex = widInvalid ;
    _widNewMasterIndex  = widInvalid ;
    _widMMergeLog       = widInvalid ;

}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CPartInfoList::~CPartInfoList()
{
    CPartInfo * pNode = NULL;

    while ( (pNode = RemoveFirst()) != NULL ) {
        delete pNode;
    }
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CPartInfo* CPartInfoList::GetPartInfo( PARTITIONID partId )
{
    for ( CForPartInfoIter it(*this); !AtEnd(it); Advance(it) )
    {
        if ( it->GetPartId() == partId )
        {
            return it.GetPartInfo();
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\rwex.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       RWEX.CXX
//
//  Contents:   Relevant word extraction
//
//  Classes:    CRelevantWord, CRWStore, CRWHeap
//
//  History:    25-Apr-94        dlee      Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <rwex.hxx>

//+---------------------------------------------------------------------------
//
// Member:     CRWStore::CRWStore, public
//
// Synopsis:   Constructor for relevant word store
//
// Arguments:  [pwList]   -- array of work ids to operate over, must be in
//                           increasing order
//             [cWids]    -- # of items in pwList
//             [cIds]     -- # of relevant word key ids per wid to store
//
// History:    25-Apr-94     dlee       Created.
//
//----------------------------------------------------------------------------

CRWStore::CRWStore(WORKID *pwList,ULONG cWids,ULONG cIds)
    : _cWids(cWids), _cIds(cIds), _ulSearchLeftOff(0)
{
    _cbRow = _RowSize(cIds);

    for (ULONG x = 0; x < _cWids; x++)
    {
        SRWHeader *p = GetRow(x);
        p->wid = pwList[x];
        p->cItems = 0;
    }

} //CRWStore

//+---------------------------------------------------------------------------
//
// Member:     CRWStore::new, public
//
// Synopsis:   Private new operator
//
// Arguments:  [st]     -- predefined param
//             [cWids]  -- # of rows for the array
//             [cIds]   -- # of relevant word key ids per wid to store
//
// History:    25-Apr-94     dlee       Created.
//
//----------------------------------------------------------------------------

void * CRWStore::operator new(size_t st,ULONG cWids,ULONG cIds)
{
    return (void *) ::new char[_ObjectSize(cWids,cIds)];
} //new

#if _MSC_VER >= 1200
void CRWStore::operator delete(void * p, ULONG cWids, ULONG cIds)
{
    ::delete (p);
}
#endif

//+---------------------------------------------------------------------------
//
// Member:     CRWStore::Insert, public
//
// Synopsis:   Inserts a keyid in a wid's heap if the rank is sufficient.
//
// Arguments:  [wid]      -- wid on whose heap is operated
//             [keyid]    -- keyid to add
//             [lRank]   --  rank of the keyid in the wid
//
// History:    17-Jun-94     dlee       Created.
//
//----------------------------------------------------------------------------

void CRWStore::Insert(WORKID wid,KEYID keyid, LONG lRank)
{
    SRWHeader *ph = _Find(wid,GetRow(_ulSearchLeftOff),
                          _cWids - _ulSearchLeftOff);

    Win4Assert(ph != 0);

    //
    // This heap object is merely an accessor to a heap whose storage
    // has already been allocated.  The heap object operates on the heap
    // but does not own the heap's memory.
    //
    CRWHeap heap(ph,_cIds);
    heap.Insert(keyid,lRank);

    //
    // Start the next binary search one after where the last search
    // left off, since we know the wids will come through in sorted order.
    //
    _ulSearchLeftOff = _HeaderToRow(ph) + 1;
} //Insert

//+---------------------------------------------------------------------------
//
// Member:     CRWStore::_Find, private
//
// Synopsis:   Finds a wid's heap in the array of heaps given a wid
//
// Arguments:  [wid]      -- wid of heap to find
//             [base]     -- pointer to first element in heap array
//             [cRows]    -- # of rows in the array
//
// Returns:    pointer to the head of the heap for the wid or 0 if not found.
//
// History:    25-Apr-94     dlee       Created.
//
//----------------------------------------------------------------------------

SRWHeader * CRWStore::_Find(WORKID wid,SRWHeader *pBase,ULONG cRows)
{
    Win4Assert(cRows != 0);

    SRWHeader *lo = pBase;
    SRWHeader *hi = lo->Forward(cRows - 1,_cbRow);
    SRWHeader *mid;
    ULONG cHalf;

    while (lo <= hi)
    {
        if (cHalf = cRows / 2)
        {
           mid = lo->Forward((cRows & 1) ? cHalf : (cHalf - 1),_cbRow);
           if (wid == mid->wid)
           {
               return mid;
           }
           else if (wid < mid->wid)
           {
               hi = mid->Backward(1,_cbRow);
               cRows = (cRows & 1) ? cHalf : (cHalf - 1);
           }
           else
           {
               lo = mid->Forward(1,_cbRow);
               cRows = cHalf;
           }
        }
        else if (cRows != 0)
        {
            if (wid == lo->wid)
                return lo;
            else
                return 0;
        }
        else
        {
            break;
        }
    }

    return 0;
} //_Find

//+---------------------------------------------------------------------------
//
// Member:     CRWHeap::DeQueue, public
//
// Synopsis:   Removes the lowest-ranking keyid in the heap for a wid
//
// Returns:    keyid of the lowest-ranking member of the heap
//
// History:    25-Apr-94     dlee       Created.
//
//----------------------------------------------------------------------------

KEYID CRWHeap::DeQueue()
{
    ULONG ulL,ulR,ulMax;
    KEYID kRet = _ph->aItems[0].kKeyId;

    _ph->cItems--;

    //
    // Take out the bottom-right most leaf and bubble it down from
    // the top of the tree until it is less than its parent.
    //
    SRWItem iFix = _ph->aItems[_ph->cItems];
    ULONG ulPos = 0;

    while (!_IsLeaf(ulPos))
    {
        ulL = _Left(ulPos);
        ulR = _Right(ulPos);

        if (!_IsValid(ulR))
            ulMax = ulL;
        else
        {
            if (_ph->aItems[ulL].lRank < _ph->aItems[ulR].lRank)
                ulMax = ulL;
            else
                ulMax = ulR;
        }

        if (_ph->aItems[ulMax].lRank < iFix.lRank)
        {
            _ph->aItems[ulPos] = _ph->aItems[ulMax];
            ulPos = ulMax;
        }
        else
        {
            break;
        }
    }

    _ph->aItems[ulPos] = iFix;

    return kRet;
} //DeQueue

//+---------------------------------------------------------------------------
//
// Member:     CRWStore::Insert, public
//
// Synopsis:   Inserts an keyid in the rw heap for a wid if the keyid's rank
//             is greater than the lowest ranking keyid in the heap or if
//             the heap is not yet full.
//
// Arguments:  [keyid]    -- item to insert
//             [lRank]   -- rank of the keyid
//
// History:    25-Apr-94     dlee       Created.
//
//----------------------------------------------------------------------------

void CRWHeap::Insert(KEYID keyid, LONG lRank)
{
    if ((_ph->cItems < _ulMaxIds) ||
        (_ph->aItems[0].lRank < lRank))
    {
        //
        // Pop off the top element if the list is full
        //
        if (_ph->cItems == _ulMaxIds)
            DeQueue();

        //
        // Insert element as the rightmost bottom level leaf in the heap
        //
        ULONG ulPos = _ph->cItems++;
        _ph->aItems[ulPos].kKeyId = keyid;
        _ph->aItems[ulPos].lRank = lRank;

        //
        // bubble the element up until it fits correctly in the tree
        //
        while (ulPos)
        {
            ULONG ulParent = _Parent(ulPos);
            if (_ph->aItems[ulPos].lRank < _ph->aItems[ulParent].lRank)
            {
                //
                // swap the elements
                //
                SRWItem t = _ph->aItems[ulPos];
                _ph->aItems[ulPos] = _ph->aItems[ulParent];
                _ph->aItems[ulParent] = t;
                ulPos = ulParent;
            }
            else
            {
                break;
            }
        }
    }
} //Insert

//+---------------------------------------------------------------------------
//
// Member:     CRelevantWord::CRelevantWord, public
//
// Synopsis:   Constructor for the relevant word object
//
// Arguments:  [pwid]      -- array of wids in sorted order to track
//             [cWidsUsed] -- # of wids in the array
//             [cRW]       -- # of relevant words per wid to track
//
// History:    25-Apr-94     dlee       Created.
//
//----------------------------------------------------------------------------

CRelevantWord::CRelevantWord(WORKID *pwid,ULONG cWidsUsed,ULONG cRW)
    : _pWidItem(0), _pstore(0), _cWidsAdded(0)
{
    TRY
    {
        _pstore = new(cWidsUsed,cRW) CRWStore(pwid,cWidsUsed,cRW);

        _pWidItem = new SRWWidItem[cWidsUsed];
    }
    CATCH ( CException, e )
    {
        delete _pWidItem;
        delete _pstore;

        RETHROW();
    }
    END_CATCH
} //CRelevantWord

//+---------------------------------------------------------------------------
//
// Member:     CRelevantWord::~CRelevantWord
//
// Synopsis:   Destructor for the relevant word object
//
// History:    25-Apr-94     dlee       Created.
//
//----------------------------------------------------------------------------

CRelevantWord::~CRelevantWord()
{
    delete _pWidItem;
    delete _pstore; // may be 0
} //~CRelevantWord

//+---------------------------------------------------------------------------
//
// Member:     CRelevantWord::DoneWithKey, public
//
// Synopsis:   Computes rank for each wid occurance of a keyid and adjusts
//             the heaps appropriately
//
// Arguments:  [keyid]    -- keyid on which to calculate
//             [maxWid]   -- # docs on disk
//             [cWids]    -- # docs with key on disk
//
// History:    25-Apr-94     dlee       Created.
//
//----------------------------------------------------------------------------

void CRelevantWord::DoneWithKey(KEYID keyid,ULONG maxWid,ULONG cWids)
{
    if (0 != cWids)
    {
        _SetWidInfo(maxWid,cWids);

        for (ULONG x = 0; x < _cWidsAdded; x++)
        {
            Win4Assert(_pWidItem[x].wid != 0);
            _pstore->Insert(_pWidItem[x].wid,keyid,_Rank(_pWidItem[x].cOcc));
        }

        _pstore->DoneWithKey();

        _cWidsAdded = 0;
    }
    else
    {
        Win4Assert(0 == _cWidsAdded);
    }
} //DoneWithKey

//+-------------------------------------------------------------------------
//
//  Function:   _SortULongArray, private
//
//  Synopsis:   Sorts an array of unsigned longs from low to high
//
//  Arguments:  [pulItems]      -- list of IDs to be sorted
//              [cItems] -- # of root words to be sorted
//
//  Returns:    void
//
//  Algorithm:  Heapsort, not quick sort.  Give up 20% speed to save kernel
//              stack and prevent against n*n performance on sorted lists.
//
//  History:    14-Mar-94       Dlee    Created
//
//--------------------------------------------------------------------------

#define _CompUL(x,y) ((*(x)) > (*(y)) ? 1 : (*(x)) == (*(y)) ? 0 : -1)
#define _SwapUL(x,y) { ULONG _t = *(x); *(x) = *(y); *(y) = _t; }

inline static void _AddRootUL(ULONG x,ULONG n,ULONG *p)
{
    ULONG _x = x;
    ULONG _j = (2 * (_x + 1)) - 1;

    while (_j < n)
    {
        if (((_j + 1) < n) &&
            (_CompUL(p + _j,p + _j + 1) < 0))
            _j++;
        if (_CompUL(p + _x,p + _j) < 0)
        {
            _SwapUL(p + _x,p + _j);
            _x = _j;
            _j = (2 * (_j + 1)) - 1;
        }
        else break;
    }
} //_AddRootUL

void _SortULongArray(ULONG *pulItems,ULONG cItems)
{
    if (cItems == 0)
        return;

    long z;

    for (z = (((long) cItems + 1) / 2) - 1; z >= 0; z--)
    {
        _AddRootUL(z,cItems,pulItems);
    }

    for (z = cItems - 1; z != 0; z--)
    {
        _SwapUL(pulItems,pulItems + z);
        _AddRootUL(0,(ULONG) z,pulItems);
    }
} //_SortULongArray
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\resman.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       RESMAN.CXX
//
//  Contents:   Resource Manager
//
//  Classes:    CResManager
//
//  History:    08-Apr-91   BartoszM    Created
//              4-Jan-95    BartoszM    Separated Filter Manager
//              Jan-08-97   mohamedn    CFwEventItem and CDmFwEventItem
//              24-Feb-97   SitaramR    Push filtering
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cci.hxx>
#include <xact.hxx>
#include <pstore.hxx>
#include <cifailte.hxx>
#include <ciole.hxx>
#include <regevent.hxx>
#include <ciregkey.hxx>
#include <eventlog.hxx>
#include <cievtmsg.h>
#include <cifrmcom.hxx>
#include <fwevent.hxx>
#include <pidmap.hxx>
#include <identran.hxx>
#include <psavtrak.hxx>

#include "resman.hxx"
#include "ci.hxx"
#include "partn.hxx"
#include "pindex.hxx"
#include "mindex.hxx"
#include "idxids.hxx"
#include "indxact.hxx"
#include "merge.hxx"
#include "mmerglog.hxx"
#include "pendcur.hxx"
#include "fltstate.hxx"
#include "idle.hxx"
#include "notxact.hxx"
#include "lowres.hxx"

const ULONG lowDiskWaterMark = 3 * 512 * 1024; // 1.5 MB
const ULONG highDiskWaterMark = lowDiskWaterMark + 512 * 1024; // 2.0 MB
const ULONG minDiskFreeForMerge = lowDiskWaterMark;

class CRevertBoolValue {
public:
    CRevertBoolValue( BOOL & rfValue, BOOL fValue ) :
        _rfVal( rfValue ),
        _fRevert( TRUE )
    {
        Win4Assert( rfValue != fValue );
        _fPrevVal = _rfVal;
        _rfVal = fValue;
    }

    ~CRevertBoolValue()
    {
        if (_fRevert)
            _rfVal = _fPrevVal;
    }

    void Revert()
    {
        _rfVal = _fPrevVal;
        _fRevert = FALSE;
    }

private:
    BOOL &  _rfVal;
    BOOL    _fPrevVal;
    BOOL    _fRevert;
};


CMergeThreadKiller::CMergeThreadKiller( CResManager & resman )
    : _resman(resman), _fKill(TRUE)
{
}

CMergeThreadKiller::~CMergeThreadKiller()
{
    if ( _fKill )
    {
        _resman._fStopMerge = TRUE;
        _resman._thrMerge.Resume();
        _resman.StopMerges();
    }
}

//+---------------------------------------------------------------------------
//
//  Class:      CPendQueueTrans
//
//  Purpose:    Transaction for flushing the pending queue if there is a
//              failure while extracting entries out of the pending queue
//              and adding them to the changelog.
//
//  History:    9-11-95   srikants   Created
//
//----------------------------------------------------------------------------

class CPendQueueTrans : public CTransaction
{
public:

    CPendQueueTrans( CPendingQueue & pendQueue ) : _pendQueue( pendQueue )
    {
    }

    ~CPendQueueTrans()
    {
        if ( CTransaction::XActAbort == _status )
        {
            CLock lock( _pendQueue.GetMutex() );

            _pendQueue.LokFlushCompletedEntries();
        }
    }

private:

    CPendingQueue &     _pendQueue;

};

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::CResManager, public
//
//  Arguments:  [cat] -- catalog
//              [xact] -- transaction
//
//  History:    08-Apr-91   BartoszM    Created
//              Jan-07-96   mohamedn    CFwEventItem
//
//----------------------------------------------------------------------------

CResManager::CResManager(
        PStorage &storage,
        CCiFrameworkParams & params,
        ICiCDocStore * pDocStore,
        CI_STARTUP_INFO const & startupInfo,
        IPropertyMapper * pPropMapper,
        CTransaction& xact,
        XInterface<CIndexNotificationTable> & xIndexNotifTable )
:   _sigResman(eSigResman),
    _frmwrkParams( params ),
    _mergeTime(0),
    _storage ( storage ),
    _sKeyList(0),
    _idxTab( _storage.QueryIndexTable( xact ) ),
    _partList ( storage, *_idxTab, _sKeyList, xact, params ),
    _fresh ( storage, xact, _partList ),
    _partidToMerge ( partidInvalid ),
    _fStopMerge(FALSE),
    _pMerge(0),
#pragma warning( disable : 4355 )           // this used in base initialization
    _thrMerge ( MergeThread, this, TRUE ),  // create suspended
    _mergeKiller( *this ),
#pragma warning( default : 4355 )
    _activeDeletedIndex( _idxTab->GetDeletedIndex() ),
    _cQuery(0),
    _cFilteredDocuments(0),
    _pBackupWorkItem(0),
    _isBeingEmptied(FALSE),
    _isLowOnDiskSpace(FALSE),
    _isDismounted(FALSE),
    _isOutOfDate(FALSE),
    _isCorrupt(FALSE),
    _fFirstTimeUpdatesAreEnabled( TRUE ),
    _fPushFiltering( FALSE ),
    _fFlushWorkerActive( FALSE ),
    _configFlags( startupInfo.startupFlags ),
    _xIndexNotifTable( xIndexNotifTable.Acquire() ),
    _dwFilteringState( 0 ),
    _pFilterAgent( 0 )
{
    Win4Assert( 0 != pDocStore );

    //
    // Look for a resource monitor.  If none exists, use the default.
    //

    _xLowResDefault.Set( new CLowRes(_frmwrkParams) );

    SCODE sc = pDocStore->QueryInterface( IID_ICiCResourceMonitor,
                                          _xLowRes.GetQIPointer() );

    if ( FAILED(sc) )
    {
        _xLowResDefault->AddRef();
        _xLowRes.Set( _xLowResDefault.GetPointer() );
    }

    //


    //
    // The presence or absence of an actual pointer in _xIndexNotifTable,
    // indicates whether the client has specified pull filtering or push
    // filtering.
    //

    _fPushFiltering = !_xIndexNotifTable.IsNull();

    //
    // Initialize the resman in all the partitions.
    //
    CPartIter iter;
    for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList))
    {
        CPartition * pPart = iter.LokGet();
        pPart->SetResMan( this, FPushFiltering() );
    }

    if ( _fPushFiltering )
    {
        //
        // In push filtering, an identity translator is used
        //

        CIdentityNameTranslator *pIdentityTrans = new CIdentityNameTranslator();

        sc = pIdentityTrans->QueryInterface( IID_ICiCDocNameToWorkidTranslator,
                                             _translator.GetQIPointer() );
        Win4Assert( SUCCEEDED( sc ) );

        _translator->Release();              // QI does an AddRef
    }
    else
    {
        //
        // In pull filtering, the client provides the translator, which may
        // be the Ex version.
        //

        sc = pDocStore->QueryInterface( IID_ICiCDocNameToWorkidTranslatorEx,
                                        _translator2.GetQIPointer() );

        if ( SUCCEEDED(sc) )
            sc = _translator2->QueryInterface( IID_ICiCDocNameToWorkidTranslator,
                                               _translator.GetQIPointer() );
        else
            sc = pDocStore->QueryInterface( IID_ICiCDocNameToWorkidTranslator,
                                            _translator.GetQIPointer() );
    }

    if ( S_OK != sc )
        THROW( CException(sc) );

    //
    // Create a workIdToDocName converter object.
    //
    _xWorkidToDocName.Set( new CWorkIdToDocName( _translator.GetPointer(), _translator2.GetPointer() ) );

    ICiCAdviseStatus * pAdviseStatus;
    sc = pDocStore->QueryInterface( IID_ICiCAdviseStatus,
                                    (void **) & pAdviseStatus );
    if ( S_OK != sc )
        THROW( CException(sc) );

    _adviseStatus.Set( pAdviseStatus );
    _prfCounter.SetAdviseStatus( pAdviseStatus );

    ICiCPropertyStorage * pPropStore;
    sc = pDocStore->QueryInterface( IID_ICiCPropertyStorage,
                                    (void **) & pPropStore );
    if ( S_OK != sc )
        THROW( CException(sc) );

    _propStore.Set( pPropStore );

    pDocStore->AddRef();
    _docStore.Set( pDocStore );

    pPropMapper->AddRef();
    _mapper.Set( pPropMapper );

    ULONG mergeTime = _frmwrkParams.GetMasterMergeTime();
    _mergeTime = CMasterMergePolicy::ComputeMidNightMergeTime(mergeTime);

    if ( -1 == _mergeTime )
    {
       CFwEventItem   item(EVENTLOG_ERROR_TYPE,
                           MSG_CI_BAD_SYSTEM_TIME,
                           0);

       item.ReportEvent( _adviseStatus.GetReference() );

       THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    //
    // Restore the information associated with any master merge that
    // was stopped when the drive was dismounted.
    //
    _partList.RestoreMMergeState(*this, _storage);

    _partIter.LokInit( _partList );

    _isLowOnDiskSpace = LokCheckIfDiskLow( *this,
                                           _storage,
                                           _isLowOnDiskSpace,
                                           _adviseStatus.GetReference() );

    _thrMerge.SetPriority ( _frmwrkParams.GetThreadPriorityMerge() );

    _mergeKiller.Defuse();
    _thrMerge.Resume();

    //
    //  Set the merge progress indicator to 0, and refresh other counters
    //

    _prfCounter.Update( CI_PERF_MERGE_PROGRESS, 0 );

    LokUpdateCounters();

    //
    // Enable or disables updates/notifications based on disk space available
    // and whether the catalog is readonly
    //
    if ( _isLowOnDiskSpace || _storage.IsReadOnly() )
    {
        DisableUpdates( partidDefault );
        _state.LokSetState( eUpdatesDisabled );
    }
    else
    {
        EnableUpdates( partidDefault );
        SCODE sc = _docStore->EnableUpdates();
        if ( SUCCEEDED( sc ) )
           _state.LokSetState( eSteady );
        else
           _state.LokSetState( eUpdatesToBeEnabled );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::~CResManager, public
//
//  Synopsis:   Shuts down merge(s)
//
//  History:    13-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

CResManager::~CResManager()
{
    _workMan.AbortWorkItems();
    LokDeleteFlushWorkItems();
    _workMan.WaitForDeath();

    StopMerges();

    #if CIDBG==1
    // ======================================
    {
        CPriLock    lock(_mutex);
        Win4Assert( 0 == _pBackupWorkItem );
    }
    // ======================================
    #endif  // CIDBG==1
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::MergeThread, public
//
//  Synopsis:   Entry point for the thread responsible
//              for asynchronous merges
//
//  History:    05-Mar-92   BartoszM    Created
//
//----------------------------------------------------------------------------
DWORD WINAPI CResManager::MergeThread( void* self )
{
    if ( !((CResManager*)self)->_fStopMerge )
        ((CResManager*)self)->DoMerges();

    return 0;
}

//==============
// STATE CHANGES
//==============

//+---------------------------------------------------------------------------
//
//  Function:   Dismount
//
//  Synopsis:   Dismounts the catalog by stopping any in-progress merge
//              and also finishing off any pending writes ( eg. ChangeLog).
//
//  History:    6-20-94   srikants   Created
//
//----------------------------------------------------------------------------

NTSTATUS CResManager::Dismount()
{
    ciDebugOut(( DEB_ITRACE, "*** CI: Initiating DisMount ***\n" ));

    NTSTATUS status = STATUS_SUCCESS;

    TRY
    {
        //
        // Inform all the partitions to cleanup. We have to abort any
        // in-progress merges without having to take a lock. There could
        // be another thread (like the filter thread) with the lock doing
        // a long operation. In one case we had it trying to create a new
        // fresh test and the memory writer could not make any progress
        // because the merge was continuing to dirty the pages.
        //

        // There is no need to take a lock because the partitions are not
        // going away and the operation we are about to do is just turning
        // on a one-way flag.
        //
        {
            PARTITIONID partid = 1;
            CPartition* pPart = _partList.LokGetPartition ( partid );
            pPart->PrepareForCleanup();
        }

        //
        // Stop in progress merges.
        //

        StopMerges();

        //
        // Dismount each of the partitions.
        //
        // ================================================
        {
            CPriLock lock( _mutex );
            Win4Assert( !_isDismounted );

            _isDismounted = TRUE;

            CKeyList * pKeyList = _sKeyList.Acquire();
            delete pKeyList;

            CPartIter iter;
            for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList))
            {
                CPartition * pPart = iter.LokGet();

                // =======================================================
                CChangeTrans  xact( *this, pPart );

                if ( STATUS_SUCCESS == pPart->LokDismount( xact ) )
                {
                    xact.LokCommit();
                }
                //=========================================================
            }

            if ( _pBackupWorkItem )
                _pBackupWorkItem->GetSaveProgressTracker().SetAbort();
        }
        // ================================================

        _workMan.WaitForDeath();

    }
    CATCH( CException, e )
    {
        status = e.GetErrorCode();
        ciDebugOut(( DEB_ERROR,
            "ContentIndex Dismount Failed. Error Code 0x%X\n", status ));
    }
    END_CATCH

    ciDebugOut(( DEB_ITRACE, "*** CI: Completed DisMount ***\n" ));

    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   CResManager::Empty, public
//
//  Synopsis:   Releases resources associated with the resman object.  This
//              includes all indexes, the persistent freshlog, the persistant
//              changelog, the freshtest, and the master merge log.
//
//  History:    15-Aug-94   DwightKr    Created
//
//----------------------------------------------------------------------------
void CResManager::Empty()
{
    CPriLock lock( _mutex );

    _isBeingEmptied = TRUE;

    //
    //  Cancel any connections to the CI Filter service.
    //
    _pFilterAgent->LokCancel();

    //
    //  Delete everything from the index table here first.
    //
    _idxTab->LokEmpty();

    //
    //  If anything fails after this point, chkdsk /f or autochk will
    //  release the disk storage associated with the leaked objects
    //  since they are no longer part of the persistent index list.
    //

    //
    //  For each partition, zombify all indexes.
    //
    CPartIter iter;
    for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList))
    {
        CPartition* pPart = iter.LokGet();

        //
        //  Zombify all indexes in this partition, and delete them if their
        //  ref-count is 0.
        //
        CIndex ** aIndex = 0;
        TRY
        {
            unsigned cIndex;
            aIndex = pPart->LokZombify( cIndex );

            ReleaseIndexes( cIndex, aIndex, NULL );
        }
        CATCH ( CException, e )
        {
        }
        END_CATCH

        delete [] aIndex;

        //
        //  Delete the change log associated with this partition.  These
        //  routines do not throw exceptions.
        //
        WORKID widChangeLog = _partList.GetChangeLogObjectId( pPart->GetId() );
        if ( widChangeLog != widInvalid)
            _storage.RemoveObject( widChangeLog );

        WORKID widMMergeLog;
        WORKID widDummy;
        pPart->GetMMergeObjectIds( widMMergeLog, widDummy, widDummy );
        if ( widMMergeLog != widInvalid)
            _storage.RemoveObject( widMMergeLog );
    }

    _fresh.LokEmpty();          // Release storage associated with fresh test

    WORKID widFreshLog  = _storage.GetSpecialItObjectId( itFreshLog );

#ifdef KEYLIST_ENABLED
    WORKID widKeyList   = _storage.GetSpecialItObjectId( itMMKeyList );
#else
    WORKID widKeyList   = widInvalid;
#endif  //

    WORKID widPhrLat    = _storage.GetSpecialItObjectId( itPhraseLat );

    if ( widFreshLog != widInvalid)
        _storage.RemoveObject( widFreshLog );
    if ( widKeyList != widInvalid)
        _storage.RemoveObject( widKeyList );
    if ( widPhrLat != widInvalid)
        _storage.RemoveObject( widPhrLat );
}

//+---------------------------------------------------------------------------
//
//  Function:   StopCurrentMerge
//
//  Synopsis:   Aborts any in-progress merge.
//
//  History:    5-04-94   srikants   Created
//
//----------------------------------------------------------------------------

NTSTATUS CResManager::StopCurrentMerge()
{
    {
        CPriLock lock( _mutex );

        //
        // If we're doing a merge right now then kill it off.
        //

        if ( 0 != _pMerge )
            _pMerge->LokAbort();

    }

    return STATUS_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Member:      CResManager::DisableUpdates, public
//
//  Arguments:   [partid] -- partition id
//
//  History:     24-Dec-94  Anonymous   Created
//
//----------------------------------------------------------------------------
void CResManager::DisableUpdates( PARTITIONID partid )
{
    CPriLock lock( _mutex );
    CPartition * pPart = _partList.LokGetPartition( partid );

    Win4Assert( 0 != pPart );
    pPart->LokDisableUpdates();
}


//+---------------------------------------------------------------------------
//
//  Member:      CResManager::EnableUpdates, public
//
//  Arguments:   [partid]    -- partition id
//
//  History:     24-Dec-94  Anonymous   Created
//
//----------------------------------------------------------------------------
void CResManager::EnableUpdates( PARTITIONID partid )
{
    CPriLock lock( _mutex );
    CPartition * pPart = _partList.LokGetPartition( partid );

    Win4Assert( 0 != pPart );
    pPart->LokEnableUpdates( _fFirstTimeUpdatesAreEnabled );

    _fFirstTimeUpdatesAreEnabled = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   LokCheckIfDiskLow
//
//  Synopsis:   Checks if we are running low on free disk space. It has
//              a "LowWaterMark" and a "HighWaterMark".
//
//              If current state is "not full", then it will check to
//              see if the free disk space is < the LowWaterMark.
//
//              if current state is "full", then it will check to see if
//              the free disk space is < the HighWaterMark.
//
//              The HighWaterMark is > the LowWaterMark to prevent hysterisis.
//
//  Arguments:  [resman]         -- Resource manager
//              [storage]        -- Storage object.
//              [fCurrent]       -- Current state.
//              [adviseStatus]   -- reference to ICiCAdviseStatus
//
//  Returns:    TRUE if we are running low on disk space.
//              FALSE otherwise.
//
//  History:    10-11-94   srikants   Created
//              Jan-07-96  mohamedn   CFwEventItem
//
//----------------------------------------------------------------------------

BOOL LokCheckIfDiskLow( CResManager & resman,
                        PStorage & storage,
                        BOOL fIsCurrentFull,
                        ICiCAdviseStatus & adviseStatus )
{
    BOOL fLowOnDisk = fIsCurrentFull;

    TRY
    {
        __int64 diskTotal, diskRemaining;
        storage.GetDiskSpace( diskTotal, diskRemaining );

        if ( !fIsCurrentFull )
            fLowOnDisk = diskRemaining < lowDiskWaterMark;
        else
            fLowOnDisk = diskRemaining < highDiskWaterMark;

        //
        // It is okay to read it without mutex as it is only a heuristic.
        //
        if ( fLowOnDisk && !fIsCurrentFull && !storage.IsReadOnly() )
        {
            ciDebugOut(( DEB_WARN, "****YOU ARE RUNNING LOW ON DISK SPACE****\n"));
            ciDebugOut(( DEB_WARN, "****PLEASE FREE UP SOME SPACE        ****\n"));

            ULONG mbToFree = highDiskWaterMark/(1024*1024);

            ULONG mbIndex;
            resman.IndexSize( mbIndex );
            mbToFree = max( mbToFree, mbIndex );
            mbToFree = min( mbToFree, 50 ); // don't ask for more than 50 MB

            CFwEventItem item(  EVENTLOG_AUDIT_FAILURE,
                                MSG_CI_LOW_DISK_SPACE,
                                2);

            item.AddArg(storage.GetVolumeName() );
                        item.AddArg(mbToFree);

            item.ReportEvent(adviseStatus);
        }
        else if ( fIsCurrentFull && !fLowOnDisk )
        {
            ciDebugOut(( DEB_WARN, "****DISK SPACE FREED UP              ****\n"));
        }
    }
    CATCH( CException,e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Error 0x%X while getting disk space info\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    return ( fLowOnDisk );
}


//+---------------------------------------------------------------------------
//
//  Function:   NoFailFreeResources
//
//  Synopsis:   deletes a big wordlist and schedules refiltering
//
//  History:    6-Jan-95    BartoszM    Created
//
//----------------------------------------------------------------------------

void CResManager::NoFailFreeResources()
{
    ciDebugOut(( DEB_WARN, "Running out of resources.  " ));
    TRY
    {

        PARTITIONID partId = 1;

        CPriLock   lock(_mutex);
        CPartition * pPart = LokGetPartition( partId );


        //
        // Before calling remove word list, we must append any refiled
        // documents to the doc queue. This is because, the docqueue
        // can handle only one set of refiled documents.
        //
        {
            // =========================================
            CChangeTrans    xact( *this, pPart );
            pPart->LokAppendRefiledDocs( xact );
            xact.LokCommit();
            // =========================================
        }

        LokNoFailRemoveWordlist( pPart );
    }
    CATCH( CException, e )
    {
    }
    END_CATCH
}


//+-------------------------------------------------------------------------
//
//  Member:     CResManager::IsMemoryLow, private
//
//  Returns:    TRUE if we're in a low memory situation
//
//  History:    10-May-93 AmyA      Created from old DoUpdates
//               3-May-96 dlee      #if 0'ed it out because the memory
//                                  load # isn't reliable, and we've
//                                  got LOTS of other allocations anyway.
//              05-Nov-97 KyleP     New approach
//
//--------------------------------------------------------------------------

BOOL CResManager::IsMemoryLow()
{
    SCODE sc = _xLowRes->IsMemoryLow();

    if ( E_NOTIMPL == sc )
        sc = _xLowResDefault->IsMemoryLow();

    return ( S_OK == sc );
}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::IsIoHigh, private
//
//  Returns:    TRUE if the system is performing a 'lot' of I/O
//
//  History:    10-Dec-97  KyleP    Created
//
//  Notes:      This call takes time (~ 5 sec) to complete.
//
//--------------------------------------------------------------------------

BOOL CResManager::IsIoHigh()
{
    SCODE sc = _xLowRes->IsIoHigh( &_fStopMerge );

    if ( E_NOTIMPL == sc )
        sc = _xLowResDefault->IsIoHigh( &_fStopMerge );

    return ( S_OK == sc );
}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::IsBatteryLow, private
//
//  Returns:    TRUE if the system is running low on battery power.
//
//  History:    16-Jul-98  KyleP    Created
//
//  Notes:      By default, even 100% battery (as opposed to A/C) may be
//              considered low.
//
//--------------------------------------------------------------------------

BOOL CResManager::IsBatteryLow()
{
    SCODE sc = _xLowRes->IsBatteryLow();

    if ( E_NOTIMPL == sc )
        sc = _xLowResDefault->IsBatteryLow();

    return ( S_OK == sc );
}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::IsOnBatteryPower, private
//
//  Returns:    TRUE if the system is running on battery power.
//
//  History:    01-Oct-00  dlee    Created
//
//--------------------------------------------------------------------------

BOOL CResManager::IsOnBatteryPower()
{
    SCODE sc = _xLowRes->IsOnBatteryPower();

    if ( E_NOTIMPL == sc )
        sc = _xLowResDefault->IsOnBatteryPower();

    return ( S_OK == sc );
} //IsOnBatteryPower

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::SampleUserActivity, private
//
//  Returns:    - nothing -
//
//  History:    31 Jul 98  AlanW    Created
//
//--------------------------------------------------------------------------

void CResManager::SampleUserActivity()
{
    SCODE sc = _xLowRes->SampleUserActivity();

    if ( E_NOTIMPL == sc )
        _xLowResDefault->SampleUserActivity();

    return;
}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::IsUserActive, private
//
//  Arguments:  [fCheckLongTerm] - TRUE if long-term activity should be checked.
//
//  Returns:    TRUE if the interactive user is using the keyboard or mouse
//
//  History:    28 Jul 98  AlanW    Created
//
//--------------------------------------------------------------------------

BOOL CResManager::IsUserActive(BOOL fCheckLongTerm)
{
    SCODE sc = _xLowRes->IsUserActive(fCheckLongTerm);

    if ( E_NOTIMPL == sc )
        sc = _xLowResDefault->IsUserActive(fCheckLongTerm);

    return ( S_OK == sc );
}

//======================
//  STATE AND STATISTICS
//======================

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::CountPendingUpdates, public
//
//  Arguments:  [secCount (output)] -- Count of secondary Q Updates
//
//  Returns:    Count of pending updates.
//
//  History:    14-Dec-92 KyleP     Created
//
//  Notes:      If wordlists are being constructed the count may be low.
//
//--------------------------------------------------------------------------

unsigned CResManager::CountPendingUpdates(unsigned& secCount)
{
    CPriLock lock( _mutex );
    unsigned count = 0;
    CPartIter iter;
    secCount = 0;
    for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList))
    {
        count += iter.LokGet()->LokCountUpdates();

        secCount += iter.LokGet()->LokCountSecUpdates();
    }
    return(count + secCount);
}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::UpdateCounters, public
//
//  Returns:    Updates performance counters.
//
//  History:    05-Jan-95 BartoszM     Created
//
//--------------------------------------------------------------------------

void CResManager::LokUpdateCounters()
{
    if ( !_isDismounted )
    {
        _prfCounter.Update( CI_PERF_NUM_WORDLIST, _partList.LokWlCount() );

        unsigned cSecQDocuments;
        unsigned cUnfilteredDocs = CountPendingUpdates( cSecQDocuments );
        _prfCounter.Update( CI_PERF_FILES_TO_BE_FILTERED, cUnfilteredDocs );
        _prfCounter.Update( CI_PERF_DEFERRED_FILTER_FILES, cSecQDocuments );

        _prfCounter.Update( CI_PERF_NUM_UNIQUE_KEY, _sKeyList->MaxKeyIdInUse() );
        _prfCounter.Update( CI_PERF_DOCUMENTS_FILTERED, _cFilteredDocuments );

        ULONG cDocuments;
        GetClientState( cDocuments );
        _prfCounter.Update( CI_PERF_NUM_DOCUMENTS, cDocuments );
    }
}

//====================
// UPDATES AND QUERIES
//====================

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::ReserveUpdate, public
//
//  Arguments:  [wid] -- Used to confirm hint.
//
//  Returns:    Hint to position of reserved slot.
//
//  History:    30-Aug-95   KyleP       Created
//
//----------------------------------------------------------------------------

unsigned CResManager::ReserveUpdate( WORKID wid )
{
    CPriLock lock ( _pendQueue.GetMutex() );

    return _pendQueue.LokPrepare( wid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::UpdateDocument, public
//
//  Arguments:  [iHint]    -- Positional hint
//              [wid]      -- wid to add/delete
//              [partid]   -- partition containing this wid
//              [usn]      -- USN associated with change
//              [volumeId] -- Volume Id
//              [action]   -- addition / deletion
//
//  History:    08-Apr-91   BartoszM    Created
//              08-Oct-93   BartoszM    Rewrote to accept single document
//              30-Aug-95   KyleP       Use reserved slots
//
//----------------------------------------------------------------------------

SCODE CResManager::UpdateDocument( unsigned iHint,
                                   WORKID wid,
                                   PARTITIONID partid,
                                   USN usn,
                                   VOLUMEID volumeId,
                                   ULONG action )
{
    if ( !IsIndexingEnabled() )
        return CI_E_FILTERING_DISABLED;

    Win4Assert ( partid == 1 );

    //
    // Try to avoid lock contention
    // with filter agent
    //
    _pFilterAgent->SlowDown();


    CPriLock lock ( _mutex );

    BOOL fComplete;

    {
        CPriLock lock2( _pendQueue.GetMutex() );

        if ( _isBeingEmptied )          // The content index is empty
        {
            //
            // Just get rid of any pending entries in the queue.
            //
            if ( !_pendQueue.LokComplete( iHint, wid, usn, volumeId, partid, action ) )
            {
                while ( _pendQueue.LokRemove( wid, usn, volumeId, partid, action ) )
                    ;
            }
            return CI_E_SHUTDOWN;
        }

        //
        // The if clause triggers when this document is the only one
        // on the queue.
        //

        fComplete = _pendQueue.LokComplete( iHint, wid, usn, volumeId, partid, action );
    }

    SCODE sc = S_OK;

    if ( fComplete )
    {
        CPartition* pPart = _partList.LokGetPartition ( partid );

        CChangeTrans xact( *this, pPart );
        sc = pPart->LokUpdateDocument ( xact, wid, usn, volumeId, action, 1, 0 );
        xact.LokCommit();

        _pFilterAgent->LokWakeUp();
    }
    else
    {
        BOOL fGotOne = FALSE;

        CPendQueueTrans  pendQueueTrans( _pendQueue );

        while ( TRUE )
        {
            BOOL fGotAnother;

            {
                CLock lock2( _pendQueue.GetMutex() );
                fGotAnother = _pendQueue.LokRemove( wid, usn, volumeId, partid, action );
            }

            if ( fGotAnother )
            {
                fGotOne = TRUE;

                CPartition* pPart = _partList.LokGetPartition ( partid );

                CChangeTrans xact( *this, pPart );
                sc = pPart->LokUpdateDocument ( xact, wid, usn, volumeId, action, 1, 0 );
                xact.LokCommit();
            }
            else
                break;
        }

        pendQueueTrans.Commit();

        if ( fGotOne )
            _pFilterAgent->LokWakeUp();
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CResManager::FlushUpdates
//
//  Synopsis:   Flushes all update notifications to disk
//
//  History:    27-Jun-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CResManager::FlushUpdates()
{
    CPriLock lock( _mutex );
    CPartition * pPart = _partList.LokGetPartition( partidDefault );

    Win4Assert( 0 != pPart );

    pPart->LokFlushUpdates();
}


//+---------------------------------------------------------------------------
//
//  Member:     CResManager::QueryIndexes, public
//
//  Arguments:  [cPartitions]     -- count of partitions
//              [aPartID]         -- array of partition id's
//              [freshTest]       -- return arg.: fresh test
//              [cInd]            -- return arg: count of indexes
//              [cPendingUpdates] -- Pending update 'threshold'.  If fewer
//                                   pending updates, the pending wids are
//                                   returned in *pcurPending.
//              [pcurPending]     -- Pending cursors stored here.
//              [pFlags]          -- return arg: status of indexes
//
//  Returns:    Array of pointers to indexes
//
//  History:    08-Oct-91   BartoszM    Created
//
//  Notes:      Called by Query
//              Indexes and fresh test have ref count increased
//              Flags may change to indicate status of indexes
//
//----------------------------------------------------------------------------

CIndex** CResManager::QueryIndexes (
    unsigned cPartitions,
    PARTITIONID aPartID[],
    CFreshTest** freshTest,
    unsigned& cInd,
    ULONG cPendingUpdates,
    CCurStack * pcurPending,
    ULONG* pFlags )
{

    unsigned count = 0;
    CPartition* pPart;

    CPriLock lock ( _mutex );

    if ( _isCorrupt )
        THROW( CException( CI_CORRUPT_DATABASE ) );

    if ( _isBeingEmptied )   // Content index is empty or corrupt
    {
        cInd = 0;
        cPartitions = 0;

        return 0;
    }

    for ( unsigned i = 0; i < cPartitions; i++ )
    {
        pPart = _partList.LokGetPartition( aPartID [i] );
        count += pPart->LokIndexCount();
    }

    XArray<CIndex *> apIndex( count );

#if CIDBG || DBG
    unsigned j = 0;
#endif

    for ( i = 0; i < cPartitions; i++ )
    {
        pPart = _partList.LokGetPartition(aPartID [i]);

#if CIDBG || DBG
        j +=
#endif // CIDBG || DBG
        pPart->LokGetIndexes ( &apIndex[i] );

        if ( LokIsScanNeeded() && !_storage.IsReadOnly() )
            *pFlags |=  CI_NOT_UP_TO_DATE;

        //
        // If we're looking for pending updates, get them.  Otherwise just
        // set the out-of-date flag.
        //

        unsigned cPending = pPart->LokCountUpdates();

        cPending += pPart->LokCountSecUpdates();

        if ( cPending != 0 )
        {
            ULONG fFlags = CI_NOT_UP_TO_DATE;   // assume non-success

            if ( cPendingUpdates > 0 )
            {
                Win4Assert( 0 != pcurPending );

                if ( cPending <= cPendingUpdates )
                {
                    XArray<WORKID> pWid( cPending );

                    BOOL fSucceeded = pPart->LokGetPendingUpdates(
                                                    pWid.GetPointer(),
                                                    cPending );
                    if ( fSucceeded )
                    {
                        Win4Assert( cPending > 0 );

                        XPtr<CPendingCursor> xCursor( new CPendingCursor( pWid, cPending ) );
                        pcurPending->Push( xCursor.GetPointer() );
                        xCursor.Acquire();
                        fFlags = 0;
                    }
                }
            }
            *pFlags |= fFlags;
        }
    }

    //
    // Also check to see if we are actually in the process of filtering some
    // documents.
    //
    if ( _docList.Count() > 0 )
    {
        if ( _docList.Count() <= cPendingUpdates )
        {
            Win4Assert( 0 != pcurPending );

            XArray<WORKID> pWid( _docList.Count() );

            ciDebugOut((DEB_FILTERWIDS,
                       "CResManager::QueryIndexes - pending documents: %d %x\n",
                        _docList.Count(), pWid.GetPointer()));

            _docList.LokGetWids( pWid );
            XPtr<CPendingCursor> xCursor( new CPendingCursor( pWid, _docList.Count() ) );
            pcurPending->Push( xCursor.GetPointer() );
            xCursor.Acquire();
        }
        else
            *pFlags |= CI_NOT_UP_TO_DATE;
    }

    //
    // Also check documents pending notifcation that may be complete but
    // out-of-order.
    //

    {
        CPriLock lock( _pendQueue.GetMutex() );

        unsigned cwidPending = _pendQueue.LokCountCompleted();

        if ( cwidPending > 0 )
        {
            if ( cwidPending <= cPendingUpdates )
            {
                Win4Assert( 0 != pcurPending );

                XArray<WORKID> pWid( cwidPending );

                _pendQueue.LokGetCompleted( pWid.GetPointer() );

                XPtr<CPendingCursor> xCursor( new CPendingCursor( pWid, cwidPending ) );
                pcurPending->Push( xCursor.GetPointer() );
                xCursor.Acquire();
            }
            else
                *pFlags |= CI_NOT_UP_TO_DATE;
        }
    }

    //
    // Finally, check for pending scans.
    //

    if ( _isOutOfDate )
        *pFlags |= CI_NOT_UP_TO_DATE;

    Win4Assert ( j == count );

    *freshTest = _fresh.LokGetFreshTest();

    cInd = count;

    return apIndex.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::ReleaseIndexes, public
//
//  Synopsis:   Decrements ref counts, deletes if indexes
//              marked to be deleted.
//
//  Arguments:  [cInd] -- count of indexes
//              [apIndex] -- array of indexes
//              [freshTest] -- fresh test
//
//  History:    08-Oct-91   BartoszM    Created
//
//  Notes:      Takes ResMan lock
//
//----------------------------------------------------------------------------

void CResManager::ReleaseIndexes ( unsigned cInd, CIndex** apIndex,
    CFreshTest* pFreshTest )
{
    ciDebugOut (( DEB_ITRACE, "Release Indexes\n" ));

    CPriLock lock ( _mutex );

    for ( unsigned i = 0; i < cInd; i++ )
    {
        if ( apIndex[i] != 0 )
            LokReleaseIndex ( apIndex[i] );
    }

    if ( pFreshTest)
        _fresh.LokReleaseFreshTest (pFreshTest);
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::BackupContentIndexData
//
//  Synopsis:   Private method called by the merge thread to backup the
//              content index data. If successful, it sets the status of
//              the backup work item to indicate success. Otherwise, it
//              must be considered to have failed.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::BackupContentIndexData()
{
    Win4Assert( 0 != _pBackupWorkItem );

    ciDebugOut(( DEB_WARN, "Starting Backup of Ci Data\n" ));

    //
    // Create the backup object.
    //
    CPartition *pPartition =_partList.LokGetPartition ( partidDefault );

    CBackupCiPersData   backup( *_pBackupWorkItem,
                                *this,
                                *pPartition );

    // =========================================
    {
        CPriLock    lock(_mutex);
        backup.LokGrabResources();
    }
    // =========================================

    backup.BackupIndexes();

    // =========================================
    {
        CPriLock    lock(_mutex);
        backup.LokBackupMetaInfo();
        ciDebugOut(( DEB_WARN, "Completed Backup of Ci Data\n" ));
        _pBackupWorkItem->LokSetStatus( STATUS_SUCCESS );
    }
    // =========================================
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokUpdateBackupMergeProgress
//
//  Synopsis:   Updates the backup progress during the merge.
//
//  History:    3-20-97   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::LokUpdateBackupMergeProgress()
{
    Win4Assert( 0 != _pBackupWorkItem );

    CCiFrmPerfCounter counter( _adviseStatus.GetPointer(),
                               CI_PERF_MERGE_PROGRESS );
    DWORD dwMergeProgress = counter.GetCurrValue();

    //
    // Assuming Merge is half of the work, we will assume half
    // progress. So make the denominator 200 instead of 100.
    //
    if ( _pMerge )
    {
        const cShadowMergePart = 5;

        if ( _pBackupWorkItem->IsFullSave() )
        {
            if ( _pMerge->GetMergeType() != mtMaster )
            {
                //
                // The shadow merge preceding a master is approx. 5%
                // say.
                //
                dwMergeProgress = cShadowMergePart;
            }
            else
            {
                dwMergeProgress = min(dwMergeProgress + cShadowMergePart, 100);
            }
        }

        _pBackupWorkItem->LokUpdateMergeProgress( (ULONG) dwMergeProgress, 100 );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::BackupCIData
//
//  Synopsis:   External method to backup content index data. It creates
//              a backup work item and waits for the backup to complete.
//
//  Arguments:  [storage]         - Destination storage
//              [fFull]           - [in/out] Set to TRUE if a full merge is
//              needed on input; On output will be set to TRUE if a full
//              merge was done.
//              [progressTracker] - Progress tracker.
//
//  History:    3-18-97   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CResManager::BackupCIData( PStorage & storage,
                                 BOOL & fFull,
                                 XInterface<ICiEnumWorkids> & xEnumWorkids,
                                 PSaveProgressTracker & progressTracker )
{
    if ( !IsIndexMigrationEnabled() || !IsIndexingEnabled() )
        return CI_E_INVALID_STATE;

    SCODE sc = S_OK;

    Win4Assert( fFull );

    TRY
    {

        // ===================================================
        {
            CLock   lock(_mutex);
            if ( _isDismounted )
                THROW( CException( CI_E_SHUTDOWN ) );

            // There can be only one operation going on at a time.

            if ( 0 != _pBackupWorkItem )
                THROW( CException( CI_E_INVALID_STATE ) );

            _pBackupWorkItem = new CBackupCiWorkItem( storage,
                                                      fFull,
                                                      progressTracker );

            _eventMerge.Set();
        }
        // ===================================================

        ciDebugOut(( DEB_WARN, "Waiting for backup to complete\n" )) ;
        //
        // Wait for the work-item to be completed.
        //
        while ( TRUE )
        {
            DWORD const dwWaitTime = 1 * 60 * 1000; // 1 minute in millisecs
            _pBackupWorkItem->WaitForCompletion( dwWaitTime );

            //============================================================
            {
                CPriLock    lock(_mutex);
                if ( _pBackupWorkItem->LokIsDone() )
                    break;

                //
                // If there is a merge going on, we must update the progress.
                //
                if ( _pBackupWorkItem->LokIsDoingMerge() )
                    LokUpdateBackupMergeProgress();

                _pBackupWorkItem->LokReset();
            }
            //============================================================

        } // of while


        sc= _pBackupWorkItem->GetStatus();
        ciDebugOut(( DEB_WARN, "Backup completed with code 0x%X\n", sc ));
        if ( S_OK == sc )
        {
            fFull = _pBackupWorkItem->IsFullSave();
            xEnumWorkids.Set( _pBackupWorkItem->AcquireWorkIdEnum() );
        }

        // ====================================
        {
            CLock   lock(_mutex);
            delete _pBackupWorkItem;
            _pBackupWorkItem = 0;
        }
        // ====================================
    }
    CATCH( CException,e )
    {
        sc = HRESULT_FROM_WIN32( e.GetErrorCode() );
        Win4Assert( !"How Did we Come Here" );
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::CiState, public
//
//  Arguments:  [state] -- internal state of the CI
//
//  History:    01-Nov-95   DwightKr    Created
//
//
//----------------------------------------------------------------------------

#define setState( field, value ) \
    if ( state.cbStruct >= ( offsetof( CIF_STATE, field) +   \
                             sizeof( state.field ) ) )       \
    {                                                        \
        state.field = ( value );                             \
    }

#define roundup(a, b) ((a%b) ? (a/b + 1) : (a/b))

NTSTATUS CResManager::CiState(CIF_STATE & state)
{
    CPriLock lock( _mutex );

    if ( _isDismounted )
        return CI_E_SHUTDOWN;

    if ( _isCorrupt )
        return CI_CORRUPT_DATABASE;

    setState( cWordList, _partList.LokWlCount() );
    setState( cPersistentIndex, _partList.LokIndexCount() - state.cWordList );

    // Get the perf counter for the # of queries executed

    Win4Assert( !_adviseStatus.IsNull() );
    long cQ;
    _adviseStatus->GetPerfCounterValue( CI_PERF_TOTAL_QUERIES, &cQ );
    setState( cQueries, cQ );

    unsigned cSecQDocuments;
    ULONG cUnfilteredDocs = CountPendingUpdates(cSecQDocuments) + _docList.Count();
    setState( cDocuments, cUnfilteredDocs );
    setState( cSecQDocuments, cSecQDocuments );
    setState( cFreshTest, LokGetFreshCount() );

    CCiFrmPerfCounter counter( _adviseStatus.GetPointer(),
                               CI_PERF_MERGE_PROGRESS );
    setState( dwMergeProgress, (ULONG) counter.GetCurrValue() );

    setState( cFilteredDocuments, _cFilteredDocuments );
    unsigned size = roundup(_partList.LokIndexSize(), ((1024*1024)/CI_PAGE_SIZE));
    setState( dwIndexSize,  size);
    setState( cUniqueKeys, _sKeyList->MaxKeyIdInUse() );

    state.cbStruct = min( state.cbStruct, sizeof(state) );

    DWORD eCiState = _dwFilteringState;

    //
    //  Set each of the state bits independently.
    //

    //
    //  Are we in a shadow or master merge?
    //
    if ( 0 != _pMerge )
    {
        switch (_pMerge->GetMergeType() )
        {
        case mtShadow:
            eCiState |= CIF_STATE_SHADOW_MERGE;
            break;

        case mtAnnealing:
            eCiState |= CIF_STATE_ANNEALING_MERGE;
            break;

        case mtIncrBackup:
            eCiState |= CIF_STATE_INDEX_MIGRATION_MERGE;
            break;

        default:
            eCiState |= CIF_STATE_MASTER_MERGE;
            break;
        }
    }
    else
    {
        CPartition *pPartition = _partList.LokGetPartition ( partidDefault );

        if ( pPartition->InMasterMerge() )
            eCiState |= CIF_STATE_MASTER_MERGE_PAUSED;
    }

    if ( LokIsScanNeeded() )
        eCiState |= CIF_STATE_CONTENT_SCAN_REQUIRED;

    setState( eState, (CIF_STATE_FLAGS) eCiState );

    return STATUS_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::IndexSize
//
//  Synopsis:   Computes the size of the indexes in all partitions
//
//  Arguments:  [mbIndex] - On output, will have the size of all indexes
//              in MBs.
//
//  History:    4-15-96   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::IndexSize( ULONG & mbIndex )
{
    CLock   lock(_mutex);
    mbIndex = _partList.LokIndexSize() / ((1024*1024)/CI_PAGE_SIZE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokCheckWordlistQuotas, public
//
//  Synopsis:   Determine if we've reached wordlist capacity.
//
//  Returns:    TRUE if we have as much wordlist data in memory as
//              parameters allow.
//
//  History:    14-Jan-1999   KyleP      Created
//
//----------------------------------------------------------------------------

BOOL CResManager::LokCheckWordlistQuotas()
{
    CPartIter iter;

    for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList) )
    {
        CPartition* pPart = iter.LokGet();

        if ( pPart->LokCheckWordlistMerge() )
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::MarkCorruptIndex
//
//  Synopsis:   Marks the index as corrupt, disables updates in all partitions
//              and wakes up the merge thread to notify the framework client
//              about the corruption.
//
//  History:    1-30-97   srikants   Created
//
//----------------------------------------------------------------------------

NTSTATUS CResManager::MarkCorruptIndex()
{
    CPriLock    lock(_mutex);

    //
    // Disable updates in all partitions
    //
    CPartIter iter;
    for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList))
    {
        CPartition * pPart = iter.LokGet();
        pPart->LokDisableUpdates();
    }

    if ( _state.FLokCorruptionNotified() )
        return S_OK;

    _isCorrupt = TRUE;
    StopCurrentMerge();
    _eventMerge.Set();

    return S_OK;
}

//=====================
//             KEYINDEX
//=====================

#ifdef KEYLIST_ENABLED
//+---------------------------------------------------------------------------
//
//  Member:      CResManager::_AddRefKeyList, private
//
//  Synopsis:    Adds to refcount on the keylist
//
//  History:     07-Jul-94   dlee        Created
//
//----------------------------------------------------------------------------

CKeyList * CResManager::_AddRefKeyList()
{
    CPriLock lock( _mutex );
    _sKeyList->Reference();
    return _sKeyList.GetPointer();
}

//+---------------------------------------------------------------------------
//
//  Member:      CResManager::_ReleaseKeyList, private
//
//  Synopsis:    Release a refcount on the keylist
//
//  History:     07-Jul-94   dlee        Created
//
//----------------------------------------------------------------------------

void CResManager::_ReleaseKeyList()
{
    CPriLock lock( _mutex );

    _sKeyList->Release();

    if ( !_sKeyList->InUse() && _sKeyList->IsZombie() )
    {
        ciDebugOut(( DEB_ITRACE,
                     "Keylist %x unreferenced zombie.  Deleting\n",
                     _sKeyList->GetId() ));

        CKeyList * pKeyList = _sKeyList.Acquire();
        pKeyList->Remove();
        delete pKeyList;
    }
}

#endif  // KEYLIST_ENABLED

//+---------------------------------------------------------------------------
//
//  Member:      CResManager::KeyToId, public
//
//  Synopsis:    Maps from a key to an id.
//
//  Arguments:   [pkey] -- pointer to the key to be mapped to ULONG
//
//  Returns:     key id - a ULONG
//
//  History:     03-Nov-93   w-Patg      Created.
//               17-Feb-94   KyleP       Initial version
//
//----------------------------------------------------------------------------

ULONG CResManager::KeyToId( CKey const * pkey )
{

#ifdef KEYLIST_ENABLED
    CKeyList * pKeyList = _AddRefKeyList();

    ULONG kid = pKeyList->KeyToId( pkey );

    _ReleaseKeyList();

    return( kid );
#else
    return widInvalid;
#endif  // KEYLIST_ENABLED

}

//+---------------------------------------------------------------------------
//
//  Member:      CResManager::IdToKey, public
//
//  Synopsis:    Maps from an id to a key.
//
//  Arguments:   [ulKid] -- key id to be mapped to a key
//               [rkey] -- reference to the returned key
//
//  Returns:     void
//
//  History:     03-Nov-93   w-Patg      Created.
//               17-Feb-94   KyleP       Initial version
//
//----------------------------------------------------------------------------
void CResManager::IdToKey( ULONG ulKid, CKey & rkey )
{

#ifdef KEYLIST_ENABLED
    CKeyList * pKeyList = _AddRefKeyList();

    pKeyList->IdToKey( ulKid, rkey );

    _ReleaseKeyList();
#else
    rkey.FillMin();
#endif  // KEYLIST_ENABLED

}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::ComputeRelevantWords, public
//
//  Synopsis:   Computes and returns relevant words for a set of wids
//
//  Arguments:  [cRows]    -- # of rows to compute and in pwid array
//              [cRW]      -- # of rw per wid
//              [pwid]     -- array of wids to work over
//              [partid]   -- partition
//
//  History:    10-May-94 v-dlee  Created
//
//--------------------------------------------------------------------------

CRWStore * CResManager::ComputeRelevantWords(ULONG cRows,ULONG cRW,
                                             WORKID *pwids,
                                             PARTITIONID partid)
{
    CRWStore *prws = 0;

#ifdef KEYLIST_ENABLED

    CPriLock lock( _mutex );

    CPartition *pPart = LokGetPartition(partid);

    if (pPart != 0)
    {
        CPersIndex *pIndex= pPart->GetCurrentMasterIndex();

        if (pIndex != 0)
        {
            prws = pIndex->ComputeRelevantWords(cRows,cRW,pwids,
                                                _sKeyList.GetPointer() );
        }
    }
#endif  // KEYLIST_ENABLED

    return prws;
} //ComputeRelevantWords

//+-------------------------------------------------------------------------
//
//  Member:     CRWStore::RetrieveRelevantWords, public
//
//  Synopsis:   Retrieves relevant words already computed
//
//  Arguments:  [fAcquire] -- TRUE if ownership is transferred.
//              [partid]   -- partition
//
//  History:    10-May-94 v-dlee  Created
//
//--------------------------------------------------------------------------

CRWStore * CResManager::RetrieveRelevantWords(BOOL fAcquire,
                                              PARTITIONID partid)
{
    CRWStore *prws = 0;

#ifdef KEYLIST_ENABLED

    CPriLock lock( _mutex );

    CPartition *pPart = LokGetPartition(partid);

    if (pPart != 0)
    {
        prws = pPart->RetrieveRelevantWords(fAcquire);
    }
#endif  // KEYLIST_ENABLED

    return prws;
} //RetrieveRelevantWords



//================
// PRIVATE METHODS
//================



//+-------------------------------------------------------------------------
//
//  Member:     CResManager::CompactResources
//
//  History:    05-Jan-95 BartoszM     Created
//
//--------------------------------------------------------------------------

void CResManager::CompactResources()
{
    CPriLock lock( _mutex );

    CPartIter iter;
    for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList))
    {
        iter.LokGet()->LokCompact();
    }
}


 //=================================//
 //              MERGES             //
 //=================================//

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::DoMerges, private
//
//  History:    08-Apr-91   BartoszM    Created
//              25-Feb-92   BartoszM    Rewrote to use thread
//              30-Jun-97   KrishnaN    Calling docstore.FlushPropertyStore
//                                      before a shadow merge.
//              03-Mar-98   KitmanH     Don't merge if _storage is read-only
//
//  Notes:      Entry point for captive threads
//
//----------------------------------------------------------------------------

void CResManager::DoMerges()
{
    if ( _storage.IsReadOnly() )
       return;

    CCiFrmPerfCounter pPerIndexCounter( _adviseStatus.GetPointer(), CI_PERF_NUM_PERSISTENT_INDEXES );
    CCiFrmPerfCounter pIndexSizeCounter( _adviseStatus.GetPointer(), CI_PERF_INDEX_SIZE );
    CCiFrmPerfCounter pPendingCounter( _adviseStatus.GetPointer(), CI_PERF_FILES_TO_BE_FILTERED );
    CCiFrmPerfCounter pNumKeysCounter( _adviseStatus.GetPointer(), CI_PERF_NUM_UNIQUE_KEY);
    CCiFrmPerfCounter pWordListCounter(_adviseStatus.GetPointer(), CI_PERF_NUM_WORDLIST);
    CCiFrmPerfCounter pDeferredFilesCounter( _adviseStatus.GetPointer(), CI_PERF_DEFERRED_FILTER_FILES );

    XPtr<CIdleTime> xIdle( new CIdleTime() );

    //
    // Allow mount to complete before checking for merges. O/W we will
    // start a merge before the mount/startup is complete and it might
    // prevent a system from coming up.
    //

    const lowDiskPollTime = 1;  // 1 minute

    DWORD dwWaitTime = _isLowOnDiskSpace ? lowDiskPollTime : _frmwrkParams.GetMaxMergeInterval();

    _eventMerge.Wait(  dwWaitTime * 1000 * 60 );

    BOOL fAnnealing = FALSE;

    while ( !_fStopMerge )
    {
        BOOL fCorrupt = FALSE;

        ciDebugOut (( DEB_ITRACE, "\t|Merge Wakeup!\n" ));

        //
        // Book keeping chores.
        //
        BOOL    fBackupCiData = FALSE;
        BOOL    fBackupStarted = FALSE;

        TRY
        {
            // ===============================================
            CPriLock   lock(_mutex);

            if ( _isCorrupt  )
            {
               if ( !_state.FLokCorruptionNotified() )
                  LokNotifyCorruptionToClient();
            }
            else
            {
               //
               // Use low disk condition plus the current state to decide if
               // updates should be enabled or not
               //

               _isLowOnDiskSpace = LokCheckIfDiskLow( *this,
                                                      _storage,
                                                      _isLowOnDiskSpace,
                                                      _adviseStatus.GetReference() );
               if ( _isLowOnDiskSpace )
               {
                  if ( _state.LokGetState() != eUpdatesToBeDisabled
                       && _state.LokGetState() != eUpdatesDisabled )
                  {
                     _state.LokSetState( eUpdatesToBeDisabled );
                     _state.LokSetUpdateType( eIncremental );
                  }
               }
               else
               {
                  if ( _state.LokGetState() == eUpdatesDisabled )
                     _state.LokSetState( eUpdatesToBeEnabled );
               }

               if ( _state.LokGetState() == eUpdatesToBeDisabled )
                  LokNotifyDisableUpdatesToClient();
               else if ( _state.LokGetState() == eUpdatesToBeEnabled )
                  LokNotifyEnableUpdatesToClient();
            }

            fBackupCiData = 0 != _pBackupWorkItem;
            // ===============================================
        }
        CATCH( CException, e )
        {
            // ignore and try again the next time through the loop.
        }
        END_CATCH

        TRY
        {
            if ( !_isCorrupt && _partidToMerge != partidInvalid )
            {
                ciDebugOut (( DEB_ITRACE, "Forced merge in %ld\n",
                              _partidToMerge ));

                switch ( _mtForceMerge )
                {
                case CI_MASTER_MERGE:
                    MasterMerge ( _partidToMerge );
                    break;

                case CI_SHADOW_MERGE:
                    Merge( mtShadow, _partidToMerge );
                    break;

                case CI_ANNEALING_MERGE:
                    Merge( mtAnnealing, _partidToMerge );
                    break;

                case CI_ANY_MERGE:
                    break;  // Do nothing.  Let normal mechanism work it out.

                default:
                    Win4Assert( !"Invalid ForceMerge type" );
                }
            }

            if ( !_isLowOnDiskSpace && !_isCorrupt )
            {
                //
                // Refile the documents from the secondary queue to the primary
                // queue in pull filtering.
                //
                // ======================= lock ======================
                if ( !_fPushFiltering )
                {
                    CLock   lock(_mutex);
                    LokRefileSecQueueDocs();
                }
                // ======================= unlock ======================

                if ( fBackupCiData )
                {
                    BOOL fIsMasterPresent = FALSE;
                    BOOL fIsMMergeInProgress = FALSE;

                    //================================
                    {
                        CPriLock    lock(_mutex);
                        _pBackupWorkItem->LokSetDoingMerge();
                        fIsMasterPresent = LokIsMasterIndexPresent( partidDefault );
                        fIsMMergeInProgress = LokIsMasterMergeInProgress( partidDefault );
                    }
                    //================================

                    if ( _pBackupWorkItem->IsFullSave() ||
                         fIsMMergeInProgress ||
                         !fIsMasterPresent )
                    {
                        _pBackupWorkItem->SetDoingFullSave();
                        MasterMerge( partidDefault );
                    }
                    else
                    {
                        Merge( mtIncrBackup, partidDefault );
                    }

                    fBackupStarted = TRUE;
                    BackupContentIndexData();
                }
                else
                {
                    if ( fAnnealing )
                    {
                        fAnnealing = FALSE;

                        CPartIdStack partitionIds;
                        CheckAndDoMerge( mtAnnealing, partitionIds );

                        while ( partitionIds.Count() > 0 )
                           Merge( mtAnnealing, partitionIds.Pop() );
                    }

                    {
                        CPartIdStack partitionIds;
                        CheckAndDoMerge( mtShadow, partitionIds );

                        while ( partitionIds.Count() > 0 )
                        {
                            // Call FlushPropertyStore on DocStore to give it
                            // a chance to persist changes before a shadow merge.
                            _docStore->FlushPropertyStore();
                            Merge(  mtShadow, partitionIds.Pop() );
                        }
                    }

                    {
                        if ( CheckDeleteMerge( _partidToMerge != partidInvalid ) )
                        {
                            // Call FlushPropertyStore on DocStore to give it
                            // a chance to persist changes before a shadow merge.
                            _docStore->FlushPropertyStore();
                            Merge( mtDeletes, 1 );
                        }
                    }

                    BOOL fIsMasterPresent = FALSE;
                    BOOL fIsMMergeInProgress = FALSE;

                    //================================
                    {
                        CPriLock    lock(_mutex);
                        fIsMasterPresent = LokIsMasterIndexPresent( partidDefault );
                        fIsMMergeInProgress = LokIsMasterMergeInProgress( partidDefault );
                    }
                    //================================

                    {
                        CPartIdStack partitionIds;
                        CheckAndDoMerge( mtMaster, partitionIds );

                        while ( partitionIds.Count() > 0 )
                            MasterMerge( partitionIds.Pop() );
                    }
                }

            }
        }
        CATCH ( CException, e )
        {
            ciDebugOut (( DEB_ERROR,
                          "ResMan::DoMerges -- merge failed with 0x%x\n",
                          e.GetErrorCode() ));

            if ( IsDiskFull(e.GetErrorCode()) )
            {
                ciDebugOut(( DEB_ERROR, "***** DISK IS FULL *****\n" ));
                CPriLock   lock(_mutex);
                _isLowOnDiskSpace = LokCheckIfDiskLow( *this,
                                           _storage,
                                           _isLowOnDiskSpace,
                                           _adviseStatus.GetReference() );
            }
            else if ( IsCorrupt( e.GetErrorCode() ) )
            {
                Win4Assert( "!Merge failed, but not for low disk.  Why?" );
                fCorrupt = TRUE;
            }

            //
            // We have to prevent a master merge from being restarted
            // immediately. The reason for failure could be something like
            // out of disk space (typical reason) or log full. In either
            // case we will only be exacerbating the situation if we
            // restart immediately.
            //
            _eventMerge.Reset();

        }
        END_CATCH

        // ==========================================================
        {
            CPriLock lock( _mutex );

            Win4Assert( _partList.LokIndexCount() >= _partList.LokWlCount() );
            pPerIndexCounter.Update(_partList.LokIndexCount()-_partList.LokWlCount());
            pIndexSizeCounter.Update(_partList.LokIndexSize() / ((1024*1024)/CI_PAGE_SIZE) );

            pNumKeysCounter.Update(_sKeyList->MaxKeyIdInUse());

            pWordListCounter.Update(_partList.LokWlCount());

            _partidToMerge = partidInvalid;
            if ( _fStopMerge )
            {
                ciDebugOut(( DEB_ITRACE, "Stopping Merge\n" ));
                break;
            }

            if ( !_isCorrupt && ( _state.LokGetState() == eSteady ) && ( 0 != _pFilterAgent ) )
                _pFilterAgent->LokWakeUp();

            _eventMerge.Reset();   // sleep

            if ( fBackupStarted || _isCorrupt )
            {
                //
                // Set that backup to be complete even if it failed. Once
                // Backup starts, it either succeeds or fails but in either
                // case the operation is considered done.
                //

                if ( 0 != _pBackupWorkItem )
                {
                    if ( _isCorrupt )
                        _pBackupWorkItem->LokSetStatus( CI_CORRUPT_DATABASE );

                    _pBackupWorkItem->LokSetDone();
                }
            }
        }
        // ==========================================================

        BOOL fSteadyState = TRUE;

        if ( fCorrupt )
        {
            CPriLock lock(_mutex);
            _isCorrupt = TRUE;
            fSteadyState = _state.LokGetState() == eSteady;
        }

        unsigned cSecQCount;
        unsigned cPending = CountPendingUpdates( cSecQCount );

        //
        //  Wait for either the merge event to be signaled or the deadman timeout.
        //

        dwWaitTime = ( ( _isLowOnDiskSpace ) ||
                       ( !fSteadyState ) ||
                       ( 0 != cPending ) ) ?
                     lowDiskPollTime : _frmwrkParams.GetMaxMergeInterval();

        NTSTATUS Status = _eventMerge.Wait( dwWaitTime * 60 * 1000 );

        if ( !_isCorrupt )
        {
            unsigned PercentIdle = xIdle->PercentIdle();

            //
            // Are we idle enough to consider an annealing merge?
            //

            if ( STATUS_TIMEOUT == Status && PercentIdle >= _frmwrkParams.GetMinMergeIdleTime() )
            {
                ciDebugOut(( DEB_ITRACE, "Idle time for period: %u percent\n", PercentIdle ));
                fAnnealing = TRUE;
            }
        }

        if ( _fStopMerge )
        {
            ciDebugOut(( DEB_ITRACE, "Stopping Merge\n" ));
            break;
        }

        cPending = CountPendingUpdates( cSecQCount );

        pPendingCounter.Update(cPending);
        pDeferredFilesCounter.Update(cSecQCount);

        ciDebugOut (( DEB_ITRACE | DEB_PENDING,
                      "%d updates pending\n", cPending ));
    }

    // ===========================================
    {
        CPriLock    lock2(_mutex);
        if ( _pBackupWorkItem )
        {
            ciDebugOut(( DEB_WARN, "Forcing the backup to be done\n" ));
            _pBackupWorkItem->LokSetDone();
        }
    }
    // ===========================================
}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::StopMerges, private
//
//  Synopsis:   Aborts merge-in-progress (if any) and sets merge flag.
//
//  History:    13-Aug-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CResManager::StopMerges()
{
    {
        CPriLock lock( _mutex );

        _fStopMerge = TRUE;
        _eventMerge.Set(); // wake up

        //
        // If we're doing a merge right now then kill it off.
        //

        if ( 0 != _pMerge )
        {
            _pMerge->LokAbort();
        }
    }

    //
    // Wait for merge thread to die.
    //

    _thrMerge.WaitForDeath();
}


//+---------------------------------------------------------------------------
//
//  Member:     CResManager::CheckAndDoMerge, private
//
//  History:    08-Apr-91   BartoszM    Created
//
//  Notes:      Called by captive thread.
//
//----------------------------------------------------------------------------

void CResManager::CheckAndDoMerge( MergeType mt, CPartIdStack & partitionIds)
{
    if ( !IsBatteryLow() )
    {
        CPriLock lock( _mutex );
        ciDebugOut (( DEB_ITRACE, "check merge\n" ));
        CPartIter iter;

        for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList))
        {
            CPartition* pPart = iter.LokGet();

            if ( mt == mtMaster )
            {
                __int64 shadowIndexSize = pPart->LokIndexSize();
                CPersIndex * pMasterIndex = pPart->GetCurrentMasterIndex();
                if ( pMasterIndex )
                    shadowIndexSize -= pMasterIndex->Size();
    
                shadowIndexSize *= CI_PAGE_SIZE;
    
                CMasterMergePolicy mergePolicy( _storage, shadowIndexSize,
                                                LokGetFreshCount(),
                                                _mergeTime,
                                                _frmwrkParams,
                                                _adviseStatus.GetReference() );

                if ( mergePolicy.IsTimeToMasterMerge() ||
                     ( mergePolicy.IsMidNightMergeTime() &&
                       !IsOnBatteryPower() ) )
                    partitionIds.Push( pPart->GetId() );
            }
            else
            {
                if ( pPart->LokCheckMerge(mt) ||
                     ( IsMemoryLow() && pPart->LokCheckLowMemoryMerge() ) )
                {
                    #if CIDBG == 1
                    if ( !pPart->LokCheckMerge(mt) )
                    {
                        ciDebugOut(( DEB_WARN, "Merge due to low memory. %u wordlists, %u shadow.\n",
                                     pPart->WordListCount(), pPart->LokIndexCount() ));
                    }
                    #endif
                    partitionIds.Push( pPart->GetId() );
                }
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::CheckDeleteMerge, private
//
//  Synopsis:   Merge check for delete merge
//
//  Arguments:  [fForce] -- If TRUE, even 1 pending delete will force merge.
//
//  Returns:    TRUE if merge should be performed.
//
//  History:    12-Jun-97   KyleP       Created
//
//  Notes:      Called by captive thread.
//
//----------------------------------------------------------------------------

BOOL CResManager::CheckDeleteMerge( BOOL fForce )
{
    CPriLock lock( _mutex );
    ciDebugOut (( DEB_ITRACE, "check delete merge\n" ));

    //
    // A 'delete merge' occurs when enough documents have been deleted, and no
    // documents have been added or modified (which would cause a shadow merge).
    //

    return ( ( _fresh.LokDeleteCount() > _frmwrkParams.GetMaxFreshDeletes() ) ||
             ( fForce && _fresh.LokDeleteCount() > 0 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::Merge, private
//
//  Synopsis:   Perform a merge in partition
//
//  Arguments:  [partid] -- partition id
//              [mt]     -- Merge type
//
//  Signals:    CExcetpion
//
//  History:    08-Apr-91   BartoszM    Created
//              13-Nov-91   BartoszM    Rewrote using CMerge
//
//----------------------------------------------------------------------------

void CResManager::Merge( MergeType mt, PARTITIONID partid )
{
    ciDebugOut (( DEB_ITRACE, "%s", (mtDeletes == mt) ? "Delete merging: Have a quick stretch" :
                                                        "Shadow merging: Get a cup of coffee\n" ));

    CMerge Merge( *this, partid, mt );

    //
    // Perform resource acquisition under storage transaction.  If
    // aborted all persistent storage will be deleted by the storage
    // transaction.
    //
    {
        CPriLock lock ( _mutex );

        Win4Assert( _pMerge == 0 );

        if (_fStopMerge)
        {
            ciDebugOut(( DEB_ITRACE, "Stopping Merge\n" ));
            return;
        }

        Merge.LokGrabResources();  // may throw an exception

        //
        // Optimization: Don't merge zero indexes.
        //

        if ( 0 != Merge.LokCountOld() )
        {
            _pMerge = &Merge;
        }
        else if ( mtDeletes != mt )
        {
            ciDebugOut(( DEB_ITRACE, "Shadow merge of zero indexes.  Cancelled.\n" ));
            return;
        }

    }

    XPtr<CNotificationTransaction> xNotifyTrans;

    // Perform the merge under simple transaction
    // No lock held.
    {
        TRY
        {
            //
            // Perform merge, if necessary.
            //

            if ( 0 != Merge.LokCountOld() )
            {
                CCiFrmPerfCounter counter( _adviseStatus.GetPointer(), CI_PERF_MERGE_PROGRESS );
                Merge.Do( counter );

            }

            //
            // NotifTrans should be outside resman lock and the resman lock
            // is acquired in notifTran's destructor
            //
            xNotifyTrans.Set( new CNotificationTransaction( this,
                                  _xIndexNotifTable.GetPointer() ) );
        }
        CATCH ( CException, e )
        {
            CPriLock lock ( _mutex );
            Merge.LokRollBack();
            _pMerge = 0;

            // Really bad errors indicate the index is corrupt.

            SCODE scE = e.GetErrorCode();

            if ( STATUS_INTEGER_DIVIDE_BY_ZERO == scE ||
                 STATUS_ACCESS_VIOLATION       == scE ||
                 STATUS_IN_PAGE_ERROR          == scE )
            {
                ciDebugOut(( DEB_ERROR,
                             "Corrupt index, caught 0x%x\n", scE ));
                _storage.ReportCorruptComponent( L"ShadowMerge" );
                THROW( CException( CI_CORRUPT_DATABASE ) );
            }

            RETHROW();
        }
        END_CATCH
    }

    // nb: no failures allowed until CMergeTrans is constructed!

    CDiskIndex* pIndexNew = 0;
    { //=================== begin notification transaction =========================
        {
            CLock lock( _mutex );
            XPtr<CFreshTest> xFreshTestAtMerge;

            {
                _pMerge = 0;

                CMergeTrans Xact( *this, _storage, Merge );

                unsigned cIndOld  = Merge.LokCountOld();
                INDEXID* aIidOld  = Merge.LokGetIidList();
                pIndexNew = Merge.LokGetNewIndex();

                //
                // Write the new fresh test persistently to disk.
                //
                CPersFresh newFreshLog( _storage, _partList );
                CShadowMergeSwapInfo swapInfo;

                swapInfo._widNewFreshLog = _fresh.LokUpdate( Merge,
                                                             Xact,
                                                             newFreshLog,
                                                             pIndexNew ? pIndexNew->GetId() : iidInvalid,
                                                             cIndOld,
                                                             aIidOld,
                                                             xFreshTestAtMerge );

                swapInfo._widOldFreshLog =
                                    _storage.GetSpecialItObjectId( itFreshLog );
                swapInfo._cIndexOld = cIndOld;
                swapInfo._aIidOld = aIidOld;

                _partList.LokSwapIndexes( Xact,
                                          partid,
                                          pIndexNew,
                                          swapInfo );

                //
                // No failures allowed after this point on until the transaction
                // is committed.
                //
                Merge.ReleaseNewIndex();

                ciDebugOut (( DEB_ITRACE, "done merging\n" ));

                Xact.LokCommit();

#if CIDBG == 1
                if ( pIndexNew )
                    pIndexNew->Reference();
#endif
                //==========================================
            }

            ciFAILTEST( STATUS_NO_MEMORY );

            CPartition *pPartition =_partList.LokGetPartition ( partid );

            //
            // Delete the wids in the change log that have made it to
            // the new shadow index created in this merge. The algorithm
            // needs the latest fresh test, fresh test snapshoted at the
            // start of shadow merge and the doc list. If the latest fresh
            // test is the same as the fresh test at merge, then as an
            // optimization, the fresh test at merge is null. So, in the
            // optimized case, we use the latest fresh test as the fresh
            // test at merge.
            //

            CFreshTest *pFreshTestLatest = _fresh.LokGetFreshTest();
            CFreshTestLock freshTestLock( pFreshTestLatest );

            CFreshTest *pFreshTestAtMerge;
            if ( xFreshTestAtMerge.IsNull() )
                pFreshTestAtMerge = pFreshTestLatest;
            else
                pFreshTestAtMerge = xFreshTestAtMerge.GetPointer();

            //==========================================

            CChangeTrans xact( *this, pPartition );
            pPartition->LokDeleteWIDsInPersistentIndexes( xact,
                                                          *pFreshTestLatest,
                                                          *pFreshTestAtMerge,
                                                          _docList,
                                                          xNotifyTrans.GetReference() );
            xact.Commit();
        }

        xNotifyTrans.Free();
    } //=================== end notification transaction =========================

    #if CIDBG == 1
        if ( pIndexNew )
        {
            pIndexNew->VerifyContents();

            {
                CPriLock lock ( _mutex );
                LokReleaseIndex( pIndexNew );
            }
        }
    #endif

    _storage.CheckPoint();
} //Merge

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LogMMergeStartFailure
//
//  Synopsis:   Writes an eventlog message to indicate a MasterMerge could
//              not be started.
//
//  Arguments:  [fRestart]       - Indicates if this is a restarted master merge.
//              [storage]        - Storage reference
//              [error]          - Error code.
//              [adviseStatus]   - reference to ICiCAdviseStatus
//
//  History:    5-27-96   srikants   Created
//              Jan-07-96 mohamedn   CDmFwEventItem
//
//----------------------------------------------------------------------------

void CResManager::LogMMergeStartFailure( BOOL fRestart,
                                         PStorage & storage,
                                         ULONG error,
                                         ICiCAdviseStatus & adviseStatus)
{

    TRY
    {
        DWORD dwMsgCode = fRestart ?
                          MSG_CI_MASTER_MERGE_CANT_RESTART :
                          MSG_CI_MASTER_MERGE_CANT_START;


        CDmFwEventItem Item( EVENTLOG_AUDIT_FAILURE,
                             dwMsgCode,
                             2,
                             sizeof(error),
                             (void *)&error );
        Item.AddArg( storage.GetVolumeName() );
        Item.AddArg( error );

        Item.ReportEvent( adviseStatus );

    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in LogMMergeStartFailure\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
}


//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LogMMergePaused
//
//  Synopsis:   Writes an eventlog message that master merge was paused.
//
//  Arguments:  [storage]      - Storage
//              [error]        - Error which caused the merge to be paused.
//              [adviseStatus] - Advise status to use for notifying about the
//              event.
//
//  History:    1-24-97   srikants   Added header
//
//----------------------------------------------------------------------------

void CResManager::LogMMergePaused( PStorage & storage,
                                   ULONG error,
                                   ICiCAdviseStatus &adviseStatus)
{

    if ( IsCorrupt( error ) )
    {
        // don't log "paused" when there is corruption
        return;
    }

    TRY
    {

        CDmFwEventItem Item( EVENTLOG_INFORMATION_TYPE,
                             MSG_CI_MASTER_MERGE_ABORTED,
                             2,
                             sizeof(error),
                             (void *)&error );
        Item.AddArg( storage.GetVolumeName() );
        Item.AddArg( error );

        Item.ReportEvent( adviseStatus );

    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X in LogMMergePaused\n",
                     e.GetErrorCode() ));
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::MasterMerge, private
//
//  Synopsis:   Perform a MasterMerge in partition
//
//  Arguments:  [partid] -- partition id
//
//  Signals:    CException
//
//  History:    08-Apr-91   BartoszM    Created
//              13-Nov-91   BartoszM    Rewrote using CMerge
//              17-Feb-94   KyleP       Added keylist merge
//              Jan-07-96   mohamedn    CDmFwEventItem
//
//----------------------------------------------------------------------------

void CResManager::MasterMerge ( PARTITIONID partid )
{
    ciDebugOut (( DEB_ITRACE, "\n===MASTER MERGE===\n" ));

    //
    //  Force a shadow merge if we are not restarting a master merge.  This
    //  will force all word lists into persistent indexes.
    //
    BOOL    fMasterMergePaused = FALSE;

    //
    // Before starting the master merge, we have to swap the deleted index
    // iid. However, if there is a failure before we commit the beginning
    // of the master merge, we have to roll back this change. The
    // CDeletedIIDTrans object does this.
    //
    CDeletedIIDTrans    delIIDTrans( *this );
    INDEXID iidDelPreMerge = iidInvalid;

    {
        CPriLock lock ( _mutex );
        CPartition *pPartition = _partList.LokGetPartition ( partid );
        fMasterMergePaused = pPartition->InMasterMerge();
        if ( !fMasterMergePaused )
        {
            if ( 0 == LokGetFreshCount() )
            {
                //
                // There is no benefit in doing a master merge. Just return
                //
                return;
            }

            iidDelPreMerge = _activeDeletedIndex.GetIndex();
            delIIDTrans.LokLogNewDeletedIid( iidDelPreMerge,
                                             _activeDeletedIndex.GetNewIndex() );
            _activeDeletedIndex.SwapIndex();
        }
    }


    if ( !fMasterMergePaused )
    {
        //
        // First do a delete merge to finish merging all outstanding
        // word-lists into a persistent index.
        //
        // A delete merge will force an optimized null merge if there are
        // outstanding deletes in the fresh test which need to be logged.
        // This is an important case for Push filtering.  Since it doesn't
        // hurt in the other model, just keep the code identical.
        //

        Merge( mtDeletes, partid );
    }
    else
    {
        //
        // This is a restarted master merge. The _activeDeletedIndex contains
        // the "Post" master merge deleted index. The "New" one will be same
        // as the "Prev" one.
        //
        iidDelPreMerge = _activeDeletedIndex.GetNewIndex();

        CDmFwEventItem Item( EVENTLOG_INFORMATION_TYPE,
                             MSG_CI_MASTER_MERGE_RESTARTED,
                             1 );

        Item.AddArg( _storage.GetVolumeName() );
        Item.ReportEvent( _adviseStatus.GetReference() );

    }


    CMasterMerge Merge( *this, partid );

    TRY
    {
        CPriLock lock ( _mutex );

        Win4Assert( _pMerge == 0 );

        if ( _fStopMerge )
        {
            ciDebugOut(( DEB_ITRACE, "Stopping Merge\n" ));
            return;
        }

        ciFAILTEST( STATUS_NO_MEMORY );

        CPartition *pPartition =_partList.LokGetPartition ( partid );

        if ( !pPartition->InMasterMerge() )
        {
            Win4Assert( delIIDTrans.IsTransLogged() );
            Merge.LokGrabResources( delIIDTrans );     // may throw an exception
            if ( 0 == Merge.LokCountOld() )
            {
                ciDebugOut(( DEB_ITRACE, "Master merge of 0 indexes cancelled\n"));
                return;
            }
        }
        else
        {
            Merge.LokLoadRestartResources();
        }

        //
        // The deletionIIDTrans must be either committed or not logged at
        // all.
        //
        Win4Assert( !delIIDTrans.IsRollBackTrans() );

        _pMerge = &Merge;

    }
    CATCH( CException, e )
    {
        ciDebugOut(( DEB_ERROR, "Error 0x%X while starting a MasterMerge\n",
                     e.GetErrorCode() ));

        LogMMergeStartFailure( fMasterMergePaused,
                               _storage,
                               e.GetErrorCode(),
                               _adviseStatus.GetReference() );

        RETHROW();
    }
    END_CATCH


    // Perform the merge under simple transaction
    // No lock held.
    {
        TRY
        {
            // Perform merge
            CCiFrmPerfCounter counter( _adviseStatus.GetPointer(), CI_PERF_MERGE_PROGRESS );
            Merge.Do( counter );
        }
        CATCH ( CException, e )
        {
            CPriLock lock ( _mutex );
            Merge.LokRollBack();
            _pMerge = 0;

            LogMMergePaused( _storage,
                             e.GetErrorCode(),
                             _adviseStatus.GetReference() );
            RETHROW();
        }
        END_CATCH
    }

    CMasterMergeIndex* pMMergeIndex = 0;
    {
        CPriLock lock ( _mutex );
        {
            _pMerge = 0;

            unsigned cIndOld  = Merge.LokCountOld();
            INDEXID* aIidOld  = Merge.LokGetIidList();
            pMMergeIndex = Merge.LokGetMasterMergeIndex();

            CMergeTrans MergeTrans( *this, _storage, Merge );

            ciFAILTEST( STATUS_NO_MEMORY );

            //==========================================
            CMasterMergeTrans xact( *this,
                                    _storage,
                                    MergeTrans,
                                    pMMergeIndex,
                                    Merge );

            CPartition *pPart = LokGetPartition(partid);

            #ifdef KEYLIST_ENABLED
            pPart->SetRelevantWords(pMMergeIndex->AcquireRelevantWords());
            #endif  // KEYLIST_ENABLED

            //
            // Remove old indexes from fresh list after master merge
            //
            CPersFresh newFreshLog( _storage, _partList );

            CMasterMergeSwapInfo SwapInfo;

            SwapInfo._widNewFreshLog = _fresh.LokRemoveIndexes (
                                          MergeTrans,
                                          newFreshLog,
                                          cIndOld, aIidOld, iidDelPreMerge );

            SwapInfo._widOldFreshLog = _storage.GetSpecialItObjectId( itFreshLog );

            SwapInfo._cIndexOld = cIndOld;
            SwapInfo._aIidOld = aIidOld;
            SwapInfo._partid = partid;

            CKeyList const * pOldKeyList = _sKeyList.GetPointer();
            CKeyList const * pNewKeyList = Merge.LokGetNewKeyList();

            _partList.LokSwapIndexes( MergeTrans,
                                      partid,
                                      pMMergeIndex,
                                      SwapInfo,
                                      pOldKeyList,
                                      pNewKeyList );
            //
            // After this point, we must not resume the master merge even
            // if there is a soft failure.
            //
            Merge.ReleaseNewIndex();

#ifdef KEYLIST_ENABLED
            //
            // Get rid of the current KeyList and replace it with the
            // new KeyList
            //
            _storage.SetSpecialItObjectId( itMMKeyList, widInvalid );
            CKeyList * pKeyList = _sKeyList.Acquire();
            Win4Assert( 0 != pKeyList );
            _sKeyList.Set( Merge.LokGetNewKeyList() );
            Merge.LokReleaseNewKeyList();
            pKeyList->Zombify();

            if ( !pKeyList->InUse() )
            {
                pKeyList->Remove();
                delete pKeyList;
            }

#else
            CKeyList * pKeyList = _sKeyList.Acquire();
            Win4Assert( 0 != pKeyList );
            _sKeyList.Set( Merge.LokGetNewKeyList() );
            Merge.LokReleaseNewKeyList();
            delete pKeyList;
#endif  // KEYLIST_ENABLED

#if CIDBG == 1
            pMMergeIndex->Reference();
#endif
            xact.LokCommit();
            //==========================================

            ciDebugOut (( DEB_ITRACE, "done merging\n" ));
        }

        //
        // There is no need to compact the change log here because the
        // participants in the master merge are persistent indexes and
        // there will be no wids to be deleted from the change log when
        // persistent indexes are merged into another persistent index.
        //
    }

#if CIDBG == 1
    pMMergeIndex->VerifyContents();
    {
        CPriLock lock ( _mutex );
        LokReleaseIndex( pMMergeIndex );
    }
#endif

    _storage.CheckPoint();

    CDmFwEventItem Item( EVENTLOG_INFORMATION_TYPE,
                         MSG_CI_MASTER_MERGE_COMPLETED,
                         1 );
    Item.AddArg( _storage.GetVolumeName() );
    Item.ReportEvent( _adviseStatus.GetReference() );
}

//+---------------------------------------------------------------------------
//
//  Class:      CReleaseMMergeIndex
//
//  Purpose:    Class to acquire the ownernship of the target and current
//              master indexes during the destruction of a mastermerge index
//              and release the target and current indexes.
//
//  History:    9-29-94   srikants   Created
//
//----------------------------------------------------------------------------

class CReleaseMMergeIndex
{

public:

    CReleaseMMergeIndex( CResManager & resman, CMasterMergeIndex * mmIndex );

    ~CReleaseMMergeIndex();

private:

    CResManager &       _resman;
    CMasterMergeIndex * _pmmIndex;
    CPersIndex *        _pTargetMaster;
    CPersIndex *        _pCurrentMaster;
};

CReleaseMMergeIndex::CReleaseMMergeIndex( CResManager & resman,
                     CMasterMergeIndex * mmIndex ) :
                            _resman(resman),
                            _pmmIndex(mmIndex),
                            _pTargetMaster(0),
                            _pCurrentMaster(0)
{
    Win4Assert( _pmmIndex );
    Win4Assert( _pmmIndex->IsZombie() && !_pmmIndex->InUse() );
    _pmmIndex->AcquireCurrentAndTarget( &_pCurrentMaster, &_pTargetMaster );
    Win4Assert( 0 == _pCurrentMaster || _pCurrentMaster->IsZombie() );

    if ( 0 != _pCurrentMaster )
    {
        _pCurrentMaster->Reference();
    }

    Win4Assert( 0 != _pTargetMaster );
    _pTargetMaster->Reference();

}

CReleaseMMergeIndex::~CReleaseMMergeIndex()
{
    delete _pmmIndex;

    if ( 0 != _pCurrentMaster )
        _resman.LokReleaseIndex( _pCurrentMaster );

    _resman.LokReleaseIndex( _pTargetMaster );
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokReleaseIndex, private
//
//  Synopsis:   Decrements ref counts, deletes if index
//              marked to be deleted.
//
//  Arguments:  [pIndex] -- index to be released
//
//  History:    08-Oct-91   BartoszM    Created
//
//  Notes:      ResMan LOCKED
//
//----------------------------------------------------------------------------

void CResManager::LokReleaseIndex ( CIndex* pIndex )
{
    pIndex->Release();

    if ( pIndex->IsZombie() && !pIndex->InUse() )
    {
        CIndexId iid = pIndex->GetId();

        //
        //  If it is not a master index, it has to be removed from the
        //  Partition object. A master index would have been already removed
        //  when merge completed.
        //
        //  If we are in the Empty path, then we want to force all indexes
        //  to be deleted if their ref-count is 0.
        //

        if ( !pIndex->IsMaster() || _isBeingEmptied )
        {
            if ( !_isDismounted )
            {
                TRY
                {
                    _partList.LokRemoveIndex ( iid );
                }
                CATCH( CException, e )
                {
                    ciDebugOut(( DEB_ERROR,
                        "Index 0x%08x could not be deleted from index table\n",
                        iid ));
                }
                END_CATCH

                TRY
                {
                    // Must impersonate as system since query threads
                    // impersonating as a query user can't delete the
                    // files sometimes deleted when an index is released
                    // after a merge.  Impersonation can fail, which will
                    // leak the file on disk.

                    CImpersonateSystem impersonate;

                    if ( iid.IsPersistent() )
                        pIndex->Remove();
                }
                CATCH( CException, e )
                {
                    ciDebugOut(( DEB_ERROR,
                        "Index 0x%08x could not be deleted from disk, %#x\n",
                        iid, e.GetErrorCode() ));
                }
                END_CATCH
            }
            else
            {
                //
                // Zombie indexes are cleaned up after reboot.
                //
                //
                // After a dismount, we should not have any dirty streams
                // and releasing a persistent zombie index will update the
                // index table on disk. That is not allowed. This situation
                // happens only when queries have not been released and
                // shutdown is happening.
                //
                //
                ciDebugOut(( DEB_WARN,
                    "Index with iid 0x%X being released AFTER CI dismount\n",
                             iid ));
            }

            delete pIndex;
        }
        else
        {
            //
            // This must be a master merge index as no other master index
            // can be a zombie.
            //
            Win4Assert( pIndex->IsMasterMergeIndex() );
            CReleaseMMergeIndex mmIndexRel( *this,
                                            (CMasterMergeIndex *)pIndex );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LokReplaceMasterIndex
//
//  Synopsis:   Replaces the CMasterMergeIndex with the CPersIndex incarnation
//              of the target master index in the index list. Also prepares
//              the CMasterMergeIndex for removal from the in-memory index
//              list by zombifying it.
//
//  Arguments:  [pMMergeIndex] --  The target index in the CMasterMergeIndex
//              form.
//              [pNewMaster]   --  The CPersIndex form of the target index.
//
//  History:    6-30-94   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::LokReplaceMasterIndex ( CMasterMergeIndex* pMMergeIndex )
{
    Win4Assert( pMMergeIndex->IsMaster() && pMMergeIndex->IsZombie() );

    CPersIndex * pNewMaster = pMMergeIndex->GetTargetMaster();
    Win4Assert( pNewMaster->IsMaster() && !pNewMaster->IsZombie() );

    //
    // Delete the master merge index from the partition.
    //
    CIndexId iid = pMMergeIndex->GetId();
    CPartition * pPart = _partList.LokGetPartition( iid.PartId() );
    pPart->LokRemoveIndex ( iid );

    //
    // Check if there is a query in progress. If not, we can
    // go ahead and delete it. If a query is in progress, the
    // indexsnapshot of the query will delete it.
    //
    if ( !pMMergeIndex->InUse() )
    {
        Win4Assert( !pNewMaster->InUse() );
        pMMergeIndex->ReleaseTargetAndCurrent();
        delete pMMergeIndex;
    }

    //
    // Add the new master index to the partition object. This will
    // now be the only master accessible to new queries.
    //
    pPart->AddIndex( pNewMaster );

}


//
//+---------------------------------------------------------------------------
//
//  Function:   RollBackDeletedIIDChange
//
//  Synopsis:   Rolls back the changed made to the deleted iid during the
//              beginning of a master merge.
//
//  Arguments:  [xact] -  The transaction object which is rolling back the
//              change to the deleted iid.
//
//  History:    7-17-95   srikants   Created
//
//  Notes:      Consider the following sequence of events:
//
//  1. Pre-MasterMerge preparations : Change Deleleted IID to iidDeleted2 from
//     iidDeleted1.
//
//  2. Start a shadow merge.
//
//  3. Commit the beginning of a new MasterMerge
//
//  4. Complete the master merge .....
//
//  If there is a failure between steps 2 and 3, we just revert the deleted
//  IID back to iidDeleted2. Even if some entries were created in the fresh
//  list between steps 2 & 3 of the form, WID->iidDeleted2, it is okay. They
//  will get deleted from the fresh list on the second MasterMerge.
//
//----------------------------------------------------------------------------

void CResManager::RollBackDeletedIIDChange( CDeletedIIDTrans & xact )
{
    CPriLock   lock(_mutex);

    Win4Assert( _activeDeletedIndex.GetIndex() == xact.GetNewDelIID() );
    Win4Assert( _activeDeletedIndex.GetNewIndex() == xact.GetOldDelIID() );

    _activeDeletedIndex.SwapIndex();
}

//========================
//  FILTER RELATED METHODS
//========================



//+---------------------------------------------------------------------------
//
//  Function:   LokGetFilterDocs
//
//  Synopsis:   Gets documents from the change log for filtering. _docList
//              will be filled with the documents.
//
//  Arguments:  [cMaxDocs]        -- [in] Maximum number of docs to retrieve
//              [cDocs]           -- [out] Number of documents retrieved
//              [state]           -- [in/out] State of the document retrieval
//                                   progress.
//
//  Returns:    Number of documents in the docBuffer.
//
//  History:    6-16-94   srikants   Separated for making kernel mode call
//                                   Asynchronous.
//
//  Notes:      This function has two goals:
//
//              1. Select documents from different partitions in a round
//                 robin fashion.
//
//----------------------------------------------------------------------------

BOOL CResManager::LokGetFilterDocs ( ULONG cMaxDocs,
                                     ULONG & cDocs,
                                     CGetFilterDocsState & state )
{
    ciDebugOut(( DEB_ITRACE, "# CResManager::LokGetFilterDocs.\n" ));
    Win4Assert( state.GetTriesLeft() > 0 && state.GetTriesLeft() <=2 );

    cDocs = 0;
    Win4Assert ( !_isBeingEmptied );

    unsigned maxDocs = min( cMaxDocs, CI_MAX_DOCS_IN_WORDLIST);

    if ( _partIter.LokAtEnd() )
        return FALSE;      // There are no valid partitions

    // we are sure that the partition is valid
    CPartition* pPart = _partIter.LokGet();
    Win4Assert ( pPart != 0 );

    //
    // Don't bother looking for more documents to filter if there
    // are too many wordlists in memory -- wait until they are
    // merged.
    //
    if ( pPart->WordListCount() < _frmwrkParams.GetMaxWordlists() )
    {
        CChangeTrans  xact( *this, pPart );
        pPart->LokQueryPendingUpdates ( xact, maxDocs, _docList );
        xact.LokCommit();
    }
    else
    {
        ciDebugOut(( DEB_ITRACE,
                     "Too many wordlists.  Waking merge\n" ));
        _eventMerge.Set();
    }

    _docList.SetPartId ( pPart->GetId() );
    //==================================
    //
    // If there is a failure after this point, we have to re-add
    // the documents to the change log.
    //
    cDocs = _docList.Count();

    for (unsigned i = 0; i < cDocs; i++)
    {
        if (_docList.Status(i) != DELETED && _docList.Status(i) != WL_NULL)
            break;
    }

    BOOL fRetry = FALSE;

    if ( i == cDocs && i != 0 )
    {
        CIndexTrans  xact( *this );
        _fresh.LokDeleteDocuments ( xact, _docList, _activeDeletedIndex.GetIndex() );
        xact.LokCommit();
        cDocs = 0;
        _docList.LokClear();
        state.Reset();

        //
        // If we are doing a bunch of deletions in a "delnode" case,
        // we should see if the number of changed documents has exceeded
        // the max fresh test count and wake up the merge thread. Note
        // that we are not starting a merge here - the merge thread will
        // deal with the policy issues.
        //
        if ( LokGetFreshCount() > _frmwrkParams.GetMaxFreshCount() ||
             CheckDeleteMerge( FALSE ) )
        {
            _eventMerge.Set();
        }

        LokUpdateCounters();
    }

    _partIter.LokAdvance( _partList );
    if ( _partIter.LokAtEnd() )
    {
        _partIter.LokInit( _partList );
        state.DecrementTries();
        fRetry = (0 == cDocs) && (state.GetTriesLeft() > 0);
    }
    else
    {
        fRetry = ( 0 != cDocs );
    }

    Win4Assert( cDocs == _docList.Count() );

    return fRetry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::FillDocBuffer, public
//
//  Synopsis:   Fills buffer with strings for paths and properties of docs
//              to be filtered
//
//  Arguments:  [docBuffer] -- (in, out) buffer to be filled with document
//                             names.
//              [cb]        -- (in, out) count of bytes in docBuffer
//              [cDocs]     -- (out) count of # documents to filter
//              [state]     -- [in/out] State of the document retrieval
//                             progress.
//
//  History:    08-Apr-1991   BartoszM    Created
//              24-Nov-1992   KyleP       Retry pending documents
//              22-Mar-1993   AmyA        Split into several functions
//              22-Jan-1997   SrikantS    Changed doc. names to bytes for frame
//                                        work.
//              18-May-2000   KitmanH     Changed to push retried docs to filter
//                                        one by one
//
//----------------------------------------------------------------------------

void CResManager::FillDocBuffer( BYTE * docBuffer,
                                 ULONG & cb, ULONG & cDocs,
                                 CGetFilterDocsState & state )
{
    Win4Assert( docBuffer != 0 );

    // =========================================
    {
        CPriLock    lock(_mutex);
        _docList.LokSortOnWid();
    }
    // ==========================================

    unsigned cDocuments = _docList.Count();

    //
    // Format of the data
    // 4 Bytes remaining files count, 2 Bytes number of files. Following
    // that is (2 Bytes of Name Length in bytes, Name)*
    //

    if ( _fPushFiltering )
    {
        //
        // We can't take an exception while growing the aborted wids
        // array while doing exception processing in the filter manager.
        // So, pre-allocate the array now to insure we won't run out of
        // room later.  Now is a good time to die; later isn't.
        //

        CPriLock lock( _mutex );

        _aAbortedWids.LokReserve( cDocuments );

        //
        // In push filtering there are no refiles, and hence the buffer
        // cannot overflow. Check that the buffer can fit 16 documents.
        // A document name is the serialized form of the wid, i.e. it's
        // 4 bytes long. The buffer size is 4K.
        //

        Win4Assert( cb > 4 + 2 + 16 * (2 + 4) );
    }

    const cbLenField = sizeof(ULONG);

    Win4Assert( cb >= cbLenField );
    Win4Assert( sizeof(ULONG) == 4 );

    if ( cb < cbLenField )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    //
    // Fill the number of documents left in the changelog in the first
    // 4 bytes of the buffer.
    //
    // =========================================================
    {
        CPriLock lock( _mutex );
        ULONG partid = 1;  
        CPartition * pPart = _partList.LokGetPartition( partid );
        ULONG cDocsLeft = pPart->LokCountUpdates();
        RtlCopyMemory( docBuffer, &cDocsLeft, sizeof(ULONG) );
    }
    // =========================================================

    RtlZeroMemory( docBuffer + cbLenField, sizeof USHORT );

    const cbUSHORT = sizeof USHORT;

    BYTE * pCount = docBuffer + cbLenField;
    *pCount = 0;

    BYTE * pBuf = pCount + cbUSHORT;
    BYTE * pEnd = docBuffer + cb;

    cDocs = 0;

    // copy path/property pairs into buffer until we run out of either
    // buffer space or pairs. We stop filling the buffer if we encounter a
    // document that has a retry count > 1, we will fill the docBuffer with
    // these docs one at a time 

    ciDebugOut((DEB_FILTERWIDS | DEB_ITRACE,
               "CResManager::FillDocBuffer..."));

    unsigned cbExtraSpaceNeeded = 0;

    for (unsigned cSrcDocs = 0; cSrcDocs < cDocuments; cSrcDocs++)
    {
        //
        // Leave the first 2 bytes for the length field
        //
        unsigned cbPath = (unsigned)(pEnd - pBuf);

        if ( cbPath <= cbUSHORT )
        {
            // We would definitely need more space than a USHORT, but
            // we don't know how much right now. But since the filter
            // increases space by a PAGE, I guess we should do fine.
            cbExtraSpaceNeeded = cbUSHORT - cbPath + 1;
            break;
        }

        if (_docList.Status(cSrcDocs) == DELETED)
        {
            cbPath = 0;
            ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, " %dX",
                         _docList.Wid(cSrcDocs) ));
        }
        else
        {          
            if ( _docList.Retries(cSrcDocs) > 1 )
            {
                ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, 
                             "************FillDocBuffer: Retry count is %d. Wid is %d\n", 
                             _docList.Retries(cSrcDocs), 
                             _docList.Wid(cSrcDocs) ));
                ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, "cDocs is %d\n", cDocs ));

                if ( cDocs >  0 )
                {
                    //
                    // There is at least one document in the docBuffer. Stop
                    // now so we can file the doc(s) being retried one by one.
                    //
                    break;
                }
                else
                {
                    //
                    // Add the currenct doc. Stop if the current add is successful
                    //

                    //
                    // Make room for the length field at the beginning.
                    //
                    cbPath -= cbUSHORT;

                    ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, " %d",
                                 _docList.Wid(cSrcDocs) ));

                    unsigned cbPathIn = cbPath;

                    //
                    // If this is not the first try, then attempt to get a more
                    // accurate path.  We may be suffering from NTBUG: 270566
                    //

                    // changes cbPath.
                    if ( !WorkidToDocName( _docList.Wid(cSrcDocs),
                                           pBuf+cbUSHORT,
                                           cbPath,
                                           TRUE ) )
                    {
                        if ( cbPathIn < cbPath)
                        {
                            cbExtraSpaceNeeded = cbPath - cbPathIn;
                        }
                        break;
                    }

                    // cbPath = 0 if object has been deleted (not added to docBuffer)
                    if ( cbPath == 0 )
                    {
                        _docList.SetStatus( cSrcDocs, DELETED );
                        ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, "X" ));
                    }
                    else
                    {
                        ClearNonStoragePropertiesForWid( _docList.Wid(cSrcDocs) );
                        cSrcDocs++;
                        cDocs++;
                        USHORT uscb = (USHORT) cbPath;
                        RtlCopyMemory( pBuf, &uscb, cbUSHORT );
                        pBuf += (cbPath+cbUSHORT);
                        break;
                    }    
                }
            }
            else  // not retries
            {
                ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, 
                             "FillDocBuffer: Not retry for wid %d\n", 
                             _docList.Wid(cSrcDocs) ));

                //
                // Make room for the length field at the beginning.
                //
                cbPath -= cbUSHORT;

                ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, " %d",
                             _docList.Wid(cSrcDocs) ));

                unsigned cbPathIn = cbPath;

                // changes cbPath.
                if ( !WorkidToDocName( _docList.Wid(cSrcDocs),
                                       pBuf+cbUSHORT,
                                       cbPath,
                                       FALSE ) )
                {
                    if ( cbPathIn < cbPath)
                    {
                        cbExtraSpaceNeeded = cbPath - cbPathIn;
                    }
                    break;
                }

                // cbPath = 0 if object has been deleted
                if ( cbPath == 0 )
                {
                    _docList.SetStatus( cSrcDocs, DELETED );
                    ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, "X" ));
                }
                else
                {
                    cDocs++;
                    ClearNonStoragePropertiesForWid( _docList.Wid(cSrcDocs) );
                }
            }
        }

        USHORT uscb = (USHORT) cbPath;
        RtlCopyMemory( pBuf, &uscb, cbUSHORT );

        pBuf += (cbPath+cbUSHORT);
    }
    ciDebugOut (( DEB_FILTERWIDS | DEB_NOCOMPNAME, "\n" ));

    //
    // Fill in the count of the number of documents.
    //
    USHORT usFileCount = (USHORT) cSrcDocs;
    RtlCopyMemory( pCount, &usFileCount, cbUSHORT );


    if ( cSrcDocs < cDocuments )
    {
        if ( 0 == cSrcDocs && cbExtraSpaceNeeded > 0 )
        {
            // We need a larger buffer
            cb += cbExtraSpaceNeeded;
        }

        //
        // No refiling in push filtering
        //
        Win4Assert( !_fPushFiltering );

        ciDebugOut (( DEB_ITRACE, "Putting back documents\n" ));
        CDocList docListExtra;

        docListExtra.SetPartId( _docList.PartId() );

        for ( unsigned i = 0, j = cSrcDocs; j < cDocuments; i++, j++ )
        {
            ciDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, " %d", _docList.Wid(j) ));
            ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, "Refiling Wid %d\n", _docList.Wid(j) ));
            docListExtra.Set( i,
                              _docList.Wid(j),
                              _docList.Usn(j),
                              _docList.VolumeId(j) );
        }

        ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "\n" ));

        CPriLock   lock2(_mutex);

        docListExtra.LokSetCount(i);
        _docList.LokSetCount( cSrcDocs );

        ReFileCommit ( docListExtra );
    }

    //
    //  If we were unable to convert any of the wids to paths, then all of
    //  them have been deleted.
    //
    if ( 0 == cDocs )
    {
        ciDebugOut (( DEB_ITRACE, "All docs were deleted\n" ));

        CPriLock    lock3(_mutex);

        _docList.LokClear();
        state.Reset();
    }
    else
    {
        cb = (ULONG)(pBuf - docBuffer);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   NoFailReFile
//
//  Synopsis:   re-adds the documents to the change log witout committing
//
//  History:    6-16-94   srikants   Separated from FilterReady for making
//                                   kernel mode call Asynchronous.
//
//----------------------------------------------------------------------------

BOOL CResManager::NoFailReFile ( CDocList& docList )
{
    //
    // No refiling in push filtering
    //
    Win4Assert( !_fPushFiltering );

    CPriLock lock ( _mutex );

    if ( _isBeingEmptied )
        return FALSE;

    LokNoFailReFileChanges( docList );
    docList.LokClear();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReFileCommit
//
//  Synopsis:   re-adds the documents to the change log and commits
//              them to the change list.
//
//  History:    6-16-94   srikants   Separated from FilterReady for making
//                                   kernel mode call Asynchronous.
//
//----------------------------------------------------------------------------

BOOL CResManager::ReFileCommit ( CDocList& docList )
{
    //
    // No refiling in push filtering
    //
    Win4Assert( !_fPushFiltering );

    CPriLock lock ( _mutex );

    if ( _isBeingEmptied )
        return FALSE;

    LokNoFailReFileChanges( docList );
    docList.LokClear();

    //
    // The docqueue can handle only one set of refiled documents.
    // we MUST complete processing of the
    // refiled documents.
    //
    PARTITIONID partId = 1;    

    CPartition * pPart = LokGetPartition( partId );

    {
        // =========================================
        CChangeTrans    xact( *this, pPart );
        pPart->LokAppendRefiledDocs( xact );
        xact.LokCommit();
        // =========================================
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   LokNoFailReFileChanges
//
//  Synopsis:   Refiles the updates with the change log.
//
//  Arguments:  [docList] --  contains the documents to be added back to the
//              change log.
//
//  History:    5-16-94   srikants   Modified to deal with failures during
//                                   append of docs to change log.
//
//  Notes:      This CANNOT throw
//
//----------------------------------------------------------------------------

void CResManager::LokNoFailReFileChanges( CDocList& docList )
{
    //
    // No refiling in push filtering
    //
    Win4Assert( !_fPushFiltering );

    Win4Assert ( docList.PartId() == 1 );

    CPartition* pPart = _partList.LokGetPartition ( docList.PartId() );

    pPart->LokRefileDocs( docList );
    _pFilterAgent->LokWakeUp ();
}

//+-------------------------------------------------------------------------
//
//  Member:     CResManager::LokReFileDocument, public
//
//  Returns:    Put a document back on the quueue to be refiltered
//
//  History:    05-Jan-95 BartoszM     Created
//
//--------------------------------------------------------------------------

void CResManager::LokReFileDocument ( PARTITIONID partid,
                                      WORKID wid,
                                      USN usn,
                                      VOLUMEID volumeId,
                                      ULONG retries,
                                      ULONG secQRetries )
{
    //
    // No refiling in push filtering
    //
    Win4Assert( !_fPushFiltering );

    CPartition* pPart = _partList.LokGetPartition(partid);

    //==========================================
    CChangeTrans xact( *this, pPart );

    //
    // A usn of 0 is used for all refiled documents
    //
    pPart->LokUpdateDocument (xact, wid, 0, volumeId, CI_UPDATE_OBJ, retries, secQRetries);
    xact.LokCommit();
    //==========================================
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokAddToSecQueue
//
//  Synopsis:   Adds the given document to the secondary change log of the
//              partition.
//
//  Arguments:  [partid]       - PartitionId
//              [wid]          - WorkId of the document
//              [volumeId]     - Volume id
//              [cSecQRetries] - Sec Q Retry Count
//
//  History:    5-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::LokAddToSecQueue( PARTITIONID partid,
                                    WORKID wid,
                                    VOLUMEID volumeId,
                                    ULONG cSecQRetries )
{
    //
    // No refiling in push filtering
    //
    Win4Assert( !_fPushFiltering );

    CPartition* pPart = _partList.LokGetPartition(partid);

    //==========================================
    CChangeTrans xact( *this, pPart );
    pPart->LokAddToSecQueue (xact, wid, volumeId, cSecQRetries);
    xact.LokCommit();
    //==========================================
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokRefileSecQueueDocs
//
//  Synopsis:   Transfers the documents from the secondary queue to the primary
//              change queue.
//
//  History:    5-09-96   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::LokRefileSecQueueDocs()
{
    //
    // No refiling in push filtering
    //
    Win4Assert( !_fPushFiltering );

    CPartIter iter;
    for ( iter.LokInit(_partList); !iter.LokAtEnd(); iter.LokAdvance(_partList))
    {
        CPartition * pPart = iter.LokGet();

        //==========================================
        CChangeTrans    xact( *this, pPart );
        pPart->LokRefileSecQueue( xact );
        xact.LokCommit();
        //==========================================
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CResManager::LokTransferWordlist, public
//
//  Returns:    Transfer a wordlist from the filter manager
//              to the content index
//
//  History:    05-Jan-95 BartoszM     Created
//
//--------------------------------------------------------------------------

BOOL CResManager::LokTransferWordlist ( PWordList& pWordList )
{
    BOOL fSuccess = TRUE;
    PARTITIONID partid = _docList.PartId();
    CPartition* pPart = _partList.LokGetPartition(partid);
    INDEXID iid = pWordList->GetId();


    TRY
    {
        //==========================================
        CIndexTrans  xact( *this );

        //
        // LokDone can fail while trying to add unfinished docs to the
        // change log. In that case we must disable further USN updates.
        // We should commit the change transaction immediately after the
        // LokDone succeeds.
        //
        CChangeTrans changeXact( *this, pPart );
        pPart->LokDone ( changeXact, iid, _docList );
        ciFAILTEST( STATUS_NO_MEMORY );
        changeXact.LokCommit();

        _fresh.LokAddIndex ( xact, iid, _activeDeletedIndex.GetIndex(),
                             _docList, *pWordList );
        ciDebugOut (( DEB_ITRACE, "CFilterManager::FilterDone "
                    "Success: transfering wordlist\n" ));

        pWordList->Done();

        //
        // This may be an empty wordlist: all documents were deleted or in error.
        // If so, just get rid of the wordlist.
        //

        if ( pWordList->IsEmpty() )
        {
#if CIDBG == 1
            unsigned cShouldHaveData = 0;
            unsigned cDocuments = _docList.Count();

            for ( unsigned iDoc = 0; iDoc < cDocuments; iDoc++ )
            {
                switch ( _docList.Status(iDoc) )
                {
                case TOO_MANY_RETRIES:
                case SUCCESS:
                case TOO_MANY_BLOCKS_TO_FILTER:
                    cShouldHaveData++;
                    break;

                default:
                    break;
                }
            }

            if ( cShouldHaveData != 0 )
            {
                for ( unsigned iDoc = 0; iDoc < cDocuments; iDoc++ )
                {
                    ciDebugOut(( DEB_ERROR, "WID: 0x%x   STATUS: %d\n",
                                 _docList.Wid(iDoc), _docList.Status(iDoc) ));
                }
            }

            Win4Assert( cShouldHaveData == 0 );
#endif
            pWordList.Delete();
        }
        else
            pWordList.Transfer ( pPart );

        xact.LokCommit();

    }
    CATCH ( CException, e )
    {
        ciDebugOut(( DEB_ERROR,
                     "Exception 0x%x caught commiting wordlist.\n"
                     "delete wordlist and clear doclist\n",
                     e.GetErrorCode() ));
        fSuccess = FALSE;
    }
    END_CATCH

    _eventMerge.Set();  // wake up
    return fSuccess;
}


//+---------------------------------------------------------------------------
//
//  Function:   LokNoFailRemoveWordlist
//
//  Synopsis:   Removes the biggest wordlist from memory and adds the
//              documents back to the change log.
//
//  Requires:   _docList.Count() == 0  when this method is called. This
//              relies on the fact that there are no other outstanding
//              wordlists being constructed.
//
//  History:    10-20-94   srikants   Added the header section and modified
//                                    to deal with the change in refiling
//                                    documents.
//
//----------------------------------------------------------------------------

void CResManager::LokNoFailRemoveWordlist( CPartition * pPart )
{
    //
    // In push filtering, we don't delete completed wordlist to simplify
    // the logic of aborting the notification transaction on the client
    //
    if ( _isBeingEmptied || _fPushFiltering )
        return;

    //
    // Look for biggest wordlist
    //

    unsigned cInd;
    CIndex ** apIndex = pPart->LokQueryMergeIndexes( cInd, mtWordlist );
    XPtrST<CIndex *> xIndex( apIndex );

    unsigned size = 0;
    CWordList * pWordList = 0;

    for ( unsigned i = 0; i < cInd; i++ )
    {
        apIndex[i]->Release();

        if ( apIndex[i]->Size() > size )
        {
            Win4Assert( apIndex[i]->IsWordlist() );

            pWordList = (CWordList *)apIndex[i];
            size = pWordList->Size();
        }
    }


    if ( pWordList )
    {
        //
        // Reschedule contents for later filtering.
        //

        INDEXID iid = pWordList->GetId();
        ciDebugOut(( DEB_ITRACE,
                 "Removing wordlist %x to reduce resource consumption.\n",
                  iid ));

        CDocList _docList;
        _docList.SetPartId ( pPart->GetId() );

        pWordList->GetDocuments( _docList );

#if CIDBG == 1
        for ( unsigned cWid = 0; cWid < _docList.Count(); cWid++ )
        {
            ciDebugOut(( DEB_ITRACE, "Reschedule filtering of wid %d\n",
                         _docList.Wid( cWid ) ));
        }
#endif // CIDBG == 1

        LokNoFailReFileChanges ( _docList );

        //
        // Remove it
        //

        ciDebugOut(( DEB_WARN, "Deleting wordlist with USN (%x, %x).\n",
                 lltoHighPart(pWordList->Usn()), (ULONG) pWordList->Usn() ));

        pPart->LokRemoveIndex( iid );

        if ( !pWordList->InUse() )
        {
            _partList.LokRemoveIndex ( iid );
            delete pWordList;
        }
        else
        {
            pWordList->Zombify();
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CResManager::LokMakeWordlistId, public
//
//  Returns:    Makes unique wordlist id
//
//  History:    05-Jan-95 BartoszM     Created
//
//--------------------------------------------------------------------------

INDEXID CResManager::LokMakeWordlistId (PARTITIONID partid)
{
    CPartition* pPart = _partList.LokGetPartition(partid);

    if ( pPart == 0 )
        return iidInvalid;

    // Get unique index id
    INDEXID iid = pPart->LokMakeWlstId ();
    ciDebugOut((DEB_FILTERWIDS,
                "CResManager::LokMakeWorkListId - new wordlist iid: %x\n", iid));

    return iid;
}


//+-------------------------------------------------------------------------
//
//  Member:      CResManager::ReportFilterFailure, public
//
//  Synopsis:    Write to event log about unsuccessful filtering
//
//  Arguments:   [wid] -- workid of the file that couldn't be filtered
//
//  History:    05-Jan-95 BartoszM     Created
//
//--------------------------------------------------------------------------

void CResManager::ReportFilterFailure (WORKID wid)
{
    PROPVARIANT var;
    var.vt = VT_UI4;
    var.ulVal = wid;

    _adviseStatus->NotifyStatus( CI_NOTIFY_FILTERING_FAILURE,
                                 1,
                                 &var );
}


//=========
// SCANNING
//=========


//+---------------------------------------------------------------------------
//
//  Member:     CResManager::SetUpdateLost
//
//  Synopsis:   Sets that an update got lost and wakes up the merge thread
//              to notify the client about it.
//
//  Arguments:  [partId] - Partition id
//
//  History:    1-24-97   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::SetUpdatesLost( PARTITIONID partId )
{
    CPriLock    lock(_mutex);
    if ( _state.LokGetState() != eUpdatesToBeDisabled )
    {
       _state.LokSetState( eUpdatesToBeDisabled );
       _state.LokSetUpdateType( eIncremental );
       StopCurrentMerge();
       _eventMerge.Set();
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokCleanupForFullCiScan, public
//
//  History:    10-Nov-94   DwightKr    Created
//
//  Notes:      This routine performs the disk I/O and other operations
//              which does the cleanup after a corruption is detected.
//
//              This routine is similar to the Empty() method, except
//              that we do not delete the change log object or the
//              freshlog object, and the index list must contain
//              the change log and fresh log after the cleanup is complete.
//
//----------------------------------------------------------------------------
void CResManager::LokCleanupForFullCiScan()
{
    if ( 0 != _pMerge )                     // Stop in progress merges.
        _pMerge->LokAbort();

    //
    //  Delete everything from the index table here first.
    //
    _idxTab->LokEmpty();

    //
    //  If anything fails after this point, chkdsk /f or autochk will
    //  release the disk storage associated with the leaked objects
    //  since they are no longer part of the persistent index list.
    //

    //
    //  For each partition, zombify all indexes, and re-add the change
    //  log to the index table on disk.
    //
    CPartIter iter;
    for ( iter.LokInit(_partList);
         !iter.LokAtEnd();
          iter.LokAdvance(_partList))
    {
        CPartition* pPart = iter.LokGet();
        Win4Assert( pPart != NULL );

        pPart->LokDisableUpdates();

        //
        //  Zombify all indexes in this partition, and delete them if
        //  their ref-count is 0.
        //
        unsigned cIndex;
        CIndex ** aIndex = pPart->LokZombify( cIndex );
        ReleaseIndexes( cIndex, aIndex, NULL );

        delete [] aIndex;

        WORKID widMMergeLog;
        WORKID widDummy;
        pPart->GetMMergeObjectIds( widMMergeLog, widDummy, widDummy );
        if ( widMMergeLog != widInvalid)
            _storage.RemoveObject( widMMergeLog );

        //
        //  Empty the fresh test and the fresh log, and add it to the
        //  index table on disk.
        //
        pPart->LokEmpty();          // Release change list/log storage

        WORKID oidChangeLog = pPart->GetChangeLogObjectId();
        Win4Assert( oidChangeLog != widInvalid );
       _partList.LokAddIt( oidChangeLog, itChangeLog, pPart->GetId() );
    }

    //
    //  Empty the fresh test, fresh log, and add the fresh log to
    //  the index table on disk.
    //
    _fresh.LokInit();               // Release fresh test/log storage
    WORKID oidFreshLog = _storage.GetSpecialItObjectId(itFreshLog);
    Win4Assert( oidFreshLog != widInvalid );
    _partList.LokAddIt( oidFreshLog, itFreshLog, partidFresh1 );

#ifdef KEYLIST_ENABLED
    WORKID widKeyList = _storage.GetSpecialItObjectId( itMMKeyList );
#else
    WORKID widKeyList = widInvalid;
#endif  // KEYLIST_ENABLED

    WORKID widPhrLat  = _storage.GetSpecialItObjectId( itPhraseLat );

    if ( widKeyList != widInvalid)
    {
        _storage.RemoveObject( widKeyList );
        _storage.SetSpecialItObjectId( itMMKeyList, widInvalid );
    }

    if ( widPhrLat != widInvalid)
    {
        _storage.RemoveObject( widPhrLat );
        _storage.SetSpecialItObjectId( itPhraseLat, widInvalid );
    }

    _isBeingEmptied = FALSE;                // Allow new queries
}

// ===========================================================
// Content Index Frame Work Interfacing.
// ===========================================================

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::WorkidToDocName
//
//  Synopsis:   Converts the given workid to path and fill it in the buffer
//              given.
//
//  Arguments:  [wid]       -- Workid to convert.
//              [pbBuf]     --  Destination buffer;
//              [cb]        -- On input the total number of bytes that can be
//                             put. On output, the actual number of bytes copied.
//                             For a deleted file, the cb will be 0.
//              [fAccurate] -- TRUE --> Attempt to get a more accurate
//                             workid-to-path translation.
//
//  Returns:    TRUE if successfully converted; FALSE means the buffer was
//              not big enough.
//
//  History:    12-04-96   srikants   Created
//
//  Notes:      WorkidToDocName is called outside the resman lock. It is a
//              potentially long operation and taking resman lock is not
//              advisable. Also, creation of a CWorkidToDocName object once
//              for each wid->docName conversion is expensive. So, we create
//              one in resman constructor and protect it with a separate
//              lock.
//
//----------------------------------------------------------------------------

BOOL CResManager::WorkidToDocName( WORKID wid,
                                   BYTE * pbBuf,
                                   unsigned & cb,
                                   BOOL fAccurate )
{

    CLock   lock(_workidToDocNameMutex);

    ULONG cbDocName;

    BYTE const * pbDocName = _xWorkidToDocName->GetDocName( wid, cbDocName, fAccurate );

    BOOL fStatus = TRUE;

    if ( pbDocName )
    {
        ciDebugOut(( DEB_FILTERWIDS | DEB_NOCOMPNAME, 
                     "WorkidToDocName: wid is %d and DocName is %ws\n",
                     wid, 
                     pbDocName ));

        if ( cbDocName > cb )
            fStatus = FALSE;
        else
            RtlCopyMemory( pbBuf, pbDocName, cbDocName );

        cb = cbDocName;
    }
    else
    {
        cb = 0;
    }

    return fStatus;
} // WorkidToDocName

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::GetClientState
//
//  Synopsis:   Gets the client specific status information like total
//              number of documents.
//
//  Arguments:  [cDocuments]    - [out] Total # of documents
//
//  History:    12-04-96   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::GetClientState( ULONG & cDocuments )
{
    CI_CLIENT_STATUS    status;
    SCODE sc = _docStore->GetClientStatus( &status );
    if ( S_OK == sc )
    {
        cDocuments = status.cDocuments;
    }
    else
    {
        cDocuments = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokNotifyCorruptionToClient
//
//  Synopsis:   Informs the client that the catalog is corrupt
//
//  History:    12-04-96   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::LokNotifyCorruptionToClient()
{
    Win4Assert( _isCorrupt );

    DisableUpdates( partidDefault );

    SCODE sc = _docStore->DisableUpdates( FALSE, CI_CORRUPT_INDEX );
    if ( SUCCEEDED( sc ) )
        _state.LokSetCorruptionNotified();

    //
    // Disabled following assert so that the general NT 5 user is not
    // bothered by this assert.
    //

    //Win4Assert( ! "We must empty the Content Index" );
    // Empty();
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokNotifyDisableUpdatesToClient
//
//  Synopsis:   Informs the client that updates should be disabled
//
//  History:    07-05-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CResManager::LokNotifyDisableUpdatesToClient()
{
    Win4Assert( _state.LokGetState() == eUpdatesToBeDisabled );

    DisableUpdates( partidDefault );
    BOOL fIncremental = _state.LokGetUpdateType() == eIncremental;

    SCODE sc = _docStore->DisableUpdates( fIncremental, CI_LOST_UPDATE );
    if ( SUCCEEDED(sc) )
    {
        ciDebugOut(( DEB_WARN, "Notified disabled updates to DocStore\n" ));
        _state.LokSetState( eUpdatesDisabled );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::LokNotifyEnableUpdatesToClient
//
//  Synopsis:   Informs the client that updates should be enabled
//
//  History:    07-05-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CResManager::LokNotifyEnableUpdatesToClient()
{
   Win4Assert( _state.LokGetState() == eUpdatesToBeEnabled );
   EnableUpdates( partidDefault );

   SCODE sc = _docStore->EnableUpdates();
   if ( SUCCEEDED(sc) )
   {
      ciDebugOut(( DEB_WARN, "Notified enable updates to DocStore\n" ));
      _state.LokSetState( eSteady );
   }
}

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::StoreValue
//
//  Synopsis:   Stores the given value in the document store
//
//  Arguments:  [wid] - WorkId of the document
//              [ps]  - The FULLPROPSPEC of the property
//              [var] - Value of the property
//              [fInSchema] - Returns TRUE if the property is in the schema
//
//  Returns:    SCODE result
//
//  History:    12-18-96   srikants   Created
//
//----------------------------------------------------------------------------

SCODE CResManager::StoreValue( WORKID wid,
                               CFullPropSpec const & ps,
                               CStorageVariant const & var,
                               BOOL & fInSchema )
{
    FULLPROPSPEC const * fps = ps.CastToStruct();
    PROPVARIANT const * pVar = ConvertToPropVariant( &var );

    // Default to TRUE since the return code isn't checked!

    fInSchema = TRUE;

    SCODE sc = _propStore->StoreProperty( wid, fps, pVar );

    if ( CI_E_PROPERTY_NOT_CACHED == sc )
        fInSchema = FALSE;
    else if ( FAILED( sc ) )
        return sc;

    return S_OK;
}

BOOL CResManager::StoreSecurity( WORKID wid,
                                 PSECURITY_DESCRIPTOR pSD,
                                 ULONG cbSD )
{
    return S_OK == _docStore->StoreSecurity( wid, (BYTE *) pSD, cbSD );
}


//+---------------------------------------------------------------------------
//
//  Member:     CResManager::FPSToPROPID, public
//
//  Synopsis:   Converts FULLPROPSPEC property to PROPID
//
//  Arguments:  [fps] -- FULLPROPSPEC representation of property
//              [pid] -- PROPID written here on success
//
//  Returns:    S_OK on success
//
//  History:    29-Dec-1997  KyleP      Created.
//
//----------------------------------------------------------------------------

SCODE CResManager::FPSToPROPID( CFullPropSpec const & fps, PROPID & pid )
{
    return _mapper->PropertyToPropid( fps.CastToStruct(), TRUE, &pid );
}

//
// Flush notify support
//

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::NotifyFlush
//
//  Synopsis:   Notifies the client that changes got flushed and gives the
//              flush information.
//
//  Arguments:  [ft]       - FileTime of the last successful flush.
//              [cEntries] - Number of entries in the aInfo
//              [aInfo]    - Array of USN information for the flush.
//
//  History:    1-27-97   srikants   Created
//
//  Note:       We should not call directly into framework client because
//              it violates resman->client lock hierarchy. We should not call
//              into client with resman lock held.
//
//----------------------------------------------------------------------------

void CResManager::NotifyFlush( FILETIME const & ft,
                               ULONG cEntries,
                               USN_FLUSH_INFO ** ppInfo )
{
    if ( !_fPushFiltering )
    {
       //
       // Notification of flushes are sent in pull filtering only.
       // For push filtering, the ICiCIndexNotificationStatus
       // interface is used to notify clients.
       //

       CPriLock   lock(_mutex);

       CChangesFlushNotifyItem * pItem =
               new CChangesFlushNotifyItem( ft, cEntries, ppInfo );
       _flushList.Queue( pItem );

       if (! _fFlushWorkerActive)
       {
           CFwFlushNotify * pWorkItem = new CFwFlushNotify( _workMan, *this );
           _workMan.AddToWorkList( pWorkItem );

           pWorkItem->AddToWorkQueue();
           pWorkItem->Release();
        }
    }
} //NotifyFlush

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::ProcessFlushNotifies
//
//  Synopsis:   Processes the queued flush notifies in a FIFO order. This
//              method is called only by the asynchronous worker thread
//              responsible for notifying the client about flushes.
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::ProcessFlushNotifies()
{

   //
   // Only one worker thread allowed to operate on the list at a time.
   //
   CLock lock (_mtxChangeFlush );
   CRevertBoolValue RevertFlushActive( _fFlushWorkerActive, TRUE );

   while ( TRUE )
   {
      CChangesFlushNotifyItem * pItem = 0;

      //
      // Remove the first flush item from the list under resman lock.
      //

      //===========================================
      {
         CPriLock   lock(_mutex);
         pItem = _flushList.GetFirst();
         if ( pItem )
            _flushList.Pop();

         if (_flushList.IsEmpty())
             RevertFlushActive.Revert();
      }
      //===========================================

      if ( pItem )
      {

         SCODE sc = _docStore->CheckPointChangesFlushed(
                         pItem->GetFlushTime(),
                         pItem->GetCount(),
                         pItem->GetFlushInfo() );

         if ( FAILED(sc) )
         {
             //
             // We don't have to requeue this item. The client's restart
             // work will just increase.
             //
             ciDebugOut(( DEB_ERROR,
                          "CheckPointChangesFlushed failed. Error (0x%X)\n",
                          sc ));
         }

         pItem->Close();
         delete pItem;
      }
      else
      {
         break;
      }
   } // While (TRUE)
} //ProcessFlushNotifies

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::_LokDeleteFlushWorkItems
//
//  Synopsis:   Deletes the flush notifies in the queue. This is called
//              during shutdown (dismount) to clean up any asynchronous
//              worker threads referring to resman.
//
//  History:    1-27-97   srikants   Created
//
//----------------------------------------------------------------------------

void CResManager::LokDeleteFlushWorkItems()
{
    for ( CChangesFlushNotifyItem * pItem = _flushList.Pop();
          0 != pItem;
          pItem = _flushList.Pop() )
    {
        pItem->Close();
        delete pItem;
    }
} //LokDeleteFlushWorkItems

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::NoFailAbortWidsInDocList
//
//  Synopsis:   Used in push filtering to abort all wids in the current
//              doclist
//
//  History:    24-Feb-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CResManager::NoFailAbortWidsInDocList()
{
   CPriLock lock ( _mutex );

   if ( _isBeingEmptied )
       return ;

   for ( unsigned i=0; i<_docList.Count(); i++ )
   {
       WORKID wid = _docList.Wid(i);
       USN usn = _docList.Usn(i);

       //
       // Abort the client transaction
       //
       _xIndexNotifTable->AbortWid( wid, usn );

       //
       // Keep track of aborted wids for use during
       // changlog shrink from front.
       //
       _aAbortedWids.NoFailLokAddWid( wid, usn );
   }

   _docList.LokClear();
} //NoFailAbortWidsInDocList

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::NoFailAbortWid
//
//  Synopsis:   Used in push filtering to abort a wid
//
//  Arguments:  [wid]  -- Workid
//              [usn]  -- Usn
//
//  History:    24-Feb-97   SitaramR   Created
//
//----------------------------------------------------------------------------

void CResManager::NoFailAbortWid( WORKID wid, USN usn )
{
    CPriLock lock ( _mutex );

    if ( _isBeingEmptied )
        return ;

    //
    // Abort the client transaction
    //
    _xIndexNotifTable->AbortWid( wid, usn );

    //
    // Keep track of aborted wid for use during
    // changlog shrink from front.
    //
    _aAbortedWids.NoFailLokAddWid( wid, usn );
} //NoFailAbortWid

//+---------------------------------------------------------------------------
//
//  Member:     CResManager::ClearNonStoragePropertiesForWid
//
//  Synopsis:   Clear non-storage properties from the property storage for wid
//
//  Arguments:  [wid]  -- Workid
//
//  History:    10-Oct-2000   KitmanH   Created
//
//----------------------------------------------------------------------------

SCODE CResManager::ClearNonStoragePropertiesForWid( WORKID wid )
{
    return _propStore->ClearNonStoragePropertiesForWid( wid );
}

//====================
// MASTER MERGE POLICY
//====================

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergePolicy::IsTimeToMasterMerge, public
//
//  Synopsis:   Determines if the system should start a master merge
//              immediately, and not wait until the master merge time.
//
//  History:    4-Aug-94    DwightKr        Created
//
//  Notes:      If new tests are added simply add them here.
//
//----------------------------------------------------------------------------
BOOL CMasterMergePolicy::IsTimeToMasterMerge() const
{
    return IsMaxShadowIndexSize()    ||
           IsMaxFreshListCount()     ||
           IsMinDiskFreeForceMerge();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergePolicy::IsMinDiskFreeForceMerge, private
//
//  Synopsis:   If the amount of free disk space is lower than a threshold,
//              then we should master merge, since it is likely that disk
//              space will be released.
//
//  History:    4-Aug-94    DwightKr        Created
//              Jan-07-96   mohamedn        CDmFwEventItem
//
//----------------------------------------------------------------------------
BOOL CMasterMergePolicy::IsMinDiskFreeForceMerge() const
{
    //
    //  If we've exceeded the MIN_DISKFREE_FORCE_MERGE space used on
    //  the system, and a master merge has the potential to make some
    //  useful progress, then it's time to force a master merge.  The
    //  values of MIN_DISKFREE_FORCE_MERGE and MAX_SHADOW_FREESPACE
    //  are expressed as a percentage.
    //
    __int64 diskTotal, diskRemaining;
    _storage.GetDiskSpace( diskTotal, diskRemaining );

    if ( diskRemaining < minDiskFreeForMerge )
        return FALSE;

    if (diskRemaining*100/diskTotal < _frmwrkParams.GetMinDiskFreeForceMerge() &&
        _shadowIndexSize*100/diskRemaining > _frmwrkParams.GetMaxShadowFreeForceMerge() )
    {
       CDmFwEventItem item(  EVENTLOG_INFORMATION_TYPE,
                             MSG_CI_MASTER_MERGE_STARTED_TOTAL_DISK_SPACE_USED,
                             2);

       item.AddArg( _storage.GetVolumeName() );
       item.AddArg( _frmwrkParams.GetMinDiskFreeForceMerge() );

       item.ReportEvent(_adviseStatus);

       ciDebugOut(( DEB_ITRACE | DEB_PENDING,
                    "Master merge, reason: Low on disk space\n" ));

       return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergePolicy::IsMaxFreshListCount, private
//
//  Synopsis:   If the number of entries in the fresh list is great than
//              a threshold, we should master merge, and free up memory
//              occupied by the fresh hash.
//
//  History:    4-Aug-94    DwightKr        Created
//              Jan-07-96   mohamedn        CDmFwEventItem
//
//----------------------------------------------------------------------------
BOOL CMasterMergePolicy::IsMaxFreshListCount() const
{
    if ( _freshCount > _frmwrkParams.GetMaxFreshCount() )
    {

       CDmFwEventItem item( EVENTLOG_INFORMATION_TYPE,
                            MSG_CI_MASTER_MERGE_STARTED_FRESH_LIST_COUNT,
                            2);

       item.AddArg( _storage.GetVolumeName() );
       item.AddArg( _frmwrkParams.GetMaxFreshCount() );

       item.ReportEvent(_adviseStatus);

       ciDebugOut(( DEB_ITRACE | DEB_PENDING,
                    "Master merge, reason: More than %d entries in freshhash\n",
                     _frmwrkParams.GetMaxFreshCount() ));

       return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergePolicy::IsMaxShadowIndexSize, private
//
//  Synopsis:   If the combined size of all shadow indexes is greater than
//              a threahold, we should master merge, and free up disk space.
//              The content index should not take up more than a given
//              percentage of disk space.
//
//  History:    4-Aug-94    DwightKr        Created
//              Jan-07-96   mohamedn        CDmFwEventItem
//
//----------------------------------------------------------------------------
BOOL CMasterMergePolicy::IsMaxShadowIndexSize() const
{
    __int64 diskTotal, diskRemaining;
    _storage.GetDiskSpace( diskTotal, diskRemaining );

    if ( diskRemaining < minDiskFreeForMerge )
        return FALSE;

    if ( _shadowIndexSize*100/diskTotal > _frmwrkParams.GetMaxShadowIndexSize() )
    {

       CDmFwEventItem item( EVENTLOG_INFORMATION_TYPE,
                            MSG_CI_MASTER_MERGE_STARTED_SHADOW_INDEX_SIZE,
                            2);

       item.AddArg( _storage.GetVolumeName() );
       item.AddArg( _frmwrkParams.GetMaxShadowIndexSize() );

       item.ReportEvent(_adviseStatus);

       ciDebugOut(( DEB_ITRACE | DEB_PENDING,
                    "Master merge, reason: Combined shadow indexes > %d%% of disk\n",
                     _frmwrkParams.GetMaxShadowIndexSize() ));

       return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMasterMergePolicy::ComputeMidNightMergeTime
//
//  Synopsis:   Function to compute the time (in hundreds of nanoseconds
//              from midnight Dec 31, 1969) for the next master merge based on
//              the value given from registry.
//
//  Arguments:  [mergeTime] -  The time read from the registry control params.
//                             It's an offset in minutes after midnight.
//
//  Returns:    LONG - time for next merge
//
//  History:    19-Feb-1996  srikants   Moved the code from svcfilt.cxx
//              17-Nov-1999  KyleP      Stop using CRT
//
//  Notes:      If the time is before January 1, 1970 it will return -1.
//
//----------------------------------------------------------------------------

ULONGLONG CMasterMergePolicy::ComputeMidNightMergeTime( LONG mergeTime )
{
    Win4Assert( mergeTime < 24 * 60 );
    mergeTime *= 60;

    //
    // What time is it here?
    //

    SYSTEMTIME stLocal;
    GetLocalTime( &stLocal );

    LONG lNow = stLocal.wHour*60*60 + stLocal.wMinute*60 + stLocal.wSecond;

    //
    // Have we passed the daily merge time?
    //

    LONGLONG llHNSTilMerge;   // Hundred-Nano-Second-Til-Merge
    LONGLONG const llHNSOneDay = 24*60*60*10000000i64;

    if ( lNow < mergeTime )
        llHNSTilMerge = mergeTime * 10000000i64;
    else
        llHNSTilMerge = mergeTime * 10000000i64 + llHNSOneDay;

    //
    // Create the *local* filetime for the next merge
    //

    stLocal.wHour = 0;
    stLocal.wMinute = 0;
    stLocal.wSecond = 0;
    stLocal.wMilliseconds = 1;

    FILETIME ftLocal;
    if ( !SystemTimeToFileTime( &stLocal, &ftLocal ) )
        return -1;

    ((ULARGE_INTEGER *)&ftLocal)->QuadPart += llHNSTilMerge;

    //
    // Now, adjust to UTC and return
    //

    FILETIME ft;

    if ( !LocalFileTimeToFileTime( &ftLocal, &ft ) )
        return -1;

#if CIDBG == 1
    FILETIME ft2;

    GetSystemTimeAsFileTime( &ft2 );

    Win4Assert( ((ULARGE_INTEGER *)&ft2)->QuadPart < ((ULARGE_INTEGER *)&ft)->QuadPart );
#endif // CIDBG

    return ((ULARGE_INTEGER *)&ft)->QuadPart;
} //ComputeMidNightMergeTime

//+---------------------------------------------------------------------------
//
//  Member:     CMasterMergePolicy::IsMidNightMergeTime, public
//
//  Synopsis:   Determines if it's been 24 hours since the last merge time
//
//  History:     4-Aug-1994  DwightKr   Created
//              17-Nov-1999  KyleP      Stop using CRT
//
//----------------------------------------------------------------------------

BOOL CMasterMergePolicy::IsMidNightMergeTime()
{
    FILETIME ft;
    GetSystemTimeAsFileTime( &ft );

    if ( ((ULARGE_INTEGER *)&ft)->QuadPart > _mergeTime )
    {
        ULONG mergeTime = _frmwrkParams.GetMasterMergeTime();

        ULONGLONG oldMergeTime = _mergeTime;

        _mergeTime = ComputeMidNightMergeTime( mergeTime );

        //
        // If it's been more than 30 minutes since the master merge time, don't
        // do it.  This can happen if we were doing a master merge as part of
        // indexing documents or if you turn on a machine in the morning and it
        // was off at the master merge time.
        //

        LONGLONG const llHNSHalfHour = 30*60*10000000i64;

        if ( ((ULARGE_INTEGER *)&ft)->QuadPart > ( oldMergeTime + llHNSHalfHour ) )
            return FALSE;

        return TRUE;
    }

    return FALSE;
} //IsMidNightMergeTime
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\set.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   SET.CXX
//
//  Contents:   Bit set
//
//  Classes:    CSimpleSet, CSet
//
//  History:    01-Nov-91   BartoszM    Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "set.hxx"

//
// CSimpleSet
//

//
// LowestBit [x] = position of lowest bit in byte x
// EOS if set exhaused.
//

#define EMPTY 16

//  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
static const char LowestBit[] = {
EMPTY, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};

//+---------------------------------------------------------------------------
//
//  Member:     CSimpleSet::FirstElement, public
//
//  Synopsis:   Returns the first element in the set
//
//  History:    01-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

int CSimpleSet::FirstElement() const
{
    unsigned char* pb = (unsigned char*) &_bitset;
    for ( unsigned i = 0; i < sizeof ( set_t ); i++ )
    {
        if ( pb[i] != 0 )
            return LowestBit [ pb[i] ] + i * 8;
    }
    return EOS;
}

//
// CSet
//

//+---------------------------------------------------------------------------
//
//  Member:     CSet::CSet, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [s] -- source set
//
//  History:    01-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CSet::CSet ( CSet& s )
{
        memcpy ( _aSimpleSet, s._aSimpleSet, sizeof _aSimpleSet );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSet:operator=, public
//
//  History:    01-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CSet& CSet::operator= ( CSet& s )
{
        memcpy ( _aSimpleSet, s._aSimpleSet, sizeof _aSimpleSet );
        return *this;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSet::IsEmpty, public
//
//  Synopsis:   Checks if the set is empty
//
//  History:    01-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

BOOL CSet::IsEmpty() const
{
        for ( int i = 0; i < SET_ENTRIES; i++ )
        {
                if ( ! _aSimpleSet[i].IsEmpty() )
                        return FALSE;
        } 
        return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSet::FirstElement, public
//
//  Synopsis:   Returns the first element
//
//  History:    01-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

int CSet::FirstElement() const
{
    int i = 0;

    while ( _aSimpleSet[i].IsEmpty() )
    {
        if ( ++i == SET_ENTRIES )
            return EOS;
        } 
        return i * SIMPLE_SET_SIZE + _aSimpleSet[i].FirstElement();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSet::Clear, public
//
//  Synopsis:   Removes all elements from set
//
//  History:    01-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

void CSet::Clear()
{
        for ( int i = 0; i < SET_ENTRIES; i++ )
                _aSimpleSet[i].Clear();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSet::Fill, public
//
//  Synopsis:   Fill the set
//
//  History:    01-Nov-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

void CSet::Fill()
{
        for ( int i = 0; i < SET_ENTRIES; i++ )
                _aSimpleSet[i].Fill();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\sort.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       SORT.CXX
//
//  Contents:   Key sorting
//
//  History:    12-Jun-91   BartoszM    Created
//              19-Jun-91       reviewed
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <entry.hxx>

#include "sort.hxx"
#include "compress.hxx"

void CDirectory::AddEntry ( CBlock* pBlock, CKeyBuf& key )
{
    /*
    ciDebugOut (( DEB_ITRACE, "directory: add %d - %.*ws\n",
        _counter, key.StrLen(), key.GetStr() ));
    */
    _tree.Add ( _counter, key );
    _blocks [_counter] = pBlock;
    _counter++;
}

//+---------------------------------------------------------------------------
//
// Member:      CSortChunk::CSortChunk, public
//
// Synopsis:    Copy logically sorted buffer into sort chunk
//              using a compressor
//
// Arguments:   [maxOccTable] -- table of max occurrences for wids
//
// History:     28-May-92   KyleP       Separate Single/Multiple wid compressor
//              07-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

CSortChunk::CSortChunk( CMaxOccTable& maxOccTable )
    : _blocks( 0 ),
      _cBlocks( 0 ),
      _maxOccTable( maxOccTable )
{
}

//+---------------------------------------------------------------------------
//
// Member:      CSortChunk::Init, public
//
// Synopsis:    2nd-phase of construction for a CShortChunk
//
// Arguments:   [buf] -- sorted entry buffer
//              [cb] -- count of bytes in buffer
//              [widMax] -- maximum WORKID for the word list.
//
// History:     28-May-92   KyleP       Separate Single/Multiple wid compressor
//              07-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

void CSortChunk::Init(
    const BYTE * pBuf,
    ULONG        cb,
    WORKID       widMax )
{
    //ciDebugOut (( DEB_ITRACE, "copying into sort chunk\n" ));

    if ( cb < sizeof(int) + sizeof(WORKID) )
    {   // buffer is too small to hold correct information
        THROW(CException(CI_CORRUPT_FILTER_BUFFER));
    }

    // extract necessary information from the end of the buffer
    const BYTE* pbEndVector = pBuf + cb - sizeof(int) - sizeof(WORKID);
    INT_PTR * pEndVector = (INT_PTR *)pbEndVector;
    int offsetVector = *(int *)(pbEndVector + sizeof(WORKID));
    _widSingle = *(WORKID *)(pbEndVector);

    INT_PTR * pVector = (INT_PTR *)(pBuf + offsetVector);
    int cbEntries = (int)((BYTE *)pVector - pBuf);

    // get count by taking size of the array of offsets, then subtracting space
    // for the two sentinel entries.
    int count = (int)(pEndVector - pVector) - 2;

    if ( (offsetVector < 0) || ( count < 0 ) )
    {   // pVector is not valid
        THROW(CException(CI_CORRUPT_FILTER_BUFFER));
    }

    _cBlocks = 0;
    OCCURRENCE oldOcc = OCC_INVALID;
    if ( pVector[0] >= cbEntries || pVector[0] < 0 )
    {
        THROW(CException(CI_CORRUPT_FILTER_BUFFER));
    }
    CEntry * pLastEntry = (CEntry *)(pBuf + pVector[0]); // sentinel

    if ((pLastEntry->Pid()!=0)||
        (pLastEntry->Wid()!=widInvalid)||
        (pLastEntry->Occ()!=0)||
        (pLastEntry->Count()!=0))
    {   // this is not a sentinel
        THROW(CException(CI_CORRUPT_FILTER_BUFFER));
    }

    if ( _widSingle == widInvalid )
    {
        CCompress compr;

        _blocks = compr.GetFirstBlock();

        for ( int i = 1; i <= count; i++ )
        {
            if ( pVector[i] >= cbEntries || pVector[i] < 0 )
            {
                THROW(CException(CI_CORRUPT_FILTER_BUFFER));
            }
            CEntry * pEntry = (CEntry *)(pBuf + pVector[i]);
            OCCURRENCE newOcc = pEntry->Occ();

            Win4Assert(pEntry->Pid()!=pidInvalid);            // invalid PROPID
            Win4Assert(pEntry->Pid()!=pidAll);
            Win4Assert(pEntry->Wid()<=widMax);                // invalid WORKID
            Win4Assert(pEntry->Wid()<=CI_MAX_DOCS_IN_WORDLIST);  // invalid WORKID
            Win4Assert(newOcc!=OCC_INVALID);                   // invalid OCCURRENCE
            Win4Assert(pEntry->Count()<=MAXKEYSIZE);          // invalid key size
            Win4Assert( pLastEntry->Compare( pEntry ) <= 0 );  // unsorted buffer

            if ((pEntry->Pid()==pidInvalid)||           // invalid PROPID
                (pEntry->Pid()==pidAll)||
                (pEntry->Wid()>widMax)||                // invalid WORKID
                (pEntry->Wid()>CI_MAX_DOCS_IN_WORDLIST)||                // invalid WORKID
                (newOcc==OCC_INVALID)||                  // invalid OCCURRENCE
                (pEntry->Count()>MAXKEYSIZE)||          // invalid key size
                (pLastEntry->Compare( pEntry ) > 0))   // unsorted buffer
            {
                THROW(CException(CI_CORRUPT_FILTER_BUFFER));
            }

            _maxOccTable.PutOcc( pEntry->Wid(), pEntry->Pid(), pEntry->Occ() );

            if ( !compr.SameKey ( pEntry->Count(), pEntry->GetKeyBuf() ) ||
                 !compr.SamePid ( pEntry->Pid() ) )
            {
                compr.PutKey( pEntry->Count(),
                              pEntry->GetKeyBuf(),
                              pEntry->Pid() );
                compr.PutWid( pEntry->Wid() );
            }
            else
            {
                if ( !compr.SameWid ( pEntry->Wid() ) )
                {
                    compr.PutWid ( pEntry->Wid() );
                }
                else if ( newOcc == oldOcc )
                {
                    // adding exact same key twice
                    THROW(CException(CI_CORRUPT_FILTER_BUFFER));
                }
            }
            compr.PutOcc( newOcc );
            oldOcc = newOcc;
            pLastEntry = pEntry;
        }

        _cBlocks = compr.KeyBlockCount();
    }
    else
    {
        if ( _widSingle > widMax )
        {
            // invalid WORKID
            ciDebugOut (( DEB_WARN, "_widSingle %d, widMax %d\n",
                _widSingle, widMax ));
            THROW(CException(CI_CORRUPT_FILTER_BUFFER));
        }

        COneWidCompress compr;

        _blocks = compr.GetFirstBlock();

        for ( int i = 1; i <= count; i++ )
        {
            if ( pVector[i] >= cbEntries || pVector[i] < 0 )
            {
                THROW(CException(CI_CORRUPT_FILTER_BUFFER));
            }
            CEntry * pEntry = (CEntry *)(pBuf + pVector[i]);
            OCCURRENCE newOcc = pEntry->Occ();

            if ((pEntry->Pid()==pidInvalid)||           // invalid PROPID
                (pEntry->Pid()==pidAll)||
                (newOcc==OCC_INVALID)||                  // invalid OCCURRENCE
                (pEntry->Count()>MAXKEYSIZE)||          // invalid key size
                (pLastEntry->Compare(pEntry)>0))             // unsorted buffer
            {
                THROW(CException(CI_CORRUPT_FILTER_BUFFER));
            }

            _maxOccTable.PutOcc( _widSingle, pEntry->Pid(), pEntry->Occ() );

            if ( !compr.SameKey ( pEntry->Count(), pEntry->GetKeyBuf() ) ||
                 !compr.SamePid ( pEntry->Pid() ) )
            {
                compr.PutKey( pEntry->Count(),
                                pEntry->GetKeyBuf(),
                                pEntry->Pid() );
            }
            else if ( newOcc == oldOcc )
            {
                // adding exact same key twice
                THROW(CException(CI_CORRUPT_FILTER_BUFFER));
            }

            compr.PutOcc( newOcc );
            oldOcc = newOcc;
            pLastEntry = pEntry;
        }

        _cBlocks = compr.KeyBlockCount();
    }

    _dir.Init ( _cBlocks );

    // scan blocks and add all the keys

    CKeyBuf keyBuf;

    for ( CBlock* pBlock = _blocks; pBlock != 0; pBlock = pBlock->_pNext )
    {
        if ( pBlock->_offFirstKey != offInvalid )
        {
            pBlock->GetFirstKey( keyBuf );
            _dir.AddEntry( pBlock, keyBuf );
        }
    }

    // save some memory

    _blocks->CompressList();

    _dir.Done();
} //Init

//+---------------------------------------------------------------------------
//
// Member:      CSortChunk::~CSortChunk, public
//
// History:     12-Aug-91   BartoszM    Created
//
//----------------------------------------------------------------------------

CSortChunk::~CSortChunk ()
{
    while ( _blocks != 0 )
    {
        CBlock * tmp = _blocks;
        _blocks = _blocks->_pNext;
        delete tmp;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSortChunk::QueryCursor
//
//  Synopsis:   Creates a cursor for a given key
//
//  Arguments:  [iid] -- index id
//              [widTable] -- wid translation table
//
//  History:    28-May-92   KyleP       Separate Single/Multiple wid compressor
//              27-Sep-91   BartoszM    Created
//
//----------------------------------------------------------------------------

CChunkCursor* CSortChunk::QueryCursor (
        INDEXID iid,
        const CWidTable& widTable,
        WORKID widMax )
{
    XPtr<CChunkCursor> xCur;

    if ( _widSingle == widInvalid )
        xCur.Set( new CManyWidChunkCursor ( iid, widTable, this, widMax, _maxOccTable ) );
    else
        xCur.Set( new COneWidChunkCursor( iid, widTable, _widSingle, this, widMax, _maxOccTable ) );
    xCur->Init();
    return xCur.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSortChunk::QueryCursor
//
//  Synopsis:   Creates a cursor for a given key
//
//  Arguments:  [iid] -- index id
//              [widTable] -- wid translation table
//              [pkey] -- key to seek
//
//  Returns:    Cursor or NULL if key not found
//
//  History:    28-May-92   KyleP       Separate Single/Multiple wid compressor
//              27-Sep-91   BartoszM    Created
//
//----------------------------------------------------------------------------

CChunkCursor* CSortChunk::QueryCursor (
        INDEXID iid,
        const CWidTable& widTable,
        const CKey * pKeySearch,
        WORKID widMax )
{
    XPtr<CChunkCursor> xCur;

    if ( _widSingle == widInvalid )
        xCur.Set( new CManyWidChunkCursor ( iid, widTable, this, widMax, _maxOccTable ) );
    else
        xCur.Set( new COneWidChunkCursor( iid, widTable, _widSingle, this, widMax, _maxOccTable ) );

    const CKeyBuf* pKeyFound = xCur->SeekKey ( pKeySearch );

    if ( !pKeyFound ||
         !pKeySearch->MatchPid (*pKeyFound) ||
         pKeySearch->CompareStr(*pKeyFound) != 0 )
    {
        xCur.Free();
    }

    return xCur.Acquire();
}

//+---------------------------------------------------------------------------
//
// Member:      CSortChunk::CreateRange(), public
//
// Synopsis:    Adds all cursors with keys between pkey and pkeyEnd to curStk.
//
// Arguments:   [curStk] -- CKeyCurStack to add cursors to.
//              [pkey] -- Beginning of key range.
//              [pkeyEnd] -- End of key range.
//              [iid] -- Index id for QueryCursor.
//              [widTable] -- Wid Table for QueryCursor.
//
// History:     07-Feb-92   AmyA        Created.
//              14-Feb-92   AmyA        Moved from CWordList.
//              28-May-92   KyleP       Separate Single/Multiple wid compressor
//
//----------------------------------------------------------------------------

void CSortChunk::CreateRange(COccCurStack & curStk,
        const CKey * pKeyStart,
        const CKey * pKeyEnd,
        INDEXID iid,
        const CWidTable& widTable,
        WORKID widMax )
{
    XPtr<CChunkCursor> xCursor;

    if ( _widSingle == widInvalid )
        xCursor.Set( new CManyWidChunkCursor ( iid, widTable, this, widMax, _maxOccTable ) );
    else
        xCursor.Set( new COneWidChunkCursor( iid, widTable, _widSingle, this, widMax, _maxOccTable ) );

    const CKeyBuf* pKeyCurrent = xCursor->SeekKey ( pKeyStart );
    if ( 0 == pKeyCurrent )
    {
        xCursor.Free();
        return;
    }

    CChunkCursor * pCursor = xCursor.Acquire();
    curStk.Push( pCursor );
    PROPID pid = pKeyStart->Pid();

    ciDebugOut((DEB_ITRACE, "Found key %.*ws, pid %d\n",
           pKeyCurrent->StrLen(), pKeyCurrent->GetStr(), pKeyCurrent->Pid()));

    do
    {
        if (pid != pidAll)  // exact pid match
        {
            // skip wrong pids
            while (pid != pKeyCurrent->Pid())
            {
#if CIDBG == 1 //------------------------------------------
                if (pKeyCurrent)
                {
                    ciDebugOut(( DEB_ITRACE, "  skip: %.*ws, pid %d, wid %d\n",
                        pKeyCurrent->StrLen(),
                        pKeyCurrent->GetStr(),
                        pKeyCurrent->Pid(),
                        pCursor->WorkId() ));
                }
                else
                    ciDebugOut(( DEB_ITRACE, "   <NULL> key\n" ));
#endif  //--------------------------------------------------
                pKeyCurrent = pCursor->GetNextKey();
                if (pKeyCurrent == 0
                    || pKeyEnd->CompareStr(*pKeyCurrent) < 0 )
                    break;
            }
            // either pid matches or we have overshot
            // i.e. different pids and current string > end
        }

        if (pKeyCurrent == 0 || !pKeyEnd->MatchPid (*pKeyCurrent)
            || pKeyEnd->CompareStr (*pKeyCurrent) < 0 )
        {
            break;  // <--- LOOP EXIT
        }

        if ( _widSingle == widInvalid )
            pCursor = new CManyWidChunkCursor( *(CManyWidChunkCursor *)pCursor );
        else
            pCursor = new COneWidChunkCursor( *(COneWidChunkCursor *)pCursor );

        curStk.Push(pCursor);
        pKeyCurrent = pCursor->GetNextKey();
#if CIDBG == 1
        if (pKeyCurrent)
        {
            ciDebugOut((DEB_ITRACE, "Key is %.*ws\n",
                pKeyCurrent->StrLen(), pKeyCurrent->GetStr()));
        }
        else
            ciDebugOut(( DEB_ITRACE, "   <NULL> key\n" ));
#endif // CIDBG == 1
    } while ( pKeyCurrent );

    // Since we have one more cursor in curStk than we wanted...
    curStk.DeleteTop();
}

//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::CManyWidChunkCursor, private
//
// Synopsis:    initialize a chunk cursor
//
// Arguments:   [iid] -- index id
//              [widTable] -- wid translation table
//              [pChunk] -- sort chunk
//              [widMax] -- maximum wid
//              [maxOccTable] -- table of max occurrences of wids
//
// Notes:       No seek is made! Can be used for merges,
//              otherwise Seek has to be called next.
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//
//----------------------------------------------------------------------------

CManyWidChunkCursor::CManyWidChunkCursor( INDEXID iid,
                                          const CWidTable& widTable,
                                          CSortChunk *pChunk,
                                          WORKID widMax,
                                          CMaxOccTable& maxOccTable )
    : CChunkCursor(iid, widMax, pChunk),
      _widTable( widTable ),
      _maxOccTable( maxOccTable )
{
    Win4Assert ( pChunk != 0 );
}

void CManyWidChunkCursor::Init()
{
    Init( _pChunk->GetBlock() );
}

void CManyWidChunkCursor::Init( CBlock* pBlock )
{
    Win4Assert ( pBlock != 0 );

    _decomp.Init ( pBlock );

    const CKeyBuf *pKey = _decomp.GetKey();
    if ( pKey )
        _pid = pKey->Pid();

    // should try to position on a valid work id
    _curFakeWid = _decomp.WorkId();
    WORKID wid = _widTable.FakeWidToWid( _curFakeWid );

    Win4Assert ( _curFakeWid != widInvalid );

    if ( wid == widInvalid )
        wid = NextWorkId();

    if ( wid == widInvalid )
        GetNextKey();
}

//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::SeekKey,private
//
// Synopsis:    seek to the specified key
//
// Effects:     positions cursor at specified key or later
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//
//----------------------------------------------------------------------------

const CKeyBuf * CManyWidChunkCursor::SeekKey( const CKey * pkey )
{
    Win4Assert ( pkey != 0 );

    CDirectory& dir = _pChunk->GetDir();
    CBlock* pBlock = dir.Seek ( *pkey );

    Init ( pBlock );

    const CKeyBuf * tmpKey = _decomp.GetKey();

    //----------------------------------------------------
    // Notice: Make sure that pidAll is smaller
    // than any other legal PID. If the search key
    // has pidAll we want to be positioned at the beginning
    // of the range.
    //----------------------------------------------------

    Win4Assert ( pidAll == 0 );

    while ( tmpKey != 0  &&  pkey->Compare(*tmpKey) > 0 )
        tmpKey = GetNextKey();

    if ( tmpKey )
    {
        _pid = tmpKey->Pid();
        UpdateWeight();
    }

    return tmpKey;
}

//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::GetKey, public
//
// Synopsis:    return the current key, NULL if it doesn't exist
//
// Returns:     current key
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//
//----------------------------------------------------------------------------
const CKeyBuf *CManyWidChunkCursor::GetKey()
{
    return _decomp.GetKey();
}

//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::GetNextKey, public
//
// Synopsis:    advance to next key and return it if it exists
//
// Effects:     changes cursor position
//
// Returns:     next key if it exists or NULL
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//
//----------------------------------------------------------------------------
const CKeyBuf * CManyWidChunkCursor::GetNextKey()
{
    const CKeyBuf* key;
    WORKID wid;

    do
    {
        key = _decomp.GetNextKey();
        if ( key != 0)
        {
            _curFakeWid = _decomp.WorkId();
            wid = _widTable.FakeWidToWid( _curFakeWid );
            Win4Assert( _curFakeWid != widInvalid );
            if ( wid == widInvalid )
                wid = NextWorkId();
        }
    } while ( key != 0 && wid == widInvalid );

    if ( key )
    {
        _pid = key->Pid();
        UpdateWeight();
    }

    return key;
}

//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::WorkId, public
//
// Synopsis:    return current work id under cursor
//
// Returns:     a workid or widInvalid
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//              28-May-92   KyleP       Added WorkId mapping
//
//----------------------------------------------------------------------------
WORKID CManyWidChunkCursor::WorkId()
{
    _curFakeWid = _decomp.WorkId();

    return ( _widTable.FakeWidToWid( _curFakeWid ) );
}

//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::NextWorkId
//
// Synopsis:    Advance to next workid within key and return it if it exists
//
// Returns:     next workid or widInvalid if it doesn't exist
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//              28-May-92   KyleP       Added WorkId mapping
//              22-Sep-93   AmyA        Added additional check for widInvalid
//
//----------------------------------------------------------------------------
WORKID CManyWidChunkCursor::NextWorkId()
{
    WORKID wid;

    do
    {
        _curFakeWid = _decomp.NextWorkId();
        wid = _widTable.FakeWidToWid( _curFakeWid );
    } while ( wid == widInvalid && _curFakeWid != widInvalid );

    return wid;
}

void CManyWidChunkCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    _decomp.RatioFinished (denom, num);
}

//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::Occurrence, public
//
// Synopsis:    return current occurrence under cursor
//
// Returns:     occurrence or OCC_INVALID
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//
//----------------------------------------------------------------------------
OCCURRENCE CManyWidChunkCursor::Occurrence()
{
    return _decomp.Occurrence();
}

//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::NextOccurrence, public
//
// Synopsis:    advance to next occurrence within current workid
//
// Returns:     next occurrence if it exists, otherwise OCC_INVALID
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//
//----------------------------------------------------------------------------
OCCURRENCE CManyWidChunkCursor::NextOccurrence()
{
    return _decomp.NextOccurrence();
}


//+---------------------------------------------------------------------------
//
// Member:      CManyWidChunkCursor::MaxOccurrence, public
//
// Synopsis:    Returns max occurrence count of current workid and pid
//
// History:     20-Jun-96   SitaramR      Created
//
//----------------------------------------------------------------------------
OCCURRENCE CManyWidChunkCursor::MaxOccurrence()
{
    return _maxOccTable.GetMaxOcc( _curFakeWid, _pid );
}


//+---------------------------------------------------------------------------
//
//  Member:     CManyWidChunkCursor::WorkIdCount, public
//
//  Synopsis:   return wid count
//
//  Expects:    cursor positioned after key, wid heap empty
//
//  History:    21-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

ULONG  CManyWidChunkCursor::WorkIdCount()
{
    return _decomp.WorkIdCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CManyWidChunkCursor::OccurrenceCount, public
//
//  Synopsis:   return occurrence count
//
//  Expects:    cursor positioned after work id
//
//  History:    21-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

ULONG  CManyWidChunkCursor::OccurrenceCount()
{
    return _decomp.OccurrenceCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CManyWidChunkCursor::HitCount, public
//
//  Synopsis:   return occurrence count for current work id
//
//  Expects:    cursor positioned after work id
//
//  History:    27-Feb-92   AmyA        Created
//
//----------------------------------------------------------------------------

ULONG  CManyWidChunkCursor::HitCount()
{
    return OccurrenceCount();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::COneWidChunkCursor, private
//
// Synopsis:    initialize a chunk cursor
//
// Arguments:   [iid]      -- index id
//              [widTable] -- wid mapping
//              [wid]      -- The single wid in the chunk.
//              [pChunk]   -- sort chunk
//              [widMax]   -- maximum wid
//              [maxOccTable] -- table of max occurrences of wids
//
// Notes:       No seek is made! Can be used for merges,
//              otherwise Seek has to be called next.
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

COneWidChunkCursor::COneWidChunkCursor( INDEXID iid,
                                        CWidTable const & widTable,
                                        WORKID wid,
                                        CSortChunk *pChunk,
                                        WORKID widMax,
                                        CMaxOccTable& maxOccTable )
        : CChunkCursor( iid, widMax, pChunk ),
          _wid( widTable.FakeWidToWid( wid ) ),
          _maxOccTable( maxOccTable ),
          _fakeWid( wid )
{
    _widReal = _wid;
}

void COneWidChunkCursor::Init()
{
    _decomp.Init ( _pChunk->GetBlock() );

    const CKeyBuf *pKey = _decomp.GetKey();
    if ( pKey )
        _pid = pKey->Pid();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::SeekKey,private
//
// Synopsis:    Seek to the specified key
//
// Effects:     positions cursor at specified key or later
//
// Arguments:   [pkey] -- Key to seek to.
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

const CKeyBuf * COneWidChunkCursor::SeekKey( const CKey * pkey )
{
    if ( _widReal == widInvalid )
        return 0;

    Win4Assert ( pkey != 0 );

    //
    // Find the chunk.
    //

    CDirectory& dir = _pChunk->GetDir();
    CBlock* pBlock = dir.Seek ( *pkey );

    Win4Assert ( pBlock != 0 );

    //
    // Set up.
    //

    _decomp.Init ( pBlock );


    //
    // Go forward to the correct key.
    //

    CKeyBuf const * tmpKey;

    //----------------------------------------------------
    // Notice: Make sure that pidAll is smaller
    // than any other legal PID. If the search key
    // has pidAll we want to be positioned at the beginning
    // of the range.
    //----------------------------------------------------

    Win4Assert ( pidAll == 0 );

    for ( tmpKey = _decomp.GetKey();
          tmpKey != 0  &&  pkey->Compare(*tmpKey) > 0;
          tmpKey = _decomp.GetNextKey() )
            continue; // Null body

    if ( tmpKey )
    {
        _pid = tmpKey->Pid();
        UpdateWeight();
    }

    return tmpKey;
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::GetKey, public
//
// Synopsis:    return the current key, NULL if it doesn't exist
//
// Returns:     current key
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

const CKeyBuf *COneWidChunkCursor::GetKey()
{
    if ( _widReal == widInvalid )
        return 0;

    return _decomp.GetKey();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::GetNextKey, public
//
// Synopsis:    advance to next key and return it if it exists
//
// Effects:     changes cursor position
//
// Returns:     next key if it exists or NULL
//
// History:     28-May-92   KyleP       Created
//              02-Jun-92   KyleP       Restore real wid
//
//----------------------------------------------------------------------------

const CKeyBuf * COneWidChunkCursor::GetNextKey()
{
    if ( _widReal == widInvalid )
        return 0;

    const CKeyBuf* key = _decomp.GetNextKey();

    if ( key )
    {
        _wid = _widReal;
        _pid = key->Pid();
        UpdateWeight();
    }

    return key;
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::WorkId, public
//
// Synopsis:    return current work id under cursor
//
// Returns:     a workid or widInvalid
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

WORKID COneWidChunkCursor::WorkId()
{
    return( _wid );
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::NextWorkId
//
// Synopsis:    Advance to next workid within key and return it if it exists
//
// Returns:     next workid or widInvalid if it doesn't exist
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

WORKID COneWidChunkCursor::NextWorkId()
{
    _wid = widInvalid;
    return( widInvalid );
}

void COneWidChunkCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    denom = 1;
    if (_wid == widInvalid)
        num = 1;
    else
        num = 0;
}

//+---------------------------------------------------------------------------
//
// Member:     COneWidChunkCursor::WorkIdCount, public
//
// Returns:    1
//
// Expects:    cursor positioned after key, wid heap empty
//
// History:    28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

ULONG  COneWidChunkCursor::WorkIdCount()
{
    return( 1 );
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::Occurrence, public
//
// Synopsis:    return current occurrence under cursor
//
// Returns:     occurrence or OCC_INVALID
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

OCCURRENCE COneWidChunkCursor::Occurrence()
{
    Win4Assert( _wid != widInvalid );

    return _decomp.Occurrence();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::NextOccurrence, public
//
// Synopsis:    advance to next occurrence within current workid
//
// Returns:     next occurrence if it exists, otherwise OCC_INVALID
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

OCCURRENCE COneWidChunkCursor::NextOccurrence()
{
    Win4Assert( _wid != widInvalid );

    return _decomp.NextOccurrence();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::MaxOccurrence, public
//
// Synopsis:    Returns max occurrence count of current workid and pid
//
// History:     20-Jun-96   SitaramR      Created
//
//----------------------------------------------------------------------------
OCCURRENCE COneWidChunkCursor::MaxOccurrence()
{
    return _maxOccTable.GetMaxOcc( _fakeWid, _pid );
}


//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::OccurrenceCount, public
//
// Synopsis:    return occurrence count
//
// Expects:     cursor positioned after work id
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

ULONG  COneWidChunkCursor::OccurrenceCount()
{
    Win4Assert( _wid != widInvalid );

    return _decomp.OccurrenceCount();
}

//+---------------------------------------------------------------------------
//
// Member:      COneWidChunkCursor::HitCount, public
//
// Synopsis:    return occurrence count for current work id
//
// Expects:     cursor positioned after work id
//
// History:     28-May-92   KyleP       Created
//
//----------------------------------------------------------------------------

ULONG  COneWidChunkCursor::HitCount()
{
    return OccurrenceCount();
}
//+-------------------------------------------------------------------------
//
//  Member:     CWidTable::CWidTable, public
//
//  Synopsis:   Create a WorkId mapping table.
//
//  History:    20-May-92 KyleP     Created
//
//--------------------------------------------------------------------------

CWidTable::CWidTable()
: _count( 0 )
{
#if CIDBG == 1
    //
    // Initially the table will be all 0 \(illegal wid\)
    //

    memset( _table, 0, sizeof(_table) );
#endif
}

//+-------------------------------------------------------------------------
//
//  Member:     CWidTable::WidToFakeWid, public
//
//  Synopsis:   Maps a WorkId to a table index.
//
//  Arguments:  [wid] -- WorkId to map.  May already be mapped.
//
//  Returns:    The index of [wid]
//
//  History:    20-May-92 KyleP     Created
//
//  Notes:      This is clearly a non-optimal insertion algorithm but
//              it's called so infrequently that a more complex solution
//              would involve more code than it's worth.
//
//--------------------------------------------------------------------------

WORKID CWidTable::WidToFakeWid( WORKID wid )
{
    Win4Assert( _count <= CI_MAX_DOCS_IN_WORDLIST );

    for ( int iDoc = _count - 1; iDoc >= 0; iDoc-- )
    {
        if ( wid == _table[iDoc].Wid() )
            return( iDocToFakeWid ( iDoc ) );
    }

    WORKID fakeWid = iDocToFakeWid ( _count );

    _table[ _count ].SetWid( wid );
    _count++;

    return( fakeWid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\wlcursor.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1995.
//
//  File:       WLCURSOR.CXX
//
//  Contents:   Wordlist Merge Cursor
//
//  Classes:    CWlCursor
//
//  History:    17-Jun--91   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <curstk.hxx>

#include "wlcursor.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::CWlCursor, public
//
//  Synopsis:   Create a cursor that merges a number of chunk cursors.
//
//  Arguments:  [cCursor] -- count of cursors
//              [stkCursor] -- CKeyCurStack
//
//  History:    17-Jun-91   BartoszM    Created
//              24-Jan-92   AmyA        Modified to take CKeyCurArray as a
//                                      parameter.
//
//  Notes:      The cursors and the array will be deleted by destructor.
//
//----------------------------------------------------------------------------

CWlCursor::CWlCursor( int cCursor, CKeyCurStack & stkCursor, WORKID widMax )
: CKeyCursor ( 0, widMax ),
  _keyHeap(),
  _widHeap ( cCursor ),
  _occHeap ( cCursor )
{
    // Two step construction of the heap.
    // We have to make sure that all cursors have a valid key

    CKeyCursor **aCursor = stkCursor.AcqStack();
    int count = 0;

    //
    // Remove 1. empty cursors
    //        2. cursors which are positioned on widInvalid and which
    //           don't have a valid nextKey
    //
    for ( int i = 0; i < cCursor; i++ )
    {
        Win4Assert ( aCursor[i] != 0 );

        BOOL fDelete = FALSE;
        if ( aCursor[i]->GetKey() == 0 )
            fDelete = TRUE;
        else
        {
            if ( aCursor[i]->WorkId() == widInvalid )
            {
                if ( aCursor[i]->GetNextKey() == 0 )
                    fDelete = TRUE;
            }
        }

        if ( fDelete )
        {
            delete aCursor[i];
        }
        else if ( count != i )
            aCursor[count++] = aCursor[i];
        else
            count++;
    }

    _keyHeap.MakeHeap ( count, aCursor );
    if ( !_keyHeap.IsEmpty() )
    {
        _iid = _keyHeap.Top()->IndexId();
        _pid = _keyHeap.Top()->Pid();

        ReplenishWid();
        ComputeWidCount();
        ReplenishOcc();
        ComputeOccCount();

        UpdateWeight();
    }       
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::GetKey, public
//
//  Synopsis:   Get current key.
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      Does not replenish occHeap or widHeap
//              Current key is defined as:
//              1. cur key of all cursors in occHeap and widHeap, or,
//              2. if both empty, cur key of Top of keyHeap and
//                 all others with the same cur key
//
//----------------------------------------------------------------------------

const CKeyBuf * CWlCursor::GetKey()
{

    if ( _occHeap.IsEmpty() )
    {
        if (_widHeap.IsEmpty() )
        {
            if ( _keyHeap.IsEmpty() )
                return 0;
            return _keyHeap.Top()->GetKey();
        }
        else
            return _widHeap.Top()->GetKey();
    }
    else
        return _occHeap.Top()->GetKey();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      Current wid is defined as:
//              1. cur wid of all cursors in occHeap, or,
//              2. if occHeap empty, cur wid of Top of widHeap
//                 and cur wid of all cursors in widHeap
//                 with the same wid
//
//----------------------------------------------------------------------------

WORKID  CWlCursor::WorkId()
{
    if ( _occHeap.IsEmpty() )
    {
        if ( _widHeap.IsEmpty() )
        {
            return widInvalid;
        }
        return _widHeap.Top()->WorkId();
    }
    else
        return _occHeap.Top()->WorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::Occurrence, public
//
//  Synopsis:   Get current occurrence.
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      Current occurrence is defined as:
//              1. cur occ of top of occHeap and cur occ of all other
//                 cursors in it with the same cur occ
//
//----------------------------------------------------------------------------

OCCURRENCE   CWlCursor::Occurrence()
{
    if ( _occHeap.IsEmpty() )
        return OCC_INVALID;

    return _occHeap.Top()->Occurrence();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::GetNextKey, public
//
//  Synopsis:   Move to next key
//
//  Returns:    Target key or NULL if no more keys
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      1. Increment and move to keyHeap all cursors from
//                 occHeap and widHeap, or,
//              2. if both empty, increment and reheap all cursors
//                 from the keyHeap with the same cur key as Top
//
//----------------------------------------------------------------------------

const CKeyBuf * CWlCursor::GetNextKey()
{
    if ( ! _occHeap.IsEmpty() || !_widHeap.IsEmpty() )
    {
        // Move all cursors from occHeap and widHeap to keyHeap
        // advancing them to the next key

        CKeyCursor * cur;
        while ( ( cur = _occHeap.RemoveBottom() ) != 0 )
        {
            if ( cur->GetNextKey() == 0 )
            {
                delete cur;
            }
            else
            {
                _keyHeap.Add ( cur );
            }
        }

        while ( ( cur = _widHeap.RemoveBottom() ) != 0 )
        {
            if ( cur->GetNextKey() == 0 )
            {
                delete cur;
            }
            else
            {
                _keyHeap.Add ( cur );
            }
        }
    }
    else if ( !_keyHeap.IsEmpty() )
    {
        // Advance all cursors
        // with the lowest key.

        CKeyBuf key = *_keyHeap.Top()->GetKey();
        do {
            if ( _keyHeap.Top()->GetNextKey() == 0 )
            {
                delete _keyHeap.RemoveTop();
                if ( _keyHeap.IsEmpty () )
                    return 0;
            }
            else
                _keyHeap.Reheap();
        } while ( AreEqual ( &key, _keyHeap.Top()->GetKey()) );
    }
    else
        return 0;

    if ( _keyHeap.IsEmpty() )
        return 0;
    else
    {   
        _pid = _keyHeap.Top()->Pid();

        ReplenishWid();
        ComputeWidCount();
        ReplenishOcc();
        ComputeOccCount();

        UpdateWeight();

        return GetKey();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::NextWorkId, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      1. increment and move to widHeap all cursors in occHeap, or,
//              2. if occHeap empty, increment and reheap all cursors with
//                 the same wid as Top of widHeap
//
//----------------------------------------------------------------------------

WORKID       CWlCursor::NextWorkId()
{
    if ( ! _occHeap.IsEmpty() )
    {
        CKeyCursor * cur;
        while ( ( cur = _occHeap.RemoveBottom() ) != 0 )
        {
            cur->NextWorkId();
            _widHeap.Add ( cur );
        }
    }
    else
    {
        if ( _widHeap.IsEmpty() )
            return widInvalid;

        WORKID wid = _widHeap.Top()->WorkId();
        if ( wid == widInvalid )
            return widInvalid;
        
        do
        {
            _widHeap.Top()->NextWorkId();
            _widHeap.Reheap();
        } while ( _widHeap.Top()->WorkId() == wid && wid != widInvalid );

    }

    if ( WorkId() != widInvalid )
    {
        ReplenishOcc();
        ComputeOccCount();
    }

    return WorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::NextOccurrence, public
//
//  Synopsis:   Move to next occurrence
//
//  Returns:    Target occurrence or OCC_INVALID if no more occurrences
//              for current wid
//
//  History:    06-May-91   BartoszM    Created
//
//  Notes:      1. Increment and reheap Top of occHeap
//
//----------------------------------------------------------------------------

OCCURRENCE   CWlCursor::NextOccurrence()
{
    Win4Assert( WorkId() != widInvalid );

    if ( _occHeap.IsEmpty() )
        return OCC_INVALID;

    OCCURRENCE occPrev = _occHeap.Top()->Occurrence();
    if ( occPrev == OCC_INVALID )
        return OCC_INVALID;


    OCCURRENCE occNext;

    // Skip duplicate occurrences

    do {
        _occHeap.Top()->NextOccurrence();

        _occHeap.Reheap();

        occNext = _occHeap.Top()->Occurrence();

    } while ( occPrev  == occNext && occPrev != OCC_INVALID);

    return occNext;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::RatioFinished
//
//  Synopsis:   Return query progress
//
//  Arguments:  [ulDenominator] - on return, denominator of fraction
//              [ulNumerator] - on return, numerator of fraction
//
//  History:    23-Jun-96    SitaramR    Added header
//
//----------------------------------------------------------------------------

void CWlCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    if ( _occHeap.IsEmpty() && _widHeap.IsEmpty() && _keyHeap.IsEmpty() )
    {
        num = denom = 1;
        return;
    }

    denom = 0;
    num   = 0;

    // at least one of the heaps is not empty
    CKeyCursor **vector;
    int count = _occHeap.Count();
    vector = _occHeap.GetVector();
    for (int i = 0; i < count; i++)
    {
        ULONG d, n;
        vector[i]->RatioFinished(d, n);

        denom += d;
        num += n;
        Win4Assert( denom >= d && d > 0 );      // overflow?
    }

    count = _widHeap.Count();
    vector = _widHeap.GetVector();

    for (i = 0; i < count; i++)
    {
        ULONG d, n;
        vector[i]->RatioFinished(d, n);

        denom += d;
        num += n;
        Win4Assert( denom >= d && d > 0 );      // overflow?
    }

    Win4Assert( 0 != denom );

    // may be more in the heap -- not really done yet.

    if ( denom == num )
        denom++;
}



//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::MaxOccurrence
//
//  Synopsis:   Returns max occurrence of current wid, pid
//
//  History:    20-Jun-96   SitaramR    Created
//
//----------------------------------------------------------------------------
OCCURRENCE CWlCursor::MaxOccurrence()
{
    if ( _occHeap.IsEmpty() )
    {
        if (_widHeap.IsEmpty() )
            return OCC_INVALID;

        return _widHeap.Top()->MaxOccurrence();
    }
    else
        return _occHeap.Top()->MaxOccurrence();
}


//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::ComputeWidCount
//
//  Synopsis:   Computes the wid count
//
//  History:    23-Jun-96   SitaramR    Created
//
//----------------------------------------------------------------------------

void CWlCursor::ComputeWidCount()
{
    _ulWidCount = 0;

    int count = _widHeap.Count();
    if ( count > 0 )
    {
        CKeyCursor **curVec = _widHeap.GetVector();
        while ( --count >= 0 )
            _ulWidCount += curVec[count]->WorkIdCount();
    }

    if ( _ulWidCount == 0 )
        _ulWidCount = 1;

    //
    // _ulWidCount is an approximation because wid's can be counted multiple
    // times. However, the widCount cannot be more than the number of docs
    // in a wordlist.
    //
    if ( _ulWidCount > CI_MAX_DOCS_IN_WORDLIST )
        _ulWidCount = CI_MAX_DOCS_IN_WORDLIST;
}



//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::WorkIdCount, public
//
//  Synopsis:   return wid count
//
//  History:    21-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

ULONG CWlCursor::WorkIdCount()
{
    return _ulWidCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::ComputeOccCount
//
//  Synopsis:   Computes the occurrence count
//
//  History:    23-Jun-96   SitaramR    Created
//
//----------------------------------------------------------------------------

void CWlCursor::ComputeOccCount()
{
     Win4Assert( WorkId() != widInvalid );

    _ulOccCount = 0;

    int count = _occHeap.Count();
    if ( count > 0 )
    {
        CKeyCursor **curVec = _occHeap.GetVector();
        while ( --count >= 0 )
        {
            Win4Assert(  curVec[count]->WorkId() != widInvalid );

            _ulOccCount += curVec[count]->OccurrenceCount();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::OccurrenceCount, public
//
//  Synopsis:   return occurrence count
//
//  History:    21-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

ULONG CWlCursor::OccurrenceCount()
{
    Win4Assert( WorkId() != widInvalid );

    return _ulOccCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::HitCount, public
//
//  Synopsis:   return occurrence count
//
//  History:    27-Feb-92   AmyA        Created
//
//  Notes:      see notes for OccurrenceCount().
//
//----------------------------------------------------------------------------

ULONG CWlCursor::HitCount()
{
    return OccurrenceCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::ReplenishOcc, private
//
//  Synopsis:   Replenish the occurrence heap
//
//  Returns:    TRUE if successful, FALSE if key heap exhausted
//
//  Requires:   _occHeap empty
//
//  History:    06-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

BOOL CWlCursor::ReplenishOcc()
{
    ciAssert ( _occHeap.IsEmpty() );

    Win4Assert( WorkId() != widInvalid );

    if ( _widHeap.IsEmpty() )
    {
        return FALSE;
    }

    // Move all cursors with the current wid
    // to occ heap

    WORKID wid = _widHeap.Top()->WorkId();

    do {
        CKeyCursor* cur = _widHeap.RemoveTop();

        _occHeap.Add ( cur );
    } while ( !_widHeap.IsEmpty() && (wid == _widHeap.Top()->WorkId()) );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWlCursor::ReplenishWid, protected
//
//  Synopsis:   Replenish the wid heap
//
//  Returns:    TRUE if successful, FALSE if key heap exhausted
//
//  Effects:    Updates _iid to the ones of the widHeap top
//
//  History:    06-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

BOOL CWlCursor::ReplenishWid()
{

    if ( _keyHeap.IsEmpty() )
    {
        return FALSE;
    }

    Win4Assert( _keyHeap.Top()->GetKey() != 0 );
    Win4Assert( _keyHeap.Top()->WorkId() != widInvalid );

    //
    // Move all cursors with the lowest key to widHeap
    //
    CKeyBuf key = *_keyHeap.Top()->GetKey();

    do {
        CKeyCursor* cur = _keyHeap.RemoveTop();
        _widHeap.Add ( cur );
    } while ( !_keyHeap.IsEmpty()
        && AreEqual (&key, _keyHeap.Top()->GetKey()) );

    _iid = _widHeap.Top()->IndexId();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\stat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       STAT.CXX
//
//  Contents:   Statistics support.
//
//  Classes:    CStat -- Basic statistics object
//
//  History:    23-May-91       KyleP          Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define INPTR stm
#define DEB_PRINTF( x ) fprintf x

#include "stat.hxx"

double _sqrt (double);

//+---------------------------------------------------------------------------
//
//  Member:     CStat::CStat, public
//
//  Synopsis:   Initializes statistics object.
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CStat::CStat()
{
    ClearCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::ClearCount, public
//
//  Synopsis:   Clears the statistics object (Count() == 0).
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CStat::ClearCount()
{
    _count = 0;
    _sigma = 0;
    _sigmaSquared = 0;
    _min = 0xFFFFFFFF;
    _max = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::Add, public
//
//  Synopsis:   Adds a data point.
//
//  Arguments:  [Item] -- New data item to add.
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CStat::Add(unsigned long Item)
{
    _count++;
    _sigma += Item;
    _sigmaSquared += (Item * Item);
    _min = __min(_min, Item);
    _max = __max(_max, Item);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::Count, public
//
//  Returns:    The number of data points which have been added.
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

int CStat::Count() const
{
    return(_count);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::Mean, public
//
//  Returns:    The mean of the data.
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

double CStat::Mean() const
{
    if (_count == 0)
        return(0);
    else
        return((double)_sigma / (double)_count);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::SDev, public
//
//  Returns:    The standard deviation of the data.
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

double CStat::SDev() const
{
    if (_count < 2)
        return(0.0);
    else
    {

        //
        //        __      /---------------------
        // SDev =   \    /   1     n        _ 2
        //           \  / ------- SUM (x  - x)
        //            \/   n - 1  i=1   i
        //

        double mean = Mean();

#if 1
        double TmpV =  (1.0 /
                       ((double)_count - 1.0)) *
                       ((double)_sigmaSquared
                          - 2.0 * mean * (double)_sigma
                          + mean * mean * (double)_count);
        double SqrtTmpV = _sqrt(TmpV);

        ciDebugOut (( 0x30000000, "***** Value : %f Square Root : %f\n",
                     TmpV, SqrtTmpV ));
        return(SqrtTmpV);
#else
        return(_sqrt( (1.0 /
                       ((double)_count - 1.0)) *
                       ((double)_sigmaSquared
                          - 2.0 * mean * (double)_sigma
                          + mean * mean * (double)_count)));
#endif
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::Total, public
//
//  Returns:    The sum of the data.
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

unsigned long CStat::Total() const
{
    return(_sigma);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::Min, public
//
//  Returns:    The minimum data point.
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

unsigned long CStat::Min() const
{
    return(_min);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::Max, public
//
//  Returns:    The maximum data point.
//
//  History:    24-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

unsigned long CStat::Max() const
{
    return(_max);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStat::Print, public
//
//  Synopsis:   Print the statistical data.
//
//  Arguments:  [stm] -- Stream to print to.
//
//              [szName] -- Descriptive string for these stats.
//
//              [fHeader] -- Prints a header if non-zero.
//
//              [Div] -- Factor to divide the results by. In general
//                       this will be either 1 (counting bytes) or
//                       8 (counting bits, want to display bytes).
//
//  History:    28-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CStat::Print(FILE * stm, char * szName, int fHeader, unsigned int Div)
{
    if (fHeader)
    {

        //
        //           0    5    0    5    0    5    0    5    0    5    0    5    0    5
        //

        DEB_PRINTF((INPTR, "                 Mean     SDev    Min    Max     Count    Sum\n" ));
        DEB_PRINTF((INPTR, "               -------- -------- ------ ------ -------- ---------\n" ));
    }

    Win4Assert ( Div != 0 );

    DEB_PRINTF((INPTR, "%-13s: %8.2lf %8.2lf %6lu %6lu %8u %9lu\n",
            szName,
            Mean() / (double)Div,
            SDev() / (double)Div,
            Min() / (unsigned long)Div,
            Max() / (unsigned long)Div,
            Count(),
            Total() / (unsigned long)Div ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistrib::CDistrib, public
//
//  Synopsis:   Constructor for statistical distribution object.
//
//  Arguments:  [cBuckets] -- Count of ranges for which counts will be
//                            kept. A larger [cBuckets] --> greater accuracy.
//
//              [min] -- Minimum value to be added.
//
//              [max] -- Maximum value to be added.
//
//  History:    07-Jun-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CDistrib::CDistrib(
        unsigned int cBuckets,
        unsigned long min,
        unsigned long max)
{
    _min = min;

    _cBuckets = cBuckets;

    unsigned long width = (max - min + 1) / cBuckets;

    if (width == 0)
    {
        width = 1;
        _cBuckets = (max - min + 1);
    }

    _maxcount = 0;

    _aBucket = new unsigned long [_cBuckets];
    _aMaxBucket = new unsigned long [_cBuckets];

    if ((_aBucket == 0) || (_aMaxBucket == 0))
    {
        _cBuckets = 0;
        delete _aBucket;
        delete _aMaxBucket;
        return;
    }

    for (unsigned int i = 0; i < _cBuckets; i++)
    {
        _aBucket[i] = 0;
        _aMaxBucket[i] = _min + width*(i+1) - 1;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistrib::CDistrib, public
//
//  Synopsis:   Constructor for statistical distribution object.
//
//  Arguments:  [cBuckets] -- Count of ranges for which counts will be
//                            kept. A larger [cBuckets] --> greater accuracy.
//
//              [min] -- Minimum value to be added.
//
//              [aMaxBucket] -- An array of maximums for each bucket.
//                              Bucket #0 contains entries from [min] to
//                              [aMaxBucket][0]. The ith bucket holds
//                              entries from [aMaxBucket][i-1] + 1 to
//                              [aMaxBucket][i].
//
//  History:    18-Jun-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CDistrib::CDistrib(
        unsigned int cBuckets,
        unsigned long min,
        unsigned long * aMaxBucket)
{
    _min = min;

    _cBuckets = cBuckets;

    _maxcount = 0;

    _aBucket = new unsigned long [_cBuckets];
    _aMaxBucket = new unsigned long [_cBuckets];

    if ((_aBucket == 0) || (_aMaxBucket == 0))
    {
        _cBuckets = 0;
        delete _aBucket;
        delete _aMaxBucket;
        return;
    }

    memset(_aBucket, 0, sizeof(unsigned long) * _cBuckets);

    for (unsigned int i = 0; i < _cBuckets; i++)
    {
        _aMaxBucket[i] = aMaxBucket[i];
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistrib::~CDistrib, public
//
//  Synopsis:   Displays statistical distribution.
//
//  History:    07-Jun-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CDistrib::~CDistrib()
{
    delete _aBucket;
    delete _aMaxBucket;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistrib::Add, public
//
//  Synopsis:   Add a new data point.
//
//  Arguments:  [Item] -- the data point.
//
//  Requires:   [Item] is between the min and max specified in the
//              constructor.
//
//  History:    07-Jun-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CDistrib::Add(unsigned long Item)
{
    if ((_cBuckets == 0) ||
        (Item < _min) ||
        (Item > _aMaxBucket[_cBuckets - 1]))
    {
        return;
    }

    for (unsigned int i = _cBuckets;
            (i > 0) && (Item <= _aMaxBucket[i-1]);
            i--);

    if (++_aBucket[i] > _maxcount)
        _maxcount = _aBucket[i];
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistrib::Print, public
//
//  Synopsis:   Display the results.
//
//  Arguments:  [INPTR] -- Output stream.
//
//  History:    07-Jun-91   KyleP       Created.
//
//----------------------------------------------------------------------------

void CDistrib::Print(FILE * stm)
{
    unsigned long div = __max(_maxcount / 50, 1);
    unsigned int  fEmpty = 0;

    for (unsigned int i = 1; i <= _cBuckets; i++)
    {
        if (_aBucket[_cBuckets - i] == 0)
        {
            if (!fEmpty)
            {
                fEmpty = 1;
                DEB_PRINTF((INPTR, "   :\n" ));
            }
            continue;
        }

        fEmpty = 0;

        DEB_PRINTF((INPTR, "%ld - %ld: (%ld)\t",
                (i == _cBuckets ? _min : _aMaxBucket[_cBuckets - i - 1] + 1),
                _aMaxBucket[_cBuckets - i],
                _aBucket[_cBuckets - i] ));

        for (unsigned int j = 0; j < _aBucket[_cBuckets - i] / div; j++)
        {
            DEB_PRINTF((INPTR, "*"));
        }

        DEB_PRINTF((INPTR, "\n"));
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CPopularKeys::CPopularKeys, public
//
//  Arguments:  [cKeep] -- Keep track of top [cKeep] keys
//
//  History:    14-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

CPopularKeys::CPopularKeys( int cKeep )
        : _cKeep( cKeep )
{
    _acWid = new unsigned long [cKeep];
    _aKey = new CKeyBuf [cKeep];

    for ( int i = 0; i < cKeep; i++ )
    {
        _acWid[i] = 0;
    }
}


CPopularKeys::~CPopularKeys()
{
    delete [] _acWid;
    delete [] _aKey;
}

void CPopularKeys::Add( CKeyBuf const & key, unsigned long cWid )
{
    if ( cWid > _acWid[0] )
    {
        for ( int i = 0; i < _cKeep && cWid > _acWid[i]; i++ )
            continue;                       // NULL Body
        i--;

        for ( int j = 0; j < i; j++ )
        {
            _acWid[j] = _acWid[j+1];
            _aKey[j] = _aKey[j+1];
        }

        _acWid[i] = cWid;
        _aKey[i] = key;
    }
}

void CPopularKeys::Print(FILE * stm)
{
#if CIDBG == 1
    DEB_PRINTF(( INPTR,
             " Count   Key\n"
             "-------  ----------------------------------\n" ));

    for ( int i = _cKeep - 1; i >= 0; i-- )
    {
        //
        //  If this is a STRING in the contents, then print it out
        //
        if ( STRING_KEY == _aKey[i].Type() )
        {
            DEB_PRINTF(( INPTR, "%7u  (CONT) \"%.*ws\"\n",
                     _acWid[i], _aKey[i].StrLen(), _aKey[i].GetStr() ));
        }
        else if (_aKey[i].Count() > cbKeyPrefix)
        {
            //
            //  This is one of the various properties.  Dump it out
            //
            DEB_PRINTF(( INPTR, "%7u  (PROP)  Pid=0x%4.4x  Type=%3.1d  Len=%3.1d\t\t",
                     _acWid[i],
                     _aKey[i].Pid(),
                     _aKey[i].Type(),
                     _aKey[i].Count() - 1
                   ));

            BYTE *pb = (UCHAR *) _aKey[i].GetBuf();

            pb += cbKeyPrefix;          // Skip over key's prefix

            for ( unsigned j=cbKeyPrefix; j<_aKey[i].Count(); j++ )
            {
                DEB_PRINTF((INPTR, "%2.2x ", *pb));
                pb++;
            }

            DEB_PRINTF((INPTR, "\n"));
        }
    }
#endif // CIDBG == 1
}


#define _u_ 0.000001

inline double __Square ( double value )
{
   return(value*value);
}

inline double __abs( double value )
{
   return( value > 0.0 ? value : (0.0 - value) );
}

//+ --------------------------------------------------------------------
//
//  Function Name : sqrt
//
//  Argument : [value]
//
//  Purpose : Find the square root of the "value"
//
//  Created : t-joshh   March 6, 1993
//
// ---------------------------------------------------------------------

double _sqrt ( double value )
{
   double LowValue = 0.0;
   double HighValue = value;
   double med_value = ( HighValue + LowValue ) / 2;

   for (; ; ) {
      double TmpValue = __Square(med_value) - value;

      if ( __abs(TmpValue) < _u_ )
      {
         break;
      }

      if ( TmpValue > 0 )
      {
         HighValue = med_value;
      }
      else
      {
         LowValue = med_value;
      }

      med_value = ( HighValue + LowValue ) / 2;
   }

   return(med_value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\wordlist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       WordList.Cxx
//
//  Contents:   Implementation of the CWordList class
//
//  Classes:    CWordList
//
//  History:    06-Mar-91       KyleP       Created.
//              04-Apr-91       BartoszM    Removed init
//              10-May-91       BartoszM    Load CWLCursor cache correctly
//              13-May-91       KyleP       Removed extraneous TRY ... CATCH
//              22-May-91       Brianb      Changed to use own sorter
//              04-Jun-91       BartoszM    Rewrote it
//              19-Jun-91       reviewed
//              18-Mar-93       AmyA        Moved all entry buffer code to
//                                          ebufhdlr.cxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <doclist.hxx>

#include "wordlist.hxx"
#include "invcur.hxx"

//+---------------------------------------------------------------------------
//
// Member:     CWordList::Size, public
//
// Synopsis:   Returns rough size estimate in 4k pages
//
// History:    22-May-92    BartoszM       Created.
//
//----------------------------------------------------------------------------

unsigned CWordList::Size() const
{
    unsigned size = 0;

    CSortChunk * p = _chunks;

    while ( 0 != p )
    {
        size += p->BlockCount() * ( cbInitialBlock / 4096 );

        p = p->next;
    }

    //
    // If we have 'unfiltered' documents, then add a one size unit for
    // them.
    //

    if ( _fUnfiltered )
        size += 1;

    return size;
} //Size

//+---------------------------------------------------------------------------
//
// Member:     CWordList::CWordList, public
//
// Synopsis:   Constructor for CWordList
//
// Effects:    Initializes sort data structures
//
// Arguments:   [id] -- Index ID of the wordlist.
//              [widMax] -- maximum work id
//              [cbMemory] -- suggested size of buffer
//
// History:     07-Mar-91   KyleP       Created.
//              03-Apr-91   KyleP       Combined with initialization
//              22-May-91   Brianb      Converted to use new sort algorithm
//
//----------------------------------------------------------------------------
CWordList::CWordList( INDEXID iid, WORKID widMax )
        : CIndex(iid),
          _sigWordList(eSigWordList),
          _chunks(0),
          _count(0),
          _fUnfiltered(FALSE)
{
    // check sizes of data items in index
    ciAssert(sizeof(PROPID) == 4);
    ciAssert(sizeof(OCCURRENCE) == 4);
    // Make sure the sentinel is not too big
    ciAssert(MAXKEYSIZE < 256);

    SetMaxWorkId ( widMax );
}

//+---------------------------------------------------------------------------
//
// Member:     CWordList::~CWordList, public
//
// Synopsis:   Destructor
//
// Effects:    Release all memory used by
//
// History:    06-Mar-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CWordList::~CWordList()
{
    while( _chunks != NULL)
    {
        CSortChunk *pChunk = _chunks;
        _chunks = _chunks->next;
        delete pChunk;
    }
}

//+---------------------------------------------------------------------------
//
// Member:     CWordList::MakeChunk, public
//
// Synopsis:   Creates new sorted chunk from data in entry buffer
//
// Arguments:  [pEntryBuf] -- pointer to buffer to create sorted chunk from
//             [cb] -- count of bytes in buffer
//
// Expects:    Sentinel entry added to pEntryBuf and that the buffer is in the
//             correct format.
//
// Returns:    FALSE if there was a memory exception.  TRUE otherwise.
//
// History:    04-Jun-89    BartoszM    Created.
//             18-Mar-93    AmyA        Added entry buffer passing
//
//----------------------------------------------------------------------------


BOOL CWordList::MakeChunk ( const BYTE * pEntryBuf, ULONG cb )
{
    XPtr<CSortChunk> xChunk( new CSortChunk( _maxOccTable ) );
    xChunk->Init( pEntryBuf, cb, MaxWorkId() );
    CSortChunk* pChunk = xChunk.Acquire();
    pChunk->next = _chunks;
    _chunks = pChunk;
    _count++;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Member:      CWordList::QueryCursor, public
//
// Synopsis:    Create a cursor for the WordList
//
// Effects:     Creates a cursor
//
// Returns:     A pointer to a CKeyCursor.
//
// History:     15-Apr-91   KyleP       Created.
//              22-May-92   BrianB      Modified to use chunk merges
//              07-Jun-91   BartoszM    Rewrote
//              24-Jan-92   AmyA        Modified to use CKeyCurArray to remove
//                                      TRY...CATCH.
//
//----------------------------------------------------------------------------

CKeyCursor * CWordList::QueryCursor()
{
    if ( 0 == _count && !_fUnfiltered )
        return 0;

    CKeyCursor *pCur = 0;

    if ( 0 == _count && _fUnfiltered )
    {
        pCur = new CUnfilteredCursor( GetId(), MaxWorkId(), _widTable );
    }
    else if ( _count == 1 && !_fUnfiltered )
    {
        // single chunk return chunk cursor

        pCur = _chunks->QueryCursor( GetId(), _widTable, MaxWorkId() );
    }
    else
    {
        // multiple chunks create merge cursor

        CKeyCurStack stkCursor;

        for ( CSortChunk* pChunk = _chunks;
              pChunk != 0;
              pChunk = pChunk->next )
        {
            XPtr<CKeyCursor> xCur( pChunk->QueryCursor( GetId(),
                                                        _widTable,
                                                        MaxWorkId() ) );

            if ( !xCur.IsNull() )
            {
                stkCursor.Push( xCur.GetPointer() );
                xCur.Acquire();
            }
        }

        if ( _fUnfiltered )
        {
            XPtr<CUnfilteredCursor> xCur( new CUnfilteredCursor( GetId(),
                                                                 MaxWorkId(),
                                                                 _widTable ) );
            stkCursor.Push( xCur.GetPointer() );
            xCur.Acquire();
        }

        pCur = stkCursor.QueryWlCursor( MaxWorkId() );
    }

    return pCur;
} //QueryCursor

//+---------------------------------------------------------------------------
//
// Member:      CWordList::QueryKeyCursor, public
//
// Synopsis:    Create a cursor for the WordList
//
// Returns:     A pointer to a CKeyCursor.
//
// History:     06-Oct-98   dlee        Added header, author unknown
//
//----------------------------------------------------------------------------

CKeyCursor * CWordList::QueryKeyCursor( CKey const * pkeyTarget )
{
    CKeyCursor * pcur = QueryCursor();

    for ( CKeyBuf const * pkey = pcur->GetKey();
          pkey != 0 && pkey->Compare( *pkeyTarget ) < 0;
          pkey = pcur->GetNextKey() )
        continue;

    if ( 0 != pkey )
    {
        if ( pkey->Compare( *pkeyTarget ) == 0 )
            return pcur;
    }

    delete pcur;
    return 0;
} //QueryKeyCursor

//+---------------------------------------------------------------------------
//
// Member:      CWordList::QueryCursor, public
//
// Synopsis:    Create a cursor for the WordList
//
// Effects:     Creates a cursor
//
// Arguments:   [pkey]      -- Key to initially position the cursor on.
//              [isRange]   -- TRUE for range query
//              [cMaxNodes] -- Max number of nodes to create. Decremented
//                             on return.
//
// Returns:     A pointer to a CKeyCursor.
//
// History:     15-Apr-91   KyleP       Created.
//              22-May-92   BrianB      Modified to use chunk merges
//              07-Jun-91   BartoszM    Rewrote
//              24-Jan-92   AmyA        Modified to use CKeyCurArray to remove
//                                      TRY...CATCH.
//
//----------------------------------------------------------------------------
COccCursor * CWordList::QueryCursor( const CKey * pkey,
                                     BOOL isRange,
                                     ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    if ( _count == 0 && !_fUnfiltered )
        return 0;

    if (isRange)
    {
        CKey keyEnd;
        keyEnd.FillMax (*pkey);
        return QueryRangeCursor ( pkey, &keyEnd, cMaxNodes );
    }

    if (pkey->Pid() == pidAll)
    {
        return QueryRangeCursor ( pkey, pkey, cMaxNodes );
    }

    cMaxNodes--;

    if ( 0 == cMaxNodes )
    {
        ciDebugOut(( DEB_WARN, "Exceeded node limit in: CWordList::QueryCursor\n" ));
        THROW( CException( STATUS_TOO_MANY_NODES ) );
    }

    CKeyCursor *pCur = 0;

    if ( CUnfilteredCursor::CompareAgainstUnfilteredKey( *pkey ) == 0 )
    {
        pCur = new CUnfilteredCursor( GetId(), MaxWorkId(), _widTable );
    }
    else
    {
        if(_count == 1)
        {
            // single chunk return chunk cursor

            pCur = _chunks->QueryCursor ( GetId(), _widTable, pkey, MaxWorkId() );
        }
        else
        {
            // multiple chunks create merge cursor

            CKeyCurStack stkCursor;

            for ( CSortChunk* pChunk = _chunks;
                  pChunk != 0;
                  pChunk = pChunk->next)
            {
                XPtr<CKeyCursor> xCur( pChunk->QueryCursor( GetId(),
                                                            _widTable,
                                                            pkey,
                                                            MaxWorkId() ) );

                if ( !xCur.IsNull() )
                {
                    stkCursor.Push( xCur.GetPointer() );
                    xCur.Acquire();
                }
            }

            pCur = stkCursor.QueryWlCursor( MaxWorkId() );
        }
    }

    return pCur;
} //QueryCursor

//+---------------------------------------------------------------------------
//
// Member:      CWordList::QueryRangeCursor, public
//
// Synopsis:    Create a range cursor for the WordList
//
// Effects:     Creates a cursor
//
// Arguments:   [pkey]      -- Beginning of query range.
//              [pkeyEnd]   -- End of query range.
//              [cMaxNodes] -- Max number of nodes to create. Decremented
//                             on return.
//
// Returns:     A pointer to a CKeyCursor.
//
// History:     27-Jan-92   AmyA        Created.
//              07-Feb-92   AmyA        Moved some code to CreateRange().
//
//----------------------------------------------------------------------------
COccCursor * CWordList::QueryRangeCursor( const CKey * pkey,
                                          const CKey * pkeyEnd,
                                          ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    Win4Assert( pkey->Pid() == pkeyEnd->Pid() );
//    Win4Assert( pkey->Pid() != pidAll ||
//                pkey->CompareStr( *pkeyEnd ) == 0 );

    //
    // Decide if the invalid key is in the range.
    //

    BOOL fInvalidInRange;

    if ( pkey->Pid() == pidUnfiltered )
    {
        cMaxNodes--;

        if ( 0 == cMaxNodes )
        {
            ciDebugOut(( DEB_WARN, "Exceeded node limit in: CWordList::QueryRangeCursor\n" ));
            THROW( CException( STATUS_TOO_MANY_NODES ) );
        }

        if ( _fUnfiltered &&
             CUnfilteredCursor::CompareAgainstUnfilteredKey( *pkey ) >= 0 &&
             CUnfilteredCursor::CompareAgainstUnfilteredKey( *pkeyEnd ) <= 0 )
        {
            return new CUnfilteredCursor( GetId(), MaxWorkId(), _widTable );
        }
        else
        {
            return( 0 );
        }
    }

    ciDebugOut(( DEB_ITRACE, "Chunk count is %d\n", _count ));

    if ( _count == 0 )
        return 0;

    //
    // Cheat a little here. Build the whole range before subtracting nodes.  Also, consider
    // a 'node' to be one cursor in every chunk.  So only subtract off the maximum contribution
    // of any single chunk.
    //

    COccCurStack curStk;

    ULONG cMaxPerChunk = 0;
    ULONG cCursor = 0;

    for (CSortChunk* pChunk = _chunks;
         pChunk != 0;
         pChunk = pChunk->next)
    {
        pChunk->CreateRange(curStk, pkey, pkeyEnd, GetId(), _widTable, MaxWorkId());

        Win4Assert( curStk.Count() >= cCursor );

        ULONG cInChunk = curStk.Count() - cCursor;

        if ( cInChunk > cMaxPerChunk )
        {
            cMaxPerChunk = cInChunk;

            if ( cMaxPerChunk >= cMaxNodes )
            {
                ciDebugOut(( DEB_WARN, "Exceeded node limit in: CWordList::QueryRangeCursor\n" ));
                cMaxNodes = 0;

                THROW( CException( STATUS_TOO_MANY_NODES ) );
            }
        }

        cCursor = curStk.Count();
    }

    cMaxNodes -= cMaxPerChunk;
    Win4Assert( cMaxNodes > 0 );

    return curStk.QuerySynCursor(MaxWorkId());
}

//+---------------------------------------------------------------------------
//
// Member:      CWordList::QuerySynCursor, public
//
// Synopsis:    Create a synonym cursor for the WordList
//
// Effects:     Creates a cursor
//
// Arguments:   [keyStk]    -- Keys to query on.
//              [isRange]   -- Whether the query will be a range query.
//              [cMaxNodes] -- Max nodes (keys) to add
//
// Returns:     A pointer to a CKeyCursor.
//
// History:     31-Jan-92   AmyA        Created.
//
//----------------------------------------------------------------------------
COccCursor * CWordList::QuerySynCursor( CKeyArray & keyArr,
                                        BOOL isRange,
                                        ULONG & cMaxNodes )
{
    Win4Assert( cMaxNodes > 0 );

    if (_count == 0)
        return(0);

    //
    // Cheat a little here. Build the whole range before subtracting nodes.  Also, consider
    // a 'node' to be one cursor in every chunk.  So only subtract off the maximum contribution
    // of any single chunk.
    //

    COccCurStack curStk;

    ULONG cMaxPerChunk = 0;
    ULONG cCursor = 0;

    int keyCount = keyArr.Count();

    ciDebugOut((DEB_ITRACE, "KeyCount is %d\n", keyCount));

    for (CSortChunk* pChunk = _chunks;
            pChunk != 0;
            pChunk = pChunk->next)
    {
        for (int i = 0; i < keyCount; i++)
        {
            CKey& key = keyArr.Get(i);

            ciDebugOut((DEB_ITRACE, "Key is %.*ws\n", key.StrLen(), key.GetStr()));
            if (isRange)
            {
                CKey keyEnd;
                keyEnd.FillMax(key);

                pChunk->CreateRange(
                    curStk, &key, &keyEnd, GetId(), _widTable, MaxWorkId());
            }
            else if ( key.Pid() == pidAll )
            {
                pChunk->CreateRange(
                    curStk, &key, &key, GetId(), _widTable, MaxWorkId());
            }
            else
            {
                XPtr<CChunkCursor> xNewCur( pChunk->QueryCursor(
                    GetId(), _widTable, &key, MaxWorkId() ) );
                if ( !xNewCur.IsNull() )
                {
                    curStk.Push( xNewCur.GetPointer() );
                    xNewCur.Acquire();
                }
            }
        }

        Win4Assert( curStk.Count() >= cCursor );

        ULONG cInChunk = curStk.Count() - cCursor;

        if ( cInChunk > cMaxPerChunk )
        {
            cMaxPerChunk = cInChunk;

            if ( cMaxPerChunk >= cMaxNodes )
            {
                ciDebugOut(( DEB_WARN, "Exceeded node limit in: CWordList::QuerySynCursor\n" ));
                cMaxNodes = 0;

                THROW( CException( STATUS_TOO_MANY_NODES ) );
            }
        }

        cCursor = curStk.Count();
    }

    cMaxNodes -= cMaxPerChunk;
    Win4Assert( cMaxNodes > 0 );

    return curStk.QuerySynCursor(MaxWorkId());
}

void CWordList::GetDocuments( CDocList & doclist )
{
    unsigned cWid = 0;

    for ( unsigned i = 0; i < _widTable.Count(); i++ )
    {
        if ( _widTable.FakeWidToWid(iDocToFakeWid(i)) != widInvalid )
        {
            doclist.Set( cWid,
                         _widTable.FakeWidToWid( iDocToFakeWid(i) ),
                         0,      // Use usn of 0 for refiled wids
                         _widTable.VolumeId( iDocToFakeWid(i) ) );
            cWid++;
        }
    }

    doclist.LokSetCount( cWid );    //  okay not to have resman lock here
}

//+---------------------------------------------------------------------------
//
// Member:      CWordList::Done, public
//
// Synopsis:    Called when a wordlist if fully constructed and available
//              for query.
//
// Effects:     Sets _fUnfiltered to TRUE if there are wids in the wid table
//              that have been invalidated.
//
// History:     09-Nov-94    KyleP      Created.
//
//----------------------------------------------------------------------------

void CWordList::Done()
{
    Win4Assert( !_fUnfiltered );

    //
    // How many invalid wids are there?
    //

    unsigned cUnfiltered = 0;

    for ( unsigned i = 1; i <= _widTable.Count(); i++ )
    {
        if ( _widTable.IsValid(i) && !_widTable.IsFiltered(i) )
            cUnfiltered++;
    }

    //
    // Create chunk of invalid property.
    //

    if ( cUnfiltered > 0 )
    {
        ciDebugOut(( DEB_ITRACE, "%d unfiltered wids in wordlist %x\n",
                     cUnfiltered, GetId() ));

        _fUnfiltered = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\atlinc.cxx ===
//+---------------------------------------------------------------------------
//  
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1998
//
// File:        atlinc.cxx
//
// Contents:    source file that includes just the standard ATL includes
//
// History:     1-6-98  mohamedn    created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stdafx.h"
#include <statreg.h>
#include <statreg.cpp>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\unioncur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1995.
//
//  File:       UNIONCUR.CXX
//
//  Contents:   Merge Cursor.  Computes union of multiple cursors.
//
//  Classes:    CUnionCursor
//
//  History:    26-Sep-91   BartoszM    Created
//              17-Jun-92   BartoszM    Separated from OrCursor
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "unioncur.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CUnionCursor::CUnionCursor, public
//
//  Synopsis:   Create a cursor that merges a number of cursors.
//
//  Arguments:  [cCursor] -- count of cursors
//              [curStack] -- stack of cursors to be merged
//
//  History:    26-Sep-91   BartoszM    Created
//
//  Notes:      The cursors and the array will be deleted by destructor.
//
//----------------------------------------------------------------------------

CUnionCursor::CUnionCursor( int cCursor, CCurStack& curStack )
{
    // Two step construction of the heap.
    // We have to make sure that all cursors have a valid key

    int count = 0;
    CCursor** aCursor = curStack.AcqStack();
    // remove empty cursors
    for ( int i = 0; i < cCursor; i++ )
    {
        ciAssert ( aCursor[i] != 0 );
        if ( aCursor[i]->WorkId() == widInvalid )
        {
            delete aCursor[i];
        }
        else if ( count != i )
            aCursor[count++] = aCursor[i];
        else
            count++;
    }

    _widHeap.MakeHeap ( count, aCursor );
    if ( !_widHeap.IsEmpty() )
    {
        _iid = _widHeap.Top()->IndexId();
        _pid = _widHeap.Top()->Pid();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CUnionCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    26-Sep-91   BartoszM    Created
//
//----------------------------------------------------------------------------

WORKID  CUnionCursor::WorkId()
{
    if ( _widHeap.IsEmpty() )
        return widInvalid;

    return _widHeap.Top()->WorkId();
}


//+---------------------------------------------------------------------------
//
//  Member:     CUnionCursor::NextWorkId, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  Effects:    Changes current IndexId.
//
//  History:    26-Sep-91   BartoszM    Created
//
//  Notes:      The same work id may be returned multiple times,
//              corresponding to multiple indexes. Fresh List
//              will filter out the ones that are stale.
//
//----------------------------------------------------------------------------

WORKID CUnionCursor::NextWorkId()
{
    if ( _widHeap.IsEmpty() )
        return widInvalid;

    _widHeap.Top()->NextWorkId();
    _widHeap.Reheap();

    WORKID wid = _widHeap.Top()->WorkId();

    if ( wid != widInvalid )
    {
        _pid = _widHeap.Top()->Pid();
        _iid = _widHeap.Top()->IndexId();
    }
    else
        _pid = pidInvalid;
    return wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnionCursor::RatioFinished, public
//
//  Synopsis:   return approximate ratio of documents processed to total
//              documents.
//
//  Notes:      The ratio, while approximate, should not return 1/1 until
//              all cursors are exhausted.
//
//----------------------------------------------------------------------------

void CUnionCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    WORKID widTop = WorkId();
    if (widTop == widInvalid)
    {
        denom = num = 1;
        return;
    }

    CCursor **vector = _widHeap.GetVector();
    int count = _widHeap.Count();

    denom = 0;
    num   = 0;

    unsigned cValid = 1;

    for (int i=0; i < count; i++)
    {
        ULONG d, n;
        vector[i]->RatioFinished(d, n);
        denom += d;
        num += n;
        Win4Assert( denom >= d && d > 0);       // overflow?

        if (n == d)
        {
            WORKID widCurrent = vector[i]->WorkId();
            if (widCurrent != widInvalid && widCurrent != widTop)
                cValid++;
        }
    }
    if (num == denom && cValid > 1)
        denom++;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUnionCursor::WorkIdCount, public
//
//  Synopsis:   Do nothing
//
//  History:    26-Sep-91   BartoszM    Created
//
//----------------------------------------------------------------------------

ULONG CUnionCursor::WorkIdCount()
{
    ciAssert (( FALSE && "UnionCursor::WorkIdCount called" ));
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnionCursor::HitCount, public
//
//  Synopsis:   return occurrence count
//
//  History:    28-Feb-92   AmyA        Created
//
//  Notes:      returns the occurrence count for the wid on top of _widHeap.
//
//----------------------------------------------------------------------------

ULONG CUnionCursor::HitCount()
{
    ciAssert( !_widHeap.IsEmpty() );

    return _widHeap.Top()->HitCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnionCursor::Rank, public
//
//  Synopsis:   return occurrence count
//
//  History:    28-Feb-92   AmyA        Created
//
//  Notes:      returns the occurrence count for the wid on top of _widHeap.
//
//----------------------------------------------------------------------------

LONG CUnionCursor::Rank()
{
    ciAssert( !_widHeap.IsEmpty() );

    return _widHeap.Top()->Rank();
}


//+-------------------------------------------------------------------------
//
//  Member:     CUnionCursor::GetRankVector, public
//
//  Effects:    Returns the weights from a vector cursor.  No effect
//              for non-vector cursors.
//
//  Arguments:  [pulVector] -- Pointer to array of ULONG into which the
//                             vector elements are returned.
//
//  Returns:    The number of elements stored in [pulVector].
//
//  History:    15-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

ULONG CUnionCursor::GetRankVector( LONG * plVector, ULONG cElements )
{
    ciAssert( !_widHeap.IsEmpty() );

    return( _widHeap.Top()->GetRankVector( plVector, cElements ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cindex\widarr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       WIDARR.CXX
//
//  Contents:   Work ID array
//
//  Classes:    CWidArray
//
//  History:    28-Oct-91   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <doclist.hxx>

#include "widarr.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CWidArray::CWidArray, public
//
//  Synopsis:   Allocates empty array of cnt elements
//
//  Arguments:  [cnt] -- size of array
//
//  History:    20-Oct-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

CWidArray::CWidArray ( unsigned cnt )
: _count(cnt)
{
    _table = new WORKID[_count];
}

//+---------------------------------------------------------------------------
//
//  Member:     CWidArray::CWidArray, public
//
//  Synopsis:   Copies these wids from DocList that correspond
//              to pidAll and whose status is SUCCESS or PENDING
//              and sorts them
//
//  Arguments:  [DocList] -- list of documents
//
//  History:    20-Oct-91   BartoszM       Created.
//
//  Notes:      Elements are sorted for the binary search to work
//
//----------------------------------------------------------------------------

CWidArray::CWidArray ( CDocList& DocList )
: _table (0), _count(0)
{
    unsigned max = DocList.Count();

    for ( unsigned i = 0; i < max; i++ )
    {
        STATUS status = DocList.Status(i);
        if ( status == SUCCESS ||  status == PENDING )
            _count++;
    }

    // create a table of wid's

    unsigned j = 0;

    if ( _count > 0 )
    {
        _table = new WORKID [ _count ];
        for ( i = 0; i < max; i++ )
        {

            STATUS status = DocList.Status(i);
            if ( status == SUCCESS ||  status == PENDING )
                _table[j++] = DocList.Wid(i);
        }
    }

#if CIDBG==1
    // check to make sure it's sorted.
    if ( _count > 0 )
        for ( i = 0; i < _count - 1; i++ )
        {
            ciAssert( _table[i+1]==widInvalid || _table[i] < _table[i+1] );
        }
#endif // CIDBG
}

//+---------------------------------------------------------------------------
//
//  Member:     CWidArray::Find, public
//
//  Synopsis:   Finds given work id
//
//  Arguments:  [wid] -- work id to search for
//
//  History:    20-Oct-91   BartoszM       Created.
//
//  Notes:      Uses binary search
//
//----------------------------------------------------------------------------

BOOL CWidArray::Find ( WORKID wid ) const
{
    int low = 0;
    int high = _count-1;

    while ( high >= low )
    {
        int mid = (low + high)/2;
        WORKID widMid = _table[mid];
        if ( widMid == wid )
            return TRUE;
        else if ( wid < widMid )
            high = mid-1;
        else // wid > widMid
            low = mid+1;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\ciodm.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1998
//
// File:        ciodm.cxx
//
// Contents:    Implementation of DLL Exports.
//
// History:     12-10-97    mohamedn/ATL Generated
//
//----------------------------------------------------------------------------

// Note: Proxy/Stub Information
//       To build a separate proxy/stub DLL, 
//       run nmake -f ciodmps.mk in the project directory.

#include "pch.cxx"
#pragma hdrstop

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include <ciodm.h>

#include "ciodmGUID.h"
#include "MacAdmin.hxx"
#include "CatAdm.hxx"
#include "scopeadm.hxx"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_AdminIndexServer, CMachineAdm)
        OBJECT_ENTRY(CLSID_CatAdm, CCatAdm)
        OBJECT_ENTRY(CLSID_ScopeAdm, CScopeAdm)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
        if (dwReason == DLL_PROCESS_ATTACH)
        {
                _Module.Init(ObjectMap, hInstance);

                DisableThreadLibraryCalls(hInstance);
        }
        else if (dwReason == DLL_PROCESS_DETACH)
                _Module.Term();
        return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
        // registers object, typelib and all interfaces in typelib
        return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\resource.h ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1997, Microsoft Corporation.
//
// File:        resource.h
//
// Contents:    ciodm message ids
//
// History:     12-10-97	mohamedn 	created
//
//----------------------------------------------------------------------------


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ciodm.rc
//
#define IDS_PROJNAME                    100
#define IDR_MACHINEADM                  101
#define IDR_CATADM                      102
#define IDR_SCOPEADM                    103

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\stdafx.cxx ===
//+---------------------------------------------------------------------------
//  
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1998
//
// File:        stdafx.cxx
//
// Contents:    source file that includes just the standard includes
//
// History:     1-6-98  mohamedn    created
//
//----------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "pch.cxx"
#pragma hdrstop

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\catadm.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997 - 2000.
//
// File:        CatAdm.cxx
//
// Contents:    CI Catalog Administration Interface methods
//
// Classes:     CCatAdm
//
// History:     12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stdafx.h"

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::InterfaceSupportsErrorInfo, public
//
//  Arguments:  [riid]  -- interface iid
//
//  Returns:    TRUE if interface supports IErrorInfo
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::InterfaceSupportsErrorInfo(REFIID riid)
{

        return ( riid == IID_ICatAdm );

}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::SetErrorInfo, public
//
//  Synopsis:   Creates & sets the error object
//
//  Arguments:  [hRes]      -- HRESULT error code to set
//              [pwszDesc]  -- error description
//
//  Returns:    none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CCatAdm::SetErrorInfo( HRESULT hRes )
{
   CiodmError  err(hRes);

   AtlSetErrorInfo(CLSID_CatAdm,  err.GetErrorMessage(), 0 , 0, IID_ICatAdm, hRes, 0 );

}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::CCatAdm, public
//
//  Synopsis:   Constructor
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

CCatAdm::CCatAdm()
        :_eCurrentState(CIODM_NOT_INITIALIZED),
         _cMinRefCountToDestroy(1),
         _cEnumIndex(0),
         _pIMacAdm(0),
         _dwTickCount(0)
{
    //
    // empty
    //
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::Initialize, public
//
//  Synopsis:   Initializes CCatAdm object, populates scopes list
//
//  Arguments:  [xCatAdmin] -- contained catAdmin
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CCatAdm::Initialize( XPtr<CCatalogAdmin>  & xCatAdmin )
{
    Win4Assert( 0 == _aIScopeAdmin.Count() );
    Win4Assert( !xCatAdmin.IsNull() );

    CTranslateSystemExceptions xlate;

    TRY
    {
        _xCatAdmin.Set( xCatAdmin.Acquire() );

        XPtr<CScopeEnum> xScopeEnum(_xCatAdmin->QueryScopeEnum());

        for ( ; xScopeEnum->Next(); )
        {
            XPtr<CScopeAdmin> xScopeAdmin( xScopeEnum->QueryScopeAdmin() );

            XInterface<ScopeAdmObject> xIScopeAdm;

            GetScopeAutomationObject( xScopeAdmin, xIScopeAdm );

            _aIScopeAdmin.Add ( xIScopeAdm.GetPointer() , _aIScopeAdmin.Count() );

            xIScopeAdm.Acquire();

        }

        _eCurrentState = CIODM_INITIALIZED;
    }
    CATCH( CException,e )
    {
        _eCurrentState = CIODM_NOT_INITIALIZED;

        _cEnumIndex = 0;

        _xCatAdmin.Free();

        _aIScopeAdmin.Free();

        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::InternalAddRef, public
//
//  Synopsis:   overrides CComObjectRootEx<Base>::InternalAddRef, to AddRef parent too
//
//  Arguments:  none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------
ULONG CCatAdm::InternalAddRef()
{
    CLock    lock(_mtx);

    //
    // AddRef self
    //
    unsigned cRef = CComObjectRootEx<CComMultiThreadModel>::InternalAddRef();

    odmDebugOut(( DEB_TRACE,"CCatAdm(%ws) AddRef returned: %d\n",
                  _xCatAdmin.IsNull() ? L"" :  _xCatAdmin->GetName(), cRef ));

    //
    // AddRef parent if it exists (it won't if catadmin was created in bogus context)
    //

    if ( 0 != _pIMacAdm )
        _pIMacAdm->AddRef();

    odmDebugOut(( DEB_TRACE,"=========================== CCatAdm(%ws) object count: %d\n",
                  _xCatAdmin.IsNull() ? L"" :  _xCatAdmin->GetName(), _cMinRefCountToDestroy ));

    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::InternalRelease, public
//
//  Synopsis:   overrides CComObjectRootEx<Base>::InternalRelease, to release parent too.
//
//  Arguments:  none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

ULONG CCatAdm::InternalRelease()
{
    CLock    lock(_mtx);

    //
    // Delete contained objects if we're being destoryed.
    // m_dwRef is an internal ATL public refcount member.
    //

    if ( _eCurrentState != CIODM_DESTROY && m_dwRef == _cMinRefCountToDestroy )
    {
        _eCurrentState = CIODM_DESTROY;

        _aIScopeAdmin.Free();

        //
        // Assert we're the only object left to be destroyed.
        //
        Win4Assert( 1 == m_dwRef );

        Win4Assert( _cMinRefCountToDestroy == 1 );

        if ( 0 != _pIMacAdm )
            _pIMacAdm->DecObjectCount();
    }
    else
    {
        Win4Assert( 1 < m_dwRef );

        Win4Assert( 1 <= _cMinRefCountToDestroy );
    }

    //
    // Release parent
    //

    unsigned cRef = CComObjectRootEx<CComMultiThreadModel>::InternalRelease();

    odmDebugOut(( DEB_TRACE,"CCatAdm(%ws) Release returned: %d\n",
                  _xCatAdmin.IsNull() ? L"" : _xCatAdmin->GetName(), cRef ));

    if ( 0 != _pIMacAdm )
        _pIMacAdm->Release();

    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::GetScopeAutomationObject, public
//
//  Synopsis:   Wraps a CScopeAdmin pointer in an IDispatch interface.
//
//  Arguments:  [xScopeAdmin]       -- Scope admin object
//              [xIScopeAdm]        -- xInterface to contain created ScopeAdmObject
//
//  Returns:    none, throws upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CCatAdm::GetScopeAutomationObject( XPtr<CScopeAdmin>          & xScopeAdmin,
                                        XInterface<ScopeAdmObject> & xIScopeAdm )

{
    Win4Assert( !xScopeAdmin.IsNull() );

    SCODE sc = ScopeAdmObject::CreateInstance( xIScopeAdm.GetPPointer() );

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "CoCreateInstance(CLSID_ScopeAdm) Failed: %x\n",sc ));

        THROW(CException(sc) );
    }
    else
    {
        Win4Assert( !xIScopeAdm.IsNull() );

        xIScopeAdm->SetParent( (CComObject<CCatAdm> *)this );

        xIScopeAdm->AddRef();

        IncObjectCount();   // inc. internal object count
    }

    //
    // Initialize the new object
    //
    xIScopeAdm->Initialize( xScopeAdmin );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::GetIDisp, public
//
//  Synopsis:   QI for IDispatch on CScopeAdm object given by the passed in index.
//
//  Arguments:  [cPosition]     -- index of CScopeAdm object
//
//  Returns:    [IDispatch *]   -- pointer to IDispatch on CScopeAdm, throws upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

IDispatch * CCatAdm::GetIDisp( unsigned cPosition )
{
    IDispatch * pTmpIDisp = 0;

    SCODE sc = _aIScopeAdmin[cPosition]->QueryInterface(IID_IDispatch, (void **) &pTmpIDisp);

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "QueryInterface() Failed: %x\n", sc ));

        THROW(CException(sc));
    }

    Win4Assert( pTmpIDisp );

    return pTmpIDisp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::ForceMasterMerge, public
//
//  Synopsis:   Starts a master merge
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::ForceMasterMerge(void)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        sc = ::ForceMasterMerge ( L"\\",
                                _xCatAdmin->GetName(),
                                _xCatAdmin->GetMachName() );
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "ForceMasterMerge Failed: %x\n",sc ));

        SetErrorInfo(sc);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::AddScope, public
//
//  Synopsis:   Adds a scope to current catalog, logon & password should only
//              be passed in if path is UNC.
//
//  Arguments:  [bstrScopeName]   - in param,  scope to Add
//              [fExclude]        - in param,  Exclude flag to set
//              [vtLogon]         - in param,  logon name
//              [vtPassword]      - in param,
//              [pIDisp]          - out param, IDispatch for new scope.
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::AddScope(BSTR bstrScopeName,
                               VARIANT_BOOL fExclude,
                               VARIANT vtLogon,
                               VARIANT vtPassword,
                               IDispatch * * pIDisp)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       ValidateInputParam( bstrScopeName );

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else
       {
            sc = IsScopeValid( bstrScopeName, SysStringLen(bstrScopeName), _xCatAdmin->IsLocal() );

            if ( SUCCEEDED(sc) )
            {
                WCHAR const * pwszLogon = GetWCHARFromVariant(vtLogon);
                WCHAR const * pwszPassword = GetWCHARFromVariant(vtPassword);

                if ( (( pwszLogon  && *pwszLogon && pwszPassword  ) && ( bstrScopeName[0] == L'\\' || bstrScopeName[1] == L'\\')) ||
                     (( !pwszLogon && !pwszPassword ) && ( bstrScopeName[1] == L':' ))  )
                {

                    if ( ScopeExists( bstrScopeName ) )
                    {
                        sc = HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS );
                    }
                    else
                    {
                        _xCatAdmin->AddScope(bstrScopeName, NULL, fExclude, pwszLogon, pwszPassword);

                        XPtr<CScopeAdmin> xScopeAdmin( _xCatAdmin->QueryScopeAdmin(bstrScopeName) );

                        unsigned cPosition = _aIScopeAdmin.Count();

                        XInterface<ScopeAdmObject> xIScopeAdm;

                        GetScopeAutomationObject( xScopeAdmin, xIScopeAdm );

                        _aIScopeAdmin.Add ( xIScopeAdm.GetPointer() , cPosition );

                        xIScopeAdm.Acquire();

                        *pIDisp = GetIDisp(cPosition);
                    }
                }
                else
                {
                    odmDebugOut(( DEB_ERROR,"Invalid Scope params: UNC scope name require Logon & passwd, local drive doesn't\n"));
                    sc = E_INVALIDARG;
                }
            }
        }

    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "AddScope Failed: %x\n",sc ));

        SetErrorInfo(sc);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  member:     CCatAdm::ScopeExists, public
//
//  Synopsis:   determines if a scope exists on this catalog.
//
//  Arguments:  [pScopePath]    -- scope path
//
//  Returns:    TRUE if scope already exists, false otherwise.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CCatAdm::ScopeExists(WCHAR const * pScopePath)
{
    Win4Assert( pScopePath );

    unsigned cPosition = _aIScopeAdmin.Count();

    for ( DWORD i = 0; i < cPosition; i++ )
    {
        Win4Assert( _aIScopeAdmin[i] );

        CScopeAdmin * pScopeAdmin = _aIScopeAdmin[i]->GetScopeAdmin();

        Win4Assert( pScopeAdmin );

        if ( !_wcsicmp( pScopePath, pScopeAdmin->GetPath() ) )
        {
            return TRUE;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetWCHARFromVariant
//
//  Synopsis:   returns a pointer to WCHAR within a variant
//
//  Arguments:  [Var]   - variant containing a bstr
//
//  Returns:    valid WCHAR * to the bstr in the variant
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

WCHAR const * GetWCHARFromVariant( VARIANT & Var )
{

    switch ( Var.vt )
    {
        case VT_BSTR:
                if ( 0 == Var.bstrVal )
                {
                    THROW(CException(E_INVALIDARG));
                }

                return Var.bstrVal;

             break;

        case VT_BSTR|VT_BYREF:

                if ( 0 == Var.pbstrVal || 0 == *Var.pbstrVal )
                {
                    THROW(CException(E_INVALIDARG));
                }

                return *Var.pbstrVal;

                break;

        case VT_BYREF|VT_VARIANT:


                if ( 0 == Var.pvarVal )
                {
                    THROW( CException(E_INVALIDARG) );
                }

                return GetWCHARFromVariant(*Var.pvarVal);

                break;


        case VT_ERROR:  // set if optional param is not set.
        case VT_EMPTY:

             //
             // do nothing
             //
             break;

        default:
             odmDebugOut(( DEB_ERROR, "Unexpected Variant type: %x\n", Var.vt ));

             THROW( CException(E_INVALIDARG) );
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::RemoveScope, public
//
//  Synopsis:   deletes a scope
//
//  Arguments:  [bstrScopePath]   - in param, scope to delete
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::RemoveScope(BSTR bstrScopePath)
{

    SCODE sc = S_OK;

    CLock    lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        ValidateInputParam( bstrScopePath );

        if ( !IsCurrentObjectValid() )
        {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            unsigned cPosition = _aIScopeAdmin.Count();

            for ( DWORD i = 0; i < cPosition; i++ )
            {
                Win4Assert( _aIScopeAdmin[i] );

                CScopeAdmin * pScopeAdmin = _aIScopeAdmin[i]->GetScopeAdmin();

                Win4Assert( pScopeAdmin );

                if ( !_wcsicmp( bstrScopePath, pScopeAdmin->GetPath() ) )
                {
                    //
                    // Remove scope from local list, move last element to empty spot,
                    // Release corresponding IDispatch
                    //

                    ScopeAdmObject * pIScopeAdm = _aIScopeAdmin.AcquireAndShrink(i);

                    Win4Assert( pIScopeAdm );

                    pIScopeAdm->SetInvalid();

                    pIScopeAdm->Release();

                    //
                    // Remove from CI
                    //

                    _xCatAdmin->RemoveScope(bstrScopePath);

                    break;
                }
            }

            if ( i == cPosition )
            {
                odmDebugOut(( DEB_ERROR, "RemoveScope Failed, Scope(%ws) not found\n", bstrScopePath ));

                sc = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            }
        }
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();

    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "RemoveScope Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::GetScopeByPath, public
//
//  Synopsis:   Searches for scopes on this catalog by Path
//
//  Arguments:  [bstrPath] -- Path to search for.
//              [pIDisp]    -- out param, IDispatch for CScopeAdmin if Path matches
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::GetScopeByPath(BSTR bstrPath, IDispatch * * pIDisp)
{
    SCODE sc = S_OK;

    CLock    lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        ValidateInputParam( bstrPath );

        if ( !IsCurrentObjectValid() )
        {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            unsigned cMaxScopes = _aIScopeAdmin.Count();

            for ( DWORD i = 0; i < cMaxScopes; i++ )
            {
                Win4Assert( _aIScopeAdmin[i] );

                CScopeAdmin *pScopeAdmin = _aIScopeAdmin[i]->GetScopeAdmin();

                Win4Assert( pScopeAdmin );

                if ( !_wcsicmp( pScopeAdmin->GetPath(), bstrPath ) )
                {
                    *pIDisp = GetIDisp(i);

                    break;
                }
            }

            //
            // Scope not found
            //
            if ( i == cMaxScopes )
            {
                odmDebugOut(( DEB_ERROR, "GetScopeByPath(%ws) Failed: Scope Not found\n",bstrPath ));

                sc = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
            }
        }
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "GetScopeByPath Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::FindFirstScope, public
//
//  Synopsis:   Scope enumerator. Resets scan to start of list.
//
//  Arguments:  [pfFound]   -- out param, True --> Found at least one scope
//
//  Returns:    SO_OK upon success, other values upon faillure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::FindFirstScope(VARIANT_BOOL * pfFound)
{

    SCODE sc = S_OK;

    CLock    lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        if ( !IsCurrentObjectValid() )
        {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            _cEnumIndex = 0;

            if ( _aIScopeAdmin.Count() > 0 )
            {
                Win4Assert( _aIScopeAdmin[0] );

                *pfFound = VARIANT_TRUE;
            }
            else
            {
                *pfFound = VARIANT_FALSE;
            }
        }
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "FindFirstScope Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::FindNextScope, public
//
//  Synopsis:   Scope enumerator. Scans for next scope in the list
//
//  Arguments:  [pfFound]   -- out param, True --> Found next scope
//
//  Returns:    SO_OK upon success, other values upon faillure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::FindNextScope(VARIANT_BOOL * pfFound)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        if ( !IsCurrentObjectValid() )
        {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            _cEnumIndex++;

            if ( _cEnumIndex < _aIScopeAdmin.Count() )
            {
                Win4Assert( _aIScopeAdmin[0] );

                *pfFound = VARIANT_TRUE;
            }
            else
            {
                *pfFound = VARIANT_FALSE;
            }
        }
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();

    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "FindNextScope Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::GetScope, public
//
//  Synopsis:   Scope enumerator. Returns IDispatch to current scope
//
//  Arguments:  [pIDisp]   -- out param, IDispatch to current scope
//
//  Returns:    SO_OK upon success, other values upon faillure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::GetScope(IDispatch * * pIDisp)
{

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        if ( !IsCurrentObjectValid() )
        {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            if ( _cEnumIndex >= _aIScopeAdmin.Count() )
            {
                odmDebugOut(( DEB_ERROR, "No More Scopes, Index: %d\n", _cEnumIndex ));

                sc = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            }
            else
            {
                Win4Assert( _aIScopeAdmin[_cEnumIndex] );

                *pIDisp = GetIDisp(_cEnumIndex);
            }
        }
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "GetScope Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_CatalogName, public
//
//  Synopsis:   Gets the CatalogName Property
//
//  Arguments:  [pVal]  -- out param, buffer containing catalog name
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_CatalogName(BSTR * pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog: %ws\n", _xCatAdmin->GetName() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else
       {
           WCHAR const * pwszName = _xCatAdmin->GetName();

           *pVal = SysAllocString(pwszName);

           if ( !*pVal )
           {
               odmDebugOut(( DEB_ERROR, "get_CatalogName Failed: Out of memory\n" ));

               sc = E_OUTOFMEMORY;
           }
       }

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_CatalogName Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_CatalogLocation, public
//
//  Synopsis:   Gets the CatalogLocation property
//
//  Arguments:  [pVal]  -- out param, buffer containing catalog location
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_CatalogLocation(BSTR * pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {

       SafeForScripting();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else
       {

           WCHAR const * pwszLocation = _xCatAdmin->GetLocation();

           *pVal = SysAllocString(pwszLocation);

           if ( !*pVal )
           {
                odmDebugOut(( DEB_ERROR, "get_CatalogLocation Failed: Out of memory\n"));

                sc = E_OUTOFMEMORY;
           }
        }

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_CatalogLocation Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::GetScopeByAlias, public
//
//  Synopsis:   Searches for scopes on this catalog by Alias
//
//  Arguments:  [bstrAlias] -- Alias to search for.
//              [pIDisp]    -- out param, IDispatch for CScopeAdmin if Alias matches
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::GetScopeByAlias(BSTR bstrAlias, IDispatch * * pIDisp)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {

       SafeForScripting();

       ValidateInputParam( bstrAlias );

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog: %ws\n", _xCatAdmin->GetName() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else
       {
           unsigned cMaxScopes = _aIScopeAdmin.Count();

           for ( DWORD i = 0; i < cMaxScopes; i++ )
           {
                Win4Assert( _aIScopeAdmin[i] );

                CScopeAdmin * pScopeAdmin = _aIScopeAdmin[i]->GetScopeAdmin();

                Win4Assert( pScopeAdmin );

                if ( !_wcsicmp( pScopeAdmin->GetAlias(), bstrAlias ) )
                {
                    *pIDisp = GetIDisp(i);

                     break;
                }
           }

           //
           // Scope not found
           //
           if ( i == cMaxScopes )
           {
              odmDebugOut(( DEB_ERROR, "GetScopeByAlias(%ws) Failed: Alias not found\n", bstrAlias ));

              sc = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
           }
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "GetScopeByAlias Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_WordListCount, public property
//
//  Synopsis:   returns catalog's WordListCount property
//
//  Arguments:  [pVal]  -- out param
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_WordListCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetWordListCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_WordListCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_PersistentIndexCount, public property
//
//  Synopsis:   returns catalog's PersistentIndexCount property
//
//  Arguments:  [pVal]  -- out param
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_PersistentIndexCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {

       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetPersistentIndexCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_PersistentIndexCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_QueryCount, public property
//
//  Synopsis:   returns catalog's QueryCount property
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_QueryCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetQueryCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_QueryCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_DocumentsToFilter, public property
//
//  Synopsis:   returns catalog's DocumentsToFilter property
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_DocumentsToFilter(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetDocumentsToFilter();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_DocumentsToFilter Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_FreshTestCount, public property
//
//  Synopsis:   returns catalog's FreshTestCount
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_FreshTestCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {

       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetFreshTestCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_FreshTestCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_PctMergeComplete, public property
//
//  Synopsis:   returns catalog's PctMergeComplete property
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_PctMergeComplete(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.PctMergeComplete();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_PctMergeComplete Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_FilteredDocumentCount, public property
//
//  Synopsis:   returns catalog's FilteredDocumentCount property
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_FilteredDocumentCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetFilteredDocumentCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_FilteredDocumentCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_TotalDocumentCount, public property
//
//  Synopsis:   returns catalog's TotalDocumentCount property
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_TotalDocumentCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetTotalDocumentCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_TotalDocumentCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_PendingScanCount, public property
//
//  Synopsis:   returns catalog's PendingDocumentCount property
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_PendingScanCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetPendingScanCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_PendingScanCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_IndexSize, public property
//
//  Synopsis:   returns catalog's IndexSize property
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_IndexSize(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetIndexSize();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_IndexSize Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_UniqueKeyCount, public property
//
//  Synopsis:   returns catalog's UniqueKeyCount
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned value, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_UniqueKeyCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetUniqueKeyCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_UniqueKeyCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_StateInfo, public property
//
//  Synopsis:   returns catalog's StateInformation
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      Property value is an unsigned value, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_StateInfo(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetStateInfo();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_StateInfo Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_IsUpToDate, public property
//
//  Synopsis:   property is TRUE if catalog is up to date.
//
//  Arguments:  [pVal]  -- out param,
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_IsUpToDate(VARIANT_BOOL *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval  )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            DWORD currentState = state.GetStateInfo();

            if ( 0 != state.GetDocumentsToFilter()             ||
                 currentState & CI_STATE_CONTENT_SCAN_REQUIRED ||
                 currentState & CI_STATE_SCANNING              ||
                 currentState & CI_STATE_RECOVERING            ||
                 currentState & CI_STATE_READING_USNS          ||
                 currentState & CI_STATE_STARTING )
            {
                *pVal = VARIANT_FALSE;
            }
            else
            {
                *pVal = VARIANT_TRUE;
            }
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_IsUpToDate Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::get_DelayedFilterCount, public property
//
//  Synopsis:   returns catalog's DelayedFilterCount property
//
//  Arguments:  [pVal]  -- out param
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Notes:      out value is an unsigned value, though it is being
//              passed as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    4-14-98    vikasman    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::get_DelayedFilterCount(LONG *pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
       SafeForScripting();

       CCatStateInfo & state = _xCatAdmin->State();

       if ( !IsCurrentObjectValid() )
       {
            odmDebugOut(( DEB_ERROR, "Invalid catalog\n" ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
       }
       else if ( GetTickCount() > _dwTickCount + UpdateInterval )
       {
            state.LokUpdate();

            _dwTickCount = GetTickCount();
       }

       if ( state.IsValid() )
       {
            *pVal = state.GetDelayedFilterCount();
       }
       else
       {
            sc = state.GetErrorCode();
       }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_DelayedFilterCount Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::PauseCatalog, public
//
//  Synopsis:   Pauses the catalog
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Arguments:  [pdwOldState]  -- out param, DWORD indicating the previous
//                                state of the catalog
//
//  History:    08-03-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::PauseCatalog( CatalogStateType * pdwOldState )
{
    Win4Assert( CICAT_STOPPED == csStopped );
    Win4Assert( CICAT_READONLY == csReadOnly );
    Win4Assert( CICAT_WRITABLE == csWritable );

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        DWORD dwOldState;

        sc = SetCatalogState ( _xCatAdmin->GetName(),
                               _xCatAdmin->GetMachName(),
                               CICAT_READONLY,
                               &dwOldState );
        
        // mask off the no_query bit
        *pdwOldState = (CatalogStateType)(dwOldState & (~CICAT_NO_QUERY));
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "PauseCatalog Failed: %x\n",sc ));
        SetErrorInfo(sc);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::StartCatalog, public
//
//  Synopsis:   Starts the catalog
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Arguments:  [pdwOldState]  -- out param, DWORD indicating the previous
//                                state of the catalog
//
//  History:    08-05-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::StartCatalog( CatalogStateType * pdwOldState )
{
    Win4Assert( CICAT_STOPPED == csStopped );
    Win4Assert( CICAT_READONLY == csReadOnly );
    Win4Assert( CICAT_WRITABLE == csWritable );

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        DWORD dwOldState;

        sc = SetCatalogState ( _xCatAdmin->GetName(),
                               _xCatAdmin->GetMachName(),
                               CICAT_WRITABLE,
                               &dwOldState );

        // mask off the no_query bit
        *pdwOldState = (CatalogStateType)(dwOldState & (~CICAT_NO_QUERY)); 
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "StartCatalog Failed: %x\n",sc ));
        SetErrorInfo(sc);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::StopCatalog, public
//
//  Synopsis:   Stops the catalog
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Arguments:  [pdwOldState]  -- out param, DWORD indicating the previous
//                                state of the catalog
//
//  History:    08-05-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::StopCatalog( CatalogStateType * pdwOldState )
{
    Win4Assert( CICAT_STOPPED == csStopped );
    Win4Assert( CICAT_READONLY == csReadOnly );
    Win4Assert( CICAT_WRITABLE == csWritable );

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        DWORD dwOldState;

        sc = SetCatalogState ( _xCatAdmin->GetName(),
                               _xCatAdmin->GetMachName(),
                               CICAT_STOPPED,
                               &dwOldState );
        
        // mask off the no_query bit
        *pdwOldState = (CatalogStateType)(dwOldState & (~CICAT_NO_QUERY)); 

    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "StopCatalog Failed: %x\n",sc ));
        SetErrorInfo(sc);
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::ContinueCatalog, public
//
//  Synopsis:   Continues the catalog
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Arguments:  [pdwOldState]  -- out param, DWORD indicating the previous
//                                state of the catalog
//
//  History:    09-08-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::ContinueCatalog( CatalogStateType * pdwOldState )
{
    Win4Assert( CICAT_STOPPED == csStopped );
    Win4Assert( CICAT_READONLY == csReadOnly );
    Win4Assert( CICAT_WRITABLE == csWritable );

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        DWORD dwOldState;

        sc = SetCatalogState ( _xCatAdmin->GetName(),
                               _xCatAdmin->GetMachName(),
                               CICAT_WRITABLE,
                               &dwOldState );

        // mask off the no_query bit
        *pdwOldState = (CatalogStateType)(dwOldState & (~CICAT_NO_QUERY));
        
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "ContinueCatalog Failed: %x\n",sc ));
        SetErrorInfo(sc);
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::IsCatalogRunning, public
//
//  Synopsis:   check if the catalog is in R/W mode
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Arguments:  [pfIsRunning]  -- out param
//
//  History:    08-10-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::IsCatalogRunning( VARIANT_BOOL *pfIsRunning )
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        DWORD dwOldState;

        sc = SetCatalogState ( _xCatAdmin->GetName(),
                               _xCatAdmin->GetMachName(),
                               CICAT_GET_STATE,
                               &dwOldState );

        *pfIsRunning = ( ( CICAT_WRITABLE & dwOldState ) &&
                        !( CICAT_NO_QUERY & dwOldState) ) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "IsCatalogRunning Failed: %x\n",sc ));
        SetErrorInfo(sc);
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::IsCatalogPaused, public
//
//  Synopsis:   check if the catalog is paused (read-only)
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Arguments:  [pfIsPaused]  -- out param
//
//  History:    08-10-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::IsCatalogPaused( VARIANT_BOOL *pfIsPaused )
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {

        SafeForScripting();

        DWORD dwOldState;

        sc = SetCatalogState ( _xCatAdmin->GetName(),
                               _xCatAdmin->GetMachName(),
                               CICAT_GET_STATE,
                               &dwOldState );

        *pfIsPaused = (CICAT_READONLY & dwOldState) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "IsCatalogPaused Failed: %x\n",sc ));
        SetErrorInfo(sc);
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCatAdm::IsCatalogStopped, public
//
//  Synopsis:   check if the catalog is stopped
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  Arguments:  [pfIsStopped]  -- out param
//
//  History:    08-10-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CCatAdm::IsCatalogStopped( VARIANT_BOOL *pfIsStopped )
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        DWORD dwOldState;

        sc = SetCatalogState ( _xCatAdmin->GetName(),
                               _xCatAdmin->GetMachName(),
                               CICAT_GET_STATE,
                               &dwOldState );

        *pfIsStopped = (CICAT_STOPPED & dwOldState) ? VARIANT_TRUE : VARIANT_FALSE;

    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "IsCatalogStopped Failed: %x\n",sc ));
        SetErrorInfo(sc);
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\scopeadm.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1998
//
// File:        ScopeAdm.cxx
//
// Contents:    CI Scope Administration Interface methods
//
// Classes:     CScopeAdm
//
// History:     12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stdafx.h"

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::InterfaceSupportsErrorInfo, public
//
//  Arguments:  [riid]  -- interface iid
//
//  Returns:    S_OK if interface supports IErrorInfo
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::InterfaceSupportsErrorInfo(REFIID riid)
{
    return ( riid == IID_IScopeAdm );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::SetErrorInfo, public
//
//  Synopsis:   Creates & sets the error object
//
//  Arguments:  [hRes]      -- HRESULT error code to set
//              [ pwszDesc] -- error description
//
//  Returns:    S_OK upon success, other values upon failure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdm::SetErrorInfo( HRESULT hRes )
{
   CiodmError  err(hRes);

   AtlSetErrorInfo(CLSID_ScopeAdm, err.GetErrorMessage(), 0 , 0, IID_IScopeAdm, hRes, 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::Initialize, public
//
//  Synopsis:   Initializes CScopeAdm object
//
//  Arguments:  [xScopeAdmin]        -- CScopeAdmin to encapsulate.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CScopeAdm::Initialize( XPtr<CScopeAdmin> & xScopeAdmin )
{
    Win4Assert( _pICatAdm );
    Win4Assert( !xScopeAdmin.IsNull() );

    _xScopeAdmin.Set( xScopeAdmin.Acquire() );

    _fValid = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::InternalAddRef, public
//
//  Synopsis:   overrides CComObjectRootEx<Base>::InternalAddRef, to AddRef parent too
//
//  Arguments:  none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------
ULONG CScopeAdm::InternalAddRef()
{
    CLock lock(_mtx);

    //
    // AddRef self
    //
    unsigned cRef = CComObjectRootEx<CComMultiThreadModel>::InternalAddRef();

    odmDebugOut(( DEB_TRACE,"CScopeAdm(%ws) AddRef returned: %d\n",
                  _xScopeAdmin.IsNull() ? L"" : _xScopeAdmin->GetPath(), cRef ));

    //
    // AddRef parent.  It won't exist if the object is created independently
    //

    if ( 0 != _pICatAdm )
        _pICatAdm->AddRef();

    return cRef;
} //InternalAddRef

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::InternalRelease, public
//
//  Synopsis:   overrides CComObjectRootEx<Base>::InternalRelease, to release parent too.
//
//  Arguments:  none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

ULONG CScopeAdm::InternalRelease()
{
    CLock lock(_mtx);

    //
    // Rlease parent
    //

    if ( ( 0 != _pICatAdm ) &&
         ( 1 == m_dwRef ) ) // we're being deleted
    {
        _pICatAdm->DecObjectCount();
    }

    //
    // Release self
    //
    unsigned cRef = CComObjectRootEx<CComMultiThreadModel>::InternalRelease();

    if ( 0 != _pICatAdm )
        _pICatAdm->Release();

    return cRef;
} //InternalRelease

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::Rescan, public
//
//  Synopsis:   Forces a rescan
//
//  Arguments:  [fFull] -- TRUE --> full rescan, FALSE --> incremental
//
//  Returns:    S_OK upon success, other values upon failure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::Rescan(VARIANT_BOOL fFull)
{

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            CCatalogAdmin * pCatalogAdmin = _pICatAdm->GetCatalogAdmin();

            Win4Assert( pCatalogAdmin );

            sc = UpdateContentIndex( _xScopeAdmin->GetPath(),     // root of scope to scan for updates
                                     pCatalogAdmin->GetName(),    // catalog name
                                     pCatalogAdmin->GetMachName(),// machine name
                                     fFull );
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "Rescan Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::SetLogonInfo, public
//
//  Synopsis:   Sets Logon Name/password
//
//  Arguments:  [bstrLogon]     -- Logon name
//              [bstrPassword]  -- password
//
//  Returns:    S_OK upon success, other values upon failure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::SetLogonInfo( BSTR bstrLogon, BSTR bstrPassword )
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {

        SafeForScripting();

        ValidateInputParam( bstrLogon );

        ValidateInputParam( bstrPassword );

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            CCatalogAdmin * pCatalogAdmin = _pICatAdm->GetCatalogAdmin();
            WCHAR const   * pwszPath      = _xScopeAdmin->GetPath();

            Win4Assert( pCatalogAdmin );
            Win4Assert( pwszPath );

            if ( pwszPath[1] == L':' )
            {
                odmDebugOut(( DEB_ERROR, "Can't set Logon info for local drives\n" ));

                sc = E_INVALIDARG;
            }
            else if ( bstrLogon && *bstrLogon )
            {
                _xScopeAdmin->SetLogonInfo( bstrLogon, bstrPassword, *pCatalogAdmin );
            }
            else
            {
                odmDebugOut(( DEB_ERROR, "invalid logon arguments\n" ));

                sc = E_INVALIDARG;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "SetLogonInfo Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::get_Path, public
//
//  Synopsis:   Gets the scope path Property
//
//  Arguments:  [pVal]  -- out param, buffer containing scope path
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::get_Path(BSTR * pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            WCHAR const * pwszPath = _xScopeAdmin->GetPath();

            *pVal = SysAllocString(pwszPath);
            if ( !*pVal )
            {
                sc = E_OUTOFMEMORY;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_PathRescan Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::put_Path, public
//
//  Synopsis:   Sets the scope path Property
//
//  Arguments:  [newVal]  -- in param, buffer containing scope path
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::put_Path(BSTR newVal)
{
    SCODE sc = S_OK;
    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        ValidateInputParam( newVal );

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            if ( _xScopeAdmin->IsVirtual() )
            {
                odmDebugOut(( DEB_ERROR, "Can't change virtual path, must use IIS\n" ));

                sc = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
            }
            else
            {
                _xScopeAdmin->SetPath(newVal);
            }
        }

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "put_PathRescan Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::get_Alias, public
//
//  Synopsis:   Gets the scope Alias Property
//
//  Arguments:  [pVal]  -- out param, buffer containing scope Alias
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::get_Alias(BSTR * pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            WCHAR const * pwszAlias = _xScopeAdmin->GetAlias();

            *pVal = SysAllocString(pwszAlias);
            if ( !*pVal )
            {
                 sc = E_OUTOFMEMORY;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_Alias Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::put_Alias , public
//
//  Synopsis:   Sets the scope alias Property
//
//  Arguments:  [newVal]  -- in param, buffer containing scope alias
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::put_Alias(BSTR newVal)
{

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        ValidateInputParam( newVal );

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            _xScopeAdmin->SetAlias(newVal);
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "put_Alias Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::get_ExcludeScope, public
//
//  Synopsis:   Gets the exclude scope Property
//
//  Arguments:  [pVal]  -- out param, containing exclude scope flag
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::get_ExcludeScope(VARIANT_BOOL * pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            *pVal = (SHORT)_xScopeAdmin->IsExclude();
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_ExcludeScope Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::put_ExcludeScope , public
//
//  Synopsis:   Sets the scope Exclude flag Property
//
//  Arguments:  [newVal]  -- in param, Exclude scope flag to set
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::put_ExcludeScope(VARIANT_BOOL newVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            _xScopeAdmin->SetExclude(newVal);
        }
    }
    CATCH( CException, e )
    {

        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "put_ExcludeScope Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::get_VirtualScope, public
//
//  Synopsis:   Gets the VirtualScope property
//
//  Arguments:  [pVal]  -- out param, containing VirtualScope flag
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::get_VirtualScope(VARIANT_BOOL * pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            *pVal = (SHORT)_xScopeAdmin->IsVirtual();
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_VirtualScope Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScopeAdm::get_Logon, public
//
//  Synopsis:   Gets the logon name
//
//  Arguments:  [pVal]  -- out param, containing logon name
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScopeAdm::get_Logon(BSTR * pVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        SafeForScripting();

        if ( !_fValid )
        {
            odmDebugOut(( DEB_ERROR, "Invalid Scope: %ws\n", _xScopeAdmin->GetPath() ));

            sc = HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
        }
        else
        {
            WCHAR const * pwszLogon = _xScopeAdmin->GetLogon();

            *pVal = SysAllocString(pwszLogon);
            if ( !*pVal )
            {
                 sc = E_OUTOFMEMORY;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "get_Logon Failed: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\ciodmerr.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1998
//
// File:        ciodmerr.cxx
//
// Contents:    ciodm error class
//
// Classes:     CiodmError
//
// History:     12-20-97    mohamedn    created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stdafx.h"

//+---------------------------------------------------------------------------
//
//  Member:     CiodmError::GetErrorMessage, public
//
//  Synopsis:   returns error message corresponing to sc value
//
//  Arguments:  none
//
//  Returns:    valid error message upon success, 0 upon failure
//
//  History:    12-20-97    mohamedn    created
//
//----------------------------------------------------------------------------

WCHAR const * CiodmError::GetErrorMessage(void)
{

    //
    //  Generate the Win32 error code by removing the facility code (7) and
    //  the error bit.
    //
    
    Win4Assert( _scError );
    
    ULONG Win32status = _scError;

    if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
    {
        Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );
    }

    //
    //  Try looking up the error in the Win32 list of error codes
    //

    if ( ! FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                          GetModuleHandle(L"kernel32.dll"),
                          Win32status,
                          0,
                          _awcsErrorMessage,
                          sizeof _awcsErrorMessage/ sizeof WCHAR,
                          0 ) )
    {

         if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                               GetModuleHandle(L"query.dll"),
                               Win32status,
                               0,
                               _awcsErrorMessage,
                               sizeof _awcsErrorMessage/ sizeof WCHAR,
                               0 ) )
         {

            odmDebugOut(( DEB_ERROR, "FormatMessage() Failed: %x\n",GetLastError() ));
         
            return 0;
         }
    }
  
    return _awcsErrorMessage;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\macadmin.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1998
//
// File:        MacAdmin.cxx
//
// Contents:    Index Server Administration Interface methods
//
// Classes:     CMachineAdm
//
// History:     12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stdafx.h"
#include <mshtml.h>

DECLARE_INFOLEVEL( odm );

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::InterfaceSupportsErrorInfo, public
//
//  Arguments:  [riid]  -- interface iid
//
//  Returns:    S_OK if interface supports IErrorInfo
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::InterfaceSupportsErrorInfo(REFIID riid)
{
        return ( riid == IID_IAdminIndexServer );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::SetErrorInfo, public
//
//  Synopsis:   Creates & sets the error object
//
//  Arguments:  [hRes]      -- HRESULT error code to set
//              [ pwszDesc] -- error description
//
//  Returns:    S_OK upon success, other values upon failure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CMachineAdm::SetErrorInfo( HRESULT hRes )
{
   CiodmError  err(hRes);

   AtlSetErrorInfo(CLSID_AdminIndexServer, err.GetErrorMessage() , 0 , 0, IID_IAdminIndexServer, hRes, 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::CMachineAdm, public
//
//  Synopsis:   Constructor
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------
CMachineAdm::CMachineAdm()
        :_eCurrentState(CIODM_NOT_INITIALIZED),
         _cMinRefCountToDestroy(1),
         _cEnumIndex(0)
{
    wcscpy(_wcsMachineName,L".");   // default to local machine

}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::InternalAddRef, public
//
//  Synopsis:   overrides CComObjectRootEx<Base>::InternalAddRef, for debugging only.
//
//  Arguments:  none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

ULONG CMachineAdm::InternalAddRef()
{
    unsigned cRef = CComObjectRootEx<CComMultiThreadModel>::InternalAddRef();

    odmDebugOut(( DEB_TRACE,"CMachineAdm AddRef returned: %d\n", cRef ));

    odmDebugOut(( DEB_TRACE,"=========================== CMachineAdm object count: %d\n",
                  _cMinRefCountToDestroy ));

    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::InternalRelease, public
//
//  Synopsis:   overrides CComObjectRootEx<Base>::InternalRelease, for debugging only.
//
//  Arguments:  none
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

ULONG CMachineAdm::InternalRelease()
{
    CLock    lock(_mtx);

    //
    // Delete contained objects if we're being destoryed.
    // m_dwRef is an internal ATL public refcount member.
    //

    if ( _eCurrentState != CIODM_DESTROY  && m_dwRef == _cMinRefCountToDestroy )
    {
         _eCurrentState = CIODM_DESTROY;

         _aICatAdmin.Free();
    }

    unsigned cRef = CComObjectRootEx<CComMultiThreadModel>::InternalRelease();

    odmDebugOut(( DEB_TRACE,"CMachineAdm Release returned: %d\n", cRef ));

    odmDebugOut(( DEB_TRACE,"=========================== CMachineAdm object count: %d\n",
                  _cMinRefCountToDestroy ));

    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::Initialize, public
//
//  Synopsis:   Initializes CMachineAdm object, creates CMachineAdmin object,
//              populates catalogs lists.
//
//  Arguments:  none.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CMachineAdm::Initialize()
{
    //
    // create CMachineAdmin object
    //

    if ( IsCurrentObjectValid() )
    {
         return;
    }

    TRY
    {
        _xMachineAdmin.Set (new CMachineAdmin( _wcsMachineName ) );

        XPtr<CCatalogEnum> xCatEnum( _xMachineAdmin->QueryCatalogEnum() );

        Win4Assert( 0 == _aICatAdmin.Count() );

        while ( xCatEnum->Next() )
        {
            XPtr<CCatalogAdmin> xCatAdmin(xCatEnum->QueryCatalogAdmin());

            XInterface<CatAdmObject>  xICatAdm;

            GetCatalogAutomationObject( xCatAdmin, xICatAdm );

            _aICatAdmin.Add( xICatAdm.GetPointer(), _aICatAdmin.Count() );

            xICatAdm.Acquire();
        }

        _eCurrentState = CIODM_INITIALIZED;
    }
    CATCH ( CException, e )
    {
        _xMachineAdmin.Free();

        _cEnumIndex = 0;

        wcscpy(_wcsMachineName,L".");

        _aICatAdmin.Free();

        _eCurrentState = CIODM_NOT_INITIALIZED;

        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::GetCatalogAutomationObject, public
//
//  Synopsis:   Wraps a CCatalogAdmin pointer in an IDispatch interface.
//
//  Arguments:  [xCatAdmin]        -- Catalog admin object
//              [xICatAdm]         -- XInterface to contain created CatAdmObject
//
//  Returns:    none, throws upon error.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

void CMachineAdm::GetCatalogAutomationObject( XPtr<CCatalogAdmin>      & xCatAdmin,
                                              XInterface<CatAdmObject> & xICatAdm )
{
    Win4Assert( !xCatAdmin.IsNull() );

    SCODE sc = CatAdmObject::CreateInstance( xICatAdm.GetPPointer() );

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "CatAdmObject::CreateInstance() Failed: %x\n", sc ));

        THROW(CException(sc));
    }
    else
    {
        Win4Assert( !xICatAdm.IsNull() );

        xICatAdm->SetParent( (CComObject<CMachineAdm> *)this );

        xICatAdm->AddRef();

        IncObjectCount();   // inc. internal object count
    }

    //
    // Initialize the new object
    //

    xICatAdm->Initialize( xCatAdmin );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::GetIDisp, public
//
//  Synopsis:   QI for IDispatch on CCatAdm object given by the passed in index.
//
//  Arguments:  [cPosition]     -- index of CCatAdm object
//
//  Returns:    [IDispatch *]   -- pointer to IDispatch on CCatAdm, throws upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

IDispatch * CMachineAdm::GetIDisp( unsigned i )
{
    IDispatch * pTmpIDisp = 0;

    SCODE sc = _aICatAdmin[i]->QueryInterface(IID_IDispatch, (void **) &pTmpIDisp);

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "QueryInterface() Failed: %x\n", sc ));

        THROW(CException(sc));
    }

    Win4Assert( pTmpIDisp );

    return pTmpIDisp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::get_MachineName, public
//
//  Synopsis:   Gets MachineName property
//
//  Arguments:  [pVal]  pointer to bstr buffer return value
//
//  Returns:    S_OK on success, other values on failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::get_MachineName(BSTR * pVal)
{
    SCODE sc = S_OK;

    CLock    lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        *pVal = SysAllocString(_wcsMachineName);

        if ( 0 == *pVal )
        {
            sc = E_OUTOFMEMORY;
        }
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "CMachineAdm::get_MachineName exception: %x\n",sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::put_MachineName, public
//
//  Synopsis:   Gets MachineName property
//
//  Arguments:  [newVal]   -- machine name to set.
//
//  Returns:    S_OK on success, other values on failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::put_MachineName(BSTR newVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {

        SafeForScripting();

        ValidateInputParam(newVal);

        if ( IsCurrentObjectValid() )
        {
            odmDebugOut(( DEB_ERROR,"CMachineAdm(%ws) already initialized", newVal));

            sc = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
        }
        else if ( SysStringLen( newVal ) >= MAX_PATH )
        {
            odmDebugOut(( DEB_ERROR,"CMachineAdm(%ws): Path too long", newVal));

            sc = E_INVALIDARG;
        }
        else
        {
            Win4Assert( L'.' == _wcsMachineName[0] && L'' == _wcsMachineName[1] );

            if ( newVal[0] == L'' )
            {
                wcscpy( _wcsMachineName, L"." );
            }
            else
            {
                wcscpy( _wcsMachineName, newVal );
            }

            Initialize();
        }
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR,"put_MachineName Failed: %x\n", sc));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::AddCatalog, public
//
//  Synopsis:   Adds a catalog.
//
//  Arguments:  [bstrCatName]       - in param, catalog name
//              [bstrCatLocation]   - in param, catalog location
//              [pIDisp]            - out param, IDisp interface to the new catalog
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::AddCatalog(BSTR bstrCatName, BSTR bstrCatLocation, IDispatch * * pIDisp)
{

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {

        SafeForScripting();

        ValidateInputParam(bstrCatName);

        ValidateInputParam(bstrCatLocation);

        Initialize();

        if ( CatalogExists( bstrCatName, bstrCatLocation ) )
        {
           sc = HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS );
        }
        else
        {
            _xMachineAdmin->AddCatalog( bstrCatName, bstrCatLocation );

            XPtr<CCatalogAdmin> xCatAdmin( _xMachineAdmin->QueryCatalogAdmin( bstrCatName ) );

            unsigned cPosition = _aICatAdmin.Count();

            XInterface<CatAdmObject>  xICatAdm;

            GetCatalogAutomationObject( xCatAdmin, xICatAdm );

            _aICatAdmin.Add( xICatAdm.GetPointer(), cPosition );

            xICatAdm.Acquire();

            *pIDisp = GetIDisp(cPosition);
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED (sc) )
    {
       odmDebugOut(( DEB_ERROR, "AddCatalog Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  member:     CMachineAdm::CatalogExists, public
//
//  Synopsis:   determines if a catalog name or location is used up.
//
//  Arguments:  [pCatName]     -- Catalog name
//              [pCatLocation] -- Catalog location.
//
//  Returns:    TRUE if catalog already exists, false otherwise.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

BOOL CMachineAdm::CatalogExists( WCHAR const * pCatName, WCHAR const * pCatLocation )
{

    Win4Assert( pCatName );
    Win4Assert( pCatLocation);

    unsigned cMaxCatalogs = _aICatAdmin.Count();

    for ( DWORD i = 0; i < cMaxCatalogs; i++ )
    {
        Win4Assert( _aICatAdmin[i] );

        CCatalogAdmin * pCatalogAdmin = _aICatAdmin[i]->GetCatalogAdmin();

        Win4Assert( pCatalogAdmin );

        if ( !_wcsicmp( pCatName, pCatalogAdmin->GetName()  ) ||
             !_wcsicmp( pCatLocation, pCatalogAdmin->GetLocation() )  )
        {
             return TRUE;
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::RemoveCatalog, public
//
//  Synopsis:   deletes a catalog, and optionally the corresponding directory
//
//  Arguments:  [bstrCatName]   - Catalog Name
//              [fDelDirectory] - TRUE --> delete catalog directory.
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::RemoveCatalog(BSTR bstrCatName, VARIANT_BOOL fDelDirectory)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();
           
        ValidateInputParam(bstrCatName);
   
        Initialize();

        if (_xMachineAdmin->IsCIStarted())
            sc = CI_E_INVALID_STATE;
        else
        {
            unsigned cMax = _aICatAdmin.Count();
   
            for ( DWORD i = 0; i < cMax ; i++ )
            {
                Win4Assert( _aICatAdmin[i] );
   
                CCatalogAdmin * pCatalogAdmin = _aICatAdmin[i]->GetCatalogAdmin();
   
                Win4Assert( pCatalogAdmin );
   
                if ( !_wcsicmp( bstrCatName, pCatalogAdmin->GetName() ) )
                {
                    //
                    // Remove from CI
                    //
   
                    _xMachineAdmin->RemoveCatalog( bstrCatName, fDelDirectory );
   
                    //
                    // Remove catalog from local list, set catalog object to invalid,
                    // and release removed catalog
                    //
   
                    CatAdmObject * pICatAdm = _aICatAdmin.AcquireAndShrink(i);
   
                    pICatAdm->SetInvalid();
   
                    pICatAdm->Release();
   
                    break;
                }
           }
   
           if ( i == cMax )
           {
               odmDebugOut(( DEB_ERROR, "RemoveCatalog Failed, Catalog(%ws) not found\n", bstrCatName ));
   
               sc = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
           }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED (sc) )
    {
       odmDebugOut(( DEB_ERROR, "RemoveCatalog Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::GetCatalogByName, public
//
//  Arguments:  [bstrCatalogName]   -- Catalog name to search for.
//              [pIDisp]            -- IDisp interface to the found catalog
//
//  Returns:    S_OK upon success, other values upon failure.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::GetCatalogByName(BSTR bstrCatalogName, IDispatch * * pIDisp)
{

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        ValidateInputParam(bstrCatalogName);

        Initialize();

        unsigned cMaxCatalogs = _aICatAdmin.Count();

        for ( DWORD i = 0; i < cMaxCatalogs; i++ )
        {
            Win4Assert( _aICatAdmin[i] );

            CCatalogAdmin * pCatalogAdmin = _aICatAdmin[i]->GetCatalogAdmin();

            Win4Assert( pCatalogAdmin );

            if ( !_wcsicmp( bstrCatalogName, pCatalogAdmin->GetName() ) )
            {
                *pIDisp = GetIDisp(i);

                break;
            }
        }

        if ( i == cMaxCatalogs )
        {
           odmDebugOut(( DEB_ERROR, "Catalog(%ws) not found\n", bstrCatalogName ));

           sc = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        }
    }
    CATCH ( CException,e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "GetCatalogByName Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::FindFirstCatalog, public
//
//  Synopsis:   Catalog enumerator. Resets scan to start of list.
//
//  Arguments:  [pfFound]   -- out param, True --> Found at least one catalog
//
//  Returns:    SO_OK upon success, other values upon faillure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::FindFirstCatalog(VARIANT_BOOL * pfFound)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        _cEnumIndex = 0;

        if ( _aICatAdmin.Count() > 0 )
        {
            Win4Assert( _aICatAdmin[_cEnumIndex] );

            *pfFound = VARIANT_TRUE;
        }
        else
        {
            *pfFound = VARIANT_FALSE;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "FindFirstCatalog Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::FindNextCatalog, public
//
//  Synopsis:   Catalog enumerator. Scans for next catalog in the list
//
//  Arguments:  [pfFound]   -- out param, True --> Found next catalog
//
//  Returns:    SO_OK upon success, other values upon faillure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::FindNextCatalog(VARIANT_BOOL * pfFound)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        if ( !IsCurrentObjectValid() )
        {
            odmDebugOut(( DEB_ERROR,"CMachineAdm not initialized" ));

            sc = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
        }
        else
        {

            _cEnumIndex++;

            if ( _cEnumIndex < _aICatAdmin.Count() )
            {
                Win4Assert( _aICatAdmin[_cEnumIndex] );

                *pfFound = VARIANT_TRUE;
            }
            else
            {
                *pfFound = VARIANT_FALSE;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "FindNextCatalog Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::GetCatalog, public
//
//  Synopsis:   Catalog enumerator. Returns IDispatch to current catalog
//
//  Arguments:  [pIDisp]   -- out param, IDispatch to current catalog
//
//  Returns:    SO_OK upon success, other values upon faillure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::GetCatalog(IDispatch * * pIDisp)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        if ( !IsCurrentObjectValid() )
        {
            odmDebugOut(( DEB_ERROR,"CMachineAdm not initialized" ));

            sc = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
        }
        else
        {

            if ( _cEnumIndex >= _aICatAdmin.Count() )
            {
                odmDebugOut(( DEB_ERROR, "No More Catalogs, Index: %d\n", _cEnumIndex ));

                sc = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            }
            else
            {

                Win4Assert( _aICatAdmin[_cEnumIndex] );

                *pIDisp = GetIDisp(_cEnumIndex);
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "GetCatalog Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::Start, public
//
//  Synopsis:   Starts cisvc service
//
//  Returns:    S_OK upon success, othervalues upon failure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::Start()
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        _xMachineAdmin->StartCI();

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "Start cisvc Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::Stop, public
//
//  Synopsis:   Stops cisvc service
//
//  Returns:    S_OK upon success, othervalues upon failure
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::Stop()
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        _xMachineAdmin->StopCI();

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "Stop cisvc Failed: %x\n", sc ));

        SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::IsRunning, public
//
//  Synopsis:   is cisvc running
//
//  Returns:    True if cisvc is running, False otherwise.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::IsRunning( VARIANT_BOOL *pfIsRunning )
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        *pfIsRunning = _xMachineAdmin->IsCIStarted() ? VARIANT_TRUE : VARIANT_FALSE;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "Failed to see if cisvc is running: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::IsPaused, public
//
//  Synopsis:   is cisvc paused
//
//  Returns:    True if cisvc is paused, False otherwise.
//
//  History:    08-11-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::IsPaused( VARIANT_BOOL *pfIsPaused )
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        *pfIsPaused = _xMachineAdmin->IsCIPaused() ? VARIANT_TRUE : VARIANT_FALSE;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "Failed to see if cisvc is paused: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::EnableCI, public
//
//  Synopsis:   Sets cisvc to auto-start (enabled) or manual start (disabled)
//
//  Arguments:  [fAutoStart] - True -> set to auto start, False -> set to demand start
//
//  Returns:    S_OK upon success, failure error if failed to set service setting.
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::EnableCI( VARIANT_BOOL fAutoStart )
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        sc = fAutoStart ? _xMachineAdmin->EnableCI() : _xMachineAdmin->DisableCI();

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "Failed enable/disable cisvc settings: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::SetLongProperty, public
//
//  Synopsis:   Sets CI registry params
//
//  Arguments:  [bstrPropName]  -- property name
//              [lPropVal]      -- property value
//
//  Returns:    S_OK upon success, othervalues upon failure
//
//  Notes:      Property value is an unsigned value, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::SetLongProperty(BSTR bstrPropName, LONG lPropVal )
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        ValidateInputParam( bstrPropName );

        Initialize();

        _xMachineAdmin->SetDWORDParam( bstrPropName, lPropVal );

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "SetLongParam Failed: %x\n", sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::GetLongProperty, public
//
//  Synopsis:   Gets CI registry params
//
//  Arguments:  [bstrPropName]  -- property name
//              [plPropVal]     -- returned property value
//
//  Returns:    S_OK upon success, othervalues upon failure
//
//  Notes:      Property value is an unsigned value, though it is being
//              passed in as a signed LONG for compatiblity with automation
//              clients (VB5, VB6 don't support unsigned long).
//
//  History:    12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::GetLongProperty(BSTR bstrPropName, LONG * plPropVal )
{

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        ValidateInputParam( bstrPropName );

        Initialize();

        unsigned long uVar = 0;

        if ( !_xMachineAdmin->GetDWORDParam( bstrPropName, uVar ) )
        {
            sc = E_FAIL;
        }
        else
        {
            *plPropVal = uVar;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "GetLONGParam Failed: %x\n", sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::SetSZProperty, public
//
//  Synopsis:   Sets CI registry params
//
//  Arguments:  [bstrPropName]  -- property name
//              [bstrVal]       -- property value
//
//  Returns:    S_OK upon success, othervalues upon failure
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::SetSZProperty(BSTR bstrPropName, BSTR bstrVal)
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        ValidateInputParam( bstrPropName );
        ValidateInputParam( bstrVal );

        Initialize();

        unsigned cLen = SysStringLen( bstrVal );
        unsigned cbLen = sizeof WCHAR * (cLen + 1);

        _xMachineAdmin->SetSZParam( bstrPropName, bstrVal, cbLen );

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "SetSZParam Failed: %x\n", sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::GetSZProperty, public
//
//  Synopsis:   Gets CI registry params
//
//  Arguments:  [bstrPropName]  -- property name
//              [pbstrVal]      -- returned property value
//
//  Returns:    S_OK upon success, othervalues upon failure
//
//  History:    4-6-97    mohamedn    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::GetSZProperty(BSTR bstrPropName, BSTR * pbstrVal)
{

    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        ValidateInputParam( bstrPropName );

        Initialize();

        WCHAR awcPropVal[MAX_PATH+1];

        if ( !_xMachineAdmin->GetSZParam( bstrPropName,
                                          awcPropVal,
                                          sizeof awcPropVal ) )
        {
            sc = E_FAIL;
        }
        else
        {
            BSTR pPropVal = SysAllocString( awcPropVal );

            if ( !pPropVal )
            {
                sc = E_OUTOFMEMORY;
            }
            else
            {
                *pbstrVal = pPropVal;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
        odmDebugOut(( DEB_ERROR, "GetSZProperty Failed: %x\n", sc ));

        SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::Pause, public
//
//  Synopsis:   Pauses cisvc service
//
//  Returns:    S_OK upon success, othervalues upon failure
//
//  History:    10-08-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::Pause()
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        _xMachineAdmin->PauseCI();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "Pause cisvc Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::Continue, public
//
//  Synopsis:   Continues cisvc service
//
//  Returns:    S_OK upon success, othervalues upon failure
//
//  History:    09-08-98    kitmanh    created
//
//----------------------------------------------------------------------------

STDMETHODIMP CMachineAdm::Continue()
{
    SCODE sc = S_OK;

    CLock lock(_mtx);

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        SafeForScripting();

        Initialize();

        _xMachineAdmin->StartCI();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( FAILED(sc) )
    {
       odmDebugOut(( DEB_ERROR, "Start cisvc Failed: %x\n", sc ));

       SetErrorInfo( sc );
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::SafeForScripting, public
//
//  Synopsis:   determines if it is safe to invoke this method from a given client site.
//
//  Arguments:  none.
//
//  Returns:    E_ACCESSDENIED if not safe to run, else S_OK
//
//  History:    9/10/98    mohamedn    created
//
//----------------------------------------------------------------------------

void CMachineAdm::SafeForScripting()
{
    SCODE sc = S_OK;

    if ( m_spUnkSite || m_dwSafety )
    {
        Win4Assert( m_spUnkSite );

        XInterface<IUnknown>  xpunkSite;

        sc = GetSite( IID_IUnknown, xpunkSite.GetQIPointer() );  // m_spUnkSite
        if ( FAILED(sc) )
        {
            odmDebugOut(( DEB_ERROR, "GetSite Failed sc: %x, m_spUnkSite: %x, punkSite:%x, m_dwSafety:%x\n", sc, m_spUnkSite, xpunkSite.GetPointer() , m_dwSafety ));

            THROW( CException( E_ACCESSDENIED ) );
        }
        else
        {
            Win4Assert( !xpunkSite.IsNull() );

            if ( m_dwSafety && LocalZoneCheck(xpunkSite.GetPointer()) != S_OK)
            {
                odmDebugOut(( DEB_ERROR, "LocalZoneCheck() Failed, Access denied\n" ));

                THROW( CException( E_ACCESSDENIED ) );
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::IUnknown_QueryService, private
//
//  Synopsis:   determines if it is safe to invoke this method from a given client site.
//
//  Arguments:  [punk]          -- site's IUnkown
//              [guidService]   -- sp guid
//              [riid]          -- interface to query for.
//              [ppvOut]        -- out param, contaiing found interface
//
//  Returns:    S_OK upon success, failure codes otherwise.
//
//  History:    9/10/98    mohamedn    created
//
//----------------------------------------------------------------------------

HRESULT CMachineAdm::IUnknown_QueryService(IUnknown* punk, REFGUID guidService, REFIID riid, void **ppvOut)
{
    HRESULT hres;
    XInterface<IServiceProvider> xPsp;

    *ppvOut = NULL;
    if (!punk)
        return E_FAIL;

    hres = punk->QueryInterface(IID_IServiceProvider, xPsp.GetQIPointer() );
    if ( SUCCEEDED(hres) )
    {
        hres = xPsp->QueryService(guidService, riid, ppvOut);
    }

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::GetHTMLDoc2, private
//
//  Synopsis:   determines if it is safe to invoke this method from a given client site.
//
//  Arguments:  [punk]          -- site's IUnknown
//              [ppHtmlDoc]     -- out param to htm doc
//
//  Returns:    S_OK upon success, failure codes otherwise.
//
//  History:    9/10/98    mohamedn    created
//
//----------------------------------------------------------------------------

HRESULT CMachineAdm::GetHTMLDoc2(IUnknown *punk, IHTMLDocument2 **ppHtmlDoc)
{
    HRESULT hr = E_NOINTERFACE;

    *ppHtmlDoc = NULL;

    //  The window.external, jscript "new ActiveXObject" and the <OBJECT> tag
    //  don't take us down the same road.

    XInterface<IOleClientSite> xClientSite;

    hr = punk->QueryInterface(IID_IOleClientSite, xClientSite.GetQIPointer());
    if (SUCCEEDED(hr))
    {
        //  <OBJECT> tag path

        XInterface<IOleContainer> xContainer;

        hr = xClientSite->GetContainer(xContainer.GetPPointer());
        if (SUCCEEDED(hr))
        {
            hr = xContainer->QueryInterface(IID_IHTMLDocument2, (void **)ppHtmlDoc);
        }

        if (FAILED(hr))
        {
            //  window.external path
            XInterface<IWebBrowser2> xWebBrowser2;

            hr = IUnknown_QueryService(xClientSite.GetPointer(), SID_SWebBrowserApp, IID_IHTMLDocument2, xWebBrowser2.GetQIPointer() );
            if (SUCCEEDED(hr))
            {
                XInterface<IDispatch> xDispatch;

                hr = xWebBrowser2->get_Document(xDispatch.GetPPointer());
                if (SUCCEEDED(hr))
                {
                    hr = xDispatch->QueryInterface(IID_IHTMLDocument2, (void **)ppHtmlDoc);
                }
            }
        }
    }
    else
    {
        //  jscript path
        hr = IUnknown_QueryService(punk, SID_SContainerDispatch, IID_IHTMLDocument2, (void **)ppHtmlDoc);
    }

    Win4Assert( FAILED(hr) || (*ppHtmlDoc) );
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::LocalZoneCheckPath, private
//
//  Synopsis:   determines if it is safe to invoke this method from a given client site.
//
//  Arguments:  [pbstrPath]          -- out param. Path of htm page.
//
//  Returns:    S_OK upon success, failure codes otherwise.
//
//  History:    9/10/98    mohamedn    created
//
//----------------------------------------------------------------------------

HRESULT CMachineAdm::LocalZoneCheckPath(LPCWSTR pbstrPath)
{
    HRESULT hr = E_ACCESSDENIED;
    if (pbstrPath)
    {
        XInterface<IInternetSecurityManager> xSecMgr;

        if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager,
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_IInternetSecurityManager,
                                       xSecMgr.GetQIPointer())))
        {
            DWORD dwZoneID = URLZONE_UNTRUSTED;
            if (SUCCEEDED(xSecMgr->MapUrlToZone(pbstrPath, &dwZoneID, 0)))
            {
                if (dwZoneID == URLZONE_LOCAL_MACHINE)
                    hr = S_OK;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachineAdm::LocalZoneCheck, private
//
//  Synopsis:   determines if it is safe to invoke this method from a given client site.
//
//  Arguments:  [punkSite]          -- site's IUnknown.
//
//  Returns:    S_OK upon success, failure codes otherwise.
//
//  History:    9/10/98    mohamedn    created
//
//----------------------------------------------------------------------------

HRESULT CMachineAdm::LocalZoneCheck(IUnknown *punkSite)
{

    //  Return S_FALSE if we don't have a host site since we have no way of doing a
    //  security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
        return S_FALSE;

    // Try to use the URL from the document to zone check

    XInterface<IHTMLDocument2> xHtmlDoc;
    HRESULT hr = E_ACCESSDENIED;

    if (SUCCEEDED(GetHTMLDoc2(punkSite, xHtmlDoc.GetPPointer()) ))
    {
        Win4Assert(xHtmlDoc.GetPointer());

        BSTR bstrPath;

        if ( SUCCEEDED( xHtmlDoc->get_URL(&bstrPath) ))
        {
            hr = LocalZoneCheckPath( bstrPath );

            SysFreeString(bstrPath);
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cipwd\cipwd.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  Purpose:    Hack app for setting/viewing password entries used by
//              CI to index remote scopes.  Someday, this will be
//              handled by a real GUI admin tool.
//
//  History:    28-Oct-96   dlee   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

extern "C"
{
    #include <ntsam.h>
    #include <ntlsa.h>
}

#include <cisecret.hxx>

void DumpSecrets( WCHAR const * pwcMachine )
{
    // list all of the ci secret items

    CCiSecretRead secret( pwcMachine );
    CCiSecretItem * pItem = secret.NextItem();

    while ( 0 != pItem )
    {
        printf( " catalog, user, password: '%ws' '%ws' '%ws'\n",
                pItem->getCatalog(),
                pItem->getUser(),
                pItem->getPassword() );

        pItem = secret.NextItem();
    }
} //DumpSecrets

void AddOrReplaceSecret(
    WCHAR const * pwcCat,
    WCHAR const * pwcUser,
    WCHAR const * pwcPW )
{
    // write objects start blank -- the old entries must be copied
    // into the write object, along with the new entry.

    CCiSecretWrite secretWrite;
    CCiSecretRead secret;
    CCiSecretItem * pItem = secret.NextItem();

    while ( 0 != pItem )
    {
        if ( ( !_wcsicmp( pwcCat, pItem->getCatalog() ) ) &&
             ( !_wcsicmp( pwcUser, pItem->getUser() ) ) )
        {
            // don't add this -- replace it below
        }
        else
        {
            // just copy the item

            secretWrite.Add( pItem->getCatalog(),
                             pItem->getUser(),
                             pItem->getPassword() );
        }

        pItem = secret.NextItem();
    }

    // add the new item

    secretWrite.Add( pwcCat, pwcUser, pwcPW );

    // write it to the sam database

    secretWrite.Flush();
} //AddOrReplaceSecret

void EmptySecrets()
{
    CCiSecretWrite secretWrite;
    secretWrite.Flush();
} //EmptySecrets

void Usage()
{
    printf( "usage: cipwd catalogname domain\\user pwd\n"
            "   or: cipwd -d[ump] [machine] (dump the entry list) \n"
            "   or: cipwd -e[mpty] (empty the entry list)\n" );
    exit( 1 );
} //Usage

int __cdecl main( int argc, char *argv[] )
{
    TRANSLATE_EXCEPTIONS;

    TRY
    {
        if ( argc < 2 || argc > 4 )
            Usage();

        if ( 2 == argc || 3 == argc )
        {
            if ( argv[1][0] == '-' && argv[1][1] == 'd' )
            {
                if ( 2 == argc )
                    DumpSecrets( 0 );
                else
                {
                    WCHAR awcMachine[ MAX_PATH ];
                    mbstowcs( awcMachine, argv[2], sizeof awcMachine );

                    DumpSecrets( awcMachine );
                }
            }
            else if ( argv[1][0] == '-' && argv[1][1] == 'e' )
                EmptySecrets();
            else
                Usage();
        }
        else
        {
            WCHAR awcCat[ MAX_PATH ];
            mbstowcs( awcCat, argv[1], sizeof awcCat );

            WCHAR awcUser[ MAX_PATH ];
            mbstowcs( awcUser, argv[2], sizeof awcUser );

            WCHAR awcPwd[ MAX_PATH ];
            mbstowcs( awcPwd, argv[3], sizeof awcPwd );

            AddOrReplaceSecret( awcCat, awcUser, awcPwd );
        }
    }
    CATCH ( CException, e )
    {
        printf( "caught exception 0x%x\n", e.GetErrorCode() );
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return 0;
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\ciodm\stdafx.h ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation.
//
// File:        stdafx.h
//
// Contents:    include file for standard system include files,
//              or project specific include files that are used frequently,
//              but are changed infrequently
//
// History:     12-10-97    mohamedn    created
//
//----------------------------------------------------------------------------

#pragma once

#ifndef STRICT
#define STRICT
#endif 

#define _ATL_FREE_THREADED

//
// debug AddRef/Release - remove when done.
//
#define _ATL_DEBUG_REFCOUNT
//    #define _ATL_DEBUG_QI

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#define _ATL_DEBUG_REFCOUNT
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#include <comdef.h>
#include <shlobj.h>
#include <shlguid.h>

#include <catalog.hxx>
#include <catadmin.hxx>
#include "resource.h"
#include <cisem.hxx>
#include "ciodmerr.hxx"

#include "initguid.h"
#include "ciodm.h"


#include "MacAdmin.hxx"
#include "CatAdm.hxx"
#include "scopeadm.hxx"

DECLARE_DEBUG( odm );

#if DBG == 1
    #define odmDebugOut( x ) odmInlineDebugOut x
#else
    #define odmDebugOut( x )
#endif  // DBG


//
// Utility routines
//
inline void ValidateInputParam(BSTR bstr)
{
    if ( 0 == bstr )
        THROW( CException(E_INVALIDARG) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cisvc\cisvc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       cisvc.cxx
//
//  Contents:   CI service
//
//  History:    17-Sep-96   dlee   Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <cievtmsg.h>
#include <cisvcex.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>

DECLARE_INFOLEVEL(ci)

//+-------------------------------------------------------------------------
//
//  Function:   main, public
//
//  Purpose:    Call into CI to start the service
//
//  Arguments:  [argc] - number of arguments passed
//              [argv] - arguments
//
//  History:    05-Jan-97   dlee  Created
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR *argv[] )
{
    #if CIDBG == 1
        ciInfoLevel = DEB_ERROR | DEB_WARN | DEB_IWARN | DEB_IERROR;
    #endif

    static SERVICE_TABLE_ENTRY _aServiceTableEntry[2] =
    {
        { wcsCiSvcName, CiSvcMain },
        { NULL, NULL }
    };

    ciDebugOut( (DEB_ITRACE, "Ci Service: Attempting to start Ci service\n" ));

    // Turn off system popups

    CNoErrorMode noErrors;

    // Translate system exceptions into C++ exceptions

    CTranslateSystemExceptions translate;

    TRY
    {
        //
        //  Inform the service control dispatcher the address of our start
        //  routine. This routine will not return if it is successful,
        //  until service shutdown.
        //
        if ( !StartServiceCtrlDispatcher( _aServiceTableEntry ) )
        {
            ciDebugOut( (DEB_ITRACE, "Ci Service: Failed to start service, rc=0x%x\n", GetLastError() ));
            THROW( CException() );
        }
    }
    CATCH (CException, e)
    {
        ciDebugOut(( DEB_ERROR,
                     "Ci Service exception in main(): 0x%x\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    ciDebugOut( (DEB_ITRACE, "Ci Service: Leaving CIServiceMain()\n" ));

    return 0;
} //main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\assert.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if CIDBG == 1

// needed for CT TOM assert events trapping
#include <assert.hxx>
#include <namesem.hxx>
#include <smem.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>

#include <dprintf.h>            // w4printf, w4dprintf prototypes
#include <cidllsem.hxx>

#undef FAR
#undef NEAR

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_STRESSBREAK;
extern char * aDebugBuf;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


EXPORTIMP void APINOT
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    #if 0
    //
    // This code is for the CT Lab only.  When running in the lab,
    // all assert popups will be trapped and notifications will
    // be sent to the manager.  If running in the office (non-lab
    // mode), the event CTTOMTrapAssertEvent will not exist and
    // consequently, no event will be pulsed.
    //

    HANDLE hTrapAssertEvent,
           hThreadStartEvent;

    if (hTrapAssertEvent = OpenEvent(EVENT_ALL_ACCESS,
                                     FALSE,
                                     CAIRO_CT_TOM_TRAP_ASSERT_EVENT))
    {
        SetEvent(hTrapAssertEvent);

        //
        // This event is to allow TOM Manager time to perform
        // a CallBack to the dispatcher.
        //
        if (hThreadStartEvent = OpenEvent(EVENT_ALL_ACCESS,
                                          FALSE,
                                          CAIRO_CT_TOM_THREAD_START_EVENT))
        {
            //
            // Wait until it's ok to popup or until timed-out
            //
            WaitForSingleObject(hThreadStartEvent, TWO_MINUTES);
        }
    }
    #endif // 0

    //
    // Always check to make sure the assert flag hasn't changed.
    //

    CRegAccess regAdmin( RTL_REGISTRY_CONTROL, wcsRegAdmin );

    ULONG ulLevel = regAdmin.Read( wcsWin4AssertLevel, 0xFFFFFFFF );

    if (ulLevel != 0xFFFFFFFF )
        SetWin4AssertLevel( ulLevel );

    //
    // Do the assert
    //

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_STRESSBREAK)
    {
        //
        // See if a debugger is attachable.  If not, then put up a popup.
        //

        BOOL fOk = FALSE;

        try
        {
            CRegAccess regAeDebug( RTL_REGISTRY_ABSOLUTE,
                                   L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug" );

            WCHAR wcsTemp[100];
            regAeDebug.Get( L"Auto", wcsTemp, sizeof(wcsTemp)/sizeof(WCHAR) );

            if ( L'1' == wcsTemp[0] && 0 == wcsTemp[1] )
            {
                regAeDebug.Get( L"Debugger", wcsTemp, sizeof(wcsTemp)/sizeof(WCHAR) );

                if ( 0 != wcsTemp[0] && 0 == wcsstr( wcsTemp, L"drwtsn" ) )
                {
                    fOk = TRUE;
                }
            }
        }
        catch( ... )
        {
        }

        //
        // Debugger is attachable, break in.
        //

        if ( fOk )
        {
            w4dprintf( "***\n***\n*** Restartable software exception used to activate user-mode\n" );
            w4dprintf( "*** debugger. Enter 'g' to continue past assert (if you can't wait).\n" );
            w4dprintf( "*** Please send mail to the NtQuery alias first. aDebugBuf = 0x%x\n***\n***\n", aDebugBuf );

            RaiseException( ASSRT_STRESSEXCEPTION, 0, 0, 0 );
        }

        //
        // No debugger.  Put up a popup.
        //

        else
        {
            int id = PopUpError(szMessage,iLine,szFile);

            if (id == IDCANCEL)
            {
                DebugBreak();
            }
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

EXPORTIMP int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if ( 0 == pszModuleName )
            pszModuleName = szModuleName;
        else
            pszModuleName++;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf( szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
             pszModuleName, szFile, iLine, pid, tid);

    UINT uiOldMode = SetErrorMode( 0 );

    int id = MessageBoxA( 0,
                          (char *) szMsg,
                          (LPSTR) szAssertCaption,
                          MB_SERVICE_NOTIFICATION |
                          MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL );

    SetErrorMode( uiOldMode );

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (!id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA( NULL,
                              (char *) szMsg,
                              (LPSTR) szAssertCaption,
                              MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                              MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL );

        }
        else
        {
            // default: break if you can't display the messagebox

            id = IDCANCEL;
        }
    }

    return id;
}

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

CDLLStaticMutexSem g_mxsAssert;

CIPMutexSem     mtxDebugBuf( L"CiDebugMtx", CIPMutexSem::AppendPid, FALSE, 0 );
CNamedSharedMem memDebugBuf( L"CiDebugMem", CNamedSharedMem::AppendPid, 1024 * 32 );
BOOL *          pfUseDebugBuf = 0;
BOOLEAN *       pfIsBeingDebugged = 0;
ULONG *         piDebugBuf = 0;
char *          aDebugBuf = 0;


//
// Very special version of the debug allocator.  Doesn't record allocation
// in log.  Failure to free is not considered a leak.
//

#if CIDBG == 1
void * ciNewDebugNoRecord( size_t size );

enum eAlloc { NoRecordAlloc };
inline void * __cdecl operator new ( size_t size, eAlloc )
{
    return ciNewDebugNoRecord( size );
}
#endif

EXPORTIMP void APINOT
vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();

        g_mxsAssert.Request();

        if ( 0 == pfUseDebugBuf )
        {
            piDebugBuf = (ULONG *)memDebugBuf.Get();
            pfUseDebugBuf = (BOOL *)memDebugBuf.Get() + sizeof(*piDebugBuf);
            aDebugBuf = (char *)memDebugBuf.Get();

            //
            // We can look here to tell when a process is being debugged.
            //

            pfIsBeingDebugged = &NtCurrentPeb()->BeingDebugged;

            CIPLock lock( mtxDebugBuf );

            if ( 0 == *piDebugBuf )
            {
                *piDebugBuf = sizeof(*piDebugBuf) + sizeof(*pfUseDebugBuf);
                *pfUseDebugBuf = TRUE;

            }
        }

        BOOL fRequested = FALSE;

        if ( 0 != pfIsBeingDebugged && *pfUseDebugBuf && !*pfIsBeingDebugged )
        {
            mtxDebugBuf.Request();
            fRequested = TRUE;
        }

        //
        // Assume no debug message will be > 1K
        //

        if ( *pfUseDebugBuf && *piDebugBuf >= ( 31 * 1024 ) )
            *piDebugBuf = sizeof(*piDebugBuf) + sizeof(*pfUseDebugBuf);

        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                if ( 0 != pfIsBeingDebugged && *pfUseDebugBuf && !*pfIsBeingDebugged )
                {
                    *piDebugBuf += sprintf( aDebugBuf + *piDebugBuf, "%d.%03d> ", pid, tid );
                    *piDebugBuf += sprintf( aDebugBuf + *piDebugBuf, "%s: ", pszComp);
                }
                else
                {
                    w4dprintf( "%d.%03d> ", pid, tid );
                    w4dprintf("%s: ", pszComp);
                }
            }

            if ( 0 != pfIsBeingDebugged && *pfUseDebugBuf && !*pfIsBeingDebugged )
                *piDebugBuf += vsprintf( aDebugBuf + *piDebugBuf, ppszfmt, pargs );
            else
                w4vdprintf(ppszfmt, pargs);
        }

        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        if ( fRequested )
            mtxDebugBuf.Release();

        g_mxsAssert.Release();
    }
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // CIDBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\dbgmod.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       dbgmod.cxx
//
//  Contents:   Support for visual debug values
//
//  Classes:
//
//  Functions:
//
//  History:    12-Mar-93  KevinRo  Created
//
//  This module handles debug values, such as breakpoints and settable
//  values. By using this module, the values can be examined and changed
//  in a debugging window. The debugging window uses its own thread, so
//  changes can be effected asynchronously.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//
// NOTE: This file is surrounded by if CIDBG == 1, which means that these
// routines are in the debugging version ONLY
//


#if CIDBG == 1

#include <dbgpoint.hxx>


//
// The following Mutex provides a lock for registering the InfoLevelGroup
//

//CMutexSem  mtxInfoLevelLock;

//+-------------------------------------------------------------------------
//
//  Function:   dbgGetIniInfoLevels
//
//  Synopsis:   Called by the CInfoLevel constructor to get the default
//              value for an InfoLevel from win.ini
//
//  Arguments:
//  [pwzName] --    Name of InfoLevel
//  [ulDefault] --  Default value if not found in win.ini
//
//  Requires:
//
//  Returns:    Returns the value read from profile, or default if the value
//              didn't exist in the correct section.
//
//--------------------------------------------------------------------------


WCHAR *pwzInfoLevelSectionName = L"Cairo InfoLevels";
WCHAR *pwzInfoLevelDefault = L"$";

#define INIT_VALUE_SIZE 16
extern "C"
EXPORTIMP
ULONG APINOT dbgGetIniInfoLevel(WCHAR const *pwzName,ULONG ulDefault)
{
    WCHAR awcInitValue[INIT_VALUE_SIZE];

    ULONG ulRet;

    ulRet = GetProfileString(pwzInfoLevelSectionName,
                             pwzName,
                             pwzInfoLevelDefault,
                             awcInitValue,
                             INIT_VALUE_SIZE);

    if(ulRet == (INIT_VALUE_SIZE - 1))
    {
        return(ulDefault);

    }
    if(awcInitValue[0] == L'$')
    {
        return(ulDefault);
    }

    if(swscanf(awcInitValue,L"%x",&ulRet) != 1)
    {
        return(ulDefault);
    }

    return(ulRet);
}

// stubs

extern "C"
EXPORTIMP
void APINOT dbgRemoveGroup(HANDLE hGroup)
{}

extern "C"
EXPORTIMP
void APINOT dbgRegisterGroup(WCHAR const *pwzName,HANDLE *phGroup)
{}

extern "C"
EXPORTIMP
void APINOT dbgNotifyChange(HANDLE hGroup,CDebugBaseClass *pdv)
{}


extern "C"
EXPORTIMP
void APINOT dbgRegisterValue(WCHAR const *pwzName,
                             HANDLE hGroup,
                             CDebugBaseClass *pdv)
{}

extern "C"
EXPORTIMP
void APINOT dbgRemoveValue(HANDLE hGroup,CDebugBaseClass *pdv)
{}


#endif // if CIDBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\alocdbg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       alocdbg.cxx
//
//  Contents:   This file implements an arena that tracks memory allocations
//              and frees.
//
//  History:    28-Oct-92   IsaacHe     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <alocdbg.hxx>
#include <basetyps.h>
#include <tracheap.h>
#include <wtypes.h>

extern "C"
{
#include <imagehlp.h>
#define MAX_TRANSLATED_LEN 80
}

#include "snapimg.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   RecordStack functions(s) below...per processor type
//
//  Synopsis:   Record a stack backtrace into fTrace
//
//  Arguments:  [cFrameSkipped] --  How many stack frames to skip over and
//                      not record
//              [fTrace] -- The recorded frames are put in here
//
//  Returns:    A checksum of the stack frames for fast initial lookups
//
//  Notes:      If we can do stack backtracing for whatever processor we're
//              compiling for, the #define CANDOSTACK
//
//----------------------------------------------------------------------------
#if defined (_X86_)

static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{

#define CANDOSTACK

    ULONG sum;
    USHORT cStack;

    // NOTE:  RtlCaptureStackBackTrace does not understand FPOs, so routines
    //        that have FPOs will be skipped in the backtrace.  Also, there is
    //        a chance of an access violation for inter-module calls from an
    //        FPO routine, so enclose the call to RtlCaptureStackBackTrace
    //        in a TRY/CATCH.

    __try
    {
        sum = 0;
        cStack = RtlCaptureStackBackTrace(cFrameSkipped + 1,
                                          DEPTHTRACE, fTrace, &sum );
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // Checksum any addresses that may have been collected in the buffer
        //

        for ( cStack = 0, sum = 0; cStack < DEPTHTRACE; cStack++ )
        {
            sum += (ULONG) (fTrace[cStack]);
        }
    }

    return sum;
}

#elif defined( _AMD64_ )

DWORD
RecordStack(
    int cFrameSkipped,
    void *fTrace[DEPTHTRACE]
    )

{

#define CANDOSTACK

    ULONG sum;
    USHORT cStack;

    __try
    {
        sum = 0;
        cStack = RtlCaptureStackBackTrace(cFrameSkipped + 1,
                                          DEPTHTRACE,
                                          &fTrace[0],
                                          &sum);

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Checksum any addresses that may have been collected in the buffer.
        //

        for (cStack = 0, sum = 0; cStack < DEPTHTRACE; cStack++) {
            sum += (ULONG)((ULONG64)(fTrace[cStack]));
        }
    }

    return sum;
}

#endif // machine-specific RecordStack implementations

#if  CIDBG

#pragma optimize( "y", off )

DECLARE_INFOLEVEL( heap );
DECLARE_DEBUG( heap );
#define heapDebugOut(x) heapInlineDebugOut x

DECLARE_INFOLEVEL(Cn);

/*
 * The maximum number of AllocArenaCreate's we expect
 */
static const    MAXARENAS       = 5;

/*
 * When printing leak dumps, the max number we will print out.  Note, we keep
 * track of all of them, we just don't want to take forever to terminate a
 * process
 */
static const    MAXDUMP         = 500;

/*
 * The maximum size we'll let any single debug arena get
 */
static const ULONG ARENASIZE    = 2048*1024;

/*
 * The unit of growth for the arena holding the AllocArena data.
 * Must be a power of 2
 */
static const ALLOCRECINCR       = 128;


AllocArena *AllocArenas[ MAXARENAS + 1 ];


//
// Create an arena for recording allocation statistics.  Return the arena
// pointer to the caller
//
STDAPI_( AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment )
{
        // the first time through, we set up the symbol handler
        static int FirstTime = TRUE;
        if ( FirstTime )
        {
            //
            //  Snap to imagehlp dll
            //

            if (!SnapToImageHlp( ))
            {
                heapDebugOut(( DEB_WARN, "ci heap unable to load imagehlp!\n" ));
                return FALSE;
            }
            LocalSymSetOptions( SYMOPT_DEFERRED_LOADS );
            LocalSymInitialize( GetCurrentProcess(), NULL, TRUE );
            FirstTime = FALSE;
        }

        struct AllocArena *paa = NULL;

        if( memctx == MEMCTX_TASK ) {
#if     defined( CANDOSTACK )

                if( heapInfoLevel & DEB_WARN ) {

                        paa = (struct AllocArena *)VirtualAlloc(
                                NULL, ARENASIZE, MEM_RESERVE, PAGE_NOACCESS );
                        if( paa == NULL )
                                return NULL;

                        paa = (AllocArena *)VirtualAlloc( paa,
                           sizeof(*paa)+(ALLOCRECINCR-1)*sizeof(HeapAllocRec),
                           MEM_COMMIT, PAGE_READWRITE );

                }
                else
#endif
                {
                        paa = (struct AllocArena *)calloc( 1, sizeof(*paa) );
                }
        }

        if( paa == NULL )
                return NULL;

        memcpy( paa->Signature,HEAPSIG,sizeof(HEAPSIG));
        if( comment )
                strncpy(paa->comment, comment, sizeof(paa->comment) );

        InitializeCriticalSection( &paa->csExclusive );

        for( int i=0; i < MAXARENAS; i++ )
                if( AllocArenas[i] == 0 ) {
                        AllocArenas[i] = paa;
                        break;
                }

#if     defined( CANDOSTACK )
        if( (heapInfoLevel & DEB_WARN) == 0 )
#endif
        {
                paa->flags.KeepStackTrace = 0;
                paa->AllocRec[0].paa = paa;
                return paa;
        }

#if     defined( CANDOSTACK )
        paa->cRecords = ALLOCRECINCR;
        paa->cTotalRecords = ALLOCRECINCR;
        paa->flags.KeepStackTrace = 1;

        return paa;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordAlloc
//
//  Synopsis:   Keep a hash table of the stack backtraces of the allocations
//              we've done.
//
//  Arguments:  [paa] -- Return value from AllocArenaCreate() above
//              [bytes] -- the number of bytes being allocated by the caller.
//                      This value is recorded in the stack backtrace entry.
//
//  Algorithm:  The arena for the AllocArena is created with VirtualAlloc.
//                      pAllocArena->cRecords is the index of the next
//                      free record.  The first ALLOCRECINCR records are heads
//                      of separate lists of the records.
//
//  Returns:    A pointer to the AllocRec structure recording the entry.
//              Can return NULL if we can't record the allocation.
//
//----------------------------------------------------------------------------
STDAPI_( HeapAllocRec FAR * )
AllocArenaRecordAlloc( AllocArena *paa, size_t bytes )
{
        if( paa == NULL )
                return NULL;

        EnterCriticalSection( &paa->csExclusive );

        if( bytes ) {
                paa->cAllocs++;
                paa->cBytesNow += bytes;
                paa->cBytesTotal += bytes;
        } else {
                paa->czAllocs++;
        }

        //
        // Record 'size' in the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

        LeaveCriticalSection( &paa->csExclusive );

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace == 0 )
#endif
                return &paa->AllocRec[0];

#if     defined( CANDOSTACK )

        DWORD sum;
        struct HeapAllocRec *phar,*hp;
        void *fTrace[ DEPTHTRACE ];

        //
        // See if we find an existing record of this stack backtrace
        //
        memset( fTrace, '\0', sizeof( fTrace ) );
        sum = RecordStack( 2, fTrace );

        hp = &paa->AllocRec[ sum & (ALLOCRECINCR-1) ];

        EnterCriticalSection( &paa->csExclusive );

        for( phar = hp; phar != NULL; phar = phar->u.next )
                if( phar->sum == sum && RtlEqualMemory(phar->fTrace,fTrace,sizeof(fTrace)))
                {
                        phar->count++;
                        phar->bytes += bytes;
                        phar->total.bytes += bytes;
                        phar->total.count++;
                        phar->paa = paa;
                        LeaveCriticalSection( &paa->csExclusive );
                        return phar;
                }
        //
        // We have no record of this allocation.  Make one!
        //
        if( hp->total.count && paa->cRecords == paa->cTotalRecords ) {
                //
                // The arena is currently full.  Grow it by ALLOCRECINCR
                //
                AllocArena *npHeap;

                npHeap = (AllocArena *)VirtualAlloc(
                        paa,
                        sizeof(AllocArena)+
                        ((paa->cTotalRecords + ALLOCRECINCR) *
                                sizeof(HeapAllocRec) ),
                        MEM_COMMIT, PAGE_READWRITE );

                if( npHeap != paa )
                {
                    if ( 0 == (paa->cMissed % 1000) )
                    {
                        heapDebugOut(( DEB_WARN,
                                       "ci: Missed recording alloc -- couldn't grow arena 0x%x to %u bytes.  Error %d\n",
                                       paa,
                                       ((paa->cTotalRecords + ALLOCRECINCR) * sizeof(HeapAllocRec)),
                                       GetLastError() ));
                    }

                    paa->cMissed++;
                    LeaveCriticalSection( &paa->csExclusive );
                    return NULL;
                }

                paa->cTotalRecords += ALLOCRECINCR;
        }

        if( hp->total.count == 0 ) {
                phar = hp;
        } else {
                phar = &paa->AllocRec[ paa->cRecords++ ];
                phar->u.next = hp->u.next;
                hp->u.next = phar;
        }

        paa->cPaths++;

        memcpy( phar->fTrace, fTrace, sizeof( fTrace ) );
        phar->count = phar->total.count = 1;
        phar->bytes = phar->total.bytes = bytes;
        phar->sum = sum;
        phar->paa = paa;
        LeaveCriticalSection( &paa->csExclusive );
        return phar;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordReAlloc
//
//  Synopsis:   Update the record to reflect the fact that we've ReAlloc'd
//              the memory chunk.
//
//  Arguments:  [vp] -- Return value from AllocArenaRecordAlloc() above
//              [oldbytes] -- size of the memory before ReAllocation
//              [newbytes] -- new size of the memory
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordReAlloc( HeapAllocRec FAR *vp, size_t oldbytes, size_t newbytes)
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        paa->cReAllocs++;
        paa->cBytesNow -= oldbytes;
        paa->cBytesNow += newbytes;

        if( newbytes > oldbytes )
                paa->cBytesTotal += newbytes - oldbytes;

        //
        // Take 'oldbytes' out of the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( oldbytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        //
        // Record 'newbytes' in the histogram of requests
        //
        for( i=31; i>=0; i-- )
                if( newbytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->bytes -= oldbytes;
                vp->bytes += newbytes;
                vp->total.count++;
                if( newbytes > oldbytes )
                        vp->total.bytes += newbytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordFree
//
//  Synopsis:   Caller has freed memory -- keep accounting up to date
//
//  Arguments:  [vp] -- Value returned by AllocArenaRecordAlloc() above
//              [bytes] -- The number of bytes being freed
//
//  Algorithm:  AllocRec structures, once allocated, are never actually
//                      freed back to the Hash memory arena.  This helps us
//                      understand historical use of the heap.
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordFree( HeapAllocRec FAR *vp, size_t bytes )
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        //
        // Record this free in the histogram
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        paa->cFrees++;
        paa->cBytesNow -= bytes;

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->count--;
                vp->bytes -= bytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

STDAPI_( void )
AllocArenaDumpRecord( HeapAllocRec FAR *bp )
{
#if     defined( CANDOSTACK )
        char achBuffer[ MAX_TRANSLATED_LEN ], *p;
        static int FirstTime = TRUE;

        // make sure we print the nice undecorated names
        if ( FirstTime )
        {
            LocalSymSetOptions( SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS );
            FirstTime = FALSE;
        }

        heapDebugOut((DEB_WARN, "*** %d allocs, %u bytes:\n",
                         bp->count, bp->bytes ));

        HANDLE hProcess = GetCurrentProcess();

        for( int j=0; j<DEPTHTRACE && bp->fTrace[j]; j++ )
        {
            BYTE             symbolInfo[sizeof(IMAGEHLP_SYMBOL) + MAX_TRANSLATED_LEN];
            PIMAGEHLP_SYMBOL psym = (PIMAGEHLP_SYMBOL) &symbolInfo;

            DWORD_PTR        dwDisplacement;

            psym->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
            psym->MaxNameLength = MAX_TRANSLATED_LEN;

            if ( LocalSymGetSymFromAddr( hProcess,
                                   (ULONG_PTR)(bp->fTrace[j]),
                                   &dwDisplacement,
                                   psym ) )
            {
                if ( LocalSymUnDName( psym, achBuffer, MAX_TRANSLATED_LEN ) )
                {
                    heapDebugOut((DEB_WARN,
                                  "       %s+0x%p (0x%p)\n",
                                  achBuffer,
                                  dwDisplacement,
                                  (ULONG_PTR)(bp->fTrace[j]) ));
                }
                else
                {
                    heapDebugOut(( DEB_WARN,
                                   "       %s+%#x (%#x)\n",
                                   psym->Name,
                                   dwDisplacement,
                                   bp->fTrace[j] ));
                }
            }
            else
            {
                heapDebugOut(( DEB_WARN,
                               "       0x%x (symbolic name unavailable)\n",
                               (ULONG_PTR)bp->fTrace[j] ));
            }
        }
#endif
}

extern "C" ULONG DbgPrint( PCH Format, ... );

STDAPI_( void )
AllocArenaDump( AllocArena *paa )
{
        if( paa == NULL ) {
                for( int i = 0; i < MAXARENAS && AllocArenas[i]; i++ )
                        AllocArenaDump( AllocArenas[i] );
                return;
        }

        EnterCriticalSection( &paa->csExclusive );

        char *cmdline = GetCommandLineA();

        if( cmdline == NULL )
                cmdline = "???";

        HeapAllocRec *bp = paa->AllocRec;
        HeapAllocRec *ep = bp + paa->cRecords;

        if( paa->cBytesNow )
                heapDebugOut((DEB_WARN, "***** CiExcept.Lib: %u bytes leaked mem for %s in '%s'\n", paa->cBytesNow, paa->comment, cmdline ));

        // always dump leaks
        ULONG oldLevel = heapInfoLevel;
        heapInfoLevel |= DEB_TRACE;

#if     defined( CANDOSTACK )
        if( paa->cBytesNow && paa->flags.KeepStackTrace )
        {
                int cleaks = 0;

                for( ; bp < ep; bp++) {
                        if( bp->count )
                                ++cleaks;
                }

                if( cleaks ) {
                        heapDebugOut((DEB_WARN, "***** %s %u MEM LEAKS\n",
                                paa->comment, cleaks ));


                        if( heapInfoLevel & DEB_TRACE ) {
                                HeapAllocRec *bp;
                                UINT maxdump = MAXDUMP;
                                for( bp = paa->AllocRec; maxdump && bp<ep; bp++)
                                        if( bp->count ) {
                                                heapDebugOut((DEB_TRACE, "\n"));
                                                AllocArenaDumpRecord( bp );
                                                maxdump--;
                                        }
                        } else if( cleaks )
                                heapDebugOut((DEB_WARN, "** Set query!heapInfoLevel to x707 for leak backtrace\n"));

                }
        }
#endif

        heapInfoLevel = oldLevel;

        if( (heapInfoLevel & DEB_TRACE) && paa->cBytesTotal )
        {
                heapDebugOut((DEB_TRACE,"\n"));
                heapDebugOut((DEB_TRACE,
                              "'%s' Memory Stats: %u allocations, %u frees, %u missed\n",
                              cmdline, paa->cAllocs, paa->cFrees, paa->cMissed ));

                if( paa->czAllocs )
                        heapDebugOut((DEB_TRACE,
                                "\t%u zero allocs\n", paa->czAllocs ));

        // i64s are not handled by debugout

        char acBuf[100];
        sprintf( acBuf, "\t%I64u bytes allocated\n", paa->cBytesTotal );
        heapDebugOut((DEB_TRACE, acBuf ));

        heapDebugOut((DEB_TRACE,
                        "*** Histogram of Allocated Mem Sizes ***\n"));

        heapDebugOut((DEB_TRACE,
                      "      Min          Max         Tot           Simul\n" ));
        for( int i=0; i < 32; i++ )
        {
            if( paa->Histogram.total[i] )
            {
                heapDebugOut((DEB_TRACE,
                        "%9u -> %9u\t%9u\t%9u\n",
                        1<<i, (1<<(i+1))-1,
                        paa->Histogram.total[i],
                        paa->Histogram.simul[i] ));
            }
        }
    }
    LeaveCriticalSection( &paa->csExclusive );
}

#endif  // CIDBG

CStaticMutexSem g_mtxGetStackTrace;

void GetStackTrace( char * pszBuf, ULONG ccMax )
{
    // Trial and error shows that Imagehlp isn't thread-safe

    CLock lock( g_mtxGetStackTrace );

    // If we cannot get to IMAGEHLP then no stack traces are available

    if (!SnapToImageHlp( ))
        return;

    if ( 0 == pszBuf || ccMax == 0 )
        return;

    char * pszCurrent = pszBuf;

    TRY
    {

#if     defined( CANDOSTACK )

        static int FirstTime = TRUE;

        // make sure we print the nice undecorated names

        if ( FirstTime )
        {
            LocalSymSetOptions( SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS );
            FirstTime = FALSE;
        }

        //
        // Determine the current stack.
        //
        void *fTrace[ DEPTHTRACE ];

        //
        // See if we find an existing record of this stack backtrace
        //
        memset( fTrace, '\0', sizeof( fTrace ) );
        DWORD sum = RecordStack( 2, fTrace );
        if ( 0 == sum )
            return;

        HANDLE hProcess = GetCurrentProcess();

        for( int j=0; j<DEPTHTRACE && fTrace[j]; j++ )
        {
            BYTE             symbolInfo[sizeof(IMAGEHLP_SYMBOL) + MAX_TRANSLATED_LEN];
            PIMAGEHLP_SYMBOL psym = (PIMAGEHLP_SYMBOL) &symbolInfo;

            DWORD_PTR        dwDisplacement;

            psym->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
            psym->MaxNameLength = MAX_TRANSLATED_LEN;

            char szTempBuf[MAX_TRANSLATED_LEN+256];

            if ( LocalSymGetSymFromAddr( hProcess,
                                   (ULONG_PTR)fTrace[j],
                                   &dwDisplacement,
                                   psym ) )
                sprintf( szTempBuf, "       %s+0x%p (0x%p)\n",
                         psym->Name, dwDisplacement, fTrace[j] );
            else
                sprintf( szTempBuf, "  0x%p\n", (ULONG_PTR)fTrace[j] );

            ULONG cc = strlen(szTempBuf);
            if ( cc+pszCurrent >= pszBuf+ccMax )
                break;

            RtlCopyMemory( pszCurrent, szTempBuf, cc );
            pszCurrent += cc;
        }
#endif
    }
    CATCH( CException, e )
    {
        pszBuf[0] = 0;
    }
    END_CATCH

    *pszCurrent = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\ciexcpt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000
//
//  File:       ciexcpt.cxx
//
//  Contents:   Macro package for C++ exception support
//
//  Classes:    CException               -- The base for all exception classes
//              CExceptionContext        -- Per-thread exception context.
//              CUnwindable -- Classes with destructors inherit
//                                          from this.
//
//  History:    22-May-91   KyleP       Created Interface.
//              15-Aug-91   SethuR      Included terminate(),unexpected()
//                                      set_unexpected(),set_terminate()
//              18-Oct-91   KyleP       Win32 try/except implementation
//              19-Nov-91   KyleP       Fix heap unwind, multiple inheritance
//              14-May-92   BryanT      Disable heapchk for FLAT builds.
//              25-Apr-95   DwightKr    Native C++ exception support
//              30-Oct-98   KLam        Translate in page error to disk full
//                                      when appropriate
//              07-Jan-99   KLam        Debug out when in page error occurs
//
//  Notest:     This file is a hack until C 9.x supports exceptions for
//              compilers on all platforms
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//#include <nulock.hxx>

#if CIDBG == 1

extern "C" {
#include <imagehlp.h>
#define MAX_TRANSLATED_LEN 80
}

#include "snapimg.hxx"

void TranslateAddress(
    ULONG p,
    char *achBuffer,
    ULONG cchBuffer)
{
    BYTE             symbolInfo[sizeof(IMAGEHLP_SYMBOL) + MAX_TRANSLATED_LEN];
    PIMAGEHLP_SYMBOL psym = (PIMAGEHLP_SYMBOL) symbolInfo;

    DWORD_PTR        dwDisplacement;

    psym->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    psym->MaxNameLength = MAX_TRANSLATED_LEN;

    HANDLE hProcess = GetCurrentProcess();

    if ( SnapToImageHlp( ) &&
         LocalSymGetSymFromAddr( hProcess,
                           (ULONG_PTR)p,
                           &dwDisplacement,
                           psym )
       )
    {
        char * pszFormat = dwDisplacement ? "%s+0x%p\n" : "%s\n";
        char achTmpBuf[ MAX_TRANSLATED_LEN ];

        if ( LocalSymUnDName( psym, achTmpBuf, MAX_TRANSLATED_LEN ) )
        {
            _snprintf( achBuffer, cchBuffer,
                          pszFormat,
                          achTmpBuf,
                          dwDisplacement );
        }
        else
        {
            _snprintf( achBuffer, cchBuffer,
                          pszFormat,
                          psym->Name,
                          dwDisplacement );
        }
    }
    else
    {
        _snprintf( achBuffer, cchBuffer,
                       "%px (symbolic name unavailable)",
                       (ULONG_PTR)p );
    }
}
#endif // CIDBG

//
// If EXCEPT_TEST is defined, then the exception code can be compiled
// without use the the 'Win4 environment'.  This is only to facilitate
// testing.  When EXCEPT_TEST is defined debug messages are printed
// to stdout instead of the debug terminal.
//

#if !defined( EXCEPT_TEST )

# if CIDBG == 1

DECLARE_DEBUG( ex )

//
// See ciexcpt.hxx for an explanation of why exInlineDebugOut isn't used.
//

void exInlineDebugOut2(unsigned long fDebugMask, char const *pszfmt, ...)
{
    va_list ArgList;
    va_start(ArgList, pszfmt);

    if (exInfoLevel & fDebugMask)
    {
        vdprintf(fDebugMask, exInfoLevelString, (char const *) pszfmt, ArgList);
    }

    va_end(ArgList);
}

# endif // (CIDBG == 1)

# if CIDBG == 1

//
// The default is to print exception messages to debug terminal.
//

unsigned long Win4ExceptionLevel = EXCEPT_MESSAGE;

#  if !defined( DECLARE_INFOLEVEL )
    extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;
    extern EXTRNC char *comp##InfoLevelString = #comp;
#  else
    DECLARE_INFOLEVEL(ex)
#  endif

# endif // (CIDBG == 1)

//+---------------------------------------------------------------------------
//
//  Function:   SetWin4ExceptionLevel
//
//  Synopsis:   Sets global exception level
//
//  History:    15-Sep-91   KevinRo Created
//
//----------------------------------------------------------------------------

# if (CIDBG == 1)

EXPORTIMP unsigned long APINOT
SetWin4ExceptionLevel(
    unsigned long ulNewValue)
{
    unsigned long ul;

    ul = Win4ExceptionLevel;
    Win4ExceptionLevel = ulNewValue;
    return(ul);
}

ULONG GetWin4ExceptionLevel(void)
{
    return Win4ExceptionLevel;
}

# endif // (CIDBG == 1)

#endif // !EXCEPT_TEST

//
// Heap checking can be turned on with this variable.
//     0x00000001 = Always check new/delete
//     0x00000002 = Check delete during unwind.
//

extern "C"
{
    int newHeapCheck = 0;
}

//
// In a multi-threaded (e.g. Win32) environment, we need one
// exception context per thread.
//

enum Unwindability
{
    NonUnwindable
};

void * __cdecl
operator new ( size_t s, Unwindability dummy )
{
#if defined ( _AUTOCHECK_ )
    return RtlAllocateHeap( RtlProcessHeap(), 0, s );
#else
    return(malloc(s));
#endif // _AUTOCHECK_
}

//+-------------------------------------------------------------------------
//
//  Function:   GetScodeError, public
//
//  Synopsis:   Translates an NTSTATUS or HRESULT into an HRESULT (SCODE)
//
//  Arguments:  [e]  -- The exception object
//
//  Returns     A SCODE equivalent
//
//  History:    3-Feb-98 dlee     Created
//
//--------------------------------------------------------------------------

EXPORTIMP SCODE APINOT GetScodeError( CException & e )
{
    //
    // This function normalizes NTSTATUS, HRESULTS, and Win32 error codes
    // into a Win32 error.  Note that it is illegal in CI to throw Win32
    // error codes because they will be confused with HRESULT success codes
    //
    // n.b. A side effect is that this error is set in the thread's LastError
    //

    SCODE sc = e.GetErrorCode();

    // If it looks like an HRESULT already, just return it.

    if ( 0x80000000 == ( 0xC0000000 & sc ) )
        return sc;

    //
    // If it's a CI 0xC error, don't try to map it since it'll return
    // ERROR_MR_MID_NOT_FOUND (and DbgBreak on checked builds).
    //

    if ( 0xC0041000 == ( 0xC0041000 & sc ) )
        return sc;

    DWORD dwError = RtlNtStatusToDosError( sc );

    if ( ERROR_MR_MID_NOT_FOUND == dwError )
    {
        ciDebugOut(( DEB_WARN, "mr mid for error %#x\n", sc ));
        return sc;
    }

    return HRESULT_FROM_WIN32( dwError );
} //GetScodeError

//+-------------------------------------------------------------------------
//
//  Method:     IsOleError, public
//
//  Synopsis:   return TRUE if sc looks like an OLE SCODE.
//
//  History:    19-Apr-95 BartoszM     Created
//
//--------------------------------------------------------------------------
inline BOOL IsOleError (NTSTATUS sc)
{
    // if it's a win32 facility error in an hresult, only certain
    // instances are allowed returned by oledb.  Map others to E_FAIL.

    if ( 0x80070000 == ( sc & 0x80070000 ) )
    {
        if ( E_OUTOFMEMORY  == sc ||
             E_INVALIDARG   == sc ||
             E_HANDLE       == sc ||
             E_ACCESSDENIED == sc )
            return TRUE;
        else
            return FALSE;
    }
    else if ( 0x80030000 == ( sc & 0x80030000 ) )
    {
        // storage errors aren't allowed by ole-db

        return FALSE;
    }

    return ((sc & 0xFFF00000) == 0x80000000) ||
           (SUCCEEDED(sc) && (sc & 0xFFFFF000) != 0);
} //IsOleError

//+-------------------------------------------------------------------------
//
//  Method:     GetOleError, public
//
//  History:    19-Apr-95 BartoszM     Created
//              26-Apr-95 DwightKr     Converted from method to function
//                                     so that it can be independent from
//                                     the class CException which is now
//                                     part of the C++ run-time package.
//
//--------------------------------------------------------------------------

EXPORTIMP SCODE APINOT GetOleError(CException & e)
{
    NTSTATUS scError = e.GetErrorCode();

    if (IsOleError(scError))
    {
        return scError;
    }
    else if ( ( STATUS_NO_MEMORY == scError ) ||
              ( STATUS_COMMITMENT_LIMIT == scError ) ||
              ( STATUS_INSUFFICIENT_RESOURCES == scError ) ||
              ( HRESULT_FROM_WIN32( ERROR_COMMITMENT_LIMIT ) == scError ) ||
              ( HRESULT_FROM_WIN32( ERROR_NO_SYSTEM_RESOURCES ) == scError ) ||
              ( STG_E_TOOMANYOPENFILES == scError ) ||
              ( STG_E_INSUFFICIENTMEMORY == scError ) )
    {
        return E_OUTOFMEMORY;
    }
    else if ( STATUS_ACCESS_DENIED == scError )
        return E_ACCESSDENIED;
    else if ( STATUS_INVALID_HANDLE == scError )
        return E_HANDLE;
    else if ( STATUS_INVALID_PARAMETER == scError )
        return E_INVALIDARG;
    else
    {
        exDebugOut(( DEB_ITRACE, "GetOleError - mapping %08x to E_FAIL\n", scError));
        return E_FAIL;
    }
}

CException::CException()
    : _lError( HRESULT_FROM_WIN32( GetLastError() ) ),
      _dbgInfo( 0 )
{
} //CException

#if CIDBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   ExceptionReport
//
//  Synopsis:   Outputs Exception messages based on the Win4ExceptionLevel
//              variable. Used by programs compiled with DEBUG defined
//
//  History:    15-Sep-91   KevinRo Created
//
//----------------------------------------------------------------------------

EXPORTIMP void APINOT
ExceptionReport(
    unsigned int iLine,
    char *szFile,
    char *szMsg,
    long lError )
{
# if DBG
    if (Win4ExceptionLevel & EXCEPT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();
        exDebugOut((DEB_FORCE,
                    "%s - line: %u file: %s, thread id %x\n",
                    szMsg, iLine, szFile, tid));
        if (lError != -1)
            exDebugOut((DEB_FORCE,"\terror code 0x%lx\n", lError ));

    }

# endif

    if (Win4ExceptionLevel & EXCEPT_POPUP)
    {
        if(PopUpError(szMsg,iLine,szFile) == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else
    {
        if (Win4ExceptionLevel & EXCEPT_BREAK)
        {
            DebugBreak();
        }
    }
}

#endif  //  CIDBG == 1

//+-------------------------------------------------------------------------
//
//  Setup the runtime package to translate system exceptions (i.e. those
//  usually processed by try / except blocks) into C++ exceptions (those
//  processed by try / catch blocks).  This has no effect on try / except
//  blocks; as they will still continue to see the standard C exception.
//
//  The translation is accomplished by telling the C run-time package to
//  call a user-specified function each time a system exception occurs.  The
//  function translates the exception into a class and rethrows with the
//  class.  If their is a following CATCH block, then the C++ class will
//  be caught.  If there is a following except, then the original system
//  exception will be caught.
//
//--------------------------------------------------------------------------

//
//  Convert system exceptions to a C++ exception.
//

void _cdecl SystemExceptionTranslator( unsigned int uiWhat,
                                       struct _EXCEPTION_POINTERS * pexcept )
{
    //
    // Intentionally don't translate STATUS_PRIVILEGED_INSTRUCTION (see
    // Win4AssertEx for details.
    //

    //
    // In certain situations when a compressed or sparse file is mapped and we
    // run out of disk space the system can throw an in page error instead of
    // the appropriate error
    //
    // Throw the proper exception code so that the error can be handled correctly
    //

    if ( STATUS_IN_PAGE_ERROR == pexcept->ExceptionRecord->ExceptionCode &&
         pexcept->ExceptionRecord->NumberParameters >= 3 )
    {
        exDebugOut(( DEB_WARN, "SystemExceptionTranslator: Received In Page IO Error\n"));
        Win4Assert ( STATUS_IN_PAGE_ERROR == uiWhat );

        if ( STATUS_DISK_FULL == pexcept->ExceptionRecord->ExceptionInformation[2] ||
             STATUS_VOLUME_DISMOUNTED == pexcept->ExceptionRecord->ExceptionInformation[2] ||
             STATUS_INSUFFICIENT_RESOURCES == pexcept->ExceptionRecord->ExceptionInformation[2] )
        {
            exDebugOut(( DEB_WARN, "SystemExceptionTranslator: Translating In Page IO Error to 0x%x\n",
                                     (unsigned int) pexcept->ExceptionRecord->ExceptionInformation[2] ));
            uiWhat = (unsigned int) pexcept->ExceptionRecord->ExceptionInformation[2];
            pexcept->ExceptionRecord->ExceptionCode = (NTSTATUS) pexcept->ExceptionRecord->ExceptionInformation[2];
        }

    }

    #if CIDBG == 1
        if ( ASSRT_STRESSEXCEPTION != uiWhat )
            throw CException( uiWhat ) ;
    #else
        throw CException( uiWhat ) ;
    #endif
} //SystemExceptionTranslator
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\crequest.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       crequest.cxx
//
//  Contents:   Client side of catalog/query requests
//
//  Classes:    CPipeClient
//              CRequestClient
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <query.hxx>
#include <cidbprop.hxx>
#include <sizeser.hxx>
#include <memser.hxx>

DECLARE_INFOLEVEL(prx);

//+-------------------------------------------------------------------------
//
//  Member:     CPipeClient::CPipeClient, protected
//
//  Synopsis:   Simple constructor
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

CPipeClient::CPipeClient() : _hPipe( INVALID_HANDLE_VALUE )
{
} //CPipeClient

//+-------------------------------------------------------------------------
//
//  Member:     CPipeClient::Init, protected
//
//  Synopsis:   Second phase constructor for a client pipe.  The pipe is
//              opened or an exception is thrown.  This method may take
//              awhile to complete depending on the availability of a pipe
//              instance on the server and on the timeout for the pipe as
//              set on the server.
//
//  Arguments:  [pwcMachine] - Name of the server or "." for local machine
//              [pwcPipe]    - Name of the pipe
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CPipeClient::Init(
    WCHAR const * pwcMachine,
    WCHAR const * pwcPipe )
{

#if CI_PIPE_TESTING

    _pTraceBefore = 0;
    _pTraceAfter = 0;
    _hTraceDll = LoadLibraryEx( L"cipipetrace.dll", 0,
                                LOAD_WITH_ALTERED_SEARCH_PATH );

    if ( 0 != _hTraceDll )
    {
        _pTraceBefore = (PipeTraceBeforeCall)
                        GetProcAddress( _hTraceDll, "Before" );
        _pTraceAfter = (PipeTraceAfterCall)
                        GetProcAddress( _hTraceDll, "After" );
    }

#endif // CI_PIPE_TESTING

    RtlZeroMemory( &_overlapped, sizeof _overlapped );
    RtlZeroMemory( &_overlappedWrite, sizeof _overlappedWrite );

    _fServerIsRemote = ( L'.' != pwcMachine[0] );

    WCHAR awcName[ MAX_PATH ];

    unsigned cwc = wcslen( pwcMachine );
    cwc += wcslen( pwcPipe );
    cwc += 20;

    if ( cwc >= ( sizeof awcName / sizeof WCHAR ) )
        THROW( CException( E_INVALIDARG ) );

    wcscpy( awcName, L"\\\\" );
    wcscat( awcName, pwcMachine );
    wcscat( awcName, L"\\pipe\\" );
    wcscat( awcName, pwcPipe );

    #if CIDBG == 1

        WCHAR awcThisUser[ UNLEN ];
        DWORD cbThisUser = sizeof awcThisUser / sizeof WCHAR;
        GetUserName( awcThisUser, &cbThisUser );

        prxDebugOut(( DEB_ITRACE,
                      "connecting tid %d to pipe '%ws' as user '%ws'\n",
                      GetCurrentThreadId(),
                      awcName,
                      awcThisUser ));

    #endif // CIDBG == 1

    do
    {
        // Timeout based on what the server specified if a pipe exists
        // but no instances are available.  Throw if no pipe exists.

        if  ( ! WaitNamedPipe( awcName, NMPWAIT_USE_DEFAULT_WAIT ) )
            QUIETTHROW( CException() );

        // At least one instance was available.  This CreateFile will fail
        // if some other app grabbed the instance before we could.  If so,
        // wait and try again.

        _hPipe = CreateFile( awcName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             0,   // security
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             0 ); // template

        if ( INVALID_HANDLE_VALUE != _hPipe )
        {
            // Local client pipes are always created in byte mode, not
            // message mode, so set the mode to message.

            DWORD dwMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;

            if ( ! SetNamedPipeHandleState( _hPipe, &dwMode, 0, 0 ) )
            {
                HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
                CloseHandle( _hPipe );
                _hPipe = INVALID_HANDLE_VALUE;
                THROW( CException( hr ) );
            }
            break;
        }
        else if ( ERROR_PIPE_BUSY != GetLastError() )
        {
            THROW( CException() );
        }
    } while ( TRUE );

    prxDebugOut(( DEB_ITRACE, "created pipe 0x%x\n", _hPipe ));
} //Init

//+-------------------------------------------------------------------------
//
//  Member:     CPipeClient::Close, protected
//
//  Synopsis:   Closes the pipe if it is open
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CPipeClient::Close()
{
    if ( INVALID_HANDLE_VALUE != _hPipe )
    {
        prxDebugOut(( DEB_ITRACE, "closing pipe: 0x%x\n", _hPipe ));
        BOOL fCloseOk = CloseHandle( _hPipe );
        Win4Assert( fCloseOk );

        _hPipe = INVALID_HANDLE_VALUE;
    }

#if CI_PIPE_TESTING

    if ( 0 != _hTraceDll )
    {
        FreeLibrary( _hTraceDll );
        _hTraceDll = 0;
    }

#endif // CI_PIPE_TESTING

} //Close

//+-------------------------------------------------------------------------
//
//  Function:   HandleClientWriteError
//
//  Synopsis:   Handles error case on pipe write commands
//
//  Arguments:  [hPipe]  -- Pipe on which the operation failed
//
//  Notes:      When it looks like the connection has gone stale, throw
//              STATUS_CONNECTION_DISCONNECTED, so the caller knows to
//              open a new pipe to the server.
//
//  History:    16-May-99   dlee       Created.
//
//--------------------------------------------------------------------------

void HandleClientWriteError( HANDLE hPipe )
{
    //
    // This error state will happen for stale cached ICommands.
    // Alternatively, the handle will be set to INVALID_HANDLE_VALUE by
    // TerminateRudelyNoThrow(), and the pipe will no longer
    // be connected if cisvc went down.
    // Throw a well-known status so we can try to connect again.
    //

    DWORD dwError = GetLastError();

    if ( INVALID_HANDLE_VALUE     == hPipe ||
         ERROR_PIPE_NOT_CONNECTED == dwError ||
         ERROR_BAD_PIPE           == dwError ||
         ERROR_BAD_NET_RESP       == dwError ) // rdr gives this sometimes
        THROW( CException( STATUS_CONNECTION_DISCONNECTED ) );

    THROW( CException() );
} //HandleClientWriteError

//+-------------------------------------------------------------------------
//
//  Member:     CPipeClient::TransactSync, protected
//
//  Synopsis:   Does a synchronous write/read transaction on the pipe.
//
//  Arguments:  [pvWrite]       - Buffer to be written
//              [cbToWrite]     - # of bytes to write
//              [pvRead]        - Buffer for read result
//              [cbReadRequest] - Size of pvRead
//              [cbRead]        - Returns # of bytes read
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CPipeClient::TransactSync(
    void *  pvWrite,
    DWORD   cbToWrite,
    void *  pvRead,
    DWORD   cbReadRequest,
    DWORD & cbRead )
{
    prxDebugOut(( DEB_ITRACE, "xact tid %d on pipe 0x%x\n",
                  GetCurrentThreadId(),
                  _hPipe ));

    //
    // Win32 named pipe operations require buffers < 64k.  If you specify
    // a larger buffer it succeeds without a failure code, but the server
    // never sees the request.  So do an explicit check here to validate
    // the buffer size.
    //

    if ( cbToWrite > 0xffff )
        THROW( CException( E_INVALIDARG ) );

    _overlapped.hEvent = _event.GetHandle();

#if CI_PIPE_TESTING

    void * pvWriteOrg = pvWrite;
    DWORD cbToWriteOrg = cbToWrite;

    if ( 0 != _pTraceBefore )
        (*_pTraceBefore)( _hPipe,
                          cbToWriteOrg,
                          pvWriteOrg,
                          cbToWrite,
                          pvWrite );

#endif // CI_PIPE_TESTING

    if ( ! TransactNamedPipe( _hPipe,
                              pvWrite,
                              cbToWrite,
                              pvRead,
                              cbReadRequest,
                              &cbRead,
                              &_overlapped ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            if ( !GetOverlappedResult( _hPipe,
                                       &_overlapped,
                                       &cbRead,
                                       TRUE ) )
                HandleClientWriteError( _hPipe );
        }
        else
            HandleClientWriteError( _hPipe );
    }

#if CI_PIPE_TESTING

    if ( 0 != _pTraceAfter )
        (*_pTraceAfter)( _hPipe,
                         cbToWriteOrg,
                         pvWriteOrg,
                         cbToWrite,
                         pvWrite,
                         cbRead,
                         pvRead );

#endif // CI_PIPE_TESTING

} //TransactSync

//+-------------------------------------------------------------------------
//
//  Member:     CPipeClient::WriteSync, protected
//
//  Synopsis:   Does a synchronous write to the pipe.
//
//  Arguments:  [pvWrite]       - Buffer to be written
//              [cbToWrite]     - # of bytes to write
//
//  Notes:      When it looks like the connection has gone stale, throw
//              STATUS_CONNECTION_DISCONNECTED, so the caller knows to
//              open a new pipe to the server,.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CPipeClient::WriteSync(
    void * pvWrite,
    DWORD  cbToWrite )
{
    prxDebugOut(( DEB_ITRACE, "writesync tid %d on pipe 0x%x\n",
                  GetCurrentThreadId(),
                  _hPipe ));

    //
    // Win32 named pipe operations require buffers < 64k.  If you specify
    // a larger buffer it succeeds without a failure code, but the server
    // never sees the request.  So do an explicit check here to validate
    // the buffer size.
    //

    if ( cbToWrite > 0xffff )
        THROW( CException( E_INVALIDARG ) );

    _overlappedWrite.hEvent = _eventWrite.GetHandle();
    DWORD cbWritten;

    if ( ! WriteFile( _hPipe,
                      pvWrite,
                      cbToWrite,
                      &cbWritten,
                      &_overlappedWrite ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            if ( !GetOverlappedResult( _hPipe,
                                       &_overlappedWrite,
                                       &cbWritten,
                                       TRUE ) )
                HandleClientWriteError( _hPipe );
        }
        else
            HandleClientWriteError( _hPipe );
    }
} //WriteSync

//+-------------------------------------------------------------------------
//
//  Member:     CPipeClient::ReadSync, protected
//
//  Synopsis:   Does a synchronous from the pipe.
//
//  Arguments:  [pvRead]        - Buffer for read result
//              [cbReadRequest] - Size of pvRead
//              [cbRead]        - Returns # of bytes read
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CPipeClient::ReadSync(
    void *  pvRead,
    DWORD   cbToRead,
    DWORD & cbRead )
{
    prxDebugOut(( DEB_ITRACE, "readsync 1 tid %d on pipe 0x%x\n",
                  GetCurrentThreadId(),
                  _hPipe ));

    _overlapped.hEvent = _event.GetHandle();

    if ( ! ReadFile( _hPipe,
                     pvRead,
                     cbToRead,
                     &cbRead,
                     &_overlapped ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            if ( !GetOverlappedResult( _hPipe,
                                       &_overlapped,
                                       &cbRead,
                                       TRUE ) )
            {
                // If this assert hits, you probably added large notify msg

                Win4Assert( ERROR_MORE_DATA != GetLastError() );
                THROW( CException() );
            }
        }
        else
            THROW( CException() );
    }
} //ReadSync

//+-------------------------------------------------------------------------
//
//  Member:     CPipeClient::ReadSync, protected
//
//  Synopsis:   Does a synchronous read from the pipe, aborting the read
//              if hEvent is signalled before the read is started or
//              completed.
//
//  Arguments:  [pvRead]        - Buffer for read result
//              [cbReadRequest] - Size of pvRead
//              [cbRead]        - Returns # of bytes read
//              [hEvent]        - When signalled, the read is aborted
//
//  Returns:    TRUE if hEvent has been triggered
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

BOOL CPipeClient::ReadSync(
    void *  pvRead,
    DWORD   cbToRead,
    DWORD & cbRead,
    HANDLE  hEvent )
{
    cbRead = 0;

    // Since the read below can complete without going pending,
    // check the terminate event here first.

    if ( 0 == WaitForSingleObject( hEvent, 0 ) )
        return TRUE;

    prxDebugOut(( DEB_ITRACE, "readsync 2 tid %d on pipe 0x%x\n",
                  GetCurrentThreadId(),
                  _hPipe ));

    _overlapped.hEvent = _event.GetHandle();

    if ( ! ReadFile( _hPipe,
                     pvRead,
                     cbToRead,
                     &cbRead,
                     &_overlapped ) )
    {
        if ( ERROR_IO_PENDING == GetLastError() )
        {
            HANDLE ah[2];
            ah[0] = _event.GetHandle();
            ah[1] = hEvent;

            DWORD dw = WaitForMultipleObjects( 2, ah, FALSE, INFINITE );
            Win4Assert( 0 == dw || 1 == dw );

            if ( 0 == dw )
            {
                if ( !GetOverlappedResult( _hPipe,
                                           &_overlapped,
                                           &cbRead,
                                           FALSE ) )
                    THROW( CException() );
            }
            else if ( 1 == dw )
            {
                prxDebugOut(( DEB_ITRACE,
                              "notify thread told to die, cancel i/o\n" ));

                // Cancel the io so that it won't complete on buffers that
                // have been freed.  No check can be made of the return code
                // since the pipe may have been closed by now on the server.

                BOOL fOK = CancelIo( _hPipe );
                prxDebugOut(( DEB_ITRACE, "CancelIo: %d\n", fOK ));
                if ( !fOK ) {
                    prxDebugOut(( DEB_ITRACE, "CancelIo error: %d\n",
                                  GetLastError() ));
                }

                if ( !GetOverlappedResult( _hPipe,
                                           &_overlapped,
                                           &cbRead,
                                           TRUE ) )
                {
                    cbRead = 0;

                    DWORD dw = GetLastError();
                    prxDebugOut(( DEB_ITRACE,
                                  "i/o cancelled, result: %d\n", dw ));
                    // benign assert if hit; I'm is just curious.
                    Win4Assert( ERROR_OPERATION_ABORTED == dw ||
                                ERROR_NO_DATA           == dw );
                }

                return TRUE;
            }
            else THROW( CException() );
        }
        else THROW( CException() );
    }

    return FALSE;
} //ReadSync

//+-------------------------------------------------------------------------
//
//  Function:   TranslateNewPropsToOldProps
//
//  Synopsis:   Translates v 6+ client properties into version 5 props
//
//  Arguments:  [oldProps]    - destination of translated values
//              [newProps]    - source of translated values
//
//  History:    31-May-97   dlee       Created.
//
//--------------------------------------------------------------------------

void TranslateNewPropsToOldProps(
    CDbProperties & oldProps,
    CDbProperties & newProps )
{
    const GUID guidFsClientPropset = DBPROPSET_FSCIFRMWRK_EXT;
    const GUID guidQueryCorePropset = DBPROPSET_CIFRMWRKCORE_EXT;

    // pluck out the catalog and scope information from the new set

    BSTR bstrMachine = 0;
    BSTR bstrCatalog = 0;
    CDynArrayInPlace<LONG> aDepths(2);
    CDynArrayInPlace<BSTR> aScopes(2);
    LONG lQueryType = 0;

    for ( ULONG i = 0; i < newProps.Count(); i++ )
    {
        CDbPropSet & propSet = newProps.GetPropSet( i );
        DBPROPSET *pSet = propSet.CastToStruct();

        if ( guidQueryCorePropset == pSet->guidPropertySet )
        {
            ULONG cProp = pSet->cProperties;
            DBPROP * pProp = pSet->rgProperties;

            for ( ULONG p = 0; p < pSet->cProperties; p++, pProp++ )
            {
                VARIANT &v = pProp->vValue;
                switch ( pProp->dwPropertyID )
                {
                    case DBPROP_MACHINE :
                    {
                        if ( VT_BSTR == v.vt )
                            bstrMachine = v.bstrVal;
                        else if ( ( VT_ARRAY | VT_BSTR ) == v.vt )
                        {
                            ULONG cElem = v.parray->rgsabound[0].cElements;
                            WCHAR **ppMachines = (WCHAR **) v.parray->pvData;

                            if ( 0 != cElem )
                            {
                                // if not 1, it's a bug in higher level code

                                Win4Assert( 1 == cElem );
                                bstrMachine = ppMachines[0];
                            }
                        }
                        break;
                    }
                }
            }
        }
        else if ( guidFsClientPropset == pSet->guidPropertySet )
        {
            ULONG cProp = pSet->cProperties;
            DBPROP * pProp = pSet->rgProperties;

            for ( ULONG p = 0; p < pSet->cProperties; p++, pProp++ )
            {
                VARIANT &v = pProp->vValue;
                prxDebugOut(( DEB_ITRACE, "converting from vt: 0x%x\n", v.vt ));
                switch ( pProp->dwPropertyID )
                {
                    case DBPROP_CI_INCLUDE_SCOPES :
                    {
                        // can be either a BSTR or a safearray of BSTRs

                        if ( VT_BSTR == v.vt )
                        {
                            aScopes[0] = v.bstrVal;
                        }
                        else if ( ( VT_ARRAY | VT_BSTR ) == v.vt )
                        {
                            ULONG cElem = v.parray->rgsabound[0].cElements;
                            WCHAR **ppScopes = (WCHAR **) v.parray->pvData;

                            for ( ULONG e = 0; e < cElem; e++ )
                                aScopes[ e ] = ppScopes[ e ];
                        }
                        break;
                    }
                    case DBPROP_CI_DEPTHS :
                    {
                        // can be either an I4 or an array of I4s

                        if ( VT_I4 == v.vt )
                        {
                            aDepths[0] = v.lVal;
                        }
                        else if ( ( VT_ARRAY | VT_I4 ) == v.vt )
                        {
                            ULONG cElem = v.parray->rgsabound[0].cElements;
                            ULONG *pElem = (ULONG *) v.parray->pvData;
                            for ( ULONG e = 0; e < cElem; e++ )
                                aDepths[ e ] = pElem[ e ];
                        }
                        break;
                    }
                    case DBPROP_CI_CATALOG_NAME :
                    {
                        if ( VT_BSTR == v.vt )
                            bstrCatalog = v.bstrVal;
                        else if ( ( VT_ARRAY | VT_BSTR ) == v.vt )
                        {
                            ULONG cElem = v.parray->rgsabound[0].cElements;
                            WCHAR **ppNames = (WCHAR **) v.parray->pvData;

                            if ( 0 != cElem )
                            {
                                // if not 1, it's a bug in higher level code

                                Win4Assert( 1 == cElem );
                                bstrCatalog = ppNames[0];
                            }
                        }
                        break;
                    }
                    case DBPROP_CI_QUERY_TYPE :
                    {
                        Win4Assert( VT_I4 == v.vt );
                        lQueryType = v.lVal;
                        break;
                    }
                }
            }
        }
    }

    if ( 0 == bstrCatalog ||
         0 == bstrMachine )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    prxDebugOut(( DEB_ITRACE,
                  "Converting new props to old props, catalog '%ws'\n",
                  bstrCatalog ));

    prxDebugOut(( DEB_ITRACE,
                  "type %d, %d scopes, %d depths\n",
                  lQueryType,
                  aScopes.Count(),
                  aDepths.Count() ));

    // create an old set of properties based on the info

    DBPROPSET aNewSet[2];
    DBPROP aFSProps[4];
    RtlZeroMemory( aFSProps, sizeof aFSProps );
    ULONG cNewSet = 2;
    aNewSet[0].cProperties = 2;
    aNewSet[0].guidPropertySet = guidFsClientPropset;
    aNewSet[0].rgProperties = aFSProps;

    aFSProps[0].dwPropertyID = DBPROP_CI_CATALOG_NAME;
    aFSProps[0].vValue.vt = VT_LPWSTR;
    aFSProps[0].vValue.bstrVal = bstrCatalog;
    aFSProps[0].colid.eKind = DBKIND_GUID_PROPID;

    aFSProps[1].dwPropertyID = DBPROP_CI_QUERY_TYPE;
    aFSProps[1].vValue.vt = VT_I4;
    aFSProps[1].vValue.lVal = lQueryType;
    aFSProps[1].colid.eKind = DBKIND_GUID_PROPID;


    if ( 0 != aDepths.Count() )
    {
        aFSProps[cNewSet].dwPropertyID = DBPROP_CI_DEPTHS;
        aFSProps[cNewSet].colid.eKind = DBKIND_GUID_PROPID;
        PROPVARIANT &vDepths = (PROPVARIANT &) aFSProps[cNewSet].vValue;
        cNewSet++;
        vDepths.vt = VT_VECTOR | VT_I4;
        vDepths.cal.cElems = aDepths.Count();
        vDepths.cal.pElems = (LONG *) aDepths.GetPointer();
    }

    if ( 0 != aScopes.Count() )
    {
        aFSProps[cNewSet].dwPropertyID = DBPROP_CI_INCLUDE_SCOPES;
        aFSProps[cNewSet].colid.eKind = DBKIND_GUID_PROPID;
        PROPVARIANT &vScopes = (PROPVARIANT &) aFSProps[cNewSet].vValue;
        cNewSet++;
        vScopes.vt = VT_VECTOR | VT_LPWSTR;
        vScopes.calpwstr.cElems = aScopes.Count();
        vScopes.calpwstr.pElems = (WCHAR **) aScopes.GetPointer();
    }

    aNewSet[0].cProperties = cNewSet;

    DBPROP aQueryProps[1];
    RtlZeroMemory( aQueryProps, sizeof aQueryProps );
    aNewSet[1].cProperties = 1;
    aNewSet[1].guidPropertySet = guidQueryCorePropset;
    aNewSet[1].rgProperties = aQueryProps;

    aQueryProps[0].dwPropertyID = DBPROP_MACHINE;
    aQueryProps[0].vValue.vt = VT_BSTR;
    aQueryProps[0].vValue.bstrVal = bstrMachine;
    aQueryProps[0].colid.eKind = DBKIND_GUID_PROPID;

    SCODE sc = oldProps.SetProperties( 2, aNewSet );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );
} //TranslateNewPropsToOldProps

//+-------------------------------------------------------------------------
//
//  Member:     CRequestClient::CRequestClient, public
//
//  Synopsis:   Constructor for a client request
//
//  Arguments:  [pwcMachine]      - Machine name of server
//              [pDbProperties]   - Client version 6 set of properties
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

CRequestClient::CRequestClient(
    WCHAR const *   pwcMachine,
    IDBProperties * pDbProperties ) :
        _fNotifyOn( FALSE ),
        _fNotifyEverOn( FALSE ),
        _fReadPending( FALSE ),
        _pvDataTemp( 0 ),
        _cbDataTemp( 0 )
{
    WCHAR const * pwcMach = pwcMachine;
    WCHAR const * pwcPipe = CI_PIPE_NAME;
    WCHAR awcMachine[ MAX_PATH + 1 ];

    WCHAR const * pwcColon = wcschr( pwcMachine, L':' );

    if ( 0 != pwcColon )
    {
        unsigned cwc = (unsigned) ( pwcColon - pwcMachine );

        if ( cwc >= MAX_PATH )
            THROW( CException( E_INVALIDARG ) );

        RtlCopyMemory( awcMachine, pwcMachine, sizeof( WCHAR ) * cwc );

        awcMachine[ cwc ] = 0;
        pwcMach = awcMachine;
        pwcPipe = pwcColon + 1;
    }

    Init( pwcMach, pwcPipe );

    // Send the pmConnect message to the server.  For logging and
    // debugging, send the machine and username with the message.

    WCHAR awcThisMachine[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD cwcThisMachine = sizeof awcThisMachine / sizeof WCHAR;
    if ( !GetComputerName( awcThisMachine, &cwcThisMachine ) )
        THROW( CException() );

    WCHAR awcThisUser[ UNLEN + 1 ];
    DWORD cwcThisUser = sizeof awcThisUser / sizeof WCHAR;
    if ( !GetUserName( awcThisUser, &cwcThisUser ) )
        THROW( CException() );

    Win4Assert( 0 != pDbProperties );

    //
    // We know that the IDbProperties is implemented by CDbProperties.
    //
    CDbProperties & dbp2 = *((CDbProperties *) pDbProperties);

    // Make and marshall v5 properties

    XInterface<CDbProperties> xdbp( new CDbProperties() );
    if ( xdbp.IsNull() )
        THROW( CException( E_OUTOFMEMORY ) );
    TranslateNewPropsToOldProps( xdbp.GetReference(), dbp2 );

    CSizeSerStream ssSize;
    xdbp->Marshall( ssSize );
    ULONG cbProps = ssSize.Size();

    //
    // Compute the size of the dbproperties to be sent.
    // The DBPROPSET_ROWSET properties aren't used on the server side in
    // this form -- it's a waste to marshall/unmarshall 0x27 properties
    // for no good reason.  The rowset props we care about are sent in
    // a compressed form when a query is issued.
    //

    CSizeSerStream ssSize2;
    GUID guidRowsetProp = DBPROPSET_ROWSET;
    dbp2.Marshall( ssSize2, 1, &guidRowsetProp );
    ULONG cbProps2 = ssSize2.Size();

    prxDebugOut(( DEB_ITRACE, "cb old props %d, cb new props: %d\n",
                  cbProps, cbProps2 ));

    DWORD cbRequest = CPMConnectIn::SizeOf( awcThisMachine,
                                            awcThisUser,
                                            cbProps,
                                            cbProps2 );
    XArray<BYTE> xRequest( cbRequest );
    CPMConnectIn *pRequest = new( xRequest.Get() )
                             CPMConnectIn( awcThisMachine,
                                           awcThisUser,
                                           IsServerRemote(),
                                           cbProps,
                                           cbProps2 );

    //
    // Serialize the DbProperties.
    //

    BYTE * pb = pRequest->GetBlobStartAddr();
    CMemSerStream ss( pb, cbProps );
    xdbp->Marshall( ss );

    BYTE * pb2 = pRequest->GetBlob2StartAddr();
    CMemSerStream ss2( pb2, cbProps2 );
    dbp2.Marshall( ss2, 1, &guidRowsetProp );

    pRequest->SetCheckSum( cbRequest );

    CPMConnectOut reply;
    DWORD cbReply;
    DataWriteRead( pRequest,
                   cbRequest,
                   &reply,
                   sizeof reply,
                   cbReply );
    Win4Assert( sizeof reply == cbReply );

    _ServerVersion = reply.ServerVersion();
} //CRequestClient

//+-------------------------------------------------------------------------
//
//  Member:     CRequestClient::Disconnect, public
//
//  Synopsis:   Sends a disconnect message to the server, which will then
//              do a Win32 disconnect from the pipe.  After this call, the
//              pipe handle can only be closed.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestClient::Disconnect()
{
    CProxyMessage request( pmDisconnect );
    DataWrite( &request, sizeof request );
} //Disconnect

//+-------------------------------------------------------------------------
//
//  Member:     CRequestClient::EnableNotify, public
//
//  Synopsis:   Tells the class that the notify thread will be doing reads
//              for data threads.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestClient::EnableNotify()
{
    CLock lock( _mutex );
    prxDebugOut(( DEB_ITRACE, "enable notify\n" ));

    Win4Assert( !_fNotifyOn );
    _fNotifyOn = TRUE;
    _fNotifyEverOn = TRUE;
    prxDebugOut(( DEB_ITRACE, "enabled notify\n" ));
} //EnableNotify

//+-------------------------------------------------------------------------
//
//  Member:     CRequestClient::DisableNotify, public
//
//  Synopsis:   Tells the class that the notify thread is busy so
//              data threads should wait for themselves.
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestClient::DisableNotify()
{
    CReleasableLock lock( _mutex );
    prxDebugOut(( DEB_ITRACE, "disable notify\n" ));

    Win4Assert( _fNotifyOn );

    // If a read is pending for the notify thread to complete,
    // wake the data thread up so it can wait for itself.

    _fNotifyOn = FALSE;

    if ( _fReadPending )
    {
        _pvDataTemp = 0;
        _eventData.Set();
        lock.Release();
        _eventDataDone.Wait();
    }
    prxDebugOut(( DEB_ITRACE, "disabled notify\n" ));
} //DisableNotify

//+-------------------------------------------------------------------------
//
//  Member:     CRequestClient::DataWrite, public
//
//  Synopsis:   Writes data to the pipe
//
//  Arguments:  [pvWrite] - pointer to the buffer to be written
//              [cbWrite] - # of bytes to write
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestClient::DataWrite(
    void * pvWrite,
    DWORD  cbWrite )
{
    CLock lockData( _mutexData );
    CLock lock( _mutex );

    WriteSync( pvWrite, cbWrite );
} //DataWrite

//+-------------------------------------------------------------------------
//
//  Member:     CRequestClient::DataWriteRead, public
//
//  Synopsis:   Does a data (non-notification) write/read transaction with
//              the server.
//
//  Arguments:  [pvWrite]       - Buffer to be written
//              [cbToWrite]     - # of bytes to write
//              [pvRead]        - Buffer for read result
//              [cbReadRequest] - Size of pvRead
//              [cbRead]        - Returns # of bytes read
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

void CRequestClient::DataWriteRead(
    void *  pvWrite,
    DWORD   cbWrite,
    void *  pvRead,
    DWORD   cbToRead,
    DWORD & cbRead )
{
    int ExpectedMsg = ((CProxyMessage *)pvWrite)->GetMessage();
    prxDebugOut(( DEB_ITRACE, "DataWriteRead msg %d, cb %d\n",
                                         ExpectedMsg, cbWrite ));

    CLock lockData( _mutexData );
    CReleasableLock lock( _mutex );

    if ( _fNotifyOn )
    {
        WriteSync( pvWrite, cbWrite );

        _fReadPending = TRUE;
        lock.Release();
        _eventData.Wait();
        _fReadPending = FALSE;

        prxDebugOut(( DEB_ITRACE,
                      "dwr eventdata triggered, _pvDataTemp: 0x%lx\n",
                      _pvDataTemp ));

        // set this event when we fall out of scope

        CEventSetter setter( _eventDataDone );

        if ( 0 == _pvDataTemp )
        {
            // we can wait ourselves

            lock.Request();
            ReadSync( pvRead, cbToRead, cbRead );
            prxDebugOut(( DEB_ITRACE, "dwr done, this, cb: %d\n", cbRead ));
        }
        else
        {
            // notify thread completed the read for us

            Win4Assert( _cbDataTemp <= cbToRead );
            RtlCopyMemory( pvRead, _pvDataTemp, _cbDataTemp );
            cbRead = _cbDataTemp;
            prxDebugOut(( DEB_ITRACE, "dwr done, other, cb: %d\n", cbRead ));
        }
    }
    else
    {
        if ( _fNotifyEverOn )
        {
            // Spurious notify messages prohibit use of TransactSync.  Use
            // an individual Write, then Read until the appropriate msg is
            // found, throwing away unwanted notification messages.

            WriteSync( pvWrite, cbWrite );

            do
            {
                // Some notification messages are larger than what we might
                // be reading here, so we may need to use a temporary buffer.

                void * pvReadBuffer = pvRead;
                DWORD cbReadBuffer = cbToRead;

                // CPMRatioFinishedOut is the largest notification msg.
                // Change this code if you add a larger notification message.

                Win4Assert( sizeof CPMRatioFinishedOut >=
                            sizeof CPMSendNotifyOut );
                CPMRatioFinishedOut pmTmp;

                if ( cbToRead < sizeof pmTmp )
                {
                    pvReadBuffer = &pmTmp;
                    cbReadBuffer = sizeof pmTmp;
                }

                ReadSync( pvReadBuffer, cbReadBuffer, cbRead );
                int msg = ((CProxyMessage *) pvReadBuffer)->GetMessage();

                prxDebugOut(( DEB_ITRACE, "dwr done, msg %d cb: %d\n",
                              msg, cbRead ));

                if ( ExpectedMsg == msg )
                {
                    // Copy from the temporary buffer if it was used.

                    if ( pvReadBuffer != pvRead )
                    {
                        // Normal case and error case...

                        Win4Assert( cbToRead <= cbRead ||
                                    sizeof CProxyMessage == cbRead );

                        RtlCopyMemory( pvRead, pvReadBuffer, cbRead );
                    }

                    break;
                }

                prxDebugOut(( DEB_WARN,
                              "dwr tossing spurious notify msg %d cb: %d\n",
                              msg, cbRead ));
            } while ( TRUE );
        }
        else
        {
            TransactSync( pvWrite, cbWrite, pvRead, cbToRead, cbRead );
        }
    }

    CProxyMessage &reply = * (CProxyMessage *) pvRead;

    // If the message returned a failure code, throw it.

    if ( ! SUCCEEDED( reply.GetStatus() ) )
        QUIETTHROW( CException( reply.GetStatus() ) );
} //DataWriteRead

//+-------------------------------------------------------------------------
//
//  Member:     CRequestClient::NotifyWriteRead, public
//
//  Synopsis:   Does a notification (non-data) write/read transaction with
//              the server.  If the read is a message destined for another'
//              thread, notify the thread that data is available and wait
//              for another message.
//
//  Arguments:  [hStopNotify] - if signalled, read is cancelled
//              [pvWrite]     - Buffer to be written
//              [cbWrite]     - # of bytes to write
//              [pvRead]      - Buffer for read result
//              [cbBuffer]    - Size of pvRead
//              [cbRead]      - Returns # of bytes read
//
//  Returns:    TRUE if hStopNotify was signalled, FALSE otherwise
//
//  Notes:      This function knows about pmGetNotify and pmSendNotify
//
//  History:    16-Sep-96   dlee       Created.
//
//--------------------------------------------------------------------------

BOOL CRequestClient::NotifyWriteRead(
    HANDLE  hStopNotify,
    void *  pvWrite,
    DWORD   cbWrite,
    void *  pvRead,
    DWORD   cbBuffer,
    DWORD & cbRead )
{
    // First check if we are shutting down the query

    if ( 0 == WaitForSingleObject( hStopNotify, 0 ) )
        return TRUE;

    // ensure notifications are disabled by the time we exit scope

    Win4Assert( !_fNotifyOn );
    CEnableNotify enable( *this );
    Win4Assert( _fNotifyOn );

    // If a pmGetNotify is sent and the reply is pmGetNotify, it means that
    // notifications aren't available yet and a pmSendNotify will come later.
    // If a pmSendNotify is replied, notifications were available.

    int ExpectedMsg = ((CProxyMessage *)pvWrite)->GetMessage();
    if ( pmGetNotify == ExpectedMsg )
        ExpectedMsg = pmSendNotify;

    {
        CLock lock( _mutex );
        WriteSync( pvWrite, cbWrite );
    }

    do
    {
        BYTE abBuf[ cbMaxProxyBuffer ];
        cbRead = 0;
        BOOL fStopNotify = ReadSync( abBuf,
                                     sizeof abBuf,
                                     cbRead,
                                     hStopNotify );

        // If we got any data, process the data even if "stop notify" is
        // true, since we don't want to leave the data thread stranded.

        if ( 0 != cbRead )
        {
            CProxyMessage &msg = * (CProxyMessage *) abBuf;

            prxDebugOut(( DEB_ITRACE,
                          "NotifyWriteRead complete cb %d, msg %d\n",
                          cbRead,
                          msg.GetMessage() ));

            // If the pmGetNotify came back, loop around and wait for
            // a real notification or a message intended for a data thread.

            if ( pmGetNotify == msg.GetMessage() )
            {
                if ( ! SUCCEEDED( msg.GetStatus() ) )
                    THROW( CException( msg.GetStatus() ) );
            }
            else
            {
                // If this is a notification, return so the client can be
                // advised, then this function will be re-entered.

                if ( msg.GetMessage() == ExpectedMsg )
                {
                    CProxyMessage &reply = * (CProxyMessage *) pvRead;

                    if ( ! SUCCEEDED( msg.GetStatus() ) )
                        THROW( CException( msg.GetStatus() ) );

                    Win4Assert( cbRead <= cbBuffer );
                    RtlCopyMemory( pvRead, abBuf, cbRead );
                    return fStopNotify;
                }

                // Tell the thread waiting for data that it's available.
                // That thread can throw if the status is failure.

                _pvDataTemp = abBuf;
                _cbDataTemp = cbRead;

                _eventData.Set();
                _eventDataDone.Wait();
            }
        }

        if ( fStopNotify )
            return TRUE;
    } while ( TRUE );

    return FALSE;
} //NotifyWriteRead
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//              w4vprintf
//              w4dprintf
//              w4vdprintf
//              
//  History:    18-Oct-91   vich        Created
//      
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

int _cdecl w4printf(const char *format, ...);
int _cdecl w4vprintf(const char *format, va_list arglist);

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\falloc.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       falloc.cxx
//
//  Contents:   Fast allocator that sits on top of HeapAlloc for
//              better size and performance on small allocations.
//
//  History:    15-Mar-96   dlee       Created.
//
//  Notes:      No header/tail checking is done in this allocator.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "falloc.hxx"

#pragma optimize( "t", on )

extern HANDLE gmem_hHeap;

// any allocation larger than this isn't specially handled

const USHORT cbMaxFalloc = 256;

// allows more than 150 meg of allocations of less than cbMaxFalloc.

const ULONG cMaxPages = 2048;

// size of first page for each allocation granularity

const ULONG cbFirstPage = 2048; //1024;

#if CIDBG==1 || DBG==1

    DECLARE_DEBUG( fal );
    DECLARE_INFOLEVEL( fal );
    #define falDebugOut(x) falInlineDebugOut x

    const int fillFastAlloc = 0xda;
    const int fillListAlloc = 0xdb;
    const int fillFree      = 0xdc;
    const int fillBigAlloc  = 0xdd;
    const int fillBigFree   = 0xde;

    void memPrintMemoryChains();

    // Define this to keep track of the amount of non-specially-handled
    // memory allocated.  Should be turned off for a retail build.

    #define FALLOC_TRACK_NOTINPAGE

#endif // CIDBG==1 || DBG==1

CMemMutex gmem_mutex;

static inline void EnterMemSection()
{
    gmem_mutex.Enter();
}

static inline void LeaveMemSection()
{
    gmem_mutex.Leave();
}

//+---------------------------------------------------------------------------
//
//  Class:      CPageHeader
//
//  Purpose:    Each page allocated has one of these objects at its start.
//              Pages aren't necessarily the system page size.
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

class CPageHeader
{
public:

    void Init( ULONG cbChunk, UINT cbPage )
    {
        _cbChunk = (USHORT) cbChunk;
        _pcFreeList = 0;
        _cbFree = cbPage - sizeof CPageHeader;
        _cAlloced = 0;
        _pcEndPlusOne = ( (char *) this ) + cbPage;
        _pphPrev = 0;
    }

#if CIDBG==1 || DBG==1
    void CheckFreeList() const
    {
        // validate the free list head; look for heap trashing

        ciAssert( _pcFreeList < _pcEndPlusOne );

        if ( 0 == _pcFreeList )
            return;

        UINT_PTR ulBase = (UINT_PTR) (this + 1);
        UINT_PTR ulFreeList = (UINT_PTR) _pcFreeList;
        ciAssert( ulFreeList >= ulBase );

        // freelist pointers are from the start of each chunk

        UINT_PTR ulDiff = ulFreeList - ulBase;
        ciAssert( 0 == ( ulDiff % _cbChunk ) );
    }
#endif // CIDBG==1 || DBG==1

    void * FastAlloc()
    {
        // allocates memory from beyond the end of currently allocated space

        #if CIDBG==1 || DBG==1
            ciAssert(( _cbChunk <= cbMaxFalloc ));
            ciAssert(( _cbFree >= _cbChunk ));
            ciAssert(( _cAlloced < 65535 ));
        #endif // CIDBG==1 || DBG==1

        void *pv = _pcEndPlusOne - _cbFree;
        _cbFree -= _cbChunk;
        _cAlloced++;

        #if CIDBG==1 || DBG==1
            ciAssert( IsInPage( pv ) );
            RtlFillMemory( pv, _cbChunk, fillFastAlloc );
        #endif // CIDBG==1 || DBG==1

        return pv;
    }

    void * FreeListAlloc()
    {
        // allocates memory from the freelist

        #if CIDBG==1 || DBG==1
            ciAssert(( _cAlloced < 65535 )); // overflow?
            CheckFreeList();
        #endif // CIDBG==1 || DBG==1

        _cAlloced++;
        void *pv = _pcFreeList;
        _pcFreeList = * ( (char **) pv );

        #if CIDBG==1 || DBG==1
            ciAssert(( ( 0 == _pcFreeList ) ||
                         ( _pcFreeList > (char *) this ) ));
            ciAssert( IsInPage( pv ) );
            CheckFreeList();
            RtlFillMemory( pv, _cbChunk, fillListAlloc );
        #endif // CIDBG==1 || DBG==1

        return pv;
    }

    void Free( void * pv )
    {
        #if CIDBG==1 || DBG==1
            ciAssert(( GetChunkSize() <= cbMaxFalloc ));
            ciAssert(( IsInPage( pv ) ));
            ciAssert( 0 != _cAlloced );
            CheckFreeList();
        #endif // CIDBG==1 || DBG==1

        // put the block at the front of the page's freelist

        ( * (char **) pv ) = _pcFreeList;
        _pcFreeList = (char *) pv;
        _cAlloced--;

        #if CIDBG==1 || DBG==1
            CheckFreeList();
        #endif // CIDBG==1 || DBG==1
    }

    BOOL IsValidPointer( const void * pv ) const
    {
        #if CIDBG==1 || DBG==1
            CheckFreeList();
        #endif // CIDBG==1 || DBG==1

        void * pvBase = (void *) (this + 1);
        UINT_PTR diff = (UINT_PTR) ( (char *) pv - (char *) pvBase );
        UINT_PTR mod = diff % _cbChunk;

        #if CIDBG==1 || DBG==1
            if ( 0 != mod )
            {
                falDebugOut(( DEB_WARN,
                              "Invalid small pointer: 0x%x\n", pv ));
                ciAssert( !"Invalid small pointer" );
            }
        #endif // CIDBG==1 || DBG==1

        return ( 0 == mod );
    }

    BOOL IsInPage( void * pv )
    {
        return ( ( pv >= (char *) this ) &&
                 ( pv < _pcEndPlusOne ) );
    }

    ULONG Size() { return (ULONG) ( _pcEndPlusOne - (char *) this ); }

    char * GetEndPlusOne() { return _pcEndPlusOne; }
    char * GetFreeList() { return _pcFreeList; }

    void SetNext( CPageHeader * p ) { _pphNext = p; }
    CPageHeader * Next() { return _pphNext; }

    void SetPrev( CPageHeader * p ) { _pphPrev = p; }
    CPageHeader * Prev() { return _pphPrev; }

    ULONG GetFreeSize() { return _cbFree; }

    ULONG GetAlloced() { return _cAlloced; }
    BOOL IsPageEmpty() { return 0 == _cAlloced; }

    ULONG GetChunkSize() { return _cbChunk; }

private:

    char *        _pcEndPlusOne; // one byte past the end of this page
    char *        _pcFreeList;   // first element in the free list

    CPageHeader * _pphNext;      // next page of the same chunk size
    CPageHeader * _pphPrev;      // previous page of the same chunk size

    ULONG         _cbFree;       // # bytes free and not in free list

    USHORT        _cAlloced;     // allows for maximum of 256k page size
    USHORT        _cbChunk;      // size of allocations in this page
};

#ifdef FALLOC_TRACK_NOTINPAGE
LONG          gmem_cbNotInPages = 0;
LONG          gmem_cbPeakNotInPages = 0;
#endif //FALLOC_TRACK_NOTINPAGE

// # of pages currently allocated
UINT          gmem_cPages = 0;

// peak # of bytes allocated at once
ULONG         gmem_cbPeakUsage = 0;

// current # of bytes allocated
ULONG         gmem_cbCurrentUsage = 0;

// array of pointers to pages for each allocation size, the first of
// which is the best place to look for an allocation.
CPageHeader * gmem_aHints[ cbMaxFalloc / cbMemAlignment ];

// array of all pages allocated, sorted by address
CPageHeader * gmem_aPages[ cMaxPages ];

//+---------------------------------------------------------------------------
//
//  Function:   SizeToHint
//
//  Synopsis:   Translates a memory allocation size to an index in the
//              hint array.  If alignment is 8, any allocation of size 1
//              to 8 is in hint 0, size 9 to 16 is hint 1, etc.
//
//  Arguments:  [cb] -- size of the allocation
//
//  Returns:    The hint
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

static inline ULONG SizeToHint( ULONG cb )
{
    ciAssert(( cb <= cbMaxFalloc ));
    ciAssert(( cb >= cbMemAlignment ));

    return ( cb / cbMemAlignment ) - 1;
} //SizeToHint

//+---------------------------------------------------------------------------
//
//  Function:   ReallyAllocate
//
//  Synopsis:   Calls the real memory allocator.
//
//  Arguments:  [cb] -- size of the allocation
//
//  Returns:    The pointer or 0 on failure
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

static inline void *ReallyAllocate( UINT cb )
{
    return (void *) HeapAlloc( gmem_hHeap, 0, cb );
} //ReallyAllocate

//+---------------------------------------------------------------------------
//
//  Function:   ReallyFree
//
//  Synopsis:   Frees memory
//
//  Arguments:  [pv] -- pointer to free
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

static inline void ReallyFree( void * pv )
{

    #if CIDBG==1 || DBG==1

        if ( !HeapFree( gmem_hHeap, 0, pv ) )
            ciAssert(!"Bad ptr for operator delete => LocalFree");

    #else // CIDBG==1 || DBG==1

        HeapFree( gmem_hHeap, 0, pv );

    #endif // CIDBG==1 || DBG==1

} //ReallyFree

static inline BOOL ReallyIsValidPointer( const void * pv )
{
    BOOL fOK = ( -1 != HeapSize( gmem_hHeap, 0, pv ) );

    #if CIDBG==1 || DBG==1

        if ( !fOK )
            ciAssert( !"Invalid Pointer Detected" );

    #endif // CIDBG==1 || DBG==1

    return fOK;
} //ReallyIsValidPointer

//+---------------------------------------------------------------------------
//
//  Function:   ReallyGetSize
//
//  Synopsis:   Returns the size of an allocation
//
//  Arguments:  [pv] -- pointer to allocated memory
//
//  Returns:    Size of the allocation
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

static inline UINT ReallyGetSize( void const * pv )
{
    return (UINT)HeapSize( gmem_hHeap, 0, pv );
} //ReallyGetSize

//+---------------------------------------------------------------------------
//
//  Function:   memFindPageIndex
//
//  Synopsis:   Finds the page in which a pointer might reside or where
//              a new page would be inserted.
//
//  Arguments:  [pv] -- pointer to use for the search
//
//  Returns:    The page number in which the page either resides or would
//              reside (if doing an insertion).
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

inline ULONG memFindPageIndex( const void * pv )
{
    ULONG cPages = gmem_cPages;
    ULONG iHi = cPages - 1;
    ULONG iLo = 0;

    // do a binary search looking for the page

    do
    {
        ULONG cHalf = cPages / 2;

        if ( 0 != cHalf )
        {
            ULONG cTmp = cHalf - 1 + ( cPages & 1 );
            ULONG iMid = iLo + cTmp;

            CPageHeader *page = gmem_aPages[ iMid ];

            if ( page > pv )
            {
                iHi = iMid - 1;
                cPages = cTmp;
            }
            else if ( page->GetEndPlusOne() <= pv )
            {
                iLo = iMid + 1;
                cPages = cHalf;
            }
            else
            {
                return iMid;
            }
        }
        else if ( 0 != cPages )
        {
            if ( ( gmem_aPages[ iLo ]->GetEndPlusOne() ) > pv )
                return iLo;
            else
                return iLo + 1;
        }
        else return iLo;
    }
    while ( TRUE );

    ciAssert(( ! "Invalid memFindPageIndex function exit point" ));
    return 0;
} //memFindPageIndex

//+---------------------------------------------------------------------------
//
//  Function:   AdjustPageSize
//
//  Synopsis:   Picks a page size for an allocation of a certain size base
//              on the allocation usage so far.
//
//  Arguments:  [cbAtLeast] -- the page must be at least this large.
//              [cbChunk]   -- size of the allocation.
//
//  Returns:    The recommended page size for a new page of allocations of
//              size cbChunk.
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

static inline ULONG AdjustPageSize(
    UINT   cbAtLeast,
    USHORT cbChunk )
{
    ciAssert(( cbChunk <= cbMaxFalloc ));

    UINT cPages = 0;
    CPageHeader * p = gmem_aHints[ SizeToHint( cbChunk ) ];

    while ( 0 != p )
    {
        cPages++;
        p = p->Next();
    }

    UINT cbPage;

    if ( 0 == cPages )
        cbPage = cbFirstPage;
    else if ( cPages < 4 )
        cbPage = 4096;
    else if ( cPages < 16 )
        cbPage = 8192;
    else if ( cPages < 200 )
        cbPage = 16384;
    else if ( cPages < 256 )
        cbPage = 32768;
    else
        cbPage = 65536;

    return __max( cbAtLeast, cbPage );
} //AdjustPageSize

//+---------------------------------------------------------------------------
//
//  Function:   memAddPage
//
//  Synopsis:   Allocates and adds a page to the list of pages
//
//  Arguments:  [cbPage]  -- the page must be at least this large.
//              [cbChunk] -- size of each allocation in the page.
//
//  Returns:    pointer to the page
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

CPageHeader * memAddPage(
    UINT  cbPage,
    ULONG cbChunk )
{
    ciAssert(( cbChunk <= cbMaxFalloc ));
    ciAssert(( gmem_cPages < ( cMaxPages - 1 ) ));

    // first-pass initializations for the allocator

    if ( 0 == gmem_cbPeakUsage )
    {
        RtlZeroMemory( gmem_aHints, sizeof gmem_aHints );
        RtlZeroMemory( gmem_aPages, sizeof gmem_aPages );
    }

    void * pvPage = ReallyAllocate( cbPage );

    // fail out-of-memory gracefully

    if ( 0 == pvPage )
        return 0;

    gmem_cbCurrentUsage += cbPage;
    gmem_cbPeakUsage = __max( gmem_cbPeakUsage, gmem_cbCurrentUsage );

    CPageHeader * page = (CPageHeader *) pvPage;

    ULONG iPage;

    if ( 0 == gmem_cPages )
        iPage = 0;
    else
    {
        iPage = memFindPageIndex( page );

        ciAssert(( iPage <= gmem_cPages ));

        // the pages are kept in order of address, so shift elements
        // down to make room if necessary.

        if ( iPage < gmem_cPages )
            RtlMoveMemory( & ( gmem_aPages[ iPage + 1 ] ),
                           & ( gmem_aPages[ iPage ] ),
                           ( sizeof(void *) ) * ( gmem_cPages - iPage ) );
    }

    // add the new page

    gmem_aPages[ iPage ] = page;
    gmem_cPages++;

    page->Init( cbChunk, cbPage );

    ULONG iHint = SizeToHint( cbChunk );
    CPageHeader *pOriginal = gmem_aHints[ iHint ];
    gmem_aHints[ iHint ] = page;
    page->SetNext( pOriginal );
    if ( 0 != pOriginal )
        pOriginal->SetPrev( page );

    #if CIDBG==1 || DBG==1

        // make sure the pages really are sorted

        if ( gmem_cPages >= 2 )
            for ( ULONG x = 0; x < gmem_cPages - 1; x++ )
                ciAssert(( gmem_aPages[ x ] < gmem_aPages[ x + 1 ] ));

    #endif // CIDBG==1 || DBG==1

    return page;
} //memAddPage

//+---------------------------------------------------------------------------
//
//  Function:   memDeletePage
//
//  Synopsis:   Deletes a page from the list of pages
//
//  Arguments:  [index]  -- index of the page to be deleted.
//              [page]   -- pointer to the page to be deleted.
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

void memDeletePage(
    ULONG         index,
    CPageHeader * page )
{
    ciAssert(( index < gmem_cPages ));

    // leave the first page around -- it's small and cheap

    if ( page->Size() == cbFirstPage )
        return;

    // remove the page from the hint array

    ULONG iHint = SizeToHint( page->GetChunkSize() );

    if ( gmem_aHints[ iHint ] == page )
    {
        // it's the first element in the hint linked list

        gmem_aHints[ iHint ] = page->Next();
        if ( 0 != page->Next() )
            page->Next()->SetPrev( 0 );
    }
    else
    {
        // it's somewhere in the list of hints

        ciAssert(( 0 != page->Prev() ));

        page->Prev()->SetNext( page->Next() );
        if ( 0 != page->Next() )
            page->Next()->SetPrev( page->Prev() );
    }

    gmem_cPages--;

    if ( index < gmem_cPages )
        RtlMoveMemory( & ( gmem_aPages[ index ] ),
                       & ( gmem_aPages[ index + 1 ] ),
                       (sizeof( void * )) * ( gmem_cPages - index ) );

    gmem_cbCurrentUsage -= page->Size();

    #if CIDBG==1 || DBG==1

        // make sure the pages really are sorted

        if ( gmem_cPages >= 2 )
            for ( ULONG x = 0; x < gmem_cPages - 1; x++ )
                ciAssert(( gmem_aPages[ x ] < gmem_aPages[ x + 1 ] ));

    #endif // CIDBG==1 || DBG==1

    ReallyFree( page );
} //memDeletePage

//+---------------------------------------------------------------------------
//
//  Function:   memAlloc
//
//  Synopsis:   Allocates a piece of memory.  This code should never raise
//              in any circumstance other than memory corruption.
//
//  Arguments:  [cbAlloc]  -- # of bytes to allocate
//
//  Returns:    pointer to the memory or 0 if failed
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

void * memAlloc( UINT cbAlloc)
{
    // 0 sized allocations are ok in C++ and must return unique pointers
    // Align all allocations.
    // Do this work here, where it is not under lock

    if ( 0 != cbAlloc )
        cbAlloc = memAlignBlock( cbAlloc );
    else
        cbAlloc = cbMemAlignment;

    // can we special-case this allocation?

    if ( cbAlloc <= cbMaxFalloc )
    {
        // try the hint page first

        ULONG iHint = SizeToHint( cbAlloc );

        EnterMemSection();

        CPageHeader *page = gmem_aHints[ iHint ];

        if ( 0 != page )
        {
            // most typical case is re-use of memory

            if ( 0 != page->GetFreeList() )
            {
                void *pv = page->FreeListAlloc();
                LeaveMemSection();
                return pv;
            }

            // next most typical case is first-time allocation

            if ( cbAlloc <= page->GetFreeSize() )
            {
                void *pv = page->FastAlloc();
                LeaveMemSection();
                return pv;
            }

            // otherwise look for a page with a freelist entry

            page = page->Next();

            while ( 0 != page )
            {
                ciAssert(( cbAlloc == page->GetChunkSize() ));

                // if this weren't true, why isn't the page a hint?

                ciAssert(( cbAlloc > page->GetFreeSize() ));

                if ( 0 != page->GetFreeList() )
                {
                    // try to make the hint be a page with free entries.
                    // this is about a 5% speedup when a lot is allocated.

                    CPageHeader *ptmp = gmem_aHints[ iHint ];

                    if ( page != ptmp )
                    {
                        page->Prev()->SetNext( page->Next() );
                        if ( 0 != page->Next() )
                            page->Next()->SetPrev( page->Prev() );

                        page->SetPrev( 0 );
                        page->SetNext( ptmp );
                        ptmp->SetPrev( page );

                        gmem_aHints[ iHint ] = page;
                    }

                    void *pv = page->FreeListAlloc();
                    LeaveMemSection();
                    return pv;
                }

                page = page->Next();
            }
        }

        // New page is needed

        ciAssert(( 0 == page ));

        if ( gmem_cPages < cMaxPages )
        {
            page = memAddPage( AdjustPageSize( cbAlloc + sizeof CPageHeader,
                                               (USHORT)cbAlloc ),
                               cbAlloc );

            void *pv = 0;

            if ( 0 != page )
                pv = page->FastAlloc();

            LeaveMemSection();
            return pv;
        }

        // wow.  More than 150+ meg of allocations less than 256 bytes.
        // Just call the real allocator (after asserting)

        ciAssert(( !"bug? why did we allocate so much memory?" ));
        LeaveMemSection();
    }

    // just allocate a block and be done with it.

    void *pv = ReallyAllocate( cbAlloc );

    #ifdef FALLOC_TRACK_NOTINPAGE
        if ( 0 != pv )
        {
            InterlockedExchangeAdd( &gmem_cbNotInPages,
                                    (LONG) ReallyGetSize( pv ) );
            if ( gmem_cbNotInPages > gmem_cbPeakNotInPages )
                gmem_cbPeakNotInPages = gmem_cbNotInPages;
        }
    #endif //FALLOC_TRACK_NOTINPAGE

    #if CIDBG==1 || DBG==1
        if ( 0 != pv )
            RtlFillMemory( pv, cbAlloc, fillBigAlloc );
    #endif // CIDBG==1 || DBG==1

    return pv;
} //memAlloc

//+---------------------------------------------------------------------------
//
//  Function:   memFree
//
//  Synopsis:   Frees memory
//
//  Arguments:  [pv]  -- pointer to free
//
//  History:    15-Mar-96   dlee       Created.
//
//----------------------------------------------------------------------------

void memFree( void * pv )
{
    // ciDelete does this check

    ciAssert( 0 != pv );

    {
        EnterMemSection();

        ULONG index = memFindPageIndex( pv );

        // The page is either in the array of tiny allocation pages
        // or not in the array and is a stand-alone allocation.

        if ( index < gmem_cPages )
        {
            CPageHeader * page = gmem_aPages[ index ];

            // metadata at head of page prevents this

            ciAssert(( pv != page ));

            // it's sufficient to check just the start of the page since if
            // pv were greater than the end of the page the next index
            // would have been returned from the memFindPageIndex() call

            if ( pv > page )
            {
                ciAssert(( pv >= ( (char *) page + ( sizeof CPageHeader ) ) ));
                ciAssert(( pv < page->GetEndPlusOne() ));

                #if CIDBG==1 || DBG==1
                    RtlFillMemory( pv, page->GetChunkSize(), fillFree );
                #endif // CIDBG==1 || DBG==1

                page->Free( pv );

                if ( page->IsPageEmpty() )
                    memDeletePage( index, page );

                LeaveMemSection();
                return;
            }
        }

        LeaveMemSection();
    }

    #ifdef FALLOC_TRACK_NOTINPAGE
        InterlockedExchangeAdd( &gmem_cbNotInPages,
                                - (LONG) ReallyGetSize( pv ) );
    #endif //FALLOC_TRACK_NOTINPAGE

    #if CIDBG==1 || DBG==1
        ULONG cbBlock = ReallyGetSize( pv );
        RtlFillMemory( pv, cbBlock, fillBigFree );
    #endif // CIDBG==1 || DBG==1

    ReallyFree( pv );
} //memFree

//+---------------------------------------------------------------------------
//
//  Function:   memIsValidPointer
//
//  Synopsis:   Validates a pointer
//
//  Arguments:  [pv]  -- pointer to validate
//
//  Returns:    TRUE if the pointer is apparently valid, FALSE otherwise
//
//  History:    15-Oct-97   dlee       Created.
//
//----------------------------------------------------------------------------

BOOL memIsValidPointer( const void * pv )
{
    if ( 0 == pv )
        return TRUE;

    {
        EnterMemSection();

        ULONG index = memFindPageIndex( pv );

        // The page is either in the array of tiny allocation pages
        // or not in the array and is a stand-alone allocation.

        if ( index < gmem_cPages )
        {
            CPageHeader * page = gmem_aPages[ index ];

            // metadata at head of page prevents this

            ciAssert(( pv != page ));

            // it's sufficient to check just the start of the page since if
            // pv were greater than the end of the page the next index
            // would have been returned from the memFindPageIndex() call

            if ( pv > page )
            {
                ciAssert(( pv >= ( (char *) page + ( sizeof CPageHeader ) ) ));
                ciAssert(( pv < page->GetEndPlusOne() ));

                BOOL fValid = page->IsValidPointer( pv );
                LeaveMemSection();
                return fValid;
            }
        }

        LeaveMemSection();
    }

    return ReallyIsValidPointer( pv );
} //memIsValidPointer


//+---------------------------------------------------------------------------
//
//  Function:   memSize
//
//  Synopsis:   Returns the size of an allocation
//
//  Arguments:  [pv]  -- pointer to check
//
//  Returns:    Size in bytes of the allocation
//
//  History:    25-Oct-98   dlee       Created.
//
//----------------------------------------------------------------------------

UINT memSize( const void * pv )
{
    if ( 0 == pv )
        return 0;

    {
        EnterMemSection();

        ULONG index = memFindPageIndex( pv );

        // The page is either in the array of tiny allocation pages
        // or not in the array and is a stand-alone allocation.

        if ( index < gmem_cPages )
        {
            CPageHeader * page = gmem_aPages[ index ];

            // metadata at head of page prevents this

            ciAssert(( pv != page ));

            // it's sufficient to check just the start of the page since if
            // pv were greater than the end of the page the next index
            // would have been returned from the memFindPageIndex() call

            if ( pv > page )
            {
                ciAssert(( pv >= ( (char *) page + ( sizeof CPageHeader ) ) ));
                ciAssert(( pv < page->GetEndPlusOne() ));

                UINT cb = page->GetChunkSize();
                LeaveMemSection();
                return cb;
            }
        }

        LeaveMemSection();
    }

    return ReallyGetSize( pv );
} //memSize

#pragma optimize( "", on )

void memUtilization()
{

#if CIDBG==1 || DBG==1

    EnterMemSection();

#ifdef FALLOC_TRACK_NOTINPAGE
    falDebugOut(( DEB_WARN,
                  "mem > 256 bytes 0x%x (%d), peak 0x%x (%d)\n",
                  gmem_cbNotInPages,
                  gmem_cbNotInPages,
                  gmem_cbPeakNotInPages,
                  gmem_cbPeakNotInPages ));
#endif //FALLOC_TRACK_NOTINPAGE

    falDebugOut(( DEB_WARN,
                  "mem <= 256 bytes 0x%x (%d), peak 0x%x (%d)\n",
                  gmem_cbCurrentUsage,
                  gmem_cbCurrentUsage,
                  gmem_cbPeakUsage,
                  gmem_cbPeakUsage ));

    ULONG cbTotalSize = 0;
    ULONG cbTotalInUse = 0;

    for ( ULONG i = 0; i < gmem_cPages; i++ )
    {
        CPageHeader *p = gmem_aPages[ i ];
        ULONG c = p->GetAlloced();
        c *= p->GetChunkSize();

        cbTotalInUse += c;
        cbTotalSize += p->Size();

        falDebugOut(( DEB_WARN,
                      "p 0x%p cb %#x fl 0x%p f %#x a %#x s %#x u %#x\n",
                      p,
                      (ULONG) p->GetChunkSize(),
                      (ULONG_PTR) p->GetFreeList(),
                      (ULONG) p->GetFreeSize(),
                      (ULONG) p->GetAlloced(),
                      (ULONG) p->Size(),
                      c ));
    }

    falDebugOut(( DEB_WARN, "total %#x (%d), in use: %#x (%d)\n",
                  cbTotalSize, cbTotalSize,
                  cbTotalInUse, cbTotalInUse ));

    LeaveMemSection();

#endif // CIDBG==1 || DBG==1

} //memUtilization
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\fstream.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   FSTREAM.CXX
//
//  Contents:   Stream for accessing files with run-time libs.
//
//  Classes:    CStreamFile
//
//  History:    16-Dec-92   AmyA        Created from fstream.hxx
//
//  Notes:      _pCur always points to the current file position (within the
//              buffer) EXCEPT when _pCur == _pEnd.  In this case, _fp
//              ALWAYS points to the current file position.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fstream.hxx>

IMPLEMENT_UNWIND ( CStreamFile );

//+---------------------------------------------------------------------------
//
//  Member:      CStreamFile::CStreamFile, public
//
//  Synopsis:    opens file for reading/writing
//
//  Arguments:   [filename] - ascii name of file on disk
//               [type] - new file/existing file
//
//  History:     31-Jul-92       MikeHew   Created
//
//  Notes:       FileType NewFile will open/destroy specified file
//               FileType ExistingFile will open file for reading/appending
//
//----------------------------------------------------------------------------

EXPORTIMP
CStreamFile::CStreamFile( const char * filename, FileType type )
{
    switch( type )
    {
    case NewFile:
        _fp = fopen( filename, "wb+" );
        break;

    case NewOrExistingFile:
        _fp = fopen( filename, "rb+" );
        if ( !_fp )
            _fp = fopen( filename, "wb+" );
        break;

    case ExistingFile:
        _fp = fopen( filename, "rb" );
        break;
    }

    if ( _fp )
    {
        _pBuf = new BYTE [ defaultBufSize ];
        Win4Assert ( _pCur == _pEnd );
        // buffer will be filled when first character is read.
    }
    else
        _eof = TRUE;

    END_CONSTRUCTION ( CStreamFile );
}

//+-------------------------------------------------------------------------
//
//  Member:     CStreamFile::~CStreamFile, public
//
//  Synopsis:   Closes stream.
//
//  History:    04-Aug-92 MikeHew   Created
//
//--------------------------------------------------------------------------

EXPORTIMP
CStreamFile::~CStreamFile()
{
    if ( _fp )
    {
        fclose( _fp );

        delete [] _pBuf;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:      CStreamFile::Read, public
//
//  Synopsis:    Read data from file to destination
//
//  Arguments:   [dest] - pointer to destination
//               [size] - bytes to be read
//
//  History:     31-Jul-92       MikeHew   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

EXPORTIMP unsigned APINOT
CStreamFile::Read( void *dest, unsigned size )
{
    BYTE *pBuf = (BYTE *)dest;

    ULONG unread = size;

    ULONG cb = (ULONG)(_pEnd - _pCur);

    ULONG cbRead = min ( size, cb );

    memcpy ( pBuf, _pCur, cbRead );

    pBuf += cbRead;
    _pCur += cbRead;
    unread -= cbRead;

    if ( unread > 0 )
    {
        Win4Assert ( _pCur == _pEnd );  // buffer should be "empty"

        // read more

        LONG cBuf = unread / defaultBufSize;

        if ( cBuf != 0 )
        {
            cbRead = fread ( pBuf, sizeof(BYTE), cBuf*defaultBufSize, _fp );
            pBuf += cbRead;
            unread -= cbRead;
        }

        if ( unread > 0 )
        {
            if ( FillBuf() )
            {
                cb = (ULONG)(_pEnd - _pCur);
                cbRead = min ( unread, cb );

                memcpy ( pBuf, _pCur, cbRead );
                _pCur += cbRead;
                unread -= cbRead;
            }
        }
    }

    return ( size - unread );
}

//+---------------------------------------------------------------------------
//
//  Member:      CStreamFile::Write, public
//
//  Synopsis:    Write data to file from source buffer
//
//  Arguments:   [source] - pointer to source
//               [size] - bytes to be written
//
//  History:     31-Jul-92       MikeHew   Created
//
//----------------------------------------------------------------------------

EXPORTIMP unsigned APINOT
CStreamFile::Write( const void *source, unsigned size )
{
    //
    // The seeks are to guarantee seeks between read and write.
    //

    fseek( _fp, -((long)( _pEnd - _pCur )), SEEK_CUR ); // Seek to current position
                                                // in stream
    unsigned cbWritten = fwrite( source, 1, size, _fp );
    fseek( _fp, 0, SEEK_CUR );

    _pCur = _pEnd;  // This guarantees a FillBuf() for the next buffer read

    return cbWritten;
}

//+---------------------------------------------------------------------------
//
//  Member:      CStreamFile::Seek, public
//
//  Synopsis:    Move pointer to specified offset in file
//
//  Arguments:   [offset] - signed offset from origin
//               [origin] - one of the following options:
//
//                              CUR => offset from current position
//                              END => offset from end of file
//                    (default) SET => offset from beginning of file
//
//  History:     04-Aug-92       MikeHew   Created
//
//----------------------------------------------------------------------------

EXPORTIMP int APINOT
CStreamFile::Seek( LONG offset, CStream::SEEK origin )
{
    _eof = FALSE;

    if ( _pCur == _pEnd )   // the buffer is out-of-date anyway
    {
        return fseek( _fp, offset, origin );
    }

    LONG newBufOffset;
    LONG oldBufOffset = (LONG)(_pCur - _pBuf);

    LONG curFilePos = ftell ( _fp ) - (LONG)( _pEnd - _pCur );

    // figure out the offset relative to the beginning of the buffer

    switch ( origin )
    {
    case CStream::SET:

        // test for seeking before beginning of file
        if ( offset < 0 )
            return FALSE;

        newBufOffset = offset - curFilePos + oldBufOffset;

        break;

    case CStream::END:
    {
        int fileSize = Size();

        // test for seeking before beginning of file
        if ( offset < -fileSize )
            return FALSE;

        newBufOffset = offset + fileSize - curFilePos + oldBufOffset;

        break;
    }
    case CStream::CUR:

        // test for seeking before beginning of file
        if ( curFilePos + offset < 0 )
            return FALSE;

        newBufOffset = offset + oldBufOffset;

        break;
    }
    _eof = FALSE;

    // Check to see if newOffset is within current buffer

    if ( ( newBufOffset >= 0 ) && ( newBufOffset < ( _pEnd - _pBuf ) ) )
    {
        _pCur = _pBuf + newBufOffset;
        return TRUE;
    }

    // Seek to new location

    if ( origin == CStream::CUR )
        offset -= (LONG)(_pEnd - _pCur);    // _fp pos is not current pos, so adjust
                                    // offset
    _pCur = _pEnd;  // This guarantees a FillBuf() for the next buffer read
    return fseek( _fp, offset, origin );
}

//+---------------------------------------------------------------------------
//
//  Member:      CStreamFile::Size, public
//
//  Returns      Current size of stream.
//
//  History:     03-Sep-92       KyleP     Created
//
//----------------------------------------------------------------------------

ULONG
CStreamFile::Size()
{
    fpos_t pos;
    ULONG size;

    fgetpos( _fp, &pos );

    fseek( _fp, 0, SEEK_END );
    size = ftell( _fp );

    fsetpos( _fp, &pos );

    return( size );
}

//+---------------------------------------------------------------------------
//
//  Member:      CStreamFile::FillBuf, public
//
//  Synopsis:    Fills the stream buffer from the file indicated by _fp and
//               sets all pointers and variables accordingly.
//
//  Returns:     TRUE if new information was put into the buffer, FALSE
//               if not.
//
//  History:     23-Nov-92       AmyA      Created
//
//----------------------------------------------------------------------------

BOOL
CStreamFile::FillBuf()
{
    unsigned size = fread( _pBuf, sizeof(char), defaultBufSize, _fp );
    _pEnd = _pBuf + size;
    _pCur = _pBuf;
    if ( size == 0 )
    {
        _eof = TRUE;
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\printf.c ===
/***
*printf.c - print formatted to stdout
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4printf() - print formatted data to stdout
*       defines w4vprintf() - print formatted output to stdout, get data
*                             from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"            // function prototypes

#define _W4PRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\snapimg.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       snapimg.cxx
//
//  Contents:   runtime dynlink to imagehlp
//
//  History:    23-jan-97   MarkZ       Created 
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <imagehlp.h>
#include "snapimg.hxx"

#if CIDBG
T_SymInitialize      LocalSymInitialize = SymInitialize;
#else   //  CIDBG
T_SymInitialize      LocalSymInitialize = 0;
#endif  //  CIDBG
T_SymSetOptions      LocalSymSetOptions = 0;
T_SymGetSymFromAddr  LocalSymGetSymFromAddr = 0;
T_SymUnDName         LocalSymUnDName = 0;
BOOL fLocalRoutinesInitialized = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   SnapToImageHlp()
//
//  Synopsis:   snap a runtime link to ImageHlp
//
//  Returns:    TRUE if snap has been done
//
//  History:    23-jan-97   MarkZ       Created 
//
//----------------------------------------------------------------------------

BOOL
SnapToImageHlp( void )
{
    //
    //  Make sure we don't have to do extra work
    //
    
    if (!fLocalRoutinesInitialized) {
        
        //
        //  Load ImageHlp
        //

        HINSTANCE hInstance = LoadLibrary( L"DBGHELP.DLL" );
        if (hInstance == NULL) {
            return FALSE;
        }

        //
        //  Load Routines
        //

        if ((LocalSymSetOptions = 
             (T_SymSetOptions) GetProcAddress( hInstance, "SymSetOptions" )) == NULL ||
            
            (LocalSymGetSymFromAddr = 
             (T_SymGetSymFromAddr) GetProcAddress( hInstance, "SymGetSymFromAddr" )) == NULL ||
            
            (LocalSymUnDName = 
             (T_SymUnDName) GetProcAddress( hInstance, "SymUnDName" )) == NULL ||
            
            (LocalSymInitialize =
              (T_SymInitialize) GetProcAddress( hInstance, "SymInitialize" )) == NULL
            ) {

            return FALSE;
        }

        //
        //  Signal that we are initialized
        //

        fLocalRoutinesInitialized = TRUE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#if CIDBG == 1 || DBG == 1

#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include <windows.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static long fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       ((MAX_PATH + 1) * sizeof(WCHAR))
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy = 0;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = PtrToLong(GetStdHandle(ldummy))) == 0 || fh == -1)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (int)(f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile( LongToHandle( fh ), f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_

#endif //CIDBG == 1 || DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#define _W4SPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"

#if CIDBG == 1 || DBG == 1

/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#define get_ptr_arg(x) get_void_ptr_arg(x)

/*
#if PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif
*/

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 40

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */
#define FL_LONGLONG   0x1000      /* longlong value given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

enum CHARTYPE find_char_class(char c)
{
    // since I don't know how to run maketab, I make 'I' the same charclass
    // as 'd'.

    if ( 'I' == c )
        c = 'd';

    return (c < ' ' || c > 'x') ? CH_OTHER : (lookuptable[(c)-' '] & 0xF);
}

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
LOCAL(__int64) get_int64_arg(va_list *pargptr);
/*LOCAL(INT_PTR) get_int_ptr_arg(va_list *pargptr);*/
LOCAL(void *) get_void_ptr_arg(va_list *pargptr);
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd;         /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags;          /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth;       /* selected field with -- 0 means default */
    int fwide;
    int precision;      /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen;      /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;      /* non-zero = prodcue no output for this specifier */
    char *text;         /* pointer text to be printed, not zero terminated */
    int textlen;        /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    textlen = strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'I':

                // accepted formats:
                //    %I64d
                //    %I64u
                //    %I64x
                //    %I64X
                //    %#I64x
                //    %#I64X

                if ( '6' == *format++ &&
                     '4' == *format++ )
                {
                    if ( 'd' == *format )
                    {
                        flags |= FL_SIGNED;
                        radix = 10;
                    }
                    else if ( 'u' == *format )
                    {
                        radix = 10;
                    }
                    else
                    {
                        if ( 'x' == *format )
                        {
                            radix = 16;
                            hexadd = 'a' - '9' - 1;
                        }
                        else if ( 'X' == *format )
                        {
                            radix = 16;
                            hexadd = 'A' - '9' - 1;
                        }

                        if (flags & FL_ALTERNATE)
                        {
                            /* alternate form means '0x' prefix */
                            prefix[0] = '0';
                            prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                            prefixlen = 2;
                        }
                    }

                    format++;

                    flags |= FL_LONGLONG;
                    goto COMMON_INT;
                }
                break;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned __int64 number;   /* number to convert */
                int digit;              /* ascii value of digit */
                __int64 l;                 /* temp long value */

                /* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                    {
                        if ( flags & FL_LONGLONG )
                            l = get_int64_arg(&argptr); /* sign extend */
                        else
                            l = get_int_arg(&argptr); /* sign extend */
                    }
                    else
                    {
                        if ( flags & FL_LONGLONG )
                            l = (unsigned __int64) get_int64_arg(&argptr);    /* zero-extend*/
                        else
                            l = (unsigned __int64) get_int_arg(&argptr);    /* zero-extend*/
                    }
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                if ( ! (flags & FL_LONGLONG) )
                    number = number & 0xffffffff;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

LOCAL(__int64) get_int64_arg(va_list *pargptr)
{
    return va_arg(*pargptr, __int64);
}

LOCAL(void *) get_void_ptr_arg(va_list*pargptr)
{
    return va_arg(*pargptr, void *);
}

/*
LOCAL(INT_PTR) get_int_ptr_arg(va_list *pargptr)
{
    return va_arg(*pargptr, INT_PTR);
}
*/

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif



/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}

#endif CIDBG == 1 || DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\wsprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4wcsprintf() - print formatted data to wide character string
*	defines w4vwcsprintf() - print formatted output to a wide character
*				 string, get data from argument ptr instead
*				 of explicit args.
*******************************************************************************/

#define _W4WCSPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\memory.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:  MEMORY.CXX
//
//  Contents:   Memory allocators
//
//  History:    9-27-93   IsaacHe Heavy modifications throughout:
//                                Elimination of Buddy Heap
//                                Rework of stack backtrace & leak checks
//                                Use VirtualAlloc on large chunks
//                                Elimination of KERNEL and FLAT stuff
//                                Cosmetics
//              10-12-93  IsaacHe Made a separate info level for heap
//              12-3-93   IsaacHe Removed the VirtualAlloc stuff. Moved
//                                debug support code to another file.
//              7/27/94           Cruft removal
//              4/30/96   dlee    Cruft removal
//              9/26/96   dlee    Cruft removal
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <falloc.hxx>
#include <cidllsem.hxx>

// Uncomment this to include OLE heap tracking.  This isn't normally done
// because there are some issues with exiting cleanly.
//#define USE_IMALLOCSPY

typedef void * (* PAllocFun)( UINT cb );
typedef void (* PFreeFun)( void * pv );
typedef UINT (* PSizeFun)( const void * pv );
typedef BOOL (* PValidateFun)( const void * pv );
typedef void (* PUtilizationFun)( void );

PAllocFun realAlloc = 0;
PFreeFun realFree = 0;
PSizeFun realSize = 0;
PValidateFun realValidate = 0;
PUtilizationFun realUtilization = 0;

HANDLE gmem_hHeap = 0;

inline void * heapAlloc( UINT cbAlloc )
{
    Win4Assert( 0 != gmem_hHeap );
    void * p = (void *) HeapAlloc( gmem_hHeap, 0, cbAlloc );

    #if CIDBG == 1 || DBG == 1
        if ( 0 != p )
            RtlFillMemory( p, cbAlloc, 0xda );
    #endif

    return p;
} //heapAlloc

inline void heapFree( void * p )
{
    Win4Assert( 0 != gmem_hHeap );

    #if CIDBG == 1 || DBG == 1
        UINT cb = (UINT)HeapSize( gmem_hHeap, 0, p );
        if ( ~0 != cb )
            RtlFillMemory( p, cb, 0xdc );
    #endif

    if ( !HeapFree( gmem_hHeap, 0, p ) )
        Win4Assert(!"Bad ptr for operator delete");
} //heapFree

inline UINT heapSize( void const * p )
{
    return (UINT) HeapSize( gmem_hHeap, 0, p );
}

inline BOOL heapValidate( const void * p )
{
    if ( 0 == p )
        return TRUE;

    Win4Assert( 0 != gmem_hHeap );

    if ( HeapSize( gmem_hHeap, 0, p ) <= 0 )
    {
       Win4Assert( !"Invalid pointer detected" );
       return FALSE;
    }

    return TRUE;
} //heapValidate

inline void heapUtilization()
{
    // No stats here when you use the system heap.  Use !heap or dh.exe
} //heapUtilization

#if CIDBG == 1 || DBG == 1

#include <tracheap.h>
#include <dbgpoint.hxx>
#include <propapi.h>

#include "spy.hxx"

CMallocSpy * g_pMallocSpy = 0;

void __cdecl HeapExit()
{
#ifdef USE_IMALLOCSPY
    if ( g_pMallocSpy )
    {
        MallocSpyUnRegister( g_pMallocSpy );
        g_pMallocSpy->Release();
    }
#endif // USE_IMALLOCSPY

    AllocArenaDump( 0 );
} //HeapExit

//
// Debugging dialog support...
//

extern ULONG Win4InfoLevel;
extern ULONG Win4InfoMask;

BOOL g_fDumpArena = FALSE;
DWORD g_FailTestRatio = FALSE;

void EnableCiFailTest( unsigned Ratio )
{
    g_FailTestRatio = Ratio;
}

DECLARE_DEBUG( heap );
#define heapDebugOut(x) heapInlineDebugOut x

CRITICAL_SECTION g_csDbgMemExclusive;  // ensures single creator of arena

UINT ciAddAllocRecord( UINT cb )
{
    return cb + sizeof 1 + sizeof AHeader;
}

void * ciRecordAlloc( void * p, UINT size )
{
    if ( 0 == p )
        return p;

    static AllocArena * pAllocArena = (AllocArena *) -1;

    if ( pAllocArena == (AllocArena *) -1 )
    {
        // Note: If the cs is invalid at this point, it's because
        // you're calling operator new too early.  Construct
        // your global object later.

        EnterCriticalSection( &g_csDbgMemExclusive );
        if ( pAllocArena == (AllocArena *) -1 )
        {
            pAllocArena = AllocArenaCreate( MEMCTX_TASK,
                                            "Operator new");
#ifdef USE_IMALLOCSPY
            MallocSpyRegister( &g_pMallocSpy );
#endif // USE_IMALLOCSPY

            atexit( HeapExit );
        }
        LeaveCriticalSection( &g_csDbgMemExclusive );
    }

    ((AHeader *)p)->size = size;
    ((AHeader *)p)->p = AllocArenaRecordAlloc( pAllocArena, size );
    p = (AHeader *)p + 1;
    *((char *)p + size ) = ALLOC_SIGNATURE;
    return p;
} //ciRecordAlloc

UINT ciAllocSize( void * p )
{
    if ( 0 == p )
        return 0;

    AHeader *ap = (AHeader *)p - 1;
    return ap->size;
} //ciAllocSize

void * ciRecordFree( void * p )
{
    if ( 0 == p )
        return 0;

    AHeader *ap = (AHeader *)p - 1;

    switch( *((char *)p + ap->size) )
    {
        case ALLOC_SIGNATURE:
            break;
        case FREE_SIGNATURE:
            heapDebugOut(( DEB_WARN, "Invalid freed pointer: 0x%x\n", p ));
            Win4Assert( !"Invalid freed pointer" );
            return 0;
            break;
        default:
            heapDebugOut((DEB_WARN, "Invalid overrun pointer: 0x%x\n", p ));
            Win4Assert( !"Invalid overrun pointer" );
            return 0;
            break;
    }
    *((char *)p + ap->size) = FREE_SIGNATURE;
    if ( 0 != ap->p )
        AllocArenaRecordFree( ap->p, ap->size );

    return (void *) ap;
} //CiRecordFree

//+---------------------------------------------------------------------------
//
//  Function:   ciNewDebug
//
//  Synopsis:   Debugging allocator
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:    A pointer to the allocated memory.
//
//----------------------------------------------------------------------------

void * ciNewDebug( size_t size )
{
    // just a convenient way to dump the allocation arena

    if ( g_fDumpArena )
    {
        // Note: If the cs is invalid at this point, it's because
        // you're calling operator new too early.  Construct
        // your global object later.

        EnterCriticalSection( &g_csDbgMemExclusive );

        if ( g_fDumpArena )
        {
            AllocArenaDump( 0 );
            realUtilization();
            g_fDumpArena = FALSE;
            heapDebugOut(( DEB_FORCE, "done dumping the heap\n" ));
            DebugBreak();
        }

        LeaveCriticalSection( &g_csDbgMemExclusive );
    }

    // fail test?

    if ( ( 0 != g_FailTestRatio ) &&
         ( ( rand() % g_FailTestRatio ) == 1 ) )
        return 0;

    UINT cb = ciAddAllocRecord( size );
    void *p = realAlloc( cb );

    if ( 0 != p )
        p = ciRecordAlloc( p, size );

    return p;
} //CiNewDebug

//+---------------------------------------------------------------------------
//
//  Function:   ciNewDebugNoRecord
//
//  Synopsis:   Compatible with ciNewDebug, but doesn't log allocation.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:    A pointer to the allocated memory.
//
//----------------------------------------------------------------------------

void * ciNewDebugNoRecord( size_t size )
{
    void *p = realAlloc( 1 + size + sizeof AHeader );

    if ( 0 != p )
    {
        ((AHeader *)p)->size = size;
        ((AHeader *)p)->p = 0;
        p = (AHeader *)p + 1;
        *((char *)p + size ) = ALLOC_SIGNATURE;
    }

    return p;
} //CiNewDebugNoRecord

#ifdef UseCICoTaskMem

    #undef CoTaskMemAlloc
    WINOLEAPI_(LPVOID) CoTaskMemAlloc(IN ULONG cb);
    void * CICoTaskMemAlloc( ULONG cb )
    {
        // fail test?
    
        if ( ( 0 != g_FailTestRatio ) &&
             ( ( rand() % g_FailTestRatio ) == 1 ) )
            return 0;
    
        ULONG cbAlloc = ciAddAllocRecord( cb );
        void *p = CoTaskMemAlloc( cbAlloc );
        return ciRecordAlloc( p, cb );
    }
    
    #undef CoTaskMemFree
    WINOLEAPI_(void) CoTaskMemFree(IN LPVOID p);
    void CICoTaskMemFree( LPVOID p )
    {
        void *pv = ciRecordFree( p );
        CoTaskMemFree( pv );
    }

#endif // UseCICoTaskMem

#else // CIDBG == 1 || DBG == 1

#define heapDebugOut(x)

#endif // CIDBG == 1 || DBG == 1

//+---------------------------------------------------------------------------
//
//  Function:   ExceptDllMain
//
//  Synopsis:   Entry point on DLL initialization for exception-specific stuff.
//
//  History:    10-12-93   kevinro   Created
//              02-28-96   KyleP     Cleanup
//
//----------------------------------------------------------------------------

#if CIDBG == 1 || DBG == 1
extern CDLLStaticMutexSem g_mxsAssert;
#endif // CIDBG == 1 || DBG == 1

extern CStaticMutexSem g_mtxGetStackTrace;
extern CMemMutex gmem_mutex;


BOOL ExceptDllMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{
   switch( dwReason )
   {
   case DLL_PROCESS_ATTACH:

       #if CIDBG == 1 || DBG == 1
           {
               // These two objects are initialized from win.ini
    
               static CInfoLevel level( L"Win4InfoLevel",Win4InfoLevel);
               static CInfoLevel mask( L"Win4InfoMask", Win4InfoMask, (ULONG)-1 );
           }
    
           InitializeCriticalSection( &g_csDbgMemExclusive );
           g_mxsAssert.Init();

       #endif // CIDBG == 1 || DBG == 1

       g_mtxGetStackTrace.Init();
       gmem_mutex.Init();

       gmem_hHeap = HeapCreate( 0, 0, 0 );

       //
       // HeapAlloc is faster on MP machines, and falloc is faster and
       // uses less working set on UP machines.
       //

       SYSTEM_INFO si;
       GetSystemInfo( &si );

       if ( si.dwNumberOfProcessors > 1 )
       {
           realAlloc = heapAlloc;
           realFree = heapFree;
           realSize = heapSize;
           realValidate = heapValidate;
           realUtilization = heapUtilization;
       }
       else
       {
           realAlloc = memAlloc;
           realFree = memFree;
           realSize = memSize;
           realValidate = memIsValidPointer;
           realUtilization = memUtilization;
       }

       break;

   case DLL_PROCESS_DETACH:
       if ( 0 != gmem_hHeap )
       {
           HeapDestroy( gmem_hHeap );
           gmem_hHeap = 0;
       }

       #if CIDBG == 1 || DBG == 1
           DeleteCriticalSection( &g_csDbgMemExclusive );
           g_mxsAssert.Delete();
       #endif // CIDBG == 1 || DBG == 1

       break;

   case DLL_THREAD_ATTACH:
#if 0
       //
       // can't do the exception translation here for several reasons:
       //
       // 1) iis creates threads before we are called, so they don't have
       //    their exceptions translated (on dll load, those threads don't
       //    send thread_attach's, per the sdk)
       // 2) for some reason, we aren't getting thread attaches anyway.
       // 3) the first thread to call us only is guaranteed to send
       //    a process_attach, not a thread_attach (per sdk)
       // 4) we don't want to hose other ISAPI apps by changing
       //    their exception handler.
       //

       //DbgPrint("thread attach!\n");
       #if defined(NATIVE_EH)
           _set_se_translator( SystemExceptionTranslator );
           //DbgPrint("set the handler!\n");
       #endif // NATIVE_EH
#endif

       break;
   }

   return TRUE;
} //ExceptDllMain

//+---------------------------------------------------------------------------
//
//  Function:   function ciNew, public
//
//  Synopsis:   Global operator new which throws exceptions.
//
//  Effects:    Keeps track of the most recent heap allocation in each
//              thread. This information is used to determine when to
//              unlink CUnwindable objects.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:    A pointer to the allocated memory.
//              Is *NOT* initialized to 0!
//              It is 8-byte aligned.
//
//  Modifies:   _pLastNew in _exceptioncontext.
//
//----------------------------------------------------------------------------

void * ciNew( size_t size )
{
    Win4Assert( 0 != realAlloc );

    #if CIDBG == 1 || DBG == 1
        void* p = ciNewDebug( size );
    #else // CIDBG == 1 || DBG == 1
        void * p = realAlloc( size );
    #endif // CIDBG == 1 || DBG == 1

    if ( 0 == p )
        THROW( CException( E_OUTOFMEMORY ) );

    return p;
} //ciNew

//+---------------------------------------------------------------------------
//
//  Function:   ciDelete, public
//
//  Synopsis:   Matches the operator new above.
//
//  Arguments:  [p] -- The pointer to delete.
//
//  Requires:   [p] was allocated with ciNew
//
//----------------------------------------------------------------------------

void ciDelete( void * p )
{
    #if CIDBG == 1 || DBG == 1

        p = ciRecordFree( p );

    #endif // CIDBG == 1 || DBG == 1

    if ( 0 == p )
        return;

    realFree( p );
} //ciDelete

//+---------------------------------------------------------------------------
//
//  Function:   ciIsValidPointer, public
//
//  Synopsis:   Determines if a pointer is valid, was allocated with ciNew,
//              and can be freed with ciDelete.
//
//  Arguments:  [p] -- The pointer to check
//
//  Returns:    TRUE if the pointer appears valid, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL ciIsValidPointer( const void * p )
{
    if ( 0 == p )
        return TRUE;

    Win4Assert( 0 != realValidate );

    //
    // Allocations are rounded up to at least 8 bytes, so at least that
    // much must be writable.
    //

    if ( IsBadWritePtr( (void *) p, 8 ) )
    {
        heapDebugOut(( DEB_WARN, "Invalid non-writable pointer: 0x%x\n", p ));
        Win4Assert( !"Invalid non-writable pointer" );
        return FALSE;
    }

    #if CIDBG == 1 || DBG == 1

        AHeader *ap = (AHeader *)p - 1;

        switch( *((char *)p + ap->size) )
        {
            case ALLOC_SIGNATURE:
                break;
            case FREE_SIGNATURE:
                heapDebugOut(( DEB_WARN, "Invalid freed pointer: 0x%x\n", p ));
                Win4Assert( !"Invalid freed pointer" );
                return FALSE;
                break;
            default:
                heapDebugOut((DEB_WARN, "Invalid overrun pointer: 0x%x\n", p ));
                Win4Assert( !"Invalid overrun pointer" );
                return FALSE;
                break;
        }

        p = (void *) ap;

    #endif // CIDBG == 1 || DBG == 1

    return realValidate( p );
} //ciIsValidPointer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\spy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Net Library System
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       spy.cxx
//
//  Contents:   This file contains the implementation of the IMalloc Spy
//              interface that uses the memory leak tracking stuff ported
//              from Content Index to give stack traces of OLE memory
//              allocations that are not freed.  This class has been
//              modified after copying from the TABLECOPY sample in oledb
//              samples to make use of Content Index's heap tracking
//              software.
//
//  History:    10-05-97   srikants   Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
// Includes
//
/////////////////////////////////////////////////////////////////////////////

#include <spy.hxx>
#include <tracheap.h>
#include <alocdbg.hxx>

#if CIDBG==1 || DBG==1

DECLARE_DEBUG( heap );
#define heapDebugOut(x) heapInlineDebugOut x

/////////////////////////////////////////////////////////////////////////////
// Defines
//
/////////////////////////////////////////////////////////////////////////////

// AHeader + BUFFER + FOOTER
// FOOTER = TAILSIGNITURE

//All the header info must be ULONGs,
//so that the user buffer falls on a word boundary
//The tail must be a byte, since if it was a ULONG it would
//also require a word boundary, but the users buffer could
//be an odd number of bytes, so instead of rounding up, just use BYTE

const ULONG HEADSIZE    = sizeof(AHeader);  //HEADSIGNITURE
const ULONG TAILSIZE    = sizeof(BYTE);     //TAILSIGNITURE

const ULONG HEADERSIZE = ROUNDUP(HEADSIZE);
const ULONG FOOTERSIZE = TAILSIZE;

const BYTE  ALLOCSIGN = '$';
const BYTE  FREESIGN  = 'Z';

#define HEAD_OFFSET(pHeader)        ((BYTE*)pHeader)
#define TAIL_OFFSET(pHeader)        (USERS_OFFSET(pHeader)+ (AHeader *)pHeader->size)

#define USERS_OFFSET(pHeader)       (HEAD_OFFSET(pHeader) + HEADERSIZE)
#define HEADER_OFFSET(pUserBuffer)  ((BYTE*)(pUserBuffer) - HEADERSIZE) 

#define TAIL_SIGNITURE(pHeader)     (*(BYTE*)TAIL_OFFSET(pHeader))

static AllocArena * pAllocArena = (AllocArena *) -1;

/////////////////////////////////////////////////////////////////////////////
// CMallocSpy::CMallocSpy()
//
/////////////////////////////////////////////////////////////////////////////
CMallocSpy::CMallocSpy() :
    m_cRef( 1 ),	// implicit AddRef()
    m_cbRequest( 0 )
{
}

/////////////////////////////////////////////////////////////////////////////
// CMallocSpy::~CMallocSpy()
//
/////////////////////////////////////////////////////////////////////////////
CMallocSpy::~CMallocSpy()
{
    //Remove all the elements of the list
    //CAllocList.RemoveAll();
}


/////////////////////////////////////////////////////////////////////////////
// BOOL CMallocSpy::Add
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMallocSpy::Add(void* pv)
{
    Win4Assert(pv);

    //Add this element to the list
    //CAllocList.AddTail(pv);
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// BOOL CMallocSpy::Remove
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMallocSpy::Remove(void* pv)
{
    Win4Assert(pv);
    
    //Remove this element from the list
    //CAllocList.RemoveAt(CAllocList.Find(pv));
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// BOOL CMallocSpy::DumpLeaks
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMallocSpy::DumpLeaks()
{
    #if 0
    ULONG ulTotalLeaked = 0;

    //Display Leaks to the Output Window
    while(!CAllocList.IsEmpty())
    {   
        //Obtain the pointer to the leaked memory
        void* pUsersBuffer = CAllocList.RemoveHead();
        Win4Assert(pUsersBuffer);
        
        void* pHeader = HEADER_OFFSET(pUsersBuffer);
        Win4Assert(pHeader);

        //Make sure that the head/tail signitures are intact
        if(HEAD_SIGNITURE(pHeader) != HEADSIGN)
            heapDebugOut((DEB_ERROR, "-- IMallocSpy HeadSigniture Corrupted! - 0x%08x, ID=%08lu, %lu bytes\n",
                                     pUsersBuffer,
                                     BUFFER_ID(pHeader),
                                     BUFFER_LENGTH(pHeader)));

        if(TAIL_SIGNITURE(pHeader) != TAILSIGN)
            heapDebugOut((DEB_ERROR, "-- IMallocSpy TailSigniture Corrupted! - 0x%08x, ID=%08lu, %lu bytes\n",
                                     pUsersBuffer, BUFFER_ID(pHeader), BUFFER_LENGTH(pHeader)) );

        ULONG ulSize = BUFFER_LENGTH(pHeader);
        ULONG ulID   = BUFFER_ID(pHeader);
        
        heapDebugOut(( DEB_ERROR, "-- IMallocSpy LEAK! - 0x%08x, ID=%08lu, %lu bytes\n",
                                  pUsersBuffer, ulID, ulSize));
        ulTotalLeaked += ulSize;
    }

    if(ulTotalLeaked)
        heapDebugOut(( DEB_ERROR, "-- IMallocSpy Total LEAKED! - %lu bytes\n", ulTotalLeaked));
    #endif  // 0

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// HRESULT CMallocSpy::QueryInterface
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CMallocSpy::QueryInterface(REFIID riid, void** ppIUnknown)
{
    if(!ppIUnknown)
        return E_INVALIDARG;
    
    *ppIUnknown = NULL;

    //IID_IUnknown
    if(riid == IID_IUnknown)
        *ppIUnknown = this;
    //IDD_IMallocSpy
    else if(riid == IID_IMallocSpy)
         *ppIUnknown =  this;
    
    if(*ppIUnknown)
    {
        ((IUnknown*)*ppIUnknown)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// ULONG CMallocSpy::AddRef
//
/////////////////////////////////////////////////////////////////////////////
ULONG CMallocSpy::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// ULONG CMallocSpy::Release
//
/////////////////////////////////////////////////////////////////////////////
ULONG CMallocSpy::Release()
{
    if(--m_cRef)
        return m_cRef;

    heapDebugOut(( DEB_TRACE, "Releasing IMallocSpy\n" ));

    delete this;
    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// ULONG CMallocSpy::PreAlloc
//
/////////////////////////////////////////////////////////////////////////////
SIZE_T CMallocSpy::PreAlloc(SIZE_T cbRequest)
{
    //cbRequest is the orginal number of bytes requested by the user
    //Store the users requested size
    m_cbRequest = cbRequest;

    //Return the total size requested, plus extra for header/footer
    return (m_cbRequest + sizeof AHeader + 1);
}

/////////////////////////////////////////////////////////////////////////////
// void* CMallocSpy::PostAlloc
//
/////////////////////////////////////////////////////////////////////////////
void* CMallocSpy::PostAlloc(void* pHeader)
{
    //pHeader is the pointer to the head of the buffer, including the header

    if (pHeader)
    {
        //Place the Size in the HEADER
        ((AHeader *)pHeader)->size = m_cbRequest;
        ((AHeader *)pHeader)->p = AllocArenaRecordAlloc( pAllocArena, m_cbRequest );
        pHeader = (AHeader *)pHeader + 1;

        //Place the TailSigniture in the HEADER
        *((char *)pHeader + m_cbRequest ) = ALLOC_SIGNATURE;

        //Set the UsersBuffer to a known char
        memset(pHeader, ALLOCSIGN, m_cbRequest);

#ifdef FINDLEAKS
        heapDebugOut((DEB_ITRACE, "-- IMallocSpy Alloc - 0x%08x, ID=%08lu, %lu bytes\n", pHeader, ulID, m_cbRequest));
#endif // FINDLEAKS
    }

    // Return the actual users buffer
    return pHeader;
}

/////////////////////////////////////////////////////////////////////////////
// void* CMallocSpy::PreFree
//
/////////////////////////////////////////////////////////////////////////////
void* CMallocSpy::PreFree(void* pUsersBuffer, BOOL fSpyed)
{
    //pUsersBuffer is the users pointer to thier buffer, not the header

    // Check for NULL
    if(pUsersBuffer == NULL)
        return NULL;

    //If this memory was alloced under IMallocSpy, need to remove it
    if(fSpyed)
    {
        //Remove this pointer form the list
        //Remove(pUsersBuffer);
    

        AHeader *ap = (AHeader *)pUsersBuffer - 1;

        switch( *((char *)pUsersBuffer + ap->size) )
        {
        case ALLOC_SIGNATURE:
                break;
        case FREE_SIGNATURE:
                heapDebugOut((DEB_WARN, "Double deleted memory at %#x\n", pUsersBuffer ));
                AllocArenaDumpRecord( ap->p );
                Win4Assert( !"Probable double delete" );
                break;
        default:
                heapDebugOut((DEB_WARN, "Overrun memory at %#x\n", pUsersBuffer ));
                AllocArenaDumpRecord( ap->p );
                Win4Assert( !"Probable overrun heap block" );
                break;
        }
        *((char *)pUsersBuffer + ap->size) = FREE_SIGNATURE;

        if ( 0 != ap->p )
            AllocArenaRecordFree( ap->p, ap->size );
//      memset( pUsersBuffer, FREESIGN, ap->size + HEADERSIZE  );

        pUsersBuffer = (void *) ap;
    }

    //else
    return pUsersBuffer;
}


/////////////////////////////////////////////////////////////////////////////
// void CMallocSpy::PostFree
//
/////////////////////////////////////////////////////////////////////////////
void CMallocSpy::PostFree(BOOL fSpyed)
{
    // Note the free or whatever
    return;
}


/////////////////////////////////////////////////////////////////////////////
// ULONG CMallocSpy::PreRealloc
//
/////////////////////////////////////////////////////////////////////////////
SIZE_T CMallocSpy::PreRealloc( void* pUsersBuffer, SIZE_T cbRequest,
                              void** ppNewRequest, BOOL fSpyed)
{
    Win4Assert(pUsersBuffer && ppNewRequest);
    
    //If this was alloced under IMallocSpy we need to adjust
    //the size stored in the header
    if(fSpyed)
    {
        AHeader *ap = (AHeader *)pUsersBuffer - 1;

        //Find the start
        *ppNewRequest = (void *) ap;
        
        //Store the new desired size
        m_cbRequest = cbRequest;
        
        //Return the total size, including extra
        return (m_cbRequest + sizeof AHeader + 1);
    }

    //else
    *ppNewRequest = pUsersBuffer;
    return cbRequest;
}


/////////////////////////////////////////////////////////////////////////////
// void* CMallocSpy::PostRealloc
//
/////////////////////////////////////////////////////////////////////////////
void* CMallocSpy::PostRealloc(void* pHeader, BOOL fSpyed)
{
    //If this buffer was alloced under IMallocSpy
    if(fSpyed)
    {

        AHeader *ap = (AHeader *)pHeader;
        void * pUsersBuffer = (AHeader *)pHeader + 1;

        if ( m_cbRequest >= ap->size )
        {
            switch( *((char *)pUsersBuffer + ap->size) )
            {
            case ALLOC_SIGNATURE:
                    break;
            case FREE_SIGNATURE:
                    heapDebugOut((DEB_WARN, "Double deleted memory at %#x\n", pUsersBuffer ));
                    AllocArenaDumpRecord( ap->p );
                    Win4Assert( !"Probable double delete" );
                    break;
            default:
                    heapDebugOut((DEB_WARN, "Overrun memory at %#x\n", pUsersBuffer ));
                    AllocArenaDumpRecord( ap->p );
                    Win4Assert( !"Probable overrun heap block" );
                    break;
            }
        }
    
        if ( 0 != ap->p )
            AllocArenaRecordReAlloc( ap->p, ap->size, m_cbRequest );

        ap->size = m_cbRequest;

        // Position for the user's buffer.
        pHeader = pUsersBuffer;
    
        //Place the TailSigniture in the HEADER
        *((char *)pHeader + m_cbRequest ) = ALLOC_SIGNATURE;    
    }
    
    //else
    return pHeader;
}


/////////////////////////////////////////////////////////////////////////////
// void* CMallocSpy::PreGetSize
//
/////////////////////////////////////////////////////////////////////////////
void* CMallocSpy::PreGetSize(void* pUsersBuffer, BOOL fSpyed)
{
    if (fSpyed)
    {
        AHeader *ap = (AHeader *)pUsersBuffer - 1;
        return ap;
    }

    return pUsersBuffer;
}



/////////////////////////////////////////////////////////////////////////////
// ULONG CMallocSpy::PostGetSize
//
/////////////////////////////////////////////////////////////////////////////
SIZE_T CMallocSpy::PostGetSize(SIZE_T cbActual, BOOL fSpyed)
{
    if (fSpyed)
    {
        return cbActual - HEADERSIZE - FOOTERSIZE;
    }

    return cbActual;
}




/////////////////////////////////////////////////////////////////////////////
// void* CMallocSpy::PreDidAlloc
//
/////////////////////////////////////////////////////////////////////////////
void* CMallocSpy::PreDidAlloc(void* pUsersBuffer, BOOL fSpyed)
{
    if (fSpyed)
    {
        AHeader *ap = (AHeader *)pUsersBuffer - 1;
        return ap;
    }

    return pUsersBuffer;
}


/////////////////////////////////////////////////////////////////////////////
// BOOL CMallocSpy::PostDidAlloc
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMallocSpy::PostDidAlloc(void* pRequest, BOOL fSpyed, BOOL fActual)
{
    return fActual;
}



/////////////////////////////////////////////////////////////////////////////
// void CMallocSpy::PreHeapMinimize
//
/////////////////////////////////////////////////////////////////////////////
void CMallocSpy::PreHeapMinimize()
{
    // We don't do anything here
    return;
}


/////////////////////////////////////////////////////////////////////////////
// void CMallocSpy::PostHeapMinimize
//
/////////////////////////////////////////////////////////////////////////////
void CMallocSpy::PostHeapMinimize()
{
    // We don't do anything here
    return;
}

/////////////////////////////////////////////////////////////////////////////
// Resgistration
//
/////////////////////////////////////////////////////////////////////////////

void MallocSpyRegister(CMallocSpy** ppCMallocSpy)
{
    // CoInitializeEx(NULL, COINIT_MULTITHREADED);

    Win4Assert(ppCMallocSpy);

    // Win4Assert( !"Break In" );

    //Allocate Interface
    *ppCMallocSpy = new CMallocSpy(); //Constructor AddRef's
    
    //Regisiter Interface
    HRESULT hr = CoRegisterMallocSpy(*ppCMallocSpy); // Does an AddRef on Object

    heapDebugOut(( DEB_WARN, "CoRegisterMallocSpy returned 0x%X\n", hr ));

    if ( FAILED(hr) )
    {
        (*ppCMallocSpy)->Release();
        *ppCMallocSpy = 0;
        return;
    }

    Win4Assert( pAllocArena == (AllocArena *) -1 ); 
    if ( pAllocArena == (AllocArena *) -1 )
    {
        pAllocArena = AllocArenaCreate( MEMCTX_TASK,
                                        "IMalloc allocator");
        // atexit( HeapExit );
    }

    // CoUninitialize();
}

void MallocSpyUnRegister(CMallocSpy* pCMallocSpy)
{
    // CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // Win4Assert();
    CoRevokeMallocSpy(); //Does a Release on Object

    // CoUninitialize();
}

void MallocSpyDump(CMallocSpy* pCMallocSpy)
{
    Win4Assert(pCMallocSpy);
    pCMallocSpy->DumpLeaks(); 
}

#else

void MallocSpyRegister(CMallocSpy** ppCMallocSpy) { return; };
void MallocSpyUnRegister(CMallocSpy* pCMallocSpy) { return; };
void MallocSpyDump(CMallocSpy* pCMallocSpy)       { return; };

#endif //CIDBG==1 || DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\streams.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   STREAMS.CXX
//
//  Contents:   CStream functions needed for IDSMgr, Filter, and OFS.
//
//  Classes:    CStreamA, CStreamW, and CStreamASCIIStr
//
//  History:    16-Dec-92   AmyA        Created from streams.hxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <streams.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CStreamA::GetBuf, public
//
//  Synopsis:   Refills the buffer by calling the virtual function FillBuf,
//              then if the buffer was not filled, returns EOF, otherwise
//              returns the first char in buffer and increments _pCur.
//
//  History:    15-Dec-92   AmyA        Created
//
//----------------------------------------------------------------------------

EXPORTIMP int APINOT
CStreamA::GetBuf()
{
    if ( !FillBuf() )
    {
        _eof = TRUE;
        return EOF;
    }
    return *_pCur++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamW::GetBuf, public
//
//  Synopsis:   Refills the buffer by calling the virtual function FillBuf,
//              then if the buffer was not filled, returns EOF, otherwise
//              returns the first wchar in buffer and increments _pCur.
//
//  History:    15-Dec-92   AmyA        Created
//
//----------------------------------------------------------------------------

EXPORTIMP int APINOT
CStreamW::GetBuf()
{
    if ( !FillBuf() )
    {
        _eof = TRUE;
        return EOF;
    }

    return *_pCur++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStreamASCIIStr::Read, public
//
//  Synopsis:   Copies chars from the buffer into dest and returns the number
//              of chars copied.
//
//  Arguments:  [dest] -- buffer to copy chars into
//              [size] -- size of the buffer (max # of chars to copy)
//
//  History:    04-Aug-92   MikeHew     Modified for new streams
//              22-Sep-92   AmyA        Rewrote for non-NULL term. strings
//
//----------------------------------------------------------------------------

EXPORTIMP unsigned APINOT
CStreamASCIIStr::Read( void* dest, unsigned size )
{
    if ( Eof() )
        return 0;

    unsigned count = (unsigned)(_pEnd-_pCur);
    if ( size < count )
        count = size;

    memcpy ( dest, _pCur, count );
    _pCur += count;
    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\tracheap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       tracheap.h
//
//  Contents:   Heap debugging structures and routines for the heap code
//              in commnot
//
//  History:    28-Oct-92   IsaacHe     Created
//
//----------------------------------------------------------------------------


//
// We keep a stack backtrace for each allocated block of memory.  DEPTHTRACE
// is the number of frames that we record
//
#define DEPTHTRACE   26                 // depth of stack backtraces

//
// The AllocArena structure has this signature at its front.  We put a
// signature on the structure to allow external processes to snapshot the
// debug information and do some minimal check to see they are looking at the
// right stuff
//
const char HEAPSIG[] = { 'H', 'E', 'P', DEPTHTRACE };

// We keep track of the stack backtraces of allocation calls
// in these structues.

struct HeapAllocRec {
        DWORD   sum;            // checksum of stack backtrace
        void *fTrace[ DEPTHTRACE ];     // stack backtrace
        DWORD   count;          // # of un-freed allocs from this place
        size_t  bytes;          // # of un-freed bytes from this place
        struct AllocArena *paa; // points back to the beginning...
        struct {
                DWORD   count;  // # of allocs from this place
                size_t  bytes;  // # of bytes from this place
        } total;
        union {
                struct HeapAllocRec *next; // next bucket in the hash list
                void *ImageBase;        // base addr of containing module
        } u;
};

struct AllocArena {

        char Signature [ sizeof(HEAPSIG) ];
        char comment[ 32 ];
        CRITICAL_SECTION csExclusive;   // ensures single writer

        struct {
                int KeepStackTrace:1;   // are stack records being kept?
        } flags;

        ULONG cAllocs;                  // # of non zero Alloc calls
        ULONG czAllocs;                 // # of Alloc calls w/zero count
        ULONG cFrees;                   // # of Free calls
        ULONG cReAllocs;                // # of realloc calls
        ULONG cMissed;                  // # of missed stack backtraces
        ULONG cRecords;                 // index of next free AllocRec entry
        ULONG cBytesNow;                // # of bytes currently allocated
        unsigned _int64 cBytesTotal;    // # of bytes ever allocated
        ULONG cTotalRecords;            // Total # of AllocRecs
        ULONG cPaths;                   // # of distinct allocation paths

        struct {
                ULONG total[ 32 ];      // total number of allocations
                ULONG now[ 32 ];        // current # of simul allocs
                ULONG simul[ 32 ];      // highest # of simul allocs
        } Histogram;

        struct HeapAllocRec AllocRec[1]; // vector of records starts here..
};

/*
 * Allocators may want to associate one of these structures with every
 * allocation...
 */
struct AHeader {
        struct HeapAllocRec FAR *p;
        size_t size;
};

STDAPI_( struct AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment );

STDAPI_( struct HeapAllocRec FAR * )
AllocArenaRecordAlloc( struct AllocArena *paa, size_t bytes );

STDAPI_(void)
AllocArenaRecordReAlloc( struct HeapAllocRec FAR *vp,
                        size_t oldbytes, size_t newbytes );

STDAPI_(void)
AllocArenaRecordFree( struct HeapAllocRec FAR *vp, size_t bytes );

STDAPI_(void)
AllocArenaDump( struct AllocArena *paa );

STDAPI_( void )
AllocArenaDumpRecord( struct HeapAllocRec FAR *bp );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\andcur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       ANDCUR.CXX
//
//  Contents:   And Cursor.  Computes intersection of multiple cursors.
//
//  Classes:    CAndCursor
//
//  History:    24-May-91   BartoszM    Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "andcur.hxx"

#pragma optimize( "t", on )

//+---------------------------------------------------------------------------
//
//  Member:     CAndCursor::CAndCursor, public
//
//  Synopsis:   Create a cursor that merges a number of cursors.
//
//  Arguments:  [cCursor] -- count of cursors
//              [curStack] -- cursors to merge
//
//  Notes:      All cursors must come from the same index
//              and the same property
//
//  History:    24-May-91   BartoszM    Created
//              22-Feb-93   KyleP       Avoid divide-by-zero
//
//----------------------------------------------------------------------------

CAndCursor::CAndCursor( unsigned cCursor, CCurStack& curStack )
        : _aCur ( curStack.AcqStack() ),
          _cCur ( cCursor ),
          _iCur ( 0 ),
          _lMaxWeight( 0 )
{
    Win4Assert ( _aCur[0] != 0 );

    _iid =  _aCur[0]->IndexId();
    _pid =  _aCur[0]->Pid();

    //
    // Calculate maximum weight of any child.
    //

    for ( UINT i = 0; i < _cCur; i++ )
    {
        _lMaxWeight = max( _lMaxWeight, _aCur[i]->GetWeight() );
    }

    //
    // Avoid divide-by-zero
    //

    if ( _lMaxWeight == 0 )
        _lMaxWeight = 1;

    // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

    _wid = _aCur[0]->WorkId();

    FindConjunction();
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndCursor::~CAndCursor, public
//
//  Synopsis:   Delete the cursor together with children
//
//  History:    24-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

CAndCursor::~CAndCursor( )
{
    for ( unsigned i = 0; i < _cCur; i++ )
        delete _aCur[i];
    delete (void*) _aCur;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    24-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

WORKID CAndCursor::WorkId()
{
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndCursor::NexWorkID, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  History:    24-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

WORKID CAndCursor::NextWorkId()
{
    // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

    _wid = _aCur[0]->NextWorkId();
    FindConjunction();
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndCursor::HitCount, public
//
//  Synopsis:   Returns smallest HitCount of all keys in current wid.
//
//  Requires:   _wid set to any of the current wid's
//
//  Returns:    smallest occurrence count of all keys in wid.
//
//  History:    28-Feb-92   AmyA        Created
//
//  Notes:      If there is no conjunction in current wid, returns 0.
//
//----------------------------------------------------------------------------

ULONG CAndCursor::HitCount()
{
    ULONG count = _aCur[0]->HitCount();

    for ( unsigned i = 1; i < _cCur; i++ )
    {
        ULONG newcount = _aCur[i]->HitCount();

        if ( newcount < count )
            count = newcount;
    }

    return count;
}

void CAndCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    denom = 1;
    num   = 0;

    for (unsigned i=0; i < _cCur; i++)
    {
        ULONG d, n;
        _aCur[i]->RatioFinished(d, n);
        if (d == n)
        {
            // done if any cursor is done.
            denom = d;
            num = n;
            Win4Assert( denom > 0 );
            break;
        }
        else if (d > denom)
        {
            // the one with largest denom
            // is the most meaningful
            denom = d;
            num = n;
        }
        else if (d == denom && n < num )
        {
            num = n;  // be pessimistic
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndCursor::Rank, public
//
//  Synopsis:   Returns smallest rank of all keys in current wid.
//
//  Requires:   _wid set to any of the current wid's
//
//  Returns:    smallest rank of all keys in wid.
//
//  History:    14-Apr-92   AmyA        Created
//              27-Jul-92   KyleP       Use min function for weight
//
//  Notes:      If there is no conjunction in current wid, returns 0.
//
//              See "Automatic Text Processing", G. Salton, 10.4.2 for
//              a discussion of the weight formula.
//
//----------------------------------------------------------------------------

LONG CAndCursor::Rank()
{
    LONG lRank = (MAX_QUERY_RANK - _aCur[0]->Rank()) * _aCur[0]->GetWeight();

    for ( UINT i = 1; i < _cCur; i++ )
    {
        LONG lNew = (MAX_QUERY_RANK - _aCur[i]->Rank()) * _aCur[i]->GetWeight();
        lRank = max( lRank, lNew );
    }

    //
    // Normalize weight.
    //

    lRank = MAX_QUERY_RANK - (lRank / _lMaxWeight);

    return( lRank );
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndCursor::FindConjunction, private
//
//  Synopsis:   Find nearest conjunction of all the same work id's
//
//  Requires:   _wid set to any of the current wid's
//
//  Returns:    TRUE when found, FALSE otherwise
//
//  Modifies:   [_wid] to point to conjunction or to widInvalid
//
//  History:    24-May-91   BartoszM    Created
//
//  Notes:      If cursors are in conjunction, no change results
//
//----------------------------------------------------------------------------

BOOL CAndCursor::FindConjunction()
{
    BOOL fChange;
    do
    {
        fChange = FALSE;

        // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

        // for all cursors in turn

        for ( unsigned i = 0; i < _cCur; i++ )
        {

            // Seek _wid increment cursor to or past current _wid
            // or exit when exhausted

            WORKID widTmp = _aCur[i]->WorkId();

            while ( widTmp < _wid )
            {
                widTmp = _aCur[i]->NextWorkId();

                if ( widInvalid == widTmp )
                {
                    _wid = widInvalid;
                    return FALSE;
                }
            }

            // if overshot, try again with new _wid

            if ( widTmp > _wid )
            {
                _wid = widTmp;
                fChange = TRUE;
                break;
            }
        }
    } while ( fChange );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:      CAndCursor::Hit, public
//
//  Synopsis:    Hits current child (indexed by _iCur)
//
//  History:     07-Sep-92       MikeHew   Created
//
//  Notes:       Hit() should not be called more than once, except by
//               NextHit()
//
//----------------------------------------------------------------------------
LONG CAndCursor::Hit()
{
    Win4Assert( _iCur < _cCur );

    if ( WorkId() == widInvalid )
    {
        return rankInvalid;
    }
    else
    {
        return _aCur[_iCur]->Hit();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:      CAndCursor::NextHit, public
//
//  Synopsis:    NextHits current child (indexed by _iCur)
//               If current child becomes empty, increments _iCur
//
//  History:     07-Sep-92       MikeHew   Created
//
//  Notes:       NextHit() should not be called after returning rankInvalid
//
//----------------------------------------------------------------------------
LONG CAndCursor::NextHit()
{
    Win4Assert( _iCur < _cCur );

    LONG rank = _aCur[_iCur]->NextHit();
    if ( rank == rankInvalid )
    {
        if ( ++_iCur < _cCur )
        {
            return Hit();
        }
    }

    return rank;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\andncur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:   ANDCUR.CXX
//
//  Contents:   And Cursor
//
//  Classes:    CAndCursor
//
//  History:    24-May-91   BartoszM    Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "andncur.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CAndNotCursor::CAndNotCursor, public
//
//  Synopsis:   Create a cursor that takes the wids from the first child and
//              returns only the ones that do not occur in the second child
//
//  Arguments:  [pSourceCur] -- the first child cursor
//              [pFilterCur] -- the second child cursor
//
//  Notes:      All cursors must come from the same index
//              and the same property
//
//  History:    22-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

CAndNotCursor::CAndNotCursor( XCursor & curSource, XCursor & curFilter )
        : _curSource( curSource ),
          _curFilter( curFilter )
{
    _iid =  _curSource->IndexId();
    _pid =  _curSource->Pid();

    _wid = _curSource->WorkId();

    FindDisjunction();

    END_CONSTRUCTION( CAndNotCursor );
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndNotCursor::~CAndNotCursor, public
//
//  Synopsis:   Delete the cursor together with children
//
//  History:    22-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

CAndNotCursor::~CAndNotCursor( )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndNotCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    22-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

WORKID CAndNotCursor::WorkId()
{
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndNotCursor::NextWorkID, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    The next work id of the source that is not in the filter.
//
//  History:    23-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

WORKID       CAndNotCursor::NextWorkId()
{
    _wid = _curSource->NextWorkId();
    FindDisjunction();
    return _wid;
}

void CAndNotCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    _curSource->RatioFinished (denom, num);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndNotCursor::HitCount, public
//
//  Synopsis:   Returns HitCount of the source cursor.
//
//  Requires:   _wid set to any of the current wid's
//
//  Returns:    HitCount of the source cursor.
//
//  History:    23-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

ULONG CAndNotCursor::HitCount()
{
    return _curSource->HitCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndNotCursor::Rank, public
//
//  Synopsis:   Returns Rank of the source cursor.
//
//  Requires:   _wid set to any of the current wid's
//
//  Returns:    Rank of the source cursor.
//
//  History:    23-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

LONG CAndNotCursor::Rank()
{
    return _curSource->Rank();
}

//+---------------------------------------------------------------------------
//
//  Member:     CAndNotCursor::FindDisjunction, private
//
//  Synopsis:   Find the first work id that occurs in the source cursor but
//              not in the filter cursor.
//
//  Requires:   _wid set to any of the current wid's and _widFilter to be set
//              to either a wid in _curFilter or widInvalid.
//
//  Modifies:   [_wid] to point to disjunction or to widInvalid and _widFilter
//              to be greater than _wid or to be widInvalid.
//
//  History:    23-Apr-92   AmyA        Created
//
//  Notes:      If cursors are in disjunction, no change results
//
//----------------------------------------------------------------------------

void CAndNotCursor::FindDisjunction ()
{
    register WORKID widFilter = _curFilter->WorkId();

    while ( _wid != widInvalid )
    {
        while ( widFilter < _wid )
            widFilter = _curFilter->NextWorkId();

        if ( _wid != widFilter )            // Found a disjunction
            return;

        _wid = _curSource->NextWorkId();   // the current wid must occur in
                                            // both cursors, so try again.
    }
}

//+---------------------------------------------------------------------------
//
//  Member:      CAndNotCursor::Hit, public
//
//  Synopsis:    Hits source if filter IsEmpty()
//
//  History:     07-Sep-92       MikeHew   Created
//
//  Notes:       Hit() should not be called more than once
//
//----------------------------------------------------------------------------
LONG CAndNotCursor::Hit()
{
    if ( _curFilter->IsEmpty() )
    {
        return _curSource->Hit();
    }
    else
    {
        return rankInvalid;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:      CAndNotCursor::NextHit, public
//
//  Synopsis:    NextHits source
//
//  History:     07-Sep-92       MikeHew   Created
//
//  Notes:       NextHit() should not be called either Hit() or NextHit()
//               have returned rankInvalid
//
//----------------------------------------------------------------------------
LONG CAndNotCursor::NextHit()
{
    return _curSource->NextHit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\w4io.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//--------------------------------------------------------------------------

/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#ifndef NULL
#  define NULL 0
#endif

struct w4io
{
    union
    {
        struct
        {
            wchar_t *_pwcbuf;   // wchar_t output buffer
            wchar_t *_pwcstart;
        } wc;
        struct
        {
            char *_pchbuf;      // char output buffer
            char *_pchstart;
        } ch;
    } buf ;
    unsigned int cchleft;       // output buffer character count
    void (_cdecl *writechar)(int ch,
                             int num,
                             struct w4io *f,
                             int *pcchwritten);
};

#define pwcbuf          buf.wc._pwcbuf
#define pwcstart        buf.wc._pwcstart
#define pchbuf          buf.ch._pchbuf
#define pchstart        buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\common\trackva.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       trackva.cxx
//
//  Contents:   Track virtual address reservations made through VirtualAlloc
//
//  History:    15-Mar-96   dlee       Created.
//
//  Notes:      No header/tail checking is done in this allocator.
//              Assumes all entry points are called under a lock.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

DECLARE_DEBUG( va );
DECLARE_INFOLEVEL( va );
#define vaDebugOut(x) vaInlineDebugOut x

const unsigned VM_SIZE = 0x80000000;
const unsigned VM_GRANULARITY = 0x00010000;
const unsigned VM_REPORTUNIT  = 2;


inline OffsetInArray( PVOID lpAddr )
{
    return ((ULONG)lpAddr / VM_GRANULARITY) * VM_REPORTUNIT;
}

inline SizeToCount( ULONG cb )
{
    return ((ULONG)(cb + VM_GRANULARITY - 1) / VM_GRANULARITY) * VM_REPORTUNIT;
}

//+-------------------------------------------------------------------------
//
//  Function:   RecordVirtualAlloc, private
//
//  Synopsis:   Record VirtualAlloc Memory reservations in the pbVmTracker
//              array
//
//+-------------------------------------------------------------------------

char * pbVmTracker = 0;

void RecordVirtualAlloc(
    char *      pszSig,
    PVOID       lpAddr,
    DWORD       dwSize)
{
    if (pbVmTracker == 0)
    {
        pbVmTracker = (char*) VirtualAlloc( 0,
                                 (VM_SIZE/VM_GRANULARITY) * VM_REPORTUNIT,
                                            MEM_COMMIT,
                                            PAGE_READWRITE );
        RecordVirtualAlloc( "Vmtracker", pbVmTracker, VM_SIZE/VM_GRANULARITY );
    }

    unsigned iOff = OffsetInArray( lpAddr );
    unsigned cbSize = SizeToCount( dwSize );
 
    char *psz = &pbVmTracker[ iOff ];
    char * pszIn = pszSig;

    while (cbSize--)
    {
        *psz++ = *pszIn++;
        if (*pszIn == '\0')
            pszIn = pszSig;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   TrackVirtualAlloc, public
//
//  Synopsis:   Track VirtualAlloc Memory reservations
//
//+-------------------------------------------------------------------------

PVOID   TrackVirtualAlloc(
    char *      pszSig,
    PVOID       lpAddr,
    DWORD       dwSize,
    DWORD       flAllocationType,
    DWORD       flProtect )
{
    PVOID lpRet = VirtualAlloc( lpAddr, dwSize, flAllocationType, flProtect );

    if ( flAllocationType == MEM_RESERVE ||
         (lpAddr == 0 && flAllocationType == MEM_COMMIT) )
    {
        if ( 0 == lpRet )
        {
//          vaDebugOut(( DEB_WARN,
//                         "VirtualAlloc with MEM_RESERVE for tag %s failed\n",
//                         pszSig ));
        }    
        else
        {
            RecordVirtualAlloc( pszSig, lpRet, dwSize );
        }    
    }
    return lpRet;
}

BOOL   TrackVirtualFree(
    PVOID       lpAddr,
    DWORD       dwSize,
    DWORD       flFreeType )
{
    BOOL fRet = VirtualFree( lpAddr, dwSize, flFreeType );

    if ( !fRet )
    {
//      vaDebugOut(( DEB_WARN,
//                     "VirtualFree( %08x, %08x, %d ) failed\n",
//                     lpAddr, dwSize, flFreeType ));
    }
    else if ( flFreeType == MEM_RELEASE )
    {
        unsigned iOff = OffsetInArray( lpAddr );
        pbVmTracker[ iOff ] = '\0';
    }

    return fRet;
}


PVOID TrackMapViewOfFile (
    char *      pszSig,
    HANDLE hMap,
    DWORD fWrite,
    DWORD offHigh,
    DWORD offLow,
    DWORD cb )
{
    void* buf = MapViewOfFile ( hMap,
                                fWrite,
                                offHigh,
                                offLow,
                                cb );

    if ( 0 != buf )
    {
        RecordVirtualAlloc( pszSig, buf, cb );
    }
    else
    {
//      vaDebugOut(( DEB_WARN,
//                     "MapViewOfFile for tag %s failed\n",
//                     pszSig ));
    }    
    return buf;
}

BOOL   TrackUnmapViewOfFile(
    PVOID       lpAddr )
{
    if ( !UnmapViewOfFile(lpAddr) )
    {
//      vaDebugOut(( DEB_WARN,
//                    "UnMapViewOfFile (%08x) failed\n",
//                    lpAddr ));
        return FALSE;
    }
    else
    {
        unsigned iOff = OffsetInArray( lpAddr );
        pbVmTracker[ iOff ] = '\0';
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\curheap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       CURHEAP.CXX
//
//  Contents:   Implementations for the Cursor Heaps for CMergeCursor,
//              CWlCursor, and CSynCursor.
//
//  History:    20-Jan-92   BartoszM and AmyA  Created
//
//  Notes:      This code was previously located in mcursor.cxx and
//              wlcursor.cxx.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <curheap.hxx>

// Implement CWidHeapOfOccCur, a heap of cursors ordered according to work id's

IMP_HEAP ( CWidHeapOfOccCur, COccCursor, WidLessThan )

IMP_HEAP_KEY ( CWidHeapOfOccCur, COccCursor, WidLessThan, GetCursorWid, WORKID )

// Implement CWidHeap, a heap of cursors ordered according to work id's

IMP_HEAP ( CWidHeap, CCursor, WidLessThan )

IMP_HEAP_KEY ( CWidHeap, CCursor, WidLessThan, GetCursorWid, WORKID )

// Implement COccHeapofOccCur, a heap of cursors ordered according to
// occurrences

IMP_HEAP ( COccHeapOfOccCur, COccCursor, OccLessThan )

IMP_HEAP_KEY ( COccHeapOfOccCur, COccCursor, OccLessThan, GetCursorOcc, OCCURRENCE )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\convert.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       CONVERT.CXX
//
//  Contents:   Restriction to cursor converter
//
//  Classes:    CConverter
//
//  History:    16-Jul-92   MikeHew      Created
//              01-Feb-93   KyleP        Convert restrictions
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <curstk.hxx>
#include <convert.hxx>
#include <ocursor.hxx>
#include <querble.hxx>
#include <cudebug.hxx>

#include "phrcur.hxx"
#include "andcur.hxx"
#include "orcursor.hxx"
#include "veccurs.hxx"
#include "proxcur.hxx"
#include "andncur.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::CConverter, public
//
//  Synopsis:
//
//  Arguments:  [pQuerble]  -- Index
//              [cMaxNodes] -- Maximum number of nodes to build
//
//  History:    15-Jul-92   MikeHew      Created
//
//----------------------------------------------------------------------------

CConverter::CConverter( CQueriable * pQuerble, ULONG cMaxNodes )
        : _pQuerble( pQuerble ),
          _cNodesRemaining( cMaxNodes )
{
} //CConverter

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::QueryCursor, public
//
//  Synopsis:   Walk the query tree, create cursor tree
//
//  Arguments:  [pRst] -- Tree of query restrictions
//
//  History:    15-Jul-92   MikeHew      Created
//
//----------------------------------------------------------------------------

CCursor* CConverter::QueryCursor( CRestriction const * pRst )
{
    //
    // go through leaves, get cursors from index
    // combine them into a cursor tree
    //

    if ( 0 != pRst )
        return ConvertRst( pRst );

    return 0;
} //QueryCursor

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::ConvertRst, private
//
//  Synopsis:   Walk the query tree, create cursor tree
//
//  Arguments:  [pRst] -- Tree of query restrictions
//
//  History:    15-Jul-92   MikeHew      Created
//
//----------------------------------------------------------------------------

CCursor* CConverter::ConvertRst( CRestriction const * pRst )
{
    TRY
    {
        if ( pRst->IsLeaf() )
            return ConvertLeaf ( pRst );

        switch ( pRst->Type() )
        {
        case RTPhrase:
            return ConvertPhraseNode ( pRst->CastToNode() );

        case RTProximity:
            return ConvertProxNode ( pRst->CastToNode() );

        case RTVector:
            return ConvertVectorNode ( pRst->CastToNode() );

        case RTAnd:
        case RTOr:
            return ConvertNode ( pRst->CastToNode() );

        default:
            cuDebugOut(( DEB_ERROR,
                         "Restriction type %d cannot be converted to cursor\n", pRst->Type() ));

            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        }
    }
    CATCH( CException, e )
    {
        if ( !TooManyNodes() )
            RETHROW();
    }
    END_CATCH

    return 0;
} //ConvertRst

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::ConvertPhraseNode, private
//
//  Synopsis:   Convert a phrase node to a COccCursor.
//
//  Arguments:  [pNodeRst] -- Restriction
//
//  Returns:    COccCursor
//
//  History:    19-Sep-91   BartoszM    Created.
//              15-Apr-92   AmyA        Changed from ConvertOccNode and return
//                                      value from CCursor.  Moved code for
//                                      proximity node to ConvertProxNode.
//              16-Jul-92   MikeHew     Yanked out of CQParse and put into
//                                      CConverter
//
//----------------------------------------------------------------------------

COccCursor* CConverter::ConvertPhraseNode( CNodeRestriction const * pNodeRst )
{
    Win4Assert( RTPhrase == pNodeRst->Type() );

    unsigned cChild = pNodeRst->Count();

    if ( cChild == 0 )
        return 0;

    if ( cChild == 1 )
        return ConvertLeaf ( pNodeRst->GetChild(0) );

    COccCurStack curStack ( cChild );

    // Get all the cursors

    for ( unsigned i = 0; i < cChild; i++ )
    {
        CRestriction* pChild = pNodeRst->GetChild(i);
        COccCursor* pCur = ConvertLeaf ( pChild );

        if ( pCur == 0 )
            break;
        curStack.Push( pCur );
    }

    // Combine all the cursors

    unsigned cCur = curStack.Count();

    if ( cCur < cChild )
        return 0;


    XArray<OCCURRENCE> aOcc (cCur);
    CWordRestriction* wordRst = (CWordRestriction*) pNodeRst->GetChild(0);
    OCCURRENCE  occStart = wordRst->Occurrence();

    for ( unsigned k = 0; k < cCur; k++ )
    {
        wordRst = (CWordRestriction*) pNodeRst->GetChild(k);
        aOcc[k] = wordRst->Occurrence() - occStart;
    }

    return new CPhraseCursor( curStack, aOcc );
} //ConvertPhraseNode

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::ConvertProxNode, private
//
//  Synopsis:   Convert a Proximity node into a CCursor.
//
//  Arguments:  [pNodeRst] -- Restriction
//
//  Returns:    CCursor
//
//  History:    15-Apr-92   AmyA        Created.
//              16-Jul-92   MikeHew     Yanked out of CQParse and put into
//                                      CConverter
//
//----------------------------------------------------------------------------
CCursor* CConverter::ConvertProxNode( CNodeRestriction const * pNodeRst )
{
    Win4Assert ( pNodeRst->Type() == RTProximity );

    unsigned cChild = pNodeRst->Count();

    if ( cChild == 0 )
        return 0;

    // We don't support queries like: foo ~ !bar

    if ( cChild == 1 )
    {
        CRestriction * pRst = pNodeRst->GetChild(0);

        if ( pRst->IsLeaf() )
            return ConvertLeaf( pRst );
        else if ( RTPhrase == pRst->Type() )
            return ConvertPhraseNode ( pRst->CastToNode() );
        else
            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

    COccCurStack curStack ( cChild );

    // Get all the cursors

    for ( unsigned i = 0; i < cChild; i++ )
    {
        CRestriction * pChild = pNodeRst->GetChild(i);

        COccCursor * pCur;

        if ( pChild->IsLeaf() )
            pCur = ConvertLeaf( pChild );
        else if ( RTPhrase == pChild->Type() )
            pCur = ConvertPhraseNode ( pChild->CastToNode() );
        else
            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );

        if ( pCur != 0 )
            curStack.Push(pCur);
    }

    // Combine all the cursors

    unsigned cCur = curStack.Count();

    if ( cCur < cChild )
    {
        cuDebugOut (( DEB_ITRACE, "prox:Fewer cursors than expected\n" ));
        return 0;
    }

    return new CProxCursor ( cCur, curStack );
} //ConvertProxNode

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::ConvertAndNotNode, private
//
//  Synopsis:   Convert an And Not node into a CCursor.
//
//  Arguments:  [pNodeRst] -- Restriction
//
//  Returns:    CCursor
//
//  Notes:      Will return 0 if there is not exactly two children nodes.
//
//  History:    22-Apr-92   AmyA        Created.
//              16-Jul-92   MikeHew     Yanked out of CQParse and put into
//                                      CConverter
//
//----------------------------------------------------------------------------

CCursor* CConverter::ConvertAndNotNode( XCursor & curSrc, CCurStack & curNot )
{
    Win4Assert( curNot.Count() > 0 );
    XCursor Cur;

    //
    // Note we should convert (a & b & !c) to (a & ( b & !c ) ),
    //         Also, convert !a & b to b & !a
    // This code has been substantially rewritten in Babylon.
    //

    while ( curNot.Count() > 0 )
    {
        XCursor curFilter( curNot.Pop() );

        //
        // WARNING: Don't put any code between the next two lines if that
        //          code can THROW.
        //

        CCursor * pTemp = new CAndNotCursor( curSrc, curFilter );
        curSrc.Set( pTemp );
    }

    return curSrc.Acquire();
} //ConvertAndNotNode

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::ConvertVectorNode, private
//
//  Synopsis:   Convert an Or, And, or AndNot node into a CCursor.
//
//  Arguments:  [pNodeRst] -- Restriction
//
//  Returns:    CCursor
//
//  History:    21-Oct-92   KyleP       Created.
//
//  Notes:      This function is very similar to ConvertNode.  The main
//              difference is that noise Restrictions have been preserved
//              in the vector input and maintain their position as place
//              holders in the vector.
//
//----------------------------------------------------------------------------

CCursor* CConverter::ConvertVectorNode( CNodeRestriction const * pNodeRst )
{
    unsigned cChild = pNodeRst->Count();

    if ( cChild == 0 )
        return 0;

    CCurStack curStack ( cChild );

    // Get all the cursors

    for ( unsigned i = 0; i < cChild; i++ )
    {
        CRestriction* pChild = pNodeRst->GetChild(i);
        CCursor* pCur = pChild ? ConvertRst ( pChild ) : 0;

        if ( pCur != 0 )
        {
            ULONG wt = pChild->Weight();
            pCur->SetWeight( min( wt, MAX_QUERY_RANK ) );
        }
        curStack.Push(pCur);
    }

    // Combine all the cursors

    Win4Assert( curStack.Count() == cChild );

    return new CVectorCursor( cChild,
                              curStack,
                              ((CVectorRestriction *)
                              pNodeRst)->RankMethod() );
} //ConvertVectorNode

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::ConvertNode, private
//
//  Synopsis:   Convert an Or, And, or AndNot node into a CCursor.
//
//  Arguments:  [pNodeRst] -- Restriction
//
//  Returns:    CCursor
//
//  History:    19-Sep-91   BartoszM    Created.
//              23-Jun-92   MikeHew     Added weight transfering.
//              16-Jul-92   MikeHew     Yanked out of CQParse and put into
//                                      CConverter
//
//----------------------------------------------------------------------------
CCursor* CConverter::ConvertNode( CNodeRestriction const * pNodeRst )
{
    unsigned cChild = pNodeRst->Count();

    if ( cChild == 0 )
        return 0;

    if ( cChild == 1 )
        return ConvertRst ( pNodeRst->GetChild(0) );

    BOOL fNullCursor = FALSE;
    BOOL fNullNotCursor = FALSE;
    CCurStack curStack ( cChild );
    CCurStack curNot( 1 );

    // Get all the cursors

    for ( unsigned i = 0; i < cChild; i++ )
    {
        CRestriction* pChild = pNodeRst->GetChild(i);
        CCursor * pCur = 0;

        if ( pChild->Type() == RTNot )
        {
            pChild = ((CNotRestriction *)pChild)->GetChild();
            pCur = ConvertRst( pChild );

            if ( 0 == pCur )
                fNullNotCursor = TRUE;
            else
                curNot.Push(pCur);
        }
        else
        {
            pCur = ConvertRst( pChild );

            if ( 0 == pCur )
                fNullCursor = TRUE;
            else
                curStack.Push(pCur);
        }

        if ( 0 != pCur )
        {
            ULONG wt = pChild->Weight();
            pCur->SetWeight( min( wt, MAX_QUERY_RANK ) );
        }
    }

    //
    // Combine all the cursors
    //

    unsigned cCur = curStack.Count();

    switch ( pNodeRst->Type() )
    {
        case RTAnd:
        {
            if ( curStack.Count() == 0
                 && !fNullCursor
                 && (curNot.Count() > 0 || fNullNotCursor) )
            {
                //
                // !cat & !dog is an invalid content restriction
                //
                cuDebugOut(( DEB_ERROR,
                             "Content AND combined with only NOT nodes\n" ));
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
            }

            if ( fNullCursor || curStack.Count() == 0 )
                return 0;

            XCursor cur;

            if ( curStack.Count() == 1 )
                cur.Set( curStack.Pop() );
            else
                cur.Set( new CAndCursor ( cCur, curStack ) );

            if ( curNot.Count() > 0 )
                return( ConvertAndNotNode( cur, curNot ) );
            else
                return( cur.Acquire() );
        }

        case RTOr:
        {
            if ( curNot.Count() > 0 )
            {
                cuDebugOut(( DEB_ERROR,
                             "Content NOT combined with OR node.  Must be AND.\n",
                             pNodeRst->Type() ));
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
            }

            if ( 0 == cCur )
                return 0;

            if ( cCur == 1 )
                return curStack.Pop();

            return new COrCursor ( cCur, curStack );
        }

        default:
            cuDebugOut(( DEB_ERROR,
                         "Restriction type %d not implemented\n",
                         pNodeRst->Type() ));
            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

    return 0;
} //ConvertNode

//+---------------------------------------------------------------------------
//
//  Member:     CConverter::ConvertLeaf, private
//
//  Synopsis:   Convert a leaf node to a cursor
//
//  Arguments:  [pNodeRst] -- Restriction
//
//  Returns:    cursor
//
//  History:    19-Sep-91   BartoszM    Created.
//              16-Jul-92   MikeHew     Yanked out of CQParse and put into
//                                      CConverter
//
//----------------------------------------------------------------------------

COccCursor* CConverter::ConvertLeaf( CRestriction const * pRst )
{
    if ( TooManyNodes() )
    {
        ciDebugOut(( DEB_WARN, "Node limit reached (detected) in CConverter::ConverLeaf.\n" ));
        THROW( CException( STATUS_TOO_MANY_NODES ) );
    }

    switch ( pRst->Type() )
    {
    case RTWord:
    {
        CWordRestriction* wordRst = (CWordRestriction*) pRst;
        const CKey* pKey = wordRst->GetKey();
        return _pQuerble->QueryCursor( pKey, wordRst->IsRange(), _cNodesRemaining );
    }
    case RTSynonym:
    {
        CSynRestriction* pSynRst = (CSynRestriction*) pRst;
        CKeyArray& keyArray = pSynRst->GetKeys();

        return _pQuerble->QuerySynCursor ( keyArray, pSynRst->IsRange(), _cNodesRemaining );
    }
    case RTRange:
    {
        CRangeRestriction* pRangRst = (CRangeRestriction*) pRst;

        COccCursor * pCursor = _pQuerble->QueryRangeCursor ( pRangRst->GetStartKey(),
                                                             pRangRst->GetEndKey(),
                                                             _cNodesRemaining );
        if( 0 != pCursor && pidUnfiltered == pRangRst->Pid() )
            pCursor->SetUnfilteredOnly( TRUE );
    
        return pCursor;
    }
    default:
        cuDebugOut(( DEB_ITRACE, "Wrong type for occurrence leaf\n" ));
        return 0;
    }
} //ConvertLeaf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\cursor.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       Cursor.Cxx
//
//  Contents:   Cursor classes
//
//  Classes:    CCursor
//
//  History:    15-Apr-91   KyleP       Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

DECLARE_INFOLEVEL ( cu )

//+---------------------------------------------------------------------------
//
//  Member:     CCursor::WorkIdCount, public
//
//  Returns:    Estimated work id count (if possible) ???
//
//  History:    27-Sep-91   BartoszM    Created.
//
//----------------------------------------------------------------------------

ULONG CCursor::WorkIdCount() { return(0); }

//+-------------------------------------------------------------------------
//
//  Member:     CCursor::GetWeightVector, public
//
//  Effects:    Returns the weights from a vector cursor.  No effect
//              for non-vector cursors.
//
//  Arguments:  [pulVector] -- Pointer to array of ULONG into which the
//                             vector elements are returned.
//
//  Returns:    The number of elements stored in [pulVector].
//
//  History:    15-Jul-92 KyleP     Created
//
//  Notes:      This method only does something interesting for the
//              vector cursor.  For the vector cursor, it returns the
//              individual ranks for each element of the vector in
//              addition to the composite rank.
//
//--------------------------------------------------------------------------

ULONG CCursor::GetRankVector( LONG *, ULONG )
{
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\orcursor.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2001.
//
//  File:       ORCURSOR.CXX
//
//  Contents:   Merge Cursor.  Computes union of multiple cursors.
//
//  Classes:    COrCursor
//
//  History:    26-Sep-91   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <orcursor.hxx>
#include <curstk.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     COrCursor::COrCursor, public
//
//  Synopsis:   Create a sursor that merges a number of cursors.
//
//  Arguments:  [cCursor] -- count of cursors
//              [curStack] -- cursors to be merged
//
//  History:    26-Sep-91   BartoszM    Created
//              14-Jul-92   KyleP       Use max function for Rank
//              22-Feb-93   KyleP       Avoid divide-by-zero
//
//  Notes:      The cursors and the array will be deleted by destructor.
//              The cursors have to come from one index
//
//----------------------------------------------------------------------------

COrCursor::COrCursor( int cCursor, CCurStack& curStack )
        : _lMaxWeight( 0 ), _iCur( 0 ), _wid( widInvalid )
{
    // Two step construction of the heap.
    // We have to make sure that all cursors have a valid key

    int count = 0;
    CCursor** aCursor = curStack.AcqStack();

    // remove empty cursors
    for ( int i = 0; i < cCursor; i++ )
    {
        Win4Assert ( aCursor[i] != 0 );
        if ( aCursor[i]->WorkId() == widInvalid )
        {
            delete aCursor[i];
        }
        else
        {
            _lMaxWeight = max( _lMaxWeight, aCursor[i]->GetWeight() );
            if ( count != i )
                aCursor[count++] = aCursor[i];
            else
                count++;
        }
    }

    //
    // Avoid divide-by-zero
    //

    if ( _lMaxWeight == 0 )
        _lMaxWeight = 1;

    _widHeap.MakeHeap ( count, aCursor );
    if ( !_widHeap.IsEmpty() )
    {
        CCursor & cursor = * _widHeap.Top();

        _wid = cursor.WorkId();
        _iid = cursor.IndexId();
        _pid = cursor.Pid();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COrCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    26-Sep-91   BartoszM    Created
//
//----------------------------------------------------------------------------

WORKID COrCursor::WorkId()
{
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     COrCursor::NextWorkId, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  History:    26-Sep-91   BartoszM    Created
//
//----------------------------------------------------------------------------

WORKID COrCursor::NextWorkId()
{
    if ( widInvalid == _wid )
        return widInvalid;

    WORKID widNew;

    do
    {
        _widHeap.Top()->NextWorkId();

        _widHeap.ReheapKey();

        widNew = _widHeap.Top()->WorkId();
    }
    while ( widNew == _wid );

    _wid = widNew;

    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     COrCursor::WorkIdCount, public
//
//  Synopsis:   return wid count
//
//  History:    26-Sep-91   BartoszM    Created
//
//  Notes:      1. Sum up wid count of all cursors in widHeap
//
//----------------------------------------------------------------------------

ULONG COrCursor::WorkIdCount()
{
    Win4Assert (( FALSE && "OrCursor::WorkIdCount called" ));
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     COrCursor::HitCount, public
//
//  Synopsis:   return occurrence count
//
//  History:    28-Feb-92   AmyA        Created
//
//  Notes:      returns the occurrence count for the wid on top of _widHeap.
//
//----------------------------------------------------------------------------

ULONG COrCursor::HitCount()
{
    if ( widInvalid == _wid )
        return 0;

    ULONG hitCnt = 0;

    CCursor **vector = _widHeap.GetVector();
    int count = _widHeap.Count();

    for (int i=0; i < count; i++)
    {
        if ( vector[i]->WorkId() == _wid )
            hitCnt += vector[i]->HitCount();
    }

    return hitCnt;
}

//+---------------------------------------------------------------------------
//
//  Member:     COrCursor::RatioFinished, public
//
//  Synopsis:   return approximate ratio of documents processed to total
//              documents.
//
//  Notes:      The ratio, while approximate, should not return 1/1 until
//              all cursors are exhausted.
//
//----------------------------------------------------------------------------

void COrCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    if ( widInvalid == _wid )
    {
        denom = num = 1;
        return;
    }

    CCursor **vector = _widHeap.GetVector();
    int count = _widHeap.Count();
    unsigned cValid = 1;

    denom = 0;
    num   = 0;

    for (int i=0; i < count; i++)
    {
        ULONG d, n;
        vector[i]->RatioFinished(d, n);
        Win4Assert( n <= d && d > 0 );

        num += n;
        denom += d;
        Win4Assert( d <= denom );       // overflow?

        if (n == d)
        {
            WORKID widCurrent = vector[i]->WorkId();
            if (widCurrent != widInvalid && widCurrent != _wid)
                cValid++;
        }
    }
    if (num == denom && cValid > 1)
        denom++;
}

//+---------------------------------------------------------------------------
//
//  Member:     COrCursor::Rank, public
//
//  Synopsis:   returns a rank (turns the OrCursor into a Quorum Cursor)
//
//  History:    13-Apr-92   AmyA        Created
//              23-Jun-92   MikeHew     Added Weighting
//              14-Jul-92   KyleP       Use max function for Rank
//
//  Notes:      See "Automatic Text Processing", G. Salton, 10.4.2 for
//              a discussion of the weight formula.
//
//----------------------------------------------------------------------------

LONG COrCursor::Rank()
{
    if ( widInvalid == _wid )
        return 0;

    LONG lRank = 0;
    CCursor **vector = _widHeap.GetVector();

    int cCur = _widHeap.Count();

    for ( int i = 0; i < cCur; i++ )
    {
        if ( vector[i]->WorkId() == _wid )
        {
            LONG lNew = vector[i]->Rank() * vector[i]->GetWeight();
            lRank = max( lRank, lNew );
        }
    }

    //
    // Normalize weight.
    //

    lRank = lRank / _lMaxWeight;

    return ( lRank );
}

//+---------------------------------------------------------------------------
//
//  Member:      COrCursor::Hit, public
//
//  Synopsis:    Hits current child (indexed by _iCur)
//               Moves onto next child if empty.
//
//  History:     07-Sep-92       MikeHew   Created
//
//  Notes:       Hit() should not be called more than once, except by
//               NextHit()
//
//----------------------------------------------------------------------------
LONG COrCursor::Hit()
{
    int cCur        = _widHeap.Count();
    CCursor ** aCur = _widHeap.GetVector();

    Win4Assert( _iCur < cCur );

    LONG rank = aCur[_iCur]->Hit();

    // if this cursor is empty, find one that's not

    while ( rank == rankInvalid &&
            ++_iCur < cCur )
    {
        rank = aCur[_iCur]->Hit();
    }

    return rank;
}

//+---------------------------------------------------------------------------
//
//  Member:      COrCursor::NextHit, public
//
//  Synopsis:    NextHits current child (indexed by _iCur)
//               If current child becomes empty, increments _iCur
//
//  History:     07-Sep-92       MikeHew   Created
//
//  Notes:       NextHit() should not be called after returning rankInvalid
//
//----------------------------------------------------------------------------
LONG COrCursor::NextHit()
{
    int cCur       = _widHeap.Count();
    CCursor ** aCur = _widHeap.GetVector();

    Win4Assert( _iCur < cCur );

    LONG rank = aCur[_iCur]->NextHit();
    if ( rank == rankInvalid )
    {
        if ( ++_iCur < cCur )
        {
            return Hit();
        }
    }

    return rank;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\phrcur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       PHRCUR.CXX
//
//  Contents:   Phrase Cursor.  Computes intersection of multiple cursors
//              with constraints on occurrances.
//
//  Classes:    CPhraseCursor
//
//  History:    24-May-91   BartoszM    Created.
//              19-Feb-92   AmyA        Modified to be a COccCursor instead of
//                                      a CCursor.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <misc.hxx>
#include <curstk.hxx>
#include <cudebug.hxx>

#include "phrcur.hxx"

#pragma optimize( "t", on )

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::CPhraseCursor, public
//
//  Synopsis:   Create a cursor that merges a number of cursors.
//
//  Arguments:
//              [curStack] -- cursors to be merged
//              [aOcc] -- a safe array of OCCURRENCEs for the cursors
//
//  Notes:      All cursors must come from the same index
//              all keys have the same property id
//
//  History:    24-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

CPhraseCursor::CPhraseCursor( COccCurStack& curStack, XArray<OCCURRENCE>& aOcc )
      : COccCursor(curStack.Get(0)->MaxWorkId()),
        _cCur(aOcc.Count()),
        _aCur(curStack.AcqStack()),
        _cOcc(0),
        _maxOcc(OCC_INVALID)
{
    _aOcc = aOcc.Acquire();
    _iid = _aCur[0]->IndexId();
    _pid = _aCur[0]->Pid();
    _wid = _aCur[0]->WorkId();
    _logWidMax = Log2(_widMax);
    if (FindPhrase())
        _cOcc++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::~CPhraseCursor, public
//
//  Synopsis:   Deletes children
//
//  History:    24-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

CPhraseCursor::~CPhraseCursor()
{
    for ( unsigned i=0; i < _cCur; i++)
    {
        delete _aCur[i];
    }
    delete _aCur;
    delete _aOcc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    24-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

WORKID CPhraseCursor::WorkId()
{
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::NextWorkID, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  History:    24-May-91   BartoszM    Created
//
//  Notes:      Resets _cOcc
//
//----------------------------------------------------------------------------

WORKID       CPhraseCursor::NextWorkId()
{
    _cOcc =  0;

    // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

    _wid = _aCur[0]->NextWorkId();
    _pid = _aCur[0]->Pid();
    if (FindPhrase())
        _cOcc++;
    return _wid;
}

void CPhraseCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    denom = 1;
    num   = 0;

    for (unsigned i = 0; i < _cCur; i++)
    {
        ULONG d, n;
        _aCur[i]->RatioFinished(d, n);

        if (d == n)
        {
            // done if any cursor is done.
            denom = d;
            num = n;
            Win4Assert( d > 0 );
            break;
        }
        else if (d > denom)
        {
            // the one with largest denom
            // is the most meaningful
            denom = d;
            num = n;
        }
        else if (d == denom && n < num )
        {
            num = n;  // be pessimistic
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::FindPhrase, private
//
//  Synopsis:   Find nearest phrase. First try to align wid's,
//              Then align occurrences. Loop until success
//              or no more wid alignments.
//
//  Requires:   _wid set to any of the current wid's
//
//  History:    24-May-91   BartoszM    Created
//
//  Notes:      If cursors point to phrase, no change results
//
//----------------------------------------------------------------------------

BOOL CPhraseCursor::FindPhrase ()
{
    if ( _wid == widInvalid )
    {
        _occ = OCC_INVALID;
        return FALSE;
    }

    while ( FindWidConjunction() && !FindOccConjunction() )
    {
        _wid = _aCur[0]->NextWorkId();
        _pid = _aCur[0]->Pid();
    }

    if ( _occ != OCC_INVALID )
        return TRUE;
    else
        return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::NextOccurrence, public
//
//  Synopsis:   Find phrase for next conjunction of work id's and return _occ
//
//  Requires:   _occ set to any of the cursors' occurrences
//
//  History:    03-Mar-92   AmyA        Created
//
//  Notes:      Increments _cOcc unless another occurrence is not found.
//
//----------------------------------------------------------------------------

OCCURRENCE CPhraseCursor::NextOccurrence()
{
    _occ = _aCur[0]->NextOccurrence();

    if (FindOccConjunction())
        _cOcc++;
    return _occ;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::OccurrenceCount, public
//
//  Synopsis:   Returns correct _cOcc by looping through NextOccurrence until
//              it returns OCC_INVALID.
//
//  Requires:   _occ set to any of the cursors' occurrences
//
//  History:    28-Feb-92   AmyA        Created
//
//  Notes:      _occ may get changed.
//
//----------------------------------------------------------------------------

ULONG CPhraseCursor::OccurrenceCount()
{
    while (NextOccurrence() != OCC_INVALID)
    {
        // do nothing.
    }
    return _cOcc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::MaxOccurrence
//
//  Synopsis:   Returns max occurrence count of current wid
//
//  History:    26-Jun-96    SitaramR        Created
//
//----------------------------------------------------------------------------

OCCURRENCE CPhraseCursor::MaxOccurrence()
{
    Win4Assert( _wid != widInvalid );

    if ( _wid == widInvalid )
        return OCC_INVALID;
    else return _maxOcc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::HitCount, public
//
//  Synopsis:   Returns correct _cOcc by looping through NextOccurrence until
//              it returns OCC_INVALID.
//
//  Requires:   _occ set to any of the cursors' occurrences
//
//  History:    28-Feb-92   AmyA        Created
//
//  Notes:      _occ may get changed.
//
//----------------------------------------------------------------------------

ULONG CPhraseCursor::HitCount()
{
    return OccurrenceCount();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::FindOccConjunction, private
//
//  Synopsis:   Find phrase for current conjunction of work id's
//
//  Requires:   _occ set to any of the cursors' occurrences
//
//  History:    24-May-91   BartoszM    Created
//
//----------------------------------------------------------------------------

BOOL CPhraseCursor::FindOccConjunction ()
{
    if ( _occ == OCC_INVALID )
        return FALSE;

    unsigned i;

    do
    {
        // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

        for ( i = 0; i < _cCur; i++ )
        {
            // Iterate until we have a matching occurrence

            OCCURRENCE occTarget = _occ + _aOcc[i];

            cuDebugOut(( DEB_ITRACE, "cursor %d, _occ %d, target %d, _pid %d\n", i, _occ, occTarget, _pid ));

            OCCURRENCE occTmp = _aCur[i]->Occurrence();

            while ( occTmp < occTarget )
            {
                occTmp = _aCur[i]->NextOccurrence();

                if ( OCC_INVALID == occTmp )
                {
                    _occ = OCC_INVALID;
                    return FALSE;
                }
            }

            // Keep looping until the pid matches

            while ( occTmp == occTarget &&
                    _aCur[i]->Pid() < _pid )
            {
                cuDebugOut(( DEB_ITRACE, "looking for matching pid\n" ));

                occTmp = _aCur[i]->NextOccurrence();

                if ( OCC_INVALID == occTmp )
                {
                    _occ = OCC_INVALID;
                    return FALSE;
                }
            }

            // if overshot, try again with new _occ

            if ( occTmp > occTarget )
            {
                cuDebugOut(( DEB_ITRACE, "overshot occ\n" ));

                _occ = _aCur[i]->Occurrence() - _aOcc[i];
                break;
            }

            Win4Assert( _aCur[i]->Occurrence() == occTarget );

            if ( _aCur[i]->Pid() > _pid )
            {
                cuDebugOut(( DEB_ITRACE, "overshot pid, cur %d, _pid %d\n", _aCur[i]->Pid(), _pid ));

                //
                // This pid just won't do.  Move cursor 0 to the next
                // occurrence, use that pid, and start all over.
                //

                if ( _aCur[0]->NextOccurrence() == OCC_INVALID )
                {
                    _occ = OCC_INVALID;
                    return FALSE;
                }

                _occ = _aCur[0]->Occurrence();
                _pid = _aCur[0]->Pid();
                break;
            }
        }
    } while ( i < _cCur );

    return TRUE;
} //FindOccConjunction

//+---------------------------------------------------------------------------
//
//  Member:     CPhraseCursor::FindWidConjunction, private
//
//  Synopsis:   Find nearest conjunction of all the same work id's
//
//  Requires:   _wid set to any of the current wid's
//
//  History:    24-May-91   BartoszM    Created
//
//  Notes:      If cursors are in conjunction, no change results
//
//----------------------------------------------------------------------------

BOOL CPhraseCursor::FindWidConjunction ()
{
    if ( _wid == widInvalid )
        return FALSE;

    BOOL change;

    do
    {
        change = FALSE;

        // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

        for ( unsigned i = 0; i < _cCur; i++ )
        {
            // Seek _wid

            WORKID widTmp = _aCur[i]->WorkId();

            while ( widTmp < _wid )
            {
                widTmp = _aCur[i]->NextWorkId();

                if ( widInvalid == widTmp )
                {
                    _wid = widInvalid;
                    _pid = pidInvalid;
                    _occ = OCC_INVALID;
                    return FALSE;
                }
            }

            if ( widTmp > _wid ) // overshot!
            {
                _wid = widTmp;
                _pid = _aCur[i]->Pid();

                change = TRUE;
                break;
            }
        }
    } while ( change );

    _occ = _aCur[0]->Occurrence();
    _maxOcc = _aCur[0]->MaxOccurrence();

    return TRUE;
} //FindWidConjunction

//+---------------------------------------------------------------------------
//
//  Member:      CPhraseCursor::Hit(), public
//
//  Synopsis:
//
//  Arguments:
//
//  History:     17-Sep-92       MikeHew   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG CPhraseCursor::Hit()
{
    if ( _occ == OCC_INVALID )
    {
        return rankInvalid;
    }

    for (unsigned i=0; i<_cCur; i++)
    {
        _aCur[i]->Hit();
    }

    return MAX_QUERY_RANK;
}

//+---------------------------------------------------------------------------
//
//  Member:      CPhraseCursor::NextHit(), public
//
//  Synopsis:
//
//  Arguments:
//
//  History:     17-Sep-92       MikeHew   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG CPhraseCursor::NextHit()
{
    NextOccurrence();

    return Hit();
}


//+---------------------------------------------------------------------------
//
//  Member:      CPhraseCursor::Rank(), public
//
//  Synopsis:    Returns phrase rank
//
//  History:     23-Jun-94       SitaramR created
//
//  Notes:       rank = HitCount*Log(_widMax/widCount). We make the
//               assumption that the phrase appears in this and this
//               document only, ie widcount = 1
//
//----------------------------------------------------------------------------
LONG CPhraseCursor::Rank()
{
    Win4Assert( MaxOccurrence() != 0 );

    LONG rank = RANK_MULTIPLIER * HitCount() * _logWidMax / MaxOccurrence();
    if (rank > MAX_QUERY_RANK)
      rank = MAX_QUERY_RANK;

    return rank;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\curstk.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       curarr.cxx
//
//  Contents:   Cursor Stack Classes
//
//  Classes:    COccCurStack, and CCurStack
//
//  History:    20-Jan-92       AmyA               Created
//              05-Feb-92       BartoszM           Added CCurArray
//              19-Feb-92       AmyA               Added COccCurArray
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ocursor.hxx>
#include <curstk.hxx>

#include "syncur.hxx"

COccCursor* COccCurStack::QuerySynCursor( WORKID widMax )
{
    if (Count() == 0)
        return 0;

    if (Count() == 1)
        return Pop();

    return new CSynCursor( *this, widMax );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\proxcur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:        PROXCUR.CXX
//
//  Contents:   Proximity Cursor.  Computes intersection of multiple
//              cursors with rank computed based on word occurrance
//              proximity.
//
//  Classes:    CProxCursor
//
//  History:    14-Apr-92   AmyA        Created.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <misc.hxx>
#include <curstk.hxx>

#include "proxcur.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CProxCursor::CProxCursor, public
//
//  Synopsis:   Create a cursor that merges a number of cursors.
//
//  Arguments:  [cCursor] -- count of cursors
//              [curArray] -- pointers to cursors (aquired to an array)
//              [maxDist] -- the maximum distance between occurrences
//
//  Notes:      All cursors must come from the same index
//              and the same property
//
//  History:    15-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

CProxCursor::CProxCursor( unsigned cCursor,
                          COccCurStack& curStack,
                          LONG maxDist )
: _cCur ( cCursor ),
  _maxDist ( maxDist ),
  _rank ( rankInvalid )
{
    COccCursor *pCur = curStack.Get(0);
    _occHeap.MakeHeap  ( _cCur, curStack.AcqStack() );

    Win4Assert ( pCur != 0 );

    _iid =  pCur->IndexId();
    _pid =  pCur->Pid();

    // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

    _wid = pCur->WorkId();
    _logWidMax = Log2(pCur->MaxWorkId());

    FindConjunction();

}

//+---------------------------------------------------------------------------
//
//  Member:     CProxCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    17-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

WORKID CProxCursor::WorkId()
{
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProxCursor::NextWorkID, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  History:    17-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

WORKID       CProxCursor::NextWorkId()
{
    _rank = rankInvalid;

    // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

    _wid = _occHeap.Top()->NextWorkId();
    FindConjunction();
    return _wid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProxCursor::HitCount, public
//
//  Synopsis:   Returns smallest HitCount of all keys in current wid.
//
//  Requires:   _wid set to any of the current wid's
//
//  Returns:    smallest occurrence count of all keys in wid.
//
//  History:    17-Apr-92   AmyA        Created
//
//  Notes:      If there is no conjunction in current wid, returns 0.
//
//----------------------------------------------------------------------------

ULONG CProxCursor::HitCount()
{
    if ( _rank == rankInvalid )
        _rank = CalculateRank();    // This needs to be called before HitCount
                                    // so taht the occurrence information in
                                    // the children cursors will be valid when
                                    // its called.

    COccCursor **aCur = _occHeap.GetVector();

    ULONG count = aCur[0]->HitCount();

    for ( unsigned i = 1; i < _cCur; i++ )
    {
        ULONG newcount = aCur[i]->HitCount();

        if ( newcount < count )
            count = newcount;
    }

    return count;
}

void CProxCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    COccCursor **vector = _occHeap.GetVector();

    denom = 1;
    num   = 0;

    for (unsigned i=0; i < _cCur; i++)
    {
        ULONG d, n;
        vector[i]->RatioFinished(d, n);
        if (d == n)
        {
            // done if any cursor is done
            denom = d;
            num = n;
            Win4Assert( denom > 0 );
            break;
        }
        else if (d > denom)
        {
            // the one with largest denom
            // is the most meaningful
            denom = d;
            num = n;
        }
        else if (d == denom && n < num )
        {
            num = n;  // be pessimistic
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProxCursor::Rank, public
//
//  Synopsis:   Checks to see if CalculateRank has been called.  If not, calls
//              it.
//
//  Requires:   _wid set to any of the current wid's
//
//  Returns:    _rank
//
//  History:    20-Apr-92   AmyA        Created
//
//----------------------------------------------------------------------------

LONG CProxCursor::Rank()
{
    if ( _rank == rankInvalid )
        _rank = CalculateRank();

    return _rank;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProxCursor::FindConjunction, private
//
//  Synopsis:   Find nearest conjunction of all the same work id's
//
//  Requires:   _wid set to any of the current wid's
//
//  Modifies:   [_wid] to point to conjunction or to widInvalid
//
//  History:    15-Apr-92   AmyA        Copied from CAndCursor.
//
//  Notes:      If cursors are in conjunction, no change results
//
//----------------------------------------------------------------------------

void CProxCursor::FindConjunction ()
{
    BOOL change;
    COccCursor **aCur = _occHeap.GetVector();
    do {
        change = FALSE;

        // NTRAID#DB-NTBUG9-84004-2000/07/31-dlee Indexing Service internal cursors aren't optimized to use shortest cursors first

        // for all cursors in turn try to align them on _wid

        for ( unsigned i = 0; i < _cCur; i++ )
        {

            // increment cursor to or past current _wid
            // or exit when exhausted

            while ( aCur[i]->WorkId() < _wid )
            {
                if ( aCur[i]->NextWorkId() == widInvalid )
                {
                    _wid = widInvalid;
                    return;
                }
            }

            // if overshot, try again with new _wid

            if ( aCur[i]->WorkId() > _wid )
            {
                _wid = aCur[i]->WorkId();
                change = TRUE;
                break;
            }
        }

    } while ( change );
}

//+---------------------------------------------------------------------------
//
//  Member:     CProxCursor::CalculateRank, private
//
//  Synopsis:   Assigns a rank based on the shortest distance between an
//              occurrence of each child.
//
//  Requires:   _wid set to any of the current wid's, at least two child
//              cursors.
//
//  Returns:    calculated rank
//
//  History:    17-Apr-92   AmyA        Created
//
//  Notes:      If there is no conjunction in current wid, returns 0.
//
//              New Rank computation:
//                 rank = cOcc*Log2(_widMax)*normalizedProximity(distMin)
//                 where,
//                     cOcc = hits_with_dist(distMin)
//                     where normalizedProximity(i) = ProxDefault[i]/MAX_QUERY_RANK
//
//----------------------------------------------------------------------------

//  The idea is that we are looking for the combination of occurrences (one
//  for each child cursor) that is closest together for the current wid.  To
//  do this, we only need to look at two of the child cursors from a set: the
//  one with the smallest occurrence and the one furthest from it.  We look
//  at these sets in a loop, getting the next occurrence on the cursor with
//  the smallest occurrence, then reheaping to find the new smallest
//  occurrence, and then finding the occurrence furthest from it.  By getting
//  the next occurrence on the cursor with the smallest occurrence, we are
//  guaranteeing that we will not skip  over a set of cursors that are closer
//  together.  If you need proof of this, draw a picture with the cursors
//  represented as parallel lines and the occurrences as hash marks on those
//  lines and step through the algorithm.  Remember that we start this
//  function while all the child cursors are at thier smallest occurrence
//  within the current wid, since this function needs to be called before any
//  work with occurrences is done within a wid.

LONG CProxCursor::CalculateRank()
{
    Win4Assert ( _cCur >= 2 );

    ULONG distMin = _maxDist + 1;
    unsigned cOcc = 0;     // #hits at distMin

    // loop through occurrence combinations to find the set of occurrences
    // for different cursors that are the closest together
    do
    {
        // Get smallest occurrence
        _occHeap.Reheap();
        OCCURRENCE smallOcc = _occHeap.Top()->Occurrence();

        COccCursor **aCur = _occHeap.GetVector();

        OCCURRENCE largeOcc = aCur[1]->Occurrence();

        // loop through all occurrences (except the first, which is the
        // smallest and the second) to find the occurrence furthest from the
        // smallest.

        for ( unsigned count = 2; count < _cCur; count++ )
        {
            OCCURRENCE newOcc = aCur[count]->Occurrence();
            if ( newOcc > largeOcc )
                largeOcc = newOcc;
        }

        if (largeOcc - smallOcc < PROX_MAX)
        {
            if (largeOcc - smallOcc < distMin)
            {
              distMin = largeOcc - smallOcc;
              cOcc = 1;     // reset # hits
            } else if (largeOcc - smallOcc == distMin) {
              cOcc++;
            }
        }  // else children are too far apart to affect rank


        // get the next occurrence on the cursor with the smallest occurrence
    } while ( _occHeap.Top()->NextOccurrence() != OCC_INVALID );

    if (distMin >= PROX_MAX) {
        return(0);
    }
    LONG rank = cOcc * _logWidMax * ProxDefault[distMin] / MAX_QUERY_RANK;
    if (rank > MAX_QUERY_RANK) {
      rank = MAX_QUERY_RANK;
    }
    return rank;
}

//+---------------------------------------------------------------------------
//
//  Member:      CProxCursor::Hit, public
//
//  Synopsis:    Hits current child (indexed by _iCur)
//
//  History:     07-Sep-92       MikeHew   Created
//
//  Notes:       Hit() should not be called more than once, except by
//               NextHit()
//
//               The occurrence heap is assumed valid upon entry, and remains
//               valid on exit.
//
//----------------------------------------------------------------------------
LONG CProxCursor::Hit()
{
    Win4Assert ( _cCur >= 2 );
    COccCursor **aCur = _occHeap.GetVector();

    // Make sure none of the cursors are empty

    for ( unsigned i=0; i<_cCur; ++i )
    {
        if ( aCur[i]->IsEmpty() )
            return rankInvalid;
    }

    // Starting with smallest occurrence, loop through all cursors,
    // Hitting() each one and searching for the largest occurrence.

    OCCURRENCE largeOcc = _occHeap.Top()->Occurrence();
    OCCURRENCE smallOcc = largeOcc;

    for ( i=0; i<_cCur; ++i )
    {
        aCur[i]->Hit();

        OCCURRENCE thisOcc = aCur[i]->Occurrence();

        if ( thisOcc > largeOcc )
        {
            largeOcc = thisOcc;
        }

        // get the next occurrence on the cursor with the smallest occurrence
    }

    unsigned dist = largeOcc - smallOcc;

    if (dist >= PROX_MAX)
        return(0);
    return ProxDefault[dist];
}

//+---------------------------------------------------------------------------
//
//  Member:      CProxCursor::NextHit, public
//
//  Synopsis:    calls NextOccurrence() on smallest child, then
//               returns Hit() if NextOccurrence() is valid
//
//  History:     07-Sep-92       MikeHew   Created
//
//  Notes:       NextHit() should not be called after returning rankInvalid
//
//----------------------------------------------------------------------------
LONG CProxCursor::NextHit()
{
    if ( _occHeap.Top()->NextOccurrence() == OCC_INVALID )
    {
        return rankInvalid;
    }

    _occHeap.Reheap();

    return Hit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\proxtab.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       proxtab.cxx
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "proxcur.hxx"

unsigned ProxDefault[PROX_MAX] = {
1000,  996,  986,  970,  948,  920,  886,  849,  807,  763,
 716,  668,  618,  569,  520,  472,  425,  381,  339,  300,
 263,  229,  199,  171,  146,  124,  105,   88,   73,   60,
  49,   40,   32,   26,   21,   16,   13,   10,    8,    6,
   4,    3,    2,    2,    1,    1,    0,    0,    0,    0
};

/*

 x = 1000. * exp ( - n * n / 300.);

1000, **************************************************
 996, *************************************************
 986, *************************************************
 970, ************************************************
 948, ***********************************************
 920, **********************************************
 886, ********************************************
 849, ******************************************
 807, ****************************************
 763, **************************************
 716, ***********************************
 668, *********************************
 618, ******************************
 569, ****************************
 520, **************************
 472, ***********************
 425, *********************
 381, *******************
 339, ****************
 300, ***************
 263, *************
 229, ***********
 199, *********
 171, ********
 146, *******
 124, ******
 105, *****
  88, ****
  73, ***
  60, ***
  49, **
  40, **
  32, *
  26, *
  21, *
  16,
  13,
  10,
   8,
   6,
   4,
   3,
   2,
   2,
   1,
   1,
   0,
   0,
   0,
   0,

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\syncur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       SYNCUR.CXX
//
//  Contents:   Merge Cursor for multiple keys
//
//  Classes:    CSynCursor
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//
//     widHeap     occHeap
//                (same wid)
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <misc.hxx>
#include <curstk.hxx>

#include "syncur.hxx"

#pragma optimize( "t", on )

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::CSynCursor, public
//
//  Synopsis:   Create a cursor that merges a number of cursors.
//
//  Arguments:  [curStack] -- cursors to be merged
//              [widMax] -- the maximum WORKID of the cursors
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//  Notes:      The cursors and the array will be deleted by destructor.
//              Leaves occHeap empty.
//
//----------------------------------------------------------------------------

CSynCursor::CSynCursor( COccCurStack &curStack, WORKID widMax )
  : COccCursor(widMax), _widHeap (), _occHeap ( curStack.Count() )
{
    // Two step construction of the heap.
    // We have to make sure that all cursors have a valid key

    int cCursor = curStack.Count();
    COccCursor **aCursor = curStack.AcqStack();
    int count = 0;
    // remove empty cursors
    for ( int i = 0; i < cCursor; i++ )
    {
        Win4Assert ( aCursor[i] != 0 );
        if ( aCursor[i]->IsEmpty() || aCursor[i]->WorkId() == widInvalid )
        {
            delete aCursor[i];
        }
        else if ( count != i )
            aCursor[count++] = aCursor[i];
        else
            count++;
    }

    _widHeap.MakeHeap ( count, aCursor );
    if ( !_widHeap.IsEmpty() )
    {
        _iid = _widHeap.Top()->IndexId();
        _pid = _widHeap.Top()->Pid();
        ReplenishOcc();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//  Notes:      Current wid is defined as:
//              1. Cur wid of Top of occHeap (and cur wid of all
//                 cursors in occHeap
//              2. if occHeap empty: cur wid from top of widHeap
//
//----------------------------------------------------------------------------

WORKID       CSynCursor::WorkId()
{
    if ( _occHeap.IsEmpty() )
    {
        if (_widHeap.IsEmpty())
        {
            _pid = pidInvalid;
            return widInvalid;
        }
        else
        {
            _pid = _widHeap.Top()->Pid();
            return _widHeap.Top()->WorkId();
        }
    }

    _pid = _occHeap.Top()->Pid();
    return _occHeap.Top()->WorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::Occurrence, public
//
//  Synopsis:   Get current occurrence.
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//  Notes:      Current occurrence is defined as:
//              1. cur occ of top of occHeap and cur occ of all other
//                 cursors in it with the same cur occ
//
//----------------------------------------------------------------------------

OCCURRENCE   CSynCursor::Occurrence()
{
    if ( _occHeap.IsEmpty() )
        return OCC_INVALID;

    return _occHeap.Top()->Occurrence();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::NextWorkId, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's
//
//  Effects:    Updates _iid to the one of the widHeap top
//
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//  Notes:      1. increment and move to widHeap all cursors in occHeap, or,
//              2. if occHeap empty, increment and reheap all cursors with
//                 the same wid as Top of widHeap, or,
//              3. if widHeap empty, return widInvalid.
//
//----------------------------------------------------------------------------

WORKID       CSynCursor::NextWorkId()
{
    if ( ! _occHeap.IsEmpty() )
    {
        COccCursor * cur;
        while ( ( cur = _occHeap.RemoveBottom() ) != 0 )
        {
            WORKID wid = cur->NextWorkId();
            _widHeap.AddKey( cur, wid );
        }
    }
    else
    {
        if ( _widHeap.IsEmpty() )
            return widInvalid;

        WORKID wid = _widHeap.Top()->WorkId();
        if ( wid == widInvalid )
            return widInvalid;

        do
        {
            _widHeap.Top()->NextWorkId();
            _widHeap.ReheapKey();
        } while ( _widHeap.Top()->WorkId() == wid && wid != widInvalid );
    }

    if ( WorkId() != widInvalid )
        ReplenishOcc();

    return WorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::NextOccurrence, public
//
//  Synopsis:   Move to next occurrence
//
//  Returns:    Target occurrence or OCC_INVALID if no more occurrences
//              for current (wid, index id) combination.
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//  Notes:      1. Increment and reheap Top of occHeap
//
//----------------------------------------------------------------------------

OCCURRENCE   CSynCursor::NextOccurrence()
{
    if ( _occHeap.IsEmpty() )
        return OCC_INVALID;

    OCCURRENCE occPrev = _occHeap.Top()->Occurrence();
    if ( occPrev == OCC_INVALID )
        return OCC_INVALID;

    // Get the next occurrence.  Don't skip duplicate occurrences
    // because the pids will be different.

    _occHeap.Top()->NextOccurrence();
    _occHeap.ReheapKey();

    OCCURRENCE occNext = _occHeap.Top()->Occurrence();

    // Retrieve the current PID

    if ( _occHeap.IsEmpty() )
    {
        if ( _widHeap.IsEmpty() )
            _pid = pidInvalid;
        else
            _pid = _widHeap.Top()->Pid();
    }
    else
        _pid = _occHeap.Top()->Pid();

    return occNext;
} //NextOccurrence

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::WorkIdCount, public
//
//  Synopsis:   return wid count
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//  Notes:      Sum up all wid counts of all cursors in occHeap
//              and widHeap.
//
//----------------------------------------------------------------------------

ULONG CSynCursor::WorkIdCount()
{
    if ( _occHeap.IsEmpty() && _widHeap.IsEmpty() )
    {
        return 0;
    }

    // at least one of heaps is not empty
    ULONG widCount = 0;
    COccCursor **curVec;

    int count = _occHeap.Count();
    if ( count > 0 )
    {
        curVec = _occHeap.GetVector();
        while ( --count >= 0 )
            widCount += curVec[count]->WorkIdCount();
    }

    count = _widHeap.Count();
    if ( count > 0 )
    {
        curVec = _widHeap.GetVector();
        while ( --count >= 0 )
            widCount += curVec[count]->WorkIdCount();
    }

    return widCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::OccurrenceCount, public
//
//  Synopsis:   return occurrence count
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//  Notes:      1. sum up occ count of all cursors in the occHeap
//
//----------------------------------------------------------------------------

ULONG CSynCursor::OccurrenceCount()
{
    // sum up all occ counts for the same wid

    if ( _occHeap.IsEmpty() )
        return 0;

    int count = _occHeap.Count();
    ULONG occCount = 0;
    COccCursor **curVec = _occHeap.GetVector();
    while ( --count >= 0 )
        occCount += curVec[count]->OccurrenceCount();

    return occCount;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::MaxOccurrence
//
//  Synopsis:   Returns max occurrence of current wid
//
//  History:    26-Jun-96   SitaramR    Created
//
//----------------------------------------------------------------------------

OCCURRENCE CSynCursor::MaxOccurrence()
{
    Win4Assert( !_occHeap.IsEmpty() );

    if ( _occHeap.IsEmpty() )
        return OCC_INVALID;
    else
        return _occHeap.Top()->MaxOccurrence();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::HitCount, public
//
//  Synopsis:   return occurrence count
//
//  History:    28-Feb-92   AmyA        Created
//
//  Notes:      see notes for OccurrenceCount.
//
//----------------------------------------------------------------------------

ULONG CSynCursor::HitCount()
{
    return OccurrenceCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::Hit, public
//
//  Synopsis:   Hits the top level child
//
//  History:    13-Oct-92   BartoszM        Created
//
//----------------------------------------------------------------------------

LONG  CSynCursor::Hit()
{
    if ( _occHeap.IsEmpty() )
    {
        return rankInvalid;
    }
    return _occHeap.Top()->Hit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::Hit, public
//
//  Synopsis:   Goes to next occurrence and hits the top level child
//
//  History:    13-Oct-92   BartoszM        Created
//
//----------------------------------------------------------------------------

LONG  CSynCursor::NextHit()
{
    if (NextOccurrence() == OCC_INVALID)
        return(rankInvalid);
    return Hit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::Rank, public
//
//  Synopsis:   Returns weighted average of ranks of children
//
//  History:    22-Jul-92   BartoszM        Created
//
//----------------------------------------------------------------------------

LONG CSynCursor::Rank()
{
    if ( _occHeap.IsEmpty() )
    {
        return 0;
    }

    
    unsigned count = _occHeap.Count();
    COccCursor **curVec = _occHeap.GetVector();

    // One occurance, no need to average 
    if ( 1 == count )
        return curVec[0]->Rank();

    ULONG occCount = 0;
    LONG rank = 0;
    unsigned cWid = 0;
    for (unsigned n = 0; n < count; n++)
    {
        LONG r = curVec[n]->OccurrenceCount() * curVec[n]->GetWeight();
        if(r > rank)
            rank = r;
        cWid += curVec[n]->WorkIdCount();
    }
    rank /= MAX_QUERY_RANK;
    Win4Assert ( cWid != 0 );
    rank *= RANK_MULTIPLIER * Log2 ( _widMax / cWid );

    OCCURRENCE maxOcc = _occHeap.Top()->MaxOccurrence();
    Win4Assert( maxOcc != 0 );

    rank /= maxOcc;

    return (rank > MAX_QUERY_RANK)? MAX_QUERY_RANK: rank;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::RatioFinished, public
//
//  Synopsis:   return approximate ratio of documents processed to total
//              documents.
//
//  Notes:      The ratio, while approximate, should not return 1/1 until
//              all cursors are exhausted.
//
//----------------------------------------------------------------------------

void CSynCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    WORKID widTop = WorkId();
    if (widTop == widInvalid)
    {
        num = denom = 1;
        return;
    }

    denom = 0;
    num   = 0;

    // at least one of the heaps is not empty
    COccCursor **vector;
    int count = _occHeap.Count();
    vector = _occHeap.GetVector();

    unsigned cValid = 1;

    for (int i = 0; i < count; i++)
    {
        ULONG d, n;
        vector[i]->RatioFinished(d, n);

        denom += d;
        num += n;
        Win4Assert(denom >= d);

        if (n == d)
        {
            WORKID widCurrent = vector[i]->WorkId();
            if (widCurrent != widInvalid && widCurrent != widTop)
                cValid++;
        }
    }

    count = _widHeap.Count();
    vector = _widHeap.GetVector();

    for (i = 0; i < count; i++)
    {
        ULONG d, n;
        vector[i]->RatioFinished(d, n);

        denom += d;
        num += n;
        Win4Assert(denom >= d);

        if (n == d)
        {
            WORKID widCurrent = vector[i]->WorkId();
            if (widCurrent != widInvalid && widCurrent != widTop)
                cValid++;
        }
    }
    Win4Assert( denom > 0 );
    if (num == denom && cValid > 1)
        denom++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynCursor::ReplenishOcc, private
//
//  Synopsis:   Replenish the occurrence heap
//
//  Returns:    TRUE if successful, FALSE if wid heap exhausted
//
//  Requires:   _occHeap empty
//
//  History:    20-Jan-92   BartoszM and AmyA    Created
//
//----------------------------------------------------------------------------

BOOL CSynCursor::ReplenishOcc()
{
    Win4Assert ( _occHeap.IsEmpty() );

    Win4Assert( WorkId() != widInvalid );

    if ( _widHeap.IsEmpty() )
        return FALSE;

    // Move all cursors with the current wid
    // to occ heap

    WORKID wid = _widHeap.Top()->WorkId();

    do
    {
        COccCursor* cur = _widHeap.RemoveTopKey();
        _occHeap.AddKey( cur, cur->Occurrence() );
    } while ( !_widHeap.IsEmpty() && (wid == _widHeap.Top()->WorkId()) );

    return TRUE;
} //ReplenishOcc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\daemon\cidaemon.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cidaemon.cxx
//
//  Contents:   CI Daemon
//
//  History:    07-Jun-94   DwightKr    Created
//              18-Dec-97   KLam        Removed uneeded inclusion of shtole.hxx
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <dmnproxy.hxx>

#include "cidaemon.hxx"
#include <ciregkey.hxx>

DECLARE_INFOLEVEL(ci)

//+---------------------------------------------------------------------------
//
//  Member:     CCiDaemon::CCiDaemon
//
//  Synopsis:   Contructor of the CCiDaemon class. Creates all the necessary
//              objects to start filtering in the daemon process for a
//              catalog.
//
//  Arguments:  [nameGen]    - Object used to generated shared memory and
//              event object names.
//              [dwMemSize]  - Shared memory size.
//              [dwParentId] - ProcessId of the parent process.
//
//  History:    1-06-97   srikants   Created
//
//----------------------------------------------------------------------------

CCiDaemon::CCiDaemon( CSharedNameGen & nameGen,
                      DWORD dwMemSize,
                      DWORD dwParentId )
: _proxy( nameGen, dwMemSize, dwParentId )
{
    //
    //  Retrieve startup data for the client and then create an instance
    //  of the client control.
    //

    ULONG cbData;
    GUID  clsidClientMgr;
    BYTE const * pbData = _proxy.GetStartupData( clsidClientMgr, cbData );
    if ( 0 == pbData )
    {
        ciDebugOut(( DEB_ERROR, "Failed to get startup data\n" ));
        THROW( CException( STATUS_UNSUCCESSFUL ) );
    }

    //
    //  Create the admin params and a simple wrapper class.
    //
    CCiAdminParams *pAdminParams = new CCiAdminParams;
    _xAdminParams.Set( pAdminParams );
    _xFwParams.Set( new CCiFrameworkParams( _xAdminParams.GetPointer() ) );

    //
    //  Create the filter client object based on the Client Manager classid
    //

    //  Win4Assert( FALSE );

    ICiCFilterClient *pTmpFilterClient;
    SCODE sc = CoCreateInstance( clsidClientMgr,
                                 NULL,
                                 CLSCTX_ALL,
                                 IID_ICiCFilterClient,
                                 (PVOID*)&pTmpFilterClient );
    if (!SUCCEEDED( sc )) {
        ciDebugOut(( DEB_ERROR, "Unable to bind to filter client - %x\n", sc ));
        THROW( CException( sc ));
    }

    XInterface<ICiCFilterClient> xFilterClient( pTmpFilterClient );

    //
    //  Initialize the filter client
    //

    sc = xFilterClient->Init( pbData, cbData, _xAdminParams.GetPointer( ));
    if (!SUCCEEDED( sc )) {
        ciDebugOut(( DEB_ERROR, "FilterClient->Init failed - %x\n", sc ));
        THROW( CException( sc ));
    }

    // Set the process class and thread priority after admin params
    // are initialized by Init() above.

    _proxy.SetPriority( _xFwParams->GetThreadClassFilter(),
                        _xFwParams->GetThreadPriorityFilter() );

    //
    // Set the pagefile limit.  This protects against excessive VM usage.
    //

    QUOTA_LIMITS QuotaLimit;

    NTSTATUS Status = NtQueryInformationProcess( NtCurrentProcess(),
                                                 ProcessQuotaLimits,
                                                 &QuotaLimit,
                                                 sizeof(QuotaLimit),
                                                 0 );

    if ( NT_SUCCESS(Status) )
    {
        Win4Assert( _xFwParams->GetMaxDaemonVmUse() * 1024 > _xFwParams->GetMaxDaemonVmUse() );  // Overflow check.

        //
        // The slop is because we don't want to totally trash the system with a memory allocation, but
        // once a leak has occurred all sorts of legitimate allocations will also fail.  So in the daemon
        // we allow you to allocate memory slightly beyond the max, but in the watchdog checks we bail
        // when the limit is hit.
        //

        QuotaLimit.PagefileLimit = (_xFwParams->GetMaxDaemonVmUse() + _xFwParams->GetMaxDaemonVmUse() / 10) * 1024;

        Status = NtSetInformationProcess( NtCurrentProcess(),
                                          ProcessQuotaLimits,
                                          &QuotaLimit,
                                          sizeof(QuotaLimit) );

        if ( !NT_SUCCESS(Status) )
        {
            ciDebugOut(( DEB_ERROR, "Error 0x%x setting pagefile quota.\n", Status ));

            THROW( CException( Status ) );
        }
    }

    //
    // get ICiCLangRes interface pointer; used to set a CLangList instance
    //

    ICiCLangRes * pICiCLangRes = 0;

    sc = xFilterClient->QueryInterface(IID_ICiCLangRes, (void **) &pICiCLangRes);

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    XInterface<ICiCLangRes>  xICiCLangRes(pICiCLangRes);

    _xLangList.Set( new CLangList(pICiCLangRes) );
    pAdminParams->SetLangList( _xLangList.GetPointer() );

    //
    //  Now create the filter daemon class.
    //
    ULONG cbEntryBuf;
    BYTE * pbEntryBuf = _proxy.GetEntryBuffer( cbEntryBuf );

    CFilterDaemon * pFilterDaemon =
                new CFilterDaemon( _proxy,
                                   _xFwParams.GetReference(),
                                   _xLangList.GetReference(),
                                   pbEntryBuf,
                                   cbEntryBuf,
                                   xFilterClient.GetPointer( ) );

    _xFilterDaemon.Set( pFilterDaemon );
}

CCiDaemon::~CCiDaemon()
{
    // ShutdownDaemonClient();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCiDaemon::FilterDocuments
//
//  Synopsis:   Filters documents until death of the thread or process
//
//  History:    1-06-97   srikants   Created
//
//----------------------------------------------------------------------------

void CCiDaemon::FilterDocuments()
{
    SCODE scode;

    do
    {
        scode = _xFilterDaemon->DoUpdates();
    }
    while (scode == FDAEMON_W_WORDLISTFULL );
}

//+-------------------------------------------------------------------------
//
//  Function:   Usage, public
//
//  Purpose:    Displays usage message
//
//  History:    06-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------
void Usage()
{
    printf("This program is part of the Ci Filter Service and can not be run standalone.\n");
    ciDebugOut( (DEB_ITRACE, "Ci Filter Daemon: Bad command line parameters\n" ));
}

//+---------------------------------------------------------------------------
//
//  Function:   RunTheDaemon
//
//  Synopsis:   The main function for the downlevel daemon process.
//
//  Arguments:  [argc] -
//              [argv] -
//
//  History:    2-04-96   srikants   Created
//
//  Notes:      This method is currently invoked if argc == 8. We can
//              change that to explicitly pass something in the first
//              parameter.
//
//----------------------------------------------------------------------------

NTSTATUS RunTheDaemon( int argc, WCHAR * argv[] )
{

#if DBG==1
    ciInfoLevel = DEB_ERROR | DEB_WARN | DEB_IWARN | DEB_IERROR;
#endif


    // Win4Assert( !"Break In" );

    if ( argc != 5 ||
         0 != _wcsicmp( DL_DAEMON_ARG1_W, argv[1] ) ||
         wcslen( argv[2] ) >= MAX_PATH )
    {
        printf( "%ws %ws <catalog-dir> <SharedMemSize> <ParentId>\n",
                 argv[0], DL_DAEMON_ARG1_W );
        return STATUS_INVALID_PARAMETER;
    }

    WCHAR *pwcCatalog = argv[2];
    DWORD dwMemSize = _wtol( argv[3] );
    DWORD iParentId = _wtol( argv[4] );

    NTSTATUS status = STATUS_SUCCESS;

    TRY
    {
        XCom xcom;

        XPtr<CSharedNameGen> xNameGen( new CSharedNameGen( pwcCatalog ) );

        CCiDaemon ciDaemon( xNameGen.GetReference(),
                            dwMemSize,
                            iParentId );
        //
        //  Namegen is a fairly big class. Delete the memory.
        //
        xNameGen.Free();

        ciDaemon.FilterDocuments();
    }
    CATCH( CException, e)
    {
        status = e.GetErrorCode();
        ciDebugOut(( DEB_ERROR, "DL Filter Daemon:Exiting process, error = 0x%X\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    ciDebugOut( (DEB_ITRACE, "DL Filter Daemon: Leaving main()\n" ));

    return status;
} //RunTheDaemon

//+-------------------------------------------------------------------------
//
//  Function:   main, public
//
//  Purpose:    Application entry point, sets up the service entry point
//              and registers the entry point with the service control
//              dispatcher.
//
//  Arguments:  [argc] - number of arguments passed
//              [argv] - arguments
//
//  History:    06-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

extern "C" int __cdecl wmain( int argc, WCHAR *argv[] )
{
    NTSTATUS status = STATUS_SUCCESS;

    CNoErrorMode noError;

    CTranslateSystemExceptions translate;

    TRY
    {
        #if DBG==1 || CIDBG==1
            ciInfoLevel = DEB_ERROR | DEB_WARN | DEB_IWARN | DEB_IERROR;
        #endif // DBG==1 || CIDBG==1

        #if CIDBG == 1
            BOOL fRun = TRUE;   // FALSE --> Stop
    
            TRY
            {
                CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );
    
                ULONG ulVal = reg.Read( L"StopCiDaemonOnStartup", (ULONG)0 );
    
                if ( 1 == ulVal )
                    fRun = FALSE;
            }
            CATCH( CException, e )
            {
            }
            END_CATCH;
    
            unsigned long OldWin4AssertLevel = SetWin4AssertLevel(ASSRT_MESSAGE | ASSRT_POPUP);
    
            Win4Assert( fRun );
    
            SetWin4AssertLevel( OldWin4AssertLevel );
        #endif // CIDBG

        if ( argc > 2 && 0 == _wcsicmp( argv[1], DL_DAEMON_ARG1_W ) )
        {
            status = RunTheDaemon( argc, argv );
        }
        else
        {
            Usage();
            return 0;
        }
    }
    CATCH( CException, e)
    {
        ciDebugOut(( DEB_ERROR,
                     "Unhandled error in CiDaemon: 0x%x\n",
                     e.GetErrorCode() ));
    }
    END_CATCH

    // Shutdown Kyle OLE now or it'll AV later.

    CIShutdown();

    return status;
} //wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\cursor\veccurs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999.
//
//  File:       VECCURS.CXX
//
//  Contents:   Vector-or Cursor.  Computes union of multiple cursors with
//              weighted rank computation.
//
//  Classes:    CVectorCursor
//
//  History:    23-Jul-92   KyleP       Created
//              01-Mar-93   KyleP       Use 64-bit arithmetic
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <curstk.hxx>

#include "veccurs.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CVectorCursor::CVectorCursor, public
//
//  Synopsis:   Creates a vector cursor.
//
//  Arguments:  [cCursor]    -- count of cursors
//              [curStack]   -- cursors to be merged
//              [RankMethod] -- Indicates formula used to compute rank.
//
//  History:    23-Jul-92   KyleP       Created
//
//  Notes:      The cursors and the array will be deleted by destructor.
//              The cursors have to come from one index
//
//----------------------------------------------------------------------------

CVectorCursor::CVectorCursor( int cCursor,
                              CCurStack& curStack,
                              ULONG RankMethod )
        : _cChild( cCursor ),
          _RankMethod( RankMethod ),
          _lMaxWeight( 0 ),
          _lSumWeight( 0 ),
          _ulSumSquaredWeight( 0 ),
          _widRank( widInvalid ),
          _iCur( -1 ),
          _aChildCursor( cCursor ),
          _aChildRank( cCursor ),
          _aChildWeight( cCursor )
{
    // Two step construction of the heap.
    // We have to make sure that all cursors have a valid key

    int count = 0;

    //
    // aCursor is a compacted version of the cursor array which
    // only contains valid cursors.  It is passed to the wid heap.
    //

    CCursor ** aCursor = curStack.AcqStack();
    RtlCopyMemory( _aChildCursor.GetPointer(),
                   aCursor,
                   cCursor * sizeof( CCursor * ) );

    //
    // remove empty cursors
    //

    for ( int i = 0; i < cCursor; i++ )
    {
        if ( aCursor[i] == 0 || aCursor[i]->WorkId() == widInvalid )
        {
            //
            // Invalid cursor
            //

            delete aCursor[i];
            _aChildCursor[i] = 0;
            _aChildRank[i] = 0;
            _aChildWeight[i] = 0;
        }
        else
        {
            //
            // Valid cursor
            //

            _aChildWeight[i] = _aChildCursor[i]->GetWeight();
            _lMaxWeight = max( _lMaxWeight, _aChildWeight[i] );
            _lSumWeight += _aChildWeight[i];
            _ulSumSquaredWeight += _aChildWeight[i] * _aChildWeight[i];

            if ( count != i )
                aCursor[count++] = aCursor[i];
            else
                count++;
        }
    }

    //
    // Avoid divide-by-zero in rank computation
    //

    if ( _lMaxWeight == 0 )
        _lMaxWeight = 1;

    if ( _lSumWeight == 0 )
        _lSumWeight = 1;

    if ( _ulSumSquaredWeight == 0 )
        _ulSumSquaredWeight = 1;

    _widHeap.MakeHeap ( count, aCursor );
    if ( !_widHeap.IsEmpty() )
    {
        _iid = _widHeap.Top()->IndexId();
        _pid = _widHeap.Top()->Pid();
        _RefreshRanks();
    }
} //CVectorCursor

//+---------------------------------------------------------------------------
//
//  Member:     CVectorCursor::WorkId, public
//
//  Synopsis:   Get current work id.
//
//  History:    23-Jul-92   KyleP       Lifted from COrCursor
//
//----------------------------------------------------------------------------

WORKID CVectorCursor::WorkId()
{
    if ( _widHeap.IsEmpty() )
        return widInvalid;

    return _widHeap.Top()->WorkId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorCursor::NextWorkId, public
//
//  Synopsis:   Move to next work id
//
//  Returns:    Target work id or widInvalid if no more wid's for current key
//
//  History:    23-Jul-92   KyleP       Created from COrCursor.
//
//----------------------------------------------------------------------------

WORKID CVectorCursor::NextWorkId()
{
    WORKID widOld = WorkId();
    WORKID widNew;

    if ( widOld == widInvalid )
        return widInvalid;

    do
    {
        _widHeap.Top()->NextWorkId();
        _widHeap.Reheap();
        widNew = _widHeap.Top()->WorkId();
    }
    while ( widNew == widOld );

    return widNew;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorCursor::RatioFinished, public
//
//  Synopsis:   return approximate ratio of documents processed to total
//              documents.
//
//  Notes:      The ratio, while approximate, should not return 1/1 until
//              all cursors are exhausted.
//
//----------------------------------------------------------------------------

void CVectorCursor::RatioFinished (ULONG& denom, ULONG& num)
{
    WORKID widTop = WorkId();
    if (widTop == widInvalid)
    {
        denom = num = 1;
        return;
    }

    denom = 0;
    num   = 0;

    unsigned cValid = 1;

    for (unsigned i = 0; i < _cChild; i++)
    {
        ULONG d, n;
        if (_aChildCursor[i])
        {
            _aChildCursor[i]->RatioFinished(d, n);
            Win4Assert( n <= d && d > 0 );

            denom += d;
            num += n;
            Win4Assert( d <= denom );       // overflow?

            if (n == d)
            {
                WORKID widCurrent = _aChildCursor[i]->WorkId();
                if (widCurrent != widInvalid && widCurrent != widTop)
                    cValid++;
            }
        }
    }
    Win4Assert ( denom > 0 );
    if (num == denom && cValid > 1)
        denom++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorCursor::WorkIdCount, public
//
//  Synopsis:   return wid count
//
//  History:    23-Jul-92   KyleP       Lifted from COrCursor
//
//----------------------------------------------------------------------------

ULONG CVectorCursor::WorkIdCount()
{
    Win4Assert (( FALSE && "CVectorCursor::WorkIdCount called" ));
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorCursor::HitCount, public
//
//  Synopsis:   Return occurrence count
//
//  History:    23-Jul-92   KyleP       Lifted from COrCursor
//
//----------------------------------------------------------------------------

ULONG CVectorCursor::HitCount()
{
    WORKID wid = _widHeap.Top()->WorkId();

    if (wid == widInvalid)
        return 0;

    ULONG hitCnt = 0;

    for (UINT i=0; i < _cChild; i++)
    {
        if ( _aChildCursor[i] && _aChildCursor[i]->WorkId() == wid )
            hitCnt += _aChildCursor[i]->HitCount();
    }

    return hitCnt;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorCursor::Rank, public
//
//  Returns:    Rank.
//
//  History:    23-Jul-92   KyleP       Created
//              29-Jan-93   KyleP       Fixed rounding error in Jaccard
//
//  Notes:      Uses algorithm specified by user from a small, precomputed
//              set.
//
//              See "Automatic Text Processing", G. Salton, 10.1.1 and
//              10.4.2 for a discussion of the weight formulas.
//
//----------------------------------------------------------------------------

static int const cMaxChildrenInner = ( 0xFFFFFFFF /
                                       ( MAX_QUERY_RANK * MAX_QUERY_RANK ) );

static int const cMaxChildrenDice = ( 0xFFFFFFFF /
                                      ( MAX_QUERY_RANK * MAX_QUERY_RANK * 2 ) );

static int const cMaxChildrenJaccard = ( 0xFFFFFFFF /
                                         ( MAX_QUERY_RANK * MAX_QUERY_RANK ) );

LONG CVectorCursor::Rank()
{
    LONG lRank;
    WORKID wid = _widHeap.Top()->WorkId();

    //
    // An empty heap is a minimum rank.
    //

    if (wid == widInvalid)
    {
        Win4Assert( FALSE && "Rank called on empty heap!" );
        return 0;
    }

    //
    // Get ranks for this wid.
    //

    _RefreshRanks();

    //
    // Otherwise, compute rank based on selected method.
    //

    switch ( _RankMethod )
    {
    case VECTOR_RANK_MIN:
    {
        //                                 MAX[ wi * ( MaxRank - ri ) ]
        // VECTOR_RANK_MIN     MaxRank - ---------------------------------
        //                                           MAX[wi]

        lRank = (MAX_QUERY_RANK - _aChildRank[0]) * _aChildWeight[0];

        for ( UINT i = 1; i < _cChild; i++ )
        {
            LONG lNew = (MAX_QUERY_RANK - _aChildRank[i]) * _aChildWeight[i];
            lRank = max( lRank, lNew );
        }

        lRank = MAX_QUERY_RANK - (lRank / _lMaxWeight);

        break;
    }

    case VECTOR_RANK_MAX:
    {
        //                       MAX[ wi * ri ]
        // VECTOR_RANK_MAX     -----------------
        //                          MAX[wi]

        lRank = _aChildRank[0] * _aChildWeight[0];

        for ( UINT i = 1; i < _cChild; i++ )
        {
            LONG lNew = _aChildRank[i] * _aChildWeight[i];
            lRank = max( lRank, lNew );
        }

        lRank = lRank / _lMaxWeight;

        break;
    }

    case VECTOR_RANK_INNER:
    {
        //                      n
        //                     SUM ri * wi
        //                     i=1
        // VECTOR_RANK_INNER  -------------
        //                         n
        //                        SUM wi
        //                        i=1

        if ( _cChild > cMaxChildrenInner )
        {
            THROW( CException( STATUS_INVALID_PARAMETER ) );
        }

        lRank = 0;

        for ( UINT i = 0; i < _cChild; i++ )
        {
            lRank += _aChildRank[i] * _aChildWeight[i];
        }

        lRank /= _lSumWeight;

        break;
    }

    case VECTOR_RANK_DICE:
    {
        //                          n
        //                     2 * SUM ri * wi
        //                         i=1
        // VECTOR_RANK_DICE   --------------------
        //                      n    2     n    2
        //                     SUM ri  +  SUM wi
        //                     i=1        i=1

        if ( _cChild > cMaxChildrenDice )
        {
            THROW( CException( STATUS_INVALID_PARAMETER ) );
        }

        ULONG ulWeightSum = 0;

        lRank = 0;

        for ( UINT i = 0; i < _cChild; i++ )
        {
            lRank += _aChildRank[i] * _aChildWeight[i];
            ulWeightSum += _aChildRank[i] * _aChildRank[i];
        }

        ulWeightSum += _ulSumSquaredWeight;

        //
        // Avoid nasty rounding errors
        //

        LONGLONG liTop;

        liTop =  UInt32x32To64( lRank, 2 * MAX_QUERY_RANK );

        liTop /= ulWeightSum;

        lRank = lltoul(liTop);

        break;
    }

    case VECTOR_RANK_JACCARD:
    {
        //                                  n
        //                                 SUM ri * wi
        //                                 i=1
        // VECTOR_RANK_JACCARD   ---------------------------------
        //                         n    2     n    2    n
        //                        SUM ri  +  SUM wi  - SUM ri * wi
        //                        i=1        i=1       i=1

        if ( _cChild > cMaxChildrenJaccard )
        {
            THROW( CException( STATUS_INVALID_PARAMETER ) );
        }

        ULONG ulWeightSum = 0;

        lRank = 0;

        for ( UINT i = 0; i < _cChild; i++ )
        {
            lRank += _aChildRank[i] * _aChildWeight[i];
            ulWeightSum += _aChildRank[i] * _aChildRank[i];
        }

        ulWeightSum += _ulSumSquaredWeight;
        ulWeightSum -= lRank;

        //
        // Avoid nasty rounding errors
        //

        LONGLONG liTop;

        liTop =  UInt32x32To64( lRank, MAX_QUERY_RANK );

        liTop /= ulWeightSum;

        lRank = lltoul(liTop);
        break;
    }

    default:
        Win4Assert( FALSE && "Invalid rank calculation method." );
        lRank = 0;
    }

    Win4Assert( lRank <= MAX_QUERY_RANK );

    return ( lRank );
}

//+-------------------------------------------------------------------------
//
//  Member:     CVectorCursor::GetRankVector, public
//
//  Synopsis:   Fetches the rank vector for the cursor.
//
//  Arguments:  [pulVector] -- The vector is copied here.
//
//  Requires:   There is enough space in [pulVector] for all the
//              elements of the vector.  No overflow checking is done.
//
//  Returns:    The count of elements copied.
//
//  History:    24-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

ULONG CVectorCursor::GetRankVector( LONG * plVector, ULONG cElements )
{
    //
    // Get ranks for this wid.
    //

    _RefreshRanks();

    if ( cElements >= _cChild )
        RtlCopyMemory( plVector,
                       _aChildRank.GetPointer(),
                       _cChild * sizeof LONG );

    return _cChild;
}

//+---------------------------------------------------------------------------
//
//  Member:      CVectorCursor::Hit, public
//
//  Returns:     Current hit.
//
//  History:     07-Sep-92       MikeHew   Created
//               12-Dec-92       KyleP     Modified for Vector Cursor
//
//  Notes:       A hit for the vector cursor is identical to a hit
//               for an or cursor -- 1 hilite at a time.
//
//----------------------------------------------------------------------------

LONG CVectorCursor::Hit()
{
    //
    // The first time Hit() is called, we need to position on the first hit.
    //

    CCursor ** aCur = _widHeap.GetVector();

    if ( _iCur == -1 )
    {
        NextHit();
    }

    if ( -1 == _iCur )
        return rankInvalid;

    return ( aCur[_iCur]->Hit() );
}

//+---------------------------------------------------------------------------
//
//  Member:      CVectorCursor::NextHit, public
//
//  Returns:     Next hit.
//
//  History:     07-Sep-92       MikeHew   Created
//               12-Dec-92       KyleP     Modified for Vector Cursor
//
//----------------------------------------------------------------------------

LONG CVectorCursor::NextHit()
{
    CCursor ** aCur = _widHeap.GetVector();

    LONG rank;

    if ( _iCur == -1 )
        rank = rankInvalid;
    else
        rank = aCur[_iCur]->NextHit();

    //
    // If this cursor is empty (rank == rankInvalid) and
    // there are more cursors available, find one that's non-empty.
    //

    while ( rank == rankInvalid && _iCur < _widHeap.Count() - 1 )
    {
        ++_iCur;
        rank = aCur[_iCur]->Hit();
    }

    return rank;
}

//+-------------------------------------------------------------------------
//
//  Member:     CVectorCursor::_RefreshRanks, private
//
//  Synopsis:   Fetches ranks from children with matching workids.
//
//  History:    24-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CVectorCursor::_RefreshRanks()
{
    WORKID wid = _widHeap.Top()->WorkId();

    //
    // If the cache is up-to-date, do nothing.

    if ( _widRank == wid )
        return;

    for ( UINT i = 0; i < _cChild; i++ )
    {
        WORKID widCurrent = ( _aChildCursor[i] ) ?
            _aChildCursor[i]->WorkId() : widInvalid;

        if ( widCurrent == widInvalid || widCurrent != wid )
        {
            _aChildRank[i] = 0;
        }
        else
        {
            _aChildRank[i] = _aChildCursor[i]->Rank();
        }
    }

    _widRank = wid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\deflang\lang.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       LANG.CXX
//
//  Contents:   Language Support
//
//  Classes:    CLanguage
//              CLangList
//
//  History:    02-May-91   BartoszM    Created
//
//  Notes:      The filtering pipeline is hidden in the Data Repository
//              object which serves as a sink for the filter.
//              The sink for the Data Repository is the Key Repository.
//              The language dependent part of the pipeline
//              is obtained from the Language List object and is called
//              Key Maker. It consists of:
//
//                  Word Breaker
//                  Stemmer (optional)
//                  Normalizer
//                  Noise List
//
//              Each object serves as a sink for its predecessor,
//              Key Repository is the final sink.
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <tfilt.hxx>
#include <tsource.hxx>
#include <defbreak.hxx>
#include <lang.hxx>
#include <keymak.hxx>
#include <norm.hxx>
#include <noise.hxx>
#include <ciregkey.hxx>

#define DEB_LLIST DEB_USER10

//+-------------------------------------------------------------------------
//
//  Method:     CLangList::CLangList, public
//
//  Synopsis:   Create all languages.
//
//  Arguments:  [pICiCLangRes] -- Client-provided language creator
//              [ulMaxIdle]    -- Max time (in seconds) before idle language
//                                object is elegible for deletion.
//
//  History:    02-May-91   BartoszM    Created
//              14-Jul-94   SitaramR    Moved constructor here from lang.hxx
//
//--------------------------------------------------------------------------

CLangList::CLangList( ICiCLangRes * pICiCLangRes,
                      ULONG         ulMaxIdle )
        : _xICiCLangRes(pICiCLangRes),
          _ulMaxIdle( ulMaxIdle * 1000 )
{
    _xICiCLangRes->AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:     CLangList::~CLangList, public
//
//  Synopsis:   Delete all languages.
//
//  History:    27-Apr-1994  KyleP      Created
//
//--------------------------------------------------------------------------

CLangList::~CLangList()
{
    Shutdown();
}

//+-------------------------------------------------------------------------
//
//  Method:     CLangList::Shutdown, public
//
//  Synopsis:   Delete all languages.
//
//  History:    2-July-1996  dlee    Moved from the destructor
//
//--------------------------------------------------------------------------

void CLangList::Shutdown()
{
    for ( CLanguage *pLang = _langsAvailable.Pop();
          0 != pLang;
          pLang = _langsAvailable.Pop() )
    {
        delete pLang;
    }
} //Shutdown

//+-------------------------------------------------------------------------
//
//  Method:     CLangList::Supports, public
//
//  Synopsis:   Determines if language object is suitable for lcid/pid
//
//  Arguments:  [pLang] -- Language object
//              [pid]   -- PROPID to-be-used by [pLang]
//              [lcid]  -- Locale to-be-used by [pLang]
//
//  Returns:    TRUE is [pLang] can be used to break/stem/etc. the
//              locale/property specified by [lcid]/[pid]
//
//  History:    05-Jan-1998  KyleP    Created
//
//--------------------------------------------------------------------------

BOOL CLangList::Supports( CLanguage const * pLang, PROPID pid, LCID lcid )
{
    ciDebugOut(( DEB_LLIST, "Supports, lcid %#x, pid %#x\n", lcid, pid ));

    LANGID langId = LANGIDFROMLCID(lcid);

    //
    // Easy case: Different language.
    //

    if ( !pLang->IsLocale( langId ) )
    {
        ciDebugOut(( DEB_LLIST, "  supports: lcid doesn't match\n" ));
        return FALSE;
    }

    //
    // Easy case:  Everything matches.
    //

    if ( pLang->IsPid( pid ) )
        return TRUE;

    CLangPidStateInfo stateInfo;

    if ( pLang->IsPid( CI_DEFAULT_PID ) )
    {
        //
        // Hard case:  Mismatch, but possible default match to previously
        //             seen pid.
        //

        if ( _pidHash.LokLookupOrAddLang( langId, stateInfo ) &&
             _pidHash.LokIsUseDefaultPid( pid, stateInfo.GetLangIndex() ) )
        {
            ciDebugOut(( DEB_LLIST, "CLangList::Supports -- Pid 0x%x can use current [default] language object\n", pid ));
            return TRUE;
        }

        //
        // Hardest case: Mismatch, but possible default match to brand
        //               new pid.
        //

        CLanguage * pNewLang = FindLangAndActivate( langId, pid );

        if ( 0 != pNewLang )
        {
            //
            // Obviously not a default match if there is already a specific
            // language created.  Note that extra work searching the list
            // in FindLangAndActivate is not wasted, as the ReturnLang below
            // will place the activated language on the top of the list for
            // easy access when the call is soon made to fetch the new
            // language object supporting this pid/locale.
            //

            ReturnLang( pNewLang );
            ciDebugOut(( DEB_LLIST, "  supports found it, but returning FALSE\n" ));
            return FALSE;
        }

        pNewLang = CreateLang( langId, pid, stateInfo, pLang );

        if ( 0 == pNewLang )
        {
            ciDebugOut(( DEB_LLIST, "CLangList::Supports -- New pid 0x%x can use current [default] language object\n", pid ));
            Win4Assert( pLang->IsPid( CI_DEFAULT_PID ) );  // May be a bogus assert...
            return TRUE;
        }
        else
        {
            ciDebugOut(( DEB_LLIST, "CLangList::Supports -- New pid 0x%x cannot use current language object\n", pid ));
            ReturnLang( pNewLang );  // This one should get used in just a few calls...
            return FALSE;
        }
    }

    return FALSE;
} //Supports

//+---------------------------------------------------------------------------
//
//  Member:     CLangList::BorrowLang
//
//  Synopsis:   Borrows a language object
//
//  Arguments:  [locale]    -- Locale
//              [pid]       -- property id
//              [resources] -- Which resources to load.
//
//  History:    19-Sep-91   BartoszM     Created original GetLang.
//              15-Aug-94   SitaramR     Renamed GetLang to BorrowLang and
//                                       added code to look up registry.
//               2-14-97    mohamedn     use ICiCLangRes, use lang specific
//                                       default pid cache.
//
//----------------------------------------------------------------------------


CLanguage* CLangList::BorrowLang( LCID locale, PROPID pid, ULONG resources )
{
    LANGID langId = LANGIDFROMLCID(locale);

    ciDebugOut(( DEB_LLIST, "BorrowLang lang %#x, pid %#x, resources %#x\n",
                 locale, pid, resources ));

    CLanguage * pLang = FindLangAndActivate( langId, pid );
    if ( 0 != pLang )
        return pLang;

    //==========================================================
    {
        //
        //  We have to create a new language object.  Serialize so that
        //  multiple threads are not creating simultaneously.
        //
        CLock lockCreat( _mtxCreate );

        //
        // lookup the given pid if a default pid hash table exist
        // for the given LangID.
        // If pid found in default pid cache, use CI_DEFAULT_PID
        //

        CLangPidStateInfo stateInfo;

        if ( _pidHash.LokLookupOrAddLang( langId, stateInfo ) )
        {
             if ( _pidHash.LokIsUseDefaultPid( pid, stateInfo.GetLangIndex() ) )
                  pid = CI_DEFAULT_PID;
        }

        //  Check to see if one became available while we were waiting.

        pLang = FindLangAndActivate( langId, pid );

        if ( 0 != pLang )
            return pLang;

        // Create a new CLanguage object

        pLang = CreateLang( langId, pid, stateInfo, 0, resources );
    }
    //==========================================================

    Win4Assert( pLang );

    return pLang;
} //BorrowLang

//+---------------------------------------------------------------------------
//
//  Member:     CLangList::CreateLang
//
//  Synopsis:   Creates & Returns a language object
//
//  Arguments:  [langId]        -- Locale
//              [pid]           -- property id
//              [stateInfo]     -- stateInfo to set internal state info.
//              [pDup]          -- Don't create a language just like this.
//                                 Instead, return this one.
//              [resources]     -- Which to load.
//
//  Returns:    [pLang]         -- a valid pointer to CLanguage object.
//
//  History:    19-Sep-91   BartoszM     Created original GetLang.
//              15-Aug-94   SitaramR     Renamed GetLang to BorrowLang and
//                                       added code to look up registry.
//               2-27-97    mohamedn     use ICiCLangRes,
//                                       use lang specific default pid cache.
//
//----------------------------------------------------------------------------

CLanguage * CLangList::CreateLang( LANGID langId,
                                   PROPID pid,
                                   CLangPidStateInfo & stateInfo,
                                   CLanguage const * pDup,
                                   ULONG resources )
{
    ciDebugOut(( DEB_LLIST, "CreateLang lang %#x, pid %#x, resources %#x\n",
                 langId, pid, resources ));

    ULONG pidFlags = 0;

    if ( LoadWB( resources ) )
        pidFlags |= USE_WB_DEFAULT_PID;
    if ( LoadST( resources ) )
        pidFlags |= USE_STEMMER_DEFAULT_PID;
    if ( LoadNO( resources ) )
        pidFlags |= USE_NWL_DEFAULT_PID;

    //
    // Get interfaces to the wordbreaker, stemmer and noise word list
    // via ICiCLangRes
    //

    XInterface<IWordBreaker> xIWBreak;
    XInterface<IStemmer>     xIStemmer;
    XInterface<IStream>      xIStrmNoiseFile;

    if ( pid == CI_DEFAULT_PID )
    {
        // create default word breaker, stemmer & nwl

        if ( LoadWB( resources ) )
            xIWBreak.Set( GetWordBreaker   ( langId, pid, stateInfo, TRUE ) );

        if ( LoadST( resources ) )
            xIStemmer.Set( GetStemmer       ( langId, pid, stateInfo ) );

        if ( LoadNO( resources ) )
            xIStrmNoiseFile.Set( GetNoiseWordList ( langId, pid, stateInfo ) );
    }
    else
    {
        // try to create wb, stemmer, and nwl using this pid (non-default)
        if ( LoadWB( resources ) )
            xIWBreak.Set( GetWordBreaker( langId, pid, stateInfo, FALSE ) );

        if ( LoadST( resources ) )
            xIStemmer.Set( GetStemmer( langId, pid, stateInfo ) );

        if ( LoadNO( resources ) )
            xIStrmNoiseFile.Set( GetNoiseWordList( langId, pid, stateInfo ) );

        ciDebugOut(( DEB_LLIST, "  GetPidFlags: %#x\n", stateInfo.GetPidFlags() ));

        if ( stateInfo.GetPidFlags() == pidFlags )
        {
            // Client requested to use DEFAULT_PID:
            //    add pid to the default pid cache for this langid,
            //    scan availble lang objects for a match, and return it if
            //    found else create default wb, stemmer, and nwl.

            Win4Assert ( xIWBreak.IsNull() );
            Win4Assert ( xIStemmer.IsNull() );
            Win4Assert ( xIStrmNoiseFile.IsNull() );

            _pidHash.LokAddDefaultPid( pid, stateInfo.GetLangIndex() );

            pid = CI_DEFAULT_PID;

            if ( 0 != pDup && pDup->IsLocale( langId ) && pDup->IsPid( pid ) )
                return 0;

            CLanguage * pLang = FindLangAndActivate( langId, pid );

            if ( 0 != pLang )
                return pLang;

            if ( LoadWB( resources ) )
                xIWBreak.Set( GetWordBreaker( langId, pid, stateInfo, TRUE ) );

            if ( LoadST( resources ) )
                xIStemmer.Set( GetStemmer( langId, pid, stateInfo ) );

            if ( LoadNO( resources ) )
                xIStrmNoiseFile.Set( GetNoiseWordList( langId, pid, stateInfo ) );
        }
        else
        {
            // Client didn't request default pid for all, create default wb, stemmer or nwl
            // only if client requested using default pid for it.

            if ( stateInfo.IsPidFlagSet( USE_WB_DEFAULT_PID ) )
            {
                if ( LoadWB( resources ) )
                    xIWBreak.Set( GetWordBreaker( langId, CI_DEFAULT_PID, stateInfo, TRUE ) );
            }
            else
                Win4Assert ( !xIWBreak.IsNull() );

            if ( stateInfo.IsPidFlagSet( USE_STEMMER_DEFAULT_PID ) )
            {
                if ( LoadST( resources ) )
                    xIStemmer.Set( GetStemmer( langId, CI_DEFAULT_PID, stateInfo ) );
            }

            if ( stateInfo.IsPidFlagSet( USE_NWL_DEFAULT_PID ) )
            {
                if ( LoadNO( resources ) )
                    xIStrmNoiseFile.Set( GetNoiseWordList ( langId, CI_DEFAULT_PID, stateInfo ) );
            }
        }
    }

    // create a language object given the wb, stemmer & nwl.

    CLanguage * pLang = new CLanguage( langId,
                                       pid,
                                       xIWBreak,
                                       xIStemmer,
                                       xIStrmNoiseFile );

    // Queue can't fail, so no smart pointer for pLang is needed

    //------------------------------------------------------
    {
        CLock lock( _mtxList );

        _langsInUse.Queue( pLang );
    }
    //------------------------------------------------------

    return pLang;
} //CreateLang

//+---------------------------------------------------------------------------
//
//  Member:     CLangList::GetWordBreaker, private
//
//  Synopsis:   gets a word breaker interface given a langid and a pid
//
//  Arguments:  [langid]        -- langid
//              [pid]           -- property id
//              [stateInfo]     -- stateInfo to set internal state info.
//              [fCreateDefault]-- flag to create default word breaker if TRUE
//
//  Returns:    IWordBreaker interface upon success, throws upon failure.
//
//  History:    2-27-97     MohamedN    Created (from borrowlang)
//
//----------------------------------------------------------------------------

IWordBreaker * CLangList::GetWordBreaker( LANGID langid,
                                          PROPID pid,
                                          CLangPidStateInfo & stateInfo,
                                          BOOL fCreateDefault )
{
    IWordBreaker * pIWordBreaker = 0;

    ciDebugOut(( DEB_LLIST, "!!! Actually creating a wordbreaker\n" ));

    SCODE sc = _xICiCLangRes->GetWordBreaker( langid, pid, &pIWordBreaker );
    if ( SUCCEEDED(sc) )
    {
         Win4Assert( 0 != pIWordBreaker );
    }
    else
    {
        switch (sc)
        {
            case CI_E_NOT_FOUND:
                if ( fCreateDefault )
                {
                    ciDebugOut(( DEB_ERROR,"Using default word breaker for locale 0x%x\n",
                                 langid ));

                    pIWordBreaker = new CDefWordBreaker();
                }

                // force fall thru

            case CI_E_USE_DEFAULT_PID:
                stateInfo.SetPidFlags( USE_WB_DEFAULT_PID );
                break;

            default:
                ciDebugOut(( DEB_ERROR, "GetWordBreaker Failed(locale: %x,pid: %x): sc: %x\n",
                             langid, pid, sc ));

                THROW( CException( sc ) );
        } // switch

    } // else

    return pIWordBreaker;
} //GetWordBreaker

//+---------------------------------------------------------------------------
//
//  Member:     CLangList::GetStemmer, private
//
//  Synopsis:   gets a stemmer interface given a langid and a pid
//
//  Arguments:  [langid]        -- langid
//              [pid]           -- property id
//              [stateInfo]     -- stateInfo to set internal state info.
//
//  Returns:    IStemmer interface upon success, null or throws upon failure.
//
//  History:    2-27-97     MohamedN    Created (from borrowlang)
//
//----------------------------------------------------------------------------

IStemmer * CLangList::GetStemmer( LANGID langid,
                                  PROPID pid,
                                  CLangPidStateInfo & stateInfo )
{
    SCODE           sc                  = S_OK;
    IStemmer   *    pIStemmer           = 0;


    sc = _xICiCLangRes->GetStemmer( langid, pid, &pIStemmer );
    if ( FAILED(sc) )
    {
        switch (sc)
        {

            case CI_E_NOT_FOUND:

                 ciDebugOut(( DEB_ITRACE,"no stemmer found for locale 0x%x\n",
                              langid ));

                 break;

            case CI_E_USE_DEFAULT_PID:

                 stateInfo.SetPidFlags( USE_STEMMER_DEFAULT_PID );

                 break;

            default:
                 ciDebugOut(( DEB_ERROR, "GetStemmer Failed(locale: %x,pid: %x): sc: %x\n",
                              langid,pid, sc ));

                 THROW( CException(sc) );
        } // switch

    } // else


    return pIStemmer;
} // GetStemmer

//+---------------------------------------------------------------------------
//
//  Member:     CLangList::GetNoiseWordList, private
//
//  Synopsis:   gets an IStream pointer to the noise word list, given a langid & locale.
//
//  Arguments:  [langid]        -- langid
//              [pid]           -- property id
//              [stateInfo]     -- stateInfo to set internal state info.
//
//  Returns:    IStream interface upon success, null or throws upon failure.
//
//  History:    2-27-97     MohamedN    Created (from borrowlang)
//
//----------------------------------------------------------------------------

IStream * CLangList::GetNoiseWordList( LANGID langid,
                                       PROPID pid,
                                       CLangPidStateInfo & stateInfo )
{
    SCODE           sc                  = S_OK;
    IStream   *     pIStream            = 0;

    sc = _xICiCLangRes->GetNoiseWordList( langid, pid, &pIStream );
    if ( FAILED(sc) )
    {
        switch (sc)
        {

            case CI_E_NOT_FOUND:

                 ciDebugOut(( DEB_ITRACE,"no NoiseWordList found for locale 0x%x\n",
                               langid ));

                 break;

            case CI_E_USE_DEFAULT_PID:

                 stateInfo.SetPidFlags( USE_NWL_DEFAULT_PID );

                 break;

            default:
                 ciDebugOut(( DEB_ERROR, "GetNoiseWordList Failed(locale: %x,pid: %x): sc: %x\n",
                              langid, pid, sc ));

                 THROW( CException(sc) );
        } // switch

    } // else

    return pIStream;
} //GetNoiseWordList

//+---------------------------------------------------------------------------
//
//  Member:     CLangList::FindLangAndActivate, private
//
//  Synopsis:   If a language with the given locale exits, then return the
//              language after making it active
//
//  Arguments:  [locale] -- Locale
//              [pid]    -- property id
//
//  Notes:
//
//  History:    14-Sep-94   SitaramR     Created
//
//----------------------------------------------------------------------------

CLanguage *CLangList::FindLangAndActivate( LCID locale, PROPID pid )
{
    ciDebugOut(( DEB_LLIST, "FindLangAndActivate lcid %#x, pid %#x\n",
                 locale, pid ));

    ULONG dwTick = GetTickCount();

    CLock lock( _mtxList );

    CLanguage *pLang = 0;

    CLangIter iter( _langsAvailable );

    while ( !_langsAvailable.AtEnd(iter) )
    {
        ciDebugOut(( DEB_LLIST, "  looking for match, lcid %#x, iter->IsPid %d\n",
                     iter->Locale(), iter->IsPid(pid) ));

        if ( iter->IsLocale(locale) && iter->IsPid(pid) )
        {
            pLang = iter.GetLang();

            _langsAvailable.Advance(iter);

            // move from Available list to InUse list
            pLang->Unlink();
            _langsInUse.Queue( pLang );

            //
            // Check one beyond, just to make some progress removing extra copies.
            //

            if ( !_langsAvailable.AtEnd(iter) &&
                 (dwTick - iter->LastUsed()) > _ulMaxIdle )
            {
                CLanguage *pLangTemp = iter.GetLang();
                _langsAvailable.Advance(iter);
                pLangTemp->Unlink();
                delete pLangTemp;
            }

            break;
        }

        //
        // Is it idle?  Ignore overflow.  It just means we delete too early
        // once every few days.
        //

        if ( (dwTick - iter->LastUsed()) > _ulMaxIdle )
        {
            ciDebugOut(( DEB_LLIST, "deleting idle language object\n" ));

            pLang = iter.GetLang();
            _langsAvailable.Advance(iter);
            pLang->Unlink();
            delete pLang;
            pLang = 0;
        }
        else
            _langsAvailable.Advance(iter);
    }

    ciDebugOut(( DEB_LLIST, "  FindLangAndActivate returning %p\n", pLang ));

    return pLang;
} //FindLangAndActivate

//+---------------------------------------------------------------------------
//
//  Member:     CLangList::ReturnLang, public
//
//  Synopsis:   Returns a Language
//
//  Arguments:  [pLang] -- language to be returned
//
//  History:    15-Aug-94  SitaramR     Created.
//
//----------------------------------------------------------------------------

void CLangList::ReturnLang( CLanguage *pLang )
{
    ULONG dwTick = GetTickCount();

    CLock lock( _mtxList );

    Win4Assert( pLang != 0 );

    if ( pLang->IsZombie() )
        delete pLang;
    else
    {
        // Move from InUse list to Available list.  Put it at the front of
        // the list so we don't cycle through the cached languages.

        pLang->Unlink();
        pLang->SetLastUsed( dwTick );
        _langsAvailable.Push( pLang );
    }
} //ReturnLang

//+---------------------------------------------------------------------------
//
//  Member:     CLangList::InvalidateLangResources, public
//
//  Synopsis:   Delete all language objects so that new language objects
//              can be demand loaded from registry.
//
//  History:    15-Aug-94  SitaramR     Created.
//
//----------------------------------------------------------------------------

void CLangList::InvalidateLangResources()
{
   CLock lock( _mtxList );

   ciDebugOut(( DEB_LLIST, "InvalidateLangResources\n" ));

   for ( CLanguage *pLang = _langsAvailable.Pop();
         0 != pLang;
         pLang = _langsAvailable.Pop() )
   {
       delete pLang;
   }

   for ( pLang = _langsInUse.Pop();
         pLang;
         pLang = _langsInUse.Pop() )
   {
       pLang->Zombify();          // because language is still in use
   }
} //InvalidateLangResources

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultPidHash::LokLookupOrAddLang
//
//  Synopsis:   Sets internal index to the position of langId
//              if langId is found, else creates a langId and
//              a corresponding default pid hash table.
//
//  Arguments:  [langid]    -- langid
//              [stateInfo] -- to set internal langId specific index value.
//
//  Returns:    TRUE    if lang is found
//              FALSE   if lang is not found
//
//  History:    2-27-97     MohamedN    Created
//
//----------------------------------------------------------------------------

BOOL CDefaultPidHash::LokLookupOrAddLang( LANGID langId, CLangPidStateInfo & stateInfo )
{

    BOOL fLangIdFound = FALSE;
    unsigned i;

    //
    // find whether langId is in _aLangId Table
    //

    for ( i = 0; i < _langIdCount ; i++ )
    {
        if ( _aLangId[i] == langId )
        {
            fLangIdFound = TRUE;

            break;
        }
    }

    //
    // if _aLangId is not found in _aLangID table,
    // add it, and create a corresponding hash table for it.
    //

    if ( !fLangIdFound )
    {
        BOOL fAddedLangId = FALSE;

        TRY
        {
            _aLangId.Add( langId, i );

            fAddedLangId = TRUE;

            XPtr<CPidHash> xPidHash( new CPidHash( INIT_PID_HASH_TABLE_SIZE ) );

            _aHashPidTables.Add( xPidHash.GetPointer(), i );

            xPidHash.Acquire();

            _langIdCount++;
        }
        CATCH( CException, e )
        {
            if ( fAddedLangId )
                _aLangId.Remove( i );

            RETHROW();
        }
        END_CATCH
    }

    //
    // store position of langId in our state object (found or created).
    //

    stateInfo.SetLangIndex(i);

    return fLangIdFound;
} //LokLookupOrAddLang

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultPidHash::LokIsUseDefaultPid
//
//  Synopsis:   Determines if the passed-in pid belongs to the
//              default pid group.
//
//  Arguments:  [pid]    -- property id
//              [index]  -- position of langid cache table
//
//  Returns:    TRUE        if pid is a member of the default pid group
//              FALSE       if pid is not a member of the default pid group
//
//  History:    2-27-97     MohamedN        Created
//
//----------------------------------------------------------------------------

BOOL CDefaultPidHash::LokIsUseDefaultPid( PROPID pid, unsigned index )
{
    CWidHashEntry   entry(pid);

    if ( _aHashPidTables[index] )
        return _aHashPidTables[index]->LookUpWorkId( entry );

    Win4Assert( !"invalid _aHashPidTables[index]" );
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultPidHash::LokAddDefaultPid
//
//  Synopsis:   Inserts pid into the default pid hash table for a given langId
//
//  Arguments:  [pid]    -- property id
//              [index]  -- position of langid cache table
//
//  Returns:    none
//
//  History:    2-27-97     MohamedN    Created
//----------------------------------------------------------------------------

void CDefaultPidHash::LokAddDefaultPid( PROPID pid, unsigned index )
{
    CWidHashEntry   entry(pid);

    Win4Assert( _aHashPidTables[index] );

    _aHashPidTables[index]->AddEntry(entry);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanguage::CLanguage
//
//  Synopsis:   Finds language information
//
//  History:    16-Jul-91   BartoszM     Created.
//              15-Aug-94   SitaramR     Changed constructor to take
//                                       wordbreaker and noisefile.
//
//----------------------------------------------------------------------------

#define NOISE_SIZE 257

CLanguage::CLanguage( LCID locale,
                      PROPID    pid,
                      XInterface<IWordBreaker> & xWBreak,
                      XInterface<IStemmer>     & xStemmer,
                      XInterface<IStream>      & xIStrmNoiseFile )
        : _locale( locale ),
          _pid( pid ),
          _xWBreak( xWBreak.Acquire() ),
          _xStemmer( xStemmer.Acquire() ),
          _xIStrmNoiseFile( xIStrmNoiseFile.Acquire() ),
          _zombie( FALSE )
{
    ciDebugOut(( DEB_LLIST, "CLanguage, locale %#x, pid %#x\n", locale, pid ));

    //
    // Set up for filtering noise word list.  This will always use the
    // default filter.  We don't go through CFilterDriver, because that
    // performs too much extra work: Ole binding, property filtering, etc.
    //

    if ( !_xIStrmNoiseFile.IsNull() )
    {
        XInterface<CTextIFilter> xTextIFilter( new CTextIFilter );
        SCODE sc = xTextIFilter->Load( _xIStrmNoiseFile.GetPointer() );
        if ( FAILED(sc) )
        {
            ciDebugOut(( DEB_ERROR, "Filter of pIStrmNoiseFile(%x) returned 0x%x\n",
                         _xIStrmNoiseFile.GetPointer(), sc ));
        }
        else
        {
            ULONG fBulkyObject;
            sc = xTextIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                                     IFILTER_INIT_CANON_HYPHENS |
                                     IFILTER_INIT_CANON_SPACES |
                                     IFILTER_INIT_APPLY_INDEX_ATTRIBUTES |
                                     IFILTER_INIT_INDEXING_ONLY,
                                     0,
                                     0,
                                     &fBulkyObject );
  
            if ( FAILED(sc) )
            {
                ciDebugOut(( DEB_ERROR,
                             "IFilter->Init() of pIStrmNoiseFile(%x) returned 0x%x.\n",
                             _xIStrmNoiseFile.GetPointer(), sc ));
            }
            else
            {
                STAT_CHUNK statChunk;
  
                for ( sc = xTextIFilter->GetChunk( &statChunk );
                      SUCCEEDED(sc) && (statChunk.flags & CHUNK_TEXT) == 0;
                      sc = xTextIFilter->GetChunk( &statChunk ) );
  
                if ( FAILED(sc) )
                {
                    ciDebugOut(( DEB_ERROR,
                                 "IFilter->GetChunk() of pIStrmNoiseFile(%x) returned 0x%x.\n",
                                 _xIStrmNoiseFile.GetPointer(), sc ));
                }
                else
                {
                    CNoiseListInit noiseInit( NOISE_SIZE );
  
                    //
                    // If we got this far, try creating the key maker.
                    //
  
                    CKeyMaker keymak( _xWBreak.GetPointer(), noiseInit );
  
                    OCCURRENCE occ = 0;
                    CTextSource tsource( xTextIFilter.GetPointer(), statChunk );
                    keymak.PutStream( occ, &tsource );
  
                    _xNoiseTable.Set( noiseInit.AcqStringTable() );
                }
            }
        }
    }
    else
    {
        //
        // _xIStrmNoiseFile is null, don't use a noise file in filtering
        //
        ciDebugOut(( DEB_ITRACE,
                     "Creating language object 0x%x, noise file = EMPTY\n",
                     locale ));
    }
} //CLanguage

CLanguage::~CLanguage()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\deflang\noise.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       NOISE.CXX
//
//  Contents:   Noise list
//
//  Classes:    CNoiseList, NoiseListInit, NoiseListEmpty
//              CLString, CStringList, CStringTable
//
//  History:    11-Jul-91   BartoszM    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <noise.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CLString::CLString, public
//
//  Synopsis:   Initializes and links a string list element
//
//  Arguments:  [cb] -- length
//              [buf] -- string
//              [next] -- next link in the chain
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
CLString::CLString ( UINT cb, const BYTE* buf, CLString* next )
{
    _cb = cb;
#if CIDBG == 1
    cb++;
#endif
    memcpy ( _buf, buf, cb );
    _next = next;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLString::operator new, public
//
//  Synopsis:   Allocates a string list element
//
//  Arguments:  [n]    -- size of class instance
//              [cb]   -- length of string buffer needed
//
//  History:    10 Apr 96   AlanW     Created.
//
//----------------------------------------------------------------------------

void *
CLString::operator new ( size_t n, UINT cb )
{
#if CIDBG == 1
    cb++;
#endif
    return new BYTE [n+cb];
}


//+---------------------------------------------------------------------------
//
//  Member:     CStringList::~CStringList, public
//
//  Synopsis:   Free linked list
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
CStringList::~CStringList()
{
    while ( _head != 0 )
    {
        CLString* p = _head;
        _head = _head->Next();
        delete p;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringList::Add, public
//
//  Synopsis:   Adds a string to list
//
//  Arguments:  [cb] -- length
//              [str] -- string
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
void CStringList::Add ( UINT cb, const BYTE * str )
{
    _head = new (cb) CLString ( cb, str, _head );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringList::Find, public
//
//  Synopsis:   Returns TRUE if string found in the list, FALSE otherwise
//
//  Arguments:  [cb] -- length
//              [str] -- string
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
BOOL CStringList::Find ( UINT cb, const BYTE* str ) const
{
    CLString* pStr = _head;
    while ( pStr != 0 )
    {
        if ( pStr->Equal ( cb, str ) )
        {
            return TRUE;
        }
        pStr = pStr->Next();
    }
    return FALSE;
}

#if CIDBG == 1

void CStringList::Dump () const
{
    CLString * p = _head;
    while ( p )
    {
        p->Dump();
        p = p->Next();
    }
    ciDebugOut (( DEB_ITRACE, "\n" ));
}

#endif // CIDBG == 1

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CStringTable, public
//
//  Synopsis:   Create hash table of given size
//
//  Arguments:  [size] -- size
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
CStringTable::CStringTable( UINT size )
{
    _size = size;
    _bucket = new CStringList[size];
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::~CStringTable, public
//
//  Synopsis:   Free linked lists
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
CStringTable::~CStringTable()
{
    delete [] _bucket;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::Add, publid
//
//  Synopsis:   Add a string to hash table
//
//  Arguments:  [cb] -- size
//              [str] -- string
//              [hash] -- precomputed hash value
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
void CStringTable::Add ( UINT cb, const BYTE* str, UINT hash )
{
    _bucket[_index(hash)].Add ( cb, str );
}

#if CIDBG == 1

void CStringTable::Dump () const
{
    for ( unsigned i = 0; i < _size; i++ )
    {
        if ( !_bucket[i].IsEmpty() )
        {
            ciDebugOut (( DEB_ITRACE, "%3d: ", i ));
            _bucket[i].Dump();
        }
    }
}

#endif // CIDBG == 1

//+---------------------------------------------------------------------------
//
//  Member:     CNoiseList::CNoiseList
//
//  Synopsis:   constructor for noise list
//
//  Effects:    gets buffers from key repository
//
//  Arguments:  [krep] -- key repository to give words to.
//
//  History:    05-June-91   t-WadeR     Created.
//
//----------------------------------------------------------------------------
CNoiseList::CNoiseList( const CStringTable& table, PKeyRepository& krep )
    : _krep(krep),
      _table(table),
      _cNoiseWordsSkipped(0),
      _cNonNoiseAltWords(0),
      _fFoundNoise( FALSE )
{
    krep.GetBuffers( &_pcbOutBuf, &_pbOutBuf, &_pocc );
    _cbMaxOutBuf = *_pcbOutBuf;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNoiseList::GetBuffers
//
//  Synopsis:   Returns address of normilizer's input buffers
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//
//  History:    05-June-91   t-WadeR     Created.
//
//----------------------------------------------------------------------------
void    CNoiseList::GetBuffers( UINT** ppcbInBuf, BYTE** ppbInBuf )
{
    // Don't actually have an in buffer, so pass through the out buffer
    *ppbInBuf = _pbOutBuf;
    *_pcbOutBuf = _cbMaxOutBuf;
    *ppcbInBuf = _pcbOutBuf;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNoiseList::GetFlags
//
//  Synopsis:   Returns address of ranking and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    11-Fab-92   BartoszM     Created.
//
//----------------------------------------------------------------------------
void CNoiseList::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    _krep.GetFlags ( ppRange, ppRank );
}


//+---------------------------------------------------------------------------
//
//  Member:     CNoiseList::PutWord
//
//  Synopsis:   If word isn't a noise word, passes it to the key repository
//
//  Effects:    calls _krep.PutKey
//
//  Arguments:  [hash] -- precomputed hash value
//
//  History:    05-June-91   t-WadeR     Created stub.
//
//----------------------------------------------------------------------------
void    CNoiseList::PutWord ( UINT hash )
{
    // Check the word to see if it should pass through.
    if ( _table.Find ( *_pcbOutBuf, _pbOutBuf, hash ))
    {
        _fFoundNoise = TRUE;

        //
        // if all alternate words at current occurrence have been noise words,
        //   then it is equivalent to one noise word at current occcurrence,
        //   hence increment count of noise words skipped
        //
        if ( _cNonNoiseAltWords == 0 )
            _cNoiseWordsSkipped++;
    }
    else
    {
        //
        // output word to key repository. The count of noise words skipped refers to
        //   noise words at previous occurrences only
        //
        _krep.PutKey( _cNoiseWordsSkipped );
        _cNoiseWordsSkipped = 0;
    }

    // reset count of non-noise words in preparation for word at next occurrence
    _cNonNoiseAltWords = 0;

    (*_pocc)++;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNoiseList::PutAltWord
//
//  Synopsis:   If word isn't a noise word, passes it to the key repository
//
//  Effects:    calls _krep.PutKey
//
//  Arguments:  [hash] -- precomputed hash value
//
//  History:    03-May-95   SitaramR     Created
//
//----------------------------------------------------------------------------
void    CNoiseList::PutAltWord ( UINT hash )
{
    // Check the word to see if it should pass through.
    if ( _table.Find ( *_pcbOutBuf, _pbOutBuf, hash ) )
    {
        _fFoundNoise = TRUE;
    }
    else
    {
        //
        // since this is not the last of a sequence of alternate words we increment
        //   count of non-noise words at current occurrence
        //
        _cNonNoiseAltWords++;

        //
        // output word to key repository. The count of noise words skipped refers to
        //   noise words at previous occurrences only
        //
        _krep.PutKey( _cNoiseWordsSkipped );
        _cNoiseWordsSkipped = 0;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CNoiseList::StartAltPhrase
//
//  History:    29-Nov-94   SitaramR     Created
//
//----------------------------------------------------------------------------

void CNoiseList::StartAltPhrase()
{
    _krep.StartAltPhrase( _cNoiseWordsSkipped );
    _cNoiseWordsSkipped = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNoiseList::EndAltPhrase
//
//  History:    29-Nov-94   SitaramR     Created
//
//----------------------------------------------------------------------------

void CNoiseList::EndAltPhrase()
{
    _krep.EndAltPhrase( _cNoiseWordsSkipped );
    _cNoiseWordsSkipped = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListInit::CNoiseListInit
//
//  Synopsis:   Creates a hash table to be filled
//
//  Arguments:  [size] -- size of the hash table (possibly prime #)
//
//  History:    15-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------

CNoiseListInit::CNoiseListInit ( UINT size )
{
    _table = new CStringTable ( size );

    END_CONSTRUCTION( CNoiseListInit );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListInit::GetBuffers
//
//  Synopsis:   Returns address of repository's input buffers
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//
//  History:    15-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------

void  CNoiseListInit::GetBuffers( UINT** ppcbInBuf, BYTE** ppbInBuf )
{
    _key.SetCount(MAXKEYSIZE);
    *ppcbInBuf = _key.GetCountAddress();
    *ppbInBuf = _key.GetWritableBuf();
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListInit::PutWord
//
//  Synopsis:   Puts a key into the hash table
//
//  Arguments:  [hash] -- hash value
//
//  History:    15-Jul-91   BartoszM     Created
//
//----------------------------------------------------------------------------
void CNoiseListInit::PutWord ( UINT hash )
{
    _table->Add ( _key.Count(), _key.GetBuf(), hash );
}


//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListInit::PutAltWord
//
//  Synopsis:   Puts a key into the hash table
//
//  Arguments:  [hash] -- hash value
//
//  History:    03-May-95     SitaramR    Created
//
//----------------------------------------------------------------------------
void CNoiseListInit::PutAltWord ( unsigned hash )
{
    PutWord( hash );
}



//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListEmpty::CNoiseListEmpty
//
//  Synopsis:   constructor for a default empty noise list
//
//  Effects:    gets buffers from key repository
//
//  Arguments:  [krep] -- key repository to give words to.
//              [ulFuzzy] -- Fuzziness of query
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
CNoiseListEmpty::CNoiseListEmpty( PKeyRepository& krep, ULONG ulFuzzy )
    : _krep(krep),
      _ulGenerateMethod(ulFuzzy),
      _cNoiseWordsSkipped(0),
      _cNonNoiseAltWords(0),
      _fFoundNoise( FALSE )
{
    krep.GetBuffers( &_pcbOutBuf, &_pbOutBuf, &_pocc );
    _cbMaxOutBuf = *_pcbOutBuf;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListEmpty::GetBuffers
//
//  Synopsis:   Returns address of normilizer's input buffers
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//
//  History:    16-Jul-91   BartoszM     Created.
//
//----------------------------------------------------------------------------
void    CNoiseListEmpty::GetBuffers( UINT** ppcbInBuf, BYTE** ppbInBuf )
{
    // Don't actually have an in buffer, so pass through the out buffer
    *ppbInBuf = _pbOutBuf;
    *_pcbOutBuf = _cbMaxOutBuf;
    *ppcbInBuf = _pcbOutBuf;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListEmpty::GetFlags
//
//  Synopsis:   Returns address of ranking and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    11-Fab-92   BartoszM     Created.
//
//----------------------------------------------------------------------------
void CNoiseListEmpty::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    _krep.GetFlags ( ppRange, ppRank );
}



//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListEmpty::PutWord
//
//  Synopsis:   If word isn't a noise word, passes it to the key repository
//
//  Effects:    calls _krep.PutKey
//
//  Arguments:  [hash] -- hash value (ignored)
//
//  History:    16-Jul-91   BartoszM     Created
//
//  Notes:      Filters out one letter words, unless it is a prefix (*) query
//
//----------------------------------------------------------------------------
void    CNoiseListEmpty::PutWord ( UINT )
{
    //
    // Even though the noise list is empty, we are modeling PutBreak()
    // by a skip of appropriate number of noise words, and we are counting
    // 1 letter words as noise words. Note that the length is in bytes and there is
    // a 1 byte prefix.
    //
    if ( _ulGenerateMethod != GENERATE_METHOD_PREFIX && *_pcbOutBuf <= NOISE_WORD_LENGTH )
    {
        _fFoundNoise = TRUE;

        //
        // if all alternate words at current occurrence have been noise words,
        //   then it is equivalent to one noise word at current occcurrence,
        //   hence increment count of noise words skipped
        //
        if ( _cNonNoiseAltWords == 0 )
            _cNoiseWordsSkipped++;
    }
    else
    {
        //
        // output word to key repository. The count of noise words skipped refers to
        //   noise words at previous occurrences only
        //
        _krep.PutKey( _cNoiseWordsSkipped );
        _cNoiseWordsSkipped = 0;
    }

    // reset count of non-noise words in preparation for word at next occurrence
    _cNonNoiseAltWords = 0;

    (*_pocc)++;
}




//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListEmpty::PutAltWord
//
//  Synopsis:   If word isn't a noise word, passes it to the key repository
//
//  Effects:    calls _krep.PutKey
//
//  Arguments:  [hash] -- precomputed hash value
//
//  History:    03-May-95   SitaramR     Created
//
//  Notes:      Filters out one letter words, unless it is a prefix (*) query
//
//----------------------------------------------------------------------------
void    CNoiseListEmpty::PutAltWord ( UINT hash )
{
    //
    // Even though the noise list is empty, we are modeling PutBreak()
    // by a skip of appropriate number of noise words, and we are counting
    // 1 letter words as noise words. Note that the length is in bytes and there is
    // a 1 byte prefix.
    //
    if ( _ulGenerateMethod == GENERATE_METHOD_PREFIX || *_pcbOutBuf > NOISE_WORD_LENGTH )
    {
        //
        // since this is not the last of a sequence of alternate words we increment
        //   count of non-noise words at current occurrence
        //

        _cNonNoiseAltWords++;

        //
        // output word to key repository. The count of noise words skipped refers to
        //   noise words at previous occurrences only
        //

        _krep.PutKey( _cNoiseWordsSkipped );
        _cNoiseWordsSkipped = 0;
    }
    else
        _fFoundNoise = TRUE;
}




//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListEmpty::StartAltPhrase
//
//  Synopsis:   Pass on StartAltPhrase to key repository
//
//  History:    20-Feb-95   SitaramR     Created
//
//----------------------------------------------------------------------------

void CNoiseListEmpty::StartAltPhrase()
{
    _krep.StartAltPhrase( _cNoiseWordsSkipped );
    _cNoiseWordsSkipped = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNoiseListEmpty::EndAltPhrase
//
//  Synopsis:   Pass on EndAltPhrase to key repository
//
//  History:    20-Feb-95   SitaramR     Created
//
//----------------------------------------------------------------------------

void CNoiseListEmpty::EndAltPhrase()
{
    _krep.EndAltPhrase( _cNoiseWordsSkipped );
    _cNoiseWordsSkipped = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\bmkacc.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998-2000.
//
// File:        BmkAcc.cxx
//
// Contents:    Distributed Bookmark accessor class
//
// Classes:     CDistributedBookmarkAccessor
//
// History:     25-Sep-98       VikasMan       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "bmkacc.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedBookmarkAccessor::CDistributedBookmarkAccessor, public
//
//  Synopsis:   Builds the bookmark accessors
//
//  Arguments:  [aCursor]         -- Child rowsets.
//              [cCursor]         -- Count of [aCursor].
//              [dwAccessorFlags] -- Binding type.
//              [pStatus]         -- Status reported here.  May be null.
//              [iBookmark]       -- Ordinal of bookmark column.
//              [cbBookmark]      -- Size of bookmark.
//
//  History:    28-Sep-98   VikasMan       Created.
//              06-Jan-2000 KLam           Fixed bindings
//
//----------------------------------------------------------------------------

CDistributedBookmarkAccessor::CDistributedBookmarkAccessor( 
                                  IRowset ** const aCursor,
                                  unsigned cCursor,
                                  DBACCESSORFLAGS dwAccessorFlags,
                                  DBBINDSTATUS* pStatus,
                                  DBORDINAL iBookmark,
                                  DBBKMARK cbBookmark )
{
    Win4Assert( aCursor && cCursor > 0 );

    DBBINDING bindBmk;
    DBBINDSTATUS bmkBindStatus;
    unsigned iChild;
    SCODE sc = S_OK;
    SCODE scLast = S_OK;

    TRY
    {
        _xIacc.Init( cCursor );

        for ( iChild = 0; iChild < cCursor; iChild++ )
        {
            sc = aCursor[iChild]->QueryInterface( IID_IAccessor,
                                                  _xIacc[iChild].GetQIPointer() );
            if ( FAILED(sc) )
            {
                scLast = sc;
                vqDebugOut(( DEB_ERROR,
                             "CDistributedBookmarkAccessor: CreateAccessor(child %d) returned 0x%x\n",
                             iChild, sc ));
                // Don't throw here. We want to continue on and catch all possible errors
            }
        }
    
        if (FAILED(scLast))
        {
            THROW( CException(scLast) );
        }
    
        // Binding structure for child bookmarks
        //----------------------------------//
        // Cursor# | Value1 | Value2 | ...  //  // The first 4 bytes are shared by cursor #
        // Status                           //  // and status
        //----------------------------------//
    
        _xhaccBookmark.Init( cCursor );
    
        RtlZeroMemory( &bindBmk, sizeof bindBmk );
        bindBmk.iOrdinal = iBookmark;
        bindBmk.wType    = DBTYPE_BYTES;
        bindBmk.dwPart   = DBPART_VALUE | DBPART_STATUS;
        bindBmk.cbMaxLen = ( cbBookmark - sizeof(DBROWSTATUS) ) / cCursor;
        bindBmk.obValue  = sizeof( DBROWSTATUS );
        bindBmk.obStatus = 0;
                                                            
        for ( iChild = 0 ; iChild < cCursor; iChild++ )
        {
            sc = _xIacc[iChild]->CreateAccessor( dwAccessorFlags,
                                                 1,
                                                 &bindBmk,
                                                 0,
                                                 &(_xhaccBookmark[iChild]),
                                                 &bmkBindStatus );
            if ( FAILED(sc) )
            {
                // remember that at least one child failed to create accessor
                scLast = sc;
    
                if ( pStatus && S_OK != scLast )
                {
                    // set Status to reflect the failure in binding the bookmark column
                   *pStatus = bmkBindStatus;
                }

                vqDebugOut(( DEB_ERROR,
                             "CDistributedAccessor: CreateAccessor for bookmark(child %d) returned 0x%x\n",
                             iChild, sc ));
                // Don't throw here. We want to continue on and find all failures
                continue;
            }
    
            bindBmk.obValue += bindBmk.cbMaxLen;
        }
    
        if (FAILED(scLast))
        {
            THROW( CException(scLast) );
        }
    }
    CATCH( CException, e )
    {
        _ReleaseAccessors();

        RETHROW();
    }
    END_CATCH

    Win4Assert( SUCCEEDED(sc) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDistributedBookmarkAccessor::ReleaseAccessors, private
//
//  Synopsis:   Release all the bookmark accessors
//
//  Arguments:  none
//
//  History:    28-Sep-98   VikasMan       Created.
//
//----------------------------------------------------------------------------

void CDistributedBookmarkAccessor::_ReleaseAccessors()
{
    unsigned iChild;
    
    for ( iChild = 0; iChild < _xIacc.Count(); iChild++ )
    {
        if ( _xIacc[iChild].GetPointer() && _xhaccBookmark[iChild] )
        {
            _xIacc[iChild]->ReleaseAccessor( _xhaccBookmark[iChild], 0 );
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDistributedBookmarkAccessor::GetData, public
//
//  Synopsis:   Fetches the bookmark data
//
//  Arguments:  [iChild]          -- Index of child cursor from which base data is
//                                   to be fetched.  Indicates 'current' row in [ahrow].
//              [ahrow]           -- 'Top' HROW for all cursors.  Used for bookmark
//                                   hints.
//              [pBookmarkData]   -- Value returned here, starting at offset 0
//              [cbBookmark]      -- Length of bookmark
//              [aCursor]         -- Child Rowsets
//              [cCursor]         -- Count of child cursors
//              [pStatus]         -- GetData Status returned here, if pStatus is not null
//
//  Returns:    SCODE
//
//  History:    28-Sep-98   VikasMan       Created.
//
//----------------------------------------------------------------------------

SCODE CDistributedBookmarkAccessor::GetData( unsigned iChild, HROW * ahrow, void * pBookmarkData, 
                                             DBBKMARK cbBookmark, IRowset * * const aCursor,
                                             ULONG cCursor, SCODE * pStatus )
{
    SCODE sc = S_OK;

    RtlFillMemory( pBookmarkData, cbBookmark, 0xFF );

    if ( pStatus )
    {
        *pStatus = DBSTATUS_S_OK;
    }

    for ( unsigned i = 0; i < cCursor; i++ )
    {
        SCODE sc2 = S_OK;

        if ( ahrow[i] != (HROW)0xFFFFFFFF )
        {
            sc2 = aCursor[i]->GetData( ahrow[i], GetHAccessor(i), pBookmarkData );

            if ( SUCCEEDED(sc2) && pStatus && DBSTATUS_S_OK == *pStatus )
            {
                *pStatus = *( (SCODE*)pBookmarkData );
            }
        }

        if ( FAILED(sc2) )
        {
            if ( i == iChild )
            {
                vqDebugOut(( DEB_ERROR, "CDistributedBookmarkAccessor::GetData: Child GetData returned 0x%x\n", sc ));
                sc = sc2;
                break;
            }
            else
            {
                // This can fail as we can have a invalid row handle for hints
                vqDebugOut(( DEB_TRACE, "CDistributedBookmarkAccessor::GetData: Child GetData returned 0x%x\n", sc ));
                continue;
            }
        }
    }

    *(ULONG UNALIGNED *)(pBookmarkData) = iChild;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\disacc.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 1998.
//
// File:        DisAcc.cxx
//
// Contents:    Distributed accessor class
//
// Classes:     CDistributedAccessor
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//
// Notes:       See DisBmk.hxx for a description of distriubted bookmark
//              format.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "disacc.hxx"
#include "bmkacc.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedAccessor::CDistributedAccessor, public
//
//  Synopsis:   Builds bindings to fetch bookmark.
//
//  Arguments:  [aCursor]         -- Child rowsets.
//              [cCursor]         -- Count of [aCursor].
//              [dwAccessorFlags] -- Binding type.
//              [cBindings]       -- Count of bindings in [rgBindings].
//              [rgBindings]      -- Bindings. One per bound column.
//              [rgStatus]        -- Status reported here.  May be null.
//              [iBookmark]       -- Ordinal of bookmark column.
//              [cbBookmark]      -- Size of bookmark.
//              [pCreator]        -- IRowset pointer of creator
//              [rgAllBindings]   -- rgBindings does not contain the bookmark bindings.
//                                   This param contains all the bindings.
//              [cAllBindings]    -- Count of all bindings
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CDistributedAccessor::CDistributedAccessor( IRowset ** const aCursor,
                                            unsigned cCursor,
                                            DBACCESSORFLAGS dwAccessorFlags,
                                            DBCOUNTITEM cBindings,
                                            DBBINDING const * rgBindings,
                                            DBLENGTH cbRowWidth,
                                            DBBINDSTATUS rgStatus[],
                                            void * pCreator,
                                            DBBINDING const * rgAllBindings,
                                            DBCOUNTITEM cAllBindings )
        : 
          CAccessorBase(pCreator, CAccessorBase::eRowDataAccessor),
          _aCursor( aCursor ),
          _cCursor( cCursor ),
          _aIacc( 0 ),
          _ahaccBase( 0 ),
          _pDistBmkAcc( 0 ),
          _cBookmark( 0 ),
          _cBookmarkOffsets( 0 ),
          _cAllBindings( 0 ),
          _dwAccessorFlags( dwAccessorFlags )
{
    SCODE sc = S_OK;
    SCODE scLast = S_OK;
    unsigned cChildIacc = 0;
    unsigned iChildBase = 0;
    unsigned iChildBookmark = 0;

    // make a copy of all the bindings
    Win4Assert( rgAllBindings && cAllBindings > 0 );

    _cAllBindings = cAllBindings;

    _xAllBindings.Init( (ULONG) _cAllBindings );

    RtlCopyMemory( _xAllBindings.GetPointer(),
                   rgAllBindings,
                   sizeof( DBBINDING ) * _cAllBindings );

    // Copy DBOBJECTs
    for ( unsigned iBinding = 0; iBinding < _cAllBindings; iBinding++ )
    {
        if ( 0 != rgAllBindings[iBinding].pTypeInfo ||
             0 != rgAllBindings[iBinding].pBindExt )
        {
            // These should be NULL as per OLE DB 2.0
            if ( rgStatus )
            {
                rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
            }
            
            scLast = DB_E_ERRORSOCCURRED;
        }

        if ( rgAllBindings[iBinding].pObject )
        {
            _xAllBindings[iBinding].pObject = new DBOBJECT;
            RtlCopyMemory( _xAllBindings[iBinding].pObject, 
                           rgAllBindings[iBinding].pObject,
                           sizeof( DBOBJECT ) );
        }
    }

    if ( 0 == cBindings )
    {
        if (FAILED(scLast))
            THROW( CException(scLast) );

        // 0 bindings - can occur if the bindings only had a bookmark column

        return;
    }

    XArray<DBBINDSTATUS> rgStatTmp( (unsigned) cBindings );

    TRY
    {
        //
        // Get accessors from child cursors.  All column requests except bookmark
        // can be satisfied by a single child cursor.  Note that we actually fetch
        // the child bookmark here, since it may be a binding(s).  We just throw
        // that bookmark away.  It would be too much trouble to find it later.
        //

        _ahaccBase = new HACCESSOR [ _cCursor ];
        _aIacc = new IAccessor* [ _cCursor ];
        RtlZeroMemory(_aIacc, sizeof (IAccessor*) * _cCursor);

        for ( ; iChildBase < _cCursor; iChildBase++ )
        {
            sc = _aCursor[iChildBase]->QueryInterface( IID_IAccessor,
                                                 (void **)&_aIacc[iChildBase] );
            if (SUCCEEDED( sc ))
            {
                cChildIacc++;
                sc = _aIacc[iChildBase]->CreateAccessor( dwAccessorFlags,
                                          cBindings,
                                          rgBindings,
                                          cbRowWidth,
                                          &_ahaccBase[iChildBase],
                                          rgStatTmp.GetPointer());


                if (sc == DB_S_ERRORSOCCURRED && rgStatus)
                    for (ULONG i = 0; i < cBindings; i++)
                        if (rgStatTmp[i] != DBBINDSTATUS_OK)
                            rgStatus[i] = rgStatTmp[i];
            }

            if ( FAILED(sc) )
            {
                scLast = sc;
                vqDebugOut(( DEB_ERROR,
                             "CDistributedAccessor: CreateAccessor(child %d) returned 0x%x\n",
                             iChildBase, sc ));
                // Don't throw here. We want to continue on and catch all possible errors
                continue;
            }
        }

        if (FAILED(scLast))
                THROW( CException(scLast) );

    }
    CATCH( CException, e )
    {
        //
        // Cleanup as best we can on failure.
        //
        for ( ; iChildBase > 0; iChildBase-- )
        {
            _aIacc[iChildBase-1]->ReleaseAccessor( _ahaccBase[iChildBase-1], 0 );
        }

        for ( ; cChildIacc > 0; cChildIacc-- )
        {
            _aIacc[cChildIacc-1]->Release();
        }

        delete [] _aIacc;
        _aIacc = 0;
        delete [] _ahaccBase;
        _ahaccBase = 0;

        RETHROW();
    }
    END_CATCH

    Win4Assert( SUCCEEDED(sc) );
}


void CDistributedAccessor::SetupBookmarkAccessor( 
                               CDistributedBookmarkAccessor * pDistBmkAcc, 
                               DBBINDSTATUS rgStatus[],
                               DBORDINAL iBookmark,
                               DBBKMARK cBookmark )
{
    _cBookmark = cBookmark;

    //
    // Look for bookmark binding(s)
    //
    for ( unsigned i = 0; i < _cAllBindings; i++ )
    {
        if ( _xAllBindings[i].iOrdinal == iBookmark )
        {

            if ( ( _xAllBindings[i].wType & ~DBTYPE_BYREF) != DBTYPE_BYTES )
            {
                if ( rgStatus )
                    rgStatus[i] = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
                continue;
            }

            _xBookmarkOffsets.ReSize( _cBookmarkOffsets + 1 );

            _xBookmarkOffsets[_cBookmarkOffsets] = &_xAllBindings[i];

            _cBookmarkOffsets++;
        }
    }

    if ( _cBookmarkOffsets )
    {
        _pDistBmkAcc = pDistBmkAcc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedAccessor::~CDistributedAccessor, public
//
//  Synopsis:   Destructor.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CDistributedAccessor::~CDistributedAccessor()
{
    // We should have no references left to it
   Win4Assert(GetRefcount() == 0); 

    // Delete DBOBJECTs
    for ( unsigned iBinding = 0; iBinding < _cAllBindings; iBinding++ )
    {
        if ( _xAllBindings[iBinding].pObject )
        {
            delete _xAllBindings[iBinding].pObject;
        }

        // These are for future use according to OLE-DB 2.0 and should be NULL
        Win4Assert( 0 == _xAllBindings[iBinding].pTypeInfo &&
                    0 == _xAllBindings[iBinding].pBindExt );
    }

   delete [] _ahaccBase;
   delete [] _aIacc;

   CAccessorBase * pParent = GetParent();
   
   if (pParent) 
   {  
      if (0 == pParent->DecInheritors() && 0 == pParent->GetRefcount()) 
      {
         delete pParent;
      }
   }

}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedAccessor::Release, public
//
//  Synopsis:   Release all resources (accessors)
//
//  Returns:    SCODE
//
//  History:    05-Jun-95   KyleP       Created.
//
//  Notes:      Even on error, we still try to release as much as possible.
//
//----------------------------------------------------------------------------

ULONG CDistributedAccessor::Release()
{
    SCODE sc = S_OK;

    if ( 0 == CAccessorBase::Release())
    {
        if ( 0 != _aIacc )
        {
            for ( unsigned iChild = 0; iChild < _cCursor; iChild++ )
            {
                Win4Assert (0 != _aIacc[iChild]);

                //
                // If this call throws (which it shouldn't accoring to spec)
                // we could miss release of some child accessors.
                //

                SCODE scTemp = _aIacc[iChild]->ReleaseAccessor( _ahaccBase[iChild], 0 );

                if ( sc == S_OK )
                    sc = scTemp;

                /*
                if ( 0 != _ahaccBookmark )
                {
                    //
                    // If this call throws (which it shouldn't accoring to spec)
                    // we could miss release of some child accessors.
                    //

                    SCODE scTemp = _aIacc[iChild]->ReleaseAccessor( _ahaccBookmark[iChild], 0 );

                    if ( sc == S_OK )
                        sc = scTemp;
                }
                */
                _aIacc[iChild]->Release();
                _aIacc[iChild] = 0;
            }
        }
    } 

    if (FAILED(sc)) 
    {
       THROW( CException(sc) );
    }

    return( _cRef );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedAccessor::GetBindings, public
//
//  Synopsis:   Retrieve a copy of client bindings.
//
//  Arguments:  [pdwAccessorFlags]   -- Bind type returned here.
//              [pcBindings]         -- Count of bindings in [prgBindings] returned
//                                      here.
//              [prgBindings]        -- Bindings.
//
//  Returns:    SCODE
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

SCODE CDistributedAccessor::GetBindings( DBACCESSORFLAGS * pdwAccessorFlags,
                                         DBCOUNTITEM * pcBindings,
                                         DBBINDING * * prgBindings )
{
    Win4Assert( pdwAccessorFlags && pcBindings && prgBindings );

    *pcBindings       = 0;
    *prgBindings      = 0;
    *pdwAccessorFlags = DBACCESSOR_INVALID;

    Win4Assert( _cAllBindings && _xAllBindings.GetPointer() );

    *prgBindings = (DBBINDING *) newOLE( sizeof( DBBINDING ) * (ULONG) _cAllBindings );

    RtlCopyMemory( *prgBindings,
                   _xAllBindings.GetPointer(),
                   sizeof( DBBINDING ) * _cAllBindings );

    // Copy DBOBJECTs
    for ( unsigned iBinding = 0; iBinding < _cAllBindings; iBinding++ )
    {
        if ( _xAllBindings[iBinding].pObject )
        {
            (*prgBindings)[iBinding].pObject = (DBOBJECT*) newOLE( sizeof( DBOBJECT ) );

            RtlCopyMemory( (*prgBindings)[iBinding].pObject, 
                           _xAllBindings[iBinding].pObject,
                           sizeof( DBOBJECT ) );
        }

        // These are for future use according to OLE-DB 2.0 and should be NULL
        Win4Assert( 0 == _xAllBindings[iBinding].pTypeInfo &&
                    0 == _xAllBindings[iBinding].pBindExt );
    }

    *pcBindings       = _cAllBindings;
    *pdwAccessorFlags =_dwAccessorFlags;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedAccessor::GetData, public
//
//  Synopsis:   Fetches data.
//
//  Arguments:  [iChild] -- Index of child cursor from which base data is
//                          to be fetched.  Indicates 'current' row in [ahrow].
//              [hrow]   -- HROW for iChild cursor.
//              [pData]  -- Base for client's data.
//
//  Returns:    SCODE
//
//  History:    05-Jun-95   KyleP       Created.
//
//  Notes:      This optimized version doesn't fetch bookmark(s).
//
//----------------------------------------------------------------------------

SCODE CDistributedAccessor::GetData( unsigned iChild, HROW hrow, void * pData )
{
    //
    // Fetch base columns
    //

    return ( _ahaccBase ? 
                _aCursor[iChild]->GetData( hrow, _ahaccBase[iChild], pData ) :
                S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedAccessor::GetData, public
//
//  Synopsis:   Fetches data, including bookmark column.
//
//  Arguments:  [iChild] -- Index of child cursor from which base data is
//                          to be fetched.  Indicates 'current' row in [ahrow].
//              [ahrow]  -- 'Top' HROW for all cursors.  Used for bookmark
//                          hints.
//              [pData]  -- Base for client's data.
//
//  Returns:    SCODE
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

SCODE CDistributedAccessor::GetData( unsigned iChild, HROW * ahrow, void * pData )
{
    //
    // Fetch base columns
    //

    SCODE sc = GetData( iChild, ahrow[iChild], pData );
        
    //
    // If we have bookmark columns, fetch those too.
    //

    SCODE Status;
    XGrowable<BYTE> xBookmarkData;

    if ( SUCCEEDED( sc ) && 0 != _pDistBmkAcc )
    {
        xBookmarkData.SetSize( (unsigned) _cBookmark );

        // Fetch bookmark data and value

        sc = _pDistBmkAcc->GetData( iChild, 
                                    ahrow, 
                                    xBookmarkData.Get(),
                                    _cBookmark, 
                                    _aCursor,
                                    _cCursor,
                                    &Status );

        if ( SUCCEEDED(sc) )
        {
            // Copy the bookmark data across various bindings
            for ( unsigned i = 0; i < _cBookmarkOffsets; i++ )
            {
                if ( _xBookmarkOffsets[i]->dwPart & DBPART_VALUE )
                {
                    BYTE * pDest;

                    // is the dest byref
                    if ( (_xBookmarkOffsets[i]->wType & DBTYPE_BYREF) == DBTYPE_BYREF )
                    {
                        pDest = (BYTE*) newOLE( (unsigned) _cBookmark );
                        *((ULONG_PTR*)((BYTE*)pData + _xBookmarkOffsets[i]->obValue)) = 
                            (ULONG_PTR)pDest;
                    }
                    else
                    {
                        pDest = (BYTE *)pData + _xBookmarkOffsets[i]->obValue;
                    }

                    RtlCopyMemory( pDest, xBookmarkData.Get(), _cBookmark );
                }

                if ( _xBookmarkOffsets[i]->dwPart & DBPART_LENGTH )
                    *(DBBKMARK UNALIGNED *)((BYTE *)pData + _xBookmarkOffsets[i]->obLength) = _cBookmark;


                if ( _xBookmarkOffsets[i]->dwPart & DBPART_STATUS )
                    *(DBBKMARK UNALIGNED *)((BYTE *)pData + _xBookmarkOffsets[i]->obStatus) = Status;
            }
        }
    }

    return( sc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\deflang\defbreak.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1994.
//
//  File:       DefBreak.cxx
//
//  Contents:   Text Word Breaker
//
//  History:    08-May-91   t-WadeR     Created stubs, filled in ASCII code.
//              06-Jun-91   t-WadeR     Changed to use input-based pipeline
//              11-Apr-92   KyleP       Sync to spec
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <DefBreak.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::CDefWordBreaker
//
//  Synopsis:   Constructor for the CDefWordBreaker class.
//
//  History:    07-June-91  t-WadeR     Created
//              12-Oct-92   AmyA        Added Unicode support
//
//----------------------------------------------------------------------------

CDefWordBreaker::CDefWordBreaker()
        : _cRefs(1)
{
    ciDebugOut(( DEB_ITRACE, "Creating default wordbreaker\n" ));

    // Look at IsWordChar. We don't want the last non-breaking
    // space in the chunk to be considered a word break.
    // It will be processed again (correctly) when we move to the next chunk.

    _aCharInfo3 [CDefWordBreaker::ccCompare] = C3_NONSPACING;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//----------------------------------------------------------------------------

CDefWordBreaker::~CDefWordBreaker()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CDefWordBreaker::QueryInterface( REFIID riid,
                                                         void ** ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    if ( IID_IWordBreaker == riid )
        *ppvObject = (IUnknown *)(IWordBreaker *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CDefWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CDefWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//  History:    11-Apr-1994  KyleP       Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CDefWordBreaker::Init( BOOL fQuery,
                                               ULONG ulMaxTokenSize,
                                               BOOL *pfLicense )
{
    if ( 0 == pfLicense )
        return E_INVALIDARG;

    *pfLicense = FALSE;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreaker::IsWordChar
//
//  Synopsis:   Find whether the i'th character in the buffer _awString
//              is a word character (rather than word break)
//
//  Arguments:  [i] -- index into _awString
//
//  History:    22-Jul-1994  BartoszM       Created
//
//--------------------------------------------------------------------------

inline BOOL CDefWordBreaker::IsWordChar (int i) const
{
    if (   (_aCharInfo1[i] & (C1_ALPHA | C1_DIGIT))
        || (_aCharInfo3[i] & C3_NONSPACING)  )
    {
        return TRUE;
    }

    WCHAR c = _pwcChunk[i];

    if (c == L'_')
        return TRUE;

    if (c == 0xa0) // non breaking space
    {
        // followed by a non-spacing character
        // (looking ahead is okay)
        if (_aCharInfo3[i+1] & C3_NONSPACING)
            return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::ScanChunk
//
//  Synopsis:   For each character find its type
//
//
//  History:    16-Aug-94  BartoszM     Created
//
//----------------------------------------------------------------------------

BOOL CDefWordBreaker::ScanChunk ()
{

    //
    // GetStringTypeW is returning error 87 (ERROR_INVALID_PARAMETER) if
    // we pass in a null string.
    //
    Win4Assert( (0 != _cMapped) && (0 != _pwcChunk) );

    if ( !GetStringTypeW( CT_CTYPE1,              // POSIX character typing
                          _pwcChunk,              // Source
                          _cMapped,               // Size of source
                          _aCharInfo1 ) )         // Character info
    {
        ciDebugOut(( DEB_ERROR, "GetStringTypeW returned %d\n",
                     GetLastError() ));
        return FALSE;
    }

    if ( !GetStringTypeW( CT_CTYPE3,              // Additional POSIX
                          _pwcChunk,
                          _cMapped,               // Size of source
                          _aCharInfo3 ) )         // Character info 3
    {
        ciDebugOut(( DEB_ERROR, "GetStringTypeW CTYPE3 returned %d\n",
                     GetLastError() ));
        return FALSE;
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] - source of input buffers
//              [pWordSink] - sink for words
//              [pPhraseSink] - sink for noun phrases
//
//  History:    07-June-91  t-WadeR     Created
//              12-Oct-92   AmyA        Added Unicode support
//              18-Nov-92   AmyA        Overloaded
//              11-Apr-94   KyleP       Sync with spec
//              26-Aug-94   BartoszM    Fixed Unicode parsing
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CDefWordBreaker::BreakText( TEXT_SOURCE *pTextSource,
                                                    IWordSink *pWordSink,
                                                    IPhraseSink *pPhraseSink )
{
    if ( 0 == pTextSource )
        return E_INVALIDARG;

    if ( 0 == pWordSink || pTextSource->iCur == pTextSource->iEnd)
        return S_OK;

    if (pTextSource->iCur > pTextSource->iEnd)
    {
        Win4Assert ( !"BreakText called with bad TEXT_SOURCE" );
        return E_FAIL;
    }

    SCODE sc = S_OK;

    ULONG cwc, cwcProcd;     // cwcProcd is # chars actually processed by Tokenize()
    TRY
    {
        do
        {
            //
            // Flag for first time thru loop below. This is to fix the case
            // where the length of the buffer passed in is less than
            // MAX_II_BUFFER_LEN. In this case iEnd-iCur is <= MAX_II_BUFFER_LEN
            // and we break out the inner loop and call
            // pfnFillTextBuffer without having processed any characters,
            // and so pfnFillTextBuffer returns TRUE without adding any new
            // characters and this results in an infinite loop.
            //
            BOOL fFirstTime = TRUE;

            while ( pTextSource->iCur < pTextSource->iEnd )
            {
                cwc = pTextSource->iEnd - pTextSource->iCur;

                //
                // Process in buckets of MAX_II_BUFER_LEN only
                //
                if ( cwc >= CDefWordBreaker::ccCompare )
                    cwc = CDefWordBreaker::ccCompare;
                else if ( !fFirstTime )
                    break;

                Tokenize( pTextSource, cwc, pWordSink, cwcProcd );

                Win4Assert( cwcProcd <= cwc );

                pTextSource->iCur += cwcProcd;

                fFirstTime = FALSE;
            }
        } while ( SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)) );

        cwc = pTextSource->iEnd - pTextSource->iCur;

        // we know that the remaining text should be less than ccCompare
        Win4Assert( cwc < CDefWordBreaker::ccCompare );

        if ( 0 != cwc )
        {
            Tokenize( pTextSource, cwc, pWordSink, cwcProcd );
        }

    }
    CATCH (CException, e)
    {
        ciDebugOut(( DEB_ITRACE,
                     "Exception 0x%x caught when breaking text in default wordbreaker\n",
                     e.GetErrorCode() ));

        sc = GetOleError( e );
    }
    END_CATCH

    return sc;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::Tokenize
//
//  Synopsis:   Tokenize the input buffer into words
//
//  Arguments:  [pTextSource]  --  input text source
//              [cwc]          --  # chars to process
//              [pWordSink]    --  sink for words
//              [cwcProd]      --  # chars actually processed returned here
//
//  History:    10-Aug-95   SitaramR    Created
//
//----------------------------------------------------------------------------

void CDefWordBreaker::Tokenize( TEXT_SOURCE *pTextSource,
                                ULONG cwc,
                                IWordSink *pWordSink,
                                ULONG& cwcProcd )
{
    _pwcChunk = &pTextSource->awcBuffer[pTextSource->iCur];
    _cMapped = cwc;


    if ( !ScanChunk() )
        THROW( CException( E_FAIL ) );

    BOOL fWordHasZWS = FALSE;     // Does the current word have a zero-width-space ?
    unsigned uLenZWS;             // Length of a word minus embedded zero-width-spaces

    //
    // iBeginWord is the offset into _aCharInfo of the beginning character of
    // a word.  iCur is the first *unprocessed* character.
    // They are indexes into the mapped chunk.
    //

    unsigned iBeginWord = 0;
    unsigned iCur = 0;

    SCODE sc = S_OK;

    //
    // Pump words from mapped chunk to word sink
    //
    while ( iCur < _cMapped )
    {
        //
        // Skip whitespace, punctuation, etc.
        //
        for (; iCur < _cMapped; iCur++)
            if ( IsWordChar (iCur) )
                break;

        // iCur points to a word char or is equal to _cMapped

        iBeginWord = iCur;
        if (iCur < _cMapped)
            iCur++; // we knew it pointed at word character

        //
        // Find word break. Filter may output Unicode zero-width-space, which
        // should be ignored by the wordbreaker.
        //
        fWordHasZWS = FALSE;
        for (; iCur < _cMapped; iCur++)
        {
            if ( !IsWordChar (iCur) )
            {
                if ( _pwcChunk[iCur] == ZERO_WIDTH_SPACE )
                    fWordHasZWS = TRUE;
                else
                    break;
            }
        }

        if ( fWordHasZWS )
        {
            //
            // Copy word into _awcBufZWS after stripping zero-width-spaces
            //

            uLenZWS = 0;
            for ( unsigned i=iBeginWord; i<iCur; i++ )
            {
                if ( _pwcChunk[i] != ZERO_WIDTH_SPACE )
                    _awcBufZWS[uLenZWS++] = _pwcChunk[i];
            }
        }

        // iCur points to a non-word char or is equal to _cMapped

        if ( iCur < _cMapped )
        {
            // store the word and its source position
            if ( fWordHasZWS )
                sc = pWordSink->PutWord( uLenZWS,
                                         _awcBufZWS,    // stripped word
                                         iCur - iBeginWord,
                                         pTextSource->iCur + iBeginWord );
            else
                sc = pWordSink->PutWord( iCur - iBeginWord,
                                         _pwcChunk + iBeginWord, // the word
                                         iCur - iBeginWord,
                                         pTextSource->iCur + iBeginWord );

            if ( FAILED( sc ) )
                THROW( CException( sc ) );

            iCur++; // we knew it pointed at non-word char
            iBeginWord = iCur; // in case we exit the loop now
        }
    } // next word

    Win4Assert( iCur == _cMapped );

    // End of words in chunk.
    // iCur == _cMapped
    // iBeginWord points at beginning of word or == _cMapped

    if ( 0 == iBeginWord )
    {
        // A single word fills from beginning of this chunk
        // to the end. This is either a very long word or
        // a short word in a leftover buffer.

        // store the word and its source position
        if ( fWordHasZWS )
            sc = pWordSink->PutWord( uLenZWS,
                                     _awcBufZWS,       // stripped word
                                     iCur,
                                     pTextSource->iCur ); // its source pos.
        else
            sc = pWordSink->PutWord( iCur,
                                     _pwcChunk,       // the word
                                     iCur,
                                     pTextSource->iCur ); // its source pos.

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        //
        // Position it to not add the word twice.
        //

        iBeginWord = iCur;
    }

    //
    // If this is the last chunk from text source, then process the
    // last fragment
    //

    if ( cwc < CDefWordBreaker::ccCompare && iBeginWord != iCur )
    {
        // store the word and its source position
        if ( fWordHasZWS )
            sc = pWordSink->PutWord( uLenZWS,
                                     _awcBufZWS,    // stripped word
                                     iCur - iBeginWord,
                                     pTextSource->iCur + iBeginWord );
        else
            sc = pWordSink->PutWord( iCur - iBeginWord,
                                     _pwcChunk + iBeginWord,  // the word
                                     iCur - iBeginWord,
                                     pTextSource->iCur + iBeginWord );

        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        iBeginWord = iCur;
    }

    cwcProcd = iBeginWord;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDefWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//  History:    10-Aug-95   SitaramR    Created Header
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CDefWordBreaker::ComposePhrase( WCHAR const *pwcNoun,
                                                        ULONG cwcNoun,
                                                        WCHAR const *pwcModifier,
                                                        ULONG cwcModifier,
                                                        ULONG ulAttachmentType,
                                                        WCHAR *pwcPhrase,
                                                        ULONG *pcwcPhrase )
{
    //
    // Never emitted phrase in the first place.
    //

    ciDebugOut(( DEB_WARN,
                 "IWordBreaker::ComposePhrase called on default word breaker\n" ));
    return( E_FAIL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//  History:    10-Aug-95  SitaramR     Created Header
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CDefWordBreaker::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    if ( 0 == ppwcsLicense )
        return E_INVALIDARG;

    static WCHAR const * wcsCopyright = L"Copyright (c) Microsoft Corporation, 1991-1998";
    *ppwcsLicense = wcsCopyright;

    return( S_OK );
}



extern long gulcInstances;


//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreakerCF::CDefWordBreakerCF
//
//  Synopsis:   Default Word Breaker class factory constructor
//
//  History:    07-Feb-1995     SitaramR   Created
//
//--------------------------------------------------------------------------

CDefWordBreakerCF::CDefWordBreakerCF( )
        : _cRefs( 1 )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreakerCF::~CDefWordBreakerCF
//
//  Synopsis:   Default Word Breaker class factory destructor
//
//  History:    07-Feb-1995     SitaramR   Created
//
//--------------------------------------------------------------------------

CDefWordBreakerCF::~CDefWordBreakerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreakerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    07-Feb-1995     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CDefWordBreakerCF::QueryInterface(
    REFIID  riid,
    void ** ppvObject )
{
    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreakerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    07-Feb-1995     SitaramR   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CDefWordBreakerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreakerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    07-Feb-1995     SitaramR   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CDefWordBreakerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return uTmp;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreakerCF::CreateInstance
//
//  Synopsis:   Creates new CDefWordBreaker object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    07-Feb-1995     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CDefWordBreakerCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CDefWordBreaker *pIUnk = 0;
    SCODE sc = S_OK;

    TRY
    {
        pIUnk = new CDefWordBreaker();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;

        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDefWordBreakerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    07-Feb-1995     SitaramR   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CDefWordBreakerCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\disquery.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995-2000.
//
// File:        DisQuery.cxx
//
// Contents:    PIInternalQuery for distributed implementation.
//
// Classes:     CDistributedQuery
//
// History:     05-Jun-95     KyleP       Created
//              14-JAN-97     KrishnaN    Undefined CI_INETSRV, related changes
//
// Notes:
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <coldesc.hxx>
#include <rstprop.hxx>
#include <pidmap.hxx>
#include <cmdprutl.hxx>
#include <proputl.hxx> 

#include "disquery.hxx"
#include "seqser.hxx"
#include "seqsort.hxx"
#include "scrlsort.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   EvalDistributedQuery, public
//
//  Synopsis:   Simulates bind to IInternalQuery for a ci object store
//
//  Arguments:  [ppQuery]       -- Returns a PIInternalQuery
//              [cScope]        -- Count of [awcsScope]
//              [pdwDepths]     -- Array of scope depths
//              [awcsScope]     -- Array of scopes to query
//              [awcsCat]       -- Array of overrides for catalog location
//              [fVirtualPaths] -- TRUE if [wcsScope] is a virtual scope
//                                 instead of a physical scope.
//
//  Returns:    SCODE result
//
//  History:    08-Feb-96    KyleP     Added header
//              08-Feb-96    KyleP     Add virtual path support
//              14-May-97    MohamedN  hidden core and fs properties 
//
//  Notes:      Scaffolding
//
//--------------------------------------------------------------------------

SCODE EvalDistributedQuery(
    PIInternalQuery **    ppQuery,
    CGetCmdProps    &     getCmdProps )

{
    *ppQuery                   = 0;
    CDistributedQuery * pQuery = 0;
    SCODE               sc     = S_OK;

    TRY
    {
        ULONG  cChildren = getCmdProps.GetCardinality();

        pQuery = new CDistributedQuery( cChildren );

        for ( unsigned i = 0; i < cChildren ; i++ )
        {

            PIInternalQuery   *        pChild = 0;
            CDbProperties              idbProps;

            getCmdProps.PopulateDbProps( &idbProps, i );

            SCODE s = EvalQuery(&pChild, idbProps );

            if ( FAILED( s ) )
            {
                vqDebugOut(( DEB_ERROR,
                             "Error 0x%x getting PIInternalQuery for %ws\n",
                             s, getCmdProps.GetCatalog(i) ));

                THROW( CException( s ) );
            }

            pQuery->Add( pChild, i );
        }

    }
    CATCH( CException, e )
    {
        if ( 0 != pQuery )
        {
            pQuery->Release();
            pQuery = 0;
        }
        sc = GetOleError( e );
    }
    END_CATCH

    *ppQuery = pQuery;
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDistributedQuery::CDistributedQuery, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  [cChild] -- Number of child scopes.
//
//  History:    07-Jun-95 KyleP     Created
//
//--------------------------------------------------------------------------

CDistributedQuery::CDistributedQuery( unsigned cChild )
        : _aChild( cChild ),
          PIInternalQuery( 1 )
{
    RtlZeroMemory( _aChild.GetPointer(), cChild * sizeof(PIInternalQuery *) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CDistributedQuery::~CDistributedQuery, public
//
//  Synopsis:   Destructor.
//
//  History:    07-Jun-95 KyleP     Created
//
//--------------------------------------------------------------------------

CDistributedQuery::~CDistributedQuery()
{
    for ( unsigned i = 0; i < _aChild.Count(); i++ )
    {
        if ( _aChild[i] )
        {
            _aChild[i]->Release();
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDistributedQuery::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  Returns:    Error.  No rebind from this class is supported.
//
//  History:    01-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CDistributedQuery::QueryInterface( REFIID ifid, void ** ppiuk )
{
    if ( ifid == IID_IUnknown )
    {
        AddRef();
        *ppiuk = (void *)((IUnknown *)this);
        return S_OK;
    }
    else
    {
        *ppiuk = 0;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDistributedQuery::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    01-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDistributedQuery::AddRef(void)
{
    return InterlockedIncrement( (long *)&_ref );
}

//+-------------------------------------------------------------------------
//
//  Member:     CDistributedQuery::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    01-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CDistributedQuery::Release(void)
{
    long l = InterlockedDecrement( (long *)&_ref );

    if ( l <= 0 )
    {
        delete this;
        return 0;
    }

    return l;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDistributedQuery::Execute, public
//
//  Synopsis:   Executes a query.  Helper method for ICommand::Execute.
//
//  Arguments:  [pUnkOuter]    -- Outer unknown
//              [pRestriction] -- Query restriction
//              [pidmap]       -- pid mapper for output, sort, category columns
//              [rColumns]     -- Output columns in IRowset
//              [rSort]        -- Initial sort
//              [Props]        -- Rowset properties
//              [rCateg]       -- Categorization specification
//              [cRowsets]     -- # of rowsets
//              [ppUnknowns]   -- IUnknown pointers returned here
//              [aAccessors]   -- Bag of accessors which rowsets need to inherit
//
//  Returns:    Error code
//
//  History:    07-Jun-95      KyleP    Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDistributedQuery::Execute( IUnknown *             pUnkOuter,
                                 RESTRICTION *          pRestriction,
                                 CPidMapperWithNames &  pidmap,
                                 CColumnSet &           rColumns,
                                 CSortSet &             rSort,
                                 XPtr<CMRowsetProps>  & xProps,
                                 CCategorizationSet &   rCateg,
                                 ULONG                  cRowsets,
                                 IUnknown **            ppUnknowns,
                                 CAccessorBag &         aAccessors,
                                 IUnknown *             pCreatorUnk )
{
    SCODE sc = S_OK;

    unsigned iChild = 0;
    IRowset ** aRowset = 0;

    TRY
    {
        if ( (xProps->GetPropertyFlags() & eLocatable) != 0 )
        {
            //
            // If no sort was specified for scrollable query, then add one
            // based on workid.
            //

            if ( 0 == rSort.Count() )
            {
                // This whole process could be streamlined if it was
                // possible to query bindings *before* ExecQuery was
                // called.  Then we could potentially find an existing
                // column suitable for sorting.

                //
                // Setup sort.
                //

                GUID guidQuery = DBQUERYGUID;
                CFullPropSpec propWorkId( guidQuery, DISPID_QUERY_WORKID );
                SSortKey SortKey( pidmap.NameToPid(propWorkId), QUERY_SORTASCEND );

                rSort.Add( SortKey, 0 );
            }
        }

        //
        // Since we need to bind to sort columns in order to compare rows, all
        // sort columns must be in the binding set.
        // At the same time, create a CSort from the CSortSet for use by the
        // rowset implementation class.
        //

        unsigned cOriginalColumns = rColumns.Count();
        CSort SortDup;

        if ( 0 != rSort.Count() )
        {
            for ( unsigned i = 0; i < rSort.Count(); i++ )
            {
                PROPID prop = rSort.Get( i ).pidColumn;

                CSortKey sk( *pidmap.PidToName(prop),
                             rSort.Get(i).dwOrder,
                             rSort.Get(i).locale );
                SortDup.Add(sk, i);

                for ( unsigned j = 0; j < rColumns.Count(); j++ )
                {
                    if ( rColumns.Get(j) == prop )
                        break;
                }

                if ( j == rColumns.Count() )
                {
                    rColumns.Add( prop, j );
                }
            }
        }

        //
        // This array is passed to distributed rowset.
        //

        Win4Assert(1 == cRowsets );  // allocs below only account for 1 cRowset

        XArray<IUnknown *> xUnknowns( _aChild.Count() );
        aRowset = new IRowset * [_aChild.Count()];
        
        //
        // Create the children.
        //

        CAccessorBag aEmpty(this);

        for ( iChild = 0; iChild < _aChild.Count(); iChild++ )
        {
            //
            // If we're going non-sequential, go all the way.
            //

            XPtr<CMRowsetProps> xPropsTemp( new CMRowsetProps( xProps.GetReference() ) );
            if ( (xPropsTemp->GetPropertyFlags() & eLocatable) != 0 )
                xPropsTemp->SetImpliedProperties( IID_IRowsetScroll, cRowsets );

            // For distributed rowsets, always set holdrows to true
            xPropsTemp->SetPropertyFlags( eHoldRows );

            _aChild[iChild]->Execute( 0,     // children are private and aren't aggregated
                                      pRestriction,
                                      pidmap,
                                      rColumns,
                                      rSort,
                                      xPropsTemp,
                                      rCateg,
                                      cRowsets,
                                      &xUnknowns[iChild],
                                      aEmpty,       // these guys don't really need aAccessors
                                      pCreatorUnk );  

            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "CDistributedQuery: Error 0x%x calling Execute for child %u\n",
                             sc, iChild ));
                THROW( CException(sc) );
            }

            // get IRowset pointer
            xUnknowns[iChild]->QueryInterface(IID_IRowset, (void **) &aRowset[iChild]);
            xUnknowns[iChild]->Release();  // release extra ref
        }

        //
        // First case: sequential cursors
        //

        IUnknown * pIUnkInner = 0;
        XInterface<IUnknown> xIUnkInner(pIUnkInner);
        IRowset * pTemp;  
    
        if ( 0 == (xProps->GetPropertyFlags() & eLocatable) )
        {
            if ( 0 != rSort.Count() )
            {
                pTemp = (IRowset *)
                        new CSequentialSorted(  pUnkOuter,
                                                (IUnknown **)xIUnkInner.GetQIPointer(),
                                                aRowset,
                                                _aChild.Count(),
                                                xProps.GetReference(),
                                                cOriginalColumns,
                                                SortDup,
                                                aAccessors );
            }
            else
            {
                pTemp = (IRowset *)
                        new CSequentialSerial(  pUnkOuter,
                                                (IUnknown **)xIUnkInner.GetQIPointer(),
                                                aRowset,
                                                _aChild.Count(),
                                                xProps.GetReference(),
                                                cOriginalColumns,
                                                aAccessors );
            }
        }

        //
        // Other case: Scrollable
        //

        else
        {
            Win4Assert( 0 != rSort.Count() );

            pTemp = (IRowset *)
                    new CScrollableSorted( pUnkOuter,
                                           (IUnknown **)xIUnkInner.GetQIPointer(),
                                           (IRowsetScroll **)aRowset,
                                           _aChild.Count(),
                                           xProps.GetReference(),
                                           cOriginalColumns,
                                           SortDup, 
                                           aAccessors );
        }
        *ppUnknowns = xIUnkInner.Acquire();
        Win4Assert(*ppUnknowns);

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
   
        for ( ; iChild > 0; iChild-- )
            aRowset[iChild-1]->Release();
 
        delete [] aRowset;

        RETHROW( );
    }
    END_CATCH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\distrib.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 2000.
//
// File:        Distrib.cxx
//
// Contents:    Top level distribution API
//
// Classes:     CDistributedRowset
//
// History:     23-Feb-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//              29-Mar-2000     KLam        Fixed Bookmarks
//
//  Notes: Some of the distributed versions of the Ole DB interfaces simply 
//         call into the regular implementations. In such cases, we'll avoid
//         posting oledb errors because the underlying call had already done
//         that.
//
// NTRAID#DB-NTBUG9-84041-2000/07/31-dlee Distributed queries don't supported hierarcical rowsets
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "distrib.hxx"
#include "disacc.hxx"
#include "seqser.hxx"
#include "seqsort.hxx"
#include "scrlsort.hxx"

//
// IUnknown methods.
//

//+-------------------------------------------------------------------------
//
//  Method:     CDistributedRowset::RealQueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]  -- IID of new interface
//              [ppiuk] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    10-Apr-1995     KyleP   Created
//
//  Notes:      ref count is incremented inside QueryInterface      
//
//--------------------------------------------------------------------------

SCODE CDistributedRowset::RealQueryInterface( REFIID riid, VOID **ppiuk )
{
    SCODE sc = S_OK;
    *ppiuk = 0;

    // note -- IID_IUnknown covered in QueryInterface

    if ( riid == IID_IRowset )
    {
        *ppiuk = (void *)((IRowset *)this);
    }
    else if (IID_ISupportErrorInfo == riid)
    {
        *ppiuk = (void *) ((IUnknown *) (ISupportErrorInfo *) &_DBErrorObj);
    }
    else if ( riid == IID_IRowsetInfo )
    {
        *ppiuk = (void *)((IRowsetInfo *)this);
    }
    else if ( riid == IID_IAccessor )
    {
        *ppiuk = (void *)((IAccessor *)this);
    }
    else if ( riid == IID_IColumnsInfo )
    {
        *ppiuk = (void *)((IColumnsInfo *)this);
    }
    else if ( riid == IID_IRowsetIdentity )
    {
        *ppiuk = (void *)((IRowsetIdentity *)this);
    }
    else if ( riid == IID_IConvertType )
    {
        *ppiuk = (void *)((IConvertType *)this);
    }
    else if ( riid == IID_IRowsetQueryStatus )
    {
        *ppiuk = (void *)((IRowsetQueryStatus *)this);
    }
    else if ( riid == IID_IConnectionPointContainer )
    {
        sc = _SetupConnectionPointContainer( this, ppiuk );
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    return sc;
}


//
// IRowset methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::CreateAccessor, public
//
//  Synopsis:   Creates accessor
//
//  Arguments:  [dwAccessorFlags] -- Read/Write/ReadWrite
//              [cBindings]       -- # Columns (bindings)
//              [rgBindings]      -- Bindings
//              [cbRowWidth]      -- row width (for IReadData)
//              [phAccessor]      -- Accessor returned here
//              [rgStatus  ]      -- Set to index of failed binding
//
//  History:    28-Mar-95   KyleP       Created.
//              22-Apr-97   EmilyB      Changed to use accessorbag _aAccessors
//
//  Notes: Need to have Ole DB error handling here because the error from the 
//         underlying call is translated.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::CreateAccessor( DBACCESSORFLAGS dwAccessorFlags,
                                                 DBCOUNTITEM cBindings,
                                                 const DBBINDING rgBindings[],
                                                 DBLENGTH cbRowWidth,
                                                 HACCESSOR * phAccessor,
                                                 DBBINDSTATUS * rgStatus )
{
    _DBErrorObj.ClearErrorInfo();

    if (0 == phAccessor || (0 != cBindings && 0 == rgBindings))
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IAccessor);
    
    if ( 0 == cBindings )
        return _DBErrorObj.PostHResult(DB_E_NULLACCESSORNOTSUPPORTED, IID_IAccessor);

    SCODE sc = S_OK;
    LONG iFirstValidBookmark = -1;
    unsigned iBinding;
    XArray<DBBINDSTATUS> xStatusCopy;

    TRY
    {
        BOOL fCreateCopy = FALSE;
        BOOL fHasBookmark = FALSE;

        ULONG iMinColOrdinal = 1, 
              iMaxColOrdinal = _cColumns;

        if ( -1 != _iColumnBookmark )
        {
            iMinColOrdinal--;
            iMaxColOrdinal--;
        }

        if ( rgStatus )
        {
            Win4Assert( 0 == DBSTATUS_S_OK );
            RtlZeroMemory( rgStatus, sizeof( rgStatus[0] ) * cBindings );
        }

        //
        // Create a copy of bindings iff it has bookmark column or
        // if it has invalid column, so that we can then mess around
        // with them ;-)
        //

        for ( iBinding = 0; iBinding < cBindings; iBinding++ )
        {
            fHasBookmark = ( _iColumnBookmark == rgBindings[iBinding].iOrdinal );

            if ( fHasBookmark ||
                 rgBindings[iBinding].iOrdinal > iMaxColOrdinal ||  
                 rgBindings[iBinding].iOrdinal < iMinColOrdinal )
            {
                fCreateCopy = TRUE;
                break;
            }

        }
        const DBBINDING * pActualBindings = rgBindings;
        DBCOUNTITEM cActualBindings = cBindings;

        XArray<DBBINDING> xBindingCopy;

        if ( fCreateCopy )
        {
            unsigned iBindingCopy = 0;

            xBindingCopy.Init( (unsigned) cBindings );

            for ( iBinding = 0; iBinding < cBindings; iBinding++ )
            {
                // check for a valid bookmark
                if ( _iColumnBookmark == rgBindings[iBinding].iOrdinal &&
                     DBTYPE_BYTES == ( rgBindings[iBinding].wType & ~DBTYPE_BYREF ) &&
                     DBMEMOWNER_CLIENTOWNED == rgBindings[iBinding].dwMemOwner )
                {
                    if ( -1 == iFirstValidBookmark )
                    {
                        iFirstValidBookmark = iBinding;
                    }
                    continue;
                }

                xBindingCopy[iBindingCopy] = rgBindings[iBinding];

                if ( rgBindings[iBinding].iOrdinal > iMaxColOrdinal ||  
                     rgBindings[iBinding].iOrdinal < iMinColOrdinal ||
                     _iColumnBookmark == rgBindings[iBinding].iOrdinal )
                {
                    // Invalid column -> set it to DB_INVALIDCOLUMN so
                    // that we an appropriate error is returned
                    xBindingCopy[iBindingCopy].iOrdinal = DB_INVALIDCOLUMN;
                }
                iBindingCopy++;
            }

            pActualBindings = xBindingCopy.GetPointer();
            cActualBindings = iBindingCopy;
        }

        if ( -1 != iFirstValidBookmark )
        {
            if ( rgStatus )
            {
                xStatusCopy.Init( (unsigned) cActualBindings );
            }
            // Create the bookmark accessors if needed
            if ( _xDistBmkAcc.IsNull() )
            {
                _xDistBmkAcc.Set( new CDistributedBookmarkAccessor( 
                                      _aChild,
                                      _cChild,
                                      dwAccessorFlags,
                                      rgStatus ? &rgStatus[iFirstValidBookmark] : NULL,
                                      _iColumnBookmark,
                                      _cbBookmark ) );
            }
            
            Win4Assert( _xDistBmkAcc.GetPointer() );


        }

        *phAccessor = (HACCESSOR)new
                                  CDistributedAccessor( _aChild,
                                                        _cChild,
                                                        dwAccessorFlags,
                                                        cActualBindings,
                                                        pActualBindings,
                                                        cbRowWidth,
                                                        -1 != iFirstValidBookmark ?
                                                            xStatusCopy.GetPointer() :
                                                            rgStatus,
                                                        (IUnknown *) (IRowset *) this,
                                                        rgBindings,
                                                        cBindings );

        CLock lock( _mutex );
        _aAccessors.Add( (CAccessorBase *)*phAccessor );

        if ( -1 != iFirstValidBookmark )
        {
            if ( rgStatus )
            {
                unsigned iBindingCopy = 0;
                for( iBinding = 0; iBinding < cBindings; iBinding++ )
                {
                    if ( _iColumnBookmark != rgBindings[iBinding].iOrdinal )
                    {
                        rgStatus[iBinding] = xStatusCopy[iBindingCopy++];
                    }
                }
            }
            ((CDistributedAccessor *)*phAccessor)->SetupBookmarkAccessor( 
                                                        _xDistBmkAcc.GetPointer(),
                                                        rgStatus,
                                                        _iColumnBookmark,
                                                        _cbBookmark );        
        }
    }
    CATCH( CException, e )
    {
        if ( -1 != iFirstValidBookmark )
        {
            if ( rgStatus )
            {
                unsigned iBindingCopy = 0;
                for( iBinding = 0; iBinding < cBindings; iBinding++ )
                {
                    if ( _iColumnBookmark != rgBindings[iBinding].iOrdinal )
                    {
                        rgStatus[iBinding] = xStatusCopy[iBindingCopy++];
                    }
                }
            }
        }
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR, "CDistributedRowset::CreateAccessor caught exception 0x%x\n", sc ));
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IAccessor);
    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetBindings, public
//
//  Synopsis:   Creates accessor
//
//  Arguments:  [hAccessor]   -- Handle to Accessor
//              [pdwAccessorFlags]   -- Type of binding returned here (read/write)
//              [pcBindings]  -- Count of bindings in [prgBindings] retuned
//                               here.
//              [prgBindings] -- Bindings returned here.
//
//  History:    03-Apr-95   KyleP       Created.
//              22-Apr-97   EmilyB      Changed to use accessorbag _aAccessors
//
//  Notes: Need to have Ole DB error handling here because the error from the 
//         underlying call is translated.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::GetBindings( HACCESSOR hAccessor,
                                              DBACCESSORFLAGS * pdwAccessorFlags,
                                              DBCOUNTITEM * pcBindings,
                                              DBBINDING * prgBindings[])
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc;

    TRY
    {
       CLock lock( _mutex );

       CDistributedAccessor * pAcc = (CDistributedAccessor *)_aAccessors.Convert(hAccessor);

       sc = pAcc->GetBindings( pdwAccessorFlags, pcBindings, prgBindings );
    }
    CATCH( CException, e )
    {
       vqDebugOut((DEB_ERROR, "CDistributedRowset: GetBindings caught exception 0x%x\n",
                  e.GetErrorCode()) );
       // The reason we have an exception here is 'cos pAcc is invalid
       sc = DB_E_BADACCESSORHANDLE;
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IAccessor);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetData, public
//
//  Synopsis:   Fetch data for a row.
//
//  Arguments:  [hRow]      -- Handle to row
//              [hAccessor] -- Accessor to use for fetch.
//              [pData]     -- Data goes here.
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes: Need to have Ole DB error handling here because an exception could
//         happen.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::GetData( HROW hRow,
                                          HACCESSOR hAccessor,
                                          void * pData )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        HROW hrowChild;

        int iChild = _RowManager.GetChildAndHROW( hRow, hrowChild );

        CLock lock( _mutex );
        CDistributedAccessor * pAcc = (CDistributedAccessor *)_aAccessors.Convert(hAccessor);

        sc = pAcc->GetData( iChild, hrowChild, pData );
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR, "CDistributedRowset::GetData caught exception 0x%x\n", sc ));
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowset);
    
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetReferencedRowset, public
//
//  Synopsis:   Traverse 'link' to associated rowset.
//
//  Arguments:  [iColumn]            -- Column of 'link'.
//              [ppReferencedRowset] -- Link target goes here.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::GetReferencedRowset( DBORDINAL  iColumn,
                                                      REFIID     riid,
                                                      IUnknown ** ppReferencedRowset )
{
    _DBErrorObj.ClearErrorInfo();

    // NTRAID#DB-NTBUG9-84041-2000/07/31-dlee Distributed queries don't supported hierarcical rowsets
    // This can only be implemented when the distributed rowset gains
    // support for hierarchical rowsets.
    //

    Win4Assert( !"CDistributedRowset::GetReferencedRowset not yet implemented" );
    return _DBErrorObj.PostHResult(E_NOTIMPL, IID_IRowsetInfo);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetProperties, public
//
//  Synopsis:   Return information about the capabilities of the rowset
//
//  Arguments:  [cProperties]    - number of desired properties or 0
//              [rgProperties]   - array of desired properties or NULL
//              [pcProperties]   - number of properties returned
//              [prgProperties]  - array of returned properties
//
//  Returns:    SCODE
//
//  History:    20 Nov 1995    AlanW     Created.
//
//  Notes: Need to have Ole DB error handling here because the underlying
//         call doesn't provide that.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::GetProperties(
    const ULONG         cProperties,
    const DBPROPIDSET   rgPropertyIDSets[],
    ULONG *             pcProperties,
    DBPROPSET **        prgProperties)
 {
    _DBErrorObj.ClearErrorInfo();

    // inner layer doesn't validate params...
    if ( (0 != cProperties && 0 == rgPropertyIDSets) ||
         0 == pcProperties ||
         0 == prgProperties )
    {
        vqDebugOut((DEB_IERROR, "CDistributedRowset::GetProperties: Invalid Argument(s)\n"));

        if (pcProperties)
           *pcProperties = 0;
        if (prgProperties)
           *prgProperties = 0;
        return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetInfo);
    }

    SCODE scResult = S_OK;
    *pcProperties = 0;
    *prgProperties = 0;

    TRY
    {
        //
        // Update ROWSETQUERYSTATUS property
        //

        DWORD dwStatus;
        scResult = GetStatus( & dwStatus );

        if ( FAILED( scResult ) )
            THROW( CException( scResult ) );

        _Props.SetValLong( CMRowsetProps::eid_DBPROPSET_MSIDXS_ROWSET_EXT,
                           CMRowsetProps::eid_MSIDXSPROPVAL_ROWSETQUERYSTATUS,
                           dwStatus );

        scResult = _Props.GetProperties( cProperties,
                                         rgPropertyIDSets,
                                         pcProperties,
                                         prgProperties );
    }
    CATCH( CException, e )
    {
        scResult = GetOleError(e);
        vqDebugOut(( DEB_ERROR, "CDistributedRowset::GetProperties -- caught 0x%x\n", scResult ));
    }
    END_CATCH;

    if (FAILED(scResult))
        _DBErrorObj.PostHResult(scResult, IID_IRowsetInfo);

    return scResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetSpecification, public
//
//  Synopsis:   Fetch query object corresponding to rowset.
//
//  Arguments:  [riid]            -- Bind spec to this interface.
//              [ppSpecification] -- Spec returned here.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::GetSpecification( REFIID riid,
                                                   IUnknown ** ppSpecification )
{
    _DBErrorObj.ClearErrorInfo();

    //
    // NTRAID#DB-NTBUG9-84043-2000/07/31-dlee Distributed rowset doesn't implement GetSpecification()
    //
    // This is now implemented by the base rowset.  We need to pass it on
    // through in a distributed fasion.
    //

    Win4Assert( !"CDistributedRowset::GetSpecification not yet implemented" );
    return _DBErrorObj.PostHResult(E_NOTIMPL, IID_IAccessor);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::MapColumnIDs, public
//
//  Synopsis:   Maps DBID to column ordinal.
//
//  Arguments:  [cColumnIDs]  -- Count of elements in [rgColumnIDs]
//              [rgColumnIDs] -- DBID to be mapped.
//              [rgColumns]   -- Output column ordinals.
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes: No need to have Ole DB error handling here because the underlying
//         call provides that.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::MapColumnIDs( DBORDINAL cColumnIDs,
                                               DBID const rgColumnIDs[],
                                               DBORDINAL  rgColumns[] )
{
    _DBErrorObj.ClearErrorInfo();

    IColumnsInfo * pci = 0;

    SCODE sc = _aChild[0]->QueryInterface( IID_IColumnsInfo, (void **) &pci );

    if ( SUCCEEDED(sc) )
    {
        sc = pci->MapColumnIDs( cColumnIDs, rgColumnIDs, rgColumns );
        pci->Release();
    }

    ULONG iMaxColOrdinal = _cColumns;

    if ( -1 != _iColumnBookmark )
    {
        iMaxColOrdinal--;
    }

    //
    //  Be sure none of the potentially added columns was returned.
    //
    unsigned cErrors = 0;
    if ( SUCCEEDED(sc) )
    {
        for (unsigned i=0; i<cColumnIDs; i++)
        {
            if (DB_INVALIDCOLUMN == rgColumns[i])
            {
                cErrors++;
            }
            else if ( rgColumns[i] > iMaxColOrdinal )
            {
                rgColumns[i] = DB_INVALIDCOLUMN;
                cErrors++;
            }
        }
        sc = cErrors == 0 ? S_OK :
             (cErrors != cColumnIDs) ? DB_S_ERRORSOCCURRED :
                                       DB_E_ERRORSOCCURRED;
    }

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IColumnsInfo);
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::ReleaseAccessor, public
//
//  Synopsis:   Releases accessor(s)
//
//  Arguments:  [hAccessor] -- Handle of accessor,
//              [pcRefCount] -- Ptr to ref count.
//
//  History:    28-Mar-95   KyleP       Created.
//              22-Apr-97   EmilyB      Changed to use accessorbag _aAccessors
//
//  Notes: Need to have Ole DB error handling here because the underlying call 
//         doesn't provide that.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::ReleaseAccessor( HACCESSOR hAccessor,
                                                  ULONG *   pcRefCount)
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;
    TRY
    {
        CLock lock( _mutex );
        _aAccessors.Release(hAccessor, pcRefCount);
    }
    CATCH(CException, e)
    {
       vqDebugOut((DEB_ERROR, "CDistributedRowset::ReleaseAccessor caught exception 0x%x\n",
                  e.GetErrorCode()) );
       // The reason we have an exception here is 'cos the accessor is invalid
       sc = DB_E_BADACCESSORHANDLE;
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IAccessor);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::AddRefAccessor, public
//
//  Synopsis:   AddRef accessor(s)
//
//  Arguments:  [hAccessor] -- Handle of accessor,
//              [pcRefCount] -- Ptr to ref count.
//
//  History:    16-Jan-97   KrishnaN       Created.
//              22-Apr-97   EmilyB         Changed to use accessorbag
//                                         _aAccessors
//  Notes: Need to have Ole DB error handling here because the underlying call 
//         doesn't provide that.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::AddRefAccessor( HACCESSOR hAccessor,
                                                  ULONG *   pcRefCount)
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        CLock lock( _mutex );
        _aAccessors.AddRef(hAccessor, pcRefCount);
    }
    CATCH(CException, e)
    {
       vqDebugOut((DEB_ERROR, "CDistributedRowset::AddRefAccessor caught exception 0x%x\n",
                  e.GetErrorCode()) );
       // The reason we have an exception here is 'cos the accessor is invalid.
       sc = DB_E_BADACCESSORHANDLE;
    }
    END_CATCH;

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IAccessor);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::ReleaseChapter, public
//
//  Synopsis:   Release chapter.
//
//  Arguments:  [hChapter]  -- Chapter
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::ReleaseChapter( HCHAPTER hChapter )
{
    _DBErrorObj.ClearErrorInfo();

    // NTRAID#DB-NTBUG9-84041-2000/07/31-dlee Distributed queries don't supported hierarcical rowsets
    // Currently there is no support for chapters.

    Win4Assert( !"CDistributedRowset::ReleaseChapter not yet implemented" );
    return _DBErrorObj.PostHResult(E_NOTIMPL, IID_IRowset);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::RestartPosition, public
//
//  Synopsis:   Reset cursor for GetNextRows
//
//  Arguments:  [hChapter]  -- Chapter
//
//  History:    16 Jun 95    AlanW     Created.
//
//  Notes: NO need to have Ole DB error handling here because the underlying 
//         call provides that.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::RestartPosition( HCHAPTER hChapter )
{
   SCODE sc = S_OK;
   BOOL fNotified = FALSE;

   TRY
   {
       _iCurrentRow = 0;

       if ( !_xChildNotify.IsNull() )
       {
           sc = _xChildNotify->OnRowsetChange( DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                               DBEVENTPHASE_OKTODO,
                                               FALSE );

           if ( S_FALSE == sc )
               THROW(CException(DB_E_CANCELED));
           fNotified = TRUE;
       }

       for ( unsigned i = 0; i < _cChild; i++ )
       {
           sc = _aChild[i]->RestartPosition( hChapter);

           if ( FAILED(sc) )
           {
               vqDebugOut(( DEB_ERROR, "IRowset::RestartPosition returned 0x%x\n", sc ));
               break;
           }
       }

       if ( fNotified )
       {
           _xChildNotify->OnRowsetChange( DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                          DBEVENTPHASE_DIDEVENT,
                                          TRUE );
       }
   }
   CATCH( CException, e )
   {
       sc = e.GetErrorCode();
   }
   END_CATCH
   
   if ( fNotified && FAILED(sc) )
   {
       _xChildNotify->OnRowsetChange( DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                      DBEVENTPHASE_FAILEDTODO,
                                      TRUE );
   }
   return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::AddRefRows, public
//
//  Synopsis:   Incs ref. count on row(s)
//
//  Arguments:  [cRows]       -- Number of HROWs in rghRows.
//              [rghRows]     -- Rows to be refcounted.
//              [pcRefCounted]  -- Count of rows *successfully* refcounted.
//              [rgRefCounts] -- Remaining refcounts on HROWs.
//
//  History:    10-Apr-95   KyleP       Created.
//
//  Notes: Need to have Ole DB error handling here because the underlying 
//         errors are being translated.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::AddRefRows( DBCOUNTITEM  cRows,
                                              const HROW  rghRows[],
                                              DBREFCOUNT  rgRefCounts[],
                                              DBROWSTATUS rgRowStatus[] )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;
    ULONG cRefCounted, cSuccessfullyRefCounted;

    if (cRows > 0 && 0 == rghRows)
    {
       vqDebugOut((DEB_IERROR, "CDistributedRowset::AddRefRows: Invalid Argument(s)\n"));
       return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowset);
    }

    TRY
    {
        for ( cRefCounted = cSuccessfullyRefCounted = 0; cRefCounted < cRows; cRefCounted++ )
        {
            HROW hrowChild;

            int iChild = _RowManager.GetChildAndHROW( rghRows[cRefCounted], hrowChild );

            sc = _aChild[iChild]->AddRefRows( 1,
                                               &hrowChild,
                                               0,
                                               (0 == rgRefCounts) ? 0 : &rgRefCounts[cRefCounted] );

            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "IRowset::AddRefRows returned 0x%x\n", sc ));
                continue;
            }

            _RowManager.AddRef( rghRows[cRefCounted] );

            cSuccessfullyRefCounted++;
        }

        if ( 0 != rgRefCounts )
            rgRefCounts[0] = cRefCounted;

    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        vqDebugOut(( DEB_ERROR, "CDistributedRowset::AddRefRows -- caught 0x%x\n", sc ));
    }
    END_CATCH

    // if we see an error other than DB_E_ERRORSOCCURRED, pass it straight through
    if (FAILED(sc) && sc != DB_E_ERRORSOCCURRED)
        return _DBErrorObj.PostHResult(sc, IID_IRowset);

    if (cSuccessfullyRefCounted == cRefCounted)
        return S_OK;

    if (cSuccessfullyRefCounted > 0)
        sc = DB_S_ERRORSOCCURRED;
    else
        sc = DB_E_ERRORSOCCURRED;

    return _DBErrorObj.PostHResult(sc, IID_IRowset);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::ReleaseRows, public
//
//  Synopsis:   Releases row(s)
//
//  Arguments:  [cRows]       -- Number of HROWs in rghRows.
//              [rghRows]     -- Rows to be released.
//              [rgRowOptions]-- row options
//              [rgRefCounts] -- Remaining refcounts on HROWs.
//              [rgRowStatus] -- Status values.
//
//  History:    10-Apr-95   KyleP       Created.
//              30-Jan-97   KrishnaN    Modified to conform with 1.0 spec
//
//  Notes: Need to have Ole DB error handling here because the underlying 
//         errors are being translated.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::ReleaseRows( DBCOUNTITEM  cRows,
                                              const HROW   rghRows[],
                                              DBROWOPTIONS rgRowOptions[],
                                              DBREFCOUNT   rgRefCounts[],
                                              DBROWSTATUS  rgRowStatus[])
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;
    ULONG cReleased, cSuccessfullyReleased;
    DBROWSTATUS rowStatus;

    TRY
    {
        BOOL fNotify = FALSE;
        ULONG * pRefCounts = rgRefCounts;
        DBROWSTATUS * pRowStatus = rgRowStatus;

        XArray<ULONG> xrgRefCounts;
        XArray<DBROWSTATUS> xrgRowStatus;

        if ( !_xChildNotify.IsNull() )
        {
            fNotify = TRUE;
            if ( 0 == pRefCounts )
            {
                xrgRefCounts.Init( (unsigned) cRows );
                pRefCounts = xrgRefCounts.GetPointer();
            }
            if ( 0 == pRowStatus )
            {
                xrgRowStatus.Init( (unsigned) cRows );
                pRowStatus = xrgRowStatus.GetPointer();
            }
        }

        for ( cReleased = cSuccessfullyReleased = 0; cReleased < cRows; cReleased++ )
        {
            HROW hrowChild;

            Win4Assert( DB_NULL_HROW != rghRows[cReleased]  );

            if ( DB_NULL_HROW != rghRows[cReleased] )
            {
                int iChild = _RowManager.GetChildAndHROW( rghRows[cReleased], hrowChild );

                sc = _aChild[iChild]->ReleaseRows( 1,
                                                   &hrowChild,
                                                   (0 == rgRowOptions) ? 0 : &rgRowOptions[cReleased],
                                                   (0 == rgRefCounts) ? 0 : &rgRefCounts[cReleased],
                                                   &rowStatus
                                                  );
            }
            // At this time, there is no need to translate the error returned by the child.

            if (rgRowStatus)
                rgRowStatus[cReleased] = rowStatus;

            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "IRowset::ReleaseRows returned 0x%x\n", sc ));
                continue;
            }

            if ( DB_NULL_HROW != rghRows[cReleased] )
                _RowManager.Release( rghRows[cReleased] );

            cSuccessfullyReleased++;
        }

        if ( fNotify )
        {
            ULONG cRowsToNotify = 0;
            for (ULONG i=0; i<cRows; i++)
                if ( 0 == pRefCounts[i] && DBROWSTATUS_S_OK == pRowStatus[i] )
                    cRowsToNotify++;

            if (cRowsToNotify)
            {
                XGrowable<HROW,20> xrghRows(cRowsToNotify);

                for (cRowsToNotify=0, i=0; i<cRows; i++)
                    if ( 0 == pRefCounts[i] && DBROWSTATUS_S_OK == pRowStatus[i] )
                    {
                        xrghRows[cRowsToNotify] = rghRows[i];
                        cRowsToNotify++;
                    }

                _xChildNotify->OnRowChange( cRowsToNotify,
                                            xrghRows.Get(),
                                            DBREASON_ROW_RELEASE,
                                            DBEVENTPHASE_DIDEVENT,
                                            TRUE);
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        vqDebugOut(( DEB_ERROR, "CDistributedRowset::ReleaseRows -- caught 0x%x\n", sc ));
    }
    END_CATCH

     // if we see an error other than DB_E_ERRORSOCCURRED, pass it straight through
    if (FAILED(sc) && sc != DB_E_ERRORSOCCURRED)
        return _DBErrorObj.PostHResult(sc, IID_IRowset);

    if (cSuccessfullyReleased == cReleased)
        return S_OK;
    else if (cSuccessfullyReleased > 0)
        sc = DB_S_ERRORSOCCURRED;
    else
        sc = DB_E_ERRORSOCCURRED;

    return _DBErrorObj.PostHResult(sc, IID_IRowset);
}


//
// IColumnsInfo methods
//

//+---------------------------------------------------------------------------
//
//  Function:   IsEqual, private
//
//  Arguments:  [col1] -- First DBID
//              [col2] -- Second DBID
//
//  Returns:    TRUE if col1 == col2
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL IsEqual( DBID const & col1, DBID const & col2 )
{
    if ( col1.eKind != col2.eKind )
        return( FALSE );

    switch ( col1.eKind )
    {
    case DBKIND_GUID_PROPID:
        return ( col1.uGuid.guid == col2.uGuid.guid &&
                 col1.uName.ulPropid == col2.uName.ulPropid );

    case DBKIND_GUID_NAME:
        return( col1.uGuid.guid == col2.uGuid.guid &&
                _wcsicmp( col1.uName.pwszName, col2.uName.pwszName ) == 0);

    case DBKIND_NAME:
        return( _wcsicmp( col1.uName.pwszName, col2.uName.pwszName ) == 0 );

    case DBKIND_PGUID_PROPID:
        return ( *col1.uGuid.pguid == *col2.uGuid.pguid &&
                 col1.uName.ulPropid == col2.uName.ulPropid );

    case DBKIND_PGUID_NAME:
        return( *col1.uGuid.pguid == *col2.uGuid.pguid &&
                _wcsicmp( col1.uName.pwszName, col2.uName.pwszName ) == 0 );

    default:
        Win4Assert( !"Unknown eKind" );
        return( FALSE );
    }

    Win4Assert( !"How did we get here?" );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::_GetFullColumnInfo, protected
//
//  Synopsis:   Returns basic info about columns in table.
//
//  Arguments:  [pcColumns] -- Count returned here.
//              [ppColInfo] -- Array of column descriptors returned here.
//              [ppwchInfo] -- Pointer to storage for all string values.
//
//  History:    02-Mar-95   KyleP       Created.
//              24-Jan-97   KrishnaN    Modified to conform to 1.0 spec
//
//  Notes:      Since each child cursor was given the same initial query,
//              we know all the columnid and column ordinals must be the
//              same.  Other fields will vary, and will need to be set
//              to the most relaxed value from any child cursor.
//
//              Need to have Ole DB error handling here because the underlying 
//              errors are being translated.
//
//              This implementation returns all the columns including the columns
//              that we added for sorting. The client will always call 
//              GetColumnInfo, which trims out these extra columns
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::_GetFullColumnInfo( DBORDINAL * pcColumns,
                                                     DBCOLUMNINFO ** ppColInfo,
                                                     WCHAR ** ppwchInfo)
{
    _DBErrorObj.ClearErrorInfo();

    if (0 == pcColumns || 0 == ppColInfo || 0 == ppwchInfo)
    {
       vqDebugOut((DEB_IERROR, "CDistributedRowset::GetColumnInfo: Invalid Argument(s)\n"));
       return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IColumnsInfo);
    }
    SCODE sc = S_OK;

    //
    // Get rid of cached copy, if any.
    //

    if ( 0 != _aColInfo )
    {
        *pcColumns = _cColInfo;
        *ppColInfo = _aColInfo;
        *ppwchInfo = _awchInfo;

        _aColInfo = 0;
        _awchInfo = 0;
    }
    else
    {
        *ppColInfo = 0;
        *ppwchInfo = 0;
        *pcColumns = 0;
    
        TRY
        {
            //
            // Fetch from first child.  We'll use this allocation for return, and
            // modify fields as needed.
            //
    
            IColumnsInfo * pci = 0;
    
            sc = _aChild[0]->QueryInterface( IID_IColumnsInfo, (void **) &pci );
    
    
            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "CDistributedRowset: QI to IColumnsInfo returned 0x%x\n", sc ));
                THROW( CException(sc) );
            }
    
            XInterface<IColumnsInfo> pColInfo(pci);
    
            DBCOLUMNINFO * paColTemp;
            WCHAR * pwchTemp;
            sc = pColInfo->GetColumnInfo( pcColumns, &paColTemp, &pwchTemp );
    
            XCoMem<DBCOLUMNINFO> pBaseline(paColTemp);
            XCoMem<WCHAR>        pBaseStr(pwchTemp);
    
            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "IColumnsInfo::GetColumnInfo returned 0x%x\n", sc ));
                THROW( CException(sc) );
            }
    
            //
            // Now go through remaining cursors and adjust values.  The same
            // columns must be in the same ordinal positions, but some values
            // (ex: cbMaxLength) may differ between providers.
            //
            // Any string data is just taken from the first returned value.
            //
    
            for ( unsigned i = 1; i < _cChild; i++ )
            {
                sc = _aChild[i]->QueryInterface( IID_IColumnsInfo, (void **) &pci );
    
                if ( FAILED(sc) )
                {
                    vqDebugOut(( DEB_ERROR, "CDistributedRowset: QI to IColumnsInfo returned 0x%x\n", sc ));
                    THROW( CException(sc) );
                }
    
                XInterface<IColumnsInfo> pColInfo(pci);
    
                DBCOLUMNINFO * pTempCols = 0;
                WCHAR *        pwchTemp2 = 0;
                DBORDINAL      cCols;
    
                sc = pColInfo->GetColumnInfo( &cCols, &pTempCols, &pwchTemp2 );
    
                if ( FAILED(sc) )
                {
                    vqDebugOut(( DEB_ERROR, "IColumnsInfo::GetColumnInfo returned 0x%x\n", sc ));
                    THROW( CException(sc) );
                }
    
                XCoMem<DBCOLUMNINFO> pCols( pTempCols );
                XCoMem<WCHAR>        pStr( pwchTemp2 );
    
                if ( cCols != *pcColumns )
                {
                    Win4Assert( cCols == *pcColumns );
                    THROW( CException( E_FAIL ) );
                }
    
                //
                // Review all columns.
                //
    
                for ( unsigned j = 0; j < cCols; j++ )
                {
                    //
                    // DBID has to match.
                    //
    
                    if ( !IsEqual( pBaseline[j].columnid, pCols[j].columnid ) )
                    {
                        Win4Assert( !"Mismatched columns" );
                        THROW( CException( E_FAIL ) );
                    }
    
                    //
                    // pwszName should be returned if all names are the same.
                    //
    
                    if ( 0 != pBaseline[j].pwszName && 0 != pCols[j].pwszName &&
                         wcscmp( pBaseline[j].pwszName, pCols[j].pwszName ) != 0 )
                        pBaseline[j].pwszName = 0;
    
                    //
                    // iOrdinal must match.
                    //
    
                    if ( pBaseline[j].iOrdinal != pCols[j].iOrdinal )
                    {
                        Win4Assert( !"Mismatched columns" );
                        THROW( CException( E_FAIL ) );
                    }
    
                    //
                    // If dwType doesn't match, we go to DBTYPE_VARIANT
                    //
    
                    if ( pBaseline[j].wType != pCols[j].wType )
                        pBaseline[j].wType = DBTYPE_VARIANT;
    
                    //
                    // Take the maximum cbMaxLength, except for bookmark where we sum
                    // the lengths.
                    //
    
                    Win4Assert( 0 == (pBaseline[j].dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) ||
                                ( pBaseline[j].ulColumnSize == pCols[j].ulColumnSize &&
                                  pBaseline[j].dwFlags & DBCOLUMNFLAGS_ISFIXEDLENGTH ) );
    
                    if ( pBaseline[j].dwFlags & DBCOLUMNFLAGS_ISBOOKMARK && i == (_cChild - 1) )
                    {
                        //
                        // Last pass through, add room for child id and give room
                        // to store ulColumnSize for *each* child.
                        //
    
                        pBaseline[j].ulColumnSize *= _cChild;
                        pBaseline[j].ulColumnSize += sizeof(ULONG);
                    }
                    else
                        if ( pBaseline[j].ulColumnSize < pCols[j].ulColumnSize )
                            pBaseline[j].ulColumnSize = pCols[j].ulColumnSize;
    
                    if ( pBaseline[j].wType == DBTYPE_NUMERIC )
                    {
                        //
                        // Precision and scale have to match?
                        //
    
                        if ( pBaseline[j].bPrecision != pCols[j].bPrecision ||
                             pBaseline[j].bScale != pCols[j].bScale )
                        {
                            Win4Assert( !"Mismatched columns" );
                            THROW( CException( E_FAIL ) );
                        }
                    }
    
                    //
                    // All the conditions in dwFlags are positive (e.g. IsXXX), so the
                    // final flag is the bitwise and of all children.
                    //
    
    #if CIDBG == 1
                    if ( pBaseline[j].dwFlags != pCols[j].dwFlags )
                    {
                        vqDebugOut(( DEB_WARN,
                                     "GetColumnInfo: Mismatched dwFlags 0x%x, 0x%x\n",
                                     pBaseline[j].dwFlags, pCols[j].dwFlags ));
                    }
    #endif // CIDBG == 1
    
                    pBaseline[j].dwFlags &= pCols[j].dwFlags;
    
                } // for each column
            } // for each cursor
    
            *ppColInfo = pBaseline.Acquire();   // Allow memory to pass back to client.
            *ppwchInfo = pBaseStr.Acquire();
        }
        CATCH( CException, e )
        {
            sc = e.GetErrorCode();
    
            if ( sc != E_INVALIDARG && sc != E_OUTOFMEMORY )
            {
                vqDebugOut(( DEB_ERROR, "CDistributedRowset::GetColumnInfo: bogus error code 0x%x\n", sc ));
                sc = E_FAIL;
            }
        }
        END_CATCH
    }

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IColumnsInfo);

    return( sc );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetColumnInfo, public
//
//  Synopsis:   Returns basic info about columns in table.
//
//  Arguments:  [pcColumns] -- Count returned here.
//              [ppColInfo] -- Array of column descriptors returned here.
//              [ppwchInfo] -- Pointer to storage for all string values.
//
//  History:    27-Sep-98   VikasMan    Created
//
//  Notes:      Calls _GetFullColumnInfo and then trims out the extra columns
//              that we added for sorting
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::GetColumnInfo( DBORDINAL * pcColumns,
                                                DBCOLUMNINFO ** ppColInfo,
                                                WCHAR ** ppwchInfo)
{
    SCODE sc = _GetFullColumnInfo( pcColumns, ppColInfo, ppwchInfo );

    if ( SUCCEEDED( sc ) && pcColumns && *pcColumns )
    {
        if ( *pcColumns < _cColumns )
            return E_INVALIDARG;

        Win4Assert( *pcColumns >= _cColumns );

        *pcColumns = _cColumns;
    }

    return( sc );
}


//
// IRowsetIdentity methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::IsSameRow, public
//
//  Arguments:  [hThisRow] -- First row.
//              [hThatRow] -- Second row.
//
//  Returns:    S_OK if the rows are the same, else S_FALSE.
//
//  History:    02-Mar-95   KyleP       Created.
//
//  Notes:      Assumes child rowset(s) support DBROWSETFLAGS_TRUEIDENTITY.
//
//  Notes: Need to have Ole DB error handling here because the underlying 
//         errors are being translated.

//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::IsSameRow( HROW hThisRow, HROW hThatRow )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        HROW hrowChild1, hrowChild2;

        int iChild1 = _RowManager.GetChildAndHROW( hThisRow, hrowChild1 );
        int iChild2 = _RowManager.GetChildAndHROW( hThatRow, hrowChild2 );

        if ( iChild1 == iChild2 && hrowChild1 == hrowChild2 )
            sc = S_OK;
        else
            sc = S_FALSE;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        vqDebugOut(( DEB_ERROR, "Exception 0x%x caught in CDistributedRowset::IsSameRow\n", sc ));
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowsetIdentity);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::CDistributedRowset, public
//
//  Synopsis:   Initialize distributed rowset.
//
//  Arguments:  [pUnkOuter] -- outer unknown
//              [ppMyUnk] -- OUT:  on return, filled with pointer to my
//                           non-delegating IUnknown
//              [aChild] -- Array of child rowsets.
//              [cChild] -- Count of [aChild].
//              [Props]  -- Rowset properties
//              [cColumns] -- Number of original columns
//              [aAccessors]   -- Bag of accessors which rowsets need to inherit
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes:      Ownership of aChild is transferred.
//
//----------------------------------------------------------------------------

CDistributedRowset::CDistributedRowset(
    IUnknown * pUnkOuter,
    IUnknown ** ppMyUnk,
    IRowset ** aChild,
    unsigned cChild,
    CMRowsetProps const & Props,
    unsigned cColumns,
    CAccessorBag & aAccessors,
    CCIOleDBError & DBErrorObj)
        :
#pragma warning(disable : 4355) // 'this' in a constructor
          _aAccessors( (IUnknown *) (IRowset *)this ),
          _impIUnknown(this),
#pragma warning(default : 4355)    // 'this' in a constructor
          _aChild( aChild ),
          _cChild( cChild ),
          _cColumns( cColumns ),
          _aColInfo( 0 ),
          _awchInfo( 0 ),
          _iColumnBookmark( -1 ),
          _cbBookmark( 0 ),
          _Props( Props ),
          _DBErrorObj( DBErrorObj ),
          _cMaxResults( _Props.GetMaxResults() ),
          _cFirstRows( _Props.GetFirstRows() ),
          _iCurrentRow( 0 )
{
    // NTRAID#DB-NTBUG9-84049-2000/07/31-dlee Distributed queries need to support MaxResults for scrollable sorted rowsets

    Win4Assert( _cChild > 0 );

    if (pUnkOuter) 
        _pControllingUnknown = pUnkOuter;
    else
        _pControllingUnknown = (IUnknown * )&_impIUnknown;

    //
    // We need to get column info once in order to figure out which column (if any)
    // is the bookmark column.  We'll cache the column info in _aColInfo just in
    // case the client also needs it.
    //

    SCODE sc = _GetFullColumnInfo( &_cColInfo, &_aColInfo, &_awchInfo );

    if ( FAILED(sc) )
    {
        vqDebugOut(( DEB_ERROR,
                     "CDistributedRowset: Error 0x%x fetching column info\n", sc ));
        THROW( CException( sc ) );
    }

    for ( unsigned i = 0; i < _cColInfo; i++ )
    {
        if ( _aColInfo[i].dwFlags & DBCOLUMNFLAGS_ISBOOKMARK )
        {
            _iColumnBookmark = _aColInfo[i].iOrdinal;
            _cbBookmark = _aColInfo[i].ulColumnSize;
            break;
        }
    }

    //
    // GetBindings for each accessor in bag, and use them to create accessor
    // in IRowset
    //
    // only CAccessors can be used by commands

    CAccessorBase * pAccBase = (CAccessorBase *)aAccessors.First();
    while ( 0 != pAccBase )
    {
        DBCOUNTITEM cBindings;
        DBBINDING * rgBindings;
        DBACCESSORFLAGS dwAccessorFlags;

        SCODE sc = pAccBase->GetBindings(&dwAccessorFlags, &cBindings, &rgBindings);
        if (FAILED(sc))
            THROW(CException(sc));
      
        HACCESSOR hAccessor;
        sc = CreateAccessor(dwAccessorFlags, cBindings, rgBindings, 0, &hAccessor, 0);
        CoTaskMemFree(rgBindings); //cleanup from GetBindings
        if (FAILED(sc))
            THROW(CException(sc));
      
        //
        // inherited accessors are accessed through same hAccessor as original.
        // Set parent of newly created accessor so that we can link the 2 copies.
        // Client never knows the direct HACESSOR for the inherited accessor.
        // All accessor methods check bag for an accessor with a match on
        // the parent or the creator.
        //
        ((CAccessorBase *)hAccessor)->SetParent(pAccBase);
      
        //
        // Increment inheritor count for parent accessor
        //
        pAccBase->IncInheritors();
      
        pAccBase = (CDistributedAccessor *)aAccessors.Next();
    }
#if CIDBG == 1
    for ( i++; i < _cColInfo; i++ )
    {
        Win4Assert( 0 == (_aColInfo[i].dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) );
    }
#endif

    *ppMyUnk = ((IUnknown *)&_impIUnknown);
    (*ppMyUnk)->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::~CDistributedRowset, public
//
//  Synopsis:   Destructor
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CDistributedRowset::~CDistributedRowset()
{
    unsigned ii;

    if ( !_xChildNotify.IsNull() )
    {
        _xChildNotify->OnRowsetChange( DBREASON_ROWSET_RELEASE,
                                       DBEVENTPHASE_DIDEVENT,
                                       TRUE);
    }

    for ( ii = _xArrChildAsynchCP.Count(); ii > 0; ii-- )
    {
        if ( _xArrChildAsynchCP[ii-1].GetPointer() )
        {
            _xArrChildAsynchCP[ii-1]->Unadvise( _xArrAsynchAdvise[ii-1] );
        }
    }

    for ( ii = _xArrChildWatchCP.Count(); ii > 0; ii-- )
    {
        if ( _xArrChildWatchCP[ii-1].GetPointer() )
        {
            _xArrChildWatchCP[ii-1]->Unadvise( _xArrWatchAdvise[ii-1] );
        }
    }

    _xServerCPC.Free();

    if ( 0 != _aColInfo )
        CoTaskMemFree( _aColInfo );

    if ( 0 != _awchInfo )
        CoTaskMemFree( _awchInfo );

    for ( unsigned i = 0; i < _cChild; i++ )
    {
        if ( 0 != _aChild[i] )
            _aChild[i]->Release();
    }

    delete [] _aChild;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::CanConvertType, public
//
//  Synopsis:   Gives info. on the availability of type conversions.
//
//  History:    29-Jan-97   KrishnaN       Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::CanConvert( DBTYPE wFromType,
                                             DBTYPE wToType,
                                             DBCONVERTFLAGS dwConvertFlags)
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc;

    for (unsigned iChild = 0; iChild < _cChild; iChild++)
    {

        IConvertType* pIConvertType = 0;
        sc = _aChild[iChild]->QueryInterface( IID_IConvertType, (void **) &pIConvertType );

        if (SUCCEEDED( sc ))
        {
            sc = pIConvertType->CanConvert(wFromType, wToType, dwConvertFlags);
            pIConvertType->Release();
        }

        if (sc != S_OK)
            return _DBErrorObj.PostHResult(sc, IID_IConvertType);
    }

    return S_OK;
}


//
// Helper function used by GetStatus and GetStatusEx
//
inline void ParseQueryFillStatus( DWORD   dwQueryFillStatus, 
                                  DWORD & dwError, 
                                  DWORD & dwBusy, 
                                  DWORD & dwRefresh, 
                                  DWORD & dwDone )
{
    if ( STAT_ERROR == dwQueryFillStatus )
     {
         dwError = 1;
         dwDone = 0;
     }
     else if ( STAT_BUSY == dwQueryFillStatus )
     {
         dwBusy = 1;
         dwDone = 0;
     }
     else if ( STAT_REFRESH == dwQueryFillStatus )
     {
         dwRefresh = 1;
         dwDone = 0;
     }
     else if ( STAT_DONE == dwQueryFillStatus )
     {
         dwDone &= 1;
     }
}

//
// Helper function used by GetStatus and GetStatusEx
//
inline void SetQueryFillStatus( DWORD & dwStatus, 
                                DWORD   dwError, 
                                DWORD   dwBusy, 
                                DWORD   dwRefresh, 
                                DWORD   dwDone )
{
    if ( dwError )
    {
        dwStatus |= STAT_ERROR;
    }
    else if ( dwBusy )
    {
        dwStatus |= STAT_BUSY;
    }
    else if ( dwRefresh )
    {
        dwStatus |= STAT_REFRESH;
    }
    else if ( dwDone )
    {
        dwStatus |= STAT_DONE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetStatus, public
//
//  Synopsis:   Return query status
//
//  Arguments:  [pdwStatus]      -- pointer to where query status is returned
//
//  Returns:    SCODE error code
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::GetStatus( DWORD * pdwStatus ) 
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if ( pdwStatus )
    {
        *pdwStatus = 0;
    
        DWORD dwBusy    = 0;
        DWORD dwError   = 0;
        DWORD dwRefresh = 0;
        DWORD dwDone    = 1;
    
        XInterface<IRowsetQueryStatus> xIRowsetQueryStatus;
    
        for (unsigned iChild = 0; iChild < _cChild; iChild++)
        {
            scResult = _aChild[iChild]->QueryInterface( IID_IRowsetQueryStatus, 
                                                        xIRowsetQueryStatus.GetQIPointer() );
            
            DWORD dwChildStatus;
    
            if ( SUCCEEDED( scResult ) )
                scResult = xIRowsetQueryStatus->GetStatus( &dwChildStatus );

            xIRowsetQueryStatus.Free();
    
            if (scResult != S_OK)
                return scResult;
    
            // OR the query reliability status

            *pdwStatus |= QUERY_RELIABILITY_STATUS(dwChildStatus);
    
            ParseQueryFillStatus( QUERY_FILL_STATUS( dwChildStatus ), 
                                  dwError, dwBusy, dwRefresh, dwDone );
        }
    
        // Now set the QUERY_FILL_STATUS. If we have at in the following order:
        // ERROR > BUSY > REFRESH > DONE
    
        SetQueryFillStatus( *pdwStatus, dwError, dwBusy, dwRefresh, dwDone ); 
    }

    return scResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetStatusEx, public
//
//  Synopsis:   Return query status
//
//  Arguments:  [pdwStatus]           - returns query status
//              [pcFilteredDocuments] - # of documents filtered
//              [pcDocumentsToFilter] - # of docsuments yet to filter
//              [pdwRatioFinishedDenominator] - ratio finished denominator
//              [pdwRatioFinishedNumerator]   - ratio finished numerator
//              [cbBmk]               - # of bytes in pBmk
//              [pBmk]                - bookmark for piRowBmk
//              [piRowBmk]            - returns index of bookmark in table
//              [pcRowsTotal]         - current # of rows in table
//
//  Returns:    SCODE error code
//
//----------------------------------------------------------------------------

STDMETHODIMP CDistributedRowset::GetStatusEx(
    DWORD * pdwStatus,
    DWORD * pcFilteredDocuments,
    DWORD * pcDocumentsToFilter,
    DBCOUNTITEM * pdwRatioFinishedDenominator,
    DBCOUNTITEM * pdwRatioFinishedNumerator,
    DBBKMARK   cbBmk,
    const BYTE * pBmk,
    DBCOUNTITEM * piRowBmk,
    DBCOUNTITEM * pcRowsTotal )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;

    if ( pdwStatus )
        *pdwStatus = 0;

    if ( pcFilteredDocuments )
        *pcFilteredDocuments = 0;

        *pcDocumentsToFilter = 0;

    if ( pdwRatioFinishedDenominator )
        *pdwRatioFinishedDenominator = 0;

    if ( pdwRatioFinishedNumerator )
        *pdwRatioFinishedNumerator = 0;

    if ( piRowBmk )
        *piRowBmk = 0;

    if ( pcRowsTotal )
        *pcRowsTotal = 0;

    DWORD dwBusy    = 0;
    DWORD dwError   = 0;
    DWORD dwRefresh = 0;
    DWORD dwDone    = 1;

    ULONG iBmkCursor = 0;
    BYTE const * pChildBmk = NULL;

    // Parse bookmark
    if ( cbBmk != 0 )
    {
        iBmkCursor = *( (ULONG*)pBmk );
        pChildBmk = pBmk + sizeof( ULONG ) + ( iBmkCursor * sizeof( ULONG ) );
        cbBmk = sizeof( ULONG );
    }

    double dRatio = 0;

    XInterface<IRowsetQueryStatus> xIRowsetQueryStatus;
    for (unsigned iChild = 0; iChild < _cChild; iChild++)
    {
        scResult = _aChild[iChild]->QueryInterface( IID_IRowsetQueryStatus, 
                                                    xIRowsetQueryStatus.GetQIPointer() );
        
        DWORD dwChildStatus;
        DWORD cFilteredDocuments;
        DWORD cDocumentsToFilter;
        DBCOUNTITEM dwRatioFinishedDenominator;
        DBCOUNTITEM dwRatioFinishedNumerator;
        DBCOUNTITEM iRowBmk;
        DBCOUNTITEM cRowsTotal;

        if ( SUCCEEDED( scResult ) )
        {
            scResult = xIRowsetQueryStatus->GetStatusEx( &dwChildStatus,
                                                         &cFilteredDocuments,
                                                         &cDocumentsToFilter,
                                                         &dwRatioFinishedDenominator,
                                                         &dwRatioFinishedNumerator,
                                                         ( cbBmk > 0 && iBmkCursor == iChild ) ?
                                                            cbBmk : 0,
                                                         ( cbBmk > 0 && iBmkCursor == iChild ) ?
                                                            pChildBmk : 0,
                                                         &iRowBmk,
                                                         &cRowsTotal );
        }
        xIRowsetQueryStatus.Free();

        if (scResult != S_OK)
        {
            return scResult;
        }

        // OR the query reliability status
        if ( pdwStatus )
        {
            *pdwStatus |= QUERY_RELIABILITY_STATUS(dwChildStatus);
        }

        ParseQueryFillStatus( QUERY_FILL_STATUS( dwChildStatus ), 
                              dwError, dwBusy, dwRefresh, dwDone );

        if ( pcFilteredDocuments )
            *pcFilteredDocuments += cFilteredDocuments;

        if ( pcDocumentsToFilter )
            *pcDocumentsToFilter += cDocumentsToFilter;

        if ( dwRatioFinishedDenominator )
        {
            dRatio += ( (double)dwRatioFinishedNumerator / (double)dwRatioFinishedDenominator );
        }

        if ( pcRowsTotal )
            *pcRowsTotal += cRowsTotal;
    }

    DWORD dwNum = 0;
    DWORD dwDen = 0;

    if ( dRatio )
    {
        Win4Assert( _cChild );

        dRatio /= _cChild;
        dwDen = 1;

        while ( dRatio < 1.0 )
        {
            dRatio *= 10;
            dwDen *= 10;
        }
        dwNum = (DWORD)dRatio;
    }

    if ( pdwRatioFinishedDenominator )
        *pdwRatioFinishedDenominator = dwNum;

    if ( pdwRatioFinishedNumerator )
        *pdwRatioFinishedNumerator = dwDen;

    // Now set the QUERY_FILL_STATUS. If we have at in the following order:
    // ERROR > BUSY > REFRESH > DONE

    if ( pdwStatus )
        SetQueryFillStatus( *pdwStatus, dwError, dwBusy, dwRefresh, dwDone ); 

    return scResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::_SetupChildNotifications, private
//
//  Synopsis:   Set up connection points to receive notifications from the
//              child rowsets
//
//  Arguments:  fAsynchOnly - TRUE  if Asynch only,
//                            FLASE if Asynch and Watchable    
//
//  Returns:    void
//
//  History:    03 Sep 1998    VikasMan    Created
//
//----------------------------------------------------------------------------
void CDistributedRowset::_SetupChildNotifications( BOOL fAsynchOnly )
{
    SCODE sc;
    XInterface<IConnectionPointContainer> xChildCPC;

    // various arrays for the child rowsets
    _xArrAsynchAdvise.Init( _cChild );
    _xArrChildAsynchCP.Init( _cChild );

    if ( !fAsynchOnly )
    {
        _xArrWatchAdvise.Init( _cChild );
        _xArrChildWatchCP.Init( _cChild );
    }

    _xArrChildRowsetWatchRegion.Init( _cChild );

    for (unsigned iChild = 0; iChild < _cChild; iChild++)
    {
        sc = _aChild[iChild]->QueryInterface( IID_IConnectionPointContainer, 
                                              xChildCPC.GetQIPointer() );
        if ( SUCCEEDED( sc ) )
        {
            sc = xChildCPC->FindConnectionPoint( IID_IDBAsynchNotify,
                                                 (IConnectionPoint**)_xArrChildAsynchCP[iChild].GetQIPointer() );

            if (SUCCEEDED(sc))
            {
                sc = _xArrChildAsynchCP[iChild]->Advise( (IUnknown *)(void*)(_xChildNotify.GetPointer()),
                                                        &_xArrAsynchAdvise[iChild] );
            }

            if ( !fAsynchOnly )
            {
                sc = xChildCPC->FindConnectionPoint( IID_IRowsetWatchNotify,
                                                     (IConnectionPoint**)_xArrChildWatchCP[iChild].GetQIPointer() );
    
                if (SUCCEEDED(sc))
                {
                    sc = _xArrChildWatchCP[iChild]->Advise( (IUnknown *)(void*)(_xChildNotify.GetPointer()),
                                                           &_xArrWatchAdvise[iChild] );
                }
            }                                                

            xChildCPC.Free();

            _aChild[iChild]->QueryInterface( IID_IRowsetWatchRegion,
                                             _xArrChildRowsetWatchRegion[iChild].GetQIPointer() );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::_SetupConnectionPointContainer, private
//
//  Synopsis:   Setups the connection point conatiner and other notification stuff
//              for the distributed rowset. Handles both asynchronous ( for
//              scrollable sorted rowset ) and synchronous ( for sequential rowset )
//              cases.
//              
//  Arguments:  pRowset - Rowset for which notifications are to be handled
//              ppiuk   - IConnectionPointContainer interface is returned here
//
//  Returns:    SCODE
//
//  History:    22 Sep 1998    VikasMan    Created
//
//----------------------------------------------------------------------------

SCODE CDistributedRowset::_SetupConnectionPointContainer( IRowset * pRowset, VOID * * ppiuk  )
{
    SCODE sc = S_OK;

    BOOL fWatchable = (_Props.GetPropertyFlags() & eWatchable) != 0;
    BOOL fAsynchronous = (_Props.GetPropertyFlags() & eAsynchronous) != 0;

    if ( _xServerCPC.IsNull() )
    {
        TRY
        {
            _xServerCPC.Set( new CConnectionPointContainer(
                        fAsynchronous ? 3 : 1,
                        * ((IUnknown *) pRowset),
                        _DBErrorObj ) );

            // Create an instance of CDistributedRowsetWatchNotify which acts as
            // sink for the child rowsets and connection point for this rowset's clients
            _xChildNotify.Set( new CDistributedRowsetWatchNotify( pRowset, _cChild ) );
        
            if ( fWatchable || fAsynchronous )
            {
                // set up to recieve notifications from all child rowsets
                _SetupChildNotifications( !fWatchable );
            }

           _xChildNotify->AddConnectionPoints( _xServerCPC.GetPointer(), 
                                               fAsynchronous, 
                                               fWatchable );

        }
        CATCH( CException, e )
        {
            sc = GetOleError( e );
        }
        END_CATCH;
    }

    if ( S_OK == sc )
    {
        Win4Assert( _xServerCPC.GetPointer()  );
        *ppiuk = (void *) (IConnectionPointContainer *)
                 _xServerCPC.GetPointer();
    }

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDistributedRowset::GetNextRows, public
//
//  Synopsis:   Calls _GetNextRows(which is overridden by derived classes)
//              and handles notifications
//
//  Arguments:  [hChapter]       -- Chapter
//              [cRowsToSkip]    -- Skip this many rows before beginning.
//              [cRows]          -- Try to fetch this many rows.
//              [pcRowsObtained] -- Actually fetched this many.
//              [pphRows]        -- Store HROWs here.  Allocate memory if
//                                  [pphRows] is zero.
//
//  History:    22-Sep-98   VikasMan      Created.
//
//----------------------------------------------------------------------------

SCODE CDistributedRowset::GetNextRows( HCHAPTER hChapter,
                                      DBROWOFFSET cRowsToSkip,
                                      DBROWCOUNT cRows,
                                      DBCOUNTITEM * pcRowsObtained,
                                      HROW * * pphRows )
{
    SCODE scResult = S_OK;
    BOOL fNotified = FALSE;

    TRY
    {
        Win4Assert( pcRowsObtained );

        *pcRowsObtained = 0;

        DBROWCOUNT cRowLimit = _cFirstRows > 0 ? _cFirstRows : _cMaxResults; 

        // check for max rows
        if ( cRowLimit )
        {
            if ( _iCurrentRow + cRowsToSkip > cRowLimit )
            {
                return DB_S_ROWLIMITEXCEEDED;
            }

            if ( _iCurrentRow + cRowsToSkip + cRows > cRowLimit )
            {
                cRows = cRowLimit - (_iCurrentRow + cRowsToSkip);

                if ( 0 == cRows )
                {
                    return DB_S_ROWLIMITEXCEEDED;
                }
            }
        }

        if ( !_xChildNotify.IsNull() )
        {
            scResult = _xChildNotify->OnRowsetChange( DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                                      DBEVENTPHASE_OKTODO,
                                                      FALSE);
            if ( S_FALSE == scResult )
                THROW(CException(DB_E_CANCELED));
            fNotified = TRUE;
        }
        scResult = _GetNextRows( hChapter,
                                 cRowsToSkip,
                                 cRows,
                                 pcRowsObtained,
                                 pphRows );

        if ( SUCCEEDED( scResult ) && *pcRowsObtained )
        {
            _iCurrentRow += *pcRowsObtained;
        }

        if ( fNotified )
        {
            if ( SUCCEEDED(scResult) )
            {
                if ( *pcRowsObtained != 0 )
                {
                    _xChildNotify->OnRowChange( *pcRowsObtained,
                                                *pphRows,
                                                DBREASON_ROW_ACTIVATE,
                                                DBEVENTPHASE_DIDEVENT,
                                                TRUE);
                }
                _xChildNotify->OnRowsetChange( DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                               DBEVENTPHASE_DIDEVENT,
                                               TRUE);
            }
        }
    }
    CATCH( CException, e )
    {
        scResult = GetOleError(e);
    }
    END_CATCH;

    if ( fNotified && FAILED(scResult) )
    {
        _xChildNotify->OnRowsetChange( DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                       DBEVENTPHASE_FAILEDTODO,
                                       TRUE);
    }
    return scResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\pcache.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995.
//
// File:        PCache.hxx
//
// Contents:    Protocol for HROW cache
//
// Classes:     PMiniRowCache
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "pcache.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     PMiniRowCache::PMiniRowCache, public
//
//  Synopsis:   Initialize, and setup default binding
//
//  Arguments:  [Index]     -- Identifier.  Not used internally.
//              [pRowset]   -- Rowset used to fill cache.
//              [cBindings] -- Size of [pBindings].
//              [pBindings] -- Default binding.
//              [cbMaxLen]  -- Max length of data fetched via [pBindings]
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::PMiniRowCache( int Index,
                              IRowset * pRowset,
                              unsigned cBindings,
                              DBBINDING * pBindings,
                              unsigned cbMaxLen )
        : _Index( Index ),
          _pRowset( pRowset ),
          _ahrow( 2 ),
          _chrow( 0 ),
          _ihrow( 0 ),
          _cbRow( cbMaxLen )
{
    //
    // Setup buffer for current row
    //

    _pbRow = new BYTE [_cbRow];

    //
    // Setup accessor
    //

    IAccessor * pia = 0;
    SCODE sc = _pRowset->QueryInterface( IID_IAccessor, (void **)&pia );
    if (SUCCEEDED( sc ))
    {
        sc = pia->CreateAccessor( DBACCESSOR_ROWDATA,
                                  cBindings,
                                  pBindings,
                                  0,
                                  &_hacc,
                                  0);
        pia->Release();
    }

    if ( FAILED(sc) )
    {
        delete [] _pbRow;

        vqDebugOut(( DEB_ERROR,
                     "PMiniRowCache: CreateAccessor(child %d) returned 0x%x\n",
                     _Index, sc ));

        THROW( CException(sc) );
    }

    END_CONSTRUCTION( PMiniRowCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     PMiniRowCache::~PMiniRowCache, public
//
//  Synopsis:   Destructor.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::~PMiniRowCache()
{
    //
    // Release any rows not transferred out.
    //

    FlushCache();

    delete [] _pbRow;

    IAccessor * pia = 0;
    _pRowset->QueryInterface( IID_IAccessor, (void **)&pia );
    Win4Assert(pia && "Invalid accessor!");
    pia->ReleaseAccessor( _hacc, 0 );
    pia->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     PMiniRowCache::SetCacheSize, public
//
//  Synopsis:   Adjust number of cached rows.
//
//  Arguments:  [cNewRows] -- Number of rows to cache.
//
//  History:    05-Jun-95   KyleP       Created.
//
//  Notes:      This call is advisory.  There are situtations where the
//              cache cannot be shrunk.
//
//----------------------------------------------------------------------------

void PMiniRowCache::SetCacheSize( DBCOUNTITEM cNewRows )
{
    Win4Assert( cNewRows > 0 );

    //
    // Only realloc if the cache size is different.
    //

    if ( cNewRows != (DBCOUNTITEM) _ahrow.Count() )
    {
        //
        // We can't realloc to a smaller size than the number of rows
        // we're currently holding.  Where would we put them?
        //

        if ( cNewRows < (DBCOUNTITEM) _chrow - (DBROWCOUNT) _ihrow &&
             _ihrow < _chrow )
        {
            cNewRows = _chrow - _ihrow;
        }

        //
        // Canonicalize the empty case.
        //

        if ( _ihrow >= _chrow )
            _ihrow = _chrow = 0;

        //
        // Realloc array of HROWs.
        //

        HROW * pnew = new HROW [(unsigned) cNewRows];

        RtlCopyMemory( pnew,
                       _ahrow.GetPointer() + _ihrow,
                       (_chrow - _ihrow) * sizeof(HROW) );

        delete [] _ahrow.Acquire();

        _ahrow.Set( (unsigned) cNewRows, pnew );

        //
        // Adjust index
        //

        _chrow -= _ihrow;
        _ihrow = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     PMiniRowCache::LoadData, protected
//
//  Synopsis:   Called by derived classes to load default data for a new row.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void PMiniRowCache::LoadData()
{
    //
    // Load up data for row.
    //

    SCODE sc = _pRowset->GetData( _ahrow[(unsigned) _ihrow], _hacc, _pbRow );

    if ( FAILED(sc) )
    {
        vqDebugOut(( DEB_ERROR, "PMiniRowCache: GetData returned 0x%x\n", sc ));
        THROW( CException( E_FAIL ) );
    }

#if CIDBG == 1
    if ( vqInfoLevel & DEB_ITRACE )
    {
        vqDebugOut(( DEB_ITRACE, "Data for %d: ", Index() ));

        for ( int i = 0; i < 40; i++ )
        {
            if ( _pbRow[i] >= ' ' && _pbRow[i] <= '~' && 0 == _pbRow[i+1] )
            {
                vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "%wc", *(WCHAR UNALIGNED *)&_pbRow[i] ));
                i++;
            }
            else
                vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "%02x", _pbRow[i] ));
        }
        vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "\n", _pbRow[i] ));
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     PMiniRowCache::FlushCache, public
//
//  Synopsis:   Clear the cache.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void PMiniRowCache::FlushCache()
{
    if ( !IsAtEnd() )
    {
        _pRowset->ReleaseRows( _chrow - _ihrow, _ahrow.GetPointer() + _ihrow, 0, 0, 0 );
    }

    _ihrow = _chrow = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\rowcache.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995.
//
// File:        RowCache.cxx
//
// Contents:    Forward-only cache
//
// Classes:     CMiniRowCache
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "rowcache.hxx"


//+---------------------------------------------------------------------------
//
//  Member:     CMiniRowCache::CMiniRowCache, public
//
//  Synopsis:   Initialize
//
//  Arguments:  [Index]     -- Identifier.  Not used internally.
//              [pRowset]   -- Rowset used to fill cache.
//              [cBindings] -- Size of [pBindings].
//              [pBindings] -- Default binding.
//              [cbMaxLen]  -- Max length of data fetched via [pBindings]
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CMiniRowCache::CMiniRowCache( int Index,
                              IRowset * pRowset,
                              unsigned cBindings,
                              DBBINDING * pBindings,
                              unsigned cbMaxLen )
        : PMiniRowCache( Index, pRowset, cBindings, pBindings, cbMaxLen )
{
    Next();

    END_CONSTRUCTION( CMiniRowCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::Next, public
//
//  Synopsis:   Moves to next row
//
//  Returns:    Move status
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CMiniRowCache::Next( int iDir /* = 1 */ )
{
    // Cna only go forward here
    Win4Assert( iDir > 0 );

    //
    // If we had a row in cache,  Just advance to it.  Otherwise
    // fetch more rows from table.
    //

    _ihrow++;

    if ( _ihrow >= _chrow )
    {
        //
        // Fetch more rows from table.
        //

        HROW * phrow = _ahrow.GetPointer();
        SCODE sc = _pRowset->GetNextRows( 0, 0, _ahrow.Count() , &_chrow, &phrow );

        vqDebugOut(( DEB_ITRACE, "Fetched %d from %d\n", _chrow, _Index ));

        if ( FAILED(sc) )
        {
            vqDebugOut(( DEB_ERROR, "CMiniRowCache: Error 0x%x from GetNextRows\n", sc ));
            _chrow = 0;

            THROW( CException( sc ) );
        }
        else if ( 0 == _chrow && sc != DB_S_ENDOFROWSET )
        {
            return( CMiniRowCache::NotNow );
        }

        _ihrow = 0;
    }

    if( IsAtEnd() )
    {
        return CMiniRowCache::EndOfRows;
    }

    LoadData();

    return CMiniRowCache::Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\rowheap.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 1998
//
// File:        RowHeap.cxx
//
// Contents:    Heap of rowsets.
//
// Classes:     CRowHeap
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "rowheap.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::CRowHeap, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  [cCursor] -- Max number of elements in heap.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CRowHeap::CRowHeap( unsigned cCursor )
        : _ahrowTop( cCursor ),
          _cCursor( cCursor )
{
    END_CONSTRUCTION( CRowHeap );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::Init, public
//
//  Synopsis:   Create heap.
//
//  Arguments:  [pComparator] -- Used to compare elements.
//              [apCursor]    -- Heap created from these.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CRowHeap::Init( CRowComparator * pComparator,
                     PMiniRowCache ** apCursor )
{
    _pComparator = pComparator;
    _apCursor = apCursor;

    //
    // Move invalid cursors to end.
    //

    int cValid = _cCursor;

    for ( int i = 0; i < cValid; i++ )
    {
        if ( _apCursor[i]->IsAtEnd() )
        {
            cValid--;
            PMiniRowCache * pTemp = _apCursor[i];
            _apCursor[i] = _apCursor[cValid];
            _apCursor[cValid] = pTemp;
            i--;
        }
    }

    //
    // And create a heap out of the rest.
    //

    MakeHeap( cValid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::ReInit, public
//
//  Synopsis:   Recreate heap.
//
//  Arguments:  [cValid] -- Number of valid cursors.  Others to end.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CRowHeap::ReInit( int cValid )
{
    MakeHeap( cValid );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::Validate, public
//
//  Synopsis:   See notes.
//
//  Returns:    State of heap.
//
//  History:    05-Jun-95   KyleP       Created.
//
//  Notes:      There are times when iteration stopped because some cursor
//              couldn't continue (usually for block-limited rows, or
//              some error condition).  When this situation occurs, Validate
//              must be called to reset the heap.
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CRowHeap::Validate()
{
    if ( !IsHeapEmpty() && Top()->IsAtEnd() )
        return Next();
    else
        return PMiniRowCache::Ok;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::AdjustCacheSize, public
//
//  Synopsis:   Adjust size of row cache(s).
//
//  Arguments:  [cRows] -- Total number of rows to cache.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CRowHeap::AdjustCacheSize( ULONG cRows )
{
    if ( Count() > 0 )
    {
        ULONG cRowsPerCursor = 1 + cRows / Count();

        if ( cRowsPerCursor != Top()->CacheSize() )
        {
            for ( int i = 0; i < _cCursor; i++ )
                _apCursor[i]->SetCacheSize( cRowsPerCursor );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::Next, public
//
//  Synopsis:   Move to next element.
//
//  Returns:    State of heap.  Move occurred only if PMiniRowCache::Ok.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CRowHeap::Next( int iDir /* = 1 */ )
{
    PMiniRowCache::ENext next = Top()->Next( iDir );

    if ( PMiniRowCache::NotNow == next )
        return next;

    if ( PMiniRowCache::EndOfRows == next )
    {
        RemoveTop();
    
        if ( IsHeapEmpty() )
            return next;

        next = PMiniRowCache::Ok;
    }

    _ahrowTop[Top()->Index()] = Top()->GetHROW();

    Reheap();

    return next;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::NthToTop, public
//
//  Effects:    Moves Nth element of heap to top.
//
//  Arguments:  [n] -- Nth element of heap.
//
//  History:    23-Jun-95   KyleP       Created.
//
//  Notes:      This is different from CRowHeap::Next, because the caches
//              themselves are not touched.  It is used for approximate
//              positioning.
//
//              This is a destructive function!  Elements are removed from
//              the heap.
//
//----------------------------------------------------------------------------

void CRowHeap::NthToTop( unsigned n )
{
    for ( ; n > 0; n-- )
    {
        RemoveTop();
        Reheap();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::Add, public
//
//  Synopsis:   Add element to heap.
//
//  Arguments:  [pCursor] -- Cursor to add.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CRowHeap::Add( PMiniRowCache * pCursor )
{
    //
    // Special case: empty cursor.
    //

    if ( pCursor->IsAtEnd() )
    {

        _ahrowTop[pCursor->Index()] = (HROW)-1;

        return;
    }

    _iEnd++;

    _ahrowTop[pCursor->Index()] = pCursor->GetHROW();

    //
    // Special case: empty heap.
    //

    if ( 0 == _iEnd )
    {
        _apCursor[0] = pCursor;
        return;
    }

    int child, parent;

    for ( child = _iEnd, parent = (_iEnd-1)/2;
          child > 0;
          child=parent, parent = (parent-1)/2)
    {
        if ( !_pComparator->IsLT( pCursor->GetData(),
                                pCursor->DataLength(),
                                pCursor->Index(),
                                _apCursor[parent]->GetData(),
                                _apCursor[parent]->DataLength(),
                                _apCursor[parent]->Index() ) )
            break;
        _apCursor[child] = _apCursor[parent];
    }

    _apCursor[child] = pCursor;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::Reheap, private
//
//  Synopsis:   'Heapify'.  Called when top element (only!) has changed.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CRowHeap::Reheap()
{
    PMiniRowCache * root_item = _apCursor[0];

    int parent, child;

    for ( parent = 0, child = 1;
          child <= _iEnd;
          parent = child, child = 2 * child + 1 )
    {
        if ( child < _iEnd &&
             _pComparator->IsLT( _apCursor[child+1]->GetData(),
                               _apCursor[child+1]->DataLength(),
                               _apCursor[child+1]->Index(),
                               _apCursor[child]->GetData(),
                               _apCursor[child]->DataLength(),
                               _apCursor[child]->Index() ) )
        {
            child++;
        }

        if ( !_pComparator->IsLT( _apCursor[child]->GetData(),
                                _apCursor[child]->DataLength(),
                                _apCursor[child]->Index(),
                                root_item->GetData(),
                                root_item->DataLength(),
                                root_item->Index() ) )
        {
            break;
        }

        _apCursor[parent] = _apCursor[child];
    }

    _apCursor[parent] = root_item;

#   if CIDBG == 1
        AssertCursorArrayIsValid();
#   endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowHeap::MakeHeap, private
//
//  Synopsis:   'Heapify'.  Called when all elements have changed.
//
//  Arguments:  [cValid] -- Number of valid cursors, all positioned toward
//                          beginning of array.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CRowHeap::MakeHeap( int cValid )
{
    _iEnd = -1;

    for ( int i = 0; i < cValid; i++ )
        Add( _apCursor[i] );

    for ( i = cValid; i < _cCursor; i++ )
        _ahrowTop[_apCursor[i]->Index()] = (HROW)-1;

#   if CIDBG == 1
        AssertCursorArrayIsValid();
#   endif
}

#if CIDBG == 1

void CRowHeap::AssertCursorArrayIsValid()
{
    for ( int i = 0; i < _cCursor; i++ )
        for ( int j = i+1; j < _cCursor; j++ )
        {
            if ( _apCursor[i] == _apCursor[j] )
            {
                vqDebugOut(( DEB_ERROR,
                             "Invalid rowheap: _apCursor[%d] (0x%x) == _apCursor[%d] (0x%x)\n",
                             i, _apCursor[i],
                             j, _apCursor[j] ));
                Win4Assert( _apCursor[i] != _apCursor[j] );
            }
        }
}

#endif // CIDBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\rowman.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 2000
//
// File:        RowMan.cxx
//
// Contents:    Distributed HROW manager.
//
// Classes:     CHRowManager
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "rowman.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::CHRowManager, public
//
//  Synopsis:   Initializes row manager.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CHRowManager::CHRowManager()
        : _aHRow( 0 ),
          _cHRow( 50 ),
          _iFirstFree( 0 ),
          _cChild( 0 ),
          _ahrowHint( 0 )
{
    _aHRow = new CHRow [_cHRow];

    for ( unsigned i = 0; i < _cHRow-1; i++ )
    {
        _aHRow[i].Link( i + 1 );
    }

    _aHRow[_cHRow-1].Link( -1 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::~CHRowManager, public
//
//  Synopsis:   Destructor
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CHRowManager::~CHRowManager()
{
#if CIDBG == 1
    for ( unsigned i = 0; i < _cHRow; i++ )
    {
        if ( _aHRow[i].IsInUse() )
            vqDebugOut(( DEB_WARN, "CHRowManager: HROW %d still in use\n", i ));

        Win4Assert( !_aHRow[i].IsInUse() );
    }
#endif

    delete [] _aHRow;
    delete [] _ahrowHint;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::TrackSiblings, public
//
//  Synopsis:   Turns on tracking of siblings.
//
//  Arguments:  [cChild] -- Number of child cursors.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CHRowManager::TrackSiblings( unsigned cChild )
{
    _cChild = cChild;
    _ahrowHint = new HROW [_cHRow * _cChild];
}

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::Add, public
//
//  Synopsis:   Adds a new HROW to be tracked.
//
//  Arguments:  [iChild] -- Index of governing child cursor.
//              [hrow]   -- HROW used by child cursor
//
//  Returns:    HROW used by distributed row manager.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

HROW CHRowManager::Add( unsigned iChild, HROW hrow )
{
    int iCurrent = InnerAdd( iChild, hrow );

    vqDebugOut(( DEB_ITRACE, "CHRowManager::Add HROW distr=%d child=%d,%d\n",
                 iCurrent, iChild, hrow));
    if ( IsTrackingSiblings() )
    {
        RtlFillMemory( _ahrowHint + (iCurrent * _cChild),
                       _cChild * sizeof(HROW),
                       0xFF );
        _ahrowHint[iCurrent*_cChild + iChild] = hrow;
    }

    return (HROW)( iCurrent+1 );  // we are 0 based while hrow is 1 based
}

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::Add, public
//
//  Synopsis:   Adds a new HROW to be tracked, including hints.
//
//  Arguments:  [iChild] -- Index of governing child cursor.
//              [ahrow]  -- Array of HROW, one per child cursor.
//
//  Returns:    HROW used by distributed row manager.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

HROW CHRowManager::Add( unsigned iChild, HROW const * ahrow )
{
    int iCurrent = InnerAdd( iChild, ahrow[iChild] );

    vqDebugOut(( DEB_ITRACE, "CHRowManager::Add HROW distr=%d child=%d,%d\n",
                 iCurrent, iChild, ahrow[iChild] ));

    RtlCopyMemory( _ahrowHint + (iCurrent * _cChild),
                   ahrow,
                   _cChild * sizeof(HROW) );

    return (HROW)( iCurrent+1 );  // we are 0 based while hrow is 1 based
}

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::AddRef, public
//
//  Synopsis:   De-refs a given hrow
//
//  Arguments:  [hrow] -- Distributed hrow
//
//  History:    11-sept-2000   slarimor       Created.
//
//----------------------------------------------------------------------------

void CHRowManager::AddRef( HROW hrow )
{
    unsigned iCurrent = ConvertAndValidate( hrow );
    _aHRow[iCurrent].AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::Release, public
//
//  Synopsis:   De-refs a given hrow
//
//  Arguments:  [hrow] -- Distributed hrow
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CHRowManager::Release( HROW hrow )
{
    unsigned iCurrent = ConvertAndValidate( hrow );

    _aHRow[iCurrent].Release();

    if ( !_aHRow[iCurrent].IsInUse() )
    {
        _aHRow[iCurrent].Link( _iFirstFree );
        _iFirstFree = iCurrent;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::IsSame, public
//
//  Synopsis:   Compares HROWs.
//
//  Arguments:  [hrow1] -- Distributed hrow
//              [hrow1] -- Distributed hrow
//
//  Returns:    FALSE.  We can't compare rows right now.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CHRowManager::IsSame( HROW hrow1, HROW hrow2 )
{
    // NTRAID#DB-NTBUG9-84054-2000/07/31-dlee Distributed queries don't implement hrow identity IsSame() method

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CHRowManager::Grow, private
//
//  Synopsis:   Grow HROW free space.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CHRowManager::Grow()
{
    //
    // Allocate new array.
    //

    unsigned cTemp = _cHRow * 2;
    CHRow * pTemp = new CHRow [cTemp];

    //
    // Transfer old data.
    //

    RtlCopyMemory( pTemp, _aHRow, _cHRow * sizeof(_aHRow[0]) );

    //
    // Link new elements into free list.
    //

    Win4Assert( _iFirstFree == -1 );

    for ( unsigned i = _cHRow; i < cTemp-1; i++ )
    {
        pTemp[i].Link( i + 1 );
    }

    pTemp[cTemp-1].Link( -1 );

    //
    // Out with the old, and in with the new.
    //

    delete [] _aHRow;

    _aHRow = pTemp;

    //
    // And now the same thing for the hint.  Note that we've completely taken
    // care of memory leaks for _aHRow before moving on to the hints.
    //

    if ( IsTrackingSiblings() )
    {
        HROW * pTempHint = new HROW [cTemp * _cChild];
        RtlCopyMemory( pTempHint, _ahrowHint, _cHRow*_cChild*sizeof(_ahrowHint[0]) );

        delete [] _ahrowHint;
        _ahrowHint = pTempHint;
    }

    _iFirstFree = _cHRow;
    _cHRow = cTemp;
} //Grow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\poscache.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 2000
//
// File:        PosCache.cxx
//
// Contents:    Positionable cache
//
// Classes:     CMiniPositionableCache
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//              29-Mar-2000     KLam        Fixed Bookmarks
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "poscache.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::CMiniPositionableCache, public
//
//  Synopsis:   Builds bindings to fetch bookmark.
//
//  Arguments:  [Index]           -- Identifier.  Not used internally.
//              [pRowsetScroll]   -- Rowset used to fill cache.
//              [cBindings]       -- Size of [pBindings].
//              [pBindings]       -- Default binding.
//              [cbMaxLen]        -- Max length of data fetched via [pBindings]
//              [iColumnBookmark] -- Ordinal of column containing bookmark.
//              [cbBookmark]      -- Size of bookmark
//
//  History:    05-Jun-95   KyleP       Created.
//              06-Jan-2000 KLam        Fixed bindings
//
//----------------------------------------------------------------------------

CMiniPositionableCache::CMiniPositionableCache( int Index,
                                                IRowsetScroll * pRowsetScroll,
                                                unsigned cBindings,
                                                DBBINDING * pBindings,
                                                unsigned cbMaxLen,
                                                DBORDINAL iColumnBookmark,
                                                DBBKMARK cbBookmark )
        : PMiniRowCache( Index,
                         pRowsetScroll,
                         cBindings,
                         pBindings,
                         cbMaxLen ),
          _pRowsetScroll( pRowsetScroll ),
          _fUsingBookmark( FALSE ),
          _haccBookmark( (HACCESSOR)0xFFFFFFFF ),
          _pbBookmark( (unsigned) ( sizeof(DBBKMARK) + cbBookmark + 1 )),
          _pbBookmarkSeek( (unsigned) (sizeof(DBBKMARK) + cbBookmark + 1 )),
          _hrowPrev( DB_NULL_HROW )
{
    if ( iColumnBookmark != -1 )
    {
        _fUsingBookmark = TRUE;

        //
        // Setup accessor for bookmark.
        //

        DBBINDING bindBmk;
        RtlZeroMemory(&bindBmk, sizeof bindBmk);

        bindBmk.iOrdinal = iColumnBookmark;
        bindBmk.obValue = sizeof(DBLENGTH);
        bindBmk.obLength = 0;
        bindBmk.dwPart = DBPART_VALUE | DBPART_LENGTH;
        bindBmk.cbMaxLen = _pbBookmark.Count() - sizeof(DBLENGTH);
        bindBmk.wType = DBTYPE_BYTES;

        IAccessor * pia = 0;
        SCODE sc = _pRowsetScroll->QueryInterface( IID_IAccessor, (void **)&pia );
        if (SUCCEEDED( sc ))
        {
            sc = pia->CreateAccessor( DBACCESSOR_ROWDATA,
                                      1,
                                      &bindBmk,
                                      0,
                                      &_haccBookmark,
                                      0);
            pia->Release();
        }

        if ( FAILED(sc) )
        {
            vqDebugOut(( DEB_ERROR,
                         "CMiniPositionableCache: CreateAccessor returned 0x%x\n",
                         sc ));
            THROW( CException( sc ) );
        }
    }

    //
    // Start with bookmark positioned at beginning of rowset (DBBMK_FIRST)
    //

    *(DBBKMARK *)_pbBookmark.GetPointer() = sizeof(BYTE);
    _pbBookmark[sizeof(DBBKMARK)] = DBBMK_FIRST;
    _oBookmark = 0;

    *(DBBKMARK *)_pbBookmarkSeek.GetPointer() = sizeof(BYTE);
    _pbBookmarkSeek[sizeof(DBBKMARK)] = DBBMK_FIRST;

    _xpbPrevRow.Set( new BYTE [_cbRow] );

    Next();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::~CMiniPositionableCache, public
//
//  Synopsis:   Destructor
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CMiniPositionableCache::~CMiniPositionableCache()
{
    if ( _haccBookmark != (HACCESSOR)0xFFFFFFFF )
    {
        IAccessor * pia = 0;
        _pRowsetScroll->QueryInterface( IID_IAccessor, (void **)&pia );
        Win4Assert(pia && "No Accessor!");
        pia->ReleaseAccessor( _haccBookmark, 0 );
        pia->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::Next, public
//
//  Synopsis:   Moves to next row
//
//  Returns:    Move status
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CMiniPositionableCache::Next( int iDir /* = 1 */ )
{
    //
    // If we had a row in cache,  Just advance to it.  Otherwise
    // fetch more rows from table.
    //

    _ihrow++;

    if ( _ihrow >= _chrow )
    {
        Win4Assert( iDir );

        iDir = iDir > 0 ? 1 : -1 ;

        //
        // Fetch more rows from table.
        //

        HROW * phrow = _ahrow.GetPointer();

        SCODE sc = _pRowsetScroll->GetRowsAt( 
                          0,                                           // Watch region handle
                          0,                                           // Chapter
                          *(DBBKMARK *)_pbBookmark.GetPointer(),       // cbBookmark
                          _pbBookmark.GetPointer() + sizeof(DBBKMARK), // pbBookmark
                          _oBookmark,                                  // Offset from bookmark
                          _ahrow.Count() * iDir,                       // Rows requested
                          &_chrow,                                     // Rows received
                          &phrow );                                    // HROWs stored here

        Win4Assert( DB_E_BADSTARTPOSITION != sc );

        vqDebugOut(( DEB_ITRACE, "Fetched %d from %d\n", _chrow, _Index ));

        if ( FAILED(sc) )
        {
            vqDebugOut(( DEB_ERROR, "CMiniPositionableCache: Error 0x%x from GetRowsAt\n", sc ));
            _chrow = 0;

            THROW( CException( sc ) );
        }
        else if ( 0 == _chrow && sc != DB_S_ENDOFROWSET )
        {
            return( PMiniRowCache::NotNow );
        }

        if ( _fUsingBookmark && _chrow > 0 )
        {
            //
            // Update current bookmark to last row fetched.
            //

            SCODE sc = _pRowsetScroll->GetData( _ahrow[(unsigned) (_chrow-1)],
                                                _haccBookmark,
                                                _pbBookmark.GetPointer() );

            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "Error 0x%x fetching bookmark\n", sc ));
                THROW( CException( sc ) );
            }

            _oBookmark = 1;
        }
        else
            _oBookmark += _chrow;

        _ihrow = 0;
    }

    if( IsAtEnd() )
    {
        *(DBBKMARK *)_pbBookmark.GetPointer() = sizeof(BYTE);
        _pbBookmark[sizeof(DBBKMARK)] = DBBMK_LAST;

        return CMiniPositionableCache::EndOfRows;
    }

    LoadData();

    return CMiniPositionableCache::Ok;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::LoadPrevRowData, public
//
//  Synopsis:   Load the previous row data from the current top
//              position into _hrowPrev and _xpbPrevRow
//
//  Returns:    status
//
//  History:    12-Sep-98   VikasMan       Created
//
//  Notes:      The positioning of the cursor does not change in this call.
//              _hrwoPrev is set to DB_NULL_HROW if there is no previous row
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CMiniPositionableCache::LoadPrevRowData()
{
    DBCOUNTITEM chrow = 0;

    if ( _hrowPrev != DB_NULL_HROW )
    {
        _pRowsetScroll->ReleaseRows( 1, &_hrowPrev, 0, 0, 0 );    
        _hrowPrev = DB_NULL_HROW;
    }

    HROW * phrowPrev = &_hrowPrev;

    SCODE sc = _pRowsetScroll->GetRowsAt( 
                      0,                                        // Watch region handle
                      0,                                        // Chapter
                      *(DBBKMARK *)_pbBookmark.GetPointer(),       // cbBookmark
                      _pbBookmark.GetPointer() + sizeof(DBBKMARK), // pbBookmark
                      0 - _chrow,                               // Offset from bookmark
                      1,                                        // Rows requested
                      &chrow,                                   // Rows received
                      &phrowPrev );                             // HROWs stored here

        Win4Assert( DB_E_BADSTARTPOSITION != sc );

        vqDebugOut(( DEB_ITRACE, "Fetched %d from %d\n", chrow, _Index ));

        if ( FAILED(sc) )
        {
            vqDebugOut(( DEB_ERROR, "CMiniPositionableCache: Error 0x%x from GetRowsAt\n", sc ));
            _hrowPrev = DB_NULL_HROW;

            THROW( CException( sc ) );
        }
        else if ( 0 == chrow )
        {
            return ( sc == DB_S_ENDOFROWSET ? 
                        PMiniRowCache::EndOfRows : PMiniRowCache::NotNow );
        }

        if ( 1 == chrow )
        {
            Win4Assert( _hrowPrev != DB_NULL_HROW );

            // Load Data
            SCODE sc = _pRowset->GetData( _hrowPrev, _hacc, _xpbPrevRow.GetPointer() );
        
            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "PMiniRowCache: GetData returned 0x%x\n", sc ));
                THROW( CException( E_FAIL ) );
            }
        }

    return CMiniPositionableCache::Ok;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::MovePrev, public
//
//  Synopsis:   Move to the previous row
//
//  Returns:    status
//
//  History:    12-Sep-98   VikasMan       Created
//
//  Notes:      This function uses _hrowPrev to move to previous row. Use
//              LoadPrevRowData to fill up _hrowPrev and then call this function.
//              
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CMiniPositionableCache::MovePrev()
{
    if ( _ihrow > 0 )
    {
        _ihrow--;
    }
    else if ( _hrowPrev != DB_NULL_HROW )
    {
        if ( _chrow > 0 )
        {
            _pRowsetScroll->ReleaseRows( 1, &_ahrow[(unsigned)(_chrow - 1)], 0, 0, 0 );    

            RtlMoveMemory( &_ahrow[1], &_ahrow[0], ( _chrow - 1 ) * sizeof( HROW ) );
        }
        else
        {
            SetCacheSize( _chrow = 1 );
        }

        _ahrow[0] = _hrowPrev;
        _hrowPrev = DB_NULL_HROW;

        RtlCopyMemory( _pbRow, _xpbPrevRow.GetPointer(), _cbRow );

        if ( _fUsingBookmark )
        {
            //
            // Update current bookmark to last row fetched.
            //

            SCODE sc = _pRowsetScroll->GetData( _ahrow[(unsigned)(_chrow-1)],
                                                _haccBookmark,
                                                _pbBookmark.GetPointer() );

            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "Error 0x%x fetching bookmark\n", sc ));
                THROW( CException( sc ) );
            }

            _oBookmark = 1;
        }
    }

    return CMiniPositionableCache::Ok;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::Seek, public
//
//  Synopsis:   Seek forward from current position.
//
//  Arguments:  [lRows] -- Rows to move from last seek position.
//
//  Returns:    Move status
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CMiniPositionableCache::Seek( DBROWOFFSET lRows )
{
    FlushCache();

    memcpy( _pbBookmark.GetPointer(),
            _pbBookmarkSeek.GetPointer(),
            _pbBookmark.Count() );

    _oBookmark = lRows;

    vqDebugOut(( DEB_ITRACE, "%d: Seek %d\n", Index(), lRows ));
    return Next();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::Seek, public
//
//  Synopsis:   Seek to specified bookmark.
//
//  Arguments:  [cbBookmark] -- Size of [pbBookmark]
//              [pbBookmark] -- Bookmark
//
//  Returns:    Move status
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CMiniPositionableCache::Seek( DBBKMARK cbBookmark, BYTE const * pbBookmark )
{
    Win4Assert( _fUsingBookmark ||
                (cbBookmark == 1 && (*pbBookmark == DBBMK_FIRST || *pbBookmark == DBBMK_LAST) ) );

    FlushCache();

#if CIDBG == 1
    if ( cbBookmark == 4 )
        vqDebugOut(( DEB_ITRACE, "%d: Seek 0x%x\n", Index(), *(ULONG UNALIGNED *)pbBookmark ));
#endif

    //
    // Set up bookmark.
    //

    *(DBBKMARK *)_pbBookmark.GetPointer() = cbBookmark;
    memcpy( _pbBookmark.GetPointer() + sizeof(DBBKMARK),
            pbBookmark,
            (unsigned) cbBookmark );

    *(DBBKMARK *)_pbBookmarkSeek.GetPointer() = cbBookmark;
    memcpy( _pbBookmarkSeek.GetPointer() + sizeof(DBBKMARK),
            pbBookmark,
            (unsigned) cbBookmark );

    _oBookmark = 0;

    return Next();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::Seek, public
//
//  Synopsis:   Seek to specified approximate position.
//
//  Arguments:  [ulNumerator]   -- Numerator.
//              [ulDenominator] -- Denominator.
//
//  Returns:    Move status
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CMiniPositionableCache::Seek( DBCOUNTITEM ulNumerator, DBCOUNTITEM ulDenominator )
{
    Win4Assert( _fUsingBookmark );

    FlushCache();

    vqDebugOut(( DEB_ITRACE, "%d: Seek %u/%u through.\n", Index(), ulNumerator, ulDenominator ));

    HROW * phrow = _ahrow.GetPointer();

    SCODE sc = _pRowsetScroll->GetRowsAtRatio( 0,              // Watch region handle
                                               0,              // Chapter
                                               ulNumerator,
                                               ulDenominator,
                                               _ahrow.Count(), // Rows requested
                                               &_chrow,        // Rows received
                                               &phrow );       // HROWs stored here

    vqDebugOut(( DEB_ITRACE, "Fetched %d from %d\n", _chrow, _Index ));

    if ( FAILED(sc) )
    {
        vqDebugOut(( DEB_ERROR, "CMiniPositionableCache: Error 0x%x from GetRowsAtRatio\n", sc ));
        _chrow = 0;

        THROW( CException( sc ) );
    }
    else if ( 0 == _chrow && sc != DB_S_ENDOFROWSET )
    {
        return( PMiniRowCache::NotNow );
    }

    if ( _chrow > 0 )
    {
        //
        // Update current bookmark to last row fetched.
        //

        SCODE sc = _pRowsetScroll->GetData( _ahrow[(unsigned)(_chrow-1)],
                                            _haccBookmark,
                                            _pbBookmark.GetPointer() );

        if ( FAILED(sc) )
        {
            vqDebugOut(( DEB_ERROR, "Error 0x%x fetching bookmark\n", sc ));
            THROW( CException( sc ) );
        }

        memcpy( _pbBookmarkSeek.GetPointer(),
                _pbBookmark.GetPointer(),
                _pbBookmark.Count() );

        _oBookmark = 1;
    }

    _ihrow = 0;

    if( IsAtEnd() )
    {
        return CMiniPositionableCache::EndOfRows;
    }

    LoadData();

    return CMiniPositionableCache::Ok;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMiniPositionableCache::FlushCache, public
//
//  Synopsis:   Clear the cache.
//
//  History:    12-Sep-98   VikasMan     Created
//
//----------------------------------------------------------------------------

void CMiniPositionableCache::FlushCache()
{
    if ( _hrowPrev != DB_NULL_HROW )
    {
        _pRowsetScroll->ReleaseRows( 1, &_hrowPrev, 0, 0, 0 );    
        _hrowPrev = DB_NULL_HROW;
    }
    PMiniRowCache::FlushCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\seqser.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995-2000.
//
// File:        SeqSer.cxx
//
// Contents:    Sequential cursor for serial (unsorted) results.
//
// Classes:     CSequentialSerial
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "seqser.hxx"
#include "rowman.hxx"

// Rowset object Interfaces that support Ole DB error objects
static const IID * apRowsetErrorIFs[] =
{
        &IID_IAccessor,
        &IID_IColumnsInfo,
        &IID_IConvertType,
        &IID_IRowset,
        &IID_IRowsetInfo,
        //&IID_IRowsetWatchRegion,
        //&IID_IRowsetAsynch,
        &IID_IRowsetQueryStatus,
        //&IID_IColumnsRowset,
        &IID_IConnectionPointContainer,
        &IID_IRowsetIdentity,
        //&IID_IRowsetLocate,
        //&IID_IRowsetResynch,
        //&IID_IRowsetScroll,
        //&IID_IRowsetUpdate,
        //&IID_ISupportErrorInfo
};

static const ULONG cRowsetErrorIFs  = sizeof(apRowsetErrorIFs)/sizeof(apRowsetErrorIFs[0]);

//+---------------------------------------------------------------------------
//
//  Member:     CSequentialSerial::CSequentialSerial, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  [pUnkOuter] -- outer unknown
//              [ppMyUnk] -- OUT:  on return, filled with pointer to my
//                           non-delegating IUnknown
//              [aChild] -- Child rowset(s)
//              [cChild] -- Count of rowsets in [aChild]
//              [Props]  -- Rowset properties.
//              [cCol]   -- Number of original columns.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CSequentialSerial::CSequentialSerial( IUnknown * pUnkOuter,
                                      IUnknown ** ppMyUnk,
                                      IRowset ** aChild,
                                      unsigned cChild,
                                      CMRowsetProps const & Props,
                                      unsigned cCol,
                                      CAccessorBag & aAccessors) :
          CDistributedRowset( pUnkOuter, ppMyUnk, 
                              aChild, cChild, Props, cCol,
                              aAccessors, _DBErrorObj ),  
#pragma warning(disable : 4355) // 'this' in a constructor
          _DBErrorObj(* (IUnknown *) (IRowset *)this, _mutex ),
#pragma warning(default : 4355)    // 'this' in a constructor
          _iChild( 0 )
{
    _DBErrorObj.SetInterfaceArray(cRowsetErrorIFs, apRowsetErrorIFs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSequentialSerial::~CSequentialSerial, public
//
//  Synopsis:   Virtual destructor.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CSequentialSerial::~CSequentialSerial()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CSequentialSerial::_GetNextRows, protected
//
//  Synopsis:   Sequentially fetch rows
//
//  Arguments:  [hChapter]       -- Chapter
//              [cRowsToSkip]    -- Skip this many rows before beginning.
//              [cRows]          -- Try to fetch this many rows.
//              [pcRowsObtained] -- Actually fetched this many.
//              [pphRows]        -- Store HROWs here.  Allocate memory if
//                                  [pphRows] is zero.
//
//  History:    07-Apr-95   KyleP       Created.
//
//  Notes:      Since every child cursor was given the same bindings, this
//              method can be resolved by any of the child cursors.
//
//  Notes: Need to have Ole DB error handling here because we are translating
//         errors.
//
//----------------------------------------------------------------------------

SCODE CSequentialSerial::_GetNextRows( HCHAPTER hChapter,
                                       DBROWOFFSET cRowsToSkip,
                                       DBROWCOUNT cRows,
                                       DBCOUNTITEM * pcRowsObtained,
                                       HROW * * pphRows )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    Win4Assert( 0 == hChapter && "Chapter support not yet implemented" );

    if (!pcRowsObtained || !pphRows)
    {
      vqDebugOut(( DEB_IERROR, "CSequentialSerial::GetNextRows: Invalid parameter(s).\n" ));
      return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowset);
    }
    *pcRowsObtained = 0;

    if (0 == cRows) // nothing to fetch
       return S_OK;

    TRY
    {
        //
        // Don't support backwards fetch.
        //

        if ( cRows < 0 || cRowsToSkip < 0 )
        {
            return _DBErrorObj.PostHResult(DB_E_CANTFETCHBACKWARDS, IID_IRowset);
        }

        //
        // We may have to allocate memory, if the caller didn't.
        //

        XCoMem<HROW> xmem;

        if ( 0 == *pphRows )
        {
            xmem.Set( (HROW *)CoTaskMemAlloc( (ULONG) ( cRows * sizeof(HROW) ) ) );

            *pphRows = xmem.GetPointer();
        }

        if ( 0 == *pphRows )
        {
            vqDebugOut(( DEB_ERROR, "CSequentialSerial::GetNextRows: Out of memory.\n" ));
            THROW( CException( E_OUTOFMEMORY ) );
        }

        //
        // Fetch from current child.
        //

        ULONG cTotalRowsObtained = 0;

        while ( cTotalRowsObtained < (ULONG)cRows )
        {
            if ( _iChild >= _cChild )
            {
                sc = DB_S_ENDOFROWSET;
                break;
            }

            DBCOUNTITEM cRowsObtained;

            HROW * pStart = *pphRows + cTotalRowsObtained;

            sc = _aChild[_iChild]->GetNextRows( hChapter,
                                                cRowsToSkip,
                                                cRows - cTotalRowsObtained,
                                                &cRowsObtained,
                                                &pStart );

            Win4Assert( pStart == *pphRows + cTotalRowsObtained );
            cRowsToSkip = 0;

            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR, "Error 0x%x calling IRowset::GetNextRows\n", sc ));

                //
                // If we already have some rows, then we can't 'unfetch' them, so we have
                // to mask this error.  Presumably it won't be transient and we'll get it
                // again later.
                //

                if ( cTotalRowsObtained > 0 )
                {
                    sc = DB_S_ROWLIMITEXCEEDED;
                }

                break;
            }

            //
            // Convert HROWs into distributed HROWs.
            //

            for ( unsigned i = 0; i < cRowsObtained; i++ )
            {
                (*pphRows)[cTotalRowsObtained] = _RowManager.Add( _iChild, pStart[i] );
                cTotalRowsObtained++;
            }

            //
            // May have to move to next child cursor.
            //

            if ( sc == DB_S_ENDOFROWSET )
            {
                _iChild++;
            }
            else if ( 0 == cRowsObtained )
            {
                Win4Assert( ( DB_S_ROWLIMITEXCEEDED == sc ) ||
                            ( DB_S_STOPLIMITREACHED == sc ) );
                break;
            }
        }

        *pcRowsObtained = cTotalRowsObtained;
        xmem.Acquire();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowset);

    return sc;
} //_GetNextRows

//+---------------------------------------------------------------------------
//
//  Member:     CSequentialSerial::RestartPosition, public
//
//  Synopsis:   Reset cursor for GetNextRows
//
//  Arguments:  [hChapter]  -- Chapter
//
//  History:    22 Sep 98    VikasMan     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSequentialSerial::RestartPosition( HCHAPTER hChapter )
{
    _iChild = 0;
    return CDistributedRowset::RestartPosition( hChapter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\rowcomp.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 2000.
//
// File:        RowComp.cxx
//
// Contents:    Compares two rows.
//
// Classes:     CRowComparator
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Undefined CI_INETSRV and related changes
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <compare.hxx>

#include "rowcomp.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CRowComparator::CRowComparator, public
//
//  Synopsis:   Constructor.
//
//  History:    05-Jun-95   KyleP       Created.
//              02-Feb-2000 KLam        Removed END_CONSTRUCTION
//
//----------------------------------------------------------------------------

CRowComparator::CRowComparator()
        : _aCmp(0),
          _aoColumn(0)
{}

//+---------------------------------------------------------------------------
//
//  Member:     CRowComparator::~CRowComparator, public
//
//  Synopsis:   Destructor.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CRowComparator::~CRowComparator()
{
    delete [] _aDir;
    delete [] _aCmp;
    delete [] _aoColumn;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowComparator::Init, public
//
//  Synopsis:   Initializes comparator.
//
//  Arguments:  [sort]        -- Sort specification.
//              [aBinding]    -- Binding filled in here.  Must have one
//                               element per column in sort.
//              [aColumnInfo] -- Column metadata
//              [cColumnInfo] -- Size of [aColumnInfo]
//
//  Returns:    Size of buffer needed to satisfy binding.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

unsigned CRowComparator::Init( CSort const & sort,
                               DBBINDING * aBinding,
                               DBCOLUMNINFO const * aColumnInfo,
                               DBORDINAL cColumnInfo )
{
    _cColumn = sort.Count();
    _aDir = new int [_cColumn];
    _aoColumn = new unsigned [_cColumn];
    _aCmp = new FDBCmp [_cColumn];

    BYTE * pb = (BYTE *)0 + _cColumn * sizeof(CRowComparator::SColumnStatus);

    for ( unsigned i = 0; i < _cColumn; i++ )
    {
        // NTRAID#DB-NTBUG9-84053-2000/07/31-dlee Distributed queries could be faster if ordinals were used to reference columns

        for ( DBORDINAL j = 0; j < cColumnInfo; j++ )
        {
            if ( *(CFullPropSpec *)&aColumnInfo[j].columnid == sort.Get(i).GetProperty() )
            {
                RtlZeroMemory(&aBinding[i], sizeof (DBBINDING));
                aBinding[i].dwPart = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
                aBinding[i].iOrdinal = aColumnInfo[j].iOrdinal;
                aBinding[i].wType = aColumnInfo[j].wType;
                // (sizeof (CRowComparator::SColumnStatus) * i ) + offsetof (Status)
                aBinding[i].obStatus =
                    (DBBYTEOFFSET) (ULONG_PTR)&((CRowComparator::SColumnStatus *)0)[i].Status;
                // (sizeof (CRowComparator::SColumnStatus) * i ) + offsetof (Length)
                aBinding[i].obLength =
                    (DBBYTEOFFSET) (ULONG_PTR)&((CRowComparator::SColumnStatus *)0)[i].Length;

                //
                // Invert the meaning of _aCmp[i] for columns that are descending.
                //

                Win4Assert( QUERY_SORTDESCEND == 1 && QUERY_SORTXDESCEND == 3 );

                if ( sort.Get(i).GetOrder() & 1 )
                    _aDir[i] = -1;
                else
                    _aDir[i] = 1;

                _aCmp[i] = VariantCompare.GetDBComparator( (DBTYPEENUM)aColumnInfo[j].wType );

                if ( aColumnInfo[j].wType & DBTYPE_VECTOR )
                {
                    _aoColumn[i] = (unsigned)((ULONG_PTR)AlignULONG( pb ));
                }
                else if ( aColumnInfo[j].wType & DBTYPE_ARRAY )
                {
                    _aoColumn[i] = (unsigned)((ULONG_PTR)AlignULONG( pb ));
                }
                else
                {
                    switch ( aColumnInfo[j].wType )
                    {
                    case DBTYPE_EMPTY:
                    case DBTYPE_NULL:
                    case DBTYPE_STR:
                    case DBTYPE_BSTR:
                    case DBTYPE_BYTES:
                        _aoColumn[i] = (unsigned)((ULONG_PTR)pb);
                        break;

                    case DBTYPE_I2:
                    case DBTYPE_UI2:
                    case DBTYPE_BOOL:
                        _aoColumn[i] = (unsigned)((ULONG_PTR)AlignUSHORT( pb ));
                        break;

                    case DBTYPE_I4:
                    case DBTYPE_UI4:
                    case DBTYPE_ERROR:
                        _aoColumn[i] = (unsigned)((ULONG_PTR)AlignULONG( pb ));
                        break;

                    case DBTYPE_R4:
                        _aoColumn[i] = (unsigned)((ULONG_PTR)AlignFloat( pb ));
                        break;

                    case DBTYPE_R8:
                    case DBTYPE_DATE:
                        _aoColumn[i] = (unsigned)((ULONG_PTR)AlignDouble( pb ));
                        break;

                    case DBTYPE_CY:
                    case DBTYPE_I8:
                    case DBTYPE_UI8:
                    case DBTYPE_VARIANT:
                        _aoColumn[i] = (unsigned)((ULONG_PTR)AlignLONGLONG( pb ));
                        break;

                    case DBTYPE_GUID:
                        _aoColumn[i] = (unsigned)((ULONG_PTR)AlignGUID( pb ));
                        break;

                    case DBTYPE_WSTR:
                        _aoColumn[i] = (unsigned)((ULONG_PTR)AlignWCHAR( pb ));
                        break;

                    default:
                        vqDebugOut(( DEB_WARN,
                                     "Can't determine alignment for type %d\n",
                                     aColumnInfo[j].wType ));
                        _aoColumn[i] = (unsigned)((ULONG_PTR)pb);
                        break;
                    }
                }

                aBinding[i].obValue = _aoColumn[i];
                aBinding[i].cbMaxLen = aColumnInfo[j].ulColumnSize;
                pb = (BYTE *) ULongToPtr( _aoColumn[i] ) + aColumnInfo[j].ulColumnSize;

                break;
            }
        }

        if ( j == cColumnInfo )
        {
            vqDebugOut(( DEB_ERROR, "Can't bind to sort column.\n" ));
            Win4Assert( !"Can't bind to sort column." );
            THROW( CException(E_FAIL) );
        }
    }


    vqDebugOut(( DEB_ITRACE, "CRowComparator: Allocated %d byte buffer for comparisons\n", pb ));

    return (unsigned)((ULONG_PTR)pb);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRowComparator::IsLT, public
//
//  Synopsis:   Less-than comparator
//
//  Arguments:  [pbRow1]    -- Data for row 1.
//              [cbRow1]    -- Size of [pbRow1]
//              [IndexRow1] -- Used to break ties.
//              [pbRow2]    -- Data for row 2.
//              [cbRow2]    -- Size of [pbRow2]
//              [IndexRow2] -- Used to break ties.
//
//  Returns:    TRUE of row1 < row2.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CRowComparator::IsLT( BYTE * pbRow1,
                           ULONG  cbRow1,
                           int    IndexRow1,
                           BYTE * pbRow2,
                           ULONG  cbRow2,
                           int    IndexRow2 )
{
    int iCmp = 0;

    CRowComparator::SColumnStatus * aColStatus1 = (CRowComparator::SColumnStatus *)pbRow1;
    CRowComparator::SColumnStatus * aColStatus2 = (CRowComparator::SColumnStatus *)pbRow2;

    for ( unsigned i = 0; i < _cColumn; i++ )
    {
        //
        // Verify field was successfully retrieved.
        //

        if ( FAILED(aColStatus1[i].Status) || FAILED(aColStatus2[i].Status) )
            break;

        iCmp = _aDir[i] * _aCmp[i]( pbRow1 + _aoColumn[i],
                                    (ULONG) aColStatus1[i].Length, // Length will never be 4Gb
                                    pbRow2 + _aoColumn[i],
                                    (ULONG)aColStatus2[i].Length ); // Length will never be 4Gb

        if ( 0 != iCmp )
            break;
    }

    if ( 0 == iCmp )
        return( IndexRow1 < IndexRow2 );
    else
        return( iCmp < 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\seqsort.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 1998.
//
// File:        SeqSort.cxx
//
// Contents:    Sequential cursor for sorted results.
//
// Classes:     CSequentialSerial
//
// History:     05-Jun-95       KyleP       Created
//              14-Jan-97       KrishnaN    Undefined CI_INETSRV and
//                                          related changes
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "seqsort.hxx"
#include "rowman.hxx"
#include "rowcache.hxx"

// Rowset object Interfaces that support Ole DB error objects
static const IID * apRowsetErrorIFs[] =
{
        &IID_IAccessor,
        &IID_IColumnsInfo,
        &IID_IConvertType,
        &IID_IRowset,
        &IID_IRowsetInfo,
        //&IID_IRowsetWatchRegion,
        //&IID_IRowsetAsynch,
        &IID_IRowsetQueryStatus,
        //&IID_IColumnsRowset,
        &IID_IConnectionPointContainer,
        &IID_IRowsetIdentity,
        //&IID_IRowsetLocate,
        //&IID_IRowsetResynch,
        //&IID_IRowsetScroll,
        //&IID_IRowsetUpdate,
        //&IID_ISupportErrorInfo
};

static const ULONG cRowsetErrorIFs  = sizeof(apRowsetErrorIFs)/sizeof(apRowsetErrorIFs[0]);

//+---------------------------------------------------------------------------
//
//  Member:     CSequentialSorted::CSequentialSorted, public
//
//  Synopsis:   Constructor.
//
//  Arguments:  [pUnkOuter] -- outer unknown
//              [ppMyUnk] -- OUT:  on return, filled with pointer to my
//                           non-delegating IUnknown
//              [aChild] -- Child rowset(s).
//              [cChild] -- Count of rowsets in [aChild].
//              [Props]  -- Rowset properties.
//              [cCol]   -- Number of original columns.
//              [Sort]   -- Sort specification.
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CSequentialSorted::CSequentialSorted( IUnknown * pUnkOuter,
                                      IUnknown ** ppMyUnk, 
                                      IRowset ** aChild,
                                      unsigned cChild,
                                      CMRowsetProps const & Props,
                                      unsigned cCol,
                                      CSort const & Sort,
                                      CAccessorBag & aAccessors) :
          CDistributedRowset( pUnkOuter, ppMyUnk, 
                              aChild, cChild, Props, cCol,
                              aAccessors, _DBErrorObj ),
          _apCursor( cChild ),
          _bindSort( Sort.Count() ),
#pragma warning(disable : 4355) // 'this' in a constructor
          _DBErrorObj(* (IUnknown *) (IRowset *)this, _mutex),
#pragma warning(default : 4355)    // 'this' in a constructor
          _heap( cChild )
{
    _DBErrorObj.SetInterfaceArray(cRowsetErrorIFs, apRowsetErrorIFs);
    //
    // Build binding for sort set.
    //

    DBORDINAL      cColumnInfo;
    DBCOLUMNINFO * aColumnInfo;
    WCHAR *        awchColInfo;

    SCODE sc = _GetFullColumnInfo( &cColumnInfo, &aColumnInfo, &awchColInfo );

    XCoMem<DBCOLUMNINFO> mem( aColumnInfo );
    XCoMem<WCHAR>    strings( awchColInfo );

    if ( FAILED(sc) )
    {
        vqDebugOut(( DEB_ERROR, "CSequentialSort: GetColumnInfo returned 0x%x\n", sc ));

        THROW( CException( sc ) );
    }

    _cbSort = _Comparator.Init( Sort,
                                _bindSort.GetPointer(),
                                aColumnInfo,
                                cColumnInfo );

    //
    // Create accessors
    //

    for ( unsigned i = 0; i < _cChild; i++ )
    {
        _apCursor[i] = new CMiniRowCache( i,
                                                         _aChild[i],
                                                         Sort.Count(),
                                                         _bindSort.GetPointer(),
                                                         _cbSort );
    }

    //
    // Initialize heap
    //

    _heap.Init( &_Comparator, _apCursor.GetPointer() );

    END_CONSTRUCTION( CSequentialSorted );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSequentialSorted::~CSequentialSorted, public
//
//  Synopsis:   Destructor
//
//  History:    05-Jun-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CSequentialSorted::~CSequentialSorted()
{
    //
    // Release any remaining cursors.
    //

    for ( int i = _cChild - 1; i >= 0; i-- )
    {
        delete _apCursor[i];
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSequentialSort::_GetNextRows, protected
//
//  Synopsis:   Sequentially fetch rows
//
//  Arguments:  [hChapter]       -- Chapter
//              [cRowsToSkip]    -- Skip this many rows before beginning.
//              [cRows]          -- Try to fetch this many rows.
//              [pcRowsObtained] -- Actually fetched this many.
//              [pphRows]        -- Store HROWs here.  Allocate memory if
//                                  [pphRows] is zero.
//
//  History:    07-Apr-95   KyleP       Created.
//
//  Notes: Need to have Ole DB error handling here because we are translating
//         errors.
//
//----------------------------------------------------------------------------

SCODE CSequentialSorted::_GetNextRows( HCHAPTER hChapter,
                                       DBROWOFFSET cRowsToSkip,
                                       DBROWCOUNT cRows,
                                       DBCOUNTITEM * pcRowsObtained,
                                       HROW * * pphRows )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;
    BOOL  fAllocated = FALSE;
    ULONG cTotalRowsObtained = 0;

    Win4Assert( 0 == hChapter && "Chapter support not yet implemented" );

    if (!pcRowsObtained || !pphRows)
    {
      vqDebugOut(( DEB_IERROR, "CSequentialSorted::GetNextRows: Invalid parameter(s).\n" ));
      return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowset);
    }
    *pcRowsObtained = 0;

    if (0 == cRows) // nothing to fetch
       return S_OK;

    //
    // Don't support backwards fetch.
    //
    if ( cRows < 0 || cRowsToSkip < 0 )
    {
        return _DBErrorObj.PostHResult(DB_E_CANTSCROLLBACKWARDS, IID_IRowset);
    }

    TRY
    {
        //
        // We may have to allocate memory, if the caller didn't.
        //

        if ( 0 == *pphRows )
        {
            *pphRows = (HROW *)CoTaskMemAlloc( (ULONG) ( cRows * sizeof(HROW) ) );
            fAllocated = TRUE;
        }

        if ( 0 == *pphRows )
        {
            vqDebugOut(( DEB_ERROR, "CSequentialSerial::GetNextRows: Out of memory.\n" ));
            THROW( CException( E_OUTOFMEMORY ) );
        }

        //
        // We may have reached some temporary condition such as
        // DB_S_ROWLIMITEXCEEDED on the last pass.  Iterate until we
        // have a valid heap.
        //

        _heap.Validate();

        //
        // Adjust cache size if necessary.
        //

        if ( !_heap.IsHeapEmpty() )
            _heap.AdjustCacheSize( (ULONG) cRows );

        //
        // Fetch from top of heap.
        //

        while ( cTotalRowsObtained < (ULONG)cRows )
        {
            //
            // We may be entirely out of rows.
            //

            if ( _heap.IsHeapEmpty() )
            {
                sc = DB_S_ENDOFROWSET;
                break;
            }

            if ( cRowsToSkip )
            {
                cRowsToSkip--;
            }
            else
            {
                if ( _RowManager.IsTrackingSiblings() )
                    (*pphRows)[cTotalRowsObtained] =
                        _RowManager.Add( _heap.Top()->Index(), _heap.TopHROWs() );
                else
                    (*pphRows)[cTotalRowsObtained] =
                        _RowManager.Add( _heap.Top()->Index(), _heap.Top()->GetHROW() );
    
                cTotalRowsObtained++;
            }

            //
            // Fetch the next row.
            //

            PMiniRowCache::ENext next = _heap.Next();

            if ( CMiniRowCache::NotNow == next )
            {
                sc = DB_S_ROWLIMITEXCEEDED;
                break;
            }
        }
        *pcRowsObtained = cTotalRowsObtained;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR, "Exception 0x%x calling IRowset::GetNextRows\n", sc ));

        //
        // If we already have some rows, then we can't 'unfetch' them, so we have
        // to mask this error.  Presumably it won't be transient and we'll get it
        // again later.
        //

        if ( cTotalRowsObtained > 0 )
        {
           sc = DB_S_ROWLIMITEXCEEDED;
        }
        else if ( fAllocated )
        {
            CoTaskMemFree( *pphRows );
            *pphRows = 0;
        }
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowset);

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSequentialSorted::RestartPosition, public
//
//  Synopsis:   Reset cursor for GetNextRows
//
//  Arguments:  [hChapter]  -- Chapter
//
//  History:    22 Sep 98    VikasMan     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSequentialSorted::RestartPosition( HCHAPTER hChapter )
{
    for ( unsigned i = 0; i < _cChild; i++ )
    {
        _apCursor[i]->FlushCache();
    }
    _heap.ReInit( 0 );

    SCODE sc = CDistributedRowset::RestartPosition( hChapter );

    for ( i = 0; i < _cChild; i++ )
    {
        _apCursor[i]->Next();
    }

    _heap.ReInit( _cChild );

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\distrib\scrlsort.cxx ===
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1995 - 2000
//
// File:        ScrlSort.cxx
//
// Contents:    Sorted, fully scrollable, distributed rowset.
//
// Classes:     CScrollableSorted
//
// History:     05-Jun-95       KyleP       Created
//              14-JAN-97       KrishnaN    Brought it back to conform to 1.0 spec
//
//  Notes: Some of the distributed versions of the Ole DB interfaces simply 
//         call into the regular implementations. In such cases, we'll avoid
//         posting oledb errors because the underlying call had already done
//         that.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "scrlsort.hxx"
#include "disacc.hxx"
#include "disbmk.hxx"


// Rowset object Interfaces that support Ole DB error objects
static const IID * apRowsetErrorIFs[] =
{
        &IID_IAccessor,
        &IID_IColumnsInfo,
        &IID_IConvertType,
        &IID_IRowset,
        &IID_IRowsetInfo,
        &IID_IDBAsynchStatus,
        &IID_IRowsetWatchRegion,
        &IID_IRowsetAsynch,
        &IID_IRowsetQueryStatus,
        //&IID_IColumnsRowset,
        &IID_IConnectionPointContainer,
        &IID_IRowsetIdentity,
        &IID_IRowsetLocate,
        //&IID_IRowsetResynch,
        &IID_IRowsetScroll,
        //&IID_IRowsetUpdate,
        //&IID_ISupportErrorInfo
};

static const ULONG cRowsetErrorIFs  = sizeof(apRowsetErrorIFs)/sizeof(apRowsetErrorIFs[0]);

//
// IUnknown methods.
//

//+-------------------------------------------------------------------------
//
//  Method:     CScrollableSorted::RealQueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]  -- IID of new interface
//              [ppiuk] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    10-Apr-1995     KyleP   Created
//
//  Notes:      ref count is incremented inside QueryInterface      
//
//--------------------------------------------------------------------------

SCODE  CScrollableSorted::RealQueryInterface( REFIID riid, VOID **ppiuk )
{
    SCODE sc = S_OK;

    *ppiuk = 0;

    // note -- IID_IUnknown covered in QueryInterface

    if ( riid == IID_IRowset )
    {
        *ppiuk = (void *)((IRowset *)this);
    }
    else if (IID_ISupportErrorInfo == riid)
    {
        *ppiuk = (void *) ((IUnknown *) (ISupportErrorInfo *) &_DBErrorObj);
    }
    else if ( riid == IID_IRowsetLocate )
    {
        *ppiuk = (void *)((IRowsetLocate *)this);
    }
    else if ( riid == IID_IRowsetScroll )
    {
        *ppiuk = (void *)((IRowsetScroll *)this);
    }
    else if ( riid == IID_IRowsetExactScroll )
    {
        *ppiuk = (void *)((IRowsetExactScroll *)this);
    }
    else if ( riid == IID_IColumnsInfo )
    {
        *ppiuk = (void *)((IColumnsInfo *)this);
    }
    else if ( riid == IID_IAccessor )
    {
        *ppiuk = (void *)((IAccessor *)this);
    }
    else if ( riid == IID_IRowsetIdentity )
    {
        *ppiuk = (void *)((IRowsetIdentity *)this);
    }
    else if ( riid == IID_IRowsetInfo )
    {
        *ppiuk = (void *)((IRowsetInfo *)this);
    }
    else if ( riid == IID_IRowsetAsynch )
    {
        sc = E_NOINTERFACE;
        //
        //  Support IRowsetAsynch if any of the child rowsets do.
        //
        IRowsetAsynch * pra = 0;
        for (unsigned iChild=0; iChild < _rowset._cChild; iChild++ )
        {
            sc = Get(iChild)->QueryInterface (IID_IRowsetAsynch, (void**) &pra);
            if (SUCCEEDED(sc))
            {
                pra->Release();
                *ppiuk = (void *)((IRowsetAsynch *)this);
                break;
            }
        }
    }
    else if ( riid == IID_IRowsetWatchRegion )
    {
        *ppiuk = (void *) (IRowsetWatchRegion *) this;
    }
    else if ( riid == IID_IRowsetWatchAll )
    {
        *ppiuk = (void *) (IRowsetWatchAll *) this;
    }
    else if ( riid == IID_IDBAsynchStatus )
    {
        *ppiuk = (void *) (IDBAsynchStatus *) this;
    }
    else if ( riid == IID_IConnectionPointContainer )
    {
        sc = _rowset._SetupConnectionPointContainer( this, ppiuk );
    }
    else if ( riid == IID_IRowsetQueryStatus )
    {
        *ppiuk = (void *)((IRowsetQueryStatus *)this);
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::GetData, public
//
//  Synopsis:   Fetch data for a row.
//
//  Arguments:  [hRow]      -- Handle to row
//              [hAccessor] -- Accessor to use for fetch.
//              [pData]     -- Data goes here.
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes:      This method is virtually identical to the one in its base
//              class.  The difference is that this class tracks HROWs
//              for all child cursors, to use as bookmark hints.
//
//  Notes: Need to have Ole DB error handling here because an exception could
//         happen, resulting in a local error.
//
//----------------------------------------------------------------------------

SCODE CScrollableSorted::GetData( HROW              hRow,
                                  HACCESSOR         hAccessor,
                                  void *            pData )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc;

    TRY
    {
        unsigned iChild;

        HROW * ahrow = _rowset._RowManager.GetChildAndHROWs( hRow, iChild );

        CDistributedAccessor * pAcc = (CDistributedAccessor *)_rowset._aAccessors.Convert(hAccessor);

        sc = pAcc->GetData( iChild, ahrow, pData );
    }
    CATCH( CException, e )
    {
        vqDebugOut(( DEB_ERROR, "CScrollableSorted::GetData -- caught 0x%x\n", e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowset);

    return sc;
}

//
// IRowsetLocate methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::Compare, public
//
//  Synopsis:   Compare bookmarks.
//
//  Arguments:  [hChapter]      -- Chapter.
//              [cbBM1]         -- Size of [pBM1].
//              [pBM1]          -- First bookmark.
//              [cbBM2]         -- Size of [pBM2].
//              [pBM2]          -- Second bookmark.
//              [pdwComparison] -- Result of comparison returned here.
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes:      Only equality test supported.
//
//  Notes: Need to have Ole DB error handling here because an exception could
//         happen, resulting in a local error.
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::Compare( HCHAPTER          hChapter,
                                         DBBKMARK          cbBM1,
                                         const BYTE *      pBM1,
                                         DBBKMARK          cbBM2,
                                         const BYTE *      pBM2,
                                         DBCOMPARE *       pdwComparison )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    TRY
    {
        CDistributedBookmark bmk1( cbBM1,
                                   (BYTE const *)pBM1,
                                   _rowset._cbBookmark,
                                   _rowset._cChild );
        CDistributedBookmark bmk2( cbBM2,
                                   (BYTE const *)pBM2,
                                   _rowset._cbBookmark,
                                   _rowset._cChild );

        if ( bmk1.Index() != bmk2.Index() )
            *pdwComparison = DBCOMPARE_NE;
        else
        {
            sc = Get( bmk1.Index() )->Compare( hChapter,
                                               bmk1.GetSize(),
                                               bmk1.Get(),
                                               bmk2.GetSize(),
                                               bmk2.Get(),
                                               pdwComparison );

            if ( SUCCEEDED(sc) )
            {
                if ( *pdwComparison != DBCOMPARE_EQ &&
                     *pdwComparison != DBCOMPARE_NOTCOMPARABLE )
                {
                    *pdwComparison = DBCOMPARE_NE;
                }
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        vqDebugOut(( DEB_ERROR, "CScrollableSorted::Compare returned 0x%x\n", sc ));
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowsetLocate);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::GetRowsAt, public
//
//  Synopsis:   Fetch rows from specified starting location.
//
//  Arguments:  [hChapter]       -- Chapter.
//              [cbBookmark]     -- Size of [pBookmark]
//              [pBookmark]      -- Bookmark of starting fetch position.
//              [lRowsOffset]    -- Offset from bookmark to start fetch.
//              [cRows]          -- Count of rows requested
//              [pcRowsObtained] -- Count of rows in [rrghRows] returned here.
//              [rrghRows]       -- HROWs returned here.
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes:      Backwards fetch not supported.
//
//  Notes: Need to have Ole DB error handling here because an exception could
//         happen, resulting in a local error.
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::GetRowsAt( HWATCHREGION  hRegion,
                                           HCHAPTER hChapter,
                                           DBBKMARK cbBookmark,
                                           const BYTE * pBookmark,
                                           DBROWOFFSET lRowsOffset,
                                           DBROWCOUNT cRows,
                                           DBCOUNTITEM * pcRowsObtained,
                                           HROW * rrghRows[])
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;
    BOOL  fAllocated = FALSE;
    ULONG cTotalRowsObtained = 0;

    Win4Assert( 0 == hChapter && "Chapter support not yet implemented" );

    if (0 == cRows) // nothing to fetch
       return S_OK;

    // Underlying routines are not checking for these errors, so have to
    if (0 == cbBookmark || 0 == pBookmark || 0 == pcRowsObtained || 0 == rrghRows )
    {
       vqDebugOut((DEB_IERROR, "CScrollableSorted::GetRowsAt: Invalid Argument(s)\n"));
       return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);
    }

    *pcRowsObtained = 0;

    TRY
    {
        fAllocated = SetupFetch( cRows, rrghRows );

        //
        // Seek to position.  Special cases are beginning and end of rowset.
        //

        sc = Seek( cbBookmark, pBookmark, lRowsOffset );

        if ( SUCCEEDED( sc ) )
        {
            sc = StandardFetch( cRows, pcRowsObtained, *rrghRows );

            if ( SUCCEEDED( sc ) &&
                 !_rowset._xChildNotify.IsNull() &&
                 *pcRowsObtained != 0 )
            {
                _rowset._xChildNotify->OnRowChange( *pcRowsObtained,
                                                    *rrghRows,
                                                    DBREASON_ROW_ACTIVATE,
                                                    DBEVENTPHASE_DIDEVENT,
                                                    TRUE);
            }
        }
        else if ( DB_E_BADSTARTPOSITION == sc )
        {
            // According to OLE DB 2.0 spec we should return the following
            sc = DB_S_ENDOFROWSET;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        vqDebugOut(( DEB_ERROR, "Exception 0x%x calling IRowset::GetRowsAt\n", sc ));

        //
        // If we already have some rows, then we can't 'unfetch' them, so we have
        // to mask this error.  Presumably it won't be transient and we'll get it
        // again later.
        //

        if ( *pcRowsObtained > 0 )
        {
             if ( FAILED(sc) )
                sc = DB_S_ROWLIMITEXCEEDED;
        }
        else if ( fAllocated )
            CoTaskMemFree( *rrghRows );

    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowsetLocate);

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::GetRowsByBookmark, public
//
//  Synopsis:   Fetch rows at specified location(s).
//
//  Arguments:  [hChapter]       -- Chapter.
//              [cRows]          -- Number of input bookmarks.
//              [rgcbBookmarks]  -- Count of element(s) in [ppBookmarks]
//              [ppBookmarks]    -- Bookmarks.
//              [pcRowsObtained] -- Count of rows in [rrghRows] returned here.
//              [rghRows]        -- HROWs returned here.
//              [rgRowStatus]    -- Row fetch statuses returned here
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes: Need to have Ole DB error handling here because errors are being
//         translated.
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::GetRowsByBookmark( HCHAPTER hChapter,
                                                   DBCOUNTITEM cRows,
                                                   const DBBKMARK rgcbBookmarks [],
                                                   const BYTE * ppBookmarks[],
                                                   HROW rghRows[],
                                                   DBROWSTATUS rgRowStatus[]
                                                  )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;
    ULONG cRowsObtained = 0;

    Win4Assert( 0 == hChapter && "Chapter support not yet implemented" );

    if (0 == rgcbBookmarks || 0 == ppBookmarks || 0 == rghRows)
    {
      vqDebugOut((DEB_IERROR, "CScrollableSorted::GetRowsByBookmark: Invalid Argument(s)\n"));
      return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);
    }

    SetupFetch( cRows, &rghRows );

    //
    // Note: This code could be optimized to fetch more bookmarks at
    //       once, but only by complicating the logic.  Until we find
    //       it's worth the pain, let's keep it simple!
    //

    unsigned cRowsProcessed;

    for ( cRowsProcessed = 0; cRowsProcessed < cRows; cRowsProcessed++ )
    {
        CDistributedBookmark bmk( rgcbBookmarks[cRowsProcessed],
                                  ppBookmarks[cRowsProcessed],
                                  _rowset._cbBookmark,
                                  _rowset._cChild );

        DBBKMARK cbBookmark = bmk.GetSize();
        BYTE const * pbBookmark = bmk.Get();
        sc = Get( bmk.Index() )->GetRowsByBookmark( hChapter,
                                                    1,
                                                    &cbBookmark,
                                                    (BYTE const **)&pbBookmark,
                                                    &rghRows[cRowsProcessed],
                                                    (0 == rgRowStatus) ? 0 : &rgRowStatus[cRowsProcessed]
                                                   );
        if ( FAILED(sc) )
        {
           continue;
        }
        else
        {
            rghRows[cRowsProcessed] = _rowset._RowManager.Add( bmk.Index(), rghRows[cRowsProcessed] );
            cRowsObtained++;
        }
    }

    if (cRowsProcessed == cRowsObtained)
        sc = S_OK;
    else if (cRowsObtained > 0) // and not all rows were successfully processed
        sc = DB_S_ERRORSOCCURRED;
    else    // no rows were successfully processed
        sc = DB_E_ERRORSOCCURRED;

    if ( SUCCEEDED( sc ) &&
         cRowsObtained > 0 &&
         !_rowset._xChildNotify.IsNull() )
    {
        _rowset._xChildNotify->OnRowChange( cRowsObtained,
                                            rghRows,
                                            DBREASON_ROW_ACTIVATE,
                                            DBEVENTPHASE_DIDEVENT,
                                            TRUE);
    }

    return ( S_OK == sc ?
             S_OK : _DBErrorObj.PostHResult(sc, IID_IRowsetLocate) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::Hash, public
//
//  Synopsis:   Hash bookmark
//
//  Arguments:  [hChapter]        -- Chapter.
//              [cBookmarks]      -- Number of bookmarks.
//              [rgcbBookmarks]   -- Size of bookmark(s)
//              [rgpBookmarks]    -- Bookmark(s) to hash.
//              [rgHashedValues]  -- Hash(s) returned here.
//              [rgRowStatus]    -- Row fetch statuses returned here
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes: Need to have Ole DB error handling here because errors are being
//         translated.
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::Hash( HCHAPTER hChapter,
                                      DBBKMARK cBookmarks,
                                      const DBBKMARK rgcbBookmarks[],
                                      const BYTE * rgpBookmarks[],
                                      DBHASHVALUE rgHashedValues[],
                                      DBROWSTATUS rgRowStatus[] )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;
    ULONG cSuccessfulHashes = 0;

    Win4Assert( 0 == hChapter && "Chapter support not yet implemented" );
    Win4Assert( rgHashedValues != 0 );

    // We ignore error conditions returned on calls to individual bookmarks to be
    // able to process all the bookmarks. That means invalid arguments will never
    // be detected and reported without this explicit validation.

    if (0 == rgHashedValues || (cBookmarks && (0 == rgcbBookmarks || 0 == rgpBookmarks )))
    {
       vqDebugOut((DEB_IERROR, "CScrollableSorted::Hash: Invalid Argument(s)\n"));
       return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetLocate);
    }

    TRY
    {
        ULONG partition = 0xFFFFFFFF / _rowset._cChild;

        for ( ULONG i = 0; i < cBookmarks; i++ )
        {
            //
            // Special bookmarks hash 'as-is'.
            //

            if ( rgcbBookmarks[i] == 1 )
            {
                rgHashedValues[i] = (ULONG)*rgpBookmarks[i];
                continue;
            }

            // This throws, so we need the try/catch around it
            CDistributedBookmark bmk( rgcbBookmarks[i],
                                      rgpBookmarks[i],
                                      _rowset._cbBookmark,
                                      _rowset._cChild );

            BYTE const * pBmk = bmk.Get();
            DBBKMARK cbBmk = bmk.GetSize();
            DBHASHVALUE hash;
            ULONG cErrs = 0;
            DBROWSTATUS * pErr = 0;

            sc = Get(bmk.Index())->Hash( 0, 1, &cbBmk, &pBmk, &hash,
                                         (rgRowStatus == 0) ? 0 : &rgRowStatus[i]
                                       );

            if ( FAILED(sc) )
            {
               continue;  // continue processing other bookmarks
            }

            rgHashedValues[i] = hash % partition + partition * bmk.Index();
            cSuccessfulHashes++;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        vqDebugOut(( DEB_ERROR, "CScrollableSorted::Hash caught exception 0x%x\n", sc ));
    }
    END_CATCH

    // if we see an error other than DB_E_ERRORSOCCURRED, pass it straight through
    if (FAILED(sc) && sc != DB_E_ERRORSOCCURRED)
        return _DBErrorObj.PostHResult(sc, IID_IRowsetLocate);

    if (cSuccessfulHashes == cBookmarks)
        return S_OK;

    if (cSuccessfulHashes > 0) // and not all bookmarks were successfully processed
        sc = DB_S_ERRORSOCCURRED;
    else    // no hashes were successfully processed
        sc = DB_E_ERRORSOCCURRED;

    return _DBErrorObj.PostHResult(sc, IID_IRowsetLocate);
}

//
// IRowsetScroll methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::GetApproximatePosition, public
//
//  Synopsis:   Determine approximate position of bookmark.
//
//  Arguments:  [hChapter]    -- Chapter.
//              [cbBookmark]  -- Size of [pBookmark]
//              [pBookmark]   -- Bookmark of starting fetch position.
//              [pulPosition] -- Approximate offset from beginning returned
//                               here.
//              [pulRows]     -- Approximate count of rows in table
//                               returned here.
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes: Need to have Ole DB error handling here because an exception
//         could result in a local error.
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::GetApproximatePosition( HCHAPTER hChapter,
                                                        DBBKMARK cbBookmark,
                                                        const BYTE * pBookmark,
                                                        DBCOUNTITEM * pulPosition,
                                                        DBCOUNTITEM * pulRows )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;

    Win4Assert( 0 == hChapter && "Chapter support not yet implemented" );

    if (cbBookmark !=0 && 0 == pBookmark )
    {
       vqDebugOut((DEB_IERROR,
                   "CScrollableSorted::GetApproximatePosition: Invalid Argument(s)\n"));
       return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetScroll);
    }

    TRY
    {
        CDistributedBookmark bmk( cbBookmark,
                                  (BYTE const *)pBookmark,
                                  _rowset._cbBookmark,
                                  _rowset._cChild );

        if ( 0 != pulPosition )
            *pulPosition = 0;

        if ( 0 != pulRows )
            *pulRows = 0;

        DBCOUNTITEM ulTotalRows = 0;
        DBCOUNTITEM ulValidRows = 0;
        unsigned cValidBmk = 0;

        for ( unsigned i = 0; i < _rowset._cChild; i++ )
        {
            DBCOUNTITEM ulPosition = 0;
            DBCOUNTITEM ulRows;

            BOOL fValid;
            DBBKMARK cb;

            if ( bmk.IsValid( i ) )
            {
                cValidBmk++;
                fValid = TRUE;
                cb = bmk.GetSize();
            }
            else
            {
                fValid = FALSE;
                cb = 0;
            }

            sc = Get(i)->GetApproximatePosition( hChapter,
                                                 cb,
                                                 bmk.Get(i),
                                                 (0 == pulPosition) ? 0 : &ulPosition,
                                                 &ulRows );

            if ( FAILED(sc) )
            {
                vqDebugOut(( DEB_ERROR,
                             "CScrollableSorted: GetApproximatePosition(%u) returned 0x%x\n",
                             i, sc ));
                break;
            }

            if ( 0 != pulPosition )
            {
                Win4Assert( ulPosition <= ulRows );
                *pulPosition += fValid ? ulPosition : ulRows; // If not valid bookmark,
                                                              // assume its at end
            }

            ulTotalRows += ulRows;

            if ( fValid )
                ulValidRows += ulRows;
        }

        if ( pulPosition && cValidBmk > 1 )
        {
            *pulPosition -= ( cValidBmk - 1 );
        }

        //
        // Special cases (speced in doc)
        //

        if ( cbBookmark == 1 && *(BYTE *)pBookmark == DBBMK_FIRST && 0 != pulPosition )
            *pulPosition = 1;
        else if ( cbBookmark == 1 && *(BYTE *)pBookmark == DBBMK_LAST && 0 != pulPosition )
            *pulPosition = ulTotalRows;
        //else if ( 0 != pulPosition && cValidBmk < _rowset._cChild )
        //{
        //    *pulPosition += *pulPosition * (ulTotalRows - ulValidRows) / ulValidRows;
        //}

        if ( 0 != pulRows )
            *pulRows = ulTotalRows;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        vqDebugOut(( DEB_ERROR,
        "CScrollableSorted::GetApproximatePosition caught exception 0x%x\n", sc ));
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowsetScroll);

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::GetExactPosition, public
//
//  Synopsis:   Returns the exact position of a bookmark
//
//  Arguments:  [hChapter]    -- chapter
//              [cbBookmark]  -- size of bookmark
//              [pBookmark]   -- bookmark
//              [pulPosition] -- return approx row number of bookmark
//              [pulRows]     -- returns approx # of rows in cursor or
//                               1 + approx rows if not at quiescence
//
//  Returns:    SCODE - the status of the operation.
//
//  Notes:      We don't distinguish between exact and approximate position.
//              IRowsetExactScroll is implemented only because ADO 1.5
//              started QI'ing for it.
//
//--------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::GetExactPosition(
    HCHAPTER      hChapter,
    DBBKMARK      cbBookmark,
    const BYTE *  pBookmark,
    DBCOUNTITEM * pulPosition,
    DBCOUNTITEM * pulRows) /*const*/
{
    return GetApproximatePosition( hChapter,
                                   cbBookmark,
                                   pBookmark,
                                   pulPosition,
                                   pulRows );
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::GetRowsAtRatio, public
//
//  Synopsis:   Fetch rows from approximate position.
//
//  Arguments:  [hRegion]        -- Watch region
//  Arguments:  [hChapter]       -- Chapter.
//              [ulNumerator]    -- Numerator of position.
//              [ulDenominator]  -- Denominator of position.
//              [cRows]          -- Count of rows requested
//              [pcRowsObtained] -- Count of rows in [rrghRows] returned here.
//              [rrghRows]       -- HROWs returned here.
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes: Need to have Ole DB error handling here because an exception
//         could result in a local error.
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::GetRowsAtRatio( HWATCHREGION  hRegion,
                                                HCHAPTER      hChapter,
                                                DBCOUNTITEM   ulNumerator,
                                                DBCOUNTITEM   ulDenominator,
                                                DBROWCOUNT    cRows,
                                                DBCOUNTITEM * pcRowsObtained,
                                                HROW ** rrghRows )
{
    _DBErrorObj.ClearErrorInfo();

    SCODE sc = S_OK;
    BOOL  fAllocated = FALSE;

    Win4Assert( 0 == hChapter && "Chapter support not yet implemented" );

    if (0 == pcRowsObtained || 0 == rrghRows )
    {
       vqDebugOut((DEB_IERROR, "CScrollableSorted::GetRowsAtRatio: Invalid Argument(s)"));
       return _DBErrorObj.PostHResult(E_INVALIDARG, IID_IRowsetScroll);
    }

    TRY
    {
        *pcRowsObtained = 0;
        fAllocated = SetupFetch( cRows, rrghRows );

        //
        // Seek to position.  Special cases are beginning and end of rowset.
        //

        Seek( ulNumerator, ulDenominator );

        sc = StandardFetch( cRows, pcRowsObtained, *rrghRows );

        if ( SUCCEEDED( sc ) &&
             !_rowset._xChildNotify.IsNull() &&
             *pcRowsObtained != 0 )
        {
            _rowset._xChildNotify->OnRowChange( *pcRowsObtained,
                                                *rrghRows,
                                                DBREASON_ROW_ACTIVATE,
                                                DBEVENTPHASE_DIDEVENT,
                                                TRUE);
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();

        vqDebugOut(( DEB_ERROR, "CScrollableSorted::GetRowsAtRatio: Exception 0x%x\n", sc ));

        //
        // If we already have some rows, then we can't 'unfetch' them, so we have
        // to mask this error.  Presumably it won't be transient and we'll get it
        // again later.
        //

        if ( *pcRowsObtained > 0 )
        {
            if (FAILED(sc))
                sc = DB_S_ROWLIMITEXCEEDED;
        }
        else if ( fAllocated )
        {
            CoTaskMemFree( *rrghRows );
            *rrghRows = 0;
        }
    }
    END_CATCH

    if (FAILED(sc))
        _DBErrorObj.PostHResult(sc, IID_IRowsetScroll);

    return( sc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::CScrollableSorted, public
//
//  Synopsis:   Initialize rowset.
//
//  Arguments:  [pUnkOuter] -- outer unknown
//              [ppMyUnk] -- OUT:  on return, filled with pointer to my
//                           non-delegating IUnknown
//              [aChild] -- Array of child cursors (rowsets).
//              [cChild] -- Count of elements in [aChild].
//              [Props]  -- Rowset properties.
//              [cCol]   -- Number of original columns.
//              [Sort]   -- Sort specification.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CScrollableSorted::CScrollableSorted( IUnknown * pUnkOuter,
                                      IUnknown ** ppMyUnk,
                                      IRowsetScroll ** aChild,
                                      unsigned cChild,
                                      CMRowsetProps const & Props,
                                      unsigned cCol,
                                      CSort const & Sort,
                                      CAccessorBag & aAccessors ) :
          _rowset( 0, ppMyUnk, 
                   (IRowset **)aChild, cChild, Props, cCol + 1, // Add 1 col. for bookmark
                   Sort, aAccessors ),
          _apPosCursor(cChild),
          _heap( cChild ),
#pragma warning(disable : 4355) // 'this' in a constructor
          _impIUnknown(this),
          _DBErrorObj( * ((IUnknown *) (IRowset *) this), _mutex )
#pragma warning(default : 4355)    // 'this' in a constructor
{
    unsigned iChild = 0;

    TRY
    {
        _DBErrorObj.SetInterfaceArray(cRowsetErrorIFs, apRowsetErrorIFs);
        _rowset._RowManager.TrackSiblings( cChild );

        if (pUnkOuter) 
            _pControllingUnknown = pUnkOuter;
        else
            _pControllingUnknown = (IUnknown * )&_impIUnknown;


        //
        // Create accessors
        //

        for ( ; iChild < _rowset._cChild; iChild++ )
        {
            _apPosCursor[iChild] = new CMiniPositionableCache( iChild,
                                                               Get(iChild),
                                                               Sort.Count(),
                                                               _rowset._bindSort.GetPointer(),
                                                               _rowset._cbSort,
                                                               _rowset._iColumnBookmark,
                                                               _rowset._cbBookmark );
        }

        //
        // Initialize heap
        //

        _heap.Init( &_rowset._Comparator, GetCacheArray() );

        *ppMyUnk = ((IUnknown *)&_impIUnknown);
        (*ppMyUnk)->AddRef();

    }
    CATCH( CException, e )
    {
        long lChild = iChild;

        for ( lChild--; lChild >= 0; lChild-- )
            delete _apPosCursor[lChild];

        RETHROW();
    }
    END_CATCH

    END_CONSTRUCTION( CScrollableSorted );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::~CScrollableSorted, private
//
//  Synopsis:   Destructor.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CScrollableSorted::~CScrollableSorted()
{
    unsigned ii;

    for ( ii = _rowset._cChild ; ii > 0; ii-- )
    {
        delete _apPosCursor[ii-1];
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::_GetMaxPrevRowChild, private
//
//  Synopsis:   From all the child cursors, return the index which has the
//              max. prev. row. If none of the cursor has a prev. row (they are
//              all at the top), the index returned is the total no. of cursors.
//
//  Arguments:  none
//
//  History:    10-Sep-98   VikasMan       Created.
//
//----------------------------------------------------------------------------

unsigned CScrollableSorted::_GetMaxPrevRowChild()
{
    unsigned iMaxRowChild = _rowset._cChild;
    unsigned iChild;

    BYTE * pMaxPrevData;
    BYTE * pPrevData;

    for ( iChild = 0; iChild < _rowset._cChild; iChild++ )
    {
        pMaxPrevData = _apPosCursor[iChild]->GetPrevData();

        if ( pMaxPrevData )
        {
            iMaxRowChild = iChild;
            break;
        }
    }

    for ( iChild++; iChild < _rowset._cChild; iChild++ )
    {
        pPrevData = _apPosCursor[iChild]->GetPrevData();

        if ( pPrevData )
        {
            if ( _rowset._Comparator.IsLT( 
                                     pMaxPrevData,
                                     _apPosCursor[iMaxRowChild]->DataLength(),
                                     _apPosCursor[iMaxRowChild]->Index(),
                                     pPrevData,
                                     _apPosCursor[iChild]->DataLength(),
                                     _apPosCursor[iChild]->Index() ) )
            {
                iMaxRowChild = iChild;
                pMaxPrevData = pPrevData;
            }
        }
    }
    return iMaxRowChild;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::Seek, private
//
//  Synopsis:   Position heap to specified bookmark + offset.
//
//  Arguments:  [cbBookmark] -- Size of [pbBookmark].
//              [pbBookmark] -- Bookmark.
//              [lOffset]    -- Offset from bookmark.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

SCODE CScrollableSorted::Seek( DBBKMARK cbBookmark, BYTE const * pbBookmark, DBROWOFFSET lOffset )
{
    unsigned cValid = _rowset._cChild;
    unsigned i;
    SCODE sc = S_OK;

    //
    // Special case: Beginning of table
    //

    if ( cbBookmark == 1 && *pbBookmark == DBBMK_FIRST )
    {
        //
        // Seek all cursors to beginning of table.
        //

        for ( i = 0; i < cValid; i++ )
            _apPosCursor[ i ]->Seek( cbBookmark, pbBookmark );
    }
    else if (cbBookmark == 1 && *pbBookmark ==  DBBMK_LAST)
    {
       //
       // First Seek all cursors to end of table.
       //

       for ( i = 0; i < cValid; i++ )
           _apPosCursor[ i ]->Seek( cbBookmark, pbBookmark );

       for ( i = 0; i < cValid; i++ )
       {
           if ( _apPosCursor[i]->IsAtEnd() )
           {
               _apPosCursor[i]->Seek(1);    // pushes it beyond the end
   
               //
               // Move unseekable cursor to end of array.
               //
   
               cValid--;
               SwapCursor(i, cValid);
               i--;
           }
       }
       // Find the cursor with the maximum value
       unsigned iCurWithMaxVal = 0;
       for (i = 1; i < cValid; i++)
       {
          if ( _rowset._Comparator.IsLT( _apPosCursor[iCurWithMaxVal]-> GetData(),
                                   _apPosCursor[iCurWithMaxVal]->DataLength(),
                                   _apPosCursor[iCurWithMaxVal]->Index(),
                                   _apPosCursor[i]->GetData(),
                                   _apPosCursor[i]->DataLength(),
                                   _apPosCursor[i]->Index() )
             )
             iCurWithMaxVal = i;
       }

       // Now set all cursors except _apPosCursor[iCurWithMaxVal] to end of table
       for (i = 0; i < cValid; i++)
           if (i != iCurWithMaxVal)
               _apPosCursor[i]->Seek(1);    // pushes it beyond the end

    }
    else
    {
        CDistributedBookmark bmk( cbBookmark,
                                  pbBookmark,
                                  _rowset._cbBookmark,
                                  _rowset._cChild );

        //
        // Seek target cursor.  We have to do this one first.
        //

        for ( unsigned iTarget = 0; iTarget < _rowset._cChild; iTarget++ )
        {
            if ( _apPosCursor[iTarget]->Index() == (int)bmk.Index() )
            {
                _apPosCursor[ iTarget ]->Seek( bmk.GetSize(), bmk.Get() );
                break;
            }
        }

        //
        // Seek child cursor(s), other than target.
        //

        for ( i = 0; i < cValid; i++ )
        {
            //
            // Ignore target cursor
            //

            if ( i == iTarget )
                continue;

            //
            // Seek to 'hint' position.
            //

            _apPosCursor[i]->FlushCache();
            _apPosCursor[i]->SetCacheSize( 1 );

            PMiniRowCache::ENext next;

            if ( bmk.IsValid( _apPosCursor[i]->Index() ) )
                next = _apPosCursor[i]->Seek( bmk.GetSize(), bmk.Get( _apPosCursor[i]->Index() ) );
            else
            {
                BYTE bStart = DBBMK_FIRST;
                next = _apPosCursor[i]->Seek( sizeof(bStart), &bStart );
            }

            //
            // And adjust so that the cursor is positioned just after the target cursor.
            //

            if ( next != PMiniRowCache::Ok ||
                AdjustPosition( i, iTarget ) != PMiniRowCache::Ok )

            {
                BYTE bEnd = DBBMK_LAST;
                _apPosCursor[i]->Seek( sizeof(bEnd), &bEnd );
                _apPosCursor[i]->Seek(1);    // pushes it beyond the end

                //
                // Move unseekable cursor to end of array.
                //

                cValid--;
                SwapCursor(i, cValid);
                if ( cValid == iTarget )
                {
                    iTarget = i;
                }

                i--;
            }
        }
    }

    for ( i = 0; i<cValid; i++ )
    {
        if ( _apPosCursor[i]->IsAtEnd() )
        {
            _apPosCursor[i]->Seek(1);    // pushes it beyond the end

            //
            // Move unseekable cursor to end of array.
            //

            cValid--;
            SwapCursor(i, cValid);
            i--;
        }
    }

    _heap.ReInit( cValid );

    if ( lOffset < 0 )
    {
        cValid = _rowset._cChild;

        // Load Previous rows from all valid
        for ( i = 0; i < cValid; i++ )
        {
            _apPosCursor[i]->LoadPrevRowData();
        }

        unsigned iMaxRowChild;
        BOOL fReInit = FALSE;
        for( ;; )
        {
            // Find out which rowset has the max. prev. row
            iMaxRowChild = _GetMaxPrevRowChild();

            if ( iMaxRowChild >= _rowset._cChild )
            {
                break;
                // no previous row
            }

            fReInit = TRUE;

            // Move the rowset with the max. prev. row back
            _apPosCursor[iMaxRowChild]->MovePrev();

            if ( 0 == ++lOffset )
            {
                break;
            }

            // Reload prev. row for the rowset which we moved back
            _apPosCursor[iMaxRowChild]->LoadPrevRowData();
        }

        if ( fReInit)
        {
            for ( i = 0; i<cValid; i++ )
            {
                if ( _apPosCursor[i]->IsAtEnd() )
                {
                    _apPosCursor[i]->Seek(1);    // pushes it beyond the end
        
                    //
                    // Move unseekable cursor to end of array.
                    //
        
                    cValid--;
                    SwapCursor(i, cValid);
                    i--;
                }
            }
            _heap.ReInit( cValid );
        }

        if ( lOffset < 0 )
        {
            // NTRAID#DB-NTBUG9-84055-2000/07/31-dlee Failed distribued query row fetches don't restore previous seek position
            // Do we need to reset the position of rowset back to
            // where it was before call to Seek ?

            sc = DB_E_BADSTARTPOSITION;
        }
    }
    else
    {
        for ( ; lOffset > 0; lOffset-- )
        {
            //
            // Release top HROW.
            //
    
            HROW hrow = _heap.Top()->GetHROW();
    
            SCODE sc2 = Get( _heap.Top()->Index() )->ReleaseRows( 1, &hrow, 0, 0, 0 );
    
            Win4Assert( SUCCEEDED(sc2) );
    
            PMiniRowCache::ENext next = _heap.Next();
    
            Win4Assert( PMiniRowCache::NotNow != next );
    
            if ( PMiniRowCache::EndOfRows == next )
                break;
        }
    }
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::AdjustPosition, private
//
//  Synopsis:   Adjust position of iChild-th cursor to just after the
//              iTarget-th cursor.
//
//  Arguments:  [iChild]  -- Index of child in _apPosCursor.
//              [iTarget] -- Index of target in _apPosCursor.
//
//  Returns:    Seek result.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

PMiniRowCache::ENext CScrollableSorted::AdjustPosition( unsigned iChild, int iTarget )
{
    vqDebugOut(( DEB_ITRACE, "Child: %d data = 0x%x, size = %u\n",
                 _apPosCursor[iChild]->Index(),
                 _apPosCursor[iChild]-> GetData(),
                 _apPosCursor[iChild]->DataLength() ));

    vqDebugOut(( DEB_ITRACE, "Target: %d data = 0x%x, size = %u\n",
                 _apPosCursor[iTarget]->Index(),
                 _apPosCursor[iTarget]-> GetData(),
                 _apPosCursor[iTarget]->DataLength() ));

    PMiniRowCache::ENext next;  // Used to report error states.
    int iJump;                  // Seek offset (positive or negative) from starting point.
    int iNextInc;               // Next seek increment.
    int iDirection;             // Direction of seek from initial position to target.

    if ( _rowset._Comparator.IsLT( _apPosCursor[iTarget]-> GetData(),
                                   _apPosCursor[iTarget]->DataLength(),
                                   _apPosCursor[iTarget]->Index(),
                                   _apPosCursor[iChild]->GetData(),
                                   _apPosCursor[iChild]->DataLength(),
                                   _apPosCursor[iChild]->Index() ) )
    {
        next = InitialSeek( iChild, iTarget, -1, iJump, iNextInc, iDirection );

        //
        // Running into end (actually beginning) here is ok.
        //

        if ( next == PMiniRowCache::EndOfRows )
            return PMiniRowCache::Ok;
    }
    else
        next = InitialSeek( iChild, iTarget, 1, iJump, iNextInc, iDirection );

    if ( next != PMiniRowCache::Ok )
        return next;

    //
    // At this point, iChild is at least 1 row < iTarget (or 1 row > iTarget).
    //

    vqDebugOut(( DEB_ITRACE, "Final positioning:\n" ));

    while ( iNextInc > 0 )
    {
        iJump += (iNextInc * iDirection);

        vqDebugOut(( DEB_ITRACE, "Backward %d\n", -iJump ));

        PMiniRowCache::ENext next = _apPosCursor[iChild]->Seek( iJump );

        iNextInc /= 2;

        if ( _rowset._Comparator.IsLT( _apPosCursor[iTarget]-> GetData(),
                                       _apPosCursor[iTarget]->DataLength(),
                                       _apPosCursor[iTarget]->Index(),
                                       _apPosCursor[iChild]->GetData(),
                                       _apPosCursor[iChild]->DataLength(),
                                       _apPosCursor[iChild]->Index() ) )
            iDirection = -1;
        else
            iDirection = 1;
    }

    //
    // Either the row we are on is correct, or off by one.
    //

    if ( _rowset._Comparator.IsLT( _apPosCursor[iChild]-> GetData(),
                                   _apPosCursor[iChild]->DataLength(),
                                   _apPosCursor[iChild]->Index(),
                                   _apPosCursor[iTarget]->GetData(),
                                   _apPosCursor[iTarget]->DataLength(),
                                   _apPosCursor[iTarget]->Index() ) )
        return _apPosCursor[iChild]->Seek( iJump + 1 );
    else
        return PMiniRowCache::Ok;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::InitialSeek, private
//
//  Synopsis:   Worker routine for AdjustPosition.  Binary searches until
//              iChild is at least one row on the opposite side of iTarget
//              from where it started.
//
//  Arguments:  [iChild]           -- Index of child in _apPosCursor.
//              [iTarget]          -- Index of target in _apPosCursor.
//              [InitialDirection] -- Direction to start moving.
//              [iJump]            -- Offset from starting point returned
//                                    here.
//              [iNextInc]         -- Size of last jump returned here.
//              [iDirection]       -- Direction of last jump returned here.
//
//  Returns:    Seek result.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------


PMiniRowCache::ENext CScrollableSorted::InitialSeek( unsigned iChild,
                                                     int iTarget,
                                                     int InitialDirection,
                                                     int & iJump,
                                                     int & iNextInc,
                                                     int & iDirection )
{
    //
    // If the child starts out > target, then go backward until we pass
    // the target, and then forward until *just* after target, otherwise
    // do the opposite.  The goal is to go a known distance past the target
    // so we can seek back towards it logarithmically.
    //

    iJump = 1 * InitialDirection;
    iNextInc = 1 * InitialDirection;

    int LTa;
    int LTb;

    if ( InitialDirection == 1 )
    {
        LTa = iChild;
        LTb = iTarget;
    }
    else
    {
        LTa = iTarget;
        LTb = iChild;
    }

    vqDebugOut(( DEB_ITRACE, "Initial positioning:\n" ));

    PMiniRowCache::ENext next = PMiniRowCache::EndOfRows;

    while ( iNextInc != 0 )
    {
        do
        {
            vqDebugOut(( DEB_ITRACE, "%s %u\n", iJump < 0 ? "Backward" : "Forward",
                                                iJump < 0 ? -iJump : iJump ));


            next = _apPosCursor[iChild]->Seek( iJump );

            if ( 0 == iNextInc )
            {
                Win4Assert( next != PMiniRowCache::EndOfRows );
                next = PMiniRowCache::EndOfRows;
                break;
            }

            switch ( next )
            {
            case PMiniRowCache::Ok:
                iNextInc *= 2;
                break;

            case PMiniRowCache::EndOfRows:
                iJump -= iNextInc;
                iNextInc /= 2;
                iJump += iNextInc;
                break;

            default:
                return next;
            }
        } while ( next == PMiniRowCache::EndOfRows );

        Win4Assert( iJump * InitialDirection >= 0 );
        //if ( iJump * InitialDirection > 0 &&

        if ( iJump != 0 &&
             _rowset._Comparator.IsLT( _apPosCursor[LTa]-> GetData(),
                                   _apPosCursor[LTa]->DataLength(),
                                   _apPosCursor[LTa]->Index(),
                                   _apPosCursor[LTb]->GetData(),
                                   _apPosCursor[LTb]->DataLength(),
                                   _apPosCursor[LTb]->Index() ) )
            iJump += iNextInc;
        else
            break;
    }

    iNextInc = ((iJump*InitialDirection) / 2) + 1;
    iDirection = -InitialDirection;

    return next;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::Seek, private
//
//  Synopsis:   Position heap to approximate position.
//
//  Arguments:  [ulNumerator]   -- Numerator.
//              [ulDenominator] -- Denominator.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

void CScrollableSorted::Seek( DBCOUNTITEM ulNumerator, DBCOUNTITEM ulDenominator )
{
    unsigned cValid = _rowset._cChild;

    //
    // Special case: Beginning of table
    //

    if ( 0 == ulNumerator )
    {
        //
        // Seek all cursors to beginning of table.
        //

        BYTE bmkStart = DBBMK_FIRST;

        for ( unsigned i = 0; i < _rowset._cChild; i++ )
            _apPosCursor[ i ]->Seek( sizeof(bmkStart), &bmkStart );

        _heap.ReInit( cValid );
    }

    //
    // Special case: End of table
    //

    else if ( ulNumerator == ulDenominator )
    {
        //
        // Seek all cursors to end of table.
        //

        BYTE bmkEnd = DBBMK_LAST;

        for ( unsigned i = 0; i < _rowset._cChild; i++ )
            _apPosCursor[ i ]->Seek( sizeof(bmkEnd), &bmkEnd );

        _heap.ReInit( cValid );
    
    }

    //
    // Normal case: Middle of table
    //

    else
    {
        //
        // Seek all cursors to ratio.
        //

        // Get the total # of rows

        DBCOUNTITEM ulRows = 0;
        SCODE sc = GetApproximatePosition( NULL,
                                           0,
                                           NULL,
                                           NULL,
                                           &ulRows );
        if ( SUCCEEDED (sc ) && ulRows > 0 )
        {
            DBROWOFFSET lSeekPos = (( ulNumerator * ulRows ) / ulDenominator );

            BYTE bmk;

            if ( (lSeekPos * 100 / ulRows) > 50 )
            {
                // seek from bottom
                bmk = DBBMK_LAST;
                lSeekPos = lSeekPos - (LONG) ulRows + 1;
            }
            else
            {
                // seek from top
                bmk = DBBMK_FIRST;
            }

            sc = Seek( sizeof(bmk), &bmk, lSeekPos );
        }


#if 0
        for ( unsigned i = 0; i < _rowset._cChild; i++ )
        {
            _apPosCursor[ i ]->FlushCache();
            _apPosCursor[ i ]->SetCacheSize( 1 );
            _apPosCursor[ i ]->Seek( ulNumerator, ulDenominator );
        }

        //
        // Heapify, then pick the cursor ulNumerator / ulDenominator from
        // top of the heap.
        //

        _heap.ReInit( _rowset._cChild );

        _heap.NthToTop( _rowset._cChild * ulNumerator / ulDenominator );

        unsigned iTarget = 0;

        //
        // Adjust position of all other cursors to follow target.
        //

        for ( i = 0; i < cValid; i++ )
        {
            //
            // Ignore target cursor
            //

            if ( i == iTarget )
                continue;

            if ( AdjustPosition( i, iTarget ) != PMiniRowCache::Ok )
            {
                //
                // Move unseekable cursor to end of array.
                //

                cValid--;
                SwapCursor(i, cValid);
                i--;
            }
        }
#endif
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::SetupFetch, private
//
//  Synopsis:   Common operations before seek in Get* routines.
//
//  Arguments:  [cRows]    -- Number of rows requested.
//              [rrghRows] -- Rows returned here.  May have to allocate.
//
//  Returns:    TRUE if *rrghRows was allocated.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CScrollableSorted::SetupFetch( DBROWCOUNT cRows, HROW * rrghRows[] )
{
    //
    // We may have reached some temporary condition such as
    // DB_S_ROWLIMITEXCEEDED on the last pass.  Iterate until we
    // have a valid heap.
    //

    PMiniRowCache::ENext next = _heap.Validate();

    if ( next == PMiniRowCache::NotNow )
    {
        THROW( CException( DB_E_ROWLIMITEXCEEDED ) );
    }

    //
    // We may have to allocate memory, if the caller didn't.
    //

    BOOL fAllocated = FALSE;

    if ( 0 == *rrghRows )
    {
        *rrghRows = (HROW *)CoTaskMemAlloc( (ULONG) ( abs(((LONG) cRows)) * sizeof(HROW) ) );
        fAllocated = TRUE;
    }

    if ( 0 == *rrghRows )
    {
        vqDebugOut(( DEB_ERROR, "CScrollableSorted::SetupFetch: Out of memory.\n" ));
        THROW( CException( E_OUTOFMEMORY ) );
    }

    return fAllocated;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::SetupFetch, private
//
//  Synopsis:   Common operations before seek in Get* routines.
//
//  Arguments:  [cRows]          -- Number of rows requested.
//              [pcRowsObtained] -- Count actually fetched.
//              [rghRows]        -- Rows returned here.  Already allocated
//                                  if needed.
//
//  Returns:    Status code.
//
//  History:    03-Apr-95   KyleP       Created.
//
//----------------------------------------------------------------------------

SCODE CScrollableSorted::StandardFetch( DBROWCOUNT    cRows,
                                        DBCOUNTITEM * pcRowsObtained,
                                        HROW    rghRows[] )
{
    SCODE sc = S_OK;

    int iDir = 1;

    if ( cRows < 0 )
    {
        cRows = -cRows;
        iDir = -1;
    }

    unsigned ucRows = (unsigned) cRows;

    //
    // Adjust cache size if necessary.
    //

    _heap.AdjustCacheSize( ucRows );

    //
    // Fetch from top of heap.
    //

    while ( *pcRowsObtained < ucRows )
    {
        //
        // We may be entirely out of rows.
        //

        if ( _heap.IsHeapEmpty() )
        {
            sc = DB_S_ENDOFROWSET;
            break;
        }

        (rghRows)[*pcRowsObtained] =
            _rowset._RowManager.Add( _heap.Top()->Index(),
                                     _heap.TopHROWs() );

        (*pcRowsObtained)++;

        //
        // Fetch the next row.
        //

        PMiniRowCache::ENext next = _heap.Next( iDir );

        if ( CMiniRowCache::NotNow == next )
        {
            sc = DB_S_ROWLIMITEXCEEDED;
            break;
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::RatioFinished, public
//
//  Synopsis:   Ratio finished for asynchronously populated rowsets.
//
//  Arguments:  [pulDenominator] -- Denominator returned here.
//              [pulNumerator]   -- Numerator returned here.
//              [pcRows]         -- Count of rows returned here
//              [pfNewRows]      -- TRUE if rows added since last call.
//
//  History:    03-Apr-95   KyleP       Created.
//
//  Notes: Need to have Ole DB error handling here because an exception
//         could result in a local error.
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::RatioFinished( DBCOUNTITEM * pulDenominator,
                                               DBCOUNTITEM * pulNumerator,
                                               DBCOUNTITEM * pcRows,
                                               BOOL * pfNewRows )
{
    _DBErrorObj.ClearErrorInfo();

    IRowsetAsynch * pra = 0;

    SCODE scResult = S_OK;

    *pulDenominator = 0;
    *pulNumerator = 0;
    *pcRows = 0;
    *pfNewRows = FALSE;

    for ( unsigned iChild = 0; iChild < _rowset._cChild; iChild++ )
    {
        DBCOUNTITEM ulDenom;
        DBCOUNTITEM ulNum;
        DBCOUNTITEM cRows;
        BOOL fNew;

        SCODE sc = Get(iChild)->QueryInterface( IID_IRowsetAsynch, (void **) &pra );
        if ( SUCCEEDED(sc) )
        {
            sc = pra->RatioFinished( &ulDenom, &ulNum, &cRows, &fNew );
            pra->Release();
        }

        if ( FAILED(sc) && E_NOTIMPL != sc && E_NOINTERFACE != sc )
        {
            vqDebugOut(( DEB_ERROR,
                         "IRowsetAsynch::RatioFinished(child %d) returned 0x%x\n",
                         iChild, sc ));
            scResult = sc;
            break;
        }

        if ( SUCCEEDED(sc) )
        {
            Win4Assert( *pulDenominator + ulDenom > *pulDenominator );

            *pulDenominator += ulDenom;
            *pulNumerator += ulNum;
            *pcRows += cRows;
            *pfNewRows = *pfNewRows || fNew;
        }
    }

    if ( 0 == *pulDenominator )
        scResult = E_NOTIMPL;

    if (FAILED(scResult))
        _DBErrorObj.PostHResult(scResult, IID_IRowsetAsynch);

    return( scResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::Stop, public
//
//  Synopsis:   Stop population of asynchronously populated rowsets.
//
//  Arguments:  - None -
//
//  History:    16 Jun 95   Alanw       Created.
//
//  Notes: Need to have Ole DB error handling here because errors are
//         being translated.
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::Stop( )
{
    _DBErrorObj.ClearErrorInfo();

    IRowsetAsynch * pra = 0;

    SCODE scResult = S_OK;

    for ( unsigned iChild = 0; iChild < _rowset._cChild; iChild++ )
    {
        SCODE sc = Get(iChild)->QueryInterface( IID_IRowsetAsynch,
                                                    (void **) &pra );
        if ( SUCCEEDED(sc) )
        {
            sc = pra->Stop( );
            pra->Release();
        }

        if ( FAILED(sc) && (S_OK == scResult ||
                            E_NOTIMPL != sc ||
                            E_NOINTERFACE != sc))
        {
            vqDebugOut(( DEB_ERROR,
                         "IRowsetAsynch::Stop (child %d) returned 0x%x\n",
                         iChild, sc ));
            scResult = sc;
        }
    }

    if (FAILED(scResult))
        _DBErrorObj.PostHResult(scResult, IID_IRowsetAsynch);

    return( scResult );
}

//
//  IDbAsynchStatus methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::Abort, public
//
//  Synopsis:   Cancels an asynchronously executing operation.
//
//  Arguments:  [hChapter]    -- chapter which should restart
//              [ulOperation] -- operation for which status is being requested
//
//  Returns:    SCODE error code
//
//  History:    03 Sep 1998    VikasMan    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::Abort(
    HCHAPTER            hChapter,
    ULONG               ulOperation ) 
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    XInterface<IDBAsynchStatus> xIDBAsynchStatus;

    for ( unsigned iChild = 0; iChild < _rowset._cChild; iChild++ )
    {
        SCODE sc = Get(iChild)->QueryInterface( IID_IDBAsynchStatus,
                                                xIDBAsynchStatus.GetQIPointer() );

        if ( SUCCEEDED( sc ) )
        {
            sc = xIDBAsynchStatus->Abort( hChapter, ulOperation );
            if ( S_OK == scResult )
            {
                scResult = sc;
            }
        }
        xIDBAsynchStatus.Free();
    }

    return scResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::GetStatus, public
//
//  Synopsis:   Returns the status of an asynchronously executing operation.
//
//  Arguments:  [hChapter]    -- chapter which should restart
//              [ulOperation] -- operation for which status is being requested
//
//  Returns:    SCODE error code        
//
//  History:    03 Sep 1998    VikasMan    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CScrollableSorted::GetStatus(
    HCHAPTER          hChapter,
    DBASYNCHOP             ulOperation,
    DBCOUNTITEM *           pulProgress,
    DBCOUNTITEM *           pulProgressMax,
    DBASYNCHPHASE *           pulAsynchPhase,
    LPOLESTR *        ppwszStatusText ) 
{
    _DBErrorObj.ClearErrorInfo();

    SCODE scResult = S_OK;
    XInterface<IDBAsynchStatus> xIDBAsynchStatus;

    if ( pulProgress )
        *pulProgress = 0;
    if ( pulProgressMax )
        *pulProgressMax = 0;
    if ( pulAsynchPhase )
        *pulAsynchPhase = DBASYNCHPHASE_COMPLETE;
    if ( ppwszStatusText )
        *ppwszStatusText = 0;

    XCoMem<OLECHAR> xStatusText;

    double dRatio = 0;

    for ( unsigned iChild = 0; iChild < _rowset._cChild; iChild++ )
    {
        SCODE sc = Get(iChild)->QueryInterface( IID_IDBAsynchStatus,
                                                xIDBAsynchStatus.GetQIPointer() );

        if ( SUCCEEDED( sc ) )
        {
            DBCOUNTITEM ulProgress, ulProgressMax; 
            DBASYNCHPHASE ulAsynchPhase;

            scResult = xIDBAsynchStatus->GetStatus ( hChapter, 
                                                     ulOperation,
                                                     &ulProgress,
                                                     &ulProgressMax,
                                                     &ulAsynchPhase,
                                                     0 == iChild ?
                                                     ppwszStatusText : 0 );
            if ( S_OK != scResult )
            {
                return scResult;
            }

            if ( 0 == iChild && ppwszStatusText )
            {
                xStatusText.Set( *ppwszStatusText );
            }

            if ( ulProgressMax )
            {
                dRatio += ( (double)ulProgress / (double)ulProgressMax );
            }

            if ( pulAsynchPhase && *pulAsynchPhase != DBASYNCHPHASE_POPULATION )
                *pulAsynchPhase = ulAsynchPhase;

        }
        xIDBAsynchStatus.Free();
    }

    DWORD dwNum = 0;
    DWORD dwDen = 0;

    if ( dRatio )
    {
        Win4Assert( _rowset._cChild );

        dRatio /= _rowset._cChild;
        dwDen = 1;

        while ( dRatio < 1.0 )
        {
            dRatio *= 10;
            dwDen *= 10;
        }
        dwNum = (DWORD)dRatio;
    }

    if ( pulProgress )
        *pulProgress = dwNum;

    if ( pulProgressMax )
        *pulProgressMax = dwDen;


    if ( SUCCEEDED( scResult ) )
    {
        // Let memory pass thru to the client
        xStatusText.Acquire();
    }

    return scResult;
}

//
// IRowsetWatchRegion methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CScrollableSorted::Refresh, public
//
//  Synopsis:   Implementation of IRowsetWatchRegion::Refresh. Calls refresh on
//              all the child rowsets
//
//  Arguments:  pChangesObtained
//              prgChanges
//
//  Returns:    Always returns DB_S_TOOMAYCHANGES
//
//  History:    03 Sep 1998    VikasMan    Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CScrollableSorted::Refresh(
        DBCOUNTITEM* pChangesObtained,
        DBROWWATCHCHANGE** prgChanges )
{
    _DBErrorObj.ClearErrorInfo();

    for ( unsigned iChild = 0; iChild < _rowset._cChild; iChild++ )
    {
        if ( _rowset._xArrChildRowsetWatchRegion[iChild].GetPointer() )
        {
            _rowset._xArrChildRowsetWatchRegion[iChild]->Refresh( pChangesObtained, prgChanges );
        }
    }

    *pChangesObtained = 0;

    return DB_S_TOOMANYCHANGES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\expander\qkrep.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:   QKREP.CXX
//
//  Contents:   Query Key Repository
//
//  Classes:    CQueryKeyRepository
//
//  History:    04-Jun-91    t-WadeR    Created.
//              23-Sep-91    BartosM    Rewrote to use phrase expr.
//              31-Jan-93    KyleP      Use restrictions, not expressions
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qparse.hxx>
#include <irest.hxx>

#include "qkrep.hxx"

#include <drep.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::CQueryKeyRepository
//
//  Synopsis:   Creates Key repository
//
//  History:    31-May-91   t-WadeR     Created
//              23-Sep-91   BartoszM    Rewrote to use phrase expr.
//
//----------------------------------------------------------------------------

CQueryKeyRepository::CQueryKeyRepository ( ULONG fuzzy )
        : _occLast(OCC_INVALID),
          _pOrRst(0),
          _pCurAltPhrase(0),
          _cInitialNoiseWords(0),
          _fNoiseWordsOnly(FALSE),
          _fHasSynonym( FALSE )
{
    if ( fuzzy == GENERATE_METHOD_PREFIX )
        _isRange = TRUE;
    else
        _isRange = FALSE;

    _pPhrase = new CPhraseRestriction( INIT_PHRASE_WORDS );
    Win4Assert( _pPhrase->IsValid() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::~CQueryKeyRepository
//
//  Synopsis:   Destroys
//
//  History:    31-May-91   t-WadeR     Created
//              23-Sep-91   BartoszM    Rewrote to use phrase expr.
//
//----------------------------------------------------------------------------

CQueryKeyRepository::~CQueryKeyRepository()
{
    delete _pPhrase;
    delete _pOrRst;
    delete _pCurAltPhrase;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::AcqXpr
//
//  Synopsis:   Acquire Phrase(s)
//
//  History:    07-Feb-92   BartoszM    Created
//              24-Jan-97   KyleP       Handle null phrase (from bad alt words)
//
//----------------------------------------------------------------------------

CRestriction * CQueryKeyRepository::AcqRst()
{
    CNodeRestriction *pNodeRst;

    if ( _pOrRst )
    {
        Win4Assert( _pPhrase == 0 );
        pNodeRst = _pOrRst;
    }
    else
        pNodeRst = _pPhrase;

    //
    // pNodeRst may be null, if alternate phrasing didn't work out.
    //

    if ( 0 == pNodeRst )
        return 0;

    switch( pNodeRst->Count() )
    {
    case 0:
        return( 0 );
        break;

    case 1:
        return( pNodeRst->RemoveChild(0) );
        break;

    default:
    {
        CRestriction * tmp = pNodeRst;
        _pOrRst = 0;
        _pPhrase = 0;
        return( tmp );
        break;
    }
    }
} //AcqRst

//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::PutKey
//
//  Synopsis:   Puts a key into the key list and occurrence list
//
//  Arguments:  [cNoiseWordsSkipped] -- count of noise words that have been skipped
//
//  History:    31-May-91   t-WadeR     Created
//              23-Sep-91   BartoszM    Rewrote to use phrase expr.
//              29-Nov-94   SitaramR    Rewrote to take Start/EndAltPhrase into account
//
//----------------------------------------------------------------------------

void CQueryKeyRepository::PutKey ( ULONG cNoiseWordsSkipped )
{
    // check if there is a set of alt phrases with noise words only
    if ( _fNoiseWordsOnly )
        return;

    ciDebugOut (( DEB_ITRACE, "QueryKeyRepository::PutKey \"%.*ws\", pid = %d\n",
                  _key.StrLen(), _key.GetStr(), _key.Pid() ));

    if ( _pCurAltPhrase )   // if, we are processing an alternate phrase
        AppendKey( _pCurAltPhrase, cNoiseWordsSkipped );
    else
    {
        if ( _pOrRst )
        {
            Win4Assert( _pOrRst->Count() );
            Win4Assert( _pPhrase == 0 );

            for ( unsigned i=0; i<_pOrRst->Count(); i++)
            {
                CRestriction *pRst = _pOrRst->GetChild(i);
                Win4Assert( pRst->Type() == RTPhrase );
                AppendKey( (CPhraseRestriction *) pRst, cNoiseWordsSkipped );
            }
        }
        else
            AppendKey( _pPhrase, cNoiseWordsSkipped );
    }

    _occLast = _occ;
} //PutKey

//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::AppendKey
//
//  Synopsis:   Appends a key to end of phraseRst
//
//  Arguments:  [pPhraseRst]         -- restriction to append to
//              [cNoiseWordsSkipped] -- count of noise words that have been skipped
//
//  History:    29-Nov-94   SitaramR    Created
//
//----------------------------------------------------------------------------

void CQueryKeyRepository::AppendKey( CPhraseRestriction *pPhraseRst,
                                     ULONG cNoiseWordsSkipped )
{
    // _occ as generated by CKeyMaker is not accurate because it does not
    //  take StartAltPhrase/EndAltPhrase into account. We use _occ (and _occLast)
    //  solely to test for synonyms. The test is:
    //
    //       if ( _occ == _occLast )
    //          then synonym

    if ( _occ == _occLast )
    {
        ULONG iLast = pPhraseRst->Count()-1;
        COccRestriction *pLastChild = pPhraseRst->GetChild( iLast );

        Win4Assert( pLastChild );

        if ( pLastChild->Type() == RTWord )
        {
            ciDebugOut (( DEB_ITRACE, "Create Synonym Expression\n" ));
            const CKey* pKey = ((CWordRestriction*) pLastChild)->GetKey();

            // there can be no noise words between synonyms
            Win4Assert( cNoiseWordsSkipped == 0 );

            _fHasSynonym = TRUE;
            XPtr<CSynRestriction> xTmp(new CSynRestriction ( *pKey,
                                                         pLastChild->Occurrence(),
                                                         0, 0, _isRange ));
            Win4Assert( xTmp->IsValid() );

            delete pLastChild;
            pLastChild = xTmp.Acquire();
            pPhraseRst->SetChild ( pLastChild, iLast );
        }

        Win4Assert ( pLastChild->Type() == RTSynonym );

        ((CSynRestriction*) pLastChild)->AddKey ( _key );
    }
    else
    {
        XPtr<CWordRestriction> xChildRst( new CWordRestriction( _key, _occ,
                                                                cNoiseWordsSkipped, 0, _isRange ) );
        Win4Assert( xChildRst->IsValid() );

        // calculate correct occurrence taking noise words into account

        OCCURRENCE occ = _ComputeOccurrence( xChildRst.GetPointer(), pPhraseRst );
        xChildRst->SetOccurrence( occ );

        pPhraseRst->AddChild ( xChildRst.GetPointer() );
        xChildRst.Acquire();
    }
} //AppendKey

//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::StartAltPhrase
//
//  Synopsis:   Preparation for start of an alternate phrase
//
//  Arguments:  [cNoiseWordsSkipped] -- count of noise words that have been skipped
//
//  History:    29-Nov-94   SitaramR    Created
//
//----------------------------------------------------------------------------

void CQueryKeyRepository::StartAltPhrase( ULONG cNoiseWordsSkipped )
{
    // check if there is a set of alt phrases with noise words only
    if ( _fNoiseWordsOnly )
        return;

    if ( _pCurAltPhrase )
    {
        if ( _pCurAltPhrase->Count() == 0 )
            delete _pCurAltPhrase;
        else
        {
            // add count of noise words skipped to last child of _pCurAltPhrase
            COccRestriction *pOccRst = _pCurAltPhrase->GetChild( _pCurAltPhrase->Count()-1 );
            Win4Assert( pOccRst );
            pOccRst->AddCountPostNoiseWords( cNoiseWordsSkipped );
            _stkAltPhrases.Push( _pCurAltPhrase );
        }
    }
    else
    {
        if ( _pOrRst )
        {
            Win4Assert( _pOrRst->Count() );
            Win4Assert( _pPhrase == 0 );

            // add count of noise words of last child of every phrase in _pOrRst
            for ( unsigned i=0; i<_pOrRst->Count(); i++)
            {
                CRestriction *pRst = _pOrRst->GetChild(i);
                Win4Assert( pRst->Type() == RTPhrase );
                COccRestriction *pOccRst =
                      ((CPhraseRestriction *)pRst)->GetChild( ((CPhraseRestriction *)pRst)->Count()-1 );
                Win4Assert( pOccRst );
                pOccRst->AddCountPostNoiseWords( cNoiseWordsSkipped );
            }
        }
        else
        {
            if ( _pPhrase->Count() != 0 )
            {
                // add count of noise words skipped to last child of _pPhrase
                COccRestriction *pOccRst = _pPhrase->GetChild( _pPhrase->Count()-1 );
                Win4Assert( pOccRst );
                pOccRst->AddCountPostNoiseWords( cNoiseWordsSkipped );
            }
            else  // sequence of noise words at the beginning of the phrase
                _cInitialNoiseWords = cNoiseWordsSkipped;
        }
    }

    _pCurAltPhrase = new CPhraseRestriction( INIT_PHRASE_WORDS );

    _occLast = OCC_INVALID;             // reset _occLast
}





//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::EndAltPhrase
//
//  Synopsis:   Append all alternate phrases to existing phrases
//
//  Arguments:  [cNoiseWordsSkipped] -- count of noise words that have been skipped
//
//  History:    29-Nov-94   SitaramR    Created
//
//----------------------------------------------------------------------------

void CQueryKeyRepository::EndAltPhrase( ULONG cNoiseWordsSkipped )
{
    // check if there is a set of alt phrases with noise words only
    if ( _fNoiseWordsOnly )
        return;

    // call on StartAltPhrase to stack the current alternate phrase
    Win4Assert( _pCurAltPhrase );
    StartAltPhrase( cNoiseWordsSkipped );
    delete _pCurAltPhrase;         // allocated in StartAltPhrase, but it is not needed
    _pCurAltPhrase = 0;

    // if all alternate phrases are noise, then the entire query is an
    //      uninteresting phrase because we cannot compute the occurrence of the
    //      first key after the set of alternate phrases. So, clean up and return.
    if ( _stkAltPhrases.Count() == 0 )
    {
        _fNoiseWordsOnly = TRUE;

        delete _pOrRst;
        _pOrRst = 0;
        delete _pPhrase;
        _pPhrase = 0;

        return;
    }

    XNodeRestriction xNewOrRst( new CNodeRestriction( RTOr ));

    XPhraseRestriction xTailPhrase;

    if ( _pOrRst )
    {
        // concatenate each of the stacked alternate phrases to every child phrase
        //    of _pOrRst

        Win4Assert( _pOrRst->Count() );
        Win4Assert( _pPhrase == 0 );

        while ( _stkAltPhrases.Count() > 0 )
        {
            xTailPhrase.Set( _stkAltPhrases.Pop() );
            for ( unsigned i=0; i< _pOrRst->Count(); i++)
            {
                CRestriction *pRst = _pOrRst->GetChild(i);
                Win4Assert( pRst->Type() == RTPhrase );
                CloneAndAdd( xNewOrRst.GetPointer(), (CPhraseRestriction *)pRst,
                             xTailPhrase.GetPointer() );
            }
            CPhraseRestriction *pTailPhrase = xTailPhrase.Acquire();
            delete pTailPhrase;
        }
    }
    else       // only one phrase so far
    {
        while ( _stkAltPhrases.Count() > 0 )
        {
            xTailPhrase.Set( _stkAltPhrases.Pop() );
            CloneAndAdd( xNewOrRst.GetPointer(), _pPhrase, xTailPhrase.GetPointer() );
            CPhraseRestriction *pTailPhrase = xTailPhrase.Acquire();
            delete pTailPhrase;
        }
    }

    delete _pPhrase;
    _pPhrase = 0;

    delete _pOrRst;
    _pOrRst  = xNewOrRst.Acquire();

    _occLast = OCC_INVALID;             // reset _occLast
}



//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::CloneAndAdd
//
//  Synopsis:   Clone pHeadPhrase,  pTailPhrase, concatenate and add the
//                 resulting phrase to pOrRst
//
//  Arguments:  [pOrRst] -- Destination Or node
//              [pHeadPhrase] -- first part of a phrase
//              [pTailPhrase] -- remaining part of a phrase
//
//  History:    29-Nov-94   SitaramR    Created
//
//----------------------------------------------------------------------------

void CQueryKeyRepository::CloneAndAdd( CNodeRestriction *pOrRst,
                                       CPhraseRestriction *pHeadPhrase,
                                       CPhraseRestriction *pTailPhrase )
{
    XPhraseRestriction xPhraseRst( new CPhraseRestriction( INIT_PHRASE_WORDS ) );

    Win4Assert( xPhraseRst->IsValid() );

    // clone head
    XOccRestriction xOccRst;
    for ( unsigned i=0; i<pHeadPhrase->Count(); i++ )
    {
        xOccRst.Set( pHeadPhrase->GetChild(i)->Clone() );

        Win4Assert( xOccRst->IsValid() );

        xPhraseRst.GetPointer()->AddChild( xOccRst.GetPointer() );
        xOccRst.Acquire();
    }

    // clone tail
    for ( i=0; i<pTailPhrase->Count(); i++)
    {
        xOccRst.Set( pTailPhrase->GetChild(i)->Clone() );

        Win4Assert( xOccRst->IsValid() );

        OCCURRENCE occ = _ComputeOccurrence( xOccRst.GetPointer(), xPhraseRst.GetPointer() );
        xOccRst.GetPointer()->SetOccurrence( occ );

        xPhraseRst.GetPointer()->AddChild( xOccRst.GetPointer() );
        xOccRst.Acquire();
    }

    pOrRst->AddChild( xPhraseRst.GetPointer() );
    xPhraseRst.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::_ComputeOccurrence
//
//  Synopsis:   Computes the noise word adjusted occurrence
//
//  Arguments:  [pOccRst] -- restriction whose occurrence is to be computed
//              [pPhrase] -- phrase to which pOccRst is being appended
//
//  History:    29-Nov-94   SitaramR    Created
//
//----------------------------------------------------------------------------

OCCURRENCE CQueryKeyRepository::_ComputeOccurrence( COccRestriction *pOccRst,
                                                    CPhraseRestriction *pPhraseRst )
{
    OCCURRENCE occ;
    if ( pPhraseRst->Count() )
    {
        COccRestriction *pPrevOccRst = pPhraseRst->GetChild( pPhraseRst->Count()-1 );
        Win4Assert( pPrevOccRst );

        // Occurrence of pOccRst is computed as:
        //    occurrence of previous child (pPrevOccRst) in pPhraseRst
        //  + count of noise words following pPrevOccRst
        //  + count of noise words preceeding pOccRst
        //  + 1
        occ = pPrevOccRst->Occurrence() + pPrevOccRst->CountPostNoiseWords() +
                       pOccRst->CountPrevNoiseWords() + 1;
    }
    else
    {
        // Since there are no preivous restrictions, occurrence of
        //    pOccRst is computed as:
        //
        //    count of noise words at the beginning of phrase
        //  + count of noise words preceeding pOccRst
        //  + 1
        occ = _cInitialNoiseWords + pOccRst->CountPrevNoiseWords() + 1;
    }
    return occ;
}



//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::GetBuffers
//
//  Synopsis:   Returns address of repository's input buffers
//
//  Effects:
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//              [ppocc] -- pointer to pointer to recieve address of occurrences
//
//  History:    05-June-91  t-WadeR     Created.
//
//  Notes:
//
//----------------------------------------------------------------------------

void CQueryKeyRepository::GetBuffers( unsigned** ppcbWordBuf,
                                      BYTE** ppbWordBuf, OCCURRENCE** ppocc )
{
    _key.SetCount(MAXKEYSIZE);
    *ppcbWordBuf = _key.GetCountAddress();
    *ppbWordBuf = _key.GetWritableBuf();
    *ppocc = &_occ;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::GetFlags
//
//  Synopsis:   Returns address of rank and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    11-Feb-92   BartoszM    Created.
//
//----------------------------------------------------------------------------

void  CQueryKeyRepository::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    *ppRange = &_isRange;
    *ppRank  = &_rank;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryKeyRepository::FixUp
//
//  Synopsis:   This funstion creates a word restriction with the cached phrase
//              in the CDataRepository. Then it connects the new Word Restriction
//              to the phrase (internal restriction ) with a new Or restriction.
//              If the internal restriction is an Or restriction, than it simply
//              do a AddChild to the Or restriction.
//
//  Arguments : [drep] -- CDataRepository containing the cached phrase
//
//  History:    10-Feb-2000   KitmanH   Created
//
//  Note:       This function is a hack to fix a word breaker issue. The word
//              breaker does compund word breaking for some languages, such as
//              German. For example, "tes" is broken into "tes" and "1".
//              "tes" get a synonyn "t" and "1" gets a synonym "es". This is a
//              result of a hack in the infosoft word breaker. The "1" is a place
//              holder and is thrown out in a non prefix match phrase to capture
//              the case ("tes" | "t") "es". However, this breaks the prefix
//              matching scenerio. Noise words are not thrown out in a prefix
//              matching (GENERATE_METHOD_PREFIX) query, "tes*" becomes
//              (tes*|t*) (1*|es*). In this case, tes*" is not a match unless
//              it is followed immediately with a 1* or es*, e.g. "test case"
//              is not a match whereas "tested 1000 times" and "testing especially"
//              are matches. The hack here is to Or a CWordRestriction of the
//              originally phrase without word breaking. This hack works fine,
//              if the original phrase is a single word. It will not work in the
//              multiple word case.
//
//----------------------------------------------------------------------------

void CQueryKeyRepository::FixUp( CDataRepository & drep )
{
    //
    // If the keyRep has synonym, we assume word breaking has occured.
    //

    if ( _isRange && _fHasSynonym )
    {
        XNodeRestriction xOrRst;

        if ( _pPhrase )
        {
            xOrRst.Set( new CNodeRestriction( RTOr, 2 ) );
            xOrRst->AddChild ( _pPhrase );
        }
        else
        {
            Win4Assert( 0 != _pOrRst );
            xOrRst.Set( _pOrRst );
        }

        CKeyBuf KeyBuf;
        KeyBuf.SetPid( _key.Pid() );

        drep.NormalizeWStr( KeyBuf.GetWritableBuf(), KeyBuf.GetCountAddress() );

        // Create a CWordRestriction with the Normalized form of the whole phrase
        XPtr<CWordRestriction> xWordRst( new CWordRestriction( KeyBuf,
                                                               0, // occurence
                                                               0,
                                                               0,
                                                               TRUE ) );
        xOrRst->AddChild( xWordRst.GetPointer() );
        xWordRst.Acquire();

        _pOrRst = xOrRst.Acquire();
        _pPhrase = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorKeyRepository::CVectorKeyRepository
//
//  Synopsis:   Creates Vector Key repository
//
//  History:    18-Jan-95   SitaramR    Created
//
//----------------------------------------------------------------------------

CVectorKeyRepository::CVectorKeyRepository( const CFullPropSpec & ps,
                                            LCID lcid,
                                            ULONG ulWeight,
                                            CPidMapper & pidMap,
                                            CLangList  & langList )
        : _occLast(OCC_INVALID),
          _ps(ps),
          _lcid(lcid),
          _ulWeight(ulWeight),
          _pidMap(pidMap),
          _langList( langList )
{
    _pVectorRst = new CVectorRestriction( VECTOR_RANK_JACCARD );
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorKeyRepository::~CVectorKeyRepository
//
//  History:    18-Jan-95   SitaramR    Created
//
//----------------------------------------------------------------------------

CVectorKeyRepository::~CVectorKeyRepository()
{
    delete _pVectorRst;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorKeyRepository::AcqRst
//
//  Synopsis:   Acquire vector restriction
//
//  History:    18-Jan-95   SitaramR    Created
//
//----------------------------------------------------------------------------

CVectorRestriction* CVectorKeyRepository::AcqRst()
{
    if ( _pVectorRst->Count() == 0 )
        return 0;
    else
    {
        CVectorRestriction *pTmp = _pVectorRst;
        _pVectorRst = 0;
        return pTmp;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CVectorKeyRepository::PutKey
//
//  Synopsis:   Adds a key to the vector restriction
//
//  Arguments:  cNoiseWordsSkipped -- ignored (used by CQueryKeyRepository::PutKey )
//
//  History:    18-Jan-95   SitaramR    Created
//
//----------------------------------------------------------------------------

void CVectorKeyRepository::PutKey( ULONG cNoiseWordsSkipped )
{
    ciDebugOut (( DEB_ITRACE, "VectorKeyRepository::PutKey \"%.*ws\", pid=%d\n",
                  _key.StrLen(), _key.GetStr(), _key.Pid() ));

    // _occ as generated by CKeyMaker is not accurate because it does not
    //  take StartAltPhrase/EndAltPhrase into account. We use _occ (and _occLast)
    //  solely to test for synonyms. The test is:
    //
    //       if ( _occ == _occLast )
    //          then synonym

    if ( _occ == _occLast )
    {
        ULONG iLast = _pVectorRst->Count()-1;
        COccRestriction *pLastChild = (COccRestriction *)_pVectorRst->GetChild( iLast );

        Win4Assert( pLastChild );

        if ( pLastChild->Type() == RTWord )
        {
            ciDebugOut (( DEB_ITRACE, "Create Synonym Expression\n" ));
            const CKey* pKey = ((CWordRestriction*) pLastChild)->GetKey();

            // there can be no noise words between synonyms
            Win4Assert( cNoiseWordsSkipped == 0 );

            CSynRestriction* tmp = new CSynRestriction ( *pKey,
                                                         pLastChild->Occurrence(),
                                                         0, 0, FALSE );
            Win4Assert( tmp->IsValid() );

            delete pLastChild;
            pLastChild = tmp;
            _pVectorRst->SetChild ( tmp, iLast );
        }

        Win4Assert ( pLastChild->Type() == RTSynonym );

        ((CSynRestriction*) pLastChild)->AddKey ( _key );
    }
    else
    {
        XWordRestriction xWordRst( new CWordRestriction( _key, 1, 0, 0, FALSE ));

        _pVectorRst->AddChild( xWordRst.GetPointer() );
        xWordRst.Acquire();
    }

    _occLast = _occ;
}



//+---------------------------------------------------------------------------
//
//  Member:     CVectorKeyRepository::GetBuffers
//
//  Synopsis:   Returns address of repository's input buffers
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//              [ppocc] -- pointer to pointer to recieve address of occurrences
//
//  History:    18-Jan-95    SitaramR     Created.
//
//----------------------------------------------------------------------------

void CVectorKeyRepository::GetBuffers( unsigned** ppcbWordBuf,
                                       BYTE** ppbWordBuf, OCCURRENCE** ppocc )
{
    _key.SetCount(MAXKEYSIZE);
    *ppcbWordBuf = _key.GetCountAddress();
    *ppbWordBuf = _key.GetWritableBuf();
    *ppocc = &_occ;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorKeyRepository::GetFlags
//
//  Synopsis:   Returns address of rank and range flags
//
//  Arguments:  [ppRange] -- range flag
//              [ppRank] -- rank flag
//
//  History:    18-Jan-95    SitaramR    Created.
//
//----------------------------------------------------------------------------

void  CVectorKeyRepository::GetFlags ( BOOL** ppRange, CI_RANK** ppRank )
{
    *ppRange = 0;
    *ppRank  = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVectorKeyRepository::PutPhrase
//
//  Synopsis:   Stores query time phrases
//
//  Arguments:  [pwcPhrase] -- phrase as it exists in the text sources
//              [cwcPhrase] -- count of characters in pwcPhrase
//
//  History:    14-Feb-95    SitaramR    Created.
//
//----------------------------------------------------------------------------

SCODE CVectorKeyRepository::PutPhrase( WCHAR const *pwcPhrase, ULONG cwcPhrase )
{
    XPtrST<WCHAR> xString( new WCHAR[cwcPhrase+1] );
    RtlCopyMemory( xString.GetPointer(), pwcPhrase, cwcPhrase*sizeof(WCHAR) );
    xString.GetPointer()[cwcPhrase] = 0;

    CQueryKeyRepository keyRep( GENERATE_METHOD_EXACT );

    BreakPhrase( xString.GetPointer(), _ps, _lcid, GENERATE_METHOD_EXACT, keyRep, 0, _pidMap, _langList );

    CRestriction *pPhraseRst = keyRep.AcqRst();
    if ( 0 != pPhraseRst )
    {
        XPtr<CRestriction> xRst( pPhraseRst );
        pPhraseRst->SetWeight( _ulWeight );
        _pVectorRst->AddChild( pPhraseRst );
        xRst.Acquire();
    }

    _occLast = OCC_INVALID;             // reset _occLast

    return S_OK;
}


//
// The following are needed to make midl happy.  There are no other interfaces
// to bind to.  Inheritance from IUnknown is unnecessary.
//

SCODE STDMETHODCALLTYPE CVectorKeyRepository::QueryInterface(REFIID riid, void  * * ppvObject)
{
    *ppvObject = 0;
    return( E_NOTIMPL );
}

ULONG STDMETHODCALLTYPE CVectorKeyRepository::AddRef()
{
    return( 1 );
}

ULONG STDMETHODCALLTYPE CVectorKeyRepository::Release()
{
    return( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\expander\qparse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       QPARSE.CXX
//
//  Contents:   Query parser
//
//  Classes:    CQParse -- query parser
//
//  History:    19-Sep-91   BartoszM    Implemented.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <qparse.hxx>
#include <norm.hxx>
#include <drep.hxx>
#include <cci.hxx>
#include <pidmap.hxx>
#include <fa.hxx>
#include <compare.hxx>

#include "qkrep.hxx"

DECLARE_SMARTP( InternalPropertyRestriction )

static GUID guidQuery = DBQUERYGUID;
static CFullPropSpec psUnfiltered( guidQuery, DISPID_QUERY_UNFILTERED );

static GUID guidStorage = PSGUID_STORAGE;
static CFullPropSpec psFilename( guidStorage, PID_STG_NAME );

static CFullPropSpec psRevName( guidQuery, DISPID_QUERY_REVNAME );

//+---------------------------------------------------------------------------
//
//  Member:     CQParse::CQParse, public
//
//  Synopsis:   Break phrases, normalize, and stem the query expression
//
//  Arguments:  [pidmap]   -- Propid mapper
//              [langList] -- Language list
//
//  History:    19-Sep-91   BartoszM    Created.
//
//----------------------------------------------------------------------------
CQParse::CQParse( CPidMapper & pidmap, CLangList & langList )
        : _flags(0),
          _pidmap( pidmap ),
          _langList( langList ),
          _lcidSystemDefault( GetSystemDefaultLCID() )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CQParse::Parse, public
//
//  Synopsis:   Recursively parse expression
//
//  Arguments:  [pRst] --  Tree of query expressions
//
//  Returns:    Possibly modified expression
//
//  History:    19-Sep-91   BartoszM    Created.
//              18-Jan-92   KyleP       Use restrictions
//              15-May-96   DwightKr    Add check for NULL NOT restriction
//
//  Notes:      The return CRestriction will be different than [pRst].
//              [pRst] is not touched.
//
//----------------------------------------------------------------------------

CRestriction* CQParse::Parse( CRestriction* pRst )
{
    // go through leaves:
    // normalize values
    // break and normalize phrases (create phrase nodes)
    // GenerateMethod level 1 -- convert to ranges
    // higher GenerateMethod levels -- use stemmer

    if ( pRst->IsLeaf() )
    {
        return Leaf ( pRst );
    }
    else
    {
        if ( pRst->Type() == RTNot )
        {
            CNotRestriction * pnrst = (CNotRestriction *)pRst;

            XRestriction xRst( Parse( pnrst->GetChild() ) );

            if ( xRst.GetPointer() == 0 )
            {
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
            }

            CNotRestriction *pNotRst = new CNotRestriction( xRst.GetPointer() );
            Win4Assert( pNotRst->IsValid() );
            xRst.Acquire();
            return pNotRst;
        }

        CNodeRestriction* pnrstSource = pRst->CastToNode();
        XNodeRestriction xnrstTarget;
        BOOL fVector;

        if ( pRst->Type() == RTVector )
        {
            fVector = TRUE;
            xnrstTarget.Set( new CVectorRestriction( ((CVectorRestriction *)pRst)->RankMethod(),
                                                     pRst->CastToNode()->Count() ) );
        }
        else
        {
            fVector = FALSE;
            xnrstTarget.Set( new CNodeRestriction( pRst->Type(),
                                                   pRst->CastToNode()->Count() ) );
        }

        Win4Assert( xnrstTarget->IsValid() );

        //
        // Vector nodes must be treated slightly differently than
        // AND/OR/ANDNOT nodes.  Noise words must be placeholders
        // in a vector node.
        //

        BOOL fAndNode = ( xnrstTarget->Type() == RTAnd || xnrstTarget->Type() == RTProximity );
        ULONG cOrCount = ( fAndNode ? 1: pnrstSource->Count() ); // Number of non-noise OR components

        for ( unsigned i = 0; i < pnrstSource->Count(); i++ )
        {
            CRestriction * px = Parse ( pnrstSource->GetChild(i) );

            //
            // Don't store noise phrases (null nodes) during parse,
            // *unless* this is a vector node.

            if ( 0 == px && fVector )
            {
                px = new CRestriction;
            }

            if ( 0 != px )
            {
                XRestriction xRst( px );
                xnrstTarget->AddChild ( px );

                xRst.Acquire();
            }
            else
            {
                cOrCount--;
                if ( 0 == cOrCount ) // all components are noise only
                    THROW( CException( QUERY_E_ALLNOISE ) );
            }
        }
        return xnrstTarget.Acquire();
    }
} //Parse

//+---------------------------------------------------------------------------
//
//  Member:     CQParse::Leaf, private
//
//  Synopsis:   Parse the leaf node of expression tree
//
//  Arguments:  [pExpr] -- leaf expression
//
//  Returns:    Possibly modified expression
//
//  Requires:   pExpr->IsLeaf() TRUE
//
//  History:    19-Sep-91   BartoszM    Created.
//              18-Jan-92   KyleP       Use restrictions
//              05-Nov-93   DwightKr    Changed PutUnsignedValue => PutValue
//
//----------------------------------------------------------------------------

CRestriction* CQParse::Leaf ( CRestriction* pRst )
{
    Win4Assert ( pRst->IsLeaf() );

    switch( pRst->Type() )
    {
    case RTContent:
    {
        CContentRestriction* pContRst = (CContentRestriction *) pRst;
        ULONG GenerateMethod = pContRst->GenerateMethod();

        if ( GenerateMethod > GENERATE_METHOD_MAX_USER )
        {
            vqDebugOut(( DEB_ERROR,
                         "QParse: GenerateMethod 0x%x > GENERATE_METHOD_MAX_USER\n",
                         GenerateMethod ));
            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        }

        CQueryKeyRepository keyRep( GenerateMethod );

        CRestriction * pPhraseRst;

        switch ( BreakPhrase ( pContRst->GetPhrase(),
                               pContRst->GetProperty(),
                               pContRst->GetLocale(),
                               GenerateMethod,
                               keyRep,
                               0,
                               _pidmap,
                              _langList) )
        {
        case BP_NOISE:
            _flags |= CI_NOISE_IN_PHRASE;
            // Note fall through...

        case BP_OK:
            pPhraseRst = keyRep.AcqRst();

            if ( pPhraseRst )
                pPhraseRst->SetWeight( pRst->Weight() );
            else
                _flags |= CI_NOISE_PHRASE;

            break;

        default:
            Win4Assert( !"How did we get here?" );

        case BP_INVALID_PROPERTY:
            pPhraseRst = 0;
            break;
        } // switch

        return pPhraseRst;
        break;
    }

    case RTNatLanguage:
    {
        CNatLanguageRestriction* pNatLangRst = (CNatLanguageRestriction *) pRst;
        CVectorKeyRepository vecKeyRep( pNatLangRst->GetProperty(),
                                        pNatLangRst->GetLocale(),
                                        pRst->Weight(),
                                       _pidmap,
                                       _langList );
        CRestriction* pVectorRst;

        switch ( BreakPhrase ( pNatLangRst->GetPhrase(),
                               pNatLangRst->GetProperty(),
                               pNatLangRst->GetLocale(),
                               GENERATE_METHOD_INFLECT,
                               vecKeyRep,
                               &vecKeyRep,
                               _pidmap,
                               _langList ) )
        {
        case BP_NOISE:
            _flags |= CI_NOISE_IN_PHRASE;
            // Note fall through...

        case BP_OK:
            pVectorRst = vecKeyRep.AcqRst();

            if ( pVectorRst )
                pVectorRst->SetWeight( pRst->Weight() );
            else
                _flags |= CI_NOISE_PHRASE;

            break;

        default:
            Win4Assert( !"How did we get here?" );

        case BP_INVALID_PROPERTY:
            pVectorRst = 0;
            break;
        } // switch

        return pVectorRst;
        break;
    }


    case RTProperty:
    {
        CPropertyRestriction * prstProp = (CPropertyRestriction *)pRst;

        if ( getBaseRelop(prstProp->Relation()) > PRSomeBits )
        {
            vqDebugOut(( DEB_ERROR,
                         "QParse: Invalid comparison operator %d\n",
                         prstProp->Relation() ));
            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        }

        PROPID pid = _pidmap.NameToPid( prstProp->GetProperty() );

        if ( pidInvalid != pid )
            pid = _pidmap.PidToRealPid( pid );

        if ( pidInvalid == pid )
        {
            vqDebugOut(( DEB_ERROR,
                         "QParse: Invalid property\n" ));
            THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        }

        CInternalPropertyRestriction * prstIProp =
            new CInternalPropertyRestriction( prstProp->Relation(),
                                              pid,
                                              prstProp->Value() );

        Win4Assert( prstIProp->IsValid() );

        XInternalPropertyRestriction xrstIProp( prstIProp );

        //
        // If the property restriction is over a string value, then create
        // a helper content restriction.
        //

        switch( prstProp->Value().Type() )
        {
        case VT_LPSTR:
            AddLpstrHelper( prstProp, prstIProp );
            break;

        case VT_LPWSTR:
            AddLpwstrHelper( prstProp, prstIProp );
            break;

        case VT_LPWSTR | VT_VECTOR:
            AddLpwstrVectorHelper( prstProp, prstIProp );
            break;

        case VT_BOOL:
            if ( prstProp->Value().GetBOOL() != FALSE &&
                 prstProp->Relation() == PREQ &&
                 prstProp->GetProperty() == psUnfiltered )
            {
                delete xrstIProp.Acquire();

                CUnfilteredRestriction *pUnfiltRst = new CUnfilteredRestriction;

                return( pUnfiltRst );
            }
            break;

        default:
            break;
        }

        return( xrstIProp.Acquire() );
    }

    default:
    {
        vqDebugOut(( DEB_ERROR,
                     "QParse: Invalid restriction type %d\n",
                     pRst->Type() ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        return 0;
    }
    }
} //Leaf

//+---------------------------------------------------------------------------
//
//  Member:     CQParse::AddLpwstrHelper, private
//
//  Synopsis:   Add content helpers for VT_LPWSTR properties.
//
//  Arguments:  [prstProp]  -- Property restriction (input)
//              [prstIProp] -- Internal property restriction (output)
//
//  History:    03-Oct-95   KyleP       Broke out as method.
//
//----------------------------------------------------------------------------

void CQParse::AddLpwstrHelper( CPropertyRestriction * prstProp,
                               CInternalPropertyRestriction * prstIProp )
{
    //
    // For equality, we create a content restriction with GenerateMethod level 0.
    //

    if ( prstProp->Relation() == PREQ )
    {
        CQueryKeyRepository keyRep( GENERATE_METHOD_EXACT );

        BreakPhrase ( (WCHAR *)prstProp->Value().GetLPWSTR(),
                      prstProp->GetProperty(),
                      _lcidSystemDefault,
                      GENERATE_METHOD_EXACT,
                      keyRep,
                      0,
                     _pidmap,
                     _langList );
        prstIProp->SetContentHelper( keyRep.AcqRst() );
    }

    //
    // For regular expression, create a GenerateMethod match for any fixed prefix
    // on the string.
    //

    else if ( prstProp->Relation() == PRRE )
    {
        const MAX_PREFIX_LENGTH = 50;

        unsigned i = wcscspn( prstProp->Value().GetLPWSTR(),
                              awcSpecialRegex );

        //
        // Should the 0 below be a registry parameter?
        //

        if ( i > 0 )
        {
            WCHAR wcs[MAX_PREFIX_LENGTH];

            if ( i > sizeof(wcs)/sizeof(WCHAR) - 2 )
                i = sizeof(wcs)/sizeof(WCHAR) - 2;

            memcpy( wcs, prstProp->Value().GetLPWSTR(), i*sizeof(WCHAR) );
            wcs[i] = 0;

            //
            // Trickery: Key repository is GENERATE_METHOD_PREFIX which turns key into ranges.
            //           Phrase is broken with GENERATE_METHOD_EXACTPREFIXMATCH which does 'exact'
            //           prefix matching: e.g. it uses the noise word list.  The result is
            //           that we match ranges, but don't set a content helper if we hit
            //           a noise word.  This is different from a user GENERATE_METHOD_PREFIX
            //           which uses a very minimal noise word list (only 1 character
            //           prefixes are noise).
            //

            CQueryKeyRepository keyRep( GENERATE_METHOD_PREFIX );
            if ( BP_OK == BreakPhrase ( wcs,
                                        prstProp->GetProperty(),
                                        _lcidSystemDefault,
                                        GENERATE_METHOD_EXACTPREFIXMATCH,
                                        keyRep,
                                        0,
                                        _pidmap,
                                        _langList ) )
            {
                prstIProp->SetContentHelper( keyRep.AcqRst() );
            }
        }

        //
        // If this is the filename property, then add to the content helper
        // the reversed suffix string w/o wildcards.  For *.cxx we would
        // add xxc.
        //

        if ( prstProp->GetProperty() == psFilename )
        {
            WCHAR wcs[MAX_PREFIX_LENGTH];

            WCHAR const * pBegin = prstProp->Value().GetLPWSTR();
            WCHAR const * pEnd = pBegin + wcslen(pBegin) - 1;

            i = 0;

            for ( ; pEnd >= pBegin && i < MAX_PREFIX_LENGTH - 1 ; pEnd-- )
            {
                if ( wcschr( awcSpecialRegexReverse, *pEnd ) == 0 )
                    wcs[i++] = *pEnd;
                else
                {
                    wcs[i] = 0;
                    break;
                }
            }

            if ( i < MAX_PREFIX_LENGTH )
                wcs[i] = 0;

            wcs[MAX_PREFIX_LENGTH - 1] = 0;

            if ( i > 0 )
            {
                CQueryKeyRepository keyRep( GENERATE_METHOD_PREFIX );

                if ( prstIProp->GetContentHelper() == 0 )
                {
                    if ( BP_OK == BreakPhrase ( wcs,
                                                psRevName,
                                                _lcidSystemDefault,
                                                GENERATE_METHOD_EXACTPREFIXMATCH,
                                                keyRep,
                                                0,
                                                _pidmap,
                                                _langList ) )
                    {
                        prstIProp->SetContentHelper( keyRep.AcqRst() );
                    }
                }
                else
                {
                    if ( BP_OK == BreakPhrase ( wcs,
                                                psRevName,
                                                _lcidSystemDefault,
                                                GENERATE_METHOD_EXACTPREFIXMATCH,
                                                keyRep,
                                                0,
                                                _pidmap,
                                                _langList ) )
                    {
                        CNodeRestriction *pNodeRst = new CNodeRestriction( RTAnd, 2 );
                        XNodeRestriction rstAnd( pNodeRst );

                        Win4Assert( rstAnd->IsValid() );

                        unsigned posOrig;
                        rstAnd->AddChild( prstIProp->GetContentHelper(), posOrig );

                        prstIProp->AcquireContentHelper();

                        XRestriction xRst( keyRep.AcqRst() );

                        unsigned pos;
                        rstAnd->AddChild( xRst.GetPointer(), pos );

                        xRst.Acquire();

                        if ( 0 == rstAnd->GetChild( pos ) )
                        {
                            prstIProp->SetContentHelper( rstAnd->RemoveChild( posOrig ) );
                        }
                        else
                        {
                            prstIProp->SetContentHelper( rstAnd.Acquire() );
                        }
                    }
                }
            }
        }
    }
} //AddLpwstrHelper

//+---------------------------------------------------------------------------
//
//  Member:     CQParse::AddLpstrHelper, private
//
//  Synopsis:   Add content helpers for VT_LPSTR properties.
//
//  Arguments:  [prstProp]  -- Property restriction (input)
//              [prstIProp] -- Internal property restriction (output)
//
//  History:    03-Oct-95   KyleP       Broke out as method.
//
//----------------------------------------------------------------------------

void CQParse::AddLpstrHelper( CPropertyRestriction * prstProp,
                              CInternalPropertyRestriction * prstIProp )
{
    //
    // For equality, we create a content restriction with GenerateMethod level 0.
    //

    if ( prstProp->Relation() == PREQ )
    {
        CQueryKeyRepository keyRep( GENERATE_METHOD_EXACT );

        BreakPhrase ( prstProp->Value().GetLPSTR(),
                      prstProp->GetProperty(),
                      _lcidSystemDefault,
                      GENERATE_METHOD_EXACT,
                      keyRep,
                      0,
                     _pidmap,
                     _langList );

        prstIProp->SetContentHelper( keyRep.AcqRst() );
    }

    //
    // For regular expression, create a GenerateMethod match for any fixed prefix
    // on the string.
    //

    else if ( prstProp->Relation() == PRRE )
    {
        const MAX_PREFIX_LENGTH = 50;

        unsigned i = strcspn( prstProp->Value().GetLPSTR(),
                              acSpecialRegex );

        //
        // Should the 0 below be a registry parameter?
        //

        if ( i > 0 )
        {
            char ac[MAX_PREFIX_LENGTH];

            if ( i > sizeof(ac) - 1 )
                i = sizeof(ac) - 1;

            memcpy( ac, prstProp->Value().GetLPSTR(), i );
            ac[i] = 0;

            //
            // Trickery: Key repository is GENERATE_METHOD_PREFIX which turns key into ranges.
            //           Phrase is broken with GENERATE_METHOD_EXACTPREFIXMATCH which does 'exact'
            //           prefix matching: e.g. it uses the noise word list.  The result is
            //           that we match ranges, but don't set a content helper if we hit
            //           a noise word.  This is different from a user GENERATE_METHOD_PREFIX
            //           which uses a very minimal noise word list (only 1 character
            //           prefixes are noise).
            //

            CQueryKeyRepository keyRep( GENERATE_METHOD_PREFIX );

            if ( BP_OK == BreakPhrase ( ac,
                                        prstProp->GetProperty(),
                                        _lcidSystemDefault,
                                        GENERATE_METHOD_EXACTPREFIXMATCH,
                                        keyRep,
                                        0,
                                        _pidmap,
                                        _langList ) )
            {
                prstIProp->SetContentHelper( keyRep.AcqRst() );
            }
        }
    }
} //AddLpstrHelper

//+---------------------------------------------------------------------------
//
//  Member:     CQParse::AddLpwstrVectorHelper, private
//
//  Synopsis:   Add content helpers for VT_LPWSTR | VT_VECTOR properties.
//
//  Arguments:  [prstProp]  -- Property restriction (input)
//              [prstIProp] -- Internal property restriction (output)
//
//  History:    03-Oct-95   KyleP       Created
//
//----------------------------------------------------------------------------

void CQParse::AddLpwstrVectorHelper( CPropertyRestriction * prstProp,
                                     CInternalPropertyRestriction * prstIProp )
{
    if ( prstProp->Value().Count() == 0 )
    {
        //
        // Null vector, hence no helper restriction
        //

        return;
    }

    if ( prstProp->Relation() == PREQ || prstProp->Relation() == (PREQ | PRAll) )
    {
        XNodeRestriction xrstAnd( new CNodeRestriction( RTAnd, prstProp->Value().Count() ) );

        Win4Assert( xrstAnd->IsValid() );

        for ( unsigned i = 0; i < prstProp->Value().Count(); i++ )
        {
            CQueryKeyRepository keyRep( GENERATE_METHOD_EXACT );

            BreakPhrase ( (WCHAR *)prstProp->Value().GetLPWSTR( i ),
                         prstProp->GetProperty(),
                         _lcidSystemDefault,
                         GENERATE_METHOD_EXACT,
                         keyRep,
                         0,
                         _pidmap,
                         _langList );
            CRestriction * prst = keyRep.AcqRst();

            if ( 0 != prst )
            {
                XPtr<CRestriction> xRst( prst );
                xrstAnd->AddChild( prst );
                xRst.Acquire();
            }
            else
            {
                _flags |= CI_NOISE_IN_PHRASE;
            }
        }

        //
        // If there aren't any nodes (because of noise words) don't set the
        // content helper, so we can fall back on enumeration.  Set _flags
        // in this case so it's obvious why we had to fall back on enumration.
        //

        if ( xrstAnd->Count() == 1 )
            prstIProp->SetContentHelper( xrstAnd->RemoveChild( 0 ) );
        else if ( 0 != xrstAnd->Count() )
            prstIProp->SetContentHelper( xrstAnd.Acquire() );
    }
    else if ( prstProp->Relation() == (PREQ | PRAny) )
    {
        XNodeRestriction xrstOr( new CNodeRestriction( RTOr, prstProp->Value().Count() ) );

        for ( unsigned i = 0; i < prstProp->Value().Count(); i++ )
        {
            CQueryKeyRepository keyRep( GENERATE_METHOD_EXACT );

            BreakPhrase ( (WCHAR *)prstProp->Value().GetLPWSTR( i ),
                          prstProp->GetProperty(),
                          _lcidSystemDefault,
                          GENERATE_METHOD_EXACT,
                          keyRep,
                          0,
                         _pidmap,
                         _langList );

            CRestriction * prst = keyRep.AcqRst();

            if ( 0 != prst )
            {
                XPtr<CRestriction> xRst( prst );
                xrstOr->AddChild( prst );
                xRst.Acquire();
            }
            else
                break;   // If we can't match all OR clauses, then we're in trouble.
        }

        //
        // RTAny is all-or-nothing.  A missed clause in one that CI can't resolve, which
        // means there are objects that match this query that CI won't find.
        //

        if ( xrstOr->Count() == prstProp->Value().Count() )
        {
            if ( xrstOr->Count() == 1 )
                prstIProp->SetContentHelper( xrstOr->RemoveChild( 0 ) );
            else
                prstIProp->SetContentHelper( xrstOr.Acquire() );
        }
        else
        {
            _flags |= CI_NOISE_IN_PHRASE;
        }
    }
} //AddLpwstrVectorHelper

//+---------------------------------------------------------------------------
//
//  Function:   BreakPhrase
//
//  Synopsis:   Break phrase into words and noun phrases
//
//  Arguments:  [phrase] -- string
//              [ps] -- property specification
//              [GenerateMethod] -- GenerateMethod flag
//              [keyRep] -- key repository into which words will be deposited
//              [pPhraseSink] -- sink for phrases
//              [pidMap] -- pid mapper used to convert property to propid
//
//  Returns:    Noise word status.
//
//  History:    19-Sep-1991   BartoszM    Created.
//              18-Jan-1992   KyleP       Use restrictions
//              12-Feb-2000   KitmanH     Added hack to fix German word breaking
//                                        issue for prefix matching queries
//
//----------------------------------------------------------------------------

BreakPhraseStatus BreakPhrase ( WCHAR const * phrase,
                                const CFullPropSpec & ps,
                                LCID lcid,
                                ULONG GenerateMethod,
                                PKeyRepository& krep,
                                IPhraseSink *pPhraseSink,
                                CPidMapper & pidMap,
                                CLangList  & langList )
{
    CDataRepository drep( krep, pPhraseSink, TRUE, GenerateMethod, pidMap, langList );

    if ( drep.PutLanguage( lcid ) && drep.PutPropName( ps ) )
    {
        ciDebugOut (( DEB_ITRACE,
                      "BreakPhrase: phrase = \"%ws\" Propid = %lu\n",
                      phrase, drep.GetPropId() ));

        drep.PutPhrase( phrase, wcslen(phrase) + 1 );
        krep.FixUp( drep );

        if ( drep.ContainedNoiseWords() )
            return BP_NOISE;
        else
            return BP_OK;
    }
    else
        return BP_INVALID_PROPERTY;
} //BreakPhrase

//
// DBCS version of the previous function.
//

BreakPhraseStatus BreakPhrase ( char const * phrase,
                                const CFullPropSpec & ps,
                                LCID lcid,
                                ULONG GenerateMethod,
                                PKeyRepository& krep,
                                IPhraseSink *pPhraseSink,
                                CPidMapper & pidMap,
                                CLangList  & langList )
{
    CDataRepository drep( krep, pPhraseSink, TRUE, GenerateMethod, pidMap, langList );

    if ( drep.PutLanguage( lcid ) && drep.PutPropName( ps ) )
    {
        ciDebugOut (( DEB_ITRACE,
                      "BreakPhrase: phrase = \"%s\" Propid = %lu\n",
                      phrase, drep.GetPropId() ));

        drep.PutPhrase( phrase, strlen(phrase) + 1 );
        krep.FixUp( drep );

        if ( drep.ContainedNoiseWords() )
            return BP_NOISE;
        else
            return BP_OK;
    }
    else
        return BP_INVALID_PROPERTY;
} //BreakPhrase
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\expander\qsplit.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1991 - 1998
//
// File:        qsplit.cxx
//
// Contents:    Function to parse and split query into indexable/non-indexable
//                  parts
//
// History:     26-Sep-94       SitaramR   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xpr.hxx>
#include <cci.hxx>
#include <parse.hxx>
#include <pidmap.hxx>
#include <qparse.hxx>
#include <lang.hxx>
#include <split.hxx>
#include <qsplit.hxx>
#include <qoptimiz.hxx>
#include <qiterate.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   ParseAndSplitQuery
//
//  Synopsis:   Parses the restriction and then splits it into indexable and
//              non-indexable parts. The non-indexable part is thrown away.
//
//  Arguments:  [pRestriction] -- Input restriction
//              [PidMap ]      -- Pid mapper to be filled with mappings
//              [xOutRst]      -- The indexable part of the restriction will
//                                be put in this.
//              [langList]     -- Language list (for word breakers)
//
//  Returns:    SCODE of the operation.
//
//  History:    7-23-96   srikants   Adapted from SitaramR's code.
//
//  Notes:      A multi-part query experssion is split into individual components
//              and from each component, only the indexable portion is taken.
//              All the indexable components are composed by using an OR
//              node.
//
//----------------------------------------------------------------------------

SCODE ParseAndSplitQuery( CRestriction * pRestriction,
                          CPidMapper & Pidmap,
                          XRestriction& xOutRst,
                          CLangList   & langList )
{
    SCODE sc = STATUS_SUCCESS;

    TRY
    {
        if ( 0 != pRestriction )
        {
            BOOL fCIRequiredGlobal;

            CTimeLimit timeLimit( ULONG_MAX, 0 ); // Must precede xXpr (CDFA has reference)

            XRestriction    xRstParsed;
            XXpr            xXpr;
            XRestriction    xFullyResolvableRst;

            CQParse    qparse( Pidmap, langList );   // Maps name to pid

            xRstParsed.Set( qparse.Parse( pRestriction ) );

            CQueryRstIterator   qRstIterator( 0,
                                              xRstParsed,
                                              timeLimit,
                                              fCIRequiredGlobal,
                                              TRUE, // No Timeout,
                                              FALSE  // Don't validate catalog
                                            );

            qRstIterator.GetFirstComponent( xFullyResolvableRst, xXpr );

            if ( qRstIterator.AtEnd() )
            {
                xOutRst.Set( xFullyResolvableRst.Acquire() );
            }
            else
            {
                XNodeRestriction xRstTemp( new CNodeRestriction( RTOr, 2 ) );

                if ( 0 != xFullyResolvableRst.GetPointer() )
                    xRstTemp->AddChild( xFullyResolvableRst.Acquire() );

                delete xXpr.Acquire();

                while ( !qRstIterator.AtEnd() )
                {
                    qRstIterator.GetNextComponent( xFullyResolvableRst, xXpr );
                    if ( 0 != xFullyResolvableRst.GetPointer() )
                       xRstTemp->AddChild( xFullyResolvableRst.Acquire() );
                    delete xXpr.Acquire();
                }

                switch ( xRstTemp->Count() )
                {
                case 0:
                    break;

                case 1:
                    xOutRst.Set( xRstTemp->RemoveChild( 0 ) );
                    break;

                default:
                    xOutRst.Set( xRstTemp.Acquire() );
                    break;
                }
            }
        }
        else
        {
            sc = QUERY_E_INVALIDRESTRICTION;
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\ebufhdlr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1998.
//
//  File:       EBufHdlr.Cxx
//
//  Contents:   Implementation of the CEntryBufferHandler
//
//  Classes:    CEntryBufferHandler
//
//  History:    18-Mar-93       AmyA        Created from wordlist.cxx and
//                                          sort.cxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fdaemon.hxx>
#include <entrybuf.hxx>

#include "ebufhdlr.hxx"

//+---------------------------------------------------------------------------
//
// Member:      CEntryBufferHandler::CEntryBufferHandler, public
//
// Synopsis:    Constructor
//
// Arguments:   [cbMemory] -- suggested size of entry buffer
//
// History:     18-Mar-93   AmyA    Created.
//
//----------------------------------------------------------------------------

CEntryBufferHandler::CEntryBufferHandler( ULONG cbMemory,
                                          BYTE * buffer,
                                          CFilterDaemon& fDaemon,
                                          CiProxy & proxy,
                                          CPidMapper & pidMap )
        : _entryBuf ( cbMemory, buffer ),
          _wordListFull ( FALSE ),
          _filterDaemon ( fDaemon ),
          _cFilteredBlocks( 0 )
{
}

//+---------------------------------------------------------------------------
//
// Member:      CEntryBufferHandler::FlushBuffer, private
//
// Synopsis:    Sorts entry buffer and calls CWordList::PutEntryBuffer()
//
// Expects:     Sentinel entry added to _entryBuf.
//
// History:     18-Mar-93   AmyA    Created.
//
//----------------------------------------------------------------------------

void CEntryBufferHandler::FlushBuffer()
{
    _entryBuf.Sort();
    _entryBuf.Done();   // prepare buffer to be sent to kernel

    SCODE sc = _filterDaemon.FilterDataReady ( _entryBuf.GetBuffer(),
                                               _entryBuf.GetSize() );
    _wordListFull = (sc == FDAEMON_W_WORDLISTFULL );
    _entryBuf.ReInit();

    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR,
             "FilterDataReady call from FlushBuffer failed sc 0x%x. "
             "Buffer contents lost.\n", sc ));
        THROW( CException( sc ) );
    }
}

//+---------------------------------------------------------------------------
//
// Member:      CEntryBufferHandler::Done, public
//
// Synopsis:    indicate end of the CEntryBufferHandler
//
// Effects:     Flushes entry buffer, then calls CommitWordList
//
// History:     22-May-91   Brianb      Created
//              18-Mar-93   AmyA        Moved from CWordList.
//
// Note:        This method can not throw exceptions
//
//----------------------------------------------------------------------------

void CEntryBufferHandler::Done()
{
    TRY
    {
        _entryBuf.AddSentinel();

        if ( _entryBuf.Count() != 0 )
        {
            FlushBuffer();
        }
    }
    CATCH (CException, e)
    {
        ciDebugOut (( DEB_ERROR,
                      "CEntryBufferHandler::Done failed, status=0x%x\n",
                      e.GetErrorCode() ));
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
// Member:      CEntryBufferHandler::Init, public
//
// Synopsis:    Reinitializes class after Done has been called.
//
// Effects:     Resets _wordListFull and calls ReInit on entry buffer
//
// History:     04-May-93   AmyA        Created
//
//----------------------------------------------------------------------------

void CEntryBufferHandler::Init()
{
    ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "CEntryBufferHandler::Init\n" ));
    _wordListFull = FALSE;
    _entryBuf.ReInit();
}

//+-------------------------------------------------------------------------
//
//  Member:     CEntryBufferHandler::SetWid, public
//
//  Synopsis:   Sets the WorkId to which future AddEntry calls apply.
//
//  Arguments:  [widFake] -- fake WorkId
//
//  History:    20-May-92   KyleP       Created
//              18-Mar-93   AmyA        Moved from CWordList.
//
//--------------------------------------------------------------------------

void CEntryBufferHandler::SetWid( WORKID widFake )
{
    Win4Assert ( widFake != widInvalid );
    _CurrentWidIndex = widFake;
}

//+---------------------------------------------------------------------------
//
// Member:      CEntryBufferHandler::AddEntry, public
//
// Synopsis:    Adds an entry (key, workid, etc.) to the CEntryBuffer
//
// Effects:     Adds a <key, propid, workid, occurrence>
//              tuple to the sort.
//
// Arguments:   [key] -- Normalized key
//              [occ] -- Occurrence
//
// History:     07-Mar-91   KyleP       Created.
//              22-May-91   Brianb      Changed to use own sorter
//              07-Jun-91   BartoszM    Rewrote
//              18-Mar-93   AmyA        Moved from CWordList.
//
//----------------------------------------------------------------------------

void CEntryBufferHandler::AddEntry(
                                   const CKeyBuf & key,
                                   OCCURRENCE occ )
{
    ciAssert ( key.Count() != 0 );
    ciAssert ( key.Pid() != pidInvalid );

    if ( !_entryBuf.WillFit ( key.Count() ) )
    {
        ciDebugOut (( DEB_ITRACE | DEB_NOCOMPNAME, "+" ));

        _entryBuf.AddSentinel();

        FlushBuffer();

        //
        // Check if the filtering has exceeded its space limit
        //

        _cFilteredBlocks++;
        if ( _cFilteredBlocks > _ulMaxFilteredBlocks )
        {
            ciDebugOut(( DEB_WARN, "Filtering a document has exceeded its space limit\n" ));
            QUIETTHROW( CException( FDAEMON_E_TOOMANYFILTEREDBLOCKS ) );
        }
    }

    Win4Assert ( _CurrentWidIndex != widInvalid );

    _entryBuf.AddEntry  ( key.Count(),
              key.GetBuf(),
              key.Pid(),
              _CurrentWidIndex,
              occ);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\ikrep.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:   IKREP.CXX
//
//  Contents:   Index Key Repository
//
//  Classes:    CIndexKeyRepository
//
//  History:    30-May-91    t-WadeR    Created.
//              01-July-91  t-WadeR     Added PutPropName
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pfilter.hxx>

#include "ikrep.hxx"

//+---------------------------------------------------------------------------
//
//  Member:     CIndexKeyRepository::CIndexKeyRepository
//
//  Synopsis:   Creates a key repository
//
//  History:    31-May-91   t-WadeR     Created
//              07-Feb-92   BartoszM    Inherit unwind
//----------------------------------------------------------------------------
CIndexKeyRepository::CIndexKeyRepository( CEntryBufferHandler& entBufHdlr )
: _entryBufHandler(entBufHdlr)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexKeyRepository::PutKey
//
//  Synopsis:   Puts a key into the entry buffer
//
//  Arguments:  cNoiseWordsSkipped -- ignored (used in CQueryKeyRepository::PutKey )
//
//  History:    31-May-91   t-WadeR     Created
//
//  Notes:      This could be inline, if not for the debugging code.
//
//----------------------------------------------------------------------------
void    CIndexKeyRepository::PutKey ( ULONG cNoiseWordsSkipped )
{
//    ciAssert( _key.Pid() != pidAll );
    _entryBufHandler.AddEntry( _key, _occ );
}

//+---------------------------------------------------------------------------
//
//  Member:     CIndexKeyRepository::GetBuffers
//
//  Synopsis:   Returns address of repository's input buffers
//
//  Effects:
//
//  Arguments:  [ppcbInBuf] -- pointer to pointer to size of input buffer
//              [ppbInBuf] -- pointer to pointer to recieve address of buffer
//              [ppocc] -- pointer to pointer to recieve address of occurrences
//
//  History:    05-June-91   t-WadeR     Created.
//
//----------------------------------------------------------------------------

void    CIndexKeyRepository::GetBuffers(
    UINT** ppcbWordBuf, BYTE** ppbWordBuf, OCCURRENCE** ppocc )
{
    _key.SetCount(MAXKEYSIZE);
    *ppcbWordBuf = _key.GetCountAddress();
    *ppbWordBuf = _key.GetWritableBuf();
    *ppocc = &_occ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\docsum.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:        docsum.cxx
//
//  Contents:    document summary helper class
//
//  Classes:     CDocCharacterization
//
//  History:     12-Jan-96       dlee    Created
//
//  Todo:        try to end summary on sentence or word boundary.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propspec.hxx>
#include <ciguid.hxx>
#include "docsum.hxx"

const WCHAR wcParagraph = 0x2029;

const WCHAR *pwcDescription = L"DESCRIPTION";

static CFullPropSpec psRevName( guidQuery, DISPID_QUERY_REVNAME );
static CFullPropSpec psName( guidStorage, PID_STG_NAME );

const GUID guidCharacterization = PSGUID_CHARACTERIZATION;
const GUID guidHTMLUrl = HTMLUrl;
const GUID guidHTMLComment = HTMLComment;
const GUID guidHTMLScript = HTMLScriptGuid;

static CFullPropSpec psCharacterization( guidCharacterization,
                                         propidCharacterization );

const GUID guidDocSummary = defGuidDocSummary;
static CFullPropSpec psTitle( guidDocSummary, propidTitle );
static const GUID guidHtmlInformation = defGuidHtmlInformation;

static GUID const guidMeta = { 0xd1b5d3f0,
                               0xc0b3, 0x11cf,
                               0x9a, 0x92, 0x00, 0xa0,
                               0xc9, 0x08, 0xdb, 0xf1 };

inline unsigned DocSumScore( PROPID propid )
{
    switch ( propid )
    {
        case propidTitle :
            return scoreTitle;
        case propidSubject :
            return scoreSubject;
        case propidKeywords :
            return scoreKeywords;
        case propidComments :
            return scoreComments;
        case propidTemplate :
        case propidLastAuthor :
        case propidRevNumber :
        case propidAppName :
        case propidAuthor :
            return scoreIgnore;
    }

    return scoreIfNothingElse;
} //DocSumScore

inline unsigned HtmlPropScore( PROPID propid )
{
    switch ( propid )
    {
        case PID_HEADING_1 :
            return scoreHeader1;
        case PID_HEADING_2 :
            return scoreHeader2;
        case PID_HEADING_3 :
            return scoreHeader3;
        case PID_HEADING_4 :
            return scoreHeader4;
        case PID_HEADING_5 :
            return scoreHeader5;
        case PID_HEADING_6 :
            return scoreHeader6;
    }

    return scoreIgnore;
} //HtmlPropScore

//+-------------------------------------------------------------------------
//
//  Function:   StringToClsid
//
//  Synopsis:   Convert string containing CLSID to CLSID.
//              The string must be of the form:
//              {d1b5d3f0-c0b3-11cf-9a92-00a0c908dbf1}
//
//  Arguments:  [wszClass] -- string containg CLSID
//              [guidClass] -- output guid
//
//--------------------------------------------------------------------------

void StringToClsid( WCHAR *wszClass, GUID& guidClass )
{
    wszClass[9] = 0;
    guidClass.Data1 = wcstoul( &wszClass[1], 0, 16 );
    wszClass[14] = 0;
    guidClass.Data2 = (USHORT)wcstoul( &wszClass[10], 0, 16 );
    wszClass[19] = 0;
    guidClass.Data3 = (USHORT)wcstoul( &wszClass[15], 0, 16 );

    WCHAR wc = wszClass[22];
    wszClass[22] = 0;
    guidClass.Data4[0] = (unsigned char)wcstoul( &wszClass[20], 0, 16 );
    wszClass[22] = wc;
    wszClass[24] = 0;
    guidClass.Data4[1] = (unsigned char)wcstoul( &wszClass[22], 0, 16 );

    for ( int i = 0; i < 6; i++ )
    {
        wc = wszClass[27+i*2];
        wszClass[27+i*2] = 0;
        guidClass.Data4[2+i] = (unsigned char)wcstoul( &wszClass[25+i*2], 0, 16 );
        wszClass[27+i*2] = wc;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::CDocCharacterization, public
//
//  Synopsis:   constructor
//
//  Arguments:  [cwcAtMost] -- Max size of characterization.  0 --> Don't
//                             generate one.
//
//  History:    12-Jan-96       dlee    Created
//              20-Jun-97       KyleP   Make 0 --> no characterization
//
//----------------------------------------------------------------------------

CDocCharacterization::CDocCharacterization( unsigned cwcAtMost )
        : _queue( FALSE, cwcAtMost ),
          _scoreRawText( scoreRawText ),
          _cwcIgnoreBuf( 0 ),
          _fMetaDescriptionAdded( FALSE )
{
    _fIsGenerating = (0 != cwcAtMost);
}

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::~CDocCharacterization, public
//
//  Synopsis:   destructor
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

CDocCharacterization::~CDocCharacterization()
{
    // clean up anything left in the queue -- it should be empty, except for
    // the exception case.

    CSummaryText text;

    while ( _queue.DeQueue( text ) )
        delete [] text.GetText();
} //~CDocCharacterization

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::AddCleanedString, private
//
//  Synopsis:   Adds a noise-free string to the queue if it belongs
//
//  Arguments:  [pwcSummary] -- string to add to the summary
//              [cwcSummary] -- # of characters in the string
//              [utility]    -- score for the string
//              [fDeliniate] -- if TRUE, a termination is added to the string
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

BOOL CDocCharacterization::AddCleanedString(
    const WCHAR * pwcSummary,
    unsigned      cwcSummary,
    unsigned      utility,
    BOOL          fDeliniate )
{
    Win4Assert( _fIsGenerating );

    CSummaryText text( (WCHAR *) pwcSummary,
                       cwcSummary + ( fDeliniate ? cwcSummarySpace : 0 ),
                       utility );

    unsigned cDeQueue = 0;

    // Check if the item will make it on the queue

    if ( _queue.ShouldEnQueue( text, cDeQueue ) )
    {
        //
        // Don't add duplicates.  If the duplicate has a worse score than
        // the new item, remove it and add the new item.
        //

        CSummaryText testText;

        for ( unsigned x = 0; fDeliniate && x < _queue.Count(); x++ )
        {
            CSummaryText & testText = _queue.Peek( x );

            if ( testText.isSame( pwcSummary,
                                  __min( cwcSummary, testText.GetSize() ) ) )
            {
                if ( testText.GetUtility() < utility )
                {
                    delete [] testText.GetText();
                    _queue.Remove( x );

                    // don't have to dequeue anymore if the old duplicate
                    // is large enough

                    BOOL f = _queue.ShouldEnQueue( text, cDeQueue );
                    Win4Assert( f );
                    break;
                }
                else
                {
                    return TRUE;
                }
            }
        }

        // need to remove the worst item to make room for this one?

        for ( ; cDeQueue > 0; cDeQueue-- )
        {
            Win4Assert( 0 != _queue.Count() );

            CSummaryText temp;
            _queue.DeQueue( temp );
            delete [] temp.GetText();
        }

        Win4Assert( _queue.CurrentSize() <= _queue.MaxTotalSize() );

        // make a copy of the summary string and put in in the queue

        unsigned cwc = cwcSummary + ( fDeliniate ? cwcSummarySpace : 0 );

        XArray<WCHAR> xCopy( cwc );
        RtlCopyMemory( xCopy.GetPointer(),
                       pwcSummary,
                       cwcSummary * sizeof WCHAR );

        if ( fDeliniate )
            RtlCopyMemory( xCopy.GetPointer() + cwcSummary,
                           awcSummarySpace,
                           cwcSummarySpace * sizeof WCHAR );

        text.SetText( xCopy.GetPointer() );
        _queue.EnQueue( text );

        Win4Assert( _queue.CurrentSize() <= _queue.MaxTotalSize() );

        // if the EnQueue doesn't throw, the queue owns the memory

        xCopy.Acquire();

        return TRUE;
    }

    return FALSE;
} //_AddCleanedString

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::YankNoise, private
//
//  Synopsis:   Creates a new string that has "noise" stripped out.
//
//  Arguments:  [pwcIn]  -- string to add to the summary
//              [pwcOut] -- resulting cleaned string
//              [cwc]    -- in/out number of characters
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

const WORD C1_OK =  ( C1_DIGIT | C1_SPACE | C1_ALPHA );
const WORD C1_CP =  ( C1_CNTRL | C1_PUNCT );
const WORD C1_CSP = ( C1_CNTRL | C1_SPACE | C1_PUNCT );

inline BOOL isCP(      WORD wC1 ) { return 0 != (C1_CP & wC1); }
inline BOOL isCSP(     WORD wC1 ) { return 0 != (C1_CSP & wC1); }
inline BOOL isOK(      WORD wC1 ) { return 0 != (C1_OK & wC1); }
inline BOOL isDefined( WORD wC1 ) { return 0 != (0x200 & wC1); }

inline BOOL isSpace( WORD wC1 ) { return 0 != (C1_SPACE & wC1); }
inline BOOL isCntrl( WORD wC1 ) { return 0 != (C1_CNTRL & wC1); }
inline BOOL isPunct( WORD wC1 ) { return 0 != (C1_PUNCT & wC1); }

// For example: a Japanese vowel elongating symbol
inline BOOL isDiacritic( WORD wC3 ) { return 0 != (C3_DIACRITIC & wC3 ); }

void CDocCharacterization::YankNoise(
    const WCHAR * pwcIn,
    WCHAR *       pwcOut,
    unsigned &    cwc )
{
   Win4Assert( _fIsGenerating );

   WORD awType[ cwcMaxRawUsed ];

   Win4Assert( cwc <= cwcMaxRawUsed );

   if ( GetStringTypeW( CT_CTYPE1, pwcIn, cwc, awType ) )
   {
       // eat any leading white space or punctuation

       unsigned iIn = 0;
       while ( ( iIn < cwc ) &&
               ( isCSP( awType[ iIn ] ) ) )
           iIn++;

       // make it look like the previous line ended with a CR/LF

       WORD wPrev = C1_CNTRL;
       unsigned iOut = 0;

       // filter the text, stripping redundant punctuation and white space

       while ( ( iIn < cwc ) &&
               ( iOut < cwcMaxRawUsed ) )
       {
           if ( ! ( isSpace( wPrev ) && isSpace( awType[ iIn ] ) ) )
           {
               // convert control characters and wcParagraph to ' '

               if ( ( isCntrl( awType[ iIn ] ) ) ||
                    ( wcParagraph == pwcIn[ iIn ] ) )
                   pwcOut[ iOut++ ] = L' ';
               else if ( isOK( awType[ iIn ] ) )
                   pwcOut[ iOut++ ] = pwcIn[ iIn ];
               else if ( ( isPunct( awType[ iIn ] ) ) &&
                         ( !isCP( wPrev ) ) )
                   pwcOut[ iOut++ ] = pwcIn[ iIn ];
               else
               {
                   if ( isDefined( awType[ iIn ] ) )
                   {
                       WCHAR pwszSingleChar[2];
                       pwszSingleChar[0] = pwcIn[iIn];
                       pwszSingleChar[1] = L'0';
                       WORD wType;

                       GetStringTypeW( CT_CTYPE3, pwszSingleChar, 1, &wType );

                       if ( isDiacritic( wType ) )
                           pwcOut[ iOut++ ] = pwcIn[ iIn ];
                   }
               }
           }

           wPrev = awType[ iIn++ ];
       }

       // eat any trailing spaces

       while ( iOut > 0 && L' ' == pwcOut[iOut-1] )
           iOut--;

       cwc = iOut;
   }
   else
   {
       cwc = 0;
   }
} //_YankNoise

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::Add, private
//
//  Synopsis:   Preps and adds a string to the queue.
//
//  Arguments:  [pwcSummary] -- string to add to the summary
//              [cwcSummary] -- # characters in the string
//              [utility]    -- score for the string, higher is better
//              [fYankNoise] -- if TRUE, noise is removed from the string
//
//  Returns:    FALSE if the item was rejected from a full queue because
//              it was worse than anything in the queue, TRUE otherwise.
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

const unsigned cwcTextAtATime = 25;

BOOL CDocCharacterization::Add(
    const WCHAR * pwcSummary,
    unsigned      cwcSummary,
    unsigned      utility,
    BOOL          fYankNoise )
{
    Win4Assert( _fIsGenerating );

    if ( scoreIgnore == utility )
        return FALSE;

    if ( 0 != cwcSummary )
    {
        unsigned cwcBuf = __min( cwcSummary, cwcMaxRawUsed );
        WCHAR awcBuf[ cwcMaxRawUsed ];

        if ( fYankNoise )
        {
            YankNoise( pwcSummary, awcBuf, cwcBuf );

            // no text left after removal of noise?

            if ( 0 == cwcBuf )
                return TRUE;

            // something we should ignore (the raw text version of the title)?

            if ( ( _cwcIgnoreBuf == cwcSummarySpace ) &&
                 ( !wcsncmp( awcBuf, _awcIgnoreBuf, _cwcIgnoreBuf ) ) )
                return TRUE;
        }
        else
        {
            RtlCopyMemory( awcBuf, pwcSummary, cwcBuf * sizeof WCHAR );
        }

        // if it looks like it's one sentence, send it all at once

        if ( ( utility > scoreRawText ) ||
             ( cwcBuf <= cwcMaxIgnoreBuf ) )
        {
            return AddCleanedString( awcBuf, cwcBuf, utility, fYankNoise );
        }
        else
        {
            // large block of text, so send a little at a time to the queue.

            for ( unsigned owc = 0; owc < cwcBuf; )
            {
                unsigned cwcNow = __min( cwcBuf - owc, cwcTextAtATime );

                if ( !AddCleanedString( awcBuf + owc,
                                        cwcNow,
                                        utility--,
                                        FALSE ) )
                {
                    return FALSE;
                }

                owc += cwcNow;
            }
        }
    }

    return TRUE;
} //_Add

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::AddRawText, private
//
//  Synopsis:   Adds some text to the queue with a utility of raw text.
//
//  Arguments:  [pwcRawText] -- string to add to the summary
//              [cwcText]    -- # characters in the string
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

void CDocCharacterization::AddRawText(
    const WCHAR * pwcRawText,
    unsigned      cwcText )
{
   Win4Assert( _fIsGenerating );
   Win4Assert( _queue.CurrentSize() <= _queue.MaxTotalSize() );

   if ( 0 != _scoreRawText )
   {
       if ( Add( pwcRawText, cwcText, _scoreRawText ) )
           _scoreRawText -= cwcText / cwcTextAtATime;
       else
           _scoreRawText = 0;
   }
} //_AddRawText

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::RemoveLowScoringItems, private
//
//  Synopsis:   Removes low-scoring items from the queue
//
//  Arguments:  [iLimit] -- items scoring <= iLimit are removed
//
//  History:    29-Aug-96       dlee    Created
//
//----------------------------------------------------------------------------

void CDocCharacterization::RemoveLowScoringItems(
    unsigned iLimit )
{
    Win4Assert( _fIsGenerating );

    while ( 0 != _queue.Count() )
    {
        CSummaryText &top = _queue.PeekTop();

        if ( top.GetUtility() <= iLimit )
        {
            CSummaryText text;
            _queue.DeQueue( text );
            delete [] text.GetText();
        }
        else
        {
            break;
        }
    }
} //_RemoveLowScoringItems

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::Get, public
//
//  Synopsis:   Returns the summary in one string.
//
//  Arguments:  [awcSummary]  -- output string
//              [cwcSummary]  -- in/out the length of the string
//              [fUseRawText] -- TRUE if raw text should be included
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

void CDocCharacterization::Get(
    WCHAR *    awcSummary,
    unsigned & cwcSummary,
    BOOL       fUseRawText )
{
    Win4Assert( _fIsGenerating );

    // Caller should give us a buffer large enough to hold the
    // characterization they requested and a null termination.

    Win4Assert( _queue.CurrentSize() <= _queue.MaxTotalSize() );
    Win4Assert( cwcSummary > _queue.MaxTotalSize() );
    Win4Assert( cwcSummary > _queue.CurrentSize() );

    // If we shouldn't include raw text, pop low-scoring items off the
    // top of the queue queue.

    if ( !fUseRawText )
        RemoveLowScoringItems( scoreRawText );

    // If a meta description was added, there's no point in tacking on
    // additional text in the abstract.

    if ( _fMetaDescriptionAdded )
    {
        Win4Assert( cwcSummary > _awcMetaDescription.Count() );
        RtlCopyMemory( awcSummary,
                       _awcMetaDescription.GetPointer(),
                       _awcMetaDescription.SizeOf() );
        cwcSummary = _awcMetaDescription.Count();
        awcSummary[ cwcSummary ] = 0;
    }
    else
    {
        cwcSummary = _queue.CurrentSize();

        // The item on the top of the queue is the least useful item, so
        // we have to invert the order.

        WCHAR *pwcSummary = awcSummary + cwcSummary;
        *pwcSummary = 0;

        CSummaryText text;
        while ( _queue.DeQueue( text ) )
        {
            pwcSummary -= text.GetSize();
            RtlCopyMemory( pwcSummary,
                           text.GetText(),
                           text.GetSize() * sizeof WCHAR );
            delete [] text.GetText();
        }

        Win4Assert( pwcSummary == awcSummary );
    }
} //GetSummary

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::Ignore, private
//
//  Synopsis:   Tells the class to ignore this string in the generation
//              of a summary.  This is probably the "title" of an html
//              document, which is stored in a separate property, and it
//              would be redundant to store it twice.
//
//  Arguments:  [pwcIgnore] -- string to ignore
//              [cwcText]   -- # characters in the string
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

void CDocCharacterization::Ignore(
    const WCHAR * pwcIgnore,
    unsigned      cwcText )
{
    Win4Assert( _fIsGenerating );

    // clean and save the string to ignore

    _cwcIgnoreBuf = __min( cwcText, cwcMaxIgnoreBuf );
    YankNoise( pwcIgnore, _awcIgnoreBuf, _cwcIgnoreBuf );

    // remove any instance of the string in the queue

    unsigned cwcTest = _cwcIgnoreBuf + cwcSummarySpace;

    for ( unsigned x = 0; x < _queue.Count(); x++ )
    {
        CSummaryText &testText = _queue.Peek( x );

        if ( ( cwcTest == testText.GetSize() ) &&
             ( testText.isSame( _awcIgnoreBuf, _cwcIgnoreBuf ) ) )
        {
            delete [] testText.GetText();
            _queue.Remove( x );

            break;
        }
    }
} //_Ignore

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::Add, public
//
//  Synopsis:   Adds a string value to the queue if appropriate, based on the
//              propspec and the nature of the string.
//
//  Arguments:  [pwcSummary]  -- string to ignore
//              [cwcSummary]  -- # characters in the string
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

void CDocCharacterization::Add( CStorageVariant const & var,
                                CFullPropSpec &         ps )
{
    // if the meta description has been added already, we're done.

    if ( _fMetaDescriptionAdded || !_fIsGenerating )
        return;

#if CIDBG == 1
    ciDebugOut(( DEB_DOCSUM, "docchar::Add variant type %#x\n", var.vt ));
    if ( VT_LPWSTR == var.vt )
        ciDebugOut(( DEB_DOCSUM, "  wstr: '%ws'\n", var.pwszVal ));
    else if ( VT_LPSTR == var.vt )
        ciDebugOut(( DEB_DOCSUM, "  str: '%s'\n", var.pszVal ));

    ciDebugOut(( DEB_DOCSUM,
                 "  guid {%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                 ps.GetPropSet().Data1,
                 ps.GetPropSet().Data2,
                 ps.GetPropSet().Data3,
                 ps.GetPropSet().Data4[0], ps.GetPropSet().Data4[1],
                 ps.GetPropSet().Data4[2], ps.GetPropSet().Data4[3],
                 ps.GetPropSet().Data4[4], ps.GetPropSet().Data4[5],
                 ps.GetPropSet().Data4[6], ps.GetPropSet().Data4[7] ));
    if ( ps.IsPropertyName() )
        ciDebugOut(( DEB_DOCSUM, "  string: '%ws'\n", ps.GetPropertyName() ));
    else
        ciDebugOut(( DEB_DOCSUM, "  id: '%d'\n", ps.GetPropertyPropid() ));
#endif // CIDBG

    // title is added as plain text and _Ignore() is called then.

    if ( ps != psTitle )
    {
        if ( VT_LPWSTR == var.Type() )
        {
            // Don't put file names or meta properties in abstracts.

            if ( ( psRevName != ps ) &&
                 ( psName != ps ) )
            {
                if ( guidMeta == ps.GetPropSet() )
                {
                    // This is the ideal string, based on html spec.
                    // Toss all other meta property values.

                    if ( ( ps.IsPropertyName() ) &&
                         ( 0 == _wcsicmp( ps.GetPropertyName(), pwcDescription ) ) )
                    {
                        _fMetaDescriptionAdded = TRUE;

                        // make a copy of the meta description

                        if ( 0 == var.GetLPWSTR() )
                        {
                            _awcMetaDescription.Init( 0 );
                        }
                        else
                        {
                            unsigned cwc = __min( wcslen( var.GetLPWSTR() ),
                                                  _queue.MaxTotalSize() );
                            _awcMetaDescription.Init( cwc );
                            RtlCopyMemory( _awcMetaDescription.GetPointer(),
                                           var.GetLPWSTR(),
                                           _awcMetaDescription.SizeOf() );
                        }

                        // toss everything in the queue

                        CSummaryText text;
                        while ( _queue.DeQueue( text ) )
                            delete [] text.GetText();
                    }
                }
                else if ( 0 != var.GetLPWSTR() &&
                          ( guidDocSummary == ps.GetPropSet() ) )
                {
                    Win4Assert( ps.IsPropertyPropid() );

                    Add( var.GetLPWSTR(),
                         wcslen( var.GetLPWSTR() ),
                         DocSumScore( ps.GetPropertyPropid() ) );
                }
                else
                {
                    if ( 0 != var.GetLPWSTR() )
                        Add( var.GetLPWSTR(),
                             wcslen( var.GetLPWSTR() ),
                             scoreOtherProperty );
                }
            }
        } // if VT_LPWSTR
    } // ps != psTitle
} //Add

//+---------------------------------------------------------------------------
//
//  Method:     CDocCharacterization::Add, public
//
//  Synopsis:   Adds a string to the queue if appropriate, based on the
//              propspec and the nature of the string.
//
//  Arguments:  [pwcSummary]  -- string to ignore
//              [cwcSummary]  -- # characters in the string
//              [ps]          -- Property being added
//
//  History:    12-Jan-96       dlee    Created
//
//----------------------------------------------------------------------------

void CDocCharacterization::Add(
    const WCHAR *  pwcSummary,
    unsigned       cwcSummary,
    FULLPROPSPEC & ps )
{

    Win4Assert( _queue.CurrentSize() <= _queue.MaxTotalSize() );

    // if the meta description has been added already, we're done.

    if ( _fMetaDescriptionAdded || !_fIsGenerating )
        return;

#if CIDBG == 1
    ciDebugOut(( DEB_DOCSUM, "docchar::Add: '%.*ws'\n", cwcSummary, pwcSummary ));
    ciDebugOut(( DEB_DOCSUM,
                 "  guid {%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                 ps.guidPropSet.Data1,
                 ps.guidPropSet.Data2,
                 ps.guidPropSet.Data3,
                 ps.guidPropSet.Data4[0], ps.guidPropSet.Data4[1],
                 ps.guidPropSet.Data4[2], ps.guidPropSet.Data4[3],
                 ps.guidPropSet.Data4[4], ps.guidPropSet.Data4[5],
                 ps.guidPropSet.Data4[6], ps.guidPropSet.Data4[7] ));
    if ( PRSPEC_LPWSTR == ps.psProperty.ulKind )
        ciDebugOut(( DEB_DOCSUM, "  string: '%ws'\n", ps.psProperty.lpwstr ));
    else
        ciDebugOut(( DEB_DOCSUM, "  id: '%d'\n", ps.psProperty.propid ));
#endif // CIDBG

    // add raw text unless it's the title

    if ( guidHtmlInformation == ps.guidPropSet )
    {
        Add( pwcSummary,
             cwcSummary,
             HtmlPropScore( ps.psProperty.propid ) );
    }
    else if ( guidHTMLUrl     == ps.guidPropSet ||
              guidHTMLComment == ps.guidPropSet )
    {
        // just ignore it
    }
    else if ( guidHTMLScript == ps.guidPropSet )
    {
        // note: the current html filter doesn't emit scripts, but just
        //       in case that changes this case is checked.

        ciDebugOut(( DEB_DOCSUM, "ignoring script\n" ));
    }
    else if ( psTitle == * ( (CFullPropSpec *)&ps ) )
    {
        Ignore( pwcSummary, cwcSummary );
    }
    else
    {
        AddRawText( pwcSummary, cwcSummary );
    }

    Win4Assert( _queue.CurrentSize() <= _queue.MaxTotalSize() );
} //Add
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\fdriver.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       FDRIVER.CXX
//
//  Contents:   Filter driver
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciole.hxx>
#include <drep.hxx>
#include <tfilt.hxx>
#include <tsource.hxx>
#include <fwevent.hxx>
#include <cievtmsg.h>
#include <propspec.hxx>
#include <imprsnat.hxx>
#include <oleprop.hxx>
#include <fdaemon.hxx>
#include <ntopen.hxx>
#include <ciguid.hxx>

#include "fdriver.hxx"
#include "propfilt.hxx"
#include "docsum.hxx"

static GUID guidNull = { 0x00000000,
                         0x0000,
                         0x0000,
                         { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };

//
// Local procedures
//

BOOL IsNonIndexableProp( CFullPropSpec const & fps, PROPVARIANT const &  var );


static CFullPropSpec psRevName( guidQuery, DISPID_QUERY_REVNAME );
static CFullPropSpec psName( guidStorage, PID_STG_NAME );
static CFullPropSpec psPath( guidStorage, PID_STG_PATH);
static CFullPropSpec psDirectory( guidStorage, PID_STG_DIRECTORY );

static CFullPropSpec psCharacterization( guidCharacterization,
                                         propidCharacterization );

static CFullPropSpec psTitle( guidDocSummary, propidTitle );
static GUID guidHtmlInformation = defGuidHtmlInformation;

static CFullPropSpec psAttrib( guidStorage, PID_STG_ATTRIBUTES );

//
// Helper functions
//

inline BOOL IsSpecialPid( FULLPROPSPEC const & fps )
{
    return ( fps.psProperty.ulKind == PRSPEC_PROPID &&
             fps.psProperty.propid <= PID_CODEPAGE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterDriver::CFilterDriver, public
//
//  Arguments:
//      [drep]               -- pointer to the data repository for filtered
//                              information
//      [perfobj]            -- performance object to update
//      [cFilteredBlocks]    -- Number of blocks filtered for the current
//                              document
//      [cat]                -- reference to a catalog proxy
//
//----------------------------------------------------------------------------

CFilterDriver::CFilterDriver ( CDataRepository    * drep,
                               ICiCAdviseStatus   * pAdviseStatus,
                               ICiCFilterClient * pFilterClient,
                               CCiFrameworkParams & params,
                               CI_CLIENT_FILTER_CONFIG_INFO const & configInfo,
                               ULONG & cFilteredBlocks,
                               CNonStoredProps & NonStoredProps,
                               ULONG cbBuf )
        : _drep( drep ),
          _llFileSize( 0 ),
          _cFilteredBlocks( cFilteredBlocks ),
          _params( params ),
          _pAdviseStatus( pAdviseStatus ),
          _pFilterClient( pFilterClient ),
          _configInfo( configInfo ),
          _NonStoredProps( NonStoredProps ),
          _cbBuf( cbBuf ),
          _attrib(0),
          _lcidSystemDefault( GetSystemDefaultLCID() )
{
}

//+---------------------------------------------------------------------------
//
//  Member:    CFilterDriver::FillEntryBuffer, public
//
//  Synopsis:  Filters the document that IFilter loaded.
//
//  Arguments: [pbDocName] -- Document in filter
//             [cbDocName] -- Size of [pbDocName]
//
//  Notes:     Calls to SwitchToThread() give up processor.
//
//----------------------------------------------------------------------------

STATUS CFilterDriver::FillEntryBuffer( BYTE const * pbDocName, ULONG cbDocName )
{
    _status = CANNOT_OPEN_STREAM;

    BOOL fFilterContents = FALSE;       // Assume we should NOT filter contents

    //
    //  Get opendoc for access to stored state and safely save it
    //

    ICiCOpenedDoc *pDocument;
    SCODE sc = _pFilterClient->GetOpenedDoc( &pDocument );   SwitchToThread();

    if ( !SUCCEEDED( sc ) )
    {
        ciDebugOut(( DEB_ERROR, "Unable to get OpenedDoc - %x\n", sc ));
        return _status;
    }

    XInterface<ICiCOpenedDoc> Document( pDocument );

    //
    //  Attempt to open the document
    //

    sc = Document->Open( pbDocName, cbDocName );
    SwitchToThread();

    if (!SUCCEEDED( sc ))
    {
        if ( ::IsSharingViolation( sc ) )
        {
            _status = CI_SHARING_VIOLATION;
        }
        else
        {
            ciDebugOut(( DEB_IWARN, "Unable to open docname at 0x%X - 0x%X\n",
                                     pbDocName, sc ));

            if ( FILTER_E_UNREACHABLE == sc )
                _status = CI_NOT_REACHABLE;

            return _status;
        }
    }

    // Initialize LCIDs counter.

    _cLCIDs = 0;

    //
    // Attempt to filter properties
    //

    CDocCharacterization docChar( _params.GenerateCharacterization() ?
                                  _params.GetMaxCharacterization() : 0 );

    //
    //  Get the stat property enumerator and filter based on it.
    //

    CDocStatPropertyEnum CPEProp( Document.GetPointer() );   SwitchToThread();

    fFilterContents = CPEProp.GetFilterContents( _params.FilterDirectories() );
    _llFileSize = CPEProp.GetFileSize( );

    FilterObject( CPEProp,
                  *_drep,
                  docChar );                                 SwitchToThread();

    //
    //  filter security on the file.
    //

    if ( _configInfo.fSupportsSecurity )
    {
        FilterSecurity( Document.GetPointer( ), *_drep );    SwitchToThread();
    }

    if ( CI_SHARING_VIOLATION == _status )
        return _status;

    _status = SUCCESS;

    BOOL fFilterOleProperties = fFilterContents;
    BOOL fKnownFilter = TRUE;
    BOOL fIndexable = TRUE;

    if ( fFilterContents && ( 0 == ( FILE_ATTRIBUTE_ENCRYPTED & _attrib )) )
    {
        //
        // Filter time in Mb / hr
        //

        CFwPerfTime filterCounter( _pAdviseStatus,
                                   CI_PERF_FILTER_TIME,
                                   1024*1024, 1000*60*60 );
        filterCounter.TStart();

        CFwPerfTime  bindCounter( _pAdviseStatus,
                                  CI_PERF_BIND_TIME );
        bindCounter.TStart();

        IFilter *pTmpIFilter;
        sc = Document->GetIFilter( &pTmpIFilter );           SwitchToThread();

        if ( !SUCCEEDED( sc ) )
            pTmpIFilter = 0;

        _pIFilter.Set( pTmpIFilter );

        bindCounter.TStop( );

        if ( _pIFilter.IsNull( ))
        {
            //
            // We could not obtain an IFilter but we have filtered properties.
            // We should just return whatever status we have.
            //
            ciDebugOut(( DEB_IWARN,
                         "Did not get a filter for document 0x%X\n",
                         pbDocName ));

            if ( ::IsSharingViolation( sc ))
                _status = CI_SHARING_VIOLATION;
            else if ( FILTER_E_UNREACHABLE == sc )
                _status = CI_NOT_REACHABLE;

            if ( fFilterOleProperties )
            {
                //
                //  No filter, but it might have properties.  Get them.
                //
        
                COLEPropertyEnum oleProp( Document.GetPointer( ) );                      SwitchToThread();
                BOOL fIsStorage = oleProp.IsStorage();
                if (fIsStorage)
                    FilterObject( oleProp,
                                  *_drep,
                                  docChar );                                             SwitchToThread();
            }
        
            return _status;
        }

        ULONG ulFlags;
        STAT_CHUNK statChunk;
        sc = _pIFilter->Init( IFILTER_INIT_CANON_PARAGRAPHS |
                              IFILTER_INIT_CANON_HYPHENS |
                              IFILTER_INIT_CANON_SPACES |
                              IFILTER_INIT_APPLY_INDEX_ATTRIBUTES |
                              IFILTER_INIT_INDEXING_ONLY,
                              0,
                              0,
                              &ulFlags );                    SwitchToThread();
        if ( FAILED(sc) )
        {
            ciDebugOut(( DEB_WARN, "IFilter->Init() failed.\n" ));
            THROW( CException( sc ) );
        }

        fFilterOleProperties = (( ulFlags & IFILTER_FLAGS_OLE_PROPERTIES ) != 0);

        //
        // Determine the maximum number of filtered blocks allowed for this
        // file.
        //

        unsigned __int64 ullMultiplier = _params.GetMaxFilesizeMultiplier();
        unsigned __int64 ullcbBuf = _cbBuf;
        unsigned __int64 ullcbFile = _llFileSize;
        unsigned __int64 ullcBlocks = 1 + ( ullcbFile / ullcbBuf );
        unsigned __int64 ullmaxBlocks =  ullcBlocks * ullMultiplier;

        if ( ullmaxBlocks > ULONG_MAX )
            ullmaxBlocks = ULONG_MAX;

        ULONG ulMaxFilteredBlocks = (ULONG) ullmaxBlocks;

        ciDebugOut(( DEB_ITRACE,
                     "cbfile %I64d, cBlocks %I64d, maxcBlocks %I64d\n",
                     ullcbFile, ullcBlocks, ullmaxBlocks ));

        //
        //  Get the first chunk
        //

        do
        {
            sc = _pIFilter->GetChunk( &statChunk );          SwitchToThread();
            if (SUCCEEDED(sc))
               RegisterLocale(statChunk.locale);
        }
        while ( SUCCEEDED(sc) && IsSpecialPid( statChunk.attribute ) );

        _drep->InitFilteredBlockCount( ulMaxFilteredBlocks );
        _cFilteredBlocks = 0;

        NTSTATUS Status = STATUS_SUCCESS;

        TRY
        {
            BOOL fBadEmbeddingReport = FALSE;

            while ( SUCCEEDED(sc) ||
                    FILTER_E_LINK_UNAVAILABLE == sc ||
                    FILTER_E_EMBEDDING_UNAVAILABLE == sc )
            {
                BOOL fInUse;
                Document->IsInUseByAnotherProcess( &fInUse );          SwitchToThread();
                if ( fInUse )
                {
                    _status = FILTER_EXCEPTION; // Force retry in driver
                    break;                      // Stop filtering this doc
                }

                _cFilteredBlocks = _drep->GetFilteredBlockCount();

                if ( SUCCEEDED(sc) )
                {
                    if ( IsSpecialPid( statChunk.attribute ) )
                    {
                        sc = _pIFilter->GetChunk( &statChunk );        SwitchToThread();

                        if (SUCCEEDED(sc))
                           RegisterLocale(statChunk.locale);
                        continue;
                    }

                    //
                    // Skip over unknown chunks.
                    //

                    if ( 0 == (statChunk.flags & (CHUNK_TEXT | CHUNK_VALUE)) )
                    {
                        ciDebugOut(( DEB_WARN,
                                     "Filtering of docname at 0x%X produced bogus chunk (not text or value)\n",
                                     pbDocName ));
                        sc = _pIFilter->GetChunk( &statChunk );        SwitchToThread();

                        if (SUCCEEDED(sc))
                           RegisterLocale(statChunk.locale);
                        continue;
                    }

                    if ( statChunk.flags & CHUNK_VALUE )
                    {
                        PROPVARIANT * pvar = 0;

                        sc = _pIFilter->GetValue( &pvar );

                        if ( SUCCEEDED(sc) )
                        {
                            XPtr<CStorageVariant> xvar( (CStorageVariant *)(ULONG_PTR)pvar );
                            CFullPropSpec * pps = (CFullPropSpec *)(ULONG_PTR)(&statChunk.attribute);


                            //
                            // HACK #275: If we see a ROBOTS=NOINDEX tag, then bail out.
                            //

                            if ( IsNonIndexableProp( *pps, *pvar ) )
                            {
                                ciDebugOut(( DEB_WARN,
                                    "Document %x is not indexable (robots Meta-tag)\n",
                                     pbDocName ));

                                sc = S_OK;
                                fFilterOleProperties = FALSE;
                                fIndexable = FALSE;

                                break;
                            }

                            // Index this property twice -- once with default locale and with
                            // the chunk locale.

                            FilterProperty( *pvar, *pps, *_drep, docChar, statChunk.locale );      SwitchToThread();

                            if (_lcidSystemDefault != statChunk.locale)
                            {
                                FilterProperty( *pvar, *pps, *_drep, docChar, _lcidSystemDefault );      SwitchToThread();
                            }


                            //
                            // Only fetch next if we're done with this chunk.
                            //

                            if ( 0 == (statChunk.flags & CHUNK_TEXT) || !SUCCEEDED(sc) )
                            {
                                sc = _pIFilter->GetChunk( &statChunk );          SwitchToThread();

                                if (SUCCEEDED(sc))
                                    RegisterLocale(statChunk.locale);
                                continue;
                            }
                        }
                    }

                    if ( (statChunk.flags & CHUNK_TEXT) && SUCCEEDED(sc) )
                    {
                        if ( _drep->PutLanguage( statChunk.locale ) &&
                             _drep->PutPropName( *((CFullPropSpec *)&statChunk.attribute) ) )
                        {
                            CTextSource tsource( _pIFilter.GetPointer( ), statChunk );

                            docChar.Add( tsource.awcBuffer + tsource.iCur,
                                         tsource.iEnd - tsource.iCur,
                                         statChunk.attribute );                  SwitchToThread();

                            _drep->PutStream( &tsource );                        SwitchToThread();
                            sc = tsource.GetStatus();
                        }
                        else
                        {
                            sc = _pIFilter->GetChunk( &statChunk );              SwitchToThread();

                            if (SUCCEEDED(sc))
                                RegisterLocale(statChunk.locale);
                        }

                        if ( sc == FILTER_E_NO_TEXT && (statChunk.flags & CHUNK_VALUE) )
                            sc = S_OK;
                    }

                }

                if ( FILTER_E_EMBEDDING_UNAVAILABLE == sc )
                {
                    if ( !fBadEmbeddingReport &&
                         (_params.GetEventLogFlags()&CI_EVTLOG_FLAGS_FAILED_EMBEDDING) )
                    {
                        ReportFilterEmbeddingFailure( pbDocName, cbDocName );
                        fBadEmbeddingReport = TRUE;
                    }

                    sc = _pIFilter->GetChunk( &statChunk );                      SwitchToThread();

                    if (SUCCEEDED(sc))
                        RegisterLocale(statChunk.locale);
                }
                else if ( FILTER_E_LINK_UNAVAILABLE == sc )
                {
                    sc = _pIFilter->GetChunk( &statChunk );                      SwitchToThread();

                    if (SUCCEEDED(sc))
                        RegisterLocale(statChunk.locale);
                }
            }
        }
        CATCH ( CException, e )
        {
            Status = e.GetErrorCode();
            ciDebugOut(( DEB_IERROR,
                         "Exception 0x%x thrown from filter DLL while filtering docName at 0x%X\n",
                          Status,
                          pbDocName ));
        }
        END_CATCH

        if ( !NT_SUCCESS(Status) && Status != FDAEMON_E_TOOMANYFILTEREDBLOCKS )
        {
            THROW( CException(FDAEMON_E_FATALERROR) );
        }

        if ( Status == FDAEMON_E_TOOMANYFILTEREDBLOCKS )
        {
            Win4Assert( _drep->GetFilteredBlockCount() > ulMaxFilteredBlocks );

            LogOverflow( pbDocName, cbDocName );

            //
            // Force exit from the loop
            //
            sc = FILTER_E_END_OF_CHUNKS;
        }

        _pIFilter.Free( );

        filterCounter.TStop( (ULONG)_llFileSize );
    }

    if ( FILTER_E_END_OF_CHUNKS != sc &&
         FILTER_E_PARTIALLY_FILTERED != sc &&
         FAILED( sc ) )
    {
        ciDebugOut(( DEB_IWARN, "Filter document at 0x(%X) returned SCODE 0x%x\n",
                     pbDocName, sc ));
        QUIETTHROW( CException( sc ) );
    }

    BOOL fIsStorage = FALSE;

    if ( fFilterOleProperties )
    {
        //
        //  filter ole properties only if it is a docfile
        //

        COLEPropertyEnum oleProp( Document.GetPointer( ) );                      SwitchToThread();
        fIsStorage = oleProp.IsStorage();
        if (fIsStorage)
            FilterObject( oleProp,
                          *_drep,
                          docChar );                                             SwitchToThread();
    }

    //
    // Store the document characterization in the property cache.
    // Don't bother if characterization is turned off.
    //

    if ( _params.GenerateCharacterization() )
    {
        PROPVARIANT var;
        WCHAR awcSummary[ CI_MAX_CHARACTERIZATION_MAX + 1 ];

        if ( fIndexable && docChar.HasCharacterization() )
        {
            unsigned cwcSummary = sizeof awcSummary / sizeof WCHAR;

            // Use the raw text in the abstract unless we defaulted
            // to the text filter and the file has ole properties.

            BOOL fUseRawText = fKnownFilter || !fIsStorage;

            docChar.Get( awcSummary, cwcSummary, fUseRawText );                  SwitchToThread();

            if ( 0 == cwcSummary )
            {
                var.vt = VT_EMPTY;
            }
            else
            {
                var.vt = VT_LPWSTR;
                var.pwszVal = awcSummary;
            }
        }
        else
        {
            var.vt = VT_EMPTY;
        }

        _drep->StoreValue( psCharacterization, var );                            SwitchToThread();
    }

    return _status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterDriver::LogOverflow
//
//  Synopsis:   Notifies the client that there were too many blocks in the
//              given document
//
//  Arguments:  [pbDocName] - Document Name
//              [cbDocName] - Number of bytes in the document name.
//
//  History:    1-22-97   srikants   Created
//
//----------------------------------------------------------------------------

void CFilterDriver::LogOverflow( BYTE const * pbDocName, ULONG cbDocName )
{

    PROPVARIANT var[2];

    var[0].vt = VT_VECTOR | VT_UI1;
    var[0].caub.cElems = cbDocName;
    var[0].caub.pElems = (BYTE *) pbDocName;

    var[1].vt = VT_UI4;
    var[1].ulVal = _params.GetMaxFilesizeMultiplier();

    SCODE sc = _pAdviseStatus->NotifyStatus( CI_NOTIFY_FILTER_TOO_MANY_BLOCKS,
                                       2,
                                       var );

    if ( !SUCCEEDED(sc) )
    {
        ciDebugOut(( DEB_WARN,
                     "Failed to report filter to many blocks event. Error 0x%X\n",
                     sc ));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterDriver::ReportFilterEmbeddingFailure
//
//  Synopsis:   Notifies the client that there was a failure filtering an
//              embedding.
//
//  Arguments:  [pbDocName] - Document name
//              [cbDocName] - Number of bytes in the serialized document name
//
//  History:    1-22-97   srikants   Created
//
//----------------------------------------------------------------------------

void CFilterDriver::ReportFilterEmbeddingFailure( BYTE const * pbDocName, ULONG cbDocName )
{
    PROPVARIANT var;
    var.vt = VT_VECTOR | VT_UI1;
    var.caub.cElems = cbDocName;
    var.caub.pElems = (BYTE *) pbDocName;

    SCODE sc = _pAdviseStatus->NotifyStatus( CI_NOTIFY_FILTER_EMBEDDING_FAILURE,
                                       1,
                                       &var );

    if ( !SUCCEEDED(sc) )
    {
        ciDebugOut(( DEB_WARN,
                     "Failed to report filter embedding failure event. Error 0x%X\n",
                     sc ));
    }
}

//+---------------------------------------------------------------------------
//
//  Method:    CFilterDriver::FilterProperty
//
//  Arguments: [var]     -- Property value
//             [ps]      -- Property ID
//             [drep]    -- Data repository for filtered information
//             [docChar] -- Characterization
//
//  Notes:     Calls to SwitchToThread() give up processor.
//
//----------------------------------------------------------------------------

inline void CFilterDriver::FilterProperty( CStorageVariant const & var,
                                           CFullPropSpec &         ps,
                                           CDataRepository &       drep,
                                           CDocCharacterization &  docChar,
                                           LCID locale )
{
    //
    //  Filter one very special property: Backwards name
    //

    if (ps == psName && var.Type( ) == VT_LPWSTR)
    {
        const WCHAR *pwszPath = var.GetLPWSTR( );

        int j = wcslen( pwszPath );
        XGrowable<WCHAR> xwcsRevName( j + 1 );
        int i;

        for ( i = 0; i < j; i++ )
        {
            xwcsRevName[i] = pwszPath[j - 1 - i];
        }

        xwcsRevName[i] = L'\0';

        PROPVARIANT Variant;
        Variant.vt      = VT_LPWSTR;
        Variant.pwszVal = xwcsRevName.Get();

        //
        //  Cast to avoid turning the PROPVARIANT into a CStorageVariant for no good
        //  reason.  Convert involves alloc/free.
        //

        CStorageVariant const * pvar = (CStorageVariant const *)(ULONG_PTR)(&Variant);
        FilterProperty( *pvar, psRevName, drep, docChar, 0 );                       SwitchToThread();

    }

    //
    //  Don't filter paths
    //

    if ( ps != psPath )
    {
        Win4Assert( psDirectory != ps );

        vqDebugOut(( DEB_FILTER, "Filter property 0x%x\n", ps.GetPropertyPropid() ));

        //
        //  Save some property values for use in document characterization
        //

        docChar.Add( var, ps );                                                  SwitchToThread();

        //
        //  output the property to the data repository
        //

        drep.PutLanguage( locale );
        drep.PutPropName( ps );
        drep.PutValue( var );                                                    SwitchToThread();

        // Store the value in the property cache if it should be stored there

        if ( !_NonStoredProps.IsNonStored( ps ) )
        {
            BOOL fStoredInCache;

            if ( IsNullPointerVariant( (PROPVARIANT *) & var ) )
            {
                PROPVARIANT propVar;
                propVar.vt = VT_EMPTY;
                fStoredInCache = drep.StoreValue( ps, propVar );                 SwitchToThread();
            }
            else
            {
                fStoredInCache = drep.StoreValue( ps, var );                     SwitchToThread();
            }

            // should we ignore this property in the future?

            if ( !fStoredInCache )
                _NonStoredProps.Add( ps );
        }
    }

    if ( ps == psAttrib )
        _attrib = var.GetUI4();
} //FilterProperty

//+---------------------------------------------------------------------------
//
//  Method:   CFilterDriver::FilterObject
//
//  Arguments: [propEnum]  -- iterator for properties in a file
//             [drep]      -- pointer to the data repository for filtered
//                            information
//             [docChar]   -- some property values are written here so that
//                            document characterization can happen
//
//  Notes:     Calls to SwitchToThread() give up processor.
//
//----------------------------------------------------------------------------

void CFilterDriver::FilterObject(
    CPropertyEnum &        propEnum,
    CDataRepository &      drep,
    CDocCharacterization & docChar )
{
    #if CIDBG == 1
        ULONG ulStartTime = GetTickCount();
    #endif

    CFullPropSpec ps;

    // Get the locale for the property set. Use that if available, else use all the
    // known locales to maximize the chances of retrieving a property.

    LCID locale;

    BOOL fUseKnownLocale = SUCCEEDED( propEnum.GetPropertySetLocale(locale));

    for ( CStorageVariant const * pvar = propEnum.Next( ps );
          pvar != 0;
          pvar = propEnum.Next( ps ) )
    {
        //
        //  Filter each of the properties and property sets until we run
        //  out of them. Register each property for each of the registered locales.
        //

        FilterProperty( *pvar, ps, drep, docChar, _lcidSystemDefault );       SwitchToThread();

        if (fUseKnownLocale)
        {
            ciDebugOut((DEB_FILTER, "Propset locale is 0x%x\n", locale));

            if (locale != _lcidSystemDefault)
            {
                FilterProperty( *pvar, ps, drep, docChar, locale );           SwitchToThread();
            }
        }
        else
        {
            // We want to index this property with all the known locales only if it
            // is a "string" type. For non-string types, locale doesn't matter
            VARTYPE vt = pvar->Type() | VT_VECTOR;  // enables check with or without vt_vector bit
            if (vt == (VT_VECTOR | VT_LPWSTR) ||
                vt == (VT_VECTOR | VT_BSTR)   ||
                vt == (VT_VECTOR | VT_LPSTR)
               )
            {
                int iMin = min(_cLCIDs, cLCIDMax);
                for (int i = 0; i < iMin; i++)
                {
                    ciDebugOut(( DEB_ITRACE, "Filtering property 0x%x with locale 0x%x\n",
                                 pvar, _alcidSeen[i] ));
                    if (_alcidSeen[i] != _lcidSystemDefault)
                    {
                        FilterProperty( *pvar, ps, drep, docChar, _alcidSeen[i] );       SwitchToThread();
                    }
                }
            }
        }
    }

    #if CIDBG == 1
        ULONG ulEndTime = GetTickCount();
        ciDebugOut (( DEB_USER1,
                      "Filtering properties took %d ms\n",
                      ulEndTime-ulStartTime ));
    #endif
}



//+-------------------------------------------------------------------------
//
//  Member:     CFilterDriver::FilterSecurity, private
//
//  Synopsis:   Store the security descriptor and map to an SDID
//
//  Arguments:  [wcsFileName] - file name (used only for error reporting)
//              [oplock]      - oplock held on the file
//              [drep]        - data repository
//
//  Notes:      using ACCESS_SYSTEM_SECURITY AccessMode will cause an
//              oplock break, so we should call FilterSecurity before
//              taking the oplock.
//
//  Notes:     Calls to SwitchToThread() give up processor.
//
//--------------------------------------------------------------------------

void CFilterDriver::FilterSecurity(
    ICiCOpenedDoc *Document,
    CDataRepository & drep )
{
    BOOL fCouldStore = FALSE;
    SCODE sc;

    //
    //  Initial guess about security descriptor size
    //

    const cInitSD = 512;
    BYTE abBuffer[cInitSD];

    ULONG cbSD = cInitSD;
    BYTE * pbBuffer = abBuffer;

    XPtr<SECURITY_DESCRIPTOR> xSD;

    while (TRUE)
    {

        //
        //  Attempt to get the security descriptor into the buffer
        //

        sc = Document->GetSecurity( pbBuffer, &cbSD );                           SwitchToThread();

        //
        //  If we don't need to resize, then exit while
        //

        if (SUCCEEDED( sc ) || CI_E_BUFFERTOOSMALL != sc)
        {
            break;
        }

        //
        // Allocate a bigger buffer and retrieve the security information into
        // it.
        //
        xSD.Free();
        xSD.Set( (SECURITY_DESCRIPTOR *) new BYTE [cbSD] );
        pbBuffer = (BYTE *) xSD.GetPointer();
    }

    if ( !SUCCEEDED( sc ) || 0 == cbSD )
    {
        //
        //  Store NULL security descriptor for the file
        //
        fCouldStore =  drep.StoreSecurity( 0, 0 );                               SwitchToThread();
    }
    else
    {
        //  Now store away the security descriptor and map to an SDID

        fCouldStore =
            drep.StoreSecurity( pbBuffer, cbSD );                                SwitchToThread();
    }

    if (! fCouldStore)
    {
        ciDebugOut(( DEB_ERROR, "Failed to store security info\n" ));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CFilterDriver::RegisterLocale, private
//
//  Synopsis:   Registers a locale
//
//  Arguments:  [locale] - the locale
//
//  Returns:    none
//
//  History:    27-Jan-99   KrishnaN   Created
//
//----------------------------------------------------------------------------

void CFilterDriver::RegisterLocale(LCID locale)
{
    // Ensure that the locale wasn't already registered

    int iMin = min(_cLCIDs, cLCIDMax);
    for (int i = 0; i < iMin; i++)
    {
        if (locale == _alcidSeen[i])
            return;
    }

    _alcidSeen[_cLCIDs % cLCIDMax] = locale;
    ciDebugOut(( DEB_ITRACE, "Registered %d locale 0x%x\n", _cLCIDs+1, locale));
    _cLCIDs++;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsNonIndexableProp, private
//
//  Synopsis:   Looks for ROBOTS=NOINDEX tag
//
//  Arguments:  [fps] -- Property
//              [var] -- Value
//
//  Returns:    TRUE if property [fps] == ROBOTS and value [var] == NOINDEX
//
//  History:    7-Oct-97   KyleP   Stole from Site Server
//
//  Notes:      I based my changes to this code in information found at:
//              http://info.webcrawler.com/mak/projects/robots/meta-user.html
//
//----------------------------------------------------------------------------

BOOL IsNonIndexableProp( CFullPropSpec const & fps, PROPVARIANT const &  var )
{
    static GUID guidHTMLMeta = HTMLMetaGuid;

    BOOL fIsNonIndexable = FALSE;

    if ( fps.IsPropertyName() &&
         fps.GetPropSet() == guidHTMLMeta &&
         _wcsicmp( fps.GetPropertyName(), L"ROBOTS" ) == 0 &&
         (var.vt == VT_LPWSTR || var.vt == VT_BSTR) &&
         0 != var.pwszVal )
    {
        //
        // Convert to lowercase to do wcsstr search.
        //

        unsigned cc = wcslen( var.pwszVal ) + 1;

        XGrowable<WCHAR> xwcsTemp( cc );

        RtlCopyMemory( xwcsTemp.Get(), var.pwszVal, cc * sizeof(WCHAR) );

        _wcslwr( xwcsTemp.Get() );

        //
        // Check "noindex"
        //

        fIsNonIndexable = wcsstr( xwcsTemp.Get(), L"noindex") != 0;

        //
        // Check "all"
        //

        if ( !fIsNonIndexable )
            fIsNonIndexable = wcsstr( xwcsTemp.Get(), L"none") != 0;
    }

    return fIsNonIndexable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\entrybuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       EntryBuf.Cxx
//
//  Contents:   Implementation of the CEntryBuffer and associated classes.
//
//  Classes:    CEntry, CKeyVector, CEntryBuffer, CEntryBufferHandler
//
//  History:    18-Mar-93       AmyA        Created from wordlist.cxx and
//                                          sort.cxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <entrybuf.hxx>
#include <fdaemon.hxx>
#include <pidmap.hxx>
#include <norm.hxx>

// 12 was chosed after some testing on actual data

const unsigned int minPartSize = 12;

// the stack will be big enough to quicksort 2^cwStack entries
const unsigned int cwStack  = 32;

//+---------------------------------------------------------------------------
//
// Function:    Median, public
//
// Synopsis:    Find the median of three entries
//
// Arguments:   [apEntry] -- array of pointers to entries
//              [i1], [i2], [i3] -- three indexes
//
// History:     07-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

unsigned Median ( CEntry * * apEntry,
                  unsigned i1,
                  unsigned i2,
                  unsigned i3 )
{
    const CEntry* p1 = apEntry[i1];
    const CEntry* p2 = apEntry[i2];
    const CEntry* p3 = apEntry[i3];

    int c = p1->Compare( p2 );
    if ( c > 0 ) // p1 > p2
    {
        c = p2->Compare( p3 );
        if ( c > 0 )
            return i2;
        else
        {
            c = p1->Compare( p3 );
            return ( c > 0 )? i3: i1;
        }
    }
    else // p2 >= p1
    {
        c = p1->Compare( p3 );
        if ( c > 0 )
            return i1;
        else
        {
            c = p2->Compare( p3 );
            return ( c > 0 )? i3: i2;
        }
    }
}

//+---------------------------------------------------------------------------
//
// Function:    InsertSort
//
// Synopsis:    Last step of sort is to perform a straight insertion sort
//              if the limit partition size is > 1.
//
// Arguments:   [apEntry]  -- array of pointers to sort keys
//              [count]    -- # of sort keys to be sorted
//
//  Notes:      First key is at offset 1, last at offset count
//
//---------------------------------------------------------------------------

void InsertSort( CEntry * apEntry[], unsigned count)
{
    if (count <= 1)        // nothing to sort
        return;

    // loop from 2 through nth element
    for(unsigned j = 2; j <= count; j++)
    {
        CEntry * key = apEntry[j];
        // go backwards from j-1 shifting up keys greater than 'key'
        for ( unsigned i = j - 1; i > 0 &&
              apEntry[i]->Compare( key ) > 0; i-- )
        {
            apEntry[i+1] = apEntry[i];
        }
        // found key less than 'key' or hit the beginning (i == 0)
        // insert key in the hole
        apEntry[i+1] = key;
    }
}

//+---------------------------------------------------------------------------
//
//  Class:      CIStack
//
//  Purpose:    A stack of integers
//
//  History:    12-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------
class CIStack
{
public:
    CIStack()
        { _top = _arr; }
    void Push ( unsigned i )
        { *_top++ = i; ciAssert(_top-_arr < cwStack); }
    unsigned Pop ()
        { return *--_top; }
    unsigned Top () const
        { return *_top; }
    BOOL Empty() const
        { return _top == _arr; }
private:
    unsigned _arr[cwStack];
    unsigned * _top;
};


//+---------------------------------------------------------------------------
//
// Member:      CEntryBuffer::CEntryBuffer, public
//
// Synopsis:    Fills the buffer with two sentinels.
//
// Arguments:   [cb]  -- size of the buffer
//              [buf] -- Pointer to the buffer
//
// History:     28-May-92   KyleP       Added single wid detection
//              07-Jun-91   BartoszM    Created
//              22-Feb-96   SrikantS    Pass in a buffer instead of allocing
//                                      everytime.
//
//----------------------------------------------------------------------------
CEntryBuffer::CEntryBuffer ( ULONG cb, BYTE * buf )
        : _buf( buf ), _cb( cb )
{
    Win4Assert( 0 != buf );

    // save space at the end of the buffer for the vector array offset.
    _pWidSingle = (WORKID*)(_buf + cb - sizeof(WORKID) - sizeof(int));
    _bufSize = (unsigned)((BYTE*)_pWidSingle - _buf);
    ciAssert ( _bufSize > 4*(sizeof(CEntry) + MAXKEYSIZE) );

    // This is done once during construction

    _curEntry = (CEntry*) _buf;
    _keyVec.Init ( _buf, _bufSize );

    // insert sentinel keys

    // first sort key is minimum key, i.e., 0 length key with 0 pid, 0
    // workid and 0 offset

    // this key will be added to the end of _keyVec
    // just before sorting.

    _curEntry->SetPid ( 0 );
    _curEntry->SetWid ( widInvalid );
    _curEntry->SetOcc ( 0 );
    _curEntry->SetCount ( 0 );

    _curEntry = _curEntry->Next();

    // then the maximum key
    // max key has max size filled with 0xff's

    ciAssert ( widInvalid == 0xffffffff );
    ciAssert ( OCC_INVALID == 0xffffffff );
    ciAssert ( pidInvalid == 0xffffffff );

    _curEntry->SetPid ( pidInvalid );
    _curEntry->SetWid ( widInvalid );
    _curEntry->SetOcc ( OCC_INVALID );
    _curEntry->SetCount (MAXKEYSIZE );
    memset(_curEntry->GetKeyBuf(), MAX_BYTE, MAXKEYSIZE);
    Advance();

    //
    // *_pWidSingle = 0 means we haven't seen a wid yet.
    //

    *_pWidSingle = 0;
}

//+---------------------------------------------------------------------------
//
// Member:      CEntryBuffer::ReInit, public
//
// Synopsis:    Discard old data, reuse the sentinels
//
// History:     28-May-92   KyleP       Added single wid detection
//              07-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

void CEntryBuffer::ReInit()
{
    _keyVec.Init ( _buf, _bufSize );
    _curEntry = (CEntry*) _buf;

    // skip the min key
    _curEntry = _curEntry->Next();
    // add the max key to the table
    Advance();

    //
    // *_pWidSingle = 0 means we haven't seen a wid yet.
    //

    *_pWidSingle = 0;
}

//+---------------------------------------------------------------------------
//
// Member:      CEntryBuffer::Done, public
//
// Synopsis:    Prepare buffer to be transported to kernel by calculating
//              offsets and inserting offset to first key at the end of the
//              buffer.
//
// History:     30-Jun-93   AmyA        Created
//
//----------------------------------------------------------------------------

void CEntryBuffer::Done()
{
    _keyVec.CalculateOffsets ( Count() + 2 );   // include sentinels

    // the offset to the vector array is put in the space in the buffer that
    // has been reserved after the WORKID pointed to by _pWidSingle.
    *(int *)((BYTE *)_pWidSingle + sizeof(WORKID)) =
            (int)((BYTE *)(_keyVec.GetVector()) - _buf);
}

//+---------------------------------------------------------------------------
//
// Member:      CEntryBuffer::AddEntry, public
//
// Synopsis:    Add entry to buffer
//
// Arguments:   [cb] -- size of key
//              [key] -- buffer with key
//              [pid] -- property id
//              [widFake] -- fake work id
//              [occ] -- occurrence
//
// History:     28-May-92   KyleP       Added single wid detection
//              07-Jun-91   BartoszM    Created
//
//----------------------------------------------------------------------------

void CEntryBuffer::AddEntry  (
    unsigned cb, const BYTE * key, PROPID pid, WORKID widFake, OCCURRENCE occ)
{
    ciAssert( widFake > 0 && widFake <= maxFakeWid );
    ciAssert( widFake != widInvalid );
    ciAssert( cb > 0 );

    _curEntry->SetWid ( widFake );
    _curEntry->SetPid ( pid );
    _curEntry->SetOcc ( occ );
    _curEntry->SetCount ( cb );
    memcpy ( _curEntry->GetKeyBuf(), key, cb );
    Advance();

    if ( *_pWidSingle == 0 )
        *_pWidSingle = widFake;
    else if ( *_pWidSingle != widFake )
        *_pWidSingle = widInvalid;
}

//+---------------------------------------------------------------------------
//
// Member:      CEntryBuffer::Sort, private
//
// Synopsis:    sorts the array of keys using a quicksort algorithm
//
// Effects:     sorts buffer
//
// History:     22-May-91   Brianb      Created
//              05-Jun-91   BartoszM    Rewrote it
//              02-Jun-92   KyleP       Added wid mapping.
//
//----------------------------------------------------------------------------

void CEntryBuffer::Sort()
{
    //ciDebugOut (( DEB_ITRACE, "sorting\n" ));
    unsigned count = Count();
    if (count == 0)        // nothing to sort
        return;

    CEntry ** apEntry = _keyVec.GetVector();

    // compute length of pointer array; note low key and high key
    // are at positions 0, count+1

    // Use qucksort above threshold size
    if (count > minPartSize)
    {
        CIStack stack;
        unsigned left = 1;
        unsigned right = count;

        // outer loop for sorting partitions
        while(TRUE)
        {
            // compute median of left, right, (left+right)/2
            ciAssert(right >= left + minPartSize);

            unsigned median = Median ( apEntry,
                                       left,
                                       right,
                                       (left+right)/2);

            Win4Assert( median >= left && median <= right );

            // exchange median with left
            CEntry * pivot = apEntry[median];
            apEntry [median] = apEntry[left];
            apEntry [left] = pivot;

            // point i at the pivot, j beyond the end of partition
            // and sort in between

            unsigned i = left;
            unsigned j = right + 1;

            // partition chosen, now burn the candle from both ends
            while(TRUE)
            {
                // increment i until key >= pivot
                do
                    i++;
                while ( apEntry[i]->Compare( pivot ) < 0);

                // decrement j until key <= pivot
                do
                    j--;
                while ( apEntry[j]->Compare( pivot ) > 0);

                if ( j <= i )
                    break;

                // swap the elements that are out of order
                CEntry* tmp = apEntry[i];
                apEntry[i] = apEntry[j];
                apEntry[j] = tmp;

            } // continue burning

            // finally, excange the pivot
            apEntry[left] = apEntry[j];
            apEntry[j] = pivot;

            // entries to the left of j are smaller
            // than entries to the right of j

            unsigned rsize = right - j;
            unsigned lsize = j - left;

            // Push the larger one on the stack for later sorting
            // If any of the partitions is smaller than the
            // minimum, skip it and proceed directly with the other one
            // if both are too small, pop the stack

            if ( rsize > minPartSize ) // right partition big enough
            {
                if ( lsize >= rsize ) // left even bigger
                {
                    // sort left later
                    stack.Push ( j - 1 );
                    stack.Push ( left );
                    // sort right now
                    left = j + 1;
                }
                else if ( lsize > minPartSize ) // left big enough
                {
                    // sort right later
                    stack.Push ( right );
                    stack.Push ( j + 1 );
                    // sort left now
                    right = j - 1;
                }
                else // left too small
                {
                    // sort the right partition now
                    left = j + 1;
                }
            }
            // right partition too small
            else if ( lsize > minPartSize ) // but left big enough
            {
                // sort the left partition now
                right = j - 1;
            }
            else // both are too small
            {
                if ( stack.Empty() )
                    break; // we are done!!!
                else
                {
                    // sort the next partition
                    left = stack.Pop();
                    right = stack.Pop();
                }
            }

        } // keep sorting

    } // Unsorted chunks are of the size <= minPartSize

    if (minPartSize > 1)
        InsertSort( apEntry, count);

#if CIDBG == 1
    // check to see that array is really sorted. j=0 is a sentinel.
    for (unsigned j = 1; j <= count; j++)
    {
        Win4Assert( apEntry[j]->Pid() != pidAll );

        if ( apEntry[j]->Compare( apEntry[j+1] ) >= 0 )
        {
            CKeyBuf first( apEntry[j]->Pid(),
                           apEntry[j]->GetKeyBuf(),
                           apEntry[j]->Count() );

            CKeyBuf second( apEntry[j+1]->Pid(),
                            apEntry[j+1]->GetKeyBuf(),
                            apEntry[j+1]->Count() );

            ciDebugOut(( DEB_ERROR, "apEntry[%d]='%*ws' (%p) len=0x%x pid=0x%x wid=0x%x occ=0x%x\n",
                                    j,
                                    first.StrLen(),
                                    first.GetStr(),
                                    first.GetStr(),
                                    first.StrLen(),
                                    first.Pid(),
                                    apEntry[j]->Wid(),
                                    apEntry[j]->Occ() ));

            ciDebugOut(( DEB_ERROR, "apEntry[%d]='%*ws' (%p) len=0x%x pid=0x%x wid=0x%x occ=0x%x\n",
                                    j+1,
                                    second.StrLen(),
                                    second.GetStr(),
                                    second.GetStr(),
                                    second.StrLen(),
                                    second.Pid(),
                                    apEntry[j+1]->Wid(),
                                    apEntry[j+1]->Occ() ));


            Win4Assert( apEntry[j]->Compare( apEntry[j+1] ) != 0  && "Duplicate keys");
            Win4Assert( apEntry[j]->Compare( apEntry[j+1] ) < 0 && "Out of order keys");
        }

        ciAssert( apEntry[j]->Wid() <= maxFakeWid );
    }
#endif //CIDBG == 1
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\fdaemon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       FDAEMON.CXX
//
//  Contents:   Filter driver
//
//  History:    23-Mar-93   AmyA        Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fdaemon.hxx>
#include <widtab.hxx>
#include <lang.hxx>
#include <drep.hxx>
#include <cci.hxx>
#include <pfilter.hxx>
#include <pageman.hxx>
#include <propspec.hxx>
#include <pidmap.hxx>
#include <imprsnat.hxx>
#include <frmutils.hxx>
#include <ntopen.hxx>
#include <ciguid.hxx>

#include "fdriver.hxx"
#include "ebufhdlr.hxx"
#include "ikrep.hxx"

#if DEVL==1
void DebugPrintStatus( STATUS stat );
#endif  // DEVL

const GUID guidHtmlMeta = HTMLMetaGuid;

//+---------------------------------------------------------------------------
//
//  Class:      CDocBufferIter
//
//  Purpose:    To iterate through a docBuffer passed back from the
//              FilterDataReady call
//
//----------------------------------------------------------------------------
class CDocBufferIter
{
    public:

        CDocBufferIter( const BYTE *pBuffer, int cbBuffer );

        BOOL AtEnd();

        const BYTE *  GetCurrent(unsigned & iDoc, ULONG & cbDoc );
        void          Next();
        unsigned      GetCount() const { return _iDoc; }

    private:

        const BYTE * _pCurrent;
        const BYTE * _pEnd;

        USHORT        _cDocs;       // Document Count
        USHORT        _iDoc;        // Current document
        USHORT        _cbCurrDoc;   // Number of bytes in the current doc
};


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CDocBufferIter::CDocBufferIter(const BYTE *pBuffer, int cbBuffer) :
                                _pCurrent(pBuffer+sizeof USHORT),
                                _pEnd(pBuffer+cbBuffer),
                                _iDoc(0),
                                _cbCurrDoc(0)
{
    Win4Assert( cbBuffer >= sizeof USHORT );
    RtlCopyMemory( &_cDocs, pBuffer, sizeof USHORT );
    Win4Assert( _cDocs <= CI_MAX_DOCS_IN_WORDLIST );

    //
    // Setup for the first document.
    //
    if ( _cDocs > 0 )
    {
        Win4Assert( _pCurrent + sizeof USHORT <= _pEnd );
        RtlCopyMemory( &_cbCurrDoc, _pCurrent, sizeof USHORT );
        _pCurrent += sizeof USHORT;
    }
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL CDocBufferIter::AtEnd()
{
    Win4Assert( _iDoc <= _cDocs );
    Win4Assert( _pCurrent <= _pEnd );

    return (_iDoc == _cDocs);
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
const BYTE * CDocBufferIter::GetCurrent(unsigned & iDoc, ULONG & cbDoc )
{
    Win4Assert( !AtEnd() );

    iDoc = _iDoc;                           // Number of current document
    Win4Assert( iDoc < CI_MAX_DOCS_IN_WORDLIST );
    cbDoc = _cbCurrDoc;

    return _pCurrent;
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void  CDocBufferIter::Next()
{
    //
    //  Setup next document
    //
    if ( !AtEnd() )
    {
        _pCurrent += _cbCurrDoc;

        if ( _pCurrent < _pEnd )
        {
            Win4Assert( _pCurrent + sizeof USHORT <= _pEnd );

            RtlCopyMemory( &_cbCurrDoc, _pCurrent, sizeof USHORT );
            _pCurrent += sizeof USHORT;
        }
        else
        {
            Win4Assert( _pCurrent == _pEnd );
            _cbCurrDoc = 0;
        }

        _iDoc++;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterDaemon::CFilterDaemon, public
//
//  History:    23-Mar-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CFilterDaemon::CFilterDaemon ( CiProxy & proxy,
                               CCiFrameworkParams & params,
                               CLangList & LangList,
                               BYTE * buf,
                               ULONG cbMax,
                               ICiCFilterClient *pICiCFilterClient )
    : _proxy( proxy ),
      _params( params ),
      _cFilteredDocuments( 0 ),
      _cFilteredBlocks( 0 ),
      _pbCurrentDocument( NULL ),
      _cbCurrentDocument( 0 ),
      _fStopFilter( FALSE ),
      _fWaitingForDocument( FALSE ),
      _fOwned( FALSE ),
      _entryBuffer( buf ),
      _cbMax( cbMax ),
      _xFilterClient( pICiCFilterClient ),
      _LangList( LangList ),
      _pidmap( &_proxy )
{
    //
    //  Even though we've saved pICiCFilterClient in a safe pointer, it is
    //  NOT correctly referenced by the caller.  That is our responsibility
    //

    _xFilterClient->AddRef( );

    //
    // get ICiCAdviseStatus interface pointer
    //

    SCODE sc = _xFilterClient->QueryInterface( IID_ICiCAdviseStatus, _xAdviseStatus.GetQIPointer() );

    if ( S_OK != sc )
    {
        THROW( CException(sc) );
    }

    //
    // Get optional filter status interface.
    //

    sc = _xFilterClient->QueryInterface( IID_ICiCFilterStatus, _xFilterStatus.GetQIPointer() );

    Win4Assert( ( SUCCEEDED(sc) && !_xFilterStatus.IsNull() ) ||
                ( FAILED(sc) && _xFilterStatus.IsNull() ) );

    //
    // Get config info
    //

    sc = _xFilterClient->GetConfigInfo( &_configInfo );
    if ( FAILED(sc) )
    {
        ciDebugOut(( DEB_ERROR, "GetConfigInfo failed. Error 0x%X\n", sc ));
        THROW( CException(sc) );
    }

    //
    //
    //

    if ( 0 == buf )
    {
        _cbMax = _params.GetFilterBufferSize() * 1024;
        _entryBuffer = (BYTE *)VirtualAlloc(
                                0,                  // Requested position.
                                _cbMax,             // Size (in bytes)
                                MEM_COMMIT,         // We want it now.
                                PAGE_READWRITE );   // Full access, please.

        _fOwned = TRUE;
    }

    _docBuffer = (BYTE *)(CPageManager::GetPage());
    _cbTotal = PAGE_SIZE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterDaemon::~CFilterDaemon, public
//
//  History:    17-May-93   AmyA           Created.
//
//----------------------------------------------------------------------------
CFilterDaemon::~CFilterDaemon()
{
    if ( _fOwned )
        VirtualFree( _entryBuffer, 0, MEM_RELEASE );

    CPageManager::FreePage( _docBuffer );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterDaemon::DoUpdates, private
//
//  Synopsis:   Filters Documents and creates word lists
//
//  History:    18-Apr-93   AmyA        Created
//
//  Notes:      This interface is exported across query.DLL, and hence can not
//              throw an exception.  If this routine ever returns, it is
//              the result of an error.
//
//----------------------------------------------------------------------------
SCODE CFilterDaemon::DoUpdates()
{
    SCODE scode = STATUS_SUCCESS;

    TRY
    {
        ULONG cLoops = 0;

        while (STATUS_SUCCESS == scode)
        {
            cLoops++;

            // Trim our working set every n docs

            if ( 20 == cLoops )
            {
                SetProcessWorkingSetSize( GetCurrentProcess(), -1, -1 );
                cLoops = 0;
            }

            ULONG cbNeeded = _cbTotal;
            _cbHdr   = sizeof(ULONG);

            Win4Assert( _cbTotal > _cbHdr );
            _cbDocBuffer = _cbTotal-_cbHdr;

            {
                CLock lock( _mutex );
                if ( _fStopFilter )
                {
                    ciDebugOut(( DEB_ITRACE, "Quitting filtering\n" ));
                    return STATUS_REQUEST_ABORTED;
                }
                else
                    _fWaitingForDocument = TRUE;
            }

            scode = _proxy.FilterReady( _docBuffer, cbNeeded,
                                        CI_MAX_DOCS_IN_WORDLIST );

            while ( STATUS_SUCCESS == scode && cbNeeded > _cbTotal )
            {
                // need more memory
                CPageManager::FreePage( _docBuffer );

                unsigned ccPages = cbNeeded / PAGE_SIZE;
                if ( ccPages * PAGE_SIZE < cbNeeded )
                {
                    ccPages++;
                }

                _docBuffer = (BYTE *)(CPageManager::GetPage( ccPages ));
                _cbTotal = cbNeeded = ccPages * PAGE_SIZE;

                scode = _proxy.FilterReady( _docBuffer, cbNeeded,
                                            CI_MAX_DOCS_IN_WORDLIST );
            }


            {
                CLock lock( _mutex );
                if ( _fStopFilter )
                {
                    ciDebugOut(( DEB_ITRACE, "Quitting filtering\n" ));
                    return STATUS_REQUEST_ABORTED;
                }
                else
                    _fWaitingForDocument = FALSE;
            }

            if ( NT_SUCCESS( scode ) && (_cbTotal > _cbHdr) )
            {
                _cbDocBuffer = _cbTotal-_cbHdr;

                //
                // SLM_HACK
                //

                //
                // If the number of remaining documents (after this
                // doc buffer) is less than a threshold value,
                // then wait for some time before continuing
                //
                ULONG cDocsLeft;
                RtlCopyMemory( &cDocsLeft, _docBuffer, sizeof(ULONG) );
                if ( cDocsLeft < _params.GetFilterRemainingThreshold() )
                {
                    ciDebugOut(( DEB_ITRACE,
                        "CiFilterDaemon. Number of Docs Left %d < %d.  Sleep %d s.\n",
                        cDocsLeft,
                        _params.GetFilterRemainingThreshold(),
                        _params.GetFilterDelayInterval() ));
                    Sleep(_params.GetFilterDelayInterval()*1000);
                }

                FilterDocs();
            }
        }
    }
    CATCH (CException, e)
    {
        scode = e.GetErrorCode();
    }
    END_CATCH

    return scode;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterDaemon::FilterDataReady, public
//
//  Synopsis:   Sends a buffer to be added to the current word list
//
//  Arguments:
//      [pEntryBuf] -- pointer to the entry buffer
//      [cb] -- count of bytes in the buffer
//
//  History:    31-Mar-93   AmyA        Created.
//
//----------------------------------------------------------------------------

SCODE CFilterDaemon::FilterDataReady ( const BYTE * pEntryBuf, ULONG cb )
{
    return _proxy.FilterDataReady ( pEntryBuf, cb );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFilterDaemon::StopFiltering
//
//  History:    12-Sep-93   SitaramR        Created.
//
//----------------------------------------------------------------------------
VOID CFilterDaemon::StopFiltering()
{
    CLock lock( _mutex );

    _fStopFilter = TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFilterDaemon::IsWaitingForDocument
//
//  Returns:    Whether we are waiting for documents to update
//
//  History:    12-Sep-93   SitaramR        Created.
//
//----------------------------------------------------------------------------
BOOL CFilterDaemon::IsWaitingForDocument()
{
    CLock lock( _mutex );

    return _fWaitingForDocument;
}

//+---------------------------------------------------------------------------
//
//  Class:      CFilterDocument
//
//  Purpose:    A class to filter a document by retrying different impersonation
//              contexts if necessary.
//
//  History:    7-18-96   srikants   Created
//
//----------------------------------------------------------------------------

class CFilterDocument
{

public:

    CFilterDocument( CDataRepository & drep,
                     CFilterDaemon & fDaemon,
                     CCiFrameworkParams & params,
                     CI_CLIENT_FILTER_CONFIG_INFO const & configInfo,
                     STATUS * aStatus,
                     ULONG    iDoc,
                     CNonStoredProps & NonStoredProps,
                     ULONG cbBuf )
    : _drep(drep),
      _fDaemon(fDaemon),
      _params(params),
      _configInfo(configInfo),
      _aStatus(aStatus),
      _iDoc(iDoc),
      _NonStoredProps( NonStoredProps ),
      _cbBuf( cbBuf )
    {
    }


    ULONG DoIt();

private:

    CDataRepository &       _drep;
    CFilterDaemon &         _fDaemon;
    CCiFrameworkParams &    _params;
    CI_CLIENT_FILTER_CONFIG_INFO const & _configInfo;
    STATUS *                _aStatus;
    ULONG                   _iDoc;
    CNonStoredProps &       _NonStoredProps;
    ULONG                   _cbBuf;
};

//+---------------------------------------------------------------------------
//
//  Member:     CFilterDocument::DoIt
//
//  Synopsis:   Tries to filter the file in the current impersonation context.
//
//  Returns:    Count of bytes filtered.
//
//  History:    7-18-96   srikants   Created
//
//----------------------------------------------------------------------------

ULONG CFilterDocument::DoIt()
{
    CFilterDriver filterDriver ( &_drep,
                                 _fDaemon._xAdviseStatus.GetPointer( ),
                                 _fDaemon._xFilterClient.GetPointer( ),
                                 _params,
                                 _configInfo,
                                 _fDaemon._cFilteredBlocks,
                                 _NonStoredProps,
                                 _cbBuf );

    if ( _fDaemon._fStopFilter )
    {
        ciDebugOut(( DEB_ITRACE, "Aborting filtering\n" ));
        THROW( CException(STATUS_TOO_LATE) );
    }

    _aStatus[_iDoc] = filterDriver.FillEntryBuffer( _fDaemon._pbCurrentDocument, 
                                                    _fDaemon._cbCurrentDocument );

    // In case we filtered a monster file, just round down to 4 gig.

    if ( 0 != filterDriver.GetFileSize().HighPart )
        return 0xffffffff;

    return filterDriver.GetFileSize().LowPart;
} //DoIt


//+---------------------------------------------------------------------------
//
//  Member:     CFilterDaemon::FilterDocs, private
//
//  Synopsis:   Creates a Filter Driver and filters documents in _docBuffer
//
//  History:    21-Apr-93   AmyA        Created.
//              05-Nov-93   DwightKr    Removed PROP_ALL code - we'll determine
//                                      what to filter after opening the object
//
//----------------------------------------------------------------------------

void CFilterDaemon::FilterDocs()
{
    ciAssert ( _docBuffer != 0 );

    ciDebugOut (( DEB_ITRACE, "CFilterDaemon::FilterDocs\n" ));

    CEntryBufferHandler entryBufHandler ( _cbMax,
                                          _entryBuffer,
                                          *this,
                                          _proxy,
                                          _pidmap );

    // STACK: this is a big object.
    CIndexKeyRepository krep( entryBufHandler );

    CDataRepository drep( krep, 0, FALSE, 0, _pidmap, _LangList );

    STATUS aStatus [CI_MAX_DOCS_IN_WORDLIST];
    for( unsigned i=0; i<CI_MAX_DOCS_IN_WORDLIST; i++ )    // set array
        aStatus[i] = WL_IGNORE;

    unsigned iDoc;

    CDocBufferIter iter(_docBuffer+_cbHdr, _cbTotal-_cbHdr);

    while ( !iter.AtEnd() )
    {

        _pbCurrentDocument = iter.GetCurrent(iDoc, _cbCurrentDocument);

        iter.Next();

        Win4Assert (iDoc < CI_MAX_DOCS_IN_WORDLIST );
        ciDebugOut((DEB_ITRACE, "\t%2d 0x%X\n",
                        iDocToFakeWid(iDoc), _pbCurrentDocument ));
        drep.PutWorkId ( iDocToFakeWid(iDoc) );

        _cFilteredDocuments++;
        _cFilteredBlocks = 0;

        if ( 0 == _cbCurrentDocument )
        {
            // This represents a deleted document.
            ciDebugOut(( DEB_IWARN, "Null document name 0x%x\n", _pbCurrentDocument ));
            aStatus[iDoc] = SUCCESS;
            continue;
        }

        BOOL fTookException = FALSE;

        CFwPerfTime filterTotalCounter( _xAdviseStatus.GetPointer(),
                                        CI_PERF_FILTER_TIME_TOTAL,
                                        1024*1024, 1000*60*60 );
        ULONG cbLow = 0;

        TRY
        {
            //
            // Filter time in Mb / hr
            //
            filterTotalCounter.TStart();


            if ( !_xFilterStatus.IsNull() )
            {
                SCODE sc = _xFilterStatus->PreFilter( _pbCurrentDocument, _cbCurrentDocument );

                if ( FAILED(sc) )
                {
                    ciDebugOut(( DEB_WARN, "Failing filtering because PreFilter returned 0x%x\n", sc ));
                    THROW( CException( sc ) );
                }
            }

            //
            // If necessary impersonate for accessing this file
            //
            CFilterDocument filterDocument( drep,
                                            *this,
                                            _params,
                                            _configInfo,
                                            aStatus,
                                            iDoc,
                                            _NonStoredProps,
                                            _cbMax );

            cbLow = filterDocument.DoIt();

        }
        CATCH ( CException, e )
        {
            fTookException = TRUE;

            ciDebugOut(( DEB_ITRACE,
                         "FilterDriver exception 0x%x filtering %d caught in FilterDocs.\n",
                         e.GetErrorCode(), iDoc ));

            if ( !_xFilterStatus.IsNull() )
                _xFilterStatus->PostFilter( _pbCurrentDocument, 
                                            _cbCurrentDocument,
                                            e.GetErrorCode() );

            if ( IsSharingViolation( e.GetErrorCode()) )
            {
                aStatus[iDoc] = CI_SHARING_VIOLATION;
            }
            else if ( IsNetDisconnect( e.GetErrorCode()) ||
                      CI_NOT_REACHABLE == e.GetErrorCode() )
            {
                aStatus[iDoc] = CI_NOT_REACHABLE;
            }
            else
            {
                aStatus[iDoc] = FILTER_EXCEPTION;
            }

            //
            //  Certain errors occuring while filtering are fatal. They
            //  will cause the filter daemon to terminate.

            if ( (e.GetErrorCode() == FDAEMON_E_FATALERROR) ||
                 (e.GetErrorCode() == STATUS_ACCESS_VIOLATION) ||
                 (e.GetErrorCode() == STATUS_NO_MEMORY) ||
                 (e.GetErrorCode() == STATUS_INSUFFICIENT_RESOURCES) ||
                 (e.GetErrorCode() == STATUS_DATATYPE_MISALIGNMENT) ||
                 (e.GetErrorCode() == STATUS_INSTRUCTION_MISALIGNMENT)
               )
            {
                RETHROW();
            }
        }
        END_CATCH

        if ( !_xFilterStatus.IsNull() && !fTookException )
            _xFilterStatus->PostFilter( _pbCurrentDocument, 
                                        _cbCurrentDocument,
                                        S_OK );

        filterTotalCounter.TStop( cbLow );

        if ( entryBufHandler.WordListFull() )   // finish current word list
        {
            //
            //  Does not throw
            //

            entryBufHandler.Done();

#if CIDBG == 1
            for (unsigned j=0; j<CI_MAX_DOCS_IN_WORDLIST; j++)
            {
                DebugPrintStatus( aStatus[j] );
            }
#endif // CIDBG == 1

            //
            //  If we have filled the buffer, and there are no more documents
            //  to filter then don't call FilterMore.  Exit the loop so that
            //  FilterDone can be called to finish this docList.
            //
            if ( iter.AtEnd() )
                break;

            SCODE scode = _proxy.FilterMore( aStatus, CI_MAX_DOCS_IN_WORDLIST );
            if ( FAILED(scode) )
            {
                ciDebugOut (( DEB_IERROR, "FilterMore returned with error 0x%x\n", scode ));
                THROW( CException( scode ) );
            }

            for( unsigned i = 0; i <= iDoc; i++ )    // reset array
                aStatus[i] = WL_IGNORE;
            entryBufHandler.Init();
        }
    }   // end of for loop

    _pbCurrentDocument = 0;
    _cbCurrentDocument = 0;

    //
    //  Does not throw
    //
    entryBufHandler.Done();

#if CIDBG == 1
    for (i = 0; i < CI_MAX_DOCS_IN_WORDLIST; i++)
    {
        DebugPrintStatus(aStatus[i]);
    }
#endif // CIDBG == 1

    if ( iter.GetCount() > 0 )
    {
        SCODE scode = _proxy.FilterDone( aStatus, CI_MAX_DOCS_IN_WORDLIST );

        if ( FAILED( scode ) )
        {
            ciDebugOut (( DEB_IERROR, "FilterDone returned with error 0x%x\n", scode ));
            THROW( CException( scode ) );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CNonStoredProps::Add
//
//  Synopsis:   Adds the property to the list of properties that shouldn't
//              be stored.
//
//  Arguments:  [ps]    -- Property ID
//
//  History:    9-Feb-97   dlee       Created.
//
//----------------------------------------------------------------------------

void CNonStoredProps::Add( CFullPropSpec const & ps )
{
    if ( ( guidStorage == ps.GetPropSet() ) &&
         ( ps.IsPropertyPropid() ) &&
         ( ps.GetPropertyPropid() < CSTORAGEPROPERTY ) )
    {
        Win4Assert( ps.GetPropertyPropid() != PID_STG_SIZE );

        _afStgPropNonStored[ ps.GetPropertyPropid() ] = TRUE;
    }
    else if ( guidHtmlMeta == ps.GetPropSet() )
    {
        if ( _cMetaSpecs < maxCachedSpecs )
            _aMetaSpecs[ _cMetaSpecs++ ] = ps;
    }
    else
    {
        if ( _cSpecs < maxCachedSpecs )
            _aSpecs[ _cSpecs++ ] = ps;
    }
} //Add

//+---------------------------------------------------------------------------
//
//  Method:     CNonStoredProps::IsNonStored
//
//  Synopsis:   Returns TRUE if the property shouldn't be stored
//
//  Arguments:  [ps]    -- Property ID
//
//  History:    9-Feb-97   dlee       Created.
//
//----------------------------------------------------------------------------

BOOL CNonStoredProps::IsNonStored( CFullPropSpec const & ps )
{
    if ( ( guidStorage == ps.GetPropSet() ) &&
         ( ps.IsPropertyPropid() ) &&
         ( ps.GetPropertyPropid() < CSTORAGEPROPERTY ) )
    {
        return _afStgPropNonStored[ ps.GetPropertyPropid() ];
    }
    else if ( guidHtmlMeta == ps.GetPropSet() )
    {
        for ( int x = 0; x < _cMetaSpecs; x++ )
            if ( ps == _aMetaSpecs[ x ] )
                return TRUE;
    }
    else
    {
        for ( int x = 0; x < _cSpecs; x++ )
            if ( ps == _aSpecs[ x ] )
                return TRUE;
    }

    return FALSE;
} //IsNonStored

#if CIDBG == 1
void DebugPrintStatus( STATUS stat )
{
    switch(stat)
    {
        case SUCCESS:
            // ciDebugOut((DEB_ITRACE, "Status: SUCCESS\n"));
            break;
        case PREEMPTED:
            ciDebugOut((DEB_ITRACE, "Status: PREEMPTED\n"));
            break;
        case BIND_FAILED:
            ciDebugOut((DEB_ITRACE, "Status: BIND_FAILED\n"));
            break;
        case CORRUPT_OBJECT:
            ciDebugOut((DEB_ITRACE, "Status: CORRUPT_OBJECT\n"));
            break;
        case MISSING_PROTOCOL:
            ciDebugOut((DEB_ITRACE, "Status: MISSING_PROTOCOL\n"));
            break;
        case CANNOT_OPEN_STREAM:
            ciDebugOut((DEB_ITRACE, "Status: CANNOT_OPEN_STREAM\n"));
            break;
        case DELETED:
            ciDebugOut((DEB_ITRACE, "Status: DELETED\n"));
            break;
        case ENCRYPTED:
            ciDebugOut((DEB_ITRACE, "Status: ENCRYPTED\n"));
            break;
        case FILTER_EXCEPTION:
            ciDebugOut((DEB_ITRACE, "Status: FILTER_EXCEPTION\n"));
            break;
        case OUT_OF_MEMORY:
            ciDebugOut((DEB_ITRACE, "Status: OUT_OF_MEMORY\n"));
            break;
        case PENDING:
            ciDebugOut((DEB_ITRACE, "Status: PENDING\n"));
            break;
        case WL_IGNORE:
            // ciDebugOut((DEB_ITRACE, "Status: WL_IGNORE\n"));
            break;
        case WL_NULL:
            // ciDebugOut((DEB_ITRACE, "Status: WL_NULL\n"));
            break;
        case CI_SHARING_VIOLATION:
            ciDebugOut(( DEB_ITRACE, "Status: CI_SHARING_VIOLATION\n" ));
            break;
        case CI_NOT_REACHABLE:
            ciDebugOut(( DEB_ITRACE, "Status: CI_NOT_REACHABLE\n" ));
            break;
        default:
            ciDebugOut((DEB_ITRACE, "This status is incorrect\n"));
            break;
    }
}
#endif // CIDBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\proc32.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       process.cxx
//
//  Contents:   CProcess class
//              CServiceProcess class
//
//  History:    07-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <proc32.hxx>
#include <cievtmsg.h>
#include <fwevent.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CProcess::CProcess
//
//  Purpose:    Creates a process on the local machine.
//
//  Arguments:  [wcsImageName]     -- name of EXE to run
//              [wcsCommandLine]   -- command line passed to EXE
//              [fCreateSuspended] -- should the EXE be created suspended?
//              [SAProcess]        -- Security context to run under
//              [fServiceChild]    -- Flag set to TRUE if the process is a
//                                    child of a "service" process (ala CiFilter
//                                    service or W3Svc).
//              [pAdviseStatus]    -- ICiCAdviseStatus interface, optional.
//
//  History:    06-Jun-94   DwightKr    Created
//
//  Notes:      If a system process (such as a service) spawning a process
//              it will always be created on the SYSTEM desktop, and never
//              the user's or DEFAULT desktop.  System processes do not have
//              sufficient acccess to create windows on the user's desktop.
//
//--------------------------------------------------------------------------

CProcess::CProcess( const WCHAR *wcsImageName,
                    const WCHAR *wcsCommandLine,
                    BOOL  fCreateSuspended,
                    const SECURITY_ATTRIBUTES & SAProcess,
                    BOOL  fOFSDaemon,
                    ICiCAdviseStatus * pAdviseStatus )
{
    _pAdviseStatus = pAdviseStatus;

    WCHAR wcsEXEName[_MAX_PATH + 1];
    if ( ExpandEnvironmentStrings( wcsImageName, wcsEXEName, _MAX_PATH ) == 0 )
    {
        THROW( CException() );
    }

    STARTUPINFO siDefault;
    RtlZeroMemory( &siDefault, sizeof(siDefault) );
    DWORD dwCreateFlags = 0;
    siDefault.cb = sizeof(STARTUPINFO);         // Size of this struct

    if ( fOFSDaemon )
    {
        siDefault.lpReserved = NULL;                // Not used (for now)
        siDefault.lpDesktop  = L"Default";          // Use default desktop
        siDefault.lpTitle = (WCHAR *) wcsImageName; // Default title
        siDefault.dwX = 0;                          // Don't specify where to
        siDefault.dwY = 0;                          //   place the window
        siDefault.dwXSize = 0;                      //  "   "   "   "   "
        siDefault.dwYSize = 0;                      //  "   "   "   "   "
        siDefault.dwFlags = STARTF_USESHOWWINDOW;   // Allow for minimizing
        siDefault.wShowWindow = SW_MINIMIZE;        // Normal display
        siDefault.cbReserved2 = 0;                  // Not used (for now)
        siDefault.lpReserved2 = NULL;               //  "   "   "   "   "
        dwCreateFlags = CREATE_NEW_CONSOLE;
    }
    else
    {
        siDefault.lpTitle = (WCHAR *) wcsImageName; // Default title
        dwCreateFlags = DETACHED_PROCESS;
    }

    if ( fCreateSuspended )
        dwCreateFlags |= CREATE_SUSPENDED;

    if ( !CreateProcess( fOFSDaemon ? (WCHAR *) wcsEXEName : 0,       // EXE name
                        (WCHAR *) wcsCommandLine,   // Command line
                        (SECURITY_ATTRIBUTES *) &SAProcess, // Proc sec attrib
                        NULL,                       // Thread sec attrib
                        fOFSDaemon,                 // Inherit handles
                        dwCreateFlags,              // Creation flags
                        NULL,                       // Environment
                        NULL,                       // Startup directory
                        &siDefault,                 // Startup Info
                        &_piProcessInfo ) )         // Process handles
    {
        DWORD dwLastError = GetLastError();

        if ( ERROR_FILE_NOT_FOUND == dwLastError  && _pAdviseStatus )

        {
            CFwEventItem item( EVENTLOG_AUDIT_FAILURE,
                               MSG_CI_FILE_NOT_FOUND,
                               1 );
            item.AddArg( wcsEXEName );
            item.ReportEvent(*_pAdviseStatus);
        }

        THROW( CException( HRESULT_FROM_WIN32( dwLastError) ) );
    }

    //
    // Only AddRef() once we get to a point where the constructor can
    // no longer fail (and the destructor is guaranteed to be called)
    //

    if (_pAdviseStatus)
        _pAdviseStatus->AddRef();
} //CProcess

//+-------------------------------------------------------------------------
//
//  Member:     CProcess::~CProcess
//
//  Purpose:    destructor
//
//  History:    06-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------
CProcess::~CProcess()
{
    if ( 0 != _pAdviseStatus )
        _pAdviseStatus->Release();

    Terminate();

    WaitForDeath();
}

//+-------------------------------------------------------------------------
//
//  Member:     CProcess::Resume, public
//
//  Purpose:    Continue a suspended thread
//
//  History:    06-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------
void CProcess::Resume()
{
    ResumeThread( _piProcessInfo.hThread );
}

//+-------------------------------------------------------------------------
//
//  Member:     CProcess::WaitForDeath
//
//  Purpose:    Blocks until the process has been terminated.
//
//  History:    06-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------
void CProcess::WaitForDeath( DWORD dwTimeout )
{
   DWORD res = WaitForSingleObject ( _piProcessInfo.hProcess, dwTimeout );

#if 0
   if ( WAIT_FAILED == res )
   {
        Win4Assert( !"Are we leaking a handle" );
   }
#endif  // 0

   CloseHandle(_piProcessInfo.hThread);
   CloseHandle(_piProcessInfo.hProcess);

//   if ( WAIT_FAILED == res )
//   {
//        THROW( CException() );
//   }

}

//+-------------------------------------------------------------------------
//
//  Member:     CProcess::GetProcessToken, private
//
//  Purpose:    Returns the process token for the process
//
//  History:    06-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------
HANDLE CProcess::GetProcessToken()
{
    HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION,
                                   FALSE,
                                   _piProcessInfo.dwProcessId );

    if ( NULL == hProcess )
    {
        THROW( CException() );
    }

    SWin32Handle process(hProcess);      // Save in smart pointer
    HANDLE hProcessToken = 0;
    if ( !OpenProcessToken( hProcess, TOKEN_ADJUST_DEFAULT | TOKEN_QUERY, &hProcessToken ) )
    {
        THROW( CException() );
    }

    return hProcessToken;
}


//+-------------------------------------------------------------------------
//
//  Member:     CProcess::AddDacl, public
//
//  Purpose:    Adds the access specified onto the Dacl on the process.
//
//  Arguments:  [dwAccessMask] -- Any combination of the Win32 ACCESS_MASK bits
//
//  History:    06-Jun-94   DwightKr    Created
//
//--------------------------------------------------------------------------
void CProcess::AddDacl( DWORD dwAccessMask )
{
    HANDLE hProcessToken = GetProcessToken();
    SWin32Handle processToken( hProcessToken );

    //
    //  Create a SID that gives everyone access.  We want to allow anyone
    //  to synchronize on the objects created in this process (if they
    //  can get a handle to the object to synchronize on).
    //
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_WORLD_SID_AUTHORITY;
    CSid WorldSid( NtAuthority, SECURITY_WORLD_RID );

    //
    //  Read the current Dacl.  This requires two steps.  The current
    //  Dacl size is not known, the 1st call determines its current size.
    //
    DWORD cbRequired;
    if ( !GetTokenInformation( hProcessToken,
                               TokenDefaultDacl,
                               0,
                               0,
                               &cbRequired ) )
    {
        if ( ERROR_INSUFFICIENT_BUFFER != GetLastError() )
            THROW( CException() );
    }
    else
    {
        ciDebugOut(( DEB_WARN,
                     "No default dacl(1), invalid CI configuration\n" ));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    //
    //  Create a buffer of the size requested to store the Dacl on the next
    //  call to GetTokenInformation().  Add additional space for the new
    //  synchronize-all Ace to be appended later.
    //
    cbRequired  += sizeof( ACCESS_ALLOWED_ACE ) + GetLengthSid( WorldSid );
    TOKEN_DEFAULT_DACL *pDacl = (TOKEN_DEFAULT_DACL *) new BYTE[cbRequired];
    SDacl SDacl(pDacl);         // Save in smart pointer

    if ( !GetTokenInformation( hProcessToken,
                               TokenDefaultDacl,
                               pDacl,
                               cbRequired,
                              &cbRequired ) )
    {
        THROW( CException() );
    }

    //
    // pDacl->DefaultDacl will be 0 if cisvc is started in windbg
    // with pipes preconfigured.  Don't do that -- we don't support it.
    //

    if ( 0 == pDacl->DefaultDacl )
    {
        ciDebugOut(( DEB_WARN,
                     "No default dacl(2), invalid CI configuration\n" ));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    pDacl->DefaultDacl->AclSize += (USHORT)(sizeof( ACCESS_ALLOWED_ACE ) + GetLengthSid( WorldSid ) - sizeof(ULONG));

    //
    //  Append synchronize access onto the Dacl.
    //
    if ( !AddAccessAllowedAce( pDacl->DefaultDacl,      // On to this acl,
                               ACL_REVISION,            // built for version X,
                               dwAccessMask,            // allow synchronize,
                               WorldSid ) )             // for these objects.
    {
        THROW( CException() );
    }

#if CIDBG == 1
    if ( !IsValidAcl( pDacl->DefaultDacl ) )
    {
        Win4Assert(!"Invalid Acl");
    }
#endif

    //
    //  Update the process's Dacl.
    //
    if ( !SetTokenInformation( hProcessToken,
                               TokenDefaultDacl,
                              &pDacl->DefaultDacl,
                               pDacl->DefaultDacl->AclSize ) )
    {
        THROW( CException() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996 Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debug assert function
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   Win4Assert
//
//  Synopsis:   Display assertion information
//
//----------------------------------------------------------------------------

void Win4AssertEx( char const * szFile,
                   int iLine,
                   char const * szMessage)
{
     char acsString[200];

     sprintf( acsString, "%s, File: %s Line: %u\n", szMessage, szFile, iLine );
     OutputDebugStringA( acsString );

     DebugBreak();
}

void AssertProc( LPCTSTR expr, LPCTSTR file, unsigned int line )
{
	DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\charhash.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992 - 1999 Microsoft Corporation.
//
//  File:       charhash.cxx
//
//  Contents:   Hash table that maps special characters to Unicode
//
//  Classes:    CSpecialCharHashTable
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop



//+-------------------------------------------------------------------------
//
//  Method:     CSpecialCharHashTable::CSpecialCharHashTable
//
//  Synopsis:   Constructor
//
//  History:    09-27-1999 KitmanH  Added new enties for IE 5
//
//--------------------------------------------------------------------------

CSpecialCharHashTable::CSpecialCharHashTable()
{
    //
    // Initialize the table with various Ascii string->Unicode mappings
    //

    //
    // For lt and gt, use Unicode chars from private use area to avoid
    // collision with '<' and '>' chars in Html tags. These will be
    // mapped back to '<' and '>' by the scanner.
    //
    Add(L"lt",      PRIVATE_USE_MAPPING_FOR_LT);
    Add(L"LT",      PRIVATE_USE_MAPPING_FOR_LT);    // Netscape compatibility
    Add(L"gt",      PRIVATE_USE_MAPPING_FOR_GT);
    Add(L"GT",      PRIVATE_USE_MAPPING_FOR_GT);    // Netscape compatibility

    Add(L"amp",     0x26);
    Add(L"AMP",     0x26);      // Netscape compatibility
    Add(L"quot",    PRIVATE_USE_MAPPING_FOR_QUOT);
    Add(L"QUOT",    PRIVATE_USE_MAPPING_FOR_QUOT);  // Netscape compatibility

// Base ASCII -- Basic Latin
    Add(L"excl",    0x21);
    Add(L"apos",    0x27);
    Add(L"plus",    0x2B);
    Add(L"comma",   0x2C);
    Add(L"period",  0x2E);
    Add(L"colon",   0x3A);
    Add(L"semi",    0x3B);
    Add(L"equals",  0x3D);
    Add(L"quest",   0x3F);
    Add(L"lsqb",    0x5B);
    Add(L"rsqb",    0x5D);
    Add(L"lowbar",  0x5F);
    Add(L"grave",   0x60);

// Latin 1
    Add(L"nbsp",    0xA0);
    Add(L"iexcl",   0xA1);
    Add(L"cent",    0xA2);
    Add(L"pound",   0xA3);
    Add(L"curren",  0xA4);
    Add(L"yen",     0xA5);
    Add(L"brvbar",  0xA6);
    Add(L"sect",    0xA7);
    Add(L"uml",     0xA8);
    Add(L"copy",    0xA9);
    Add(L"COPY",    0xA9);      // Netscape compatibility
    Add(L"ordf",    0xAA);
    Add(L"laquo",   0xAB);
    Add(L"not",     0xAC);
    Add(L"shy",     0xAD);
    Add(L"reg",     0xAE);
    Add(L"REG",     0xAE);      // Netscape compatibility
    Add(L"macr",    0xAF);
    Add(L"deg",     0xB0);
    Add(L"plusmn",  0xB1);
    Add(L"sup2",    0xB2);
    Add(L"sup3",    0xB3);
    Add(L"acute",   0xB4);
    Add(L"micro",   0xB5);
    Add(L"para",    0xB6);
    Add(L"middot",  0xB7);
    Add(L"cedil",   0xB8);
    Add(L"supl",    0xB9);      // Tripoli had this
    Add(L"sup1",    0xB9);
    Add(L"ordm",    0xBA);
    Add(L"raquo",   0xBB);
    Add(L"frac14",  0xBC);
    Add(L"frac12",  0xBD);
    Add(L"frac34",  0xBE);
    Add(L"iquest",  0xBF);
    Add(L"Agrave",  0xC0);
    Add(L"Aacute",  0xC1);
    Add(L"Acirc",   0xC2);
    Add(L"Atilde",  0xC3);
    Add(L"Auml",    0xC4);
    Add(L"Aring",   0xC5);
    Add(L"AElig",   0xC6);
    Add(L"Ccedil",  0xC7);
    Add(L"Egrave",  0xC8);
    Add(L"Eacute",  0xC9);
    Add(L"Ecirc",   0xCA);
    Add(L"Euml",    0xCB);
    Add(L"Igrave",  0xCC);
    Add(L"Iacute",  0xCD);
    Add(L"Icirc",   0xCE);
    Add(L"Iuml",    0xCF);
    Add(L"ETH",     0xD0);
    Add(L"Ntilde",  0xD1);
    Add(L"Ograve",  0xD2);
    Add(L"Oacute",  0xD3);
    Add(L"Ocirc",   0xD4);
    Add(L"Otilde",  0xD5);
    Add(L"Ouml",    0xD6);
    Add(L"times",   0xD7);
    Add(L"Oslash",  0xD8);
    Add(L"Ugrave",  0xD9);
    Add(L"Uacute",  0xDA);
    Add(L"Ucirc",   0xDB);
    Add(L"Uuml",    0xDC);
    Add(L"Yacute",  0xDD);
    Add(L"THORN",   0xDE);
    Add(L"szlig",   0xDF);
    Add(L"agrave",  0xE0);
    Add(L"aacute",  0xE1);
    Add(L"acirc",   0xE2);
    Add(L"atilde",  0xE3);
    Add(L"auml",    0xE4);
    Add(L"aring",   0xE5);
    Add(L"aelig",   0xE6);
    Add(L"ccedil",  0xE7);
    Add(L"egrave",  0xE8);
    Add(L"eacute",  0xE9);
    Add(L"ecirc",   0xEA);
    Add(L"euml",    0xEB);
    Add(L"igrave",  0xEC);
    Add(L"iacute",  0xED);
    Add(L"icirc",   0xEE);
    Add(L"iuml",    0xEF);
    Add(L"eth",     0xF0);
    Add(L"ntilde",  0xF1);
    Add(L"ograve",  0xF2);
    Add(L"oacute",  0xF3);
    Add(L"ocirc",   0xF4);
    Add(L"otilde",  0xF5);
    Add(L"ouml",    0xF6);
    Add(L"divide",  0xF7);
    Add(L"oslash",  0xF8);
    Add(L"ugrave",  0xF9);
    Add(L"uacute",  0xFA);
    Add(L"ucirc",   0xFB);
    Add(L"uuml",    0xFC);
    Add(L"yacute",  0xFD);
    Add(L"thorn",   0xFE);
    Add(L"yuml",    0xFF);

// Latin Extended A
    Add(L"Amacr",   0x100);
    Add(L"amacr",   0x101);
    Add(L"Abreve",  0x102);
    Add(L"abreve",  0x103);
    Add(L"Aogon",   0x104);
    Add(L"aogon",   0x105);
    Add(L"Cacute",  0x106);
    Add(L"cacute",  0x107);
    Add(L"Ccirc",   0x108);
    Add(L"ccirc",   0x109);
    Add(L"Cdot",    0x10A);
    Add(L"cdot",    0x10B);
    Add(L"Ccaron",  0x10C);
    Add(L"ccaron",  0x10D);
    Add(L"Dcaron",  0x10E);
    Add(L"dcaron",  0x10F);
    Add(L"Dstrok",  0x110);
    Add(L"dstrok",  0x111);
    Add(L"Emacr",   0x112);
    Add(L"emacr",   0x113);
    Add(L"Ebreve",  0x114);
    Add(L"ebreve",  0x115);
    Add(L"Edot",    0x116);
    Add(L"edot",    0x117);
    Add(L"Eogon",   0x118);
    Add(L"eogon",   0x119);
    Add(L"Ecaron",  0x11A);
    Add(L"ecaron",  0x11B);
    Add(L"Gcirc",   0x11C);
    Add(L"gcirc",   0x11D);
    Add(L"Gbreve",  0x11E);
    Add(L"gbreve",  0x11F);
    Add(L"Gdot",    0x120);
    Add(L"gdot",    0x121);
    Add(L"Gcedil",  0x122);
    Add(L"gcedil",  0x123);
    Add(L"Itilde",  0x128);
    Add(L"itilde",  0x129);
    Add(L"Imacr",   0x12A);
    Add(L"imacr",   0x12B);
    Add(L"Iogon",   0x12E);
    Add(L"iogon",   0x12F);
    Add(L"Idot",    0x130);
    Add(L"inodot",  0x131);
    Add(L"Kcedil",  0x136);
    Add(L"kcedil",  0x137);
    Add(L"kra",     0x138);
    Add(L"Lacute",  0x139);
    Add(L"lacute",  0x13A);
    Add(L"Lcedil",  0x13B);
    Add(L"lcedil",  0x13C);
    Add(L"Lcaron",  0x13D);
    Add(L"lcaron",  0x13E);
    Add(L"Lstrok",  0x141);
    Add(L"lstrok",  0x142);
    Add(L"Nacute",  0x143);
    Add(L"nacute",  0x144);
    Add(L"Ncedil",  0x145);
    Add(L"ncedil",  0x146);
    Add(L"Ncaron",  0x147);
    Add(L"ncaron",  0x148);
    Add(L"ENG",     0x14A);
    Add(L"eng",     0x14B);
    Add(L"Omacr",   0x14C);
    Add(L"omacr",   0x14D);
    Add(L"Odblac",  0x150);
    Add(L"odblac",  0x151);
    Add(L"OElig",   0x152);
    Add(L"oelig",   0x153);
    Add(L"Racute",  0x154);
    Add(L"racute",  0x155);
    Add(L"Rcaron",  0x158);
    Add(L"rcaron",  0x159);
    Add(L"Sacute",  0x15A);
    Add(L"sacute",  0x15B);
    Add(L"Scedil",  0x15E);
    Add(L"scedil",  0x15F);
    Add(L"Scaron",  0x160);
    Add(L"scaron",  0x161);
    Add(L"Tcedil",  0x162);
    Add(L"tcedil",  0x163);
    Add(L"Tcaron",  0x164);
    Add(L"tcaron",  0x165);
    Add(L"Tstrok",  0x166);
    Add(L"tstrok",  0x167);
    Add(L"Utilde",  0x168);
    Add(L"utilde",  0x169);
    Add(L"Umacr",   0x16A);
    Add(L"umacr",   0x16B);
    Add(L"Uring",   0x16E);
    Add(L"uring",   0x16F);
    Add(L"Udblac",  0x170);
    Add(L"udblac",  0x171);
    Add(L"Uogon",   0x172);
    Add(L"uogon",   0x173);
    Add(L"Yuml",    0x178);
    Add(L"Zacute",  0x179);
    Add(L"zacute",  0x17A);
    Add(L"Zdot",    0x17B);
    Add(L"zdot",    0x17C);
    Add(L"Zcaron",  0x17D);
    Add(L"zcaron",  0x17E);

// Spacing Modifier Letters
//  Add(L"rsquo",   0x2BC);
//  Add(L"lsquo",   0x2BD);
    Add(L"caron",   0x2C7);
    Add(L"breve",   0x2D8);
    Add(L"dot",     0x2D9);
    Add(L"ogon",    0x2DB);
    Add(L"tilde",   0x2DC);
    Add(L"dblacc",  0x2DD);

// Copied from IE4
    Add(L"fnof",    402); // latin small f with hook, =function, =florin, U0192 ISOtech
    Add(L"circ",    710); // modifier letter circumflex accent, U02C6 ISOpub
//  Add(L"tilde",   732); // small tilde, U02DC ISOdia
    Add(L"Alpha",   913); // greek capital letter alpha
    Add(L"Beta",    914); // greek capital letter beta
    Add(L"Gamma",   915); // greek capital letter gamma
    Add(L"Delta",   916); // greek capital letter delta
    Add(L"Epsilon", 917); // greek capital letter epsilon
    Add(L"Zeta",    918); // greek capital letter zeta
    Add(L"Eta",     919); // greek capital letter eta
    Add(L"Theta",   920); // greek capital letter theta
    Add(L"Iota",    921); // greek capital letter iota 
    Add(L"Kappa",   922); // greek capital letter kappa
    Add(L"Lambda",  923); // greek capital letter lambda
    Add(L"Mu",      924); // greek capital letter mu
    Add(L"Nu",      925); // greek capital letter nu
    Add(L"Xi",      926); // greek capital letter xi
    Add(L"Omicron", 927); // greek capital letter omicron
    Add(L"Pi",      928); // greek capital letter pi
    Add(L"Rho",     929); // greek capital letter rho
    Add(L"Sigma",   931); // greek capital letter sigma
    Add(L"Tau",     932); // greek capital letter tau
    Add(L"Upsilon", 933); // greek capital letter upsilon
    Add(L"Phi",     934); // greek capital letter phi
    Add(L"Chi",     935); // greek capital letter chi
    Add(L"Psi",     936); // greek capital letter psi   
    Add(L"Omega",   937); // greek capital letter omega
    Add(L"alpha",   945); // greek small letter alpha
    Add(L"beta",    946); // greek small letter beta
    Add(L"gamma",   947); // greek small letter gamma
    Add(L"delta",   948); // greek small letter delta
    Add(L"epsilon", 949); // greek small letter epsilon
    Add(L"zeta",    950); // greek small letter zeta
    Add(L"eta",     951); // greek small letter eta
    Add(L"theta",   952); // greek small letter theta
    Add(L"iota",    953); // greek small letter iota 
    Add(L"kappa",   954); // greek small letter kappa
    Add(L"lambda",  955); // greek small letter lambda
    Add(L"mu",      956); // greek small letter mu
    Add(L"nu",      957); // greek small letter nu
    Add(L"xi",      958); // greek small letter xi
    Add(L"omicron", 959); // greek small letter omicron
    Add(L"pi",      960); // greek small letter pi
    Add(L"rho",     961); // greek small letter rho
    Add(L"sigmaf",  962); // greek small final sigma
    Add(L"sigma",   963); // greek small letter sigma
    Add(L"tau",     964); // greek small letter tau
    Add(L"upsilon", 965); // greek small letter upsilon
    Add(L"phi",     966); // greek small letter phi
    Add(L"chi",     967); // greek small letter chi
    Add(L"psi",     968); // greek small letter psi   
    Add(L"omega",   969); // greek small letter omega
    Add(L"thetasym",977); // greek small letter theta symbol, U03D1 NEW
    Add(L"upsih",   978); // greek upsilon with hook symbol
    Add(L"piv",     982); // greek pi symbol
    Add(L"ensp",    8194); // en space, U2002 ISOpub
    Add(L"emsp",    8195); // em space, U2003 ISOpub
    Add(L"thinsp",  8201); // thin space, U2009 ISOpub
    Add(L"zwsp",    8203); // zero width space, U200B NEW RFC 2070
    Add(L"zwnj",    8204); // zero width non-joiner, U200C NEW RFC 2070
    Add(L"zwj",     8205); // zero width joiner, U200D NEW RFC 2070
    Add(L"lrm",     8206); // left-to-right mark, U200E NEW RFC 2070
    Add(L"rlm",     8207); // right-to-left mark, U200F NEW RFC 2070
    Add(L"ndash",   8211); // en dash, U2013 ISOpub
    Add(L"mdash",   8212); // em dash, U2014 ISOpub
    Add(L"lsquo",   8216); // left single quotation mark, U2018 ISOnum
    Add(L"rsquo",   8217); // right single quotation mark, U2019 ISOnum
    Add(L"sbquo",   8218); // single low-9 quotation mark, U201A NEW
    Add(L"ldquo",   8220); // left double quotation mark, U201C ISOnum
    Add(L"rdquo",   8221); // right double quotation mark, U201D ISOnum
    Add(L"bdquo",   8222); // double low-9 quotation mark, U201E NEW
    Add(L"dagger",  8224); // dagger, U2020 ISOpub
    Add(L"Dagger",  8225); // double dagger, U2021 ISOpub
    Add(L"bull",    8226); // bullet, =black small circle, U2022 ISOpub
    Add(L"hellip",  8230); // horizontal ellipsis, =three dot leader, U2026 ISOpub
    Add(L"lre",     8234); // Left-to-right embedding, U200F NEW RFC 2070
    Add(L"rle",     8235);
    Add(L"pdf",     8236); // Pop direction format, U200F NEW RFC 2070
    Add(L"lro",     8237); // Left-to-right override, U200F NEW RFC 2070
    Add(L"rlo",     8238); // Right-to-left override, U200F NEW RFC 2070
    Add(L"permil",  8240); // per mille sign, U2030 ISOtech
    Add(L"prime",   8242); // prime, =minutes, =feet, U2032 ISOtech
    Add(L"Prime",   8243); // double prime, =seconds, =inches, U2033 ISOtech
    Add(L"lsaquo",  8249); // single left-pointing angle quotation mark, U2039 ISO proposed
    Add(L"rsaquo",  8250); // single right-pointing angle quotation mark, U203A ISO proposed
    Add(L"oline",   8254); // overline, spacing overscore
    Add(L"frasl",   8260); // fraction slash
    Add(L"iss",     8298); // Inhibit symmetric, U200F NEW RFC 2070 swapping
    Add(L"ass",     8299); // Activate symmetric, U200F NEW RFC 2070 swapping
    Add(L"iafs",    8300); // Inhibit Arabic form, U200F NEW RFC 2070 shaping
    Add(L"aafs",    8301); // Activate Arabic form, U200F NEW RFC 2070 shaping
    Add(L"nads",    8302); // National digit shapes, U200F NEW RFC 2070
    Add(L"nods",    8303); // Nominal digit shapes, U200F NEW RFC 2070
    Add(L"euro",    8364);
    Add(L"image",   8465); // blackletter capital I, =imaginary part, U2111 ISOamso 
    Add(L"weierp",  8472); // script capital P, =power set, =Weierstrass p, U2118 ISOamso 
    Add(L"real",    8476); // blackletter capital R, =real part symbol, U211C ISOamso 
    Add(L"trade",   8482); // trade mark sign, U2122 ISOnum 
    Add(L"TRADE",   8482); // For IE3 compatibility
    Add(L"alefsym", 8501); // alef symbol, =first transfinite cardinal, U2135 NEW 
    Add(L"larr",    8592); // leftwards arrow, U2190 ISOnum 
    Add(L"uarr",    8593); // upwards arrow, U2191 ISOnum
    Add(L"rarr",    8594); // rightwards arrow, U2192 ISOnum 
    Add(L"darr",    8595); // downwards arrow, U2193 ISOnum 
    Add(L"harr",    8596); // left right arrow, U2194 ISOamsa 
    Add(L"crarr",   8629); // downwards arrow with corner leftwards, =carriage return, U21B5 NEW 
    Add(L"lArr",    8656); // leftwards double arrow, U21D0 ISOtech 
    Add(L"uArr",    8657); // upwards double arrow, U21D1 ISOamsa 
    Add(L"rArr",    8658); // rightwards double arrow, U21D2 ISOtech 
    Add(L"dArr",    8659); // downwards double arrow, U21D3 ISOamsa 
    Add(L"hArr",    8660); // left right double arrow, U21D4 ISOamsa 
    Add(L"forall",  8704); // for all, U2200 ISOtech 
    Add(L"part",    8706); // partial differential, U2202 ISOtech  
    Add(L"exist",   8707); // there exists, U2203 ISOtech 
    Add(L"empty",   8709); // empty set, =null set, =diameter, U2205 ISOamso 
    Add(L"nabla",   8711); // nabla, =backward difference, U2207 ISOtech 
    Add(L"isin",    8712); // element of, U2208 ISOtech 
    Add(L"notin",   8713); // not an element of, U2209 ISOtech 
    Add(L"ni",      8715); // contains as member, U220B ISOtech 
    Add(L"prod",    8719); // n-ary product, =product sign, U220F ISOamsb 
    Add(L"sum",     8721); // n-ary sumation, U2211 ISOamsb 
    Add(L"minus",   8722); // minus sign, U2212 ISOtech 
    Add(L"lowast",  8727); // asterisk operator, U2217 ISOtech 
    Add(L"radic",   8730); // square root, =radical sign, U221A ISOtech 
    Add(L"prop",    8733); // proportional to, U221D ISOtech 
    Add(L"infin",   8734); // infinity, U221E ISOtech 
    Add(L"ang",     8736); // angle, U2220 ISOamso 
    Add(L"and",     8743); // logical and, =wedge, U2227 ISOtech 
    Add(L"or",      8744); // logical or, =vee, U2228 ISOtech 
    Add(L"cap",     8745); // intersection, =cap, U2229 ISOtech 
    Add(L"cup",     8746); // union, =cup, U222A ISOtech 
    Add(L"int",     8747); // integral, U222B ISOtech 
    Add(L"there4",  8756); // therefore, U2234 ISOtech 
    Add(L"sim",     8764); // tilde operator, =varies with, =similar to, U223C ISOtech 
    Add(L"cong",    8773); // approximately equal to, U2245 ISOtech 
    Add(L"asymp",   8776); // almost equal to, =asymptotic to, U2248 ISOamsr 
    Add(L"ne",      8800); // not equal to, U2260 ISOtech 
    Add(L"equiv",   8801); // identical to, U2261 ISOtech 
    Add(L"le",      8804); // less-than or equal to, U2264 ISOtech 
    Add(L"ge",      8805); // greater-than or equal to, U2265 ISOtech 
    Add(L"sub",     8834); // subset of, U2282 ISOtech 
    Add(L"sup",     8835); // superset of, U2283 ISOtech 
    Add(L"nsub",    8836); // not a subset of, U2284 ISOamsn 
    Add(L"sube",    8838); // subset of or equal to, U2286 ISOtech 
    Add(L"supe",    8839); // superset of or equal to, U2287 ISOtech 
    Add(L"oplus",   8853); // circled plus, =direct sum, U2295 ISOamsb 
    Add(L"otimes",  8855); // circled times, =vector product, U2297 ISOamsb 
    Add(L"perp",    8869); // up tack, =orthogonal to, =perpendicular, U22A5 ISOtech 
    Add(L"sdot",    8901); // dot operator, U22C5 ISOamsb 
    Add(L"lceil",   8968); // left ceiling, =apl upstile, U2308, ISOamsc  
    Add(L"rceil",   8969); // right ceiling, U2309, ISOamsc  
    Add(L"lfloor",  8970); // left floor, =apl downstile, U230A, ISOamsc  
    Add(L"rfloor",  8971); // right floor, U230B, ISOamsc  
    Add(L"lang",    9001); // left-pointing angle bracket, =bra, U2329 ISOtech 
    Add(L"rang",    9002); // right-pointing angle bracket, =ket, U232A ISOtech 
    Add(L"loz",     9674); // lozenge, U25CA ISOpub 
    Add(L"spades",  9824); // black spade suit, U2660 ISOpub 
    Add(L"clubs",   9827); // black club suit, =shamrock, U2663 ISOpub 
    Add(L"hearts",  9829); // black heart suit, =valentine, U2665 ISOpub 
    Add(L"diams",   9830); // black diamond suit, U2666 ISOpub 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\tsource.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1994.
//
//  File:       TSource.cxx
//
//  Contents:   TEXT_SOURCE implementation
//
//  Classes:    CTextSource
//
//  History:    14-Apr-94   KyleP       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <tsource.hxx>
#include <mapper.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::CTextSource, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pFilter] -- IFilter (source of data)
//              [Stat]    -- Chunk statistics
//
//  History:    01-Aug-93 AmyA      Created
//              14-Apr-94 KyleP     Sync with wordbreaker spec
//
//--------------------------------------------------------------------------

CTextSource::CTextSource( IFilter * pFilter, STAT_CHUNK & Stat, CSourceMapper* pMapper )
        : _pMapper (pMapper),
          _pFilter(pFilter),
          _Stat( Stat ),
          _sc( S_OK )
{
#if CIDBG == 1

    CFullPropSpec & ps = *((CFullPropSpec *)&Stat.attribute);

    ciDebugOut(( DEB_WORDS,
                 "TEXT SOURCE: Initial chunk of "
                 "%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\\",
                 ps.GetPropSet().Data1,
                 ps.GetPropSet().Data2,
                 ps.GetPropSet().Data3,
                 ps.GetPropSet().Data4[0], ps.GetPropSet().Data4[1],
                 ps.GetPropSet().Data4[2], ps.GetPropSet().Data4[3],
                 ps.GetPropSet().Data4[4], ps.GetPropSet().Data4[5],
                 ps.GetPropSet().Data4[6], ps.GetPropSet().Data4[7] ));

    if ( ps.IsPropertyName() )
        ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME,
                     "%ws\n", ps.GetPropertyName() ));
    else
        ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME,
                     "0x%x\n", ps.GetPropertyPropid() ));
#endif // CIDBG == 1

    iEnd = 0;
    iCur = 0;
    awcBuffer = _awcFilterBuffer;
    pfnFillTextBuffer = CTextSource::FillBuf;

    if (_pMapper)
    {
        if (_Stat.idChunk == _Stat.idChunkSource)
        {
            _pMapper->NewChunk ( _Stat.idChunk, 0 );
        }
        else
        {
            _pMapper->NewDerivedChunk (
                _Stat.idChunkSource,
                _Stat.cwcStartSource,
                _Stat.cwcLenSource);
        }
    }

    FillBuf( this );
}



//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::FillBuf, public
//
//  Synopsis:   Fills buffer with IFilter::GetText and IFilter::GetChunk
//
//  History:    01-Aug-93 AmyA      Created
//              20-Apr-94 KyleP     Sync with spec
//
//  Notes:      NOTE! In several places, this function casts const away
//              from awcBuffer.  This is an acceptable cast from const to
//              non-const. The buffer is const to the client but non-const
//              to the server.
//
//--------------------------------------------------------------------------

SCODE CTextSource::FillBuf( TEXT_SOURCE * pTextSource )
{
    CTextSource * pthis = (CTextSource *)pTextSource;

    //
    // Never continue past an error condition other than FILTER_E_NO_MORE_TEXT
    //

    if ( FAILED( pthis->_sc ) && pthis->_sc != FILTER_E_NO_MORE_TEXT )
        return( pthis->_sc );

    // Don't allow wordbreaker bugs with iEnd/iCur to overwrite memory.

    Win4Assert ( pthis->iEnd >= pthis->iCur );

    if ( pthis->iCur > pthis->iEnd )
    {
        pthis->_sc = WBREAK_E_END_OF_TEXT;
        return WBREAK_E_END_OF_TEXT;
    }

    //
    // Move any existing text to beginning of buffer.
    //

    ULONG ccLeftOver = pthis->iEnd - pthis->iCur;

    if ( ccLeftOver > 0 )
    {
        RtlMoveMemory( (WCHAR *)pthis->awcBuffer,
                       &pthis->awcBuffer[pthis->iCur],
                       ccLeftOver * sizeof (WCHAR) );
    }

    if (pthis->_pMapper)
    {
        // this much has been processed from the current chunk
        pthis->_pMapper->Advance ( pthis->iCur );
    }

    pthis->iCur = 0;
    pthis->iEnd = ccLeftOver;
    ULONG ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
    const BUFFER_SLOP = 10;  // Buffer is attempted to be filled until BUFFER_SLOP remains

    //
    // Get some more text.  If *previous* call to GetText returned
    // FILTER_S_LAST_TEXT, or FILTER_E_NO_MORE_TEXT then don't even
    // bother trying.
    //

    if ( pthis->_sc == FILTER_S_LAST_TEXT || pthis->_sc == FILTER_E_NO_MORE_TEXT )
        pthis->_sc = FILTER_E_NO_MORE_TEXT;
    else
    {
        pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                               (WCHAR *) &pthis->awcBuffer[ccLeftOver] );

        if ( SUCCEEDED( pthis->_sc ) )
        {
            pthis->iEnd += ccRead;
            ccLeftOver += ccRead;
            ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;

            while ( pthis->_sc == S_OK && ccRead > BUFFER_SLOP )
            {
               //
               // Attempt to fill in as much of buffer as possible before returning
               //
               pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                                      (WCHAR *) &pthis->awcBuffer[ccLeftOver] );
               if ( SUCCEEDED( pthis->_sc ) )
               {
                  pthis->iEnd += ccRead;
                  ccLeftOver += ccRead;
                  ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
               }
            }

#if CIDBG == 1
            DebugPrintBuffer( pthis );
#endif
            //
            // Either return FILTER_S_LAST_TEXT or return S_OK because we have succeeded in
            // adding text to the buffer
            //
            if ( pthis->_sc == FILTER_S_LAST_TEXT )
                 return FILTER_S_LAST_TEXT;
            else
                 return S_OK;
        }

        if ( pthis->_sc != FILTER_E_NO_MORE_TEXT )
        {
            //
            // Weird failure, hence return, else goto next chunk
            //
            return pthis->_sc;
        }
    }

    //
    // Go to next chunk, if necessary.
    //

    while ( pthis->_sc == FILTER_E_NO_MORE_TEXT )
    {
        pthis->_sc = pthis->_pFilter->GetChunk( &pthis->_Stat );

        if ( pthis->_sc == FILTER_E_END_OF_CHUNKS )
            return WBREAK_E_END_OF_TEXT;

        if ( pthis->_sc == FILTER_E_PARTIALLY_FILTERED )
            return WBREAK_E_END_OF_TEXT;

        if ( FAILED( pthis->_sc ) )
            return( pthis->_sc );

        if ( pthis->_Stat.flags & CHUNK_VALUE )
        {
            pthis->_sc = FILTER_E_NO_TEXT;
            return WBREAK_E_END_OF_TEXT;
        }

        if ( pthis->_Stat.breakType != CHUNK_NO_BREAK )
        {
            pthis->_sc = WBREAK_E_END_OF_TEXT;
            return WBREAK_E_END_OF_TEXT;
        }

        ciDebugOut(( DEB_WORDS, "TEXT SOURCE: NoBreak chunk\n" ));

        if (pthis->_pMapper)
        {
            ULONG idChunk = pthis->_Stat.idChunk;
            if (idChunk == pthis->_Stat.idChunkSource)
            {
                pthis->_pMapper->NewChunk ( idChunk, ccLeftOver );
            }
            else
            {
                pthis->_sc = WBREAK_E_END_OF_TEXT;
                return WBREAK_E_END_OF_TEXT;
            }
        }

        ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
        pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                               (WCHAR *) &pthis->awcBuffer[ccLeftOver] );

        if ( SUCCEEDED( pthis->_sc ) )
        {
            pthis->iEnd += ccRead;
            ccLeftOver += ccRead;
            ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;

            while ( pthis->_sc == S_OK && ccRead > BUFFER_SLOP )
            {
               //
               // Attempt to fill in as much of buffer as possible before returning
               //
               pthis->_sc = pthis->_pFilter->GetText( &ccRead,
                                                     (WCHAR *) &pthis->awcBuffer[ccLeftOver] );
               if ( SUCCEEDED( pthis->_sc ) )
               {
                  pthis->iEnd += ccRead;
                  ccLeftOver += ccRead;
                  ccRead = PAGE_SIZE / sizeof(WCHAR) - ccLeftOver;
               }
            }

#if CIDBG == 1
            DebugPrintBuffer( pthis );
#endif
            //
            // Either return FILTER_S_LAST_TEXT or return S_OK because we have succeeded in
            // adding text to the buffer
            //
            if ( pthis->_sc == FILTER_S_LAST_TEXT )
                 return FILTER_S_LAST_TEXT;
            else
                 return S_OK;
        }
    }

    if ( FAILED( pthis->_sc ) )
        return( pthis->_sc );

    if ( ccRead == 0 )
        return WBREAK_E_END_OF_TEXT;

    Win4Assert( pthis->iCur == 0 );
    Win4Assert( pthis->iEnd == ccLeftOver );

    ciDebugOut(( DEB_WORDS, "TEXT SOURCE: Fill buffer with %d characters. %d left over\n",
                 pthis->iEnd, ccLeftOver ));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTextSource::DebugPrintBuffer
//
//  Synopsis:   Debug print the text buffer
//
//  Arguments:  [pThis] -- Pointer to text source
//
//  History:    08-Apr-97   SitaramR      Created
//
//--------------------------------------------------------------------------

void CTextSource::DebugPrintBuffer( CTextSource *pthis )
{
#if CIDBG == 1
   if ( ciInfoLevel & DEB_WORDS )
      {
          ciDebugOut(( DEB_WORDS, "CTextSource::FillBuf -- iCur = %u, iEnd = %u\n",
                       pthis->iCur, pthis->iEnd ));

          BOOL fOk = TRUE;
          for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
          {
              if ( pthis->awcBuffer[i] > 0xFF )
              {
                  fOk = FALSE;
                  break;
              }
          }

          if ( fOk )
          {
              unsigned j = 0;
              WCHAR awcTemp[71];

              for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
              {
                  awcTemp[j] = pthis->awcBuffer[i];
                  j++;

                  if ( j == sizeof(awcTemp)/sizeof(awcTemp[0]) - 1 )
                  {
                      awcTemp[j] = 0;
                      ciDebugOut(( DEB_WORDS, "%ws\n", awcTemp ));
                      j = 0;
                  }
              }

              awcTemp[j] = 0;
              ciDebugOut(( DEB_WORDS, "%ws\n", awcTemp ));
          }
          else
          {
              unsigned j = 0;

              for ( unsigned i = pthis->iCur; i < pthis->iEnd; i++ )
              {
                  if ( 0 == j )
                      ciDebugOut(( DEB_WORDS, "%04X", pthis->awcBuffer[i] ));
                  else if ( 14 == j )
                  {
                      ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X\n", pthis->awcBuffer[i] ));
                  }
                  else
                      ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, " %04X", pthis->awcBuffer[i] ));

                  j++;

                  if ( j > 14 )
                      j = 0;
              }

              ciDebugOut(( DEB_WORDS | DEB_NOCOMPNAME, "\n" ));
          }

      }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\fdriver\propfilt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       propfilt.cxx
//
//  Contents:   Code to filter properties on files
//
//  Classes:    COLEPropertyEnum
//              CDocStatPropertyEnum
//
//  History:    93-Oct-18 DwightKr  Created
//              94-May-23 DwightKr  Converted OFS to use OLE interfaces
//              95-Feb-07 KyleP     Rewrote
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <propspec.hxx>
#include <ciguid.hxx>
#include <tgrow.hxx>

#include "propfilt.hxx"

static CFullPropSpec psAttr( guidStorage, PID_STG_ATTRIBUTES );
static CFullPropSpec psSize( guidStorage, PID_STG_SIZE );

//+-------------------------------------------------------------------------
//
//  Function:   CheckResult
//
//  Synopsis:   DebugOut and Throw on an error
//
//  Arguments:  [hr]       -- result code to be tested
//              [pcError]  -- debugout string for debug builds
//
//  History     95-Dec-19 dlee      created
//
//--------------------------------------------------------------------------

static inline void CheckResult(
    HRESULT hr,
    char *  pcError )
{
    if ( !SUCCEEDED( hr ) )
    {
        ciDebugOut(( DEB_IERROR, pcError, hr ));
        THROW( CException( hr ) );
    }
} //CheckResult

//+-------------------------------------------------------------------------
//
//  Member:     CDocStatPropertyEnum::CDocStatPropertyEnum, public
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CDocStatPropertyEnum::CDocStatPropertyEnum( ICiCOpenedDoc * Document )
    : _PropertyStorage( 0 )
{
    //
    //  Safely get property storage
    //
    {
        IPropertyStorage *PropertyStorage;
        HRESULT hr = Document->GetStatPropertyEnum( &PropertyStorage );

        CheckResult( hr, "Could not get stat property storage %x\n" );

        _PropertyStorage.Set( PropertyStorage );
    }

    //
    //  Safely get property enumerator
    //
    {
        IEnumSTATPROPSTG *PropertyEnum;
        HRESULT hr = _PropertyStorage->Enum( &PropertyEnum );

        CheckResult( hr, "Could not get property enum %x\n" );

        _PropertyEnum.Set( PropertyEnum );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDocStatPropertyEnum::~CDocStatPropertyEnum, public
//
//  Synopsis:   Destructor
//
//  History:    93-Nov-27 DwightKr  Created
//
//--------------------------------------------------------------------------

CDocStatPropertyEnum::~CDocStatPropertyEnum()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CDocStatPropertyEnum::GetPropertySetLocale, public
//
//  Synopsis:   Get locale if available
//
//  Arguments:  [locale] - Locale
//
//  Returns:    HRESULT from property storage
//
//--------------------------------------------------------------------------

HRESULT CDocStatPropertyEnum::GetPropertySetLocale(LCID & locale)
{
    return ::GetPropertySetLocale(_PropertyStorage.GetPointer(), locale);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDocStatPropertyEnum::CacheVariant, public
//
//  Synopsis:   Load a specfied variant into the cache
//
//  Arguments:  [propid] - PROPID specifying what to load
//
//  Returns:    HRESULT from property storage
//
//--------------------------------------------------------------------------

HRESULT CDocStatPropertyEnum::CacheVariant( PROPID propid )
{
    //
    //  Set up propspec for property read
    //

    PROPSPEC prspec;
    prspec.ulKind = PRSPEC_PROPID;
    prspec.propid = propid;

    //
    //  Read out the property value
    //

    PROPVARIANT var;
    HRESULT hr = _PropertyStorage->ReadMultiple( 1, &prspec, &var );

    if (!SUCCEEDED( hr )) {
        return hr;
    }

    //
    //  Set up storage variant
    //

    switch ( var.vt )
    {
    case VT_I8:
        _varCurrent.SetI8( var.hVal );
        break;

    case VT_LPWSTR:
        _varCurrent.SetLPWSTR( var.pwszVal );

        if ( !_varCurrent.IsValid() )
            return E_OUTOFMEMORY;

        break;

    case VT_UI4:
        _varCurrent.SetUI4( var.lVal );
        break;

    case VT_FILETIME:
        _varCurrent.SetFILETIME( var.filetime );
        break;

    default:
        ciDebugOut(( DEB_IERROR, "Unknown storage type %x\n", var.vt ));
        break;
    }

    PropVariantClear( &var );

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDocStatPropertyEnum::Next, public
//
//  Synopsis:   Move to next property
//
//  Arguments:  [ps] -- Property Specification returned
//
//  Returns:    Property value, or 0 if end of properties.
//
//  History:    95-Feb-07  KyleP  Created
//
//--------------------------------------------------------------------------

CStorageVariant const * CDocStatPropertyEnum::Next( CFullPropSpec & ps )
{
    //
    //  Get the next property in the enumeration
    //

    STATPROPSTG StatPropStg;
    ULONG cFetched;
    HRESULT hr = _PropertyEnum->Next( 1, &StatPropStg, &cFetched );

    //
    //  If we failed or there were no more to fetch, then we're done
    //

    if (!SUCCEEDED( hr ) || 0 == cFetched)
        return 0;

    Win4Assert( NULL == StatPropStg.lpwstrName );

    //
    //  Load the property returned by the enumeration
    //

    hr = CacheVariant( StatPropStg.propid );

    if (!SUCCEEDED( hr ))
        return 0;

    //
    //  Set guid and propid for full property set
    //

    ps.SetPropSet( guidStorage );
    ps.SetProperty( StatPropStg.propid );

    //
    //  Return the cached property
    //

    return &_varCurrent;
} //Next

//+-------------------------------------------------------------------------
//
//  Member:     COLEPropertySetEnum::Next, public
//
//  Synopsis:   Move to next property set
//
//  Returns:    Pointer to GUID of property set.  0 if at end of sets.
//
//  History     95-Dec-19 dlee      created
//
//--------------------------------------------------------------------------

GUID const * COLEPropertySetEnum::Next()
{
    if ( 0 == _xPropSetEnum.GetPointer() )
        return 0;

    //  Have we exhaused the current buffer of property sets?  If so, then
    //  load up another buffer.

    if ( _iPropSet == _cPropSets )
    {
        _iPropSet  = 0;
        _cPropSets = 0;

        HRESULT hr = _xPropSetEnum->Next( cMaxSetsCached,
                                          _aPropSets,
                                          &_cPropSets );

        CheckResult( hr, "PropSetEnum->Next failed hr = 0x%x\n" );
    }

    if ( _cPropSets > 0 )
    {
        _iPropSet++;
        return &_aPropSets[ _iPropSet - 1 ].fmtid;
    }
    else
    {
        return 0;
    }
} //Next

//+-------------------------------------------------------------------------
//
//  Member:     COLEPropertySetEnum::COLEPropertySetEnum, public
//
//  Synopsis:   Opens a storage, property set storage, and enumerator
//
//  Arguments:  [Document]     -- opened document
//
//  History     95-Dec-19 dlee      created
//
//--------------------------------------------------------------------------

COLEPropertySetEnum::COLEPropertySetEnum(
    ICiCOpenedDoc *Document )
    : _cPropSets(   0 ),
      _iPropSet(    0 ),
      _fIsStorage(  FALSE )
{
    IPropertySetStorage * pPropertySetStorage;
    HRESULT hr = Document->GetPropertySetEnum( &pPropertySetStorage );

    if ( SUCCEEDED( hr ) )
    {
        if (FILTER_S_NO_PROPSETS != hr)
        {
            _fIsStorage = TRUE;

            //  Save away property set storage

            _xPropSetStg.Set( pPropertySetStorage );

            IEnumSTATPROPSETSTG *pPropSetEnum;
            hr = _xPropSetStg->Enum( &pPropSetEnum );

            if ( E_NOTIMPL == hr )
            {
                _fIsStorage = FALSE;
                _xPropSetStg.Free();
            }
            else
            {
                CheckResult( hr, "PropSetStg->Enum() failed hr = 0x%x\n" );
                _xPropSetEnum.Set( pPropSetEnum );
            }
        }
    }
    else
    {
        // don't raise just because it wasn't a docfile

        if ( STG_E_FILEALREADYEXISTS != hr )
            CheckResult( hr, "StgOpenStorage() failed hr = 0x%x\n" );
    }
} //COLEPropertySetEnum

//+-------------------------------------------------------------------------
//
//  Member:     COLEPropertyEnum::COLEPropertyEnum, public
//
//  Synopsis:   Constructor for class that enumerates all properties on
//              a docfile.
//
//  Arguments:  [Document]      -- opened document
//
//  History     95-Dec-19 dlee      created
//
//--------------------------------------------------------------------------

COLEPropertyEnum::COLEPropertyEnum( ICiCOpenedDoc * Document )
    : _pguidCurrent( 0 ),
      _PropSetEnum(  Document ),
      _Codepage( CP_ACP ),
      _cValues(      0 ),
      _iCurrent(     0 ),
      _fCustomOfficePropset( FALSE )
{
    Document->AddRef( );
    _xDocument.Set( Document );
    _pguidCurrent = _PropSetEnum.Next();

    END_CONSTRUCTION( COLEPropertyEnum );
} //COLEPropertyEnum

//+-------------------------------------------------------------------------
//
//  Member:     COLEPropertyEnum::GetPropertySetLocale, public
//
//  Synopsis:   Gets locale, if any.
//
//  Arguments:  [locale]      -- locale, if any
//
//  History     99-Mar-24 KrishnaN      created
//
//--------------------------------------------------------------------------

HRESULT COLEPropertyEnum::GetPropertySetLocale(LCID & locale)
{

    XInterface<IPropertyStorage> xPropStorage;

    IPropertyStorage *pPropStg = 0;
    HRESULT hr = _PropSetEnum.GetPSS()->Open( FMTID_UserDefinedProperties,
                                              STGM_READ |
                                                STGM_SHARE_EXCLUSIVE,
                                              &pPropStg );

    if (FAILED(hr))
    {
        Win4Assert(0 == pPropStg);
        ciDebugOut(( DEB_IERROR, "PropSetStg->Open() failed hr = 0x%x\n", hr ));
        return hr;
    }

    Win4Assert( 0 != pPropStg );

    xPropStorage.Set( pPropStg );

    return ::GetPropertySetLocale(xPropStorage.GetPointer(), locale);
}

//+-------------------------------------------------------------------------
//
//  Member:     COLEPropertyEnum::FillCache, private
//
//  Synopsis:   Loads the next property values for the current or next
//              property set.
//
//  History     95-Dec-19 dlee      created
//
//--------------------------------------------------------------------------

BOOL COLEPropertyEnum::FillCache()
{
    do
    {
        // all out of property sets?

        if ( 0 == _pguidCurrent )
        {
            //
            //  If we are to filter the custom office propertyset, then do it
            //  after we've filtered all other properties.
            //
            if ( _fCustomOfficePropset )
            {
                _fCustomOfficePropset = FALSE;
                _pguidCurrent = &FMTID_UserDefinedProperties;
            }
            else
            {
                return FALSE;
            }
        }

        FreeCache();

        //
        //  If this is the office property set, then we need to also try
        //  to filter the office CUSTOM property set.
        //
        if ( *_pguidCurrent == FMTID_SummaryInformation )
        {
            _fCustomOfficePropset = TRUE;
        }

        // Open the property storage if not yet open

        if ( 0 == _xPropStorage.GetPointer() )
        {
            IPropertyStorage *pPropStg;
            HRESULT hr = _PropSetEnum.GetPSS()->Open( *_pguidCurrent,
                                                      STGM_READ |
                                                         STGM_SHARE_EXCLUSIVE,
                                                      &pPropStg );

            //
            // The special second-section property set will return a
            // special failure code if it doesn't exist.  Check for this
            // code and ignore the property set.
            // OLE returns STG_E_FILENOTFOUND and the shell returns E_FAIL
            //

            if ( ( ( E_FAIL == hr ) || ( STG_E_FILENOTFOUND == hr ) ) &&
                 ( FMTID_UserDefinedProperties == *_pguidCurrent ) )
            {
                return FALSE;
            }

            CheckResult( hr, "PropSetStg->Open() failed hr = 0x%x\n" );

            Win4Assert( 0 != pPropStg );

            if ( 0 == pPropStg )
            {
                ciDebugOut(( DEB_WARN,
                             "IPropertySetStorage::Open( ) returned null property set and hr = 0x%x\n",
                             hr ));

                _pguidCurrent = _PropSetEnum.Next();
                continue;
            }

            _xPropStorage.Set( pPropStg );

            //
            // Look for codepage
            //

            PROPSPEC psCodepage = { PRSPEC_PROPID, PID_CODEPAGE };
            PROPVARIANT varCodepage;

            hr = _xPropStorage->ReadMultiple( 1, &psCodepage, &varCodepage );

            if ( SUCCEEDED(hr) && VT_I2 == varCodepage.vt && varCodepage.iVal != CP_WINUNICODE )
                _Codepage = (unsigned short) varCodepage.iVal;
            else
                _Codepage = CP_ACP;


            Win4Assert( 0 == _xPropEnum.GetPointer() );

            IEnumSTATPROPSTG *pPropEnum;
            hr = pPropStg->Enum( &pPropEnum );
            CheckResult( hr, "PropStg->Enum() failed hr = 0x%x\n" );
            _xPropEnum.Set( pPropEnum );
        }

        HRESULT hr = _xPropEnum->Next( cMaxValuesCached, _aSPS, &_cValues );
        CheckResult( hr, "PropEnum->Next failed sc = 0x%x\n" );

        if ( _cValues > 0 )
        {
            for ( unsigned i = 0; i < _cValues; i++ )
            {
                if ( 0 != _aSPS[i].lpwstrName)
                {
                    _aPropSpec[i].ulKind = PRSPEC_LPWSTR;
                    _aPropSpec[i].lpwstr = _aSPS[i].lpwstrName;
                }
                else
                {
                    _aPropSpec[i].ulKind = PRSPEC_PROPID;
                    _aPropSpec[i].propid = _aSPS[i].propid;
                }
            }

            hr = _xPropStorage->ReadMultiple( _cValues,
                                              _aPropSpec,
                                              _aPropVals );

            CheckResult( hr, "ReadMultiple failed sc = 0x%x\n" );

            //
            // HACK #274: Translate the Ole summary information LPSTR in LPWSTR
            //            Makes these properties compatible with HTML filter
            //            equivalents.
            //

            if ( FMTID_SummaryInformation == *_pguidCurrent )
            {
                for ( i = 0; i < _cValues; i++ )
                {
                    if ( ( VT_LPSTR == _aPropVals[i].Type() ) &&
                         ( 0 != _aPropVals[i].GetLPSTR() ) )
                    {
                        // ciDebugOut(( DEB_ITRACE, "Converting \"%s\" to Unicode\n", _aPropVals[i].GetLPSTR() ));

                        unsigned cc = strlen( _aPropVals[i].GetLPSTR() ) + 1;

                        XGrowable<WCHAR> xwcsProp( cc + (cc * 10 / 100) );  // 10% fluff

                        unsigned ccT = 0;

                        while ( 0 == ccT )
                        {
                            ccT = MultiByteToWideChar( _Codepage,
                                                       0, // precomposed used of the codepage supports it
                                                       _aPropVals[i].GetLPSTR(),
                                                       cc,
                                                       xwcsProp.Get(),
                                                       xwcsProp.Count() );

                            if ( 0 == ccT )
                            {
                                if ( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
                                {
                                    unsigned ccNeeded = MultiByteToWideChar( _Codepage,
                                                                             0, // precomposed used of the codepage supports it
                                                                             _aPropVals[i].GetLPSTR(),
                                                                             cc,
                                                                             0,
                                                                             0 );
                                    Win4Assert( ccNeeded > 0 );

                                    xwcsProp.SetSize( ccNeeded );
                                }
                                else
                                {
                                    ciDebugOut(( DEB_ERROR, "Error %d converting %s to codepage 0x%x\n",
                                                 GetLastError(), _aPropVals[i].GetLPSTR(), _Codepage ));

                                    ccT = 0;
                                    break;
                                }
                            }
                        }

                        if ( ccT != 0 )
                            _aPropVals[i].SetLPWSTR( xwcsProp.Get() );
                    }
                }
            }

            return TRUE;
        }
        else
        {
            // move on to the next property set

            _xPropEnum.Acquire()->Release();
            _xPropStorage.Acquire()->Release();

            _pguidCurrent = _PropSetEnum.Next();
        }
    } while ( TRUE );

    Win4Assert( !"never-never code path" );
    return FALSE;
} //FillCache

//+-------------------------------------------------------------------------
//
//  Member:     COLEPropertyEnum::Next, public
//
//  Synopsis:   Moves to next property
//
//  Arguments:  [ps] -- Content index propspec returned here
//
//  Returns:    Pointer to property value.  0 if at end.
//
//  History     95-Dec-19 dlee      created
//
//--------------------------------------------------------------------------

CStorageVariant const * COLEPropertyEnum::Next(
    CFullPropSpec & ps )
{
    //
    //  If we have exhausted the cache, then try to fill it
    //

    if ( _cValues == _iCurrent && !FillCache() ) {
        return 0;
    }

    //
    //  If the document is being requested, bail out
    //

    BOOL fInUse;
    _xDocument->IsInUseByAnotherProcess( &fInUse );

    if ( fInUse )
    {
        ciDebugOut(( DEB_ITRACE, "Oplock broken while filtering OLE properties\n" ));
        QUIETTHROW( CException( STATUS_OPLOCK_BREAK_IN_PROGRESS ) );
    }

    //
    //  Set up the full property spec
    //
    ps.SetPropSet( *_pguidCurrent );

    if ( PRSPEC_LPWSTR == _aPropSpec[_iCurrent].ulKind )
        ps.SetProperty( _aPropSpec[_iCurrent].lpwstr );
    else
        ps.SetProperty( _aPropSpec[_iCurrent].propid );

    _iCurrent++;

    return( (CStorageVariant const *) &_aPropVals[_iCurrent-1] );
} //Next

//+-------------------------------------------------------------------------
//
//  Member:     COLEPropertyEnum::FreeCache, private
//
//  Synopsis:   Frees memory for the loaded properties and their specs
//
//  History     95-Dec-19 dlee      created
//
//--------------------------------------------------------------------------

void COLEPropertyEnum::FreeCache()
{
    for ( unsigned i = 0; i < _cValues; i++ )
    {
        PropVariantClear( (PROPVARIANT *) (void *) ( & _aPropVals[ i ] ) );
        if ( PRSPEC_LPWSTR == _aPropSpec[i].ulKind )
            CoTaskMemFree( _aSPS[i].lpwstrName );
    }

    _iCurrent = 0;
    _cValues = 0;
} //FreeCache


//+-------------------------------------------------------------------------
//
//  Member:     GetPropertySetLocale
//
//  Synopsis:   Reads the locale, if any, from property storage
//
//  History     99-Mar-24 KrishnaN      created
//
//--------------------------------------------------------------------------

HRESULT GetPropertySetLocale(IPropertyStorage *pPropStorage, LCID & locale)
{
    
    Win4Assert(0 != pPropStorage );

    PROPSPEC ps;
    PROPVARIANT prop;

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = PID_LOCALE;

    // Get the locale for properties
    HRESULT hr = pPropStorage->ReadMultiple (1, 
                                   &ps, 
                                   &prop);
    if(SUCCEEDED(hr))
    {
        if(prop.vt == VT_EMPTY)
        {
            hr = E_FAIL;
        }
        else
        {
            Win4Assert(prop.vt == VT_UI4);
            locale = prop.ulVal;
            // PropVariantClear(&prop);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\anchor.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       anchor.cxx
//
//  Contents:   Parsing algorithm for anchor tag in Html
//
//  Classes:    CAnchorTag
//
// Notes:
// 
// On the start tag e.g. <a href=URL> the previous tag's handler detects
// the AnchorToken and switches the state machine to this handler.  For
// the start tag this handler parses the tag string and saves a copy of
// the URL in _pwcHrefBuf.  The GetChunk for the start tag immediately
// returns FILTER_E_NO_MORE_TEXT.  
//
// The next call to GetChunk() then detects e.g. body text and switches
// the state machine to TextToken or whatever is detected.  That content
// is then filtered independent of the anchor tag, if text it is emitted
// as ordinary body text.
//
// When the anchor end tag </a> is detected, a chunk is returned containing
// the text saved from the anchor start tag.  I don't understand why it
// was done this way, instead of just implementing it as a simple parameter
// tag in which the start tag triggers the output and the end tag is ignored.
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::CAnchorTag
//
//  Synopsis:   Constructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CAnchorTag::CAnchorTag( CHtmlIFilter& htmlIFilter,
                        CSerialStream& serialStream )
    : CHtmlElement(htmlIFilter, serialStream),
      _pwcHrefBuf(0),
      _uLenHrefBuf(0),
      _cHrefChars(0),
      _cHrefCharsFiltered(0)
{
}

void
CAnchorTag::Reset (void)
{
    _cHrefChars = 0;
    _cHrefCharsFiltered = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::~CAnchorTag
//
//  Synopsis:   Destructor
//
//  Arguments:  [htmlIFilter]    -- Html IFilter
//              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CAnchorTag::~CAnchorTag()
{
    delete[] _pwcHrefBuf;
}


//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

SCODE CAnchorTag::GetText( ULONG *pcwcOutput, WCHAR *awcBuffer )
{
    // Do nothing for the start tag; everything happens for the end tag only.

    if ( IsStartToken() )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    // End tag, return the URL saved from the start tag.

    ULONG cCharsRemaining = _cHrefChars - _cHrefCharsFiltered;

    if ( cCharsRemaining == 0 )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    if ( *pcwcOutput < cCharsRemaining )
    {
        RtlCopyMemory( awcBuffer,
                       _pwcHrefBuf + _cHrefCharsFiltered,
                       *pcwcOutput * sizeof(WCHAR) );
        _cHrefCharsFiltered += *pcwcOutput;

                FixPrivateChars (awcBuffer, *pcwcOutput);

        return S_OK;
    }
    else
    {
        RtlCopyMemory( awcBuffer,
                       _pwcHrefBuf + _cHrefCharsFiltered,
                       cCharsRemaining * sizeof(WCHAR) );
        _cHrefCharsFiltered += cCharsRemaining;
        *pcwcOutput = cCharsRemaining;

                FixPrivateChars (awcBuffer, cCharsRemaining);

        return FILTER_S_LAST_TEXT;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CAnchorTag::InitStatChunk
//
//  Synopsis:   Initializes the STAT_CHUNK
//
//  Arguments:  [pStat] -- STAT_CHUNK to initialize
//
//  Returns:    TRUE if a chunk is emitted, FLASE otherwise
//
//  History:    14-Jan-2000    KitmanH    HREF chunks are emitted with 
//                                        LOCALE_NEUTRAL
//
//--------------------------------------------------------------------------

BOOL CAnchorTag::InitStatChunk( STAT_CHUNK *pStat )
{
    PTagEntry pTE = GetTagEntry();

    pStat->idChunk = 0;
    pStat->flags = CHUNK_TEXT;
    pStat->locale = _htmlIFilter.GetCurrentLocale();
    pStat->breakType = CHUNK_EOS;

        pStat->idChunkSource = 0;
        pStat->cwcStartSource = 0;
        pStat->cwcLenSource = 0;

        // Has side effect that if a <a> follows a <a> w/o intervening </a>,
        // the FIRST rather than the SECOND <a> is ignored i.e. any start tag
        // overwrites the previous start tag's state.

    if ( IsStartToken())
    {
        //
        // Start tag, save a copy of the URL in the href=
        //

        _cHrefChars = 0;
        _cHrefCharsFiltered = 0;

        _scanner.ReadTagIntoBuffer();

        if (pTE->GetParamName() == NULL || !pTE->HasPropset())
                return FALSE;

        pTE->GetFullPropSpec (pStat->attribute);

        WCHAR *pwcHrefBuf;
        unsigned cHrefChars;
        _scanner.ScanTagBuffer( pTE->GetParamName(), pwcHrefBuf, cHrefChars );

        //
        // Need to grow internal buffer ?
        //
        if ( cHrefChars > _uLenHrefBuf )
        {
            delete[] _pwcHrefBuf;
            _pwcHrefBuf = 0;
            _uLenHrefBuf = 0;

            _pwcHrefBuf = new WCHAR[cHrefChars];
            _uLenHrefBuf = cHrefChars;
        }

        //
        //  Special handling for JAVA script HREF
        //  Format:
        //  <A HREF="javascript:document.url='<Actual URL>';">
        //  This special handling will extract the "Actual URL"
        //  in effect making the above anchor the same as
        //  <A HREF="<Actual URL>">
        //
        BOOL fJavaScriptHref = FALSE;
        unsigned uPrefixLen = ITEMCOUNT(JAVA_SCRIPT_HREF_PREFIX) - 1;
        if(cHrefChars > uPrefixLen)
        {
            if(_wcsnicmp(pwcHrefBuf, JAVA_SCRIPT_HREF_PREFIX, uPrefixLen) == 0)
            {
                fJavaScriptHref = TRUE;
            }
        }

        if(fJavaScriptHref)
        {
            //
            //  Assuming the JAVA script HREF has correct syntax, the end
            //  will be a single quote followed by a semi-colon. The "- 2"
            //  strips out these 2 characters.
            //
            int cActualHrefChars = cHrefChars - uPrefixLen;

            // Only subtract the two if it's really available.

            if ( cActualHrefChars >= 2 )
                cActualHrefChars -= 2;

            RtlCopyMemory(_pwcHrefBuf, pwcHrefBuf + uPrefixLen, cActualHrefChars*sizeof(WCHAR));
            _cHrefChars = cActualHrefChars;
        }
        else
        {
            RtlCopyMemory( _pwcHrefBuf, pwcHrefBuf, cHrefChars*sizeof(WCHAR) );
            _cHrefChars = cHrefChars;
        }

        _cHrefCharsFiltered = 0;

        return FALSE;
    }
    else
    {
       //
       // End tag, emit the href= URL saved from the start tag.
       // 

        _scanner.EatTag();

        // Unaccompanied end-tag

        if ( _cHrefChars == 0)
            return FALSE;

        if (pTE->GetParamName() == NULL || !pTE->HasPropset())
            return FALSE;

        pTE->GetFullPropSpec (pStat->attribute);

        pStat->idChunk = _htmlIFilter.GetNextChunkId();

        //
        // Set up the filter region to be the one between the start and end
        // anchor tags, i.e. the region belonging to the current Html element,
        // because we haven't changed state yet.
        //
        _htmlIFilter.GetCurHtmlElement()->InitFilterRegion( pStat->idChunkSource,
                                                            pStat->cwcStartSource,
                                                            pStat->cwcLenSource );
                pStat->locale = LOCALE_NEUTRAL;

        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\atlext.h ===
/************************************************/
/*												*/
/*			C O M M O N     A T L				*/
/*			 E X T E N S I O N S				*/
/*												*/
/* file: ATLEXT.H								*/
/*												*/
/* This file contains useful extensions to		*/
/* templates defined by ATL						*/
/*												*/
/* classes:										*/
/*	TComEnumVarCollImpl - implements			*/
/*		IEnumVARIANT on using an iterator		*/
/*	TComEnumVarColl - implements the COM		*/
/*		object that derives from the Impl.		*/
/*												*/
/* Copyright(C) by Microsoft Corp., 1996		*/
/* Author: Dmitriy Meyerzon						*/
/************************************************/

#ifndef __ATLEXT_H
#define __ATLEXT_H

#include <atlbase.h>
#include <atlcom.h>
#include "semcls.h"
#include "islist.h"
#include "irerror.h"
#include "nounkslist.h"

template <class T, class Collection, class Iterator>
class TComEnumVarCollImpl : public IEnumVARIANT
{
	public:
	TComEnumVarCollImpl() {}
	~TComEnumVarCollImpl() {}

	STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)() 
	{
		m_Iterator.Reset();
		return S_OK;
	}
	STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
	
	STDMETHOD(Init)(Collection *pCollection);

	HRESULT InitClone(TComEnumVarCollImpl<T, Collection, Iterator> *pEnum);
	
	private:
	TNoUnkSListIter<T> m_Iterator;
	TNoUnkSList<T> m_Collection;
};

template <class T, class Collection, class Iterator>
STDMETHODIMP TComEnumVarCollImpl<T,Collection,Iterator>::Next(ULONG celt, VARIANT* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
	{
		return E_POINTER;
	}

	HRESULT hr = S_OK;

	DWORD dwFetched;
	for(dwFetched=0; 
		dwFetched < celt; 
		dwFetched++, rgelt++)
	{
		if(++m_Iterator == FALSE) break;

		VariantInit(rgelt);
		IDispatch *pDispatch;
		T* pT;
		if(FAILED(m_Iterator.GetCurrentValue(&pT))) break;
		if(FAILED(pT->GetUnknown()->QueryInterface(IID_IDispatch, (void **)&pDispatch)))
		{
			break;
		}
        pT->GetUnknown()->Release();
		rgelt->vt = VT_DISPATCH;
		rgelt->pdispVal = pDispatch;
	}

	if (dwFetched < celt)
	{
		hr = S_FALSE;
	}

	if (pceltFetched != NULL)
		*pceltFetched = dwFetched;

	return hr;
}

template <class T, class Collection, class Iterator>
STDMETHODIMP TComEnumVarCollImpl<T,Collection,Iterator>::Skip(ULONG celt)
{
	HRESULT hr = S_OK;

	for(unsigned u=0; u<celt; u++)
	{
		if(++m_Iterator == FALSE)
		{
			hr = S_FALSE;
		}
	}

	return S_OK;
}

template <class T, class Collection, class Iterator>
STDMETHODIMP TComEnumVarCollImpl<T,Collection,Iterator>::Clone(IEnumVARIANT** ppEnum)
{
	typedef CComObject<TComEnumVarColl<T, Collection, Iterator> > _class;

	HRESULT hr;
	
	if (ppEnum == NULL) return E_POINTER;

	TPointer<_class> p;
	ATLTRY(p = new _class)
	if (p == NULL)
	{
		*ppEnum = NULL;
		hr = E_OUTOFMEMORY;
	}
	else
	{
		// If the data is a copy then we need to keep "this" object around
		hr = p->InitClone(this);
		if (SUCCEEDED(hr))
		{
			hr = p->_InternalQueryInterface(IID_IEnumVARIANT, (void**)ppEnum);
			if (SUCCEEDED(hr))
			{
				p = NULL;	//let reference counting take care of the object
			}
		}
	}
	
	return hr;
}

template <class T, class Collection, class Iterator>
HRESULT TComEnumVarCollImpl<T,Collection,Iterator>::Init(Collection *pCollection) 
{
	if(pCollection == NULL)
	{
		return E_POINTER;
	}

	Iterator iter(*pCollection);

	while(++iter)
	{
		TComNoUnkPointer<T> pT;
		iter.GetCurrentValue(&pT);
		m_Collection.Append(pT);
	}

	//becuase there is no init method on the iterator, we are faking it by constructing a new one and using =
	TNoUnkSListIter<T> ListIter(m_Collection);
	m_Iterator = ListIter;

	return S_OK;
}

template <class T, class Collection, class Iterator>
HRESULT TComEnumVarCollImpl<T,Collection,Iterator>::InitClone(TComEnumVarCollImpl<T,Collection,Iterator> *pEnum) 
{
	if(pEnum == NULL)
	{
		return E_POINTER;
	}

	TNoUnkSListIter<T> iter(pEnum->m_Collection);

	while(++iter)
	{
		TComNoUnkPointer<T> pT;
		iter.GetCurrentValue(&pT);
		m_Collection.Append(pT);
	}

	//becuase there is no init method on the iterator, we are faking it by constructing a new one and using =
	TNoUnkSListIter<T> ListIter(m_Collection);
	m_Iterator = ListIter;

	return S_OK;
}

template <class T, class Collection, class Iterator>
class TComEnumVarColl: 
    public TComEnumVarCollImpl<T, Collection, Iterator>, 
	public CComObjectRootEx<CComMultiThreadModelNoCS>
{
	public:
	
	typedef TComEnumVarColl<T, Collection, Iterator> _CComEnum;
	typedef TComEnumVarCollImpl<T, Collection, Iterator> _CComEnumBase;
	
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(IID_IEnumVARIANT, _CComEnumBase)
	END_COM_MAP()
};


    template <class I, const IID* piid, const CLSID *plibid, 
			class T, class Collection, class Iterator>
class TCollection:
	public CComDualImpl<I, piid, plibid>,
	public CComISupportErrorInfoImpl<piid>,
	public CComObjectRootEx<CComMultiThreadModelNoCS>
{
	public:
	TCollection(): m_fInitialized(FALSE) {}
	~TCollection() {}

	typedef TCollection<I,piid,plibid, T, Collection, Iterator> _class;
	typedef CComObject<TComEnumVarColl<T,Collection,Iterator> > _enumvar;

	BEGIN_COM_MAP(_class)
		COM_INTERFACE_ENTRY2(IDispatch,I)
		COM_INTERFACE_ENTRY_IID(*piid,I)
		COM_INTERFACE_ENTRY(ISupportErrorInfo)
	END_COM_MAP()

	STDMETHOD(Init)(Collection &rCollection, CSyncReadWrite &rSemaphore, LPVOID pReserved = NULL)
	{
		ASSERT(pReserved == NULL);
		m_pCollection = &rCollection;
		m_pSemaphore = &rSemaphore;
		m_fInitialized = TRUE;
		return S_OK;
	}

	STDMETHOD(get_Count)(long *pCount)
	{
		if(m_fInitialized == FALSE) return E_UNEXPECTED;
		if(pCount == NULL) return E_POINTER;
		*pCount = m_pCollection->GetEntries();
		return S_OK;
	}

	STDMETHOD(get_Item)(BSTR bstrName, VARIANT *pVar);
	STDMETHOD(get__NewEnum)(IUnknown **pNewEnum);

    protected:
    Collection *m_pCollection;
	CSyncReadWrite *m_pSemaphore;
	BOOL m_fInitialized;
};

template <class I, const IID* piid, const CLSID *plibid, 
			class T, class Collection, class Iterator>
STDMETHODIMP TCollection<I,piid,plibid,T,Collection,Iterator>::get_Item(BSTR bstrName, VARIANT *pVar)
{
	if(m_fInitialized == FALSE) return E_UNEXPECTED;

	NameString key(bstrName);
	CLMSubStr lookupName(key);
	TComNoUnkPointer<T> pT;

	CNonExclusive lock(*m_pSemaphore);
	HRESULT hr = m_pCollection->Lookup(&lookupName, &pT);
	if(FAILED(hr) || hr == S_FALSE)
	{
		return hr;
	}

	VariantInit(pVar);
	IDispatch *pDispatch;
	hr = pT->GetUnknown()->QueryInterface(IID_IDispatch, (void **)&pDispatch);
	if(FAILED(hr))
	{
		return hr;
	}
	
	pVar->vt = VT_DISPATCH;
	pVar->pdispVal = pDispatch;

	return S_OK;
}

template <class I, const IID* piid, const CLSID *plibid, 
			class T, class Collection, class Iterator>
STDMETHODIMP TCollection<I,piid,plibid,T,Collection,Iterator>::get__NewEnum(IUnknown **pNewEnum)
{
	if(m_fInitialized == FALSE) return E_UNEXPECTED;
	if(pNewEnum == NULL) return E_POINTER;

	*pNewEnum = NULL;

	TPointer<_enumvar> pEnumVar = new _enumvar;
	if(pEnumVar == NULL) return E_OUTOFMEMORY;

	CNonExclusive lock(*m_pSemaphore);

	HRESULT hr = pEnumVar->Init(m_pCollection);
	if(FAILED(hr)) return hr;

	hr = pEnumVar->QueryInterface(IID_IEnumVARIANT, (void **)pNewEnum);
	
	if(SUCCEEDED(hr))
	{
		pEnumVar = NULL;
	}

	return hr;
}

//
// TNoKeyCollection - Item method is based on index into collection
//
template <class I, const IID* piid, const CLSID *plibid, 
			class T, class Collection, class Iterator>
class TNoKeyCollection:
	public CComDualImpl<I, piid, plibid>,
	public CComISupportErrorInfoImpl<piid>,
	public CComObjectRootEx<CComMultiThreadModelNoCS>
{
	public:
	TNoKeyCollection(): m_fInitialized(FALSE) {}
	~TNoKeyCollection() {}

	typedef TNoKeyCollection<I,piid,plibid, T, Collection, Iterator> _class;
	typedef CComObject<TComEnumVarColl<T,Collection,Iterator> > _enumvar;

	BEGIN_COM_MAP(_class)
		COM_INTERFACE_ENTRY2(IDispatch,I)
		COM_INTERFACE_ENTRY_IID(*piid,I)
		COM_INTERFACE_ENTRY(ISupportErrorInfo)
	END_COM_MAP()

	STDMETHOD(Init)(Collection &rCollection, CSyncReadWrite &rSemaphore, LPVOID pReserved = NULL)
	{
		ASSERT(pReserved == NULL);
		m_pCollection = &rCollection;
		m_pSemaphore = &rSemaphore;
		m_fInitialized = TRUE;
		return S_OK;
	}

	STDMETHOD(get_Count)(long *pCount)
	{
		if(m_fInitialized == FALSE) return E_UNEXPECTED;
		if(pCount == NULL) return E_POINTER;
		*pCount = m_pCollection->GetEntries();
		return S_OK;
	}

	STDMETHOD(get_Item)(LONG lIndex, VARIANT *pVar);
	STDMETHOD(get__NewEnum)(IUnknown **pNewEnum);

    protected:
    Collection *m_pCollection;
	CSyncReadWrite *m_pSemaphore;
	BOOL m_fInitialized;
};

template <class I, const IID* piid, const CLSID *plibid, 
			class T, class Collection, class Iterator>
STDMETHODIMP TNoKeyCollection<I,piid,plibid,T,Collection,Iterator>::get_Item(LONG lIndex, VARIANT *pVar)
{
	if(m_fInitialized == FALSE) return E_UNEXPECTED;

	TComNoUnkPointer<T> pT;

	CNonExclusive lock(*m_pSemaphore);
	HRESULT hr = m_pCollection->GetAt(lIndex, &pT);
	if(FAILED(hr) || hr == S_FALSE)
	{
		return hr;
	}

	VariantInit(pVar);
	IDispatch *pDispatch;
	hr = pT->GetUnknown()->QueryInterface(IID_IDispatch, (void **)&pDispatch);
	if(FAILED(hr))
	{
		return hr;
	}
	
	pVar->vt = VT_DISPATCH;
	pVar->pdispVal = pDispatch;

	return S_OK;
}

template <class I, const IID* piid, const CLSID *plibid, 
			class T, class Collection, class Iterator>
STDMETHODIMP TNoKeyCollection<I,piid,plibid,T,Collection,Iterator>::get__NewEnum(IUnknown **pNewEnum)
{
	if(m_fInitialized == FALSE) return E_UNEXPECTED;
	if(pNewEnum == NULL) return E_POINTER;

	*pNewEnum = NULL;

	TPointer<_enumvar> pEnumVar = new _enumvar;
	if(pEnumVar == NULL) return E_OUTOFMEMORY;

	CNonExclusive lock(*m_pSemaphore);
	
	HRESULT hr = pEnumVar->Init(m_pCollection);
	if(FAILED(hr)) return hr;

	hr = pEnumVar->QueryInterface(IID_IEnumVARIANT, (void **)pNewEnum);
	
	if(SUCCEEDED(hr))
	{
		pEnumVar = NULL;
	}

	return hr;
}

//use this template to implement an object declared as a member variable
//inside another object, but you don't want the QI of these objects to
//be chained
template <class Base> class CComContainedNoOuterQI: public Base
{
public:
	typedef Base _BaseClass;
	CComContainedNoOuterQI(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}

	STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
	STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	
	DECLARE_GET_CONTROLLING_UNKNOWN()
};


//it's OK to AddRef and Release an object on the stack, as long as all
//pointers are released before it is destructed.
//in that case an exception will be thrown - this should not happen.

template <class Base>
class CComObjectStackRefCount : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectStackRefCount(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectStackRefCount() 
	{
		FinalRelease();
		if(m_dwRef) throw CException(E_UNEXPECTED);
	}

	STDMETHOD_(ULONG, AddRef)() {  return InternalAddRef(); }
	STDMETHOD_(ULONG, Release)()
	{ 
		ULONG l = InternalRelease();
		if(l == (ULONG)-1) throw CException(E_UNEXPECTED);
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	HRESULT m_hResFinalConstruct;
};


//
//connection points
//

template <const IID *piid>
class ATL_NO_VTABLE TComEnumConnOnUIterImpl : public IEnumConnections
{
	public:
	TComEnumConnOnUIterImpl() {}
	~TComEnumConnOnUIterImpl() {}

	STDMETHOD(Next)(ULONG celt, CONNECTDATA* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)() 
	{
		m_Iterator.Reset();
		return S_OK;
	}
	STDMETHOD(Clone)(IEnumConnections** ppEnum);
	
	STDMETHOD(Init)(CUnkSList *pList);
	
	private:
	CUnkSListIter m_Iterator;
	CUnkSList m_List;
};

template <const IID *piid>
STDMETHODIMP TComEnumConnOnUIterImpl<piid>::Next(ULONG celt, CONNECTDATA* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
	{
		return E_POINTER;
	}

	HRESULT hr = S_OK;

	DWORD dwFetched;
	for(dwFetched=0; 
		dwFetched < celt; 
		dwFetched++, rgelt++)
	{
		if(++m_Iterator == FALSE) break;

		TComPointer<IUnknown> pUnk;
		if(FAILED(m_Iterator.GetCurrentValue(&pUnk))) break;

		if(FAILED(pUnk->QueryInterface(*piid, (void **)rgelt->pUnk))) break;
		rgelt->dwCookie = (DWORD)rgelt->pUnk;
	}

	if (dwFetched < celt)
	{
		hr = S_FALSE;
	}

	if (pceltFetched != NULL)
		*pceltFetched = dwFetched;

	return hr;
}

template <const IID *piid>
STDMETHODIMP TComEnumConnOnUIterImpl<piid>::Skip(ULONG celt)
{
	HRESULT hr = S_OK;

	CNonExclusive lock(*m_pSemaphore);

	for(unsigned u=0; u<celt; u++)
	{
		if(++m_Iterator == FALSE)
		{
			hr = S_FALSE;
		}
	}

	return S_OK;
}

template <const IID *piid>
STDMETHODIMP TComEnumConnOnUIterImpl<piid>::Clone(IEnumConnections** ppEnum)
{
	typedef CComObject<TComEnumConnOnUIter<piid> > _class;

	HRESULT hr;
	
	if (ppEnum == NULL) return E_POINTER;

	TPointer<_class> p;
	ATLTRY(p = new _class)
	if (p == NULL)
	{
		*ppEnum = NULL;
		hr = E_OUTOFMEMORY;
	}
	else
	{
		// If the data is a copy then we need to keep "this" object around
		hr = p->Init(&m_List);
		if (SUCCEEDED(hr))
		{
			hr = p->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
			if (SUCCEEDED(hr))
			{
				p = NULL;	//let reference counting take care of the object
			}
		}
	}
	
	return hr;
}

template <const IID *piid>
HRESULT TComEnumConnOnUIterImpl<piid>::Init(CUnkSList *pList) 
{
	if(pList == NULL)
	{
		return E_POINTER;
	}

	CUnkSListIter next(*pList);
	while(++next)
	{
		TComPointer<IUnknown> pUnk;
		next.GetCurrentValue(&pUnk);
		m_List.Append(pUnk);
	}
	
	CUnkSListIter Iter(m_List);
	m_Iterator = Iter;

	return S_OK;
}

template <const IID *piid>
class TComEnumConnOnUIter: 
	public TComEnumConnOnUIterImpl<piid>, 
	public CComObjectRootEx<CComMultiThreadModelNoCS>
{
	public:
	
	typedef TComEnumConnOnUIter<piid> _CComEnum;
	typedef TComEnumConnOnUIterImpl<piid> _CComEnumBase;
	
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(IID_IEnumConnections, _CComEnumBase)
	END_COM_MAP()
};

//
//	IConnectionPointULstImpl
//

template <class T, const IID* piid>
class ATL_NO_VTABLE IConnectionPointULstImpl : public _ICPLocator<piid>
{
	typedef TComEnumConnOnUIter<piid> CComEnumConnections;

	public:

	IConnectionPointULstImpl(): m_srwConnectionsListAccess(TRUE) {}
	~IConnectionPointULstImpl() {}

	STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject)
	{
		if (InlineIsEqualGUID(riid, IID_IConnectionPoint) || InlineIsEqualGUID(riid, IID_IUnknown))
		{
			*ppvObject = this;
#ifdef _ATL_DEBUG_REFCOUNT
			_DebugAddRef();
#else
			AddRef();
#endif
			return S_OK;
		}
		else
			return E_NOINTERFACE;
	}
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IConnectionPointULstImpl)

	STDMETHOD(GetConnectionInterface)(IID* piid2)
	{
		if (piid2 == NULL)
			return E_POINTER;
		*piid2 = *piid;
		return S_OK;
	}
	STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC)
	{
		if (ppCPC == NULL)
			return E_POINTER;
		*ppCPC = reinterpret_cast<IConnectionPointContainer*>(
			(IConnectionPointContainerImpl<T>*)(T*)this);
		return S_OK;
	}
	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
	STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);
	
	CUnkSList &GetConnections() { return m_ConnectionsList; }
	CSyncReadWrite &GetConnListSemaphore() { return m_srwConnectionsListAccess; }

	private:
	CSyncReadWrite m_srwConnectionsListAccess;
	CUnkSList m_ConnectionsList;
};

template <class T, const IID* piid>
STDMETHODIMP IConnectionPointULstImpl<T,piid>::Advise(IUnknown* pUnkSink,
	DWORD* pdwCookie)
{
	TComPointer<IUnknown> p;
	
	HRESULT hr = S_OK;

	if (pUnkSink == NULL || pdwCookie == NULL)
		return E_POINTER;

	hr = pUnkSink->QueryInterface(*piid, (void**)&p);
	if (SUCCEEDED(hr))
	{
		CExclusive lock(m_srwConnectionsListAccess);
		m_ConnectionsList.Append(p);
		*pdwCookie = (DWORD)(IUnknown *)p;
	}
	else if (hr == E_NOINTERFACE)
		hr = CONNECT_E_CANNOTCONNECT;
	return hr;
}

template <class T, const IID* piid>
STDMETHODIMP IConnectionPointULstImpl<T,piid>::Unadvise(DWORD dwCookie)
{
	CExclusive lock(m_srwConnectionsListAccess);

	IUnknown* p = (IUnknown  *)dwCookie;

	HRESULT hr = (m_ConnectionsList.Remove(p) == S_OK) ? S_OK : CONNECT_E_NOCONNECTION;
	if (hr == S_OK && p != NULL)
		p->Release();
	return hr;
}

template <class T, const IID* piid>
STDMETHODIMP IConnectionPointULstImpl<T,piid>::EnumConnections(
	IEnumConnections** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComObject<CComEnumConnections>* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnections>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
	
	CNonExclusive lock(m_srwConnectionsListAccess);

	pEnum->Init(&m_ConnectionsList);

	HRESULT hr = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
	if (FAILED(hr))
		delete pEnum;
	return hr;
}

template <class T> inline HRESULT SetComError(HRESULT hr, const IID &riid = GUID_NULL)
{
	if(FAILED(hr))
	{
		T::Error(ErrorMessage(hr), riid, hr);
	}

	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\bldver.h ===
/*bldver.h*/

/******************************************************************
**
** This file is automatically generated by BLDVER.EXE.
** Do not attempt to change this file manually. Your changes will
** be overwritten during the next build.
**
********************************************************************/

#if !defined(_BLDVER_H_)
#define _BLDVER_H_
#define BUILD_NUMBER                            "1315.0"                        /* String version */
#define BUILD_NUM                                       1315,0                          /* int version */
#define BUILD_VERSION BUILD_NUMBER
#define ICW16_VERSION                           "3.0.1315.0\0"          /* VERSIONINFO string */
#define ICW16_VERSION_BINARY            3,0,1315,0                      /* VERSIONINFO binary */
#define ICW32_VERSION                           "4.71.1315.0\0" /* VERSIONINFO string */
#define ICW32_VERSION_BINARY            4,71,1315,0             /* VERSIONINFO binary */
#define ISBU_VERSION                            "7.0.1315.0\0"          /* VERSIONINFO string */
#define ISBU_VERSION_BINARY                     7,0,1315,0                      /* VERSIONINFO binary */
#endif // !defined(_BLDVER_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\dbgconst.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Net Library System
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       dbgconst.h
//
//  Contents:   Debug constants for indexing.
//
//  History:    6-24-97   srikants   Created
//
//----------------------------------------------------------------------------

#ifndef _DBGCONST_H_
#define _DBGCONST_H_

#define DBGT_TRACEA     TCHAR('A')
#define DBGT_TRACEB     TCHAR('B')
#define DBGT_TRACEC     TCHAR('C')
#define DBGT_TRACED     TCHAR('D')
#define DBGT_ERROR      TCHAR('E')
#define DBGT_TRACEF     TCHAR('F')
#define DBGT_TRACEG     TCHAR('G')
#define DBGT_PROPS      TCHAR('P')
#define DBGT_TRACE      TCHAR('T')
#define DBGT_VERBOSE    TCHAR('V')
#define DBGT_WARNING    TCHAR('W')

#endif  // _DBGCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\feconvrt.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1991 - 1996
//
//  File:   fecnvrt.cxx
//
//  Contents:   Japanese JIS/EUC to S-JIS converter, auto detector
//
//-----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CJPNAutoDetector::CJPNAutoDectector
//
//  Purpose:    Auto detects Japanese chars
//
//  Arguments:  [serialStream]  --  Serial stream to read from
//
//----------------------------------------------------------------------------

CJPNAutoDetector::CJPNAutoDetector( CSerialStream& serialStream )
    : _fCodePageFound( FALSE )
{
    Win4Assert( g_feConverter.IsLoaded() );

    ULONG ulSize = serialStream.GetFileSize();

    //
    // Autodetector proc takes ints only
    //
    if ( ulSize > INT_MAX )
        ulSize = INT_MAX;

	if ( ulSize != 0)
	{
		serialStream.MapAll();

		UCHAR *pBuf = (UCHAR *) serialStream.GetBuffer();

		_ulCodePage = g_feConverter.GetAutoDetectorProc()( pBuf, ulSize );

		if ( _ulCodePage == CODE_JPN_JIS
			 || _ulCodePage == CODE_JPN_EUC
			 || _ulCodePage == CODE_JPN_SJIS )
		{
			_fCodePageFound = TRUE;
		}
	}

    serialStream.Rewind();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\except.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1991-1996 Microsoft Corporation.
//
//  File:       Except.cxx
//
//  Contents:   Conversion to Ole errors
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

typedef LONG NTSTATUS;

//+-------------------------------------------------------------------------
//
//  Method:     IsOleError, public
//
//  Synopsis:   return TRUE if sc looks like an OLE SCODE.
//
//--------------------------------------------------------------------------

inline BOOL IsOleError (NTSTATUS sc)
{
    return ((sc & 0xFFF00000) == 0x80000000) ||
           (SUCCEEDED(sc) && (sc & 0xFFFFF000) != 0);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetOleError, public
//
//  Purpose:    Converts a status code to an Ole error code, because interfaces
//              return Ole error code only.
//
//--------------------------------------------------------------------------

SCODE GetOleError(CException & e)
{
    NTSTATUS scError = e.GetErrorCode();

    if (IsOleError(scError))
    {
        return scError;
    }
    else if ( STATUS_NO_MEMORY == scError )
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        return E_FAIL;
    }
}

void _cdecl SystemExceptionTranslator( unsigned int uiWhat,
                                       struct _EXCEPTION_POINTERS * pexcept )
{
    throw CException( uiWhat ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\deferred.cxx ===
//+---------------------------------------------------------------------------
//
//      Copyright (C) Microsoft Corporation, 1992-2000.
//
//      File:           deferred.cxx
//
//      Contents:       Mechanism for buffering same-propspec value chunks into 
//                              VT_LPWSTR|VT_VECTOR chunks as needed
//
//      Classes:        
//
//      History:        09-May-97       BobP            Created
// 
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <pkmguid.hxx>

//+-------------------------------------------------------------------------
//
//      Method:         CDeferTag::CDeferTag
//
//      Synopsis:       Constructor
//
//      Arguments:      [htmlIFilter]    -- Html IFilter
//                              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CDeferTag::CDeferTag( CHtmlIFilter& htmlIFilter,
                                        CSerialStream& serialStream )
        : CHtmlElement(htmlIFilter, serialStream),
          _eState(NoMoreDeferredValue),
          _pValue(NULL)
{
}

CDeferTag::~CDeferTag ()
{
        Reset();
}

void
CDeferTag::Reset (void)
{
        // Free any allocated state that client didn't fetch

        if (_pValue) {
                FreeVariant (_pValue);
                _pValue = NULL;
        }
}

//+-------------------------------------------------------------------------
//
//      Method:         CDeferTag::GetValue
//
//      Synopsis:       Retrieves a deferred tag value
//
//      Arguments:      [ppPropValue] -- Value returned here
//
//--------------------------------------------------------------------------

SCODE CDeferTag::GetValue( VARIANT **ppPropValue )
{
        switch ( _eState )
        {
        case FilteringDeferredValue:
                _eState = NoMoreDeferredValue;

                Win4Assert(_pValue);
                *ppPropValue = _pValue;
                _pValue = NULL;                         // assign ownership to caller
                return S_OK;

        case NoMoreDeferredValue:
        default:
                return FILTER_E_NO_MORE_VALUES;
        }
}

//+-------------------------------------------------------------------------
//
//      Method:         CDeferTag::InitStatChunk
//
//      Synopsis:       Initializes the STAT_CHUNK.
//                              Sets up a deferred value to return, if there is one.
//
//                              Note that there is no PTagEntry for this handler, since it did
//                              not come directly from a tag.
//
//      Arguments:      [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CDeferTag::InitStatChunk( STAT_CHUNK *pStat )
{
        pStat->idChunk = 0;
        pStat->breakType = CHUNK_EOS;
        pStat->flags = CHUNK_VALUE;
        pStat->locale = _htmlIFilter.GetCurrentLocale();
        pStat->idChunkSource = pStat->idChunk;
        pStat->cwcStartSource = 0;
        pStat->cwcLenSource = 0;

        Reset();

        if ( _htmlIFilter.GetLanguageProperty() )
        {
                // Return 

                pStat->attribute.guidPropSet = CLSID_NetLibraryInfo;
                pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
                pStat->attribute.psProperty.propid = PID_LANGUAGE;

                _pValue = _htmlIFilter.GetLanguageProperty();
                _htmlIFilter.GetLanguageProperty() = NULL;   // take ownership

                pStat->idChunk = _htmlIFilter.GetNextChunkId();
                pStat->idChunkSource = pStat->idChunk;

                _eState = FilteringDeferredValue;
                return TRUE;
        }

#ifndef DONT_COMBINE_META_TAGS
        if ( _htmlIFilter.AnyDeferredValues() == TRUE)
        {
                _htmlIFilter.GetDeferredValue (pStat->attribute, _pValue);

                pStat->idChunk = _htmlIFilter.GetNextChunkId();
                pStat->idChunkSource = pStat->idChunk;

                _eState = FilteringDeferredValue;
                return TRUE;
        }
#endif

        _eState = NoMoreDeferredValue;
        _htmlIFilter.ReturnDeferredValuesNow() = FALSE;
        return FALSE;
}


//+-------------------------------------------------------------------------
//
//      Method:         CHeadTag::InitStatChunk
//
//      Synopsis:       Initializes the STAT_CHUNK.
//
//                              This exists for the sole purpose of setting a flag, when
//                              </head> is found, to trigger returning deferred values.
//
//      Arguments:      [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CHeadTag::InitStatChunk( STAT_CHUNK *pStat )
{
        _scanner.EatTag();

        if ( IsStartToken() == FALSE )
                _htmlIFilter.ReturnDeferredValuesNow() = TRUE;

        return FALSE;
}


//+-------------------------------------------------------------------------
//
//      Method:         CCodePageTag::CCodePageTag
//
//      Synopsis:       Constructor
//
//      Arguments:      [htmlIFilter]    -- Html IFilter
//                              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CCodePageTag::CCodePageTag( CHtmlIFilter& htmlIFilter,
                                        CSerialStream& serialStream )
        : CHtmlElement(htmlIFilter, serialStream),
          _eState(NoMoreDeferredValue)
{
}

//+-------------------------------------------------------------------------
//
//      Method:         CCodePageTag::GetValue
//
//      Synopsis:       Retrieves a deferred tag value
//
//      Arguments:      [ppPropValue] -- Value returned here
//
//--------------------------------------------------------------------------

SCODE CCodePageTag::GetValue( VARIANT **ppPropValue )
{
        switch ( _eState )
        {
        case FilteringDeferredValue:
                _eState = NoMoreDeferredValue;

                LPPROPVARIANT pv;
                
                pv = (LPPROPVARIANT) CoTaskMemAlloc (sizeof(PROPVARIANT));
                if (pv == NULL)
                        throw CException(E_OUTOFMEMORY);

                pv->vt = VT_UI4;
                pv->ulVal = _htmlIFilter.GetCodePage();

                *ppPropValue = pv;
                return S_OK;

        case NoMoreDeferredValue:
        default:
                return FILTER_E_NO_MORE_VALUES;
        }
}

//+-------------------------------------------------------------------------
//
//      Method:         CCodePageTag::InitStatChunk
//
//      Synopsis:       Initializes the STAT_CHUNK.
//
//      Arguments:      [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CCodePageTag::InitStatChunk( STAT_CHUNK *pStat )
{
        pStat->idChunk = 0;
        pStat->breakType = CHUNK_EOS;
        pStat->flags = CHUNK_VALUE;
        pStat->locale = _htmlIFilter.GetCurrentLocale();
        pStat->idChunkSource = pStat->idChunk;
        pStat->cwcStartSource = 0;
        pStat->cwcLenSource = 0;

        pStat->attribute.guidPropSet = CLSID_NetLibraryInfo;
        pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
        pStat->attribute.psProperty.propid = PID_NLCODEPAGE;

        pStat->idChunk = _htmlIFilter.GetNextChunkId();
        pStat->idChunkSource = pStat->idChunk;

        _eState = FilteringDeferredValue;
        return TRUE;
}


//+-------------------------------------------------------------------------
//
//      Method:         CMetaRobotsTag::CMetaRobotsTag
//
//      Synopsis:       Constructor for a meta robots tag
//
//      Arguments:      [htmlIFilter]    -- Html IFilter
//                              [serialStream]   -- Input stream
//
//--------------------------------------------------------------------------

CMetaRobotsTag::CMetaRobotsTag( CHtmlIFilter& htmlIFilter,
                                        CSerialStream& serialStream )
        : CHtmlElement(htmlIFilter, serialStream),
          _eState(NoMoreDeferredValue)
{
}

//+-------------------------------------------------------------------------
//
//      Method:         CMetaRobotsTag::GetValue
//
//      Synopsis:       Retrieves a meta robots tag value
//
//      Arguments:      [ppPropValue] -- Value returned here
//
//--------------------------------------------------------------------------

SCODE CMetaRobotsTag::GetValue( VARIANT **ppPropValue )
{
        switch ( _eState )
        {
        case FilteringDeferredValue:
                _eState = NoMoreDeferredValue;

                *ppPropValue = _htmlIFilter.GetMetaRobotsValue();

                // client now "owns" the value
                _htmlIFilter.SetMetaRobotsValue(NULL);

                return S_OK;

        case NoMoreDeferredValue:
        default:
                return FILTER_E_NO_MORE_VALUES;
        }
}

//+-------------------------------------------------------------------------
//
//      Method:         CMetaRobotsTag::InitStatChunk
//
//      Synopsis:       Initializes the STAT_CHUNK.
//
//      Arguments:      [pStat] -- STAT_CHUNK to initialize
//
//--------------------------------------------------------------------------

BOOL CMetaRobotsTag::InitStatChunk( STAT_CHUNK *pStat )
{
        pStat->idChunk = 0;
        pStat->breakType = CHUNK_EOS;
        pStat->flags = CHUNK_VALUE;
        pStat->locale = _htmlIFilter.GetCurrentLocale();
        pStat->idChunkSource = pStat->idChunk;
        pStat->cwcStartSource = 0;
        pStat->cwcLenSource = 0;

        pStat->attribute = _htmlIFilter.GetMetaRobotsAttribute();

        pStat->idChunk = _htmlIFilter.GetNextChunkId();
        pStat->idChunkSource = pStat->idChunk;

        _eState = FilteringDeferredValue;
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//      Method:         CHtmlIFilter::SaveRobotsTag
//
//      Synopsis:       Save the content= attribute of a <meta name=robots ...> tag
//                              to return later.
//
//      Arguments:      [pwc] -- LPWSTR value of the content= attribute
//                              [cwc] -- char count at pwc.
//
//--------------------------------------------------------------------------
void
CHtmlIFilter::SaveRobotsTag (LPWSTR pwc, int cwc)
//
// Remember the content= attribute of a <meta http-equiv=robots ...> tag.
// This is called during the pre-scan for explicit charset and locale tags,
// to save the robots tag to return at the start of the "real" parse.
// Stores a PROPVARIANT ready to be returned as a value chunk.
//
// As implemented, if the doc contains more than one robots tag,
// only the last is remembered.
{
        if (_pMetaRobotsValue != NULL)
        {
                FreeVariant (_pMetaRobotsValue);
                _pMetaRobotsValue = NULL;
        }

        _MetaRobotsAttribute.guidPropSet = PROPSET_MetaInfo;
        _MetaRobotsAttribute.psProperty.ulKind = PRSPEC_LPWSTR;
        _MetaRobotsAttribute.psProperty.lpwstr = L"ROBOTS";

        if ( FFilterProperties() ||
                 IsMatchProperty (_MetaRobotsAttribute) )
        {
                PROPVARIANT *pPropVar = (PROPVARIANT *) CoTaskMemAlloc( sizeof PROPVARIANT );
                if ( pPropVar == 0 )
                        throw CException(E_OUTOFMEMORY);

                pPropVar->vt = VT_LPWSTR;
                pPropVar->pwszVal = (WCHAR *) CoTaskMemAlloc( ( cwc + 1 ) * sizeof( WCHAR ) );
                if ( pPropVar->pwszVal == 0 )
                {
                        CoTaskMemFree( (void *) pPropVar );
                        throw CException(E_OUTOFMEMORY);
                }

                RtlCopyMemory( pPropVar->pwszVal, pwc, cwc * sizeof(WCHAR) );
                pPropVar->pwszVal[cwc] = 0;

                _pMetaRobotsValue = pPropVar;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\cpool.h ===
//#---------------------------------------------------------------
//  File:		CPool.h
//        
//	Synopsis:	Header for the CPool class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//	dmitriym	changed fragments to be unlimited
//----------------------------------------------------------------

#ifndef	__CPOOL_H
#define __CPOOL_H

//#include "irdebug.h"
#include "semcls.h"

#define	DEFAULT_COMMIT_INCREMENT	0
#define	DEFAULT_RESERVE_INCREMENT	0
#define DEFAULT_FRAGMENTS			256
#define DEFAULT_FRAGMENTS_MAX		(2 << 10)	//1 Kilobytes

class CPool
{
		//
		// struct def'n for linking free instances
		// see page 473 of Stroustrup
		//
		struct	Link	{ Link*	pNext; };

	public:
		CPool( DWORD dwSignature=1 );
		~CPool( void );

		//CPool itself will not be allocated using another CPool

	    void *operator new( size_t cSize )
						{ return HeapAlloc( GetProcessHeap(), 0, cSize ); }

	    void operator delete (void *pInstance)
						{ HeapFree( GetProcessHeap(), 0, pInstance ); }

		inline BOOL IsValid();

		//
		// to be called after the constructor to VirtualAlloc the necessary
		// memory address
		//
		HRESULT Init(DWORD dwInstanceSize,
					DWORD dwReservationIncrementInstances = DEFAULT_RESERVE_INCREMENT,
					DWORD dwCommitIncrementInstances = DEFAULT_COMMIT_INCREMENT ); 

		HRESULT ReleaseMemory(BOOL fDestructor = FALSE);

		void*	Alloc();
		void	Free( void* pInstance );

		DWORD	GetCommitCount() const
				{ return	m_cNumberCommitted; }

		DWORD	GetAllocCount() const
				{ return	m_cNumberInUse; }

		DWORD	GetInstanceSize(void) const { return m_cInstanceSize; }

	private:
		//
		// internal function to alloc more mem from the OS
		//
		void 	GrowPool( );
		//
		// Structure signature for a pool object
		// 
		const DWORD			m_dwSignature;

		//
		// size of the descriptor
		//
		DWORD				m_cInstanceSize;
		//
		// virtual array number of committed instances
		//
		DWORD				m_cNumberCommitted;
		//
		// number of In_use instances ( debug/admin only )
		//
		DWORD				m_cNumberInUse;
		//
		// the handle of the pool critical section
		//
		CriticalSection		m_PoolCriticalSection;
		//
		// the pointer to the first descriptor on the free list
		//
		Link				*m_pFreeList;
		//
		// number to increment the pool when expanding
		//
		DWORD				m_cIncrementInstances;

		//
		// size of each fragment in instances
		//
		DWORD				m_cFragmentInstances;

		//
		// maximum number of fragments
		//
		DWORD				m_cFragments;

		//
		// maximum number of fragments
		//
		LPVOID				*m_pFragments;
};



#endif //__CPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\filters\html\source\codepage.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1991 - 2002.
//
//  File:   codepage.hxx
//
//  Contents:   Locale to codepage, charset recognition
//
//-----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

extern const WCHAR * WCSTRING_LANG;
extern const WCHAR * WCSTRING_NEUTRAL;

int __cdecl CodePageEntryCompare(
    WCHAR const *          pwcKey,
    SCodePageEntry const * pEntry )
{
    return wcscmp( pwcKey, pEntry->pwcCodePage );
} //CodePageEntryCompare

int __cdecl LocaleEntryCompare(
    WCHAR const *        pwcKey,
    SLocaleEntry const * pEntry )
{
    return wcscmp( pwcKey, pEntry->pwcLocale );
} //LocaleEntryCompare

const SCodePageEntry g_aCodePageEntries[] =
{
    { L"_iso-2022-jp$esc", CODE_JPN_JIS },
    { L"_iso-2022-jp$sio", CODE_JPN_JIS },
    { L"ansi_x3.4-1968", 1252 },
    { L"ansi_x3.4-1986", 1252 },
    { L"arabic", 28596 },
    { L"ascii", 1252 },
    { L"big5", 950 },
    { L"chinese", 936 },
    { L"cn-gb", 936 },
    { L"cp1256", 1256 },
    { L"cp367", 1252 },
    { L"cp819", 1252 },
    { L"cp852", 852 },
    { L"cp866", 866 },
    { L"csascii", 1252 },
    { L"csbig5", 950 },
    { L"cseuckr", 949 },
    { L"cseucpkdfmtjapanese", CODE_JPN_EUC },
    { L"csgb2312", 936 },
    { L"csiso2022jp", CODE_JPN_JIS },
    { L"csiso2022kr", 50225 },
    { L"csiso58gb231280", 936 },
    { L"csisolatin1", 1252 },
    { L"csisolatin2", 28592 },
    { L"csisolatin4", 28594 },
    { L"csisolatin5", 1254 },
    { L"csisolatinarabic", 28596 },
    { L"csisolatincyrillic", 28595 },
    { L"csisolatingreek", 28597 },
    { L"csisolatinhebrew", 1255 },
    { L"cskoi8r", 20866 },
    { L"csksc56011987", 949 },
    { L"csshiftjis", 932 },
    { L"csunicode11utf7", 65000 },
    { L"cswindows31j", 932 },
    { L"cyrillic", 28595 },
    { L"dos-720", 1256 },
    { L"dos-862", 1255 },
    { L"ecma-114", 28596 },
    { L"ecma-118", 28597 },
    { L"elot_928", 28597 },
    { L"euc-jp", CODE_JPN_EUC },
    { L"euc-kr", 949 },
    { L"extended_unix_code_packed_format_for_japanese", CODE_JPN_EUC },
    { L"gb18030", 54936 },
    { L"gb2312", 936 },
    { L"gb_2312-80", 936 },
    { L"gbk", 936 },
    { L"greek", 28597 },
    { L"greek8", 28597 },
    { L"hebrew", 1255 },
    { L"hz-gb-2312", 52936 },
    { L"ibm367", 1252 },
    { L"ibm819", 1252 },
    { L"ibm852", 852 },
    { L"ibm866", 866 },
    { L"irv", 1252 },
    { L"iso-2022-jp", CODE_JPN_JIS },
    { L"iso-2022-kr", 50225 },
    { L"iso-8859-1", 1252 },
    { L"iso-8859-2", 28592 },
    { L"iso-8859-3", 28593 },
    { L"iso-8859-4", 28594 },
    { L"iso-8859-5", 28595 },
    { L"iso-8859-6", 28596 },
    { L"iso-8859-7", 28597 },
    { L"iso-8859-8", 1255 },
    { L"iso-8859-9", 1254 },
    { L"iso-ir-100", 1252 },
    { L"iso-ir-101", 28592 },
    { L"iso-ir-110", 28594 },
    { L"iso-ir-111", 28594 },
    { L"iso-ir-126", 28597 },
    { L"iso-ir-127", 28596 },
    { L"iso-ir-138", 1255 },
    { L"iso-ir-144", 28595 },
    { L"iso-ir-148", 1254 },
    { L"iso-ir-149", 949 },
    { L"iso-ir-58", 936 },
    { L"iso-ir-6", 1252 },
    { L"iso646-us", 1252 },
    { L"iso8859-1", 1252 },
    { L"iso8859-1", 1252 },
    { L"iso8859-2", 28592 },
    { L"iso8859-2", 28592 },
    { L"iso8859-5", 28595 },
    { L"iso8859-5", 28595 },
    { L"iso_646.irv:1991", 1252 },
    { L"iso_8859-1", 1252 },
    { L"iso_8859-1:1987", 1252 },
    { L"iso_8859-2", 28592 },
    { L"iso_8859-2:1987", 28592 },
    { L"iso_8859-4", 28594 },
    { L"iso_8859-4:1988", 28594 },
    { L"iso_8859-5", 28595 },
    { L"iso_8859-5:1988", 28595 },
    { L"iso_8859-6", 28596 },
    { L"iso_8859-6:1987", 28596 },
    { L"iso_8859-7", 28597 },
    { L"iso_8859-7:1987", 28597 },
    { L"iso_8859-8", 1255 },
    { L"iso_8859-8:1988", 1255 },
    { L"iso_8859-9", 1254 },
    { L"iso_8859-9:1989", 1254 },
    { L"koi", 20866 },
    { L"koi-8-r", 20866 },
    { L"koi8", 20866 },
    { L"koi8-r", 20866 },
    { L"koi8-ru", 20866 },
    { L"korean", 949 },
    { L"ks-c-5601", 949 },
    { L"ks-c-5601-1987", 949 },
    { L"ks-c-5601-1992", 1361 },
    { L"ks_c_5601", 949 },
    { L"ks_c_5601-1987", 949 },
    { L"ks_c_5601-1989", 949 },
    { L"ksc-5601", 949 },
    { L"ksc-5601-1987", 949 },
    { L"ksc-5601-1992", 1361 },
    { L"ksc-5601-1992", 1361 },
    { L"ksc5601", 949 },
    { L"ksc_5601", 949 },
    { L"l1", 1252 },
    { L"l2", 28592 },
    { L"l4", 28594 },
    { L"l5", 1254 },
    { L"latin1", 1252 },
    { L"latin2", 28592 },
    { L"latin4", 28594 },
    { L"latin5", 1254 },
    { L"ms_4551-1", 1252 },
    { L"ms_kanji", 932 },
    { L"ns_4551-1", 1252 },
    { L"sen_850200_b", 1252 },
    { L"shift-jis", 932 },
    { L"shift_jis", 932 },
    { L"sjis", 932 },
    { L"unicode-1-1-utf-7", 65000 },
    { L"unicode-1-1-utf-8", 65001 },
    { L"unicode-2-0-utf-8", 65001 },
    { L"us", 1252 },
    { L"us-ascii", 1252 },
    { L"utf-7", 65000 },
    { L"utf-8", 65001 },
    { L"utf7", 65000 },
    { L"utf8", 65001 },
    { L"windows-1250", 1250 },
    { L"windows-1251", 1251 },
    { L"windows-1252", 1252 },
    { L"windows-1253", 1253 },
    { L"windows-1254", 1254 },
    { L"windows-1255", 1255 },
    { L"windows-1256", 1256 },
    { L"windows-1257", 1257 },
    { L"windows-1258", 1258 },
    { L"windows-874", 874 },
    { L"x-ansi", 1252 },
    { L"x-cp1250", 1250 },
    { L"x-cp1251", 1251 },
    { L"x-euc", CODE_JPN_EUC },
    { L"x-euc-jp", CODE_JPN_EUC },
    { L"x-ms-cp932", 932 },
    { L"x-sjis", 932 },
    { L"x-unicode-2-0-utf-7", 65000 },
    { L"x-unicode-2-0-utf-8", 65001 },
    { L"x-x-big5", 950 },
};

const ULONG g_cCodePageEntries = sizeof g_aCodePageEntries / sizeof g_aCodePageEntries[0];

//
// Note: this table contais both Rfc 1766 (per the HTML spec) and
//       NISO Z39.53 (per general usage of HTML) entries.

const SLocaleEntry g_aLocaleEntries[] =
{
    { L"ace",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Achinese
    { L"ach",     MAKELCID( MAKELANGID( LANG_NEUTRAL,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Acoli
    { L"ada",     MAKELCID( MAKELANGID( LANG_NEUTRAL,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Adangme
    { L"af",      MAKELCID( MAKELANGID( LANG_AFRIKAANS,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Afrikaans
    { L"af-za",   MAKELCID( MAKELANGID( LANG_AFRIKAANS,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Afrikaans - South Africa
    { L"afa",     MAKELCID( MAKELANGID( LANG_AFRIKAANS,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Afro-Asiatic (Other)
    { L"afh",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Afrihili (Artificial language)
    { L"afr",     MAKELCID( MAKELANGID( LANG_AFRIKAANS,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Afrikaans
    { L"ajm",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Aljamia
    { L"akk",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Akkadian
    { L"alb",     MAKELCID( MAKELANGID( LANG_ALBANIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Albanian
    { L"ale",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Aleut
    { L"alg",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Algonquian languages
    { L"amh",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Amharic
    { L"ang",     MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // English, Old (ca. 450-1100)
    { L"apa",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Apache languages
    { L"ar",      MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Arabic
    { L"ar-ae",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_UAE), SORT_DEFAULT ) }, // Arabic - U.A.E
    { L"ar-ar",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_SAUDI_ARABIA), SORT_DEFAULT ) }, // Arabic - Saudi Arabia
    { L"ar-bh",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_BAHRAIN), SORT_DEFAULT ) }, // Arabic - Bahrain
    { L"ar-dz",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_ALGERIA), SORT_DEFAULT ) }, // Arabic - Algeria
    { L"ar-eg",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_EGYPT), SORT_DEFAULT ) }, // Arabic - Egypt
    { L"ar-iq",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_IRAQ), SORT_DEFAULT ) }, // Arabic - Iraq
    { L"ar-jo",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_JORDAN), SORT_DEFAULT ) }, // Arabic - Jordan
    { L"ar-kw",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_KUWAIT), SORT_DEFAULT ) }, // Arabic - Kuwait
    { L"ar-lb",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_LEBANON), SORT_DEFAULT ) }, // Arabic - Lebanon
    { L"ar-ly",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_LIBYA), SORT_DEFAULT ) }, // Arabic - Libya
    { L"ar-ma",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_MOROCCO), SORT_DEFAULT ) }, // Arabic - Morocco
    { L"ar-om",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_OMAN), SORT_DEFAULT ) }, // Arabic - Oman
    { L"ar-qa",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_QATAR), SORT_DEFAULT ) }, // Arabic - Qatar
    { L"ar-sy",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_SYRIA), SORT_DEFAULT ) }, // Arabic - Syria
    { L"ar-tn",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_TUNISIA), SORT_DEFAULT ) }, // Arabic - Tunisia
    { L"ar-ye",   MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_ARABIC_YEMEN), SORT_DEFAULT ) }, // Arabic - Yemen
    { L"ara",     MAKELCID( MAKELANGID( LANG_ARABIC,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Arabic
    { L"arc",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Aramaic
    { L"arm",     MAKELCID( MAKELANGID( LANG_ARMENIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Armenian
    { L"arn",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Araucanian
    { L"arp",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Arapaho
    { L"art",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Artificial (Other)
    { L"arw",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Arawak
    { L"as",      MAKELCID( MAKELANGID( LANG_ASSAMESE,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Assamese
    { L"as-in",   MAKELCID( MAKELANGID( LANG_ASSAMESE,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Assamese - India
    { L"asm",     MAKELCID( MAKELANGID( LANG_ASSAMESE,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Assamese
    { L"ath",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Athapascan languages
    { L"ava",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Avaric
    { L"ave",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Avestan
    { L"awa",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Awadhi
    { L"aym",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Aymara
    { L"az",      MAKELCID( MAKELANGID( LANG_AZERI,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Azeri
    { L"az-az",   MAKELCID( MAKELANGID( LANG_AZERI,      SUBLANG_AZERI_LATIN), SORT_DEFAULT ) }, // Azeri - Azerbaijan (Latin)
    { L"aze",     MAKELCID( MAKELANGID( LANG_AZERI,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Azerbaijani
    { L"bad",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Banda
    { L"bai",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bamileke languages
    { L"bak",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bashkir
    { L"bal",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Baluchi
    { L"bam",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bambara
    { L"ban",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Balinese
    { L"baq",     MAKELCID( MAKELANGID( LANG_BASQUE,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Basque
    { L"bas",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Basa
    { L"bat",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Baltic (Other)
    { L"be",      MAKELCID( MAKELANGID( LANG_BELARUSIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Belarusian
    { L"be-by",   MAKELCID( MAKELANGID( LANG_BELARUSIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Belarusian - Belarus
    { L"bej",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Beja
    { L"bel",     MAKELCID( MAKELANGID( LANG_BELARUSIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Byelorussian
    { L"bem",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Bemba
    { L"ben",     MAKELCID( MAKELANGID( LANG_BENGALI,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Bengali
    { L"ber",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Berber languages
    { L"bg",      MAKELCID( MAKELANGID( LANG_BULGARIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bulgarian
    { L"bg-bg",   MAKELCID( MAKELANGID( LANG_BULGARIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bulgarian - Bulgaria
    { L"bho",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Bhojpuri
    { L"bik",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bikol
    { L"bin",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bini
    { L"bla",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Siksika
    { L"bn",      MAKELCID( MAKELANGID( LANG_BENGALI,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bengali
    { L"bn-in",   MAKELCID( MAKELANGID( LANG_BENGALI,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bengali - India
    { L"bra",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Braj
    { L"bre",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Breton
    { L"bug",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Buginese
    { L"bul",     MAKELCID( MAKELANGID( LANG_BULGARIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Bulgarian
    { L"bur",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Burmese
    { L"ca",      MAKELCID( MAKELANGID( LANG_CATALAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Catalan
    { L"ca-es",   MAKELCID( MAKELANGID( LANG_CATALAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Catalan - Spain
    { L"cad",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Caddo
    { L"cai",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Central American Indian (Other)
    { L"cam",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Khmer
    { L"car",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Carib
    { L"cat",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Catalan
    { L"cau",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Caucasian (Other)
    { L"ceb",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Cebuano
    { L"cel",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Celtic languages
    { L"cha",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Chamorro
    { L"chb",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Chibcha
    { L"che",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Chechen
    { L"chg",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Chagatai
    { L"chi",     MAKELCID( MAKELANGID( LANG_CHINESE,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Chinese
    { L"chn",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Chinook jargon
    { L"cho",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Choctaw
    { L"chr",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Cherokee
    { L"chu",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Church Slavic
    { L"chv",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Chuvash
    { L"chy",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Cheyenne
    { L"cop",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Coptic
    { L"cor",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Cornish
    { L"cpe",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Creoles and Pidgins, English-based (Other)
    { L"cpf",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Creoles and Pidgins, French-based (Other)
    { L"cpp",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Creoles and Pidgins, Portuguese-based (Other)
    { L"cre",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Cree
    { L"crp",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Creoles and Pidgins (Other)
    { L"cs",      MAKELCID( MAKELANGID( LANG_CZECH,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Czech
    { L"cs-cz",   MAKELCID( MAKELANGID( LANG_CZECH,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Czech - Czech Republic
    { L"cus",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Cushitic (Other)
    { L"cze",     MAKELCID( MAKELANGID( LANG_CZECH,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Czech
    { L"da",      MAKELCID( MAKELANGID( LANG_DANISH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Danish
    { L"da-dk",   MAKELCID( MAKELANGID( LANG_DANISH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Danish - Denmark
    { L"dak",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Dakota
    { L"dan",     MAKELCID( MAKELANGID( LANG_DANISH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Danish
    { L"de",      MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_DEFAULT), SORT_GERMAN_PHONE_BOOK ) }, // German
    { L"de-at",   MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_GERMAN_AUSTRIAN), SORT_GERMAN_PHONE_BOOK ) }, // German - Austria
    { L"de-ch",   MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_GERMAN_SWISS), SORT_GERMAN_PHONE_BOOK ) }, // German - Switzerland
    { L"de-de",   MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_GERMAN), SORT_GERMAN_PHONE_BOOK ) }, // German - Germany
    { L"de-li",   MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_GERMAN_LIECHTENSTEIN), SORT_GERMAN_PHONE_BOOK ) }, // German - Liechtenstein
    { L"de-lu",   MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_GERMAN_LUXEMBOURG), SORT_GERMAN_PHONE_BOOK ) }, // German - Luxembourg
    { L"del",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Delaware
    { L"din",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Dinka
    { L"doi",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Dogri
    { L"dra",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Dravidian (Other)
    { L"dua",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Duala
    { L"dum",     MAKELCID( MAKELANGID( LANG_DUTCH,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Dutch, Middle (ca. 1050-1350)
    { L"dut",     MAKELCID( MAKELANGID( LANG_DUTCH,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Dutch
    { L"dyu",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Dyula
    { L"efi",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Efik
    { L"egy",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Egyptian
    { L"eka",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Ekajuk
    { L"el",      MAKELCID( MAKELANGID( LANG_GREEK,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Greek
    { L"el-gr",   MAKELCID( MAKELANGID( LANG_GREEK,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Greek - Greece
    { L"elx",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Elamite
    { L"en",      MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // English
    { L"en-au",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_AUS), SORT_DEFAULT ) }, // English - Australia
    { L"en-bz",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_BELIZE), SORT_DEFAULT ) }, // English - Belize
    { L"en-ca",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_CAN), SORT_DEFAULT ) }, // English - Canada
    { L"en-cb",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_CARIBBEAN), SORT_DEFAULT ) }, // English - Caribbean
    { L"en-gb",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_UK), SORT_DEFAULT ) }, // English - United Kingdom
    { L"en-ie",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_EIRE), SORT_DEFAULT ) }, // English - Ireland
    { L"en-jm",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_JAMAICA), SORT_DEFAULT ) }, // English - Jamaica
    { L"en-nz",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_NZ), SORT_DEFAULT ) }, // English - New Zealand
    { L"en-ph",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_PHILIPPINES), SORT_DEFAULT ) }, // English - Philippines
    { L"en-tt",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_TRINIDAD), SORT_DEFAULT ) }, // English - Trinidad
    { L"en-us",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_US), SORT_DEFAULT ) }, // English - United State
    { L"en-za",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_SOUTH_AFRICA), SORT_DEFAULT ) }, // English - South Africa
    { L"en-zw",   MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_ENGLISH_ZIMBABWE), SORT_DEFAULT ) }, // English - Zimbabwe
    { L"eng",     MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // English
    { L"enm",     MAKELCID( MAKELANGID( LANG_ENGLISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // English, Middle (1100-1500)
    { L"es",      MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Spanish
    { L"es-ar",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_ARGENTINA), SORT_DEFAULT ) }, // Spanish - Argentina
    { L"es-bo",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_BOLIVIA), SORT_DEFAULT ) }, // Spanish - Bolivia
    { L"es-cl",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_CHILE), SORT_DEFAULT ) }, // Spanish - Chile
    { L"es-co",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_COLOMBIA), SORT_DEFAULT ) }, // Spanish - Colombia
    { L"es-cr",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_COSTA_RICA), SORT_DEFAULT ) }, // Spanish - Costa Rica
    { L"es-do",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_DOMINICAN_REPUBLIC), SORT_DEFAULT ) }, // Spanish - Dominican Republic
    { L"es-ec",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_ECUADOR), SORT_DEFAULT ) }, // Spanish - Ecuador
    { L"es-es",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH), SORT_DEFAULT ) }, // Spanish - Spain
    { L"es-gt",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_GUATEMALA), SORT_DEFAULT ) }, // Spanish - Guatemala
    { L"es-hn",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_HONDURAS), SORT_DEFAULT ) }, // Spanish - Honduras
    { L"es-mx",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_MEXICAN), SORT_DEFAULT ) }, // Spanish - Mexico
    { L"es-ni",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_NICARAGUA), SORT_DEFAULT ) }, // Spanish - Nicaragua
    { L"es-pa",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_PANAMA), SORT_DEFAULT ) }, // Spanish - Panama
    { L"es-pe",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_PERU), SORT_DEFAULT ) }, // Spanish - Peru
    { L"es-pr",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_PUERTO_RICO), SORT_DEFAULT ) }, // Spanish - Puerto Rico
    { L"es-py",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_PARAGUAY), SORT_DEFAULT ) }, // Spanish - Paraguay
    { L"es-sv",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_EL_SALVADOR), SORT_DEFAULT ) }, // Spanish - El Salvador
    { L"es-uy",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_URUGUAY), SORT_DEFAULT ) }, // Spanish - Uruguay
    { L"es-ve",   MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_SPANISH_VENEZUELA), SORT_DEFAULT ) }, // Spanish - Venezuela
    { L"esk",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Eskimo
    { L"esp",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Esperanto
    { L"est",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Estonian
    { L"et",      MAKELCID( MAKELANGID( LANG_ESTONIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Estonian
    { L"et-ee",   MAKELCID( MAKELANGID( LANG_ESTONIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Estonian - Estonia
    { L"eth",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Ethiopic
    { L"eu",      MAKELCID( MAKELANGID( LANG_BASQUE,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Basque
    { L"eu-es",   MAKELCID( MAKELANGID( LANG_BASQUE,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Basque - Spain
    { L"ewe",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Ewe
    { L"ewo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Ewondo
    { L"fa",      MAKELCID( MAKELANGID( LANG_FARSI,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Farsi
    { L"fa-ir",   MAKELCID( MAKELANGID( LANG_FARSI,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Farsi - Iran
    { L"fan",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Fang
    { L"far",     MAKELCID( MAKELANGID( LANG_FAEROESE,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Faroese
    { L"fat",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Fanti
    { L"fi",      MAKELCID( MAKELANGID( LANG_FINNISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Finnish
    { L"fi-fi",   MAKELCID( MAKELANGID( LANG_FINNISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Finnish - Finland
    { L"fij",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Fijian
    { L"fin",     MAKELCID( MAKELANGID( LANG_FINNISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Finnish
    { L"fiu",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Finno-Ugrian (Other)
    { L"fo",      MAKELCID( MAKELANGID( LANG_FAEROESE,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Faeroese
    { L"fo-fo",   MAKELCID( MAKELANGID( LANG_FAEROESE,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Faeroese - Faeroe Islands
    { L"fon",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Fon
    { L"fr",      MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // French
    { L"fr-be",   MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_FRENCH_BELGIAN), SORT_DEFAULT ) }, // French - Belgium
    { L"fr-ca",   MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_FRENCH_CANADIAN), SORT_DEFAULT ) }, // French - Canada
    { L"fr-ch",   MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_FRENCH_SWISS), SORT_DEFAULT ) }, // French - Switzerland
    { L"fr-fr",   MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_FRENCH), SORT_DEFAULT ) }, // French - France
    { L"fr-lu",   MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_FRENCH_LUXEMBOURG), SORT_DEFAULT ) }, // French - Luxembourg
    { L"fr-mc",   MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_FRENCH_MONACO), SORT_DEFAULT ) }, // French - Monaco
    { L"fre",     MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, //French
    { L"fri",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Friesian
    { L"frm",     MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // French, Middle (ca. 1400-1600)
    { L"fro",     MAKELCID( MAKELANGID( LANG_FRENCH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  French, Old (ca. 842-1400)
    { L"ful",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Fula
    { L"gaa",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Gaa?
    { L"gae",     MAKELCID( MAKELANGID( LANG_GALICIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Gaelic (Scots)
    { L"gag",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Gallegan
    { L"gal",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Oromo
    { L"gay",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Gayo
    { L"gem",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Germanic (Other)
    { L"geo",     MAKELCID( MAKELANGID( LANG_GEORGIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Georgian
    { L"ger",     MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // German
    { L"gil",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Gilbertese
    { L"gmh",     MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  German, Middle High (ca. 1050-1500)
    { L"goh",     MAKELCID( MAKELANGID( LANG_GERMAN,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // German, Old High (ca. 750-1050)
    { L"gon",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Gondi
    { L"got",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Gothic
    { L"grb",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Grebo
    { L"grc",     MAKELCID( MAKELANGID( LANG_GREEK,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Greek, Ancient (to 1453)
    { L"gre",     MAKELCID( MAKELANGID( LANG_GREEK,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Greek, Modern (1453- )
    { L"gu",      MAKELCID( MAKELANGID( LANG_GUJARATI,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Gujarati
    { L"gu-in",   MAKELCID( MAKELANGID( LANG_GUJARATI,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Gujarati - India
    { L"gua",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Guarani
    { L"guj",     MAKELCID( MAKELANGID( LANG_GUJARATI,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Gujarati
    { L"hai",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Haida
    { L"hau",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Hausa
    { L"haw",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hawaiian
    { L"heb",     MAKELCID( MAKELANGID( LANG_HEBREW,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Hebrew
    { L"her",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Herero
    { L"hi",      MAKELCID( MAKELANGID( LANG_HINDI,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hindi
    { L"hi-in",   MAKELCID( MAKELANGID( LANG_HINDI,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hindi - India
    { L"hil",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Hiligaynon
    { L"him",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Himachali
    { L"hin",     MAKELCID( MAKELANGID( LANG_HINDI,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hindi
    { L"hmo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hiri Motu
    { L"hr",      MAKELCID( MAKELANGID( LANG_CROATIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Croatian
    { L"hr-hr",   MAKELCID( MAKELANGID( LANG_CROATIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Croatian - Croatia
    { L"hu",      MAKELCID( MAKELANGID( LANG_HUNGARIAN,  SUBLANG_DEFAULT), SORT_HUNGARIAN_DEFAULT ) }, // Hungarian
    { L"hu-hu",   MAKELCID( MAKELANGID( LANG_HUNGARIAN,  SUBLANG_DEFAULT), SORT_HUNGARIAN_DEFAULT ) }, // Hungarian - Hungary
    { L"hun",     MAKELCID( MAKELANGID( LANG_HUNGARIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hungarian
    { L"hup",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hupa
    { L"hy",      MAKELCID( MAKELANGID( LANG_ARMENIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Armenian
    { L"hy-am",   MAKELCID( MAKELANGID( LANG_ARMENIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Armenian - Armenia
    { L"iba",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Iban
    { L"ibo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Igbo
    { L"ice",     MAKELCID( MAKELANGID( LANG_ICELANDIC,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Icelandic
    { L"id",      MAKELCID( MAKELANGID( LANG_INDONESIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Indonesian
    { L"id-id",   MAKELCID( MAKELANGID( LANG_INDONESIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Indonesian - Indonesia
    { L"ijo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Ijo
    { L"ilo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Iloko
    { L"inc",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Indic (Other)
    { L"ind",     MAKELCID( MAKELANGID( LANG_INDONESIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Indonesian
    { L"ine",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Indo-European (Other)
    { L"int",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Interlingua (International Auxiliary Language Association)
    { L"ira",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Iranian (Other)
    { L"iri",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Irish
    { L"iro",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Iroquoian languages
    { L"is",      MAKELCID( MAKELANGID( LANG_ICELANDIC,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Icelandic
    { L"is-is",   MAKELCID( MAKELANGID( LANG_ICELANDIC,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Icelandic - Iceland
    { L"it",      MAKELCID( MAKELANGID( LANG_ITALIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Italian
    { L"it-ch",   MAKELCID( MAKELANGID( LANG_ITALIAN,    SUBLANG_ITALIAN_SWISS), SORT_DEFAULT ) }, // Italian - Switzerland
    { L"it-it",   MAKELCID( MAKELANGID( LANG_ITALIAN,    SUBLANG_ITALIAN), SORT_DEFAULT ) }, // Italian - Italy
    { L"ita",     MAKELCID( MAKELANGID( LANG_ITALIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Italian
    { L"iw",      MAKELCID( MAKELANGID( LANG_HEBREW,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hebrew
    { L"iw-il",   MAKELCID( MAKELANGID( LANG_HEBREW,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Hebrew - Israel
    { L"ja",      MAKELCID( MAKELANGID( LANG_JAPANESE,   SUBLANG_DEFAULT), SORT_JAPANESE_UNICODE ) }, // Japanese
    { L"ja-jp",   MAKELCID( MAKELANGID( LANG_JAPANESE,   SUBLANG_DEFAULT), SORT_JAPANESE_UNICODE ) }, // Japanese - Japan
    { L"jav",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Javanese
    { L"jpn",     MAKELCID( MAKELANGID( LANG_JAPANESE,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Japanese
    { L"jpr",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Judeo-Persian
    { L"jrb",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Judeo-Arabic
    { L"ka",      MAKELCID( MAKELANGID( LANG_GEORGIAN,   SUBLANG_DEFAULT), SORT_GEORGIAN_TRADITIONAL ) }, // Georgian
    { L"ka-ge",   MAKELCID( MAKELANGID( LANG_GEORGIAN,   SUBLANG_DEFAULT), SORT_GEORGIAN_TRADITIONAL ) }, // Georgian - Georgia
    { L"kaa",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kara-Kalpak
    { L"kab",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kabyle
    { L"kac",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Kachin
    { L"kam",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kamba
    { L"kan",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kannada
    { L"kar",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Karen
    { L"kas",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kashmiri
    { L"kau",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kanuri
    { L"kaw",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Kawi
    { L"kaz",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Kazakh
    { L"kha",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Khasi
    { L"khi",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Khoisan (Other)
    { L"kho",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Khotanese
    { L"kik",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Kikuyu
    { L"kin",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Kinyarwanda
    { L"kir",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Kirghiz
    { L"kk",      MAKELCID( MAKELANGID( LANG_KAZAK,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kazak
    { L"kk-kz",   MAKELCID( MAKELANGID( LANG_KAZAK,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kazak - Kazakstan
    { L"kn",      MAKELCID( MAKELANGID( LANG_KANNADA,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kannada
    { L"kn-in",   MAKELCID( MAKELANGID( LANG_KANNADA,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kannada - India
    { L"ko",      MAKELCID( MAKELANGID( LANG_KOREAN,     SUBLANG_DEFAULT), SORT_KOREAN_UNICODE ) }, // Korean
    { L"ko-kr",   MAKELCID( MAKELANGID( LANG_KOREAN,     SUBLANG_DEFAULT), SORT_KOREAN_UNICODE ) }, // Korean - Korea
    { L"kok",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Konkani
    { L"kon",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kongo
    { L"kor",     MAKELCID( MAKELANGID( LANG_KOREAN,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Korean
    { L"kpe",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kpelle
    { L"kro",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kru
    { L"kru",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kurukh
    { L"kua",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Kuanyama
    { L"kur",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kurdish
    { L"kus",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kusaie
    { L"kut",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Kutenai
    { L"lad",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Ladino
    { L"lah",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Lahnd
    { L"lam",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Lamba
    { L"lan",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Langue d'oc (post-1500)
    { L"lao",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Lao
    { L"lap",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Lapp
    { L"lat",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Latin
    { L"lav",     MAKELCID( MAKELANGID( LANG_LATVIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Latvian
    { L"lin",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Lingala
    { L"lit",     MAKELCID( MAKELANGID( LANG_LITHUANIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Lithuanian
    { L"lol",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Mongo
    { L"loz",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Lozi
    { L"lt",      MAKELCID( MAKELANGID( LANG_LITHUANIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Lithuanian
    { L"lt-lt",   MAKELCID( MAKELANGID( LANG_LITHUANIAN, SUBLANG_LITHUANIAN), SORT_DEFAULT ) }, // Lithuanian - Lithuania
    { L"lub",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Luba-Katanga
    { L"lug",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Ganda
    { L"lui",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Luiseno
    { L"lun",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Lunda
    { L"luo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Luo (Kenya and Tanzania)
    { L"lv",      MAKELCID( MAKELANGID( LANG_LATVIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Latvian
    { L"lv-lv",   MAKELCID( MAKELANGID( LANG_LATVIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Latvian - Latvia
    { L"mac",     MAKELCID( MAKELANGID( LANG_MACEDONIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Macedonian
    { L"mad",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Madurese
    { L"mag",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Magahi
    { L"mah",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Marshall
    { L"mai",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Maithili
    { L"mak",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Makasar
    { L"mal",     MAKELCID( MAKELANGID( LANG_MALAYALAM,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Malayalam
    { L"man",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Mandingo
    { L"mao",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Maori
    { L"map",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Austronesian (Other)
    { L"mar",     MAKELCID( MAKELANGID( LANG_MARATHI,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Marathi
    { L"mas",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Masai
    { L"max",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Manx
    { L"may",     MAKELCID( MAKELANGID( LANG_MALAY,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Malay
    { L"men",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Mende
    { L"mic",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Micmac
    { L"min",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Minangkabau
    { L"mis",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Miscellaneous (Other)
    { L"mk",      MAKELCID( MAKELANGID( LANG_MACEDONIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Macedonian (fyrom)
    { L"mk-mk",   MAKELCID( MAKELANGID( LANG_MACEDONIAN, SUBLANG_DEFAULT), SORT_DEFAULT ) }, //     Macedonian (fyrom)
    { L"mkh",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Mon-Khmer (Other)
    { L"ml",      MAKELCID( MAKELANGID( LANG_MALAYALAM,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Malayalam
    { L"ml-in",   MAKELCID( MAKELANGID( LANG_MALAYALAM,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Malayalam - India
    { L"mla",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Malagasy
    { L"mlt",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Maltese
    { L"mni",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Manipuri
    { L"mno",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Manobo languages
    { L"moh",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Mohawk
    { L"mol",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Moldavian
    { L"mon",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Mongolian
    { L"mos",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Mossi (MOSs?)
    { L"mr",      MAKELCID( MAKELANGID( LANG_MARATHI,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Marathi
    { L"mr-in",   MAKELCID( MAKELANGID( LANG_MARATHI,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Marathi - India
    { L"ms",      MAKELCID( MAKELANGID( LANG_MALAY,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Malay
    { L"ms-bn",   MAKELCID( MAKELANGID( LANG_MALAY,      SUBLANG_MALAY_BRUNEI_DARUSSALAM), SORT_DEFAULT ) }, // Malay - Brunei Darussalam
    { L"ms-my",   MAKELCID( MAKELANGID( LANG_MALAY,      SUBLANG_MALAY_MALAYSIA), SORT_DEFAULT ) }, // Malay - Malaysia
    { L"mul",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Multiple languages
    { L"mun",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Munda (Other)
    { L"mus",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Creek
    { L"mwr",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Marwari
    { L"myn",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Mayan languages
    { L"nah",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Aztec
    { L"nai",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  North American Indian (Other)
    { L"nav",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Navajo
    { L"nde",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Ndebele (Zimbabwe)
    { L"ndo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Ndonga
    { L"ne",      MAKELCID( MAKELANGID( LANG_NEPALI,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Nepali
    { L"ne-in",   MAKELCID( MAKELANGID( LANG_NEPALI,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Nepali - India
    { L"nep",     MAKELCID( MAKELANGID( LANG_NEPALI,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Nepali
    { L"neutral", MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Neutral (non-standard)
    { L"new",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Newari
    { L"nic",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Niger-Kordofanian (Other)
    { L"niu",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Niuean
    { L"nl",      MAKELCID( MAKELANGID( LANG_DUTCH,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Dutch
    { L"nl-be",   MAKELCID( MAKELANGID( LANG_DUTCH,      SUBLANG_DUTCH_BELGIAN), SORT_DEFAULT ) }, // Dutch - Belgium
    { L"nl-nl",   MAKELCID( MAKELANGID( LANG_DUTCH,      SUBLANG_DUTCH), SORT_DEFAULT ) }, // Dutch - Netherlands
    { L"no",      MAKELCID( MAKELANGID( LANG_NORWEGIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Norwegian
    { L"no-no",   MAKELCID( MAKELANGID( LANG_NORWEGIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Norwegian - Norway
    { L"nor",     MAKELCID( MAKELANGID( LANG_NORWEGIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Norwegian
    { L"nso",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Northern Sotho
    { L"nub",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Nubian languages
    { L"nya",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Nyanja
    { L"nym",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Nyamwezi
    { L"nyn",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Nyankole
    { L"nyo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Nyoro
    { L"nzi",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Nzima
    { L"oji",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Ojibwa
    { L"or",      MAKELCID( MAKELANGID( LANG_ORIYA,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Oriya
    { L"or-in",   MAKELCID( MAKELANGID( LANG_ORIYA,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Oriya - India
    { L"ori",     MAKELCID( MAKELANGID( LANG_ORIYA,      SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Oriya
    { L"osa",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Osage
    { L"oss",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Ossetic
    { L"ota",     MAKELCID( MAKELANGID( LANG_TURKISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Turkish, Ottoman
    { L"oto",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Otomian languages
    { L"pa",      MAKELCID( MAKELANGID( LANG_PUNJABI,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Punjabi
    { L"pa-in",   MAKELCID( MAKELANGID( LANG_PUNJABI,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Punjabi - India
    { L"paa",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Papuan-Australian (Other)
    { L"pag",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Pangasinan
    { L"pal",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Pahlavi
    { L"pam",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Pampanga
    { L"pan",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Panjabi
    { L"pap",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Papiamento
    { L"pau",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Palauan
    { L"peo",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Old Persian (ca. 600-400 B.C.)
    { L"per",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Persian
    { L"pl",      MAKELCID( MAKELANGID( LANG_POLISH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Polish
    { L"pl-pl",   MAKELCID( MAKELANGID( LANG_POLISH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Polish - Poland
    { L"pli",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Pali
    { L"pol",     MAKELCID( MAKELANGID( LANG_POLISH,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Polish
    { L"pon",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Ponape
    { L"por",     MAKELCID( MAKELANGID( LANG_PORTUGUESE, SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Portuguese
    { L"pra",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Prakrit languages
    { L"pro",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Provencal, Old (to 1500)
    { L"pt",      MAKELCID( MAKELANGID( LANG_PORTUGUESE, SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Portuguese
    { L"pt-br",   MAKELCID( MAKELANGID( LANG_PORTUGUESE, SUBLANG_PORTUGUESE_BRAZILIAN), SORT_DEFAULT ) }, // Portuguese-Brazil
    { L"pt-pt",   MAKELCID( MAKELANGID( LANG_PORTUGUESE, SUBLANG_PORTUGUESE), SORT_DEFAULT ) }, // Portuguese - Portugal
    { L"pus",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Pushto
    { L"que",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Quechua
    { L"raj",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Rajasthani
    { L"rar",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Rarotongan
    { L"ro",      MAKELCID( MAKELANGID( LANG_ROMANIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Romanian
    { L"ro-ro",   MAKELCID( MAKELANGID( LANG_ROMANIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Romanian - Romania
    { L"roa",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Romance (Other)
    { L"roh",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Raeto-Romance
    { L"rom",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Romany
    { L"ru",      MAKELCID( MAKELANGID( LANG_RUSSIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Russian
    { L"ru-ru",   MAKELCID( MAKELANGID( LANG_RUSSIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Russian - Russia
    { L"rum",     MAKELCID( MAKELANGID( LANG_ROMANIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Romanian
    { L"run",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Rundi
    { L"rus",     MAKELCID( MAKELANGID( LANG_RUSSIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Russian
    { L"sa",      MAKELCID( MAKELANGID( LANG_SANSKRIT,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Sanskrit
    { L"sa-in",   MAKELCID( MAKELANGID( LANG_SANSKRIT,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Sanskrit - India
    { L"sad",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Sandawe
    { L"sag",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Sango
    { L"sai",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  South American Indian (Other)
    { L"sal",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Salishan languages
    { L"sam",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Samaritan Aramaic
    { L"san",     MAKELCID( MAKELANGID( LANG_SANSKRIT,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Sanskrit
    { L"sao",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Samoan
    { L"scc",     MAKELCID( MAKELANGID( LANG_SERBIAN,    SUBLANG_SERBIAN_CYRILLIC), SORT_DEFAULT ) }, //  Serbo-Croatian (Cyrillic)
    { L"sco",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Scots
    { L"scr",     MAKELCID( MAKELANGID( LANG_SERBIAN,    SUBLANG_SERBIAN_LATIN), SORT_DEFAULT ) }, //  Serbo-Croatian (Roman)
    { L"sel",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Selkup
    { L"sem",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Semitic (Other)
    { L"shn",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Shan
    { L"sho",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Shona
    { L"sid",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Sidamo
    { L"sio",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Siouan languages
    { L"sit",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Sino-Tibetan (Other)
    { L"sk",      MAKELCID( MAKELANGID( LANG_SLOVAK,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Slovak
    { L"sk-sk",   MAKELCID( MAKELANGID( LANG_SLOVAK,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Slovak - Slovakia
    { L"sl",      MAKELCID( MAKELANGID( LANG_SLOVENIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Slovenian
    { L"sl-si",   MAKELCID( MAKELANGID( LANG_SLOVENIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Slovenian - Slovenia
    { L"sla",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Slavic (Other)
    { L"slo",     MAKELCID( MAKELANGID( LANG_SLOVAK,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Slovak
    { L"slv",     MAKELCID( MAKELANGID( LANG_SLOVENIAN,  SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Slovenian
    { L"snd",     MAKELCID( MAKELANGID( LANG_SINDHI,     SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Sindhi
    { L"snh",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Sinhalese
    { L"som",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Somali
    { L"son",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Songhai
    { L"spa",     MAKELCID( MAKELANGID( LANG_SPANISH,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Spanish
    { L"sq",      MAKELCID( MAKELANGID( LANG_ALBANIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Albanian
    { L"sq-al",   MAKELCID( MAKELANGID( LANG_ALBANIAN,   SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Albanian - Albania
    { L"sr",      MAKELCID( MAKELANGID( LANG_SERBIAN,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, // Serbian
    { L"sr-sp",   MAKELCID( MAKELANGID( LANG_SERBIAN,    SUBLANG_SERBIAN_LATIN), SORT_DEFAULT ) }, // Serbian - Serbia (Latin)
    { L"srr",     MAKELCID( MAKELANGID( LANG_NEUTRAL,    SUBLANG_DEFAULT), SORT_DEFAULT ) }, //  Serer
    { L"sso",     MAKELCID( M