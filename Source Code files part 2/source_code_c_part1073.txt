

typedef struct _ICONCUR16 { /* iconcur */
    WORD   hInst;
    VPVOID lpStr;
} ICONCUR16;
typedef ICONCUR16 UNALIGNED *PICONCUR16;


typedef struct _WNETADDCONNECTION16 {         /* u517 */
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} WNETADDCONNECTION16;
typedef WNETADDCONNECTION16 UNALIGNED *PWNETADDCONNECTION16;

typedef struct _WNETGETCONNECTION16 {         /* u512 */
    VPVOID f3;
    VPSTR f2;
    VPSTR f1;
} WNETGETCONNECTION16;
typedef WNETGETCONNECTION16 UNALIGNED *PWNETGETCONNECTION16;

typedef struct _WNETCANCELCONNECTION16 {         /* u518 */
    BOOL16 f2;
    VPSTR f1;
} WNETCANCELCONNECTION16;
typedef WNETCANCELCONNECTION16 UNALIGNED *PWNETCANCELCONNECTION16;

typedef struct _WINDOWPLACEMENT16 {              /* wp16wow32only */
    WORD    length;
    WORD    flags;
    WORD    showCmd;
    POINT16 ptMinPosition;
    POINT16 ptMaxPosition;
    RECT16  rcNormalPosition;
} WINDOWPLACEMENT16;
typedef WINDOWPLACEMENT16 UNALIGNED *LPWINDOWPLACEMENT16;


/* New in Win95 user16 */


typedef struct _ACTIVATEKEYBOARDLAYOUT16 {       /* u562 */
    WORD    wFlags;
    DWORD   lcid;
} ACTIVATEKEYBOARDLAYOUT16;
typedef ACTIVATEKEYBOARDLAYOUT16 UNALIGNED *PACTIVATEKEYBOARDLAYOUT16;

typedef struct _BROADCASTSYSTEMMESSAGE16 {       /* u554 */
    DWORD   lParam;
    WORD    wParam;
    WORD    wMsg;
    VPDWORD lpdwRecipients;
    DWORD   dwFlags;
} BROADCASTSYSTEMMESSAGE16;
typedef BROADCASTSYSTEMMESSAGE16 UNALIGNED *PBROADCASTSYSTEMMESSAGE16;

typedef struct _CALLMSGFILTER3216 {              /* u589 */
    WORD    fMsg32;
    WORD    wContext;
    VPVOID  lpMsg32;
} CALLMSGFILTER3216;
typedef CALLMSGFILTER3216 UNALIGNED *PCALLMSGFILTER3216;

typedef struct _CASCADEWINDOWS16 {               /* u429 */
    VPVOID   ahwnd;
    WORD     chwnd;
    VPRECT16 lpRect;
    WORD     wFlags;
    HWND16   hwndParent;
} CASCADEWINDOWS16;
typedef CASCADEWINDOWS16 UNALIGNED *PCASCADEWINDOWS16;

typedef struct _CHANGEDISPLAYSETTINGS16 {        /* u557 */
    DWORD       dwFlags;
    VPDEVMODE31 lpDevMode;
} CHANGEDISPLAYSETTINGS16;
typedef CHANGEDISPLAYSETTINGS16 UNALIGNED *PCHANGEDISPLAYSETTINGS16;

typedef struct _CHECKMENURADIOITEM16 {           /* u576 */
    WORD      wFlags;
    WORD      wIDCheck;
    WORD      wIDLast;
    WORD      wIDFirst;
    HMENU16   hmenu;
} CHECKMENURADIOITEM16;
typedef CHECKMENURADIOITEM16 UNALIGNED *PCHECKMENURADIOITEM16;

typedef struct _CHILDWINDOWFROMPOINTEX16 {              /* u399 */
    WORD      wFlags;
    POINT16   pt;
    HWND16    hwnd;
} CHILDWINDOWFROMPOINTEX16;
typedef CHILDWINDOWFROMPOINTEX16 UNALIGNED *PCHILDWINDOWFROMPOINTEX16;

typedef struct _CHOOSECOLOR_CALLBACK1616 {              /* u584 */
    DWORD     lParam;
    WORD      wParam;
    WORD      wMsg;
    HWND16    hwnd;
} CHOOSECOLOR_CALLBACK1616;
typedef CHOOSECOLOR_CALLBACK1616 UNALIGNED *PCHOOSECOLOR_CALLBACK1616;

typedef struct _CHOOSEFONT_CALLBACK1616 {              /* u580 */
    DWORD     lParam;
    WORD      wParam;
    WORD      wMsg;
    HWND16    hwnd;
} CHOOSEFONT_CALLBACK1616;
typedef CHOOSEFONT_CALLBACK1616 UNALIGNED *PCHOOSEFONT_CALLBACK1616;

typedef struct _COPYIMAGE16 {              /* u390 */
    WORD      wFlags;
    SHORT     cyNew;
    SHORT     cxNew;
    WORD      wType;
    HAND16    hImage;
    HINST16   hinstOwner;
} COPYIMAGE16;
typedef COPYIMAGE16 UNALIGNED *PCOPYIMAGE16;

typedef struct _CREATEICONFROMRESOURCEEX16 {              /* u450 */
    WORD      lrDesired;
    WORD      cyDesired;
    WORD      cxDesired;
    DWORD     dwVer;
    BOOL16    fIcon;
    DWORD     cbRes;
    VPVOID    lpRes;
} CREATEICONFROMRESOURCEEX16;
typedef CREATEICONFROMRESOURCEEX16 UNALIGNED *PCREATEICONFROMRESOURCEEX16;

typedef struct _DESTROYICON3216 {              /* u553 */
    WORD      wFlags;
    HICON16   hicon;
} DESTROYICON3216;
typedef DESTROYICON3216 UNALIGNED *PDESTROYICON3216;

#ifdef NULLSTRUCT
typedef struct _DISPATCHINPUT16 {              /* u569 */
} DISPATCHINPUT16;
typedef DISPATCHINPUT16 UNALIGNED *PDISPATCHINPUT16;
#endif

typedef struct _DISPATCHMESSAGE3216 {              /* u588 */
    BOOL16 fMsg32;
    VPVOID lpMsg32;
} DISPATCHMESSAGE3216;
typedef DISPATCHMESSAGE3216 UNALIGNED *PDISPATCHMESSAGE3216;

typedef struct _DLLENTRYPOINT16 {              /* u374 */
    WORD  f6;
    DWORD f5;
    WORD  f4;
    WORD  f3;
    WORD  f2;
    DWORD f1;
} DLLENTRYPOINT16;
typedef DLLENTRYPOINT16 UNALIGNED *PDLLENTRYPOINT16;

typedef struct _DOHOTKEYSTUFF16 {              /* u541 */
    WORD  fsModifiers;
    WORD  vk;
} DOHOTKEYSTUFF16;
typedef DOHOTKEYSTUFF16 UNALIGNED *PDOHOTKEYSTUFF16;

typedef struct _DRAWANIMATEDRECTS16 {              /* u448 */
    VPRECT16 lprcEnd;
    VPRECT16 lprcStart;
    SHORT    idAnimation;
    HWND16   hwndClip;
} DRAWANIMATEDRECTS16;
typedef DRAWANIMATEDRECTS16 UNALIGNED *PDRAWANIMATEDRECTS16;

typedef struct _DRAWCAPTION16 {              /* u571 */
    WORD     wFlags;
    VPRECT16 lprc;
    HDC16    hdc;
    HWND16   hwnd;
} DRAWCAPTION16;
typedef DRAWCAPTION16 UNALIGNED *PDRAWCAPTION16;

typedef struct _DRAWCAPTIONTEMP16 {              /* u568 */
    WORD     wFlags;
    VPSTR    lpText;
    HICON16  hicon;
    HFONT16  hfont;
    VPRECT16 lprc;
    HDC16    hdc;
    HWND16   hwnd;
} DRAWCAPTIONTEMP16;
typedef DRAWCAPTIONTEMP16 UNALIGNED *PDRAWCAPTIONTEMP16;

typedef struct _DRAWEDGE16 {              /* u570 */
    WORD     wFlags;
    WORD     wEdge;
    VPRECT16 lprc;
    HDC16    hdc;
} DRAWEDGE16;
typedef DRAWEDGE16 UNALIGNED *PDRAWEDGE16;

typedef struct _DRAWFRAMECONTROL16 {              /* u567 */
    WORD     wState;
    WORD     wType;
    VPRECT16 lprc;
    HDC16    hdc;
} DRAWFRAMECONTROL16;
typedef DRAWFRAMECONTROL16 UNALIGNED *PDRAWFRAMECONTROL16;

typedef struct _DRAWICONEX16 {              /* u394 */
    WORD     wFlags;
    HAND16   hbr;
    WORD     wStepIfAni;
    SHORT    cy;
    SHORT    cx;
    HICON16  hicon;
    SHORT    y;
    SHORT    x;
    HDC16    hdc;
} DRAWICONEX16;
typedef DRAWICONEX16 UNALIGNED *PDRAWICONEX16;

typedef struct _DRAWMENUBARTEMP16 {              /* u573 */
    HFONT16  hfont;
    HMENU16  hmenu;
    VPRECT16 lprc;
    HDC16    hdc;
    HWND16   hwnd;
} DRAWMENUBARTEMP16;
typedef DRAWMENUBARTEMP16 UNALIGNED *PDRAWMENUBARTEMP16;

typedef struct _DRAWSTATE16 {              /* u449 */
    WORD            uFlags;
    SHORT           cy;
    SHORT           cx;
    SHORT           y;
    SHORT           x;
    WORD            wData;
    DWORD           lData;
    VPPROC          pfnCallBack;
    HAND16          hbrFore;
    HDC16           hdcDraw;
} DRAWSTATE16;
typedef DRAWSTATE16 UNALIGNED *PDRAWSTATE16;


typedef struct _DRAWTEXTPARAMS16 {      /* dtp16 */
    WORD  cbSize;
    SHORT iTabLength;
    SHORT iLeftMargin;
    SHORT iRightMargin;
    WORD  uiLengthDrawn;
} DRAWTEXTPARAMS16;
typedef DRAWTEXTPARAMS16 UNALIGNED *PDRAWTEXTPARAMS16;

typedef struct _DRAWTEXTEX16 {              /* u375 */
    VPVOID            lpDTparams;     // see DRAWTEXTPARAMS16 above
    DWORD             dwDTformat;
    VPRECT16          lprc;
    SHORT             cchText;
    VPSTR             lpchText;
    HDC16             hdc;
} DRAWTEXTEX16;
typedef DRAWTEXTEX16 UNALIGNED *PDRAWTEXTEX16;

typedef struct _ENUMDISPLAYSETTINGS16 {              /* u560 */
    VPDEVMODE31   lpdm;
    DWORD         dwModeNum;
    VPSTR         lpszDeviceName;
} ENUMDISPLAYSETTINGS16;
typedef ENUMDISPLAYSETTINGS16 UNALIGNED *PENUMDISPLAYSETTINGS16;

typedef struct _FINDREPLACE_CALLBACK1616 {              /* u581 */
    DWORD     lParam;
    WORD      wParam;
    WORD      wMsg;
    HWND16    hwnd;
} FINDREPLACE_CALLBACK1616;
typedef FINDREPLACE_CALLBACK1616 UNALIGNED *PFINDREPLACE_CALLBACK1616;

typedef struct _FINDWINDOWEX16 {              /* u427 */
    VPSTR     lpszName;
    VPSTR     lpszClass;
    HWND16    hwndChild;
    HWND16    hwndParent;
} FINDWINDOWEX16;
typedef FINDWINDOWEX16 UNALIGNED *PFINDWINDOWEX16;

typedef struct _FORMATMESSAGE16 {              /* u556 */
    VPDWORD   rglArgs;
    WORD      cbResultMax;
    VPSTR     lpResult;
    WORD      idLanguage;
    WORD      idMessage;
    VPVOID    lpSource;
    DWORD     dwFlags;
} FORMATMESSAGE16;
typedef FORMATMESSAGE16 UNALIGNED *PFORMATMESSAGE16;

#ifdef NULLSTRUCT
typedef struct _GETAPPVER16 {              /* u498 */
} GETAPPVER16;
typedef GETAPPVER16 UNALIGNED *PGETAPPVER16;
#endif

typedef struct _GETCLASSINFOEX16 {              /* u398 */
    VPVOID    lpwc;
    VPSTR     lpszClassName;
    HINST16   hinst;
} GETCLASSINFOEX16;
typedef GETCLASSINFOEX16 UNALIGNED *PGETCLASSINFOEX16;

#ifdef NULLSTRUCT
typedef struct _GETFOREGROUNDWINDOW16 {              /* u558 */
} GETFOREGROUNDWINDOW16;
typedef GETFOREGROUNDWINDOW16 UNALIGNED *PGETFOREGROUNDWINDOW16;
#endif

typedef struct _ICONINFO16 {     /* ii16 */
   BOOL16  fIcon;
   SHORT   xHotspot;
   SHORT   yHotspot;
   HBM16   hbmMask;
   HBM16   hbmColor;
} ICONINFO16;
typedef ICONINFO16 UNALIGNED *PICONINFO16;

typedef struct _GETICONINFO16 {              /* u395 */
    VPVOID    lpiconinfo;          // see ICONINFO16 structure above
    HICON16   hicon;
} GETICONINFO16;
typedef GETICONINFO16 UNALIGNED *PGETICONINFO16;

typedef struct _GETKEYBOARDLAYOUT16 {              /* u563 */
    DWORD     dwThreadID;
} GETKEYBOARDLAYOUT16;
typedef GETKEYBOARDLAYOUT16 UNALIGNED *PGETKEYBOARDLAYOUT16;

typedef struct _GETKEYBOARDLAYOUTLIST16 {              /* u564 */
    VPDWORD   lpdwHandleArray;
    WORD      cElements;
} GETKEYBOARDLAYOUTLIST16;
typedef GETKEYBOARDLAYOUTLIST16 UNALIGNED *PGETKEYBOARDLAYOUTLIST16;

typedef struct _GETKEYBOARDLAYOUTNAME16 {              /* u477 */
    VPSTR lpszLayoutName;
} GETKEYBOARDLAYOUTNAME16;
typedef GETKEYBOARDLAYOUTNAME16 UNALIGNED *PGETKEYBOARDLAYOUTNAME16;

typedef struct _GETMENUCONTEXTHELPID16 {              /* u385 */
    HMENU16   hmenu;
} GETMENUCONTEXTHELPID16;
typedef GETMENUCONTEXTHELPID16 UNALIGNED *PGETMENUCONTEXTHELPID16;

typedef struct _GETMENUDEFAULTITEM16 {              /* u574 */
    WORD       wFlags;
    BOOL16     fByPosition;
    HMENU16    hmenu;
} GETMENUDEFAULTITEM16;
typedef GETMENUDEFAULTITEM16 UNALIGNED *PGETMENUDEFAULTITEM16;

typedef struct _MENUITEMINFO16 {  /* mii16 */
    DWORD   cbSize;
    DWORD   fMask;
    WORD    fType;
    WORD    fState;
    WORD    wID;
    HMENU16 hSubMenu;
    HBM16   hbmpChecked;
    HBM16   hbmpUnchecked;
    DWORD   dwItemData;
    VPSTR   dwTypeData;
    WORD    cch;
} MENUITEMINFO16;
typedef MENUITEMINFO16 UNALIGNED *PMENUITEMINFO16;

typedef struct _GETMENUITEMINFO16 {              /* u443 */
    VPVOID       lpmii;   // see MENUITEMINFO16 above
    BOOL16       fByPosition;
    WORD         wIndex;
    HMENU16      hmenu;
} GETMENUITEMINFO16;
typedef GETMENUITEMINFO16 UNALIGNED *PGETMENUITEMINFO16;

typedef struct _GETMENUITEMRECT16 {              /* u575 */
    VPRECT16     lprcScreen;
    WORD         wIndex;
    HMENU16      hmenu;
    HWND16       hwnd;
} GETMENUITEMRECT16;
typedef GETMENUITEMRECT16 UNALIGNED *PGETMENUITEMRECT16;

typedef struct _GETMESSAGE3216 {              /* u586 */
    WORD         fMsg32;
    WORD         wLast;
    WORD         wFirst;
    HWND16       hwnd16;
    VPVOID       lpMsg32;
} GETMESSAGE3216;
typedef GETMESSAGE3216 UNALIGNED *PGETMESSAGE3216;

typedef struct _GETPROPEX16 {              /* u379 */
    VPSTR        lpszKey;
    HWND16       hwnd;
} GETPROPEX16;
typedef GETPROPEX16 UNALIGNED *PGETPROPEX16;

typedef struct _GETSCROLLINFO16 {              /* u476 */
    VPVOID       lpsi;
    WORD         wCode;
    HWND16       hwnd;
} GETSCROLLINFO16;
typedef GETSCROLLINFO16 UNALIGNED *PGETSCROLLINFO16;

#ifdef NULLSTRUCT
typedef struct _GETSHELLWINDOW16 {              /* u540 */
} GETSHELLWINDOW16;
typedef GETSHELLWINDOW16 UNALIGNED *PGETSHELLWINDOW16;
#endif

typedef struct _GETSYSCOLORBRUSH16 {              /* u281 */
    WORD  wIndex;
} GETSYSCOLORBRUSH16;
typedef GETSYSCOLORBRUSH16 UNALIGNED *PGETSYSCOLORBRUSH16;

typedef struct _GETWINDOWCONTEXTHELPID16 {              /* u383 */
    HWND16       hwnd;
} GETWINDOWCONTEXTHELPID16;
typedef GETWINDOWCONTEXTHELPID16 UNALIGNED *PGETWINDOWCONTEXTHELPID16;

typedef struct _GETWINDOWRGN16 {              /* u579 */
    HRGN16       hrgn;
    HWND16       hwnd;
} GETWINDOWRGN16;
typedef GETWINDOWRGN16 UNALIGNED *PGETWINDOWRGN16;

typedef struct _HACKTASKMONITOR16 {              /* u555 */
    SHORT        iMonitor;
} HACKTASKMONITOR16;
typedef HACKTASKMONITOR16 UNALIGNED *PHACKTASKMONITOR16;

typedef struct _INITTHREADINPUT16 {              /* u409 */
    WORD         wFlags;
    HAND16       hq;
} INITTHREADINPUT16;
typedef INITTHREADINPUT16 UNALIGNED *PINITTHREADINPUT16;

typedef struct _INSERTMENUITEM16 {              /* u441 */
    VPVOID       lpmii;   // see MENUITEMINFO16 above
    BOOL16       fByPosition;
    WORD         wIndex;
    HMENU16      hmenu;
} INSERTMENUITEM16;
typedef INSERTMENUITEM16 UNALIGNED *PINSERTMENUITEM16;

typedef struct _INSTALLIMT16 {              /* u594 */
    WORD         wMsgHi;
    WORD         wMsgLo;
    VPPROC       pfnDispatcher;
    VPSTR        lpszClassName;
} INSTALLIMT16;
typedef INSTALLIMT16 UNALIGNED *PINSTALLIMT16;

typedef struct _ISDIALOGMESSAGE3216 {              /* u590 */
    BOOL16       fMsg32;
    VPVOID       lpMsg32;
    HWND16       hwnd;
} ISDIALOGMESSAGE3216;
typedef ISDIALOGMESSAGE3216 UNALIGNED *PISDIALOGMESSAGE3216;

typedef struct _LOADIMAGE16 {              /* u389 */
    WORD         wFlags;
    SHORT        cyDesired;
    SHORT        cxDesired;
    WORD         wType;
    VPSTR        lpszName;
    HINST16      hinst;
} LOADIMAGE16;
typedef LOADIMAGE16 UNALIGNED *PLOADIMAGE16;

typedef struct _LOADKEYBOARDLAYOUT16 {              /* u478 */
    WORD         wFlags;
    VPSTR        lpszLayoutName;
} LOADKEYBOARDLAYOUT16;
typedef LOADKEYBOARDLAYOUT16 UNALIGNED *PLOADKEYBOARDLAYOUT16;

typedef struct _LOOKUPICONIDFROMDIRECTORYEX16 {              /* u364 */
    WORD         lrDesired;
    SHORT        cyDesired;
    SHORT        cxDesired;
    BOOL16       fIcon;
    VPVOID       lpnh;
} LOOKUPICONIDFROMDIRECTORYEX16;
typedef LOOKUPICONIDFROMDIRECTORYEX16 UNALIGNED *PLOOKUPICONIDFROMDIRECTORYEX16;

typedef struct _MENUITEMFROMPOINT16 {              /* u479 */
    POINT16      ptScreen;
    HMENU16      hmenu;
    HWND16       hwnd;
} MENUITEMFROMPOINT16;
typedef MENUITEMFROMPOINT16 UNALIGNED *PMENUITEMFROMPOINT16;

typedef struct _MSGBOXPARAMS16 {                    /* mbp16 */
    DWORD       cbSize;
    HWND16      hwndOwner;
    HINST16     hInstance;
    VPSTR       lpszText;
    VPSTR       lpszCaption;
    DWORD       dwStyle;
    VPSTR       lpszIcon;
    DWORD       dwContextHelpId;
    DWORD       vpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMS16;
typedef MSGBOXPARAMS16 UNALIGNED *PMSGBOXPARAMS16;

typedef struct _MESSAGEBOXINDIRECT16 {              /* u593 */
    VPVOID       lpmbp;
} MESSAGEBOXINDIRECT16;
typedef MESSAGEBOXINDIRECT16 UNALIGNED *PMESSAGEBOXINDIRECT16;

typedef struct _MSGWAITFORMULTIPLEOBJECTS16 {              /* u561 */
    DWORD   dwWakeMask;
    DWORD   dwMilliseconds;
    BOOL16  fWaitAll;
    VPDWORD lpHandles;
    DWORD   dwHandleCount;
} MSGWAITFORMULTIPLEOBJECTS16;
typedef MSGWAITFORMULTIPLEOBJECTS16 UNALIGNED *PMSGWAITFORMULTIPLEOBJECTS16;

typedef struct _OPENFILENAME_CALLBACK1616 {              /* u582 */
    DWORD     lParam;
    WORD      wParam;
    WORD      wMsg;
    HWND16    hwnd;
} OPENFILENAME_CALLBACK1616;
typedef OPENFILENAME_CALLBACK1616 UNALIGNED *POPENFILENAME_CALLBACK1616;

typedef struct _PEEKMESSAGE3216 {              /* u585 */
    BOOL16    fMsg32;
    WORD      wFlags;
    WORD      wLast;
    WORD      wFirst;
    HWND16    hwnd;
    VPVOID    lpMsg32;
} PEEKMESSAGE3216;
typedef PEEKMESSAGE3216 UNALIGNED *PPEEKMESSAGE3216;

typedef struct _PLAYSOUNDEVENT16 {              /* u8 */
    SHORT     iSoundId;
} PLAYSOUNDEVENT16;
typedef PLAYSOUNDEVENT16 UNALIGNED *PPLAYSOUNDEVENT16;

typedef struct _POSTMESSAGE3216 {              /* u591 */
    WORD      wParamHi;
    DWORD     lParam;
    WORD      wParamLo;
    WORD      wMsg;
    HWND16    hwnd;
} POSTMESSAGE3216;
typedef POSTMESSAGE3216 UNALIGNED *PPOSTMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _POSTPOSTEDMESSAGES16 {              /* u566 */
} POSTPOSTEDMESSAGES16;
typedef POSTPOSTEDMESSAGES16 UNALIGNED *PPOSTPOSTEDMESSAGES16;
#endif

typedef struct _POSTTHREADMESSAGE3216 {              /* u592 */
    WORD      wParamHi;
    DWORD     lParam;
    WORD      wParamLo;
    WORD      wMsg;
    DWORD     dwThreadID;
} POSTTHREADMESSAGE3216;
typedef POSTTHREADMESSAGE3216 UNALIGNED *PPOSTTHREADMESSAGE3216;

typedef struct _PRINTDLG_CALLBACK1616 {              /* u583 */
    DWORD     lParam;
    WORD      wParam;
    WORD      wMsg;
    HWND16    hwnd;
} PRINTDLG_CALLBACK1616;
typedef PRINTDLG_CALLBACK1616 UNALIGNED *PPRINTDLG_CALLBACK1616;

typedef struct _REGISTERCLASSEX16 {              /* u397 */
    VPVOID    lpwcex;
} REGISTERCLASSEX16;
typedef REGISTERCLASSEX16 UNALIGNED *PREGISTERCLASSEX16;

typedef struct _REMOVEPROPEX16 {              /* u380 */
    VPSTR     lpszKey;
    HWND16    hwnd;
} REMOVEPROPEX16;
typedef REMOVEPROPEX16 UNALIGNED *PREMOVEPROPEX16;

typedef struct _SETCHECKCURSORTIMER16 {              /* u542 */
    SHORT     iTime;
} SETCHECKCURSORTIMER16;
typedef SETCHECKCURSORTIMER16 UNALIGNED *PSETCHECKCURSORTIMER16;

typedef struct _SETFOREGROUNDWINDOW16 {              /* u559 */
    HWND16    hwnd;
} SETFOREGROUNDWINDOW16;
typedef SETFOREGROUNDWINDOW16 UNALIGNED *PSETFOREGROUNDWINDOW16;

typedef struct _SETMENUCONTEXTHELPID16 {              /* u384 */
    DWORD     dwContextHelpId;
    HMENU16   hmenu;
} SETMENUCONTEXTHELPID16;
typedef SETMENUCONTEXTHELPID16 UNALIGNED *PSETMENUCONTEXTHELPID16;

typedef struct _SETMENUDEFAULTITEM16 {              /* u543 */
    BOOL16    fByPosition;
    WORD      wIndex;
    HMENU16   hmenu;
} SETMENUDEFAULTITEM16;
typedef SETMENUDEFAULTITEM16 UNALIGNED *PSETMENUDEFAULTITEM16;

typedef struct _SETMENUITEMINFO16 {              /* u446 */
    VPVOID    lpmii;   // see MENUITEMINFO16 above
    BOOL16    fByPosition;
    WORD      wIndex;
    HMENU16   hmenu;
} SETMENUITEMINFO16;
typedef SETMENUITEMINFO16 UNALIGNED *PSETMENUITEMINFO16;

typedef struct _SETMESSAGEEXTRAINFO16 {              /* u376 */
    DWORD     dwExtraInfo;
} SETMESSAGEEXTRAINFO16;
typedef SETMESSAGEEXTRAINFO16 UNALIGNED *PSETMESSAGEEXTRAINFO16;

typedef struct _SETPROPEX16 {              /* u378 */
    DWORD     dwValue;
    VPSTR     lpszKey;
    HWND16    hwnd;
} SETPROPEX16;
typedef SETPROPEX16 UNALIGNED *PSETPROPEX16;

typedef struct _SETSCROLLINFO16 {              /* u475 */
    BOOL16    fRedraw;
    VPVOID    lpsi;
    SHORT     iCode;
    HWND16    hwnd;
} SETSCROLLINFO16;
typedef SETSCROLLINFO16 UNALIGNED *PSETSCROLLINFO16;

typedef struct _SETSYSCOLORSTEMP16 {              /* u572 */
    WORD      wBrushCount;
    VPWORD    lpBrushes;
    VPDWORD   lpRGBs;
} SETSYSCOLORSTEMP16;
typedef SETSYSCOLORSTEMP16 UNALIGNED *PSETSYSCOLORSTEMP16;

typedef struct _SETWINDOWCONTEXTHELPID16 {              /* u382 */
    DWORD     dwContextID;
    HWND16    hwnd;
} SETWINDOWCONTEXTHELPID16;
typedef SETWINDOWCONTEXTHELPID16 UNALIGNED *PSETWINDOWCONTEXTHELPID16;

typedef struct _SETWINDOWRGN16 {              /* u578 */
    BOOL16    fRedraw;
    HRGN16    hrgn;
    HWND16    hwnd;
} SETWINDOWRGN16;
typedef SETWINDOWRGN16 UNALIGNED *PSETWINDOWRGN16;

typedef struct _SIGNALPROC3216 {              /* u391 */
    DWORD     dwSignalID;
    DWORD     dwID;
    DWORD     dwFlags;
    HTASK16   htask;
} SIGNALPROC3216;
typedef SIGNALPROC3216 UNALIGNED *PSIGNALPROC3216;

typedef struct _TILEWINDOWS16 {              /* u428 */
    VPWORD    ahwnd;
    WORD      chwnd;
    VPRECT16  lprc;
    WORD      wFlags;
    HWND16    hwndParent;
} TILEWINDOWS16;
typedef TILEWINDOWS16 UNALIGNED *PTILEWINDOWS16;

typedef struct _TPMPARAMS16 {                     /* tpmp */
    WORD   cbSize;
    RECT16 rcExclude;
} TPMPARAMS16;
typedef TPMPARAMS16 UNALIGNED *PTPMPARAMS16;

typedef struct _TRACKPOPUPMENUEX16 {              /* u577 */
    VPVOID    lpTpm;                              /* see TPMPARAMS16 above */
    HWND16    hwndOwner;
    SHORT     y;
    SHORT     x;
    WORD      wFlags;
    HMENU16   hmenu;
} TRACKPOPUPMENUEX16;
typedef TRACKPOPUPMENUEX16 UNALIGNED *PTRACKPOPUPMENUEX16;

typedef struct _TRANSLATEMESSAGE3216 {              /* u587 */
    BOOL16    fMsg32;
    VPVOID    lpMsg32;
} TRANSLATEMESSAGE3216;
typedef TRANSLATEMESSAGE3216 UNALIGNED *PTRANSLATEMESSAGE3216;

typedef struct _UNINSTALLIMT16 {              /* u595 */
    WORD      wMsgHi;
    WORD      wMsgLo;
    VPPROC    pfnDispatcher;
    VPSTR     lpszClassName;
} UNINSTALLIMT16;
typedef UNINSTALLIMT16 UNALIGNED *PUNINSTALLIMT16;

typedef struct _UNLOADINSTALLABLEDRIVERS16 {              /* u300 */
    SHORT     iCode;
} UNLOADINSTALLABLEDRIVERS16;
typedef UNLOADINSTALLABLEDRIVERS16 UNALIGNED *PUNLOADINSTALLABLEDRIVERS16;

typedef struct _UNLOADKEYBOARDLAYOUT16 {              /* u565 */
    DWORD     lcid;
} UNLOADKEYBOARDLAYOUT16;
typedef UNLOADKEYBOARDLAYOUT16 UNALIGNED *PUNLOADKEYBOARDLAYOUT16;

typedef struct _WINDOWFROMDC16 {              /* u117 */
    HDC16     hdc;
} WINDOWFROMDC16;
typedef WINDOWFROMDC16 UNALIGNED *PWINDOWFROMDC16;

#ifdef NULLSTRUCT
typedef struct _WNETINITIALIZE16 {              /* u533 */
} WNETINITIALIZE16;
typedef WNETINITIALIZE16 UNALIGNED *PWNETINITIALIZE16;
#endif

typedef struct _WNETLOGON16 {              /* u534 */
    HWND16     hwndOwner;
    VPSTR      lpszProvider;
} WNETLOGON16;
typedef WNETLOGON16 UNALIGNED *PWNETLOGON16;


/* WOW private thunks in USER */


typedef struct _WOWWORDBREAKPROC16 {   /* u537 */
    SHORT   action;
    SHORT   cbEditText;
    SHORT   ichCurrentWord;
    VPVOID  lpszEditText;
} WOWWORDBREAKPROC16;
typedef WOWWORDBREAKPROC16 UNALIGNED *PWOWWORDBREAKPROC16;



// NOTE: these structs are also in mvdm\wow16\user\init.c 
//       UserInit16 && Krnl386Segs
//       - they must be the same!!!
typedef struct _USERCLIENTGLOBALS {   /* uclg */
    WORD             hInstance;
    BYTE UNALIGNED **lpgpsi;
    BYTE UNALIGNED **lpCsrFlag;
    DWORD            dwBldInfo;
    VPWORD           lpwMaxDWPMsg;
    VPSTR            lpDWPBits;
    WORD             cbDWPBits;
    WORD             wUnusedPadding;
    DWORD            pfnGetProcModule;
    DWORD UNALIGNED *lpHighestAddress;
} USERCLIENTGLOBALS;
typedef USERCLIENTGLOBALS UNALIGNED *PUSERCLIENTGLOBALS;

typedef struct _KRNL386SEGS {   /* uclg */
    WORD CodeSeg1;
    WORD CodeSeg2;
    WORD CodeSeg3;
    WORD DataSeg1;
} KRNL386SEGS;
typedef KRNL386SEGS UNALIGNED *PKRNL386SEGS;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\apc.h ===
//-----------------------------------------------------------------------
//
// APC.H - Asynchronous Procedure Call Interface File for Ring 3
//
//-----------------------------------------------------------------------
//
//	Author:     Mike Toutonghi
//	Copyright:  1993 Microsoft
//
//-----------------------------------------------------------------------
//  File Description:
//	Provides an interface to both USER and KERNEL level APCs under
//	Chicago. This file must be kept in sync with APC.INC
//
//-----------------------------------------------------------------------
//  Revision History:
//	2/26/93 - created (miketout)
//
//-----------------------------------------------------------------------

#ifdef WOW32_EXTENSIONS
#define AssertSignature(x)
#else   // WOW32_EXTENSIONS
#ifdef DEBUG
#define AssertCreate(x, p)      ((p)->x##_dwSignature = x##_SIGNATURE)
#define AssertDestroy(x, p)     ((p)->x##_dwSignature = 0x44414544)
#define AssertSignature(x)      ULONG x##_dwSignature;
#define AssertP(x, p)           Assert((p)->x##_dwSignature == x##_SIGNATURE)
#else
#define AssertCreate(x, p)
#define AssertDestroy(x, p)
#define AssertSignature(x)
#define AssertP(x, p)
#endif
#endif  // else WOW32_EXTENSIONS

//---------------------------------------------------------------------
// SUPPORT STRUCTURES
//---------------------------------------------------------------------

typedef void (APIENTRY *PAPCFUNC)( DWORD dwParam );

#ifndef PUAPC
    typedef struct _userapcrec *PUAPC;
    typedef struct _kernelapcrec *PKAPC;
#endif

//
// Structure for a sync APC. Sync APCs are APCs which are
// queueable at interrupt or event time, and synchronize
// a function with the Win32 synchronization objects.
//
// By using a sync APC, interrupt service routines can signal
// Win32 events, decrement semaphores, queue APCs, and set timers. 
//
typedef struct _syncapcrec {
    PUAPC	sar_nextapc;		// next APC in list
    DWORD	sar_dwparam1;		// first parameter
    DWORD	sar_dwparam2;		// second parameter for APC
    PAPCFUNC	sar_apcaddr;		// function to invoke
    DWORD       sar_dwparam3;           // third parameter
    AssertSignature(SYNCAPCREC)
} SYNCAPCREC;

#define	SYNCAPCREC_SIGNATURE	0x20524153

//
// Structure for a user APC
//
typedef struct _userapcrec {
    PUAPC	uar_nextapc;		// next APC in list
    DWORD	uar_apcstate;		// state (APC_DELIVERED)
    DWORD	uar_dwparam;		// parameter for APC
    PAPCFUNC	uar_apcaddr;		// function to invoke
    PAPCFUNC    uar_apcR0rundown;       // call if can't deliver APC
    AssertSignature(USERAPCREC)
} USERAPCREC;

#define	USERAPCREC_SIGNATURE	0x20524155

// APC state flags
#define APC_DELIVERED           0	// bit set when an APC is delivered
#define APC_DELIVERED_MASK      (1 << APC_DELIVERED)
#define APC_FLAG_LAST           0       // last flag

//
// Structure for a kernel APC
//
typedef struct _kernelapcrec {
    PKAPC kar_nextapc;                  // next kernel APC in list
    DWORD kar_dwparam;                  // kernel APC parameter
    PAPCFUNC kar_apcaddr;               // APC function
    PAPCFUNC kar_event;                 // used if an event is queued for APC
    DWORD kar_savedeax;			// saved eax for parameter
    DWORD kar_savedeip;			// eip for same reason as above
    WORD kar_savedcs;			// saved ring 3 cs to return w/o stk
    WORD kar_apcstate;		        // state (KAR_FLAG...)
    AssertSignature(KERNELAPCREC)
} KERNELAPCREC;

#define	KERNELAPCREC_SIGNATURE	0x2052414b

// KERNEL APC specific flags
#define	KAR_FLAG_BUSY		0
#define	KAR_FLAG_BUSY_MASK	(1 << KAR_FLAG_BUSY)
#define	KAR_FLAG_STATIC		(KAR_FLAG_BUSY+1)
#define	KAR_FLAG_STATIC_MASK	(1 << KAR_FLAG_STATIC)
#define	KAR_FLAG_CALLBACK	(KAR_FLAG_STATIC+1)
#define	KAR_FLAG_CALLBACK_MASK	(1 << KAR_FLAG_CALLBACK)

//
// Terminate Process Info structure for local reboot init dialog
//
typedef struct tpi_s {
    struct tpi_s *tpi_ptpiNext;
    void *tpi_hwnd;
    struct _pdb *tpi_ppdb;
    struct _tdb *tpi_ptdb;
    DWORD tpi_flags;
    int   tpi_nIndex;
    AssertSignature(TPI)
} TPI;

typedef TPI *PTPI;

#define TPI_SIGNATURE		0x20495054

#define	TPIF_HUNG		0x00000001
#define	TPIF_PROCESSNAME	0x00000002

//
// TerminateThread parameter packet.  Allocated at ring 3, passed to
//	VxDTerminateThread.
//
typedef struct termdata_s {
    struct _tdb *term_ptdb;		// thread to terminate
    DWORD term_ptcbAPC;			// thread to receive user APC
    DWORD term_pfnAPC;			// user APC function address
    DWORD term_hAPC;			// handle of kernel APC
    DWORD term_htimeout;		// handle of time out when nuking
    DWORD term_pfrinfo;			// force/restore crsts info pointer
    AssertSignature(TERMDATA)
} TERMDATA;

typedef TERMDATA *PTERMDATA;

#define TERMDATA_SIGNATURE	0x4d524554

typedef union tpiterm_u {
    TERMDATA tpiterm_term;
    TPI tpiterm_tpi;
} TPITERM;

//
// Parameter packet used to start a ring 0 thread
//
typedef struct _kernthreadstartdata {
    DWORD StartAddress;			// start address in ring 3
    DWORD dwThreadParam;		// parameter for ring 3 startup function
    DWORD dwKTStackSize;		// ring 3 stack size
    DWORD dwCreationFlags;		// thread creation flags
    DWORD pRing3Event;			// set after thread is created
    DWORD dwThreadID;			// handle for new thread or NULL
    DWORD dwErrorCode;			// error code if error
} KERNTHREADSTARTDATA;

//
// Parameter packet used to start a ring 0 thread
//
typedef struct _r0startdata {
    DWORD R0StartAddress;		// start address in ring 0
    DWORD dwR0ThreadParam;		// parameter for ring 0 startup function
    DWORD dwR3StackSize;		// ring 3 stack size
    DWORD pRing0Event;			// set after thread is created
    DWORD R0FailCallBack;		// or invoke this callback on failure
    DWORD dwRing3ThreadID;		// ID for thread
    DWORD dwRing0ThreadID;		// same for ring 0
} R0THREADSTARTDATA;

// include the TDBX structure
#include <tdbx.h>

#ifndef WOW32_EXTENSIONS

typedef	VOID (KERNENTRY *PFN_KERNEL_APC)(PVOID);
typedef	VOID (KERNENTRY *PFN_USER_APC)(PVOID);

DWORD __cdecl VWIN32_QueueKernelAPC(PFN_KERNEL_APC, DWORD, LPVOID, DWORD);
DWORD __cdecl VWIN32_QueueUserApc(PFN_USER_APC, DWORD, LPVOID);
DWORD __cdecl VWIN32_QueueUserApcEx(PFN_USER_APC, DWORD, LPVOID, LPVOID);

//  Queue the kernel or user APC to the kernel services thread.
#define APC_KERNEL_SERVICE_THREAD	((LPVOID)0xFFFFFFFF)

DWORD __cdecl FreeAPCList();

DWORD CancelKernelAPC();
DWORD CancelSuspendAPC();
DWORD __stdcall SuspendAPCHandler(DWORD);
#endif  // ndef WOW32_EXTENSIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\cdis.h ===
//
// Common Vwin32/Kernel32 Data Interface Structure
//
// Used to pass data to/from vwin32 from/to kernel32 during initialization.
//

typedef struct _CDIS {
    IN	DWORD	cdis_Thread0Handle;
    IN	DWORD	cdis_Process0Handle;
    IN	DWORD	cdis_Context0Handle;
    OUT	DWORD	cdis_R0ThreadHandle;
#ifndef WOW
    OUT	DWORD	cdis_pCurrentThreadInfo;
#endif  // ndef WOW
    IN	DWORD	cdis_pK16CurTask;
    IN	DWORD	cdis_init_pfnMakePrivate;
    OUT	USHORT	cdis_Dos386PSPSel;
    OUT	USHORT	cdis_Dos386PSPSeg;
    IN	USHORT	cdis_FlatCodeSelector;
    IN	USHORT	cdis_FlatDataSelector;
    IN	DWORD	cdis_TerminationHandler;
    IN	PVOID	cdis_Win16Lock;
    IN	PVOID	cdis_Krn32Lock;
    IN	PVOID	cdis_pcrstGHeap16;
    IN	PVOID	cdis_pcrstSync;
    IN	PVOID	cdis_ppmutxSysLst;
    IN	PVOID	cdis_ppcrstSysLst;
    IN	PULONG  cdis_pulRITEventPending;
    OUT DWORD	cdis_IFSMgrConvTablePtr;// ptr to Unicode/Ansi conv table
    IN  PVOID	cdis_pcscr16;		// ptr to 16 bit crit sect code ranges
    IN  PVOID	cdis_pcscr32;		// ptr to 32 bit crit sect code ranges
#ifndef WOW
    OUT PVOID   cdis_lpSysVMHighLinear; // high linear mapping
#endif  // ndef WOW
    IN  DWORD   cdis_TimerApcHandler;
    OUT DWORD   cdis_NoGangLoad;        // is gang-loading disabled ?
    IN  DWORD   cdis_dwIdObsfucator;
#ifdef DEBUG
    IN  DWORD   cdis_pSuspendCheckLocks;
#endif
#ifdef DBCS
    IN  DWORD	cdis_DBCSLeadByteTable;
#endif
#ifdef  WOW
//    IN  VOID    (*cdis_BopUnsimulate)(VOID);
    IN  PVOID   cdis_pK16CurDOSPsp;     // Linear pointer to storage in K16 for curr PSP SEL
    IN  PVOID   cdis_pDOSCurDOSPsp;     // Linear pointer to storage in V86 DOS for curr PSP SEG
    IN  PDWORD  cdis_pdwMEOWFlags;      // Linear pointer to storage in kernel32 for MEOW Flags
    IN  MTE     ***cdis_pppmteModTable; // Linear pointer to storage in kernel32 for ppmteModTable;
#endif
} CDIS, *PCDIS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\apitrace.h ===
//
// apitrace.h - Interface definitions for kernel32 api tracing support
//

//
// Apitbl.asm defines the api information table, made up of APIINFOBLOCKs.
//

typedef struct _api_info_block {
    DWORD  aib_nArgs;		// number of arguments to api
    char  *aib_apiName;		// zero terminated api name string
} APIINFOBLOCK;

typedef APIINFOBLOCK *PAPIINFOBLOCK;

extern	APIINFOBLOCK ApiInfoTable[];

//
// Define a unique constant for each api that is also an index into the
// api information table.
//
// If you define a new api constant here, you should also add an entry
// in the api information table in apitbl.asm.
//

#define API_GetLocalTime                   0
#define API_EnterCriticalSection           API_GetLocalTime + 1
#define API_LeaveCriticalSection           API_EnterCriticalSection + 1
#define API_WaitForSingleObjectEx          API_LeaveCriticalSection + 1
#define API_ResetEvent                     API_WaitForSingleObjectEx + 1
#define API_SetEvent                       API_ResetEvent + 1
#define API_CreateFileA                    API_SetEvent + 1
#define API_FileTimeToDosDateTime          API_CreateFileA + 1
#define API_TlsGetValue                    API_FileTimeToDosDateTime + 1
#define API_DuplicateHandle                API_TlsGetValue + 1
#define API_MapViewOfFileEx                API_DuplicateHandle + 1
#define API_OutputDebugStringA             API_MapViewOfFileEx + 1
#define API_FatalExit                      API_OutputDebugStringA + 1
#define API_FatalAppExitA                  API_FatalExit + 1
#define API_GetThreadSelectorEntry         API_FatalAppExitA + 1
#define API_SetThreadContext               API_GetThreadSelectorEntry + 1
#define API_GetThreadContext               API_SetThreadContext + 1
#define API_WriteProcessMemory             API_GetThreadContext + 1
#define API_ReadProcessMemory              API_WriteProcessMemory + 1
#define API_DebugActiveProcess             API_ReadProcessMemory + 1
#define API_ContinueDebugEvent             API_DebugActiveProcess + 1
#define API_WaitForDebugEvent              API_ContinueDebugEvent + 1
#define API_GetExitCodeThread              API_WaitForDebugEvent + 1
#define API_GetCurrentThread               API_GetExitCodeThread + 1
#define API_CreateThread                   API_GetCurrentThread + 1
#define API_CreateKernelThread             API_CreateThread + 1
#define API_GetCurrentProcessId            API_CreateKernelThread + 1
#define API_GetCurrentProcess              API_GetCurrentProcessId + 1
#define API_SetEnvironmentVariableA        API_GetCurrentProcess + 1
#define API_GetEnvironmentVariableA        API_SetEnvironmentVariableA + 1
#define API_GetStartupInfoA                API_GetEnvironmentVariableA + 1
#define API_GetExitCodeProcess             API_GetStartupInfoA + 1
#define API_OpenProcess                    API_GetExitCodeProcess + 1
#define API_ExitProcess                    API_OpenProcess + 1
#define API_SearchPathA                    API_ExitProcess + 1
#define API_GetOverlappedResult            API_SearchPathA + 1
#define API_InterlockedDecrement           API_GetOverlappedResult + 1
#define API_InterlockedIncrement           API_InterlockedDecrement + 1
#define API_OpenSemaphoreA                 API_InterlockedIncrement + 1
#define API_OpenMutexA                     API_OpenSemaphoreA + 1
#define API_OpenEventA                     API_OpenMutexA + 1
#define API_UninitializeCriticalSection    API_OpenEventA + 1
#define API_MakeCriticalSectionGlobal      API_UninitializeCriticalSection + 1
#define API_DeleteCriticalSection          API_MakeCriticalSectionGlobal + 1
#define API_ReinitializeCriticalSection    API_DeleteCriticalSection + 1
#define API_InitializeCriticalSection      API_ReinitializeCriticalSection + 1
#define API_WaitForMultipleObjectsEx       API_InitializeCriticalSection + 1
#define API_ReleaseSemaphore               API_WaitForMultipleObjectsEx + 1
#define API_ReleaseMutex                   API_ReleaseSemaphore + 1
#define API_PulseEvent                     API_ReleaseMutex + 1
#define API_CreateSemaphoreA               API_PulseEvent + 1
#define API_CreateMutexA                   API_CreateSemaphoreA + 1
#define API_CreateEventA                   API_CreateMutexA + 1
#define API_CloseHandle                    API_CreateEventA + 1
#define API_FlushViewOfFile                API_CloseHandle + 1
#define API_UnmapViewOfFile                API_FlushViewOfFile + 1
#define API_OpenFileMappingA               API_UnmapViewOfFile + 1
#define API_GetSystemDirectoryA            API_OpenFileMappingA + 1
#define API_GetWindowsDirectoryA           API_GetSystemDirectoryA + 1
#define API__llseek                        API_GetWindowsDirectoryA + 1
#define API__lclose                        API__llseek + 1
#define API__lwrite                        API__lclose + 1
#define API__lread                         API__lwrite + 1
#define API__lcreat                        API__lread + 1
#define API__lopen                         API__lcreat + 1
#define API_GetLogicalDrives               API__lopen + 1
#define API_GetLogicalDriveStringsA        API_GetLogicalDrives + 1
#define API_CreateDirectoryA               API_GetLogicalDriveStringsA + 1
#define API_CreateDirectoryExA             API_CreateDirectoryA + 1
#define API_RemoveDirectoryA               API_CreateDirectoryExA + 1
#define API_GetDriveTypeA                  API_RemoveDirectoryA + 1
#define API_GetTempPathA                   API_GetDriveTypeA + 1
#define API_GetTempFileNameA               API_GetTempPathA + 1
#define API_GetDiskFreeSpaceA              API_GetTempFileNameA + 1
#define API_GetDiskFreeSpaceExA            API_GetDiskFreeSpaceA + 1
#define API_GetVolumeInformationA          API_GetDiskFreeSpaceExA + 1
#define API_CopyFileA                      API_GetVolumeInformationA + 1
#define API_GetFileAttributesA             API_CopyFileA + 1
#define API_SetFileAttributesA             API_GetFileAttributesA + 1
#define API_DeleteFileA                    API_SetFileAttributesA + 1
#define API_MoveFileA                      API_DeleteFileA + 1
#define	API_MoveFileExA			   API_MoveFileA + 1
#define API_GetFileType                    API_MoveFileExA + 1
#define API_SetHandleCount                 API_GetFileType + 1
#define API_LockFile                       API_SetHandleCount + 1
#define API_UnlockFile                     API_LockFile + 1
#define API_ReadFile                       API_UnlockFile + 1
#define API_WriteFile                      API_ReadFile + 1
#define API_SetEndOfFile                   API_WriteFile + 1
#define API_SetFilePointer                 API_SetEndOfFile + 1
#define API_GetFileSize                    API_SetFilePointer + 1
#define API_GetFileTime                    API_GetFileSize + 1
#define API_SetFileTime                    API_GetFileTime + 1
#define API_FlushFileBuffers               API_SetFileTime + 1
#define API_FindFirstFileA                 API_FlushFileBuffers + 1
#define API_FindNextFileA                  API_FindFirstFileA + 1
#define API_FindClose                      API_FindNextFileA + 1
#define API_DeviceIoControl                API_FindClose + 1
#define API_CreatePipe                     API_DeviceIoControl + 1
#define API_OpenFile                       API_CreatePipe + 1
#define API_FindNextChangeNotification     API_OpenFile + 1
#define API_FindFirstChangeNotificationA   API_FindNextChangeNotification + 1
#define API_TlsSetValue                    API_FindFirstChangeNotificationA + 1
#define API_TlsFree                        API_TlsSetValue + 1
#define API_TlsAlloc                       API_TlsFree + 1
#define API_GetPriorityClass               API_TlsAlloc + 1
#define API_SetPriorityClass               API_GetPriorityClass + 1
#define API_GetThreadPriority              API_SetPriorityClass + 1
#define API_SetThreadPriority              API_GetThreadPriority + 1
#define API_CompareFileTime                API_SetThreadPriority + 1
#define API_DosDateTimeToFileTime          API_CompareFileTime + 1
#define API_SystemTimeToFileTime           API_DosDateTimeToFileTime + 1
#define API_FileTimeToSystemTime           API_SystemTimeToFileTime + 1
#define API_LocalFileTimeToFileTime        API_FileTimeToSystemTime + 1
#define API_FileTimeToLocalFileTime        API_LocalFileTimeToFileTime + 1
#define API_SetSystemTime                  API_FileTimeToLocalFileTime + 1
#define API_GetSystemTime                  API_SetSystemTime + 1
#define API_SetTimeZoneInformation         API_GetSystemTime + 1
#define API_GetTimeZoneInformation         API_SetTimeZoneInformation + 1
#define API_SetDaylightFlag                API_GetTimeZoneInformation + 1
#define API_SetLocalTime                   API_SetDaylightFlag + 1
#define API_FreeConsole                    API_SetLocalTime + 1
#define API_AllocConsole                   API_FreeConsole + 1
#define API_SetConsoleWindowInfo           API_AllocConsole + 1
#define API_GetLargestConsoleWindowSize    API_SetConsoleWindowInfo + 1
#define API_SetConsoleScreenBufferSize     API_GetLargestConsoleWindowSize + 1
#define API_ScrollConsoleScreenBufferA     API_SetConsoleScreenBufferSize + 1
#define API_ReadConsoleOutputA             API_ScrollConsoleScreenBufferA + 1
#define API_GetNumberOfConsoleMouseButtons API_ReadConsoleOutputA + 1
#define API_GetConsoleCursorInfo           API_GetNumberOfConsoleMouseButtons +1
#define API_WriteConsoleOutputAttribute    API_GetConsoleCursorInfo + 1
#define API_WriteConsoleInputA             API_WriteConsoleOutputAttribute + 1
#define API_SetConsoleTextAttribute        API_WriteConsoleInputA + 1
#define API_GetNumberOfConsoleInputEvents  API_SetConsoleTextAttribute + 1
#define API_FlushConsoleInputBuffer        API_GetNumberOfConsoleInputEvents + 1
#define API_FillConsoleOutputAttribute     API_FlushConsoleInputBuffer + 1
#define API_FillConsoleOutputCharacterA    API_FillConsoleOutputAttribute + 1
#define API_ReadConsoleOutputAttribute     API_FillConsoleOutputCharacterA + 1
#define API_ReadConsoleOutputCharacterA    API_ReadConsoleOutputAttribute + 1
#define API_WriteConsoleOutputCharacterA   API_ReadConsoleOutputCharacterA + 1
#define API_WriteConsoleOutputA            API_WriteConsoleOutputCharacterA + 1
#define API_SetConsoleCtrlHandler          API_WriteConsoleOutputA + 1
#define API_SetConsoleActiveScreenBuffer   API_SetConsoleCtrlHandler + 1
#define API_CreateConsoleScreenBuffer      API_SetConsoleActiveScreenBuffer + 1
#define API_ReadConsoleInputA              API_CreateConsoleScreenBuffer + 1
#define API_PeekConsoleInputA              API_ReadConsoleInputA + 1
#define API_SetConsoleTitleA               API_PeekConsoleInputA + 1
#define API_GetConsoleTitleA               API_SetConsoleTitleA + 1
#define API_GetConsoleScreenBufferInfo     API_GetConsoleTitleA + 1
#define API_SetConsoleCursorPosition       API_GetConsoleScreenBufferInfo + 1
#define API_SetConsoleCursorInfo           API_SetConsoleCursorPosition + 1
#define API_GetConsoleMode                 API_SetConsoleCursorInfo + 1
#define API_SetConsoleMode                 API_GetConsoleMode + 1
#define API_ReadConsoleA                   API_SetConsoleMode + 1
#define API_WriteConsoleA                  API_ReadConsoleA + 1
#define API_SetFileApisToOEM               API_WriteConsoleA + 1
#define API_CallNamedPipeA                 API_SetFileApisToOEM + 1
#define API_GetNamedPipeInfo               API_CallNamedPipeA + 1
#define API_SetNamedPipeHandleState        API_GetNamedPipeInfo + 1
#define API_GetNamedPipeHandleStateA       API_SetNamedPipeHandleState + 1
#define API_TransactNamedPipe              API_GetNamedPipeHandleStateA + 1
#define API_PeekNamedPipe                  API_TransactNamedPipe + 1
#define API_WaitNamedPipeA                 API_PeekNamedPipe + 1
#define API_SetMailslotInfo                API_WaitNamedPipeA + 1
#define API_GetMailslotInfo                API_SetMailslotInfo + 1
#define API_CreateMailslotA                API_GetMailslotInfo + 1
#define API_QueryDosDeviceA                API_CreateMailslotA + 1
#define API_SetCommConfig                  API_QueryDosDeviceA + 1
#define API_GetCommConfig                  API_SetCommConfig + 1
#define API_WaitCommEvent                  API_GetCommConfig + 1
#define API_TransmitCommChar               API_WaitCommEvent + 1
#define API_SetCommTimeouts                API_TransmitCommChar + 1
#define API_SetCommMask                    API_SetCommTimeouts + 1
#define API_PurgeComm                      API_SetCommMask + 1
#define API_GetCommTimeouts                API_PurgeComm + 1
#define API_GetCommProperties              API_GetCommTimeouts + 1
#define API_GetCommModemStatus             API_GetCommProperties + 1
#define API_GetCommMask                    API_GetCommModemStatus + 1
#define API_ClearCommError                 API_GetCommMask + 1
#define API_EscapeCommFunction             API_ClearCommError + 1
#define API_GetCommState                   API_EscapeCommFunction + 1
#define API_SetCommState                   API_GetCommState + 1
#define API_SetupComm                      API_SetCommState + 1
#define API_GetSystemInfo                  API_SetupComm + 1
#define API_Module32Next                   API_GetSystemInfo + 1
#define API_Module32First                  API_Module32Next + 1
#define API_Thread32Next                   API_Module32First + 1
#define API_Thread32First                  API_Thread32Next + 1
#define API_Process32Next                  API_Thread32First + 1
#define API_Process32First                 API_Process32Next + 1
#define API_Heap32ListNext                 API_Process32First + 1
#define API_Heap32ListFirst                API_Heap32ListNext + 1
#define API_CreateToolhelp32Snapshot       API_Heap32ListFirst + 1
#define API_ConvertToGlobalHandle          API_CreateToolhelp32Snapshot + 1
#define API_CreateFileMappingA             API_ConvertToGlobalHandle + 1
#define	API_GetFileInformationByHandle     API_CreateFileMappingA + 1
#define API_InterlockedExchange            API_GetFileInformationByHandle+1
#define API_GetProcessAffinityMask	   API_InterlockedExchange + 1      
#define API_SetThreadAffinityMask	   API_GetProcessAffinityMask+1
#define API_GetTickCount                   API_SetThreadAffinityMask+1
#define API_HeapCreate                     API_GetTickCount+1
#define API_VirtualQuery                   API_HeapCreate+1
#define API_VirtualQueryEx                 API_VirtualQuery+1
#define API_VirtualProtect                 API_VirtualQueryEx+1
#define API_VirtualProtectEx               API_VirtualProtect+1
#define API_GetShortPathNameA              API_VirtualProtectEx+1
#define API_QueueUserAPC                   API_GetShortPathNameA+1
#define API_ExpandEnvironmentStringsA	   API_QueueUserAPC+1
#define API_FindResourceA                  API_ExpandEnvironmentStringsA+1
#define API_FindResourceW                  API_FindResourceA+1
#define API_FindResourceExA                API_FindResourceW+1
#define API_FindResourceExW                API_FindResourceExA+1
#define API_EnumResourceTypesA             API_FindResourceExW+1
#define API_EnumResourceTypesW             API_EnumResourceTypesA+1
#define API_EnumResourceNamesA             API_EnumResourceTypesW+1
#define API_EnumResourceNamesW             API_EnumResourceNamesA+1
#define API_EnumResourceLanguagesA         API_EnumResourceNamesW+1
#define API_EnumResourceLanguagesW         API_EnumResourceLanguagesA+1
#define API_GetEnvironmentStringsA         API_EnumResourceLanguagesW+1
#define API_FreeEnvironmentStringsA        API_GetEnvironmentStringsA+1
#define API_SetFileApisToANSI              API_FreeEnvironmentStringsA+1
#define API_AreFileApisANSI		   API_SetFileApisToANSI+1
#define API_GetThreadLocale                API_AreFileApisANSI+1
#define API_GetComputerNameA               API_GetThreadLocale+1
#define API_SetComputerNameA               API_GetComputerNameA+1
#define API_GetProcessVersion              API_SetComputerNameA+1
#define API_GetSystemTimeAsFileTime	   API_GetProcessVersion+1
#define API_TlsFreeGlobal                  API_GetSystemTimeAsFileTime + 1
#define API_TlsAllocGlobal                 API_TlsFreeGlobal + 1
#define API_CreateWaitableTimerA           API_TlsAllocGlobal+1
#define API_OpenWaitableTimerA             API_CreateWaitableTimerA+1
#define API_SetWaitableTimer               API_OpenWaitableTimerA+1
#define API_CancelWaitableTimer            API_SetWaitableTimer+1
#define API_GetLongPathNameA               API_CancelWaitableTimer+1
#define API_GetFileAttributesExA           API_GetLongPathNameA+1
#define API_DefineDosDeviceA               API_GetFileAttributesExA+1
#define API_OpenThread					   API_DefineDosDeviceA+1
#ifdef  WOW
// Note: on 9X, somebody added API_CancelIO incorrectly.
#define API_CancelIo                       API_OpenThread+1
#define API_VerifyVersionInfoW             API_CancelIo+1
#define NAPI_INFO_BLOCKS                   API_VerifyVersionInfoW
#else
#define NAPI_INFO_BLOCKS                   API_OpenThread
#define API_CancelIo                       NAPI_INFO_BLOCKS+1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\cbcid.inc ===
; Whenever a module registers a group of callback thunks with win32c.dll,
; it uses a unique 16-bit Callback Client id to identify the group.
; We're using fixed numbers for the standard system dll's for convenience.
; We may add an id allocator to win32c.dll for use by third-party modules.
;
; Rules for CBC id's:
;
;    - CBC id's are 16-bits wide.
;    - The value 0 is reserved. Don't ues as an id.
;    - CBID_MAX is the largest id that win32c.dll supports.
;    - CBID_FREEUSE is the smallest id for use by third party developers.
;      All id's below this value are reserved by MS.


CBCID_KERNEL            equ     1
CBCID_GDI               equ     2
CBCID_USER              equ     3
CBCID_COMMDLG           equ     4
CBCID_SHELL             equ     5
CBCID_LZ                equ     6
CBCID_OLE               equ     7
CBCID_ADVAPI            equ     8

CBCID_WIN32C            equ     9
CBCID_PEN               equ     10


CBCID_FREEUSE           equ     20      ;Id's less than this reserved for MS
CBCID_MAX               equ     29      ;Largest id allowed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\console.h ===
//  CONSOLE.H
//
//      (C) Copyright Microsoft Corp., 1988-1994
//
//      Interfaces for the console
//
//  Origin: Chicago
//
//  Change history:
//
//  Date       Who        Description
//  ---------  ---------  -------------------------------------------------
//  15-Apr-93  Steve Lewin-Berlin (Cypress Software) created
//  15-Feb-94  JonT       Code cleanup and precompiled headers

#include <vmdapriv.h>

// Console flags
// WARNING: Don't change these without updating vcond\vconsole.h

#define CF_FullscreenSizeOK	1	// ON if switch to fullscreen allowed
					// (available)
					// (available)
#define CF_InputEOF		8	// ON if input EOF not consumed yet
#define CF_Fullscreen		16	// ON if console is in full screen mode
#define CF_ConagentTop		32	// ON if conagent is top level process in console
#define CF_AttributeSet		64	// ON if attribute specified
#define CF_Closing		128	// ON if not accepting new process attaches
#define	CF_ConagentWasHere	256	// ON if a kernel-launched conagent successfully rendezvous'd with conapp
#define CF_PendingSetTitle	512	// ON if SetConsoleTitle() message pending
#define CF_ConagentIsDone	1024    // ON if CF_Closing on and conagent is finished
#ifdef	NEC_98
#define CF_ForceSetNative	2048	// ON if temporary native mode
#endif	//NEC_98


// Returned by VCOND_ReadInput

#define READ_EOF		0x80000000

// Screen buffer state
//
typedef enum _SB_STATE {
	SB_PHYSICAL,
	SB_NATIVE,
	SB_MEMORY
} SB_STATE;

// Screen buffer flags (bit masks)
#define	fCursorVisible		1
#define fAttributeValid		2
#define fChanged		4

// Other defaults, etc

#define DEFAULT_ATTRIBUTE 07

#define SetFlag(f, mask)	(f |= (mask))
#define ClearFlag(f, mask)	(f &= (~mask))
#define TestFlag(f, mask)	(f & (mask))

//----------------------------------------------------------------
//		Global variables
//----------------------------------------------------------------

extern	HANDLE	hheapConsole;

//----------------------------------------------------------------
//		Macros
//----------------------------------------------------------------


#define Coord2Dword(c) ( * (DWORD *) &(c) )
#define Dword2Coord(c) ( * (COORD *) &(c) )

#define LockConsole(pConsole)	EnterCrst(&(pConsole->csCRST))
#define UnlockConsole(pConsole)	LeaveCrst(&(pConsole->csCRST));

#define LockSB(pSB)		EnterCrst(&(((SCREENBUFFER *)(pSB))->csCRST));
#define UnlockSB(pSB)		LeaveCrst(&(((SCREENBUFFER *)(pSB))->csCRST));



#define MAXCOLS 1024

//	WARNING: if this definition changes, update the definition in
//		 VMDOSAPP\TTYNGRAB.C
//
typedef struct _countedattr {
	WORD	count;
	char	Attr;
} COUNTEDATTR;

//	WARNING: if this definition changes, update the definition in
//		 VMDOSAPP\TTYNGRAB.C
//
typedef struct _packedline {
	COUNTEDATTR	*AttribArray;	// If not NULL, points to run-length encoded attribute array
	char		Attrib;		// Attribute for entire line if AttribArray is NULL
	char		ascii[];	// Character data
} PACKEDLINE;


typedef PACKEDLINE *SCREEN[];

//----------------------------------------------------------------
//	SCREENBUFFER object
//
//	WARNING: if this definition changes, update the definition in
//		 VMDOSAPP\GRABEMU.ASM
//
typedef struct _screen_buffer {
    // WinOldAp references the following fields:
    COMMON_OBJECT			// base of every object structure
    COORD	cBufsize;		// Number of rows/cols in buffer
    SCREEN *	Screen;			// Screen data
    COORD	cCursorPosition;	// Current position of cursor
    DWORD	dwCursorSize;		// Percent of cursor fill (1 - 100)
    SMALL_RECT	srWindow;		// Window (top, left, bottom, right of visible region)
    WORD	flags;			// Screen buffer flags
    // WinOldAp does not reference the rest of the structure
    SB_STATE	State;			// Physical, Native, or Memory
    CRST	csCRST;			// critical section for synching access to internal data		
    struct _console *pConsole;		// Pointer to owning console
    WORD	wAttribute;		// Current default text attribute (color)
    DWORD	flOutputMode;		// Output mode flags
#ifdef NEC_98
    BYTE        chDBCSLead;		// Holds if last string terinated at DBCS lead byte
#endif
} SCREENBUFFER;

#define MAXINCHARS 256			// Number of input characters to buffer

typedef struct _inbuffer {
    char	   cbBuf[MAXINCHARS];	// Input buffer
    SHORT	   curPos[MAXINCHARS];	// Remembers cursor pos
    WORD	   wReadIdx;		// Next index to read from
    WORD	   wWriteIdx;		// Next index to write to
    WORD	   wBufCount;		// Count of characters in buffer
#ifdef DBCS
    WORD	   wStatus;		// DBCS status flags
#endif
} INBUFFER;

#ifdef DBCS
// Status flag for DBCS handling
#define	BEGIN_TRAILBYTE	0x0001		// Buffer begin with DBCS trail byte
#endif

#define MAXTITLESIZE cbPathMax

//----------------------------------------------------------------
//	CONSOLE object
//
//	WARNING: if this definition changes, update the definition in
//		 VMDOSAPP\GRABEMU.ASM and the definition in 
//		 CORE\WIN32\VCOND\VCONSOLE.H
//
typedef struct _console {
    // WinOldAp references the following fields:
    COMMON_NSOBJECT			// base of every object structure - waitable (Input Buffer)
    SCREENBUFFER * psbActiveScreenBuffer; // Pointer to active screen buffer (if any)
    COORD	   cMaxSize;		// Max size of this console (maintained by WinOldAp)
    DWORD	   flags;		// Various console flags
    DWORD	   pidOwner;		// pid of first console "owner"
    DWORD	   tidOwner;		// tid of first console "owner"
    // WinOldAp does not reference the rest of the structure
    COORD	   cOriginalSize;	// Size inherited from DOS
    CRST	   csCRST;		// critical section for synching access to lists, etc.		   
    struct _lst *  plstOwners;		// pointer to list of owners (processes)
    struct _lst *  plstBuffers;		// pointer to list of screen buffers
    DWORD	   dwLastExitCode;	// Most recent exit code by a process in this console group
    char	   szTitle[MAXTITLESIZE]; // Title (truncated and displayed by WinOldAp)
    DWORD	   VID;			// ID used by VCOND
    HANDLE	   hVM;			// Process handle of VM which supports this console for i/o
    HANDLE	   hDisplay;		// hwnd of display port (used by WinOldAp)
    PDB *	   ppdbControlFocus;	// Process which holds current control focus for this console
    PDB *          ppdbTermConProvider; // console provider to terminate
    INBUFFER	   inbuf;		// Input buffer
    WORD	   wDefaultAttribute;	// Default screen buffer attribute
    struct _evt  * evtDoneWithVM;	// Signalled when all VM communication done
} CONSOLE;



//----------------------------------------------------------------
//		Function Prototypes
//

//----------------------------------------------------------------
//	Console
//----------------------------------------------------------------


VOID KERNENTRY SetControlFocus(void);

DWORD KERNENTRY CreateConsole(HANDLE hvm, HANDLE hwnd);

VOID KERNENTRY DisposeConsole(CONSOLE *pConsole);

DWORD KERNENTRY AttachProcessToConsole(CONSOLE *pConsole, PTDB ptdb, PPDB ppdb);

VOID KERNENTRY UnattachProcessFromConsole(CONSOLE *pConsole, PDB *ppdb);

VOID KERNENTRY RemoveOwnerFromList(CONSOLE *pConsole, PDB *ppdb);

DWORD KERNENTRY AddScreenBufferToList(CONSOLE *pConsole, SCREENBUFFER *pSB);

VOID KERNENTRY RemoveScreenBufferFromList(CONSOLE *pConsole, SCREENBUFFER *pSB);

VOID KERNENTRY DisposeScreenBuffer(SCREENBUFFER *pSB);

VOID KERNENTRY SetConsoleStartupInfo(PDB *ppdb, char *szFile);

//----------------------------------------------------------------
//	ScreenBuffer (CONSBUF)
//----------------------------------------------------------------

BOOL KERNENTRY SB_SetActive(SCREENBUFFER *pSB);

BOOL KERNENTRY SB_SetCursorPosition(SCREENBUFFER *pSB,
				    COORD dwCursorPosition);

SCREENBUFFER * KERNENTRY SB_Create(CONSOLE *pConsole,
				   BOOL bAllocateMemory);

BOOL KERNENTRY SB_GetInfo(SCREENBUFFER *pSB,
			  CONSOLE_SCREEN_BUFFER_INFO *lpCSBI);

BOOL KERNENTRY SB_SetCursorInfo(SCREENBUFFER *pSB,
				CONST CONSOLE_CURSOR_INFO *lpConsoleCursorInfo);

DWORD KERNENTRY SB_StringOut(SCREENBUFFER *pSB,
			     LPSTR lpBuffer,
			     DWORD cchToWrite);

VOID KERNENTRY SB_WriteConsoleOutput(SCREENBUFFER *pSB,
				     CONST CHAR_INFO *lpBuffer,
				     COORD srcSize,
				     COORD srcOrigin,
				     SMALL_RECT *lpsrDest);

VOID KERNENTRY SB_WriteConsoleOutputCharacters(SCREENBUFFER *pSB,
					      LPCSTR lpBuffer,
					      DWORD nChars,
					      COORD cLoc);
					      
VOID KERNENTRY SB_ReadConsoleOutputCharacters(SCREENBUFFER *pSB,
					      LPSTR lpCharacter,
					      DWORD nLength,
					      COORD cLoc);

VOID KERNENTRY SB_ReadConsoleOutputAttributes(SCREENBUFFER *pSB,
					      LPWORD lpAttribute,
					      DWORD nLength,
					      COORD cLoc);

VOID KERNENTRY SB_FillConsoleOutputAttribute(SCREENBUFFER *pSB,
					     WORD wAttribute,
					     DWORD nLength,
					     COORD cLoc);

VOID KERNENTRY SB_WriteAttribute(SCREENBUFFER *pSB,
				 CONST WORD *lpAttribute,
				 DWORD nLength,
				 COORD cLoc);

VOID KERNENTRY SB_GetCursorInfo(SCREENBUFFER *pSB,
				PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);

VOID KERNENTRY SB_FillConsoleOutputCharacter(SCREENBUFFER *pSB,
					     char cCharacter,
					     DWORD nLength,
					     COORD cLoc);

VOID KERNENTRY SB_SetAttribute(SCREENBUFFER *pSB,
			       WORD attr);

VOID KERNENTRY SB_ReadOutput(SCREENBUFFER *pSB,
			     PCHAR_INFO lpBuffer,
			     COORD dwBufferSize,
			     COORD dwBufferCoord,
			     PSMALL_RECT lpReadRegion);

BOOL KERNENTRY SB_Scroll(SCREENBUFFER *pSB,
			 CONST SMALL_RECT *psrScroll,
			 CONST SMALL_RECT *psrClip,
			 COORD cDest,
			 CONST CHAR_INFO *pciFill);

BOOL KERNENTRY SB_SetWindow(SCREENBUFFER *pSB,
			    BOOL bAbsolute,
			    CONST SMALL_RECT *psrWindow);

DWORD KERNENTRY SB_GetLargestConsole(SCREENBUFFER *pSB);

BOOL KERNENTRY SB_SetSize(SCREENBUFFER *pSB, COORD cSize);

HANDLE KERNENTRY NewHandleToActiveScreenBuffer(PDB *ppdb);

HANDLE KERNENTRY NewHandleToInputBuffer(PDB *ppdb);

CONSOLE * KERNENTRY CreateNewConsole(WORD wShowWindow);

BOOL KERNENTRY FInitConsoleHeap(void);

VOID KERNENTRY TerminateConsoleHeap(VOID);

VOID * KERNENTRY ConsoleAlloc(DWORD cbSize);

VOID * KERNENTRY ConsoleAlloc0(DWORD cbSize);

BOOL KERNENTRY ConsoleFree(VOID *pvMem);

VOID KERNENTRY SB_ReturnToPhysical(CONSOLE *pConsole);

BOOL KERNENTRY SB_ForceToPhysical(CONSOLE *pConsole);

BOOL KERNENTRY InternalReadConsoleChars(CONSOLE * pConsole,
					LPSTR lpBuffer,
					DWORD cchToRead,
					LPDWORD lpNumberOfCharsRead);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\coresig.inc ===
;/*

;** New signals here replace old ones called from Kernel to User.
;** Note that dll load and unload signals are gone
;** See below for parameter definitions of these new signals
SIG_MODULE_UNLOAD       equ 0001h       ;16-bit hModule or NE-PE buddy dying
SIG_GARBAGE_COLLECT     equ 0002h
SIG_PRE_FORCE_LOCK          equ 0003h
SIG_POST_FORCE_LOCK         equ 0004h
SIG_MODULE32_UNLOAD     equ 0005h       ;Process-detaching a PE module

SIG_THREAD_CREATE       equ 0010h
SIG_THREAD_TERMINATE    equ 0020h
SIG_THREAD              equ 00F0h

SIG_PROCESS_START       equ 0100h
SIG_PROCESS_CREATE      equ 0200h
SIG_PROCESS_EXIT        equ 0300h
SIG_PROCESS_TERMINATE   equ 0400h
SIG_PROCESS_CONSOLEREADY    equ 0500h
SIG_PROCESS_CREATE2     equ 0600h       ;Guarantees an hModule
SIG_PROCESS             equ 0F00h


;** Signal flags:  see below
SIGF_32BIT              equ 0001h
SIGF_GUI                equ 0002h
SIGF_USERFEEDBACK       equ 0004h
SIGF_FAULT              equ 0008h
SIGF_3x16BIT            equ 0010h

        if 0
;*/

//------------
// New signals
//------------


//  UserSignalProc
//
//      The receiver of signals from Kernel32 informing User of various
//      events in the life of processes and threads.
//
//  dwSignal - Identifies the type of signal.  See list of SG_XXX values
//  dwID - A process ID or thread ID from Kernel32
//  dwFlags - See SIGF_XXX values
//  hTask16 - An hTask value for communication with Kernel16

#ifdef WIN32
BOOL UserSignalProc(DWORD dwSignal, DWORD dwID, DWORD dwFlags, DWORD hTask16);
#else

//  SignalProc32
//
//      The 16-bit routine in USER that is thunked to from UserSignalProc

BOOL API SignalProc32(DWORD dwSignal, DWORD dwID, DWORD dwFlags, WORD hTask16);

//  GDISignalProc32
//
//      The 16-bit routine in GDI called by USER's SignalProc32 routine

BOOL API GDISignalProc32(DWORD dwSignal, DWORD dwID, DWORD dwFlags, WORD hTask16);

#endif

// Signal flags for various signals
#define SIGF_32BIT          0x00000001L
#define SIGF_GUI            0x00000002L
#define SIGF_USERFEEDBACK   0x00000004L
#define SIGF_FAULT          0x00000008L


//  Signal order notes:
//
//      The normal order for a single threaded Win32 app or for any Win16
//      app is as follows:
//      SIG_PROCESS_START  (Out of new process context)
//              SIG_THREAD_CREATE  (In new thread and process context)
//              SIG_PROCESS_CREATE (In new process context)
//              SIG_PROCESS_CREATE2 (In new process context after hModule set up)
//              ...  App runs, exits ...
//              SIG_PROCESS_EXIT (In exiting process context)
//              SIG_THREAD_TERMINATE 
//              SIG_PROCESS_TERMINATE (out of context)
//
//      The normal order for a multithreaded Win32 app is as follows:
//      SIG_PROCESS_START  (Out of new process context)
//              SIG_THREAD_CREATE  (In new thread and process context)
//              SIG_PROCESS_CREATE (In new process context)
//              SIG_PROCESS_CREATE2 (In new process context after hModule set up)
//              ... App runs, creates threads ...
//              SIG_THREAD_CREATE  (In new thread and process context)
//              SIG_THREAD_CREATE  (In new thread and process context)
//              ...  App runs, exits without terminating threads ...
//              SIG_PROCESS_EXIT (In exiting process context)
//              SIG_THREAD_TERMINATE (out of context)
//              SIG_THREAD_TERMINATE (out of context)
//              SIG_THREAD_TERMINATE (out of context)
//              SIG_PROCESS_TERMINATE (out of context)
//
//      In abnormal termination cases (thread or process terminated with
//      TerminateProcess/TerminateThread instead of ExitProcess/ExitThread),
//      the SIG_PROCESS_EXIT signal is not given.
//
//      Ordinarily, it would be best to not depend on the termination signal
//      order, but this might be necessary.  SIG_PROCESS_TERMINATE is
//      always the last signal sent for a process.

// SIG_MODULE_UNLOAD    
//
//      The signal is sent when either a 16-bit hModule or an 
//      NE-PE buddy is freed. Note that the process context could
//      be anything because ne-pe buddy destruction is asynchronous.
//
//      
//      dwFlags    - SIGF_32BIT  if ne-pe buddy
//      hTaskMod16 - hModule or ne-pe buddy
//
#define SIG_MODULE_UNLOAD       0x00000001L

#define SIG_GARBAGE_COLLECT     0x00000002L

//  SIG_PRE_FORCE_LOCK
//
//      The signal sent when the fault thread forces the locks away from
//      an app giving user a chance to get ready for displaying a dialog box.
//
//      dwID - id of the thread we stole the lock from
//

#define SIG_PRE_FORCE_LOCK          0x00000003L

//  SIG_POST_FORCE_LOCK
//
//      After the fault thread is finished with the displaying the dialog box.
//
//      dwID - id of the thread we stole the lock from
//

#define SIG_POST_FORCE_LOCK         0x00000004L


//  SIG_MODULE32_UNLOAD
//
//      Called in context after a PE module has process-detached from a process 
//      (of either bitness). Used to let user clean up user objects owned by
//      that module.
//
//      This signal won't be sent for process terminations (no process-detaches)
//      or faults or implicitly loaded libraries. This isn't a problem because:
//
//       1) If the process is 32-bit, any user objects created on its behalf
//          of it is private to it anyway and will be nuked as part of the 
//          process termination.
//
//       2) If the process is 16-bit, user ignores this signal anyway.
//          If a user object is registered on behalf of a 16-bit process,
//          it's lifetime is determined only by the ne-pe buddy, not
//          any process.
//      
//      dwID       - current process id
//      hTaskMod16 - ne-pe buddy of module being detached
//      
//
//
#define SIG_MODULE32_UNLOAD       0x00000005L


//  SIG_THREAD_CREATE
//
//      A signal sent whenever a thread is created.  Note that the first
//      SIG_THREAD_CREATE is sent before the SIG_PROCESS_CREATE
//
//  dwID - Thread ID

#define SIG_THREAD_CREATE           0x00000010L


//  SIG_THREAD_TERMINATE
//
//      A signal sent when a thread is terminated.  This signal is not sent
//      from the owning thread's context.  The signal handler must not make
//      assumptions about the context of the signal caller for this signal.
//
//  dwID - Thread ID

#define SIG_THREAD_TERMINATE    0x00000020L

#define SIG_THREAD              0x000000F0L


//  SIG_PROCESS_START
//
//  A signal sent when a Win32 or Win16 process is started.
//  Happens out of context, before the thread & process create signals.
//
//  dwID - Process ID

#define SIG_PROCESS_START       0x00000100L

//  SIG_PROCESS_CREATE
//
//      A signal sent when a Win32 or Win16 process is created.
//      Note that a SIG_THREAD_CREATE signals may have already been sent with
//      this process ID.
//
//  dwID - Process ID

#define SIG_PROCESS_CREATE          0x00000200L


// SIG_PROCESS_EXIT
//
//      A signal sent when a process exits normally.  This signal is always given
//      in the context of the application that is exiting.
//
//      NOTE:  This signal is NOT always given!  It is only given when the
//      process is killed with ExitProcess (not TerminateProcess) and assumes
//      that the process exited normally.
//
//      BUGBUG - this signal may not be sent for Win16 apps yet -- CHECK THIS!
//
//  dwID - Process ID

#define SIG_PROCESS_EXIT                0x00000300L

//  SIG_PROCESS_TERMINATE
//
//      A signal sent whenever a process terminates abnormally or otherwise.
//      It is called out of the context of the process terminating.
//      The signal receiver should make no assumptions about the context
//      of the signal caller in this case.
//
//      NOTE:  On normal process termination, both the SIG_PROCESS_EXIT
//      AND the SIG_PROCESS_TERMINATE are sent.  On abnormal termination,
//      only the SIG_PROCESS_TERMINATE is sent.
//
//  dwID - Process ID
//  dwFlags - Only has SIGF_32BIT, SIGF_DEBUGPROCESS available

#define SIG_PROCESS_TERMINATE   0x00000400L

//  SIG_PROCESS_CONSOLEREADY
//
//      A signal sent just before user code in a console application is
//      to be executed.  This gives USER a chance to turn off any feedback
//      UI started for a console process.  The signal handler can use
//      the the SIGF_USERFEEDBACK in this signal and in the SIG_PROCESS_CREATE
//      signal to determine the UI to enable or disable.

#define SIG_PROCESS_CONSOLEREADY        0x00000500L

//  SIG_PROCESS_CREATE2
//
//      A second create signal sent when a Win32 or Win16 process is created.
//      Sent after the SIG_PROCESS_CREATE signal. The only difference is
//      that this happens after the hModule is set up. This extra signal 
//      was added solely to make SoundEvents work.
//
//  dwID - Process ID

#define SIG_PROCESS_CREATE2         0x00000600L



#define SIG_PROCESS                 0x00000F00L

;/*
        endif
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\dbgdot.inc ===
;
; dbgdot.inc
;
; Wdeb386 dot command (.w) support
;


dbgprintf	   proto C :ptr byte, :VARARG
W32ParseDotCommand proto KERNENTRY
WdebService	   proto KERNENTRY
DPMIService	   proto KERNENTRY
W32LockDotMemory   proto KERNENTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\dbgdot.h ===
//
// dbgdot.h
//
// Wdeb386 dot command (.w) support
//


VOID  KERNENTRY dbgprintf(const char *, ...);
VOID  KERNENTRY dbgEvalExpr(DWORD *);
BOOL  KERNENTRY VerifyMemory(void *, int);
DWORD KERNENTRY GetDbgChar(void);
VOID  KERNENTRY InitDotCommand(void);
BOOL  KERNENTRY LockMemory(void *, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\demexp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  DEMEXP.H
 *  DOS emulation exports
 *
 *  History:
 *  22-Apr-1991 Sudeep Bharati (sudeepb)
 *  Created.
--*/

BOOL	 DemInit (int argc, char *argv[]);
BOOL	 DemDispatch(ULONG iSvc);
VOID	 demCloseAllPSPRecords (VOID);
DWORD	 demFileDelete (LPSTR lpFile);
DWORD	 demFileFindFirst (PVOID pDTA, LPSTR lpFile, USHORT usSearchAttr);
DWORD	 demFileFindNext (PVOID pDTA);
ULONG	 demClientErrorEx (HANDLE hFile, CHAR chDrive, BOOL bSetRegs);
UCHAR	 demGetPhysicalDriveType(UCHAR DriveNum);
ULONG	 demWOWLFNEntry(PVOID pUserFrame);
VOID	 demWOWLFNInit(PVOID pLFNInit);
NTSTATUS demSetCurrentDirectoryLCDS(UCHAR Drive, LPSTR pCurDir);
NTSTATUS demGetCurrentDirectoryLCDS(UCHAR Drive, LPSTR pCurDir);
ULONG	 demGetFileTimeByHandle_WOW(HANDLE hFile);
BOOL	 demIsShortPathName(LPSTR pszPath,BOOL fAllowWildCardName);
DWORD	 demLFNGetCurrentDirectory(UINT DriveNum,LPSTR lpDirectoryName);
DWORD	 demSetCurrentDirectoryGetDrive(LPSTR lpDirectoryName, PUINT pDriveNum);
ULONG	 demWOWLFNAllocateSearchHandle(HANDLE hFind);
HANDLE	 demWOWLFNGetSearchHandle(USHORT DosHandle);
BOOL	 demWOWLFNCloseSearchHandle(USHORT DosHandle);
VOID	 demLFNCleanup(VOID);

#define SIZEOF_DOSSRCHDTA 43

#if DEVL
// bit masks to control trace info
#define DEMDOSAPPBREAK 0x80000000
#define DEMDOSDISP     0x40000000
#define DEMFILIO       0x20000000
#define DEMSVCTRACE    0x10000000
#define KEEPBOOTFILES  0x01000000  // if set, no delete temp boot files
#define DEM_ABSDRD     0x02000000
#define DEM_ABSWRT     0x04000000
#define DEMERROR       0x08000000

extern DWORD  fShowSVCMsg;
#endif

#ifdef FE_SB
#define NTIO_411 "\\ntio411.sys"        // LANG_JAPANESE
#define NTIO_409 "\\ntio.sys"           //
#define NTIO_804 "\\ntio804.sys"        // LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED or SUBLANG_CHINESE_HONGKONG
#define NTIO_404 "\\ntio404.sys"        // LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL
#define NTIO_412 "\\ntio412.sys"        // LANG_KOREAN

#define NTDOS_411 "\\ntdos411.sys"      // LANG_JAPANESE
#define NTDOS_409 "\\ntdos.sys"         //
#define NTDOS_804 "\\ntdos804.sys"      // LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED or SUBLANG_CHINESE_HONGKONG
#define NTDOS_404 "\\ntdos404.sys"      // LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL
#define NTDOS_412 "\\ntdos412.sys"      // LANG_KOREAN
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\deb.h ===
/*
 *      deb.h - Debug API/events include file
 *
 *	4/25/93	mikem
 */

#define INVALID_ADDRESS		((PVOID)0xfffffbad)

#ifdef DEBUG

#define	DER_SIGNATURE_VALUE	0x20524544	// "DER "
#define	DEE_SIGNATURE_VALUE	0x20454544	// "DEE "

#define	debAssertCreateDER(pder)  {(pder)->der_signature = DER_SIGNATURE_VALUE;}
#define	debAssertCreateDEE(pdee)  {(pdee)->dee_signature = DEE_SIGNATURE_VALUE;}
#define	debAssertDestroyDER(pder) {(pder)->der_signature = 0x44414544;}
#define	debAssertDestroyDEE(pdee) {(pdee)->dee_signature = 0x44414544;}
#define	debAssertSignature(type)  ULONG type##_signature;
#define debAssertDER(pder) Assert((pder)->der_signature==DER_SIGNATURE_VALUE)
#define debAssertDEE(pdee) Assert((pdee)->dee_signature==DEE_SIGNATURE_VALUE)

#else

#define	debAssertCreateDER(pder)
#define	debAssertCreateDEE(pdee)
#define	debAssertDestroyDER(pder)
#define	debAssertDestroyDEE(pdee)
#define	debAssertSignature(type)
#define debAssertDER(pder)
#define debAssertDEE(pdee)

#endif

/* Debugger data block.  Pointed to by "tdb_pderDebugger" in the tdb. */

typedef struct _der {
    struct _dee *der_pdeeHead;	// list of debuggee data blocks - MUST BE FIRST
    PTDB der_ptdbDebugger;	// the debugger's thread data block
    PPDB der_ppdbDebugger;	// the debugger's process data block
    CRST der_crst;		// critical section for protecting DER
    PEVT der_pevtDebugger;	// debugger's wait event
    PEVT der_pevtDebuggee;	// debuggee's wait event
    DEBUG_EVENT der_de;		// debug event block for this debugger
    BOOL der_fContinueStatus;	// continue status for exception events
    CONTEXT der_context;	// context record while in an exception
    debAssertSignature(der)
} DER;

typedef DER *PDER;

/* Debuggee data block.  Pointed to by "pdb_pdeeDebuggee" in the pdb. */

typedef struct _dee {
    struct _dee *dee_pdeeNext;	// next in list, 0 if end - MUST BE FIRST
    PPDB dee_ppdbDebuggee;	// pointer to debuggee's process data block
    PDER dee_pderDebugger;	// pointer to debugger's data block
    HANDLE dee_ihteProcess;	// debuggee process handle for debugger
    DWORD dee_cThreads;		// count of threads in process
    HANDLE dee_hheapShared;	// shared-arena heap for storing thunks
    debAssertSignature(dee)
} DEE;

typedef DEE *PDEE;

/* Debug IAT thunk template */

typedef struct _dit {
    BYTE dit_pushop;		// 0x68
    DWORD dit_oldiat;		// old iat address
    BYTE dit_jmpop;		// 0xe9
    DWORD dit_relcom;		// relative offset to DEBCommonIATThunk
} DIT;

typedef DIT *PDIT;

/* Shared DLL debug entry record */

typedef	struct _DEBDLLCONTEXT {
    struct _DEBDLLCONTEXT *NextActive;	// null terminated active list
    struct _DEBDLLCONTEXT *NextFree;	// null terminated free list
    struct {				// exception registration record
	PVOID	Next;
	PVOID	Handler;
    } ExRegRec;
    CONTEXT Context;			// context record
} DEBDLLCONTEXT, *PDEBDLLCONTEXT;

/* Shared DLL debug entry record sentinel */

typedef	struct _DEBDLLCONTEXTSENTINEL {
    struct _DEBDLLCONTEXT *NextActive;	// null terminated active list
    struct _DEBDLLCONTEXT *NextFree;	// null terminated free list
} DEBDLLCONTEXTSENTINEL, *PDEBDLLCONTEXTSENTINEL;

/* Number of initial DEBDLLCONTEXT records per thread */

#define	N_INITIAL_DEBDLLRECS	1

VOID __cdecl DEBCommonIATThunk();
VOID __cdecl DEBCommonIATThunkUnwindHandler();

/* Prototypes for internal debug api functions */

BOOL KERNENTRY DEBCreateProcess(DWORD, DWORD, DWORD, PPDB, PTDB);
VOID KERNENTRY DEBExitProcess(PPDB);
BOOL KERNENTRY DEBCreateThread(PTDB, DWORD);
VOID KERNENTRY DEBExitThread(PTDB);
VOID KERNENTRY DEBCreateProcessEvent(PPDB, PTDB, BOOL);
VOID KERNENTRY DEBCreateThreadEvent(PTDB, PVOID);
VOID KERNENTRY DEBExitThreadOrProcessEvent();
BOOL KERNENTRY DEBExceptionEvent(DWORD, ULONG, PEXCEPTION_RECORD, PCONTEXT);
VOID KERNENTRY DEBAttachProcessModules(PTDB, BOOL);
VOID KERNENTRY DEBLoadDLLEvent(PTDB, PVOID, PVOID);
VOID KERNENTRY DEBUnloadDLLEvent(PVOID);
VOID KERNENTRY DEBRipEvent(DWORD, DWORD);
BOOL KERNENTRY DEBMakePrivate(PVOID, ULONG);
PDIT KERNENTRY DEBCreateDIT(HANDLE, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\handle.inc ===
;************************************************************************
;*									*
;*	HANDLE.H	--  Handle Table Declarations			*
;*									*
;************************************************************************
;*	Author:     Gene Apperson					*
;*	Copyright:  1991 Microsoft					*
;************************************************************************
;*  File Description:							*
;*									*
;*									*
;************************************************************************
;*  Revision History:							*
;*									*
;*									*
;************************************************************************


;* ------------------------------------------------------------ *
;*   rghte[x].flFlags bits					*
;* ------------------------------------------------------------ *

fhteInherit		EQU	80000000h	;* Is inheritable
fhteDevObj		EQU	40000000h	;* Device (file or console)

mhteSpecific            EQU     0000FFFFh       ; SPECIFIC_RIGHTS_ALL
mhteStandard            EQU     001F0000h       ; STANDARD_RIGHTS_ALL
mhteSystem              EQU     0FF000000h

fhteStdRequire          EQU     00f0000h        ; STANDARD_RIGHTS_REQUIRED
fhteSynch               EQU     0100000h        ; SYNCHRONIZE

fhteDevShrRead          EQU     00000001h
fhteDevShrWrite 	EQU	00000002h
fhteDevAccRead          EQU     00000020h
fhteDevAttrWrite 	EQU	00000100h
fhteDevAccWrite 	EQU	00000110h
fhteDevAccAll		EQU	00000130h
fhteDevAccAny		EQU	00000000h
fhteDevOverlapped       EQU     00001000h

mhteDevAcc		EQU	00000130h
mhteDevShr              EQU     00000003h

flMaskAll               EQU     0FFFFFFFFh


;*
;* MapHandle argument values.
;*
;* Object type values.
;*
typSemaphore	EQU	(1 SHL (typObjShiftAdjust + typObjSemaphore))
typEvent	EQU	(1 SHL (typObjShiftAdjust + typObjEvent))
typMutex	EQU	(1 SHL (typObjShiftAdjust + typObjMutex))
typCrst		EQU	(1 SHL (typObjShiftAdjust + typObjCrst))
typProcess	EQU	(1 SHL (typObjShiftAdjust + typObjProcess))
typThread	EQU	(1 SHL (typObjShiftAdjust + typObjThread))
typFile		EQU	(1 SHL (typObjShiftAdjust + typObjFile))
typIO		EQU	(1 SHL (typObjShiftAdjust + typObjIO))
typConsole	EQU	(1 SHL (typObjShiftAdjust + typObjConsole))
typConScreenbuf	EQU	(1 SHL (typObjShiftAdjust + typObjConScreenbuf))
typMapFile	EQU	(1 SHL (typObjShiftAdjust + typObjMapFile))
typSerial	EQU	(1 SHL (typObjShiftAdjust + typObjSerial))
typDevIOCtl	EQU	(1 SHL (typObjShiftAdjust + typObjDevIOCtl))
typPipe		EQU	(1 SHL (typObjShiftAdjust + typObjPipe))
typMailslot	EQU	(1 SHL (typObjShiftAdjust + typObjMailslot))
typToolhelp	EQU	(1 SHL (typObjShiftAdjust + typObjToolhelp))
typSocket	EQU	(1 SHL (typObjShiftAdjust + typObjSocket))
typTimer        EQU     (1 SHL (typObjShiftAdjust + typObjTimer))
typR0ObjExt	EQU	(1 SHL (typObjShiftAdjust + typObjR0ObjExt))
typAny	    	EQU (NOT (0ffffffffh SHL (1 + typObjShiftAdjust + typObjMaxValid)))
typSTDIN        EQU     (typFile OR typPipe OR typSocket OR typConsole)
typSTDOUT       EQU     (typFile OR typPipe OR typSocket OR typConScreenbuf)
typNone		EQU	0
typMask		EQU	typAny

;*
;* Boolean flag to MapHandle (snuck inside objType parameter) to prevent the
;* object from being freed until UnlockObject() is called.
;*
objLOCK		EQU	080000000h


;* ------------------------------------------------------------ *
;*								*
;* ------------------------------------------------------------ *

chteInit        EQU     16
chteInc		EQU	16

hprocCur	EQU	07FFFFFFFh
hprocInvalid	EQU	0FFFFFFFFh

;; Handles are derived by left-shifting ihte's by this many bits.
;; This corresponds to the number of low bits reserved by NT.
IHTETOHANDLESHIFT equ 2


;; Maximum value for a normal handle (handles above this value
;; are either global or special.)
;;
hMaxValid       EQU     00FFFFFFh
ihteMaxValid    EQU     (hMaxValid SHR IHTETOHANDLESHIFT)

HTE		STRUCT
  flFlags	DWORD	0
  pobj		LPOBJ	0
HTE		ENDS
LPHTE		TYPEDEF PTR HTE

HTB		STRUCT
  chteMax	DWORD	0
  rghte 	HTE	1 DUP (<>)
HTB		ENDS
LPHTB		TYPEDEF PTR HTB



;; Handles are considered global if the high byte is equal to the high byte
;;  of GLOBALHANDLEMASK.
;;
;; When handles are converted to ihtes, they are just right-shifted like
;; any other. That is, if n == IHTETOHANDLESHIFT, global ihtes have 0's
;; in the top n bits, the high byte of GLOBALHANDLEMASK in the next 8 bits.
;;
;; The low n bits of the mask must be zero because those bits are lost
;; when handles are converted to ihtes.
GLOBALHANDLEMASK equ 0453a4d3ch
.errnz GLOBALHANDLEMASK AND ((1 SHL IHTETOHANDLESHIFT) - 1)

;* ------------------------------------------------------------ *
;*		    Function Prototypes 			*
;* ------------------------------------------------------------ *

; VOID *
MapHandle PROTO KERNENTRY,
	:HANDLE,
	:DWORD,
	:DWORD

; VOID *
MapHandleWithContext PROTO KERNENTRY,
	:LPPDB,
	:HANDLE,
	:DWORD,
	:DWORD

; LPHTB
PhtbCreate PROTO KERNENTRY,
	:LPPDB

; VOID
CloseProcessHandles PROTO KERNENTRY,
	:LPPDB

; VOID
CloseDOSHandles PROTO KERNENTRY

; BOOL
FInheritHandles PROTO KERNENTRY,
	:LPPDB,
	:LPPDB

IFNDEF	IS_VXD
; LONG
FlValidateSecurity PROTO KERNENTRY,
	:LPSECURITY_ATTRIBUTES
ENDIF ;; IS_VXD

; HANDLE
ConvertToGlobalHandle PROTO KERNENTRY,
	:HANDLE


;* ------------------------------------------------------------ *
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\heap.h ===
/*
 *      heap.h - structures and equates for the Windows 32-bit heap
 *
 *  Origin: Chicago
 *
 *  Change history:
 *
 *  Date       Who        Description
 *  ---------  ---------  -------------------------------------------------
 *  1991       BrianSm    Created
 */

#ifdef DEBUG
#define HPDEBUG 1
#endif
#ifndef WIN32
#define WIN32
#endif

#define HPNOTTRUSTED 1  /* enable parameter checking */

/***LT  busyblock_s - busy heap block header structure
 *
 *      This structure is stored at the head of every busy (not free) heap
 *      block.
 *
 *      The bh_size field is in bytes and includes the size of the
 *      heap header and any slop at the end of the block that might have
 *      been included because of the heap granularity, or to keep us
 *      from leaving a block too small to hold a free heap header.
 *
 *      bh_size is also used as a forward link to the next heap block.
 *
 *      The low two bits of the bh_size field are used to hold flags
 *      (BP_FREE must be clear and HP_PREVFREE is optionally set).
 */
#ifndef HPDEBUG
struct busyheap_s {
        unsigned long   bh_size;        /* block size + flags in low 2 bits */
};
#else
struct busyheap_s {
        unsigned long   bh_size;        /* block size + flags in low 2 bits */
        unsigned long   bh_eip;         /* EIP of allocator */
        unsigned short  bh_tid;         /* thread id of allocator */
        unsigned short  bh_signature;   /* signature (should be BH_SIGNATURE)*/
        unsigned long   bh_sum;         /* checksum of this structure */
};
#endif

/*XLATOFF*/
#define BH_SIGNATURE    0x4842          /* busy heap block signature (BH) */
/*XLATON*/

#define BH_CDWSUM       3               /* count of dwords to sum in struct */


/***LT  freeblock_s - free heap block header structure
 *
 *      This structure is stored at the head of every free block on the
 *      heap.  In the last dword of every free heap block is a pointer
 *      the this structure.
 *
 *      The fh_size field is in bytes and includes the size of the
 *      heap header and any slop at the end of the block that might have
 *      been included because of the heap granularity, or to keep us
 *      from leaving a block too small to hold a free heap header.
 *
 *      fh_size is also used as a forward link to the next heap block.
 *
 *      The low two bits of the fh_size field are used to hold flags
 *      (HP_FREE must be set and HP_PREVFREE must be clear).
 */
#ifndef HPDEBUG
struct freeheap_s {
        unsigned long      fh_size;     /* block size + flags in low 2 bits */
        struct freeheap_s *fh_flink;    /* forward link to next free block */
        struct freeheap_s *fh_blink;    /* back link to previous free block */
};
#else
struct freeheap_s {
        unsigned long      fh_size;     /* block size + flags in low 2 bits */
        struct freeheap_s *fh_flink;    /* forward link to next free block */
        unsigned short     fh_pad;      /* unused */
        unsigned short     fh_signature;/* signature (should be FH_SIGNATURE)*/
        struct freeheap_s *fh_blink;    /* back link to previous free block */
        unsigned long      fh_sum;      /* checksum of this structure */
};
#endif

/*XLATOFF*/
#define FH_SIGNATURE    0x4846          /* free heap block signature (FH) */
/*XLATON*/

#define FH_CDWSUM       4               /* count of dwords to sum in struct */

/*
 *      Equates common to all heap blocks.
 *
 *      HP_FREE and HP_PREVFREE (HP_FLAGS) are stored in the low two
 *      bits of the fh_ and bh_size field.
 *      The signature is stored in the high three bits of the size.
 */
#define HP_FREE         0x00000001      /* block is free */
#define HP_PREVFREE     0x00000002      /* previous block is free */
#define HP_FLAGS        0x00000003      /* mask for all the flags */
#define HP_SIZE         0x0ffffffc      /* mask for clearing flags */
#define HP_SIGBITS      0xf0000000      /* bits used for signature */
#define HP_SIGNATURE    0xa0000000      /* valid value of signature */

/*
 *      Misc heap equates
 */
#define hpGRANULARITY   4               /* granularity for heap allocations */
#define hpGRANMASK      (hpGRANULARITY - 1)             /* for rounding */
/*XLATOFF*/
#define hpMINSIZE       (sizeof(struct freeheap_s)+sizeof(struct freeheap_s *))
                        /* min block size */

#define hpMAXALLOC      (HP_SIZE - 100) /* biggest allocatable heap block */

/* overhead for a new heap segment (header plus end sentinel) */
#define hpSEGOVERHEAD   (sizeof(struct busyheap_s) + sizeof(struct heapseg_s))

/* default reserved size of new segments added to growable heaps */
#define hpCBRESERVE     (4*1024*1024)


/*XLATON*/


/*
 * Exported flags for heap calls
 */
#ifdef WIN32
#define HP_ZEROINIT     0x40    /* zero initialize block on HP(Re)Alloc */
#define HP_MOVEABLE     0x02    /* block can be moved (HP(Re)Alloc) */
#define HP_NOCOPY       0x20    /* don't copy data on HPReAlloc */
#define HP_NOSERIALIZE  0x01    /* don't serialize heap access */
#define HP_EXCEPT       0x04    /* generate exceptions on error */
#ifdef HPMEASURE     
#define HP_MEASURE      0x80    /* enable heap measurement */
#endif

#else

#define HP_ZEROINIT     0x01    /* zero initialize block on HP(Re)Alloc */
#define HP_NOSERIALIZE  0x08    /* don't serialize heap access (HPInit) */
#define HP_NOCOPY       0x04    /* don't copy data on HPReAlloc */
#define HP_MOVEABLE     0x10    /* allow moving on HPReAlloc */
#define HP_LOCKED       0x80    /* put heap in locked memory (HPInit) */
#endif
#define HP_FIXED        0x00    /* block is at a fixed address (HPAlloc) */
#define HP_GROWABLE     0x40    /* heap can grow beyond cbreserve (HPInit) */
/*
 *  Note that flags above 0x80 will not be stored into the heap header in
 *  HPInit calls because the flags field in the header is only a byte
 */
#define HP_INITSEGMENT 0x100    /* just initialize a heap segment (HPInit) */
#define HP_DECOMMIT    0x200    /* decommit pages in free block (hpFreeSub) */
#define HP_GROWUP      0x400    /* waste last page of heap (HPInit) */

/*XLATOFF*/

/***LP  hpSize - pull size field from heap header
 *
 *      This routine depends on the size field being the first
 *      dword in the header.
 *
 *      ENTRY:  ph - pointer to heap header
 *      EXIT:   count of bytes in block (counting header).
 */
#define hpSize(ph) (*((unsigned long *)(ph)) & HP_SIZE)

/***LP  hpSetSize - set the size parameter in a heap header
 *
 *      This routine depends on the size field being the first
 *      dword in the header.
 *
 *      ENTRY:  ph - pointer to busy heap header
 *              cb - count of bytes (should be rounded using hpRoundUp)
 *      EXIT:   size is set in heap header
 */
#define hpSetSize(ph, cb) (((struct busyheap_s *)(ph))->bh_size =  \
                     ((((struct busyheap_s *)(ph))->bh_size & ~HP_SIZE) | (cb)))

/* the compiler used to do a better version with this macro than the above,
 * but not any more
#define hpSetSize2(ph, cb) *(unsigned long *)(ph) &= ~HP_SIZE; \
                           *(unsigned long *)(ph) |= (cb);
 */

/***LP  hpSetBusySize - set the entire bh_size dword for a busy block
 *
 *      This macro will set the bh_size field of the given heap header
 *      to the given size as well as setting the HP_SIGNATURE and clearing
 *      any HP_FREE or HP_PREVFREE bits.
 *
 *      ENTRY:  ph - pointer to busy heap header
 *              cb - count of bytes (should be rounded using hpRoundUp)
 *      EXIT:   bh_size field is initialized
 */
#define hpSetBusySize(ph, cb)   ((ph)->bh_size = ((cb) | HP_SIGNATURE))


/***LP  hpSetFreeSize - set the entire fh_size dword for a free block
 *
 *      This macro will set the fh_size field of the given heap header
 *      to the given size as well as setting the HP_SIGNATURE and HP_FREE
 *      and clearing HP_PREVFREE.
 *
 *      ENTRY:  ph - pointer to free heap header
 *              cb - count of bytes (should be rounded using hpRoundUp)
 *      EXIT:   bh_size field is initialized
 */
#define hpSetFreeSize(ph, cb)   ((ph)->fh_size = ((cb) | HP_SIGNATURE | HP_FREE))


/***LP  hpIsBusySignatureValid - check a busy heap block's signature
 *
 *      This macro checks the tiny signature (HP_SIGNATURE) in the bh_size
 *      field to see if it is set properly and makes sure that the HP_FREE
 *      bit is clear.
 *
 *      ENTRY:  ph - pointer to a busy heap header
 *      EXIT:   TRUE if signature is ok, else FALSE
 */
#define hpIsBusySignatureValid(ph) \
                    (((ph)->bh_size & (HP_SIGBITS | HP_FREE)) == HP_SIGNATURE)


/***LP  hpIsFreeSignatureValid - check a free heap block's signature
 *
 *      This macro checks the tiny signature (HP_SIGNATURE) in the fh_size
 *      field to see if it is set properly and makes sure that the HP_FREE
 *      bit is also set and HP_PREVFREE is clear.
 *
 *      ENTRY:  ph - pointer to a free heap header
 *      EXIT:   TRUE if signature is ok, else FALSE
 */
#define hpIsFreeSignatureValid(ph) \
          (((ph)->fh_size & (HP_SIGBITS | HP_FREE | HP_PREVFREE)) == \
                                                     (HP_SIGNATURE | HP_FREE))


/***LP  hpRoundUp - round up byte count to appropriate heap block size
 *
 *      Heap blocks have a minimum size of hpMINSIZE and hpGRANULARITY
 *      granularity.  This macro also adds on size for the heap header.
 *
 *      ENTRY:  cb - count of bytes
 *      EXIT:   count rounded up to hpGANULARITY boundary
 */
#define hpRoundUp(cb)   \
      max(hpMINSIZE,    \
          (((cb) + sizeof(struct busyheap_s) + hpGRANMASK) & ~hpGRANMASK))


/*XLATON*/

/***LK  freelist_s - heap free list head
 */
struct freelist_s {
        unsigned long     fl_cbmax;     /* max size block in this free list */
        struct freeheap_s fl_header;    /* pseudo heap header as list head */
};
#define hpFREELISTHEADS 4       /* number of free list heads in heapinfo_s */

/***LK  heapinfo_s - per-heap information (stored at start of heap)
 *
 */
struct heapinfo_s {

        /* These first three fields must match the fields of heapseg_s */
        unsigned long   hi_cbreserve;           /* bytes reserved for heap */
        struct heapseg_s *hi_psegnext;          /* pointer to next heap segment*/

        struct freelist_s hi_freelist[hpFREELISTHEADS]; /* free list heads */
#ifdef WIN32
        struct heapinfo_s *hi_procnext;         /* linked list of process heaps */
        CRST    *hi_pcritsec;                   /* pointer to serialization obj*/
        CRST    hi_critsec;                     /* serialize access to heap */
#ifdef HPDEBUG
        unsigned char   hi_matchring0[(76-sizeof(CRST))]; /* pad so .mh command works */
#endif
#else
        struct _MTX    *hi_pcritsec;            /* pointer to serialization obj*/
        struct _MTX     hi_critsec;             /* serialize access to heap */
#endif
#ifdef HPDEBUG
        unsigned long   hi_thread;              /* thread pointer of thread
                                                 * inside heap code */
        unsigned long   hi_eip;                 /* EIP of heap's creator */
        unsigned long   hi_sum;                 /* checksum of this structure*/
        unsigned short  hi_tid;                 /* thread ID of heap's creator*/
        unsigned short  hi_pad1;                /* unused */
#endif
        unsigned char   hi_flags;               /* HP_SERIALIZE, HP_LOCKED */
        unsigned char   hi_pad2;                /* unused */
        unsigned short  hi_signature;           /* should be HI_SIGNATURE */
};

/*
 * Heap Measurement functions
 */
#define  HPMEASURE_FREE    0x8000000L

#define  SAMPLE_CACHE_SIZE 1024

struct measure_s {
   char  szFile[260];
   unsigned iCur;
   unsigned uSamples[SAMPLE_CACHE_SIZE];
};

/*XLATOFF*/
#define HI_SIGNATURE  0x4948        /* heapinfo_s signature (HI) */
/*XLATON*/

#define HI_CDWSUM  1                /* count of dwords to sum */

typedef struct heapinfo_s *HHEAP;


/***LK  heapseg_s - per-heap segment structure
 *
 *      Growable heaps can have multiple discontiguous sections of memory
 *      allocated to them.  Each is headed by one of these structures.  The
 *      first segment is special, in that it has a full heapinfo_s structure,
 *      but the first fields of heapinfo_s match heapseg_s, so it can be
 *      treated as just another segment when convenient.
 */
struct heapseg_s {
        unsigned long   hs_cbreserve;   /* bytes reserved for this segment */
        struct heapseg_s *hs_psegnext;  /* pointer to next heap segment*/
};
/* XLATOFF */

/* smallest possible heap */
#define hpMINHEAPSIZE   (sizeof(struct heapinfo_s) + hpMINSIZE + \
                         sizeof(struct busyheap_s))

/***LP  hpRemove - remove item from free list
 *
 *      ENTRY:  pfh - pointer to free heap block to remove from list
 *      EXIT:   none
 */
#define hpRemoveNoSum(pfh)                              \
        (pfh)->fh_flink->fh_blink = (pfh)->fh_blink;    \
        (pfh)->fh_blink->fh_flink = (pfh)->fh_flink;

#ifdef HPDEBUG
#define hpRemove(pfh)   hpRemoveNoSum(pfh);                     \
                        (pfh)->fh_flink->fh_sum =               \
                            hpSum((pfh)->fh_flink, FH_CDWSUM);  \
                        (pfh)->fh_blink->fh_sum =               \
                            hpSum((pfh)->fh_blink, FH_CDWSUM);
#else
#define hpRemove(pfh)   hpRemoveNoSum(pfh)
#endif

/***LP  hpInsert - insert item onto the free list
 *
 *      ENTRY:  pfh - free heap block to insert onto the list
 *              pfhprev - insert pfh after this item
 *      EXIT:   none
 */
#define hpInsertNoSum(pfh, pfhprev)             \
        (pfh)->fh_flink = (pfhprev)->fh_flink;  \
        (pfh)->fh_flink->fh_blink = (pfh);      \
        (pfh)->fh_blink = (pfhprev);            \
        (pfhprev)->fh_flink = (pfh)

#ifdef HPDEBUG
#define hpInsert(pfh, pfhprev)  hpInsertNoSum(pfh, pfhprev);    \
                        (pfh)->fh_flink->fh_sum =               \
                            hpSum((pfh)->fh_flink, FH_CDWSUM);  \
                        (pfhprev)->fh_sum =                     \
                            hpSum((pfhprev), FH_CDWSUM)
#else
#define hpInsert(pfh, pfhprev)  hpInsertNoSum(pfh, pfhprev)
#endif

#ifdef WIN32
#define INTERNAL
#endif

/*
 * critical section macros to be used by all internal heap functions
 */
#ifndef WIN32
    #define hpEnterCriticalSection(hheap) mmEnterMutex(hheap->hi_pcritsec)
    #define hpLeaveCriticalSection(hheap) mmLeaveMutex(hheap->hi_pcritsec)
    #define hpInitializeCriticalSection(hheap) \
        hheap->hi_pcritsec = &(hheap->hi_critsec); \
        mmInitMutex(hheap->hi_pcritsec)
#else
    #define hpEnterCriticalSection(hheap) EnterCrst(hheap->hi_pcritsec)
    #define hpLeaveCriticalSection(hheap) LeaveCrst(hheap->hi_pcritsec)
    #define hpInitializeCriticalSection(hheap)              \
        if (hheapKernel) {                              \
            hheap->hi_critsec.typObj = 0;               /* 0 init crit sect obj type */ \
            InitializeCriticalSection( (LPCRITICAL_SECTION)(&(hheap->hi_critsec)) ); \
            hheap->hi_pcritsec = ((CRST_EXPORT *)(&(hheap->hi_critsec)))->crstInternal; \
        } else {                                        \
            hheap->hi_pcritsec = &(hheap->hi_critsec);  \
            InitCrst(hheap->hi_pcritsec);               \
        }
#endif

/*
 * Exported heap functions
 */
extern HHEAP INTERNAL HPInit(void *hheap, void *pmem, unsigned long cbreserve,
                             unsigned long flags);
extern void * INTERNAL HPAlloc(HHEAP hheap, unsigned long cb,
                             unsigned long flags);

extern void * INTERNAL HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb,
                               unsigned long flags);
#ifndef WIN32
extern unsigned INTERNAL HPFree(HHEAP hheap, void *lpMem);
extern unsigned INTERNAL HPSize(HHEAP hheap, void *lpMem);
extern HHEAP INTERNAL  HPClone(struct heapinfo_s *hheap, struct heapinfo_s *pmem);
#endif


/*
 * Local heap functions
 */
extern void INTERNAL hpFreeSub(HHEAP hheap, void *pblock, unsigned cb,
                               unsigned flags);
extern unsigned INTERNAL hpCommit(unsigned page, int npages, unsigned flags);
extern unsigned INTERNAL hpCarve(HHEAP hheap, struct freeheap_s *pfh,
                                unsigned cb, unsigned flags);
#ifdef WIN32
extern unsigned INTERNAL hpTakeSem(HHEAP hheap, void *pbh, unsigned flags);
extern void INTERNAL hpClearSem(HHEAP hheap, unsigned flags);
#else
extern unsigned INTERNAL hpTakeSem2(HHEAP hheap, void *pbh);
extern void INTERNAL hpClearSem2(HHEAP hheap);
#endif

/*
 * Debug functions
 */
#ifdef HPDEBUG

extern unsigned INTERNAL hpWalk(HHEAP hheap);
extern char INTERNAL hpfWalk;
extern char INTERNAL hpfTrashStop;
extern char INTERNAL hpfParanoid;
extern char         mmfErrorStop;
extern unsigned long INTERNAL hpGetAllocator(void);
extern unsigned long INTERNAL hpSum(PVOID p, unsigned long cdw);

#else

#define hpWalk(hheap) 1

#endif

#ifdef WIN32
#ifdef HPDEBUG
#define DebugStop() { _asm int 3 }
#define mmError(rc, string)    vDebugOut(mmfErrorStop ? DEB_ERR : DEB_WARN, string);SetError(rc)
#define mmWarn(rc, string)     vDebugOut(DEB_WARN, string);SetError(rc)
#define mmAssert(exp, psz)     if (!(exp)) vDebugOut(DEB_ERR, psz)
#else
#define mmError(rc, string) SetError(rc)
#define mmWarn(rc, string) SetError(rc)
#define mmAssert(exp, psz)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\handle.h ===
/************************************************************************/
/*									*/
/*	HANDLE.H	--  Handle Table Declarations			*/
/*									*/
/************************************************************************/
/*	Author:     Gene Apperson					*/
/*	Copyright:  1991 Microsoft					*/
/************************************************************************/
/*  File Description:							*/
/*									*/
/*									*/
/************************************************************************/
/*  Revision History:							*/
/*									*/
/*  03/13/92 (GeneA): changed default size of handle table from 32 to	*/
/*	48.  Added FGetDosHandles prototype				*/
/*									*/
/************************************************************************/


/* ------------------------------------------------------------ */
/*   rghte[x].flFlags bits					*/
/* ------------------------------------------------------------ */

#define     fhteInherit		0x80000000  /* Is inheritable */
#define     fhteDevObj		0x40000000  /* Device (file or console) */

#define     mhteSpecific        0x0000ffff  //  SPECIFIC_RIGHTS_ALL
#define     mhteStandard        0x001f0000  //  STANDARD_RIGHTS_ALL
#define     mhteSystem          0xff000000

#define     fhteStdRequire      0x000f0000  //  STANDARD_RIGHTS_REQUIRED
#define     fhteSynch           0x00100000  //  SYNCHRONIZE

//  Following specific rights are used by file/device object types.
#define     fhteDevShrRead      0x00000001
#define     fhteDevShrWrite	0x00000002
#define     fhteDevAccRead      0x00000020
#define     fhteDevAttrWrite    0x00000100  //  FILE_WRITE_ATTRIBUTES
#define     fhteDevAccWrite	0x00000110
#define     fhteDevAccAll	0x00000130
#define     fhteDevAccAny	0x00000000
#define     fhteDevOverlapped   0x00001000

#define     mhteDevAcc		0x00000130
#define     mhteDevShr          0x00000003

#define     flMaskAll		0xffffffff


//
// MapHandle argument values.
//
// Object type values.
//
#define typSemaphore	(1 << (typObjShiftAdjust + typObjSemaphore))
#define typEvent	(1 << (typObjShiftAdjust + typObjEvent))
#define typMutex	(1 << (typObjShiftAdjust + typObjMutex))
#define typCrst		(1 << (typObjShiftAdjust + typObjCrst))
#define typProcess	(1 << (typObjShiftAdjust + typObjProcess))
#define typThread	(1 << (typObjShiftAdjust + typObjThread))
#define typFile		(1 << (typObjShiftAdjust + typObjFile))
#define typChange	(1 << (typObjShiftAdjust + typObjChange))
#define	typIO		(1 << (typObjShiftAdjust + typObjIO))
#define typConsole	(1 << (typObjShiftAdjust + typObjConsole))
#define typConScreenbuf (1 << (typObjShiftAdjust + typObjConScreenbuf))
#define typMapFile	(1 << (typObjShiftAdjust + typObjMapFile))
#define typSerial	(1 << (typObjShiftAdjust + typObjSerial))
#define typDevIOCtl	(1 << (typObjShiftAdjust + typObjDevIOCtl))
#define typPipe		(1 << (typObjShiftAdjust + typObjPipe))
#define typMailslot	(1 << (typObjShiftAdjust + typObjMailslot))
#define typToolhelp	(1 << (typObjShiftAdjust + typObjToolhelp))
#define typSocket	(1 << (typObjShiftAdjust + typObjSocket))
#define typTimer	(1 << (typObjShiftAdjust + typObjTimer))
#define typR0ObjExt	(1 << (typObjShiftAdjust + typObjR0ObjExt))
#define typMsgIndicator ( 1<<(typObjShiftAdjust + typObjMsgIndicator))
#define typAny	    (~(0xffffffff << (1 + typObjShiftAdjust + typObjMaxValid)))
#define typNone		0
#define typMask		typAny
#define typSTDIN        (typFile | typPipe | typSocket | typConsole)
#define typSTDOUT       (typFile | typPipe | typSocket | typConScreenbuf)


//
// Boolean flag to MapHandle (snuck inside objType parameter) to prevent the
// object from being freed until UnlockObject() is called.
//
#define objLOCK		0x80000000


// Handles are derived by left-shifting ihte's by this many bits.
// This corresponds to the number of low bits reserved by NT.
#define IHTETOHANDLESHIFT 2


/* ------------------------------------------------------------ */
/*								*/
/* ------------------------------------------------------------ */

#define     chteInit    16
#define     chteInc	16

#define     ihteInvalid  0xFFFFFFFF
#define     ihteCurProc  0x7FFFFFFF
#define     ihteCurThread 0xFFFFFFFE
#define     hInvalid	 ((HANDLE)ihteInvalid)
#define     hCurProc	 ((HANDLE)ihteCurProc)
#define     hCurThread   ((HANDLE)ihteCurThread)


/* Maximum value for a normal handle (handles above this value
 * are either global or special.)
 */
#define     hMaxValid     0x00FFFFFF
#define     ihteMaxValid  (hMaxValid >> IHTETOHANDLESHIFT)


/* Making this non-zero will keep us from allocating handle 0 */
#define     ihteDosMax	1

typedef struct _hte {
    DWORD   flFlags;
    OBJ *   pobj;
} HTE;

typedef struct _htb {
    DWORD   chteMax;
    HTE     rghte[1];
} HTB;


// Handles are considered global if the high byte is equal to the high byte
//  of GLOBALHANDLEMASK.
//
// When handles are converted to ihtes, they are just right-shifted like
// any other. That is, if n == IHTETOHANDLESHIFT, global ihtes have 0's
// in the top n bits, the high byte of GLOBALHANDLEMASK in the next 8 bits.
// The low n bits of the mask must be zero because those bits are lost
// when handles are converted to ihtes.

#define GLOBALHANDLEMASK (0x453a4d3cLU)

// IHTEFROMHANDLEEX() uses a compare against a single watermark to
// distinguish special handle values from local and global handles.
// Thus, it's essential that global handles be numerically less
// than any special handle value.


/* ------------------------------------------------------------ */
/*		    Function Prototypes				*/
/* ------------------------------------------------------------ */

GLOBAL	HTB *	    KERNENTRY	PhtbCreate (PDB *);
GLOBAL	VOID	    KERNENTRY	PhtbDestroy(PDB *);
GLOBAL	DWORD	    KERNENTRY	FlFlagsFromHnd (PDB *, HANDLE);

GLOBAL	HANDLE	    KERNENTRY	AllocHandle(PDB *, OBJ *, DWORD);
GLOBAL	BOOL	    KERNENTRY	FreeHandle(PDB *, HANDLE);
GLOBAL	VOID *	    KERNENTRY	MapHandle(HANDLE, DWORD, DWORD);
GLOBAL	VOID *	    KERNENTRY	MapHandleWithContext(PPDB,HANDLE,DWORD,DWORD);
GLOBAL	HANDLE	    KERNENTRY	PreAllocHandle(PDB *);
GLOBAL	HANDLE	    KERNENTRY	SetPreAllocHandle(PDB *, HANDLE, OBJ *, DWORD);
GLOBAL	VOID	    KERNENTRY	FreePreAllocHandle(PDB *, HANDLE);
GLOBAL	VOID	    KERNENTRY	CloseProcessHandles (PDB *);
GLOBAL	VOID	    KERNENTRY	CloseDOSHandles (VOID);
GLOBAL	BOOL	    KERNENTRY	FInheritHandles (PDB *, PDB *);
GLOBAL	VOID	    KERNENTRY	CloseConsoleHandles (PDB *);
GLOBAL	DWORD	    KERNENTRY	FlValidateSecurity(SECURITY_ATTRIBUTES *);
GLOBAL	BOOL	    KERNENTRY	FGetDosHandles(PDB *);
GLOBAL	HANDLE	    KERNENTRY	SearchForHandle(PDB *, OBJ *, DWORD);
GLOBAL	HANDLE	    KERNENTRY	ConvertToGlobalHandle(HANDLE);

/* ------------------------------------------------------------ */

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\dxkrnl.h ===
/************************************************************************/
/*                                                                      */
/*	DXKRNL.H	--  Private Kernel Definitions                  */
/*                                                                      */
/************************************************************************/
/*	Author:     Gene Apperson					*/
/*	Copyright:  1991 Microsoft					*/
/************************************************************************/
/*  File Description:                                                   */
/*                                                                      */
/*  This header file contains private macro, data structure and 	*/
/*  procedure declarations for internal use by the kernel        	*/
/*                                                                      */
/************************************************************************/
/*  Revision History:                                                   */
/*                                                                      */
/*  04/02/91 (GeneA): created						*/
/*  2/12/93 (miketout): removed unnecessary EnterKrnlCritSect and	*/
/*		LeaveKrnlCritSect macros				*/
/*                                                                      */
/************************************************************************/

/* This is a special undocumented creation parameter bit that can
** be given to FNewProcess to create an asynchronous process.  Normally
** the thread calling FNewProcess will block until the child process
** terminates.
*/
#define fExecAsync	    0x80000000


/* The following define the return status codes for the various
** wait routines (e.g. IdWaitOnPsem, IdWaitOnPpdb, IdWaitOnPtdb,...)
*/

// This constant missing from NT's winbase.h
#define WAIT_ERROR   0xFFFFFFFFL

#define idWaitOK	0L
#define idWaitTimeout	WAIT_TIMEOUT
#define idWaitIOCompletion WAIT_IO_COMPLETION
#define idWaitAbandoned WAIT_ABANDONED
#define idWaitError	WAIT_ERROR
#define idWaitSuspended 0x40000001
#define	idWaitExit	0x0f01

/* Priority class constants to convert Win32's flags to base priority
** values
*/
#define IDLE_PRI_CLASS_BASE     4
#define NORMAL_PRI_CLASS_BASE   8
#define HIGH_PRI_CLASS_BASE     13
#define REALTIME_PRI_CLASS_BASE 24
#define REALTIME_PRI_MAX        31
#define REALTIME_PRI_MIN        16
#define NORMAL_PRI_MAX          15
#define NORMAL_PRI_MIN          1

/* Initialization phases
*/

#define	IC_BEGIN	0			// Initialization begun
#define	IC_KERNELPROC	(IC_BEGIN+1)		// Krnl process/thread exists
#define	IC_DONE		(IC_KERNELPROC+1)	// KernelInit() is complete

#ifndef WOW32_EXTENSIONS

extern	GLOBAL	BOOL	InitCompletion;

extern	GLOBAL	BOOL	fEmulate;		// TRUE=>use Win32 emulator
extern	GLOBAL	DSCR	dscrInvalid;		// 0 filled
extern	GLOBAL	TEMPSTACKINFO *pWin16TerminationStackInfo;

/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

GLOBAL	BOOL	KERNENTRY   FInstallInterrupts(VOID);
GLOBAL	BOOL	KERNENTRY   FUninstallInterrupts(VOID);
GLOBAL	LPSTR	KERNENTRY   HexToAscii(DWORD, LPSTR);
GLOBAL	VOID	KERNENTRY   Except7Handler(VOID);	    
GLOBAL	VOID	KERNENTRY   KSTerminateProcess(PDB *, DWORD);
GLOBAL	VOID	KERNENTRY   KSTerminateThread(TDB *, DWORD);
GLOBAL	VOID	KERNENTRY   KSTerminateProcessAPCHandler(PDB *);
GLOBAL	VOID	KERNENTRY   KSTerminateThreadAPCHandler(TDB *);

#endif  // ndef WOW32_EXTENSIONS

/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\heap32.inc ===
;/*

; Flags for Heap Header
L32F_NOHUSED    equ     1

; Heap signature
L32_SIGNATURE   equ     3233484Ch       ; 'LH32'

; Flags for Local32Init
LINIT_MAX16HEAP equ     1
LINIT_TILEHEAP  equ     2

; Flags for Local32Alloc
LMEM32_64K      equ     1
LMEM32_ZEROINIT equ     2

; Address types
NOHPTR16        equ     -2
NOHPTR32        equ     -1
HANDLE16        equ     0
PTR16           equ     1
PTR32           equ     2

; if address type is < MINHTYPE, there is no handle associated with address
MINHTYPE        equ     0

;-----------------------------------------------------------------------;
; Heap Header (lives at 64K-(SIZE L32HeapHeader))                    
;-----------------------------------------------------------------------;                     
L32HeapHeader   struc
FreeLists       dw      16 dup(?)   ; array of ptrs to free handles in each page
FreeCounts      dw      16 dup(?)   ; array of counts of free handles in each page
FreeTails       dw      16 dup(?)   ; array of ptrs to tail of free lists
dwSelTable      dd      ?           ; 32bit offset of handle->sel mapping table
wMaxBaseDelta   dw      ?           ; # of 64K blocks in heap * 8
wSelAdjust      dw      ?           ; (see L32FindHandleEntry, NOHPTR16 code)
dwBaseSel       dd      ?           ; base selector    
linBaseAddr     dd      ?           ; base linear address of heap
hCommit         dd      ?           ; highest committed handle
L32Flags        dd      ?           ; flags field (L32F_*)
L32Signature    dd      ?           ; heap signature (L32_SIGNATURE)
hHeap           dd      ?           ; handle to heap
L32HeapHeader   ends

L32HdrSize      equ     (size L32HeapHeader)

;Translation macro for fast handle->pointer conversion

.386p

EnumArgs macro  arglist,prefix
        argctr = 0
        for arg,<arglist>
                argctr = argctr + 1
                @CatStr(prefix,%argctr) TEXTEQU <arg>
        endm
        @CatStr(prefix,<Cnt>) = argctr

        endm

ProcessOptions  macro   optlist

        ; Initialize options to default values
        THOptFULL  = 0
        THOffset   = 10000h
        THForce32  = 0
        THNoValid  = 0

        irp     opt,<optlist>

                ifidni  <opt>,<FULL>
                        THOptFULL = 1
                endif

                ifidni  <opt>,<SEPARATE>
                        THOffset = 0
                endif

                ifidni  <opt>,<FORCE32>
                        THForce32 = 1
                endif

                ifidni  <opt>,<NOVALID>
                        THNoValid = 1
                endif
        endm

        THHdrPos = THOffset

        endm


InList  macro   reg,reglist

        ifnb <reglist>
                IsInList INSTR <reglist>,<reg>
                exitm %IsInList
        else
                exitm %0
        endif

        endm


ChooseSegReg    macro   wSel                
        PopDS=1
        ifidni  <wSel>,<0>
                sptr TEXTEQU <ds>
                PopDS=0
        else
                irp creg,<ds,es,fs,gs>
                ifidni <creg>,<wSel>
                        sptr TEXTEQU <wSel>
                        PopDS=0
                endif
                endm
        endif
        endm

UseSegReg       macro   wSel
                         
        if PopDS
                push ds
                mov ds,wSel

                sptr TEXTEQU <ds>
        endif

        ; Hack: We need to generate instructions like mov eax,[10000h]
        ;       and MASM won't generate a 32-bit offset unless the
        ;       segment is not assumed to be a 16-bit segment.  We only
        ;       need this for ds since we only generate these instructions
        ;       for merged segments.
        ifidni  sptr,<ds>
                assume ds:nothing 
        endif

        endm

RestoreSegReg   macro

        if PopDS
                pop ds
        endif

        ; See note in UseSegReg.
        ifidni  sptr,<ds>
                assumes ds,data
        endif

        endm
                              
ParseDestReg    macro   hMem

        ; Sigh.  elseif  InList(...) doesn't compile so
        ; NoDestReg is a workaround.  Somebody please
        ; get rid of it if they can figure out how!
        NoDestReg = 1
        if      InList(<hMem>,<ax,bx,cx,dx>)
                destreg32 TEXTEQU @CatStr(<e>, <hMem>)
                destreg16 TEXTEQU <hMem>
                destreg8  TEXTEQU @CatStr(@SubStr(<hMem>,1,1),<l>)
                NoDestReg = 0
        endif
        if      ((NoDestReg NE 0) AND (InList(<hMem>,<eax,ebx,ecx,edx>) NE 0))
                destreg32 TEXTEQU <hMem>
                destreg16 TEXTEQU @SubStr(<hMem>,2,2)
                destreg8  TEXTEQU @CatStr(@SubStr(<hMem>,2,1),<l>)
                NoDestReg = 0
        endif
        if      ((NoDestReg NE 0) AND (InList(<hMem>,<si,di,esi,edi>) NE 0))
                ; these regs only work if opts is blank
                destreg32 TEXTEQU <>
                destreg16 TEXTEQU <hMem>
                destreg8  TEXTEQU <>
                NoDestReg = 0
        endif
        if      NoDestReg
                destreg32 TEXTEQU <eax>
                destreg16 TEXTEQU <ax>
                destreg8  TEXTEQU <al>
                movzx     destreg32,hMem
        endif
        endm

; Table to determine if two registers overlap
??al  = 00000001b
??ah  = 00000001b
??ax  = 00000001b
??eax = 00000001b
??bl  = 00000010b
??bh  = 00000010b
??bx  = 00000010b
??ebx = 00000010b
??cl  = 00000100b
??ch  = 00000100b
??cx  = 00000100b
??ecx = 00000100b
??dl  = 00001000b
??dh  = 00001000b
??dx  = 00001000b
??edx = 00001000b
??si  = 00010000b
??esi = 00010000b
??di  = 00100000b
??edi = 00100000b

??Paste macro arg1:req, arg2:req
exitm <arg1&arg2>
endm

TranslateHandle macro   wSel,dwMem,wMemType,wRetType,reglist,dreg,opts
        local THErr
        local THOk
        local DestOk

        if (wMemType EQ HANDLE16)
                EnumArgs <dreg>,regs
                ProcessOptions <opts>
                 
                ; choose appropriate segment register based on wSel
                ChooseSegReg wSel

                ; choose appropriate destination register based on dreg
                if (regsCnt EQ 1)
                    destreg TEXTEQU <regs1>
                    ??destreg = ??Paste(??,%regs1)
                else
                    destreg TEXTEQU <eax>
                    ??destreg = ??eax
                endif

                ??dwMem = ??Paste(??,dwMem)

                ; if trivial conversion (HANDLE->HANDLE) do it & exit
                if (wRetType EQ HANDLE16)
                    mov destreg,dwMem
                    exitm
                endif

                ; if wSel isn't in segment register load it in ds
                UseSegReg wSel


                if THForce32
                    mov ecx, THHdrPos
                endif
                
                ;if full validation requested do it now
                if THOptFULL
                    ParseDestReg <dwMem>

                    test destreg8,3           ; make sure hMem % 4 == 0
                    jnz THErr

                    cmp destreg16,L32HdrSize
                    jb  THErr

                    if THForce32
                        cmp destreg16,word ptr sptr:[ecx].hCommit ; see if handle is below commit
                    else
                        cmp destreg16,word ptr sptr:[THHdrPos].hCommit ; see if handle is below commit
                    endif
                    ja THErr

                ifdifi destreg32,<bx>
                        movzx ebx,destreg16
                endif

                if THForce32
                    mov destreg,sptr:[ebx+ecx]  ; get 32bit offset in destreg
                else
                    mov destreg,sptr:[ebx+THOffset]  ; get 32bit offset in destreg
                endif

                cmp     destreg,10000h  ; see if its free
                jb      THErr

                else
                    ; fetch the address (assume dwMem is valid)

                    if THForce32
                        mov destreg,sptr:[dwMem+ecx]
                    else
                        mov destreg,sptr:[dwMem+THOffset]
                    endif

                endif

                ifdef DEBUG
                ife THNoValid
                        cmp     destreg,10000h  ; see if its free
                        jae     DestOk
                        int     3
                endif
                DestOk:
                endif



                ; if HANDLE16->PTR16 compute the selector
                if (wRetType EQ PTR16)

                    if InList(<bx>,<reglist>) OR InList(<ebx>,<reglist>)
                       push ebx
                    endif
                    if THForce32
                        mov ebx,sptr:[ecx].dwSelTable
                    else
                        mov ebx,sptr:[THHdrPos].dwSelTable
                    endif
                    
                    ; determine which registers to use...
                    if (regsCnt EQ 0)
                       ; eax,dx:ax = PTR16
                       mov edx,eax
                       shr edx,15
                       and ax,7fffh
                       mov dx,sptr:[ebx+edx*2]
                       rol eax,16
                       mov ax,dx
                       rol eax,16
                    elseif (regsCnt EQ 1)
                       ; regs1 = PTR16
                       destreg16 TEXTEQU @SubStr(dreg,2)

                       if InList(<dx>,<reglist>) OR InList(<edx>,<reglist>)
                          push edx
                       endif

                       mov edx,destreg
                       shr edx,15
                       and destreg16,7fffh
                       mov dx,sptr:[ebx+edx*2]
                       rol destreg,16
                       mov destreg16,dx
                       rol destreg,16

                       if InList(<dx>,<reglist>) OR InList(<edx>,<reglist>)
                          pop edx
                       endif

                    elseif (regsCnt EQ 2)
                       ; regs1:regs2 = PTR16
                       if InList(<dx>,<reglist>) OR InList(<edx>,<reglist>)
                          push edx
                       endif

                       mov edx,eax
                       shr edx,15
                       mov regs1,sptr:[ebx+edx*2]
                       ifdifi <ax>,regs2
                          mov regs2,ax
                       endif
                       and regs2,7fffh

                       if InList(<dx>,<reglist>) OR InList(<edx>,<reglist>)
                          pop edx
                       endif

                    else
                       .err Too many destination regs passed to TranslateHandle
                    endif

                    if InList(<bx>,<reglist>) OR InList(<ebx>,<reglist>)
                       pop ebx
                    endif
                endif

                if THOptFULL
                jmp     THOk
THErr:
                ; determine which registers to use...
                if (regsCnt EQ 0)
                   ; eax,dx:ax = PTR16
                   xor  eax,eax
                   xor  edx,edx
                elseif (regsCnt EQ 1)
                   ; regs1 = PTR16
                   xor  regs1,regs1
                elseif (regsCnt EQ 2)
                   ; regs1:regs2 = PTR16
                   xor  regs2,regs2
                   mov  regs1,regs2
                else
                   .err Too many destination regs passed to TranslateHandle
                endif
                
THOk:
                endif

                ; if wSel wasn't in segment register restore ds
                RestoreSegReg 
        elseif ((wMemType EQ PTR32) AND (wRetType EQ PTR16))

                ; input: eax = 32-bit offset
                ; output: eax = 16:16 ptr (ebx,ecx,edx trashed)
                                               
                mov     ebx,THHdrPos
                
                mov     edx,eax
                shr     edx,15
                mov     ecx,sptr:[ebx].dwSelTable
                and     eax,7fffh
                rol     eax,16
                mov     ax,sptr:[ecx+edx*2]
                rol     eax,16
                
        else
        
                ifnb    <reglist>
                        Save    <reglist>
                endif
                int 3
                cCall   Local32Translate,<wSel,dwMem,wMemType,wRetType>
                ifnb    <dreg>
                mov     dreg,eax
                endif
        endif
        endm

;Validation macro for fast 32bit handle validation


ValidHandle32   macro   wSel,hMem,opts
        local   VH32_Err 
        local   VH32_End

        ifb     <opts>
                test    hMem,2          ; ZF=0 => 32-bit, ZF=1 => 16-bit
        else
                ParseDestReg <hMem>
                ProcessOptions <opts>
                ChooseSegReg wSel

                UseSegReg wSel


                if THForce32
                    mov ecx, THHdrPos
                endif
                
                test    destreg8,3      ; make sure hMem % 4 = 0
                jnz     VH32_Err        ; if not we know it isn't valid

                cmp     destreg16,L32HdrSize ; see if handle points in header
                jb      VH32_Err        ;

                if THForce32
                    cmp     destreg32,sptr:[ecx].hCommit ; see if handle is
                else
                    cmp     destreg32,sptr:[THHdrPos].hCommit ; see if handle is
                endif
                                                ; below commit line

                ja     VH32_Err

                if THForce32
                    mov     destreg32,sptr:[destreg32+ecx]
                else
                    mov     destreg32,sptr:[destreg32+THHdrPos]
                endif
                cmp     destreg32,10000h        ; see if its free
                jae     VH32_End                ; if not we're happy

VH32_Err:

                xor     ax,ax                   ; set zero flag

VH32_End:                

                RestoreSegReg
        endif
        
;        cCall   Local32ValidHandle,<wSel,hMem>
        endm


ifndef ?INHEAP32
.286p
externFP Local32Init
externFP Local32Alloc
externFP Local32ReAlloc
externFP Local32Size
externFP Local32Translate
externFP Local32ValidHandle
externFP Local32Free
externFP Local32GetSel
endif

        if 0
;*/

/* Flags for Local32Init */
#define LINIT_MAX16HEAP         1 
#define LINIT_TILEHEAP          2
#define LINIT_EMS16HEAP         4

/* Flags for Local32Alloc */
#define LMEM32_64K      1
#define LMEM32_ZEROINIT 2

/* Address types */
#define NOHPTR16        (WORD) (-2)
#define NOHPTR32        (WORD) (-1)
#define HANDLE16        0
#define PTR16           1
#define PTR32           2

DWORD FAR PASCAL Local32Init(WORD wSel, DWORD dwcbInit, DWORD dwcbMax, DWORD dwFlags);
DWORD FAR PASCAL Local32Alloc(DWORD linHdr, DWORD dwcbRequest, WORD wType, DWORD dwFlags);
DWORD FAR PASCAL Local32ReAlloc(DWORD linHdr, DWORD dwMem, WORD wType, DWORD dwcbNew, DWORD dwFlags);
DWORD FAR PASCAL Local32Size(DWORD linHdr, DWORD dwMem, WORD wType);
DWORD FAR PASCAL Local32Translate(DWORD linHdr, DWORD dwMem, WORD wMemType,
                                  WORD wRetType);
BOOL FAR PASCAL Local32ValidHandle(DWORD linHdr, HANDLE hMem);                                  
BOOL FAR PASCAL Local32Free(DWORD linHdr, DWORD dwMem, WORD wMemType);
WORD FAR PASCAL Local32GetSel(DWORD linHdr);

#define TranslateHandle(a,b,c,d) Local32Translate((a),(b),(c),(d))

#ifndef _flat
#define _flat __based32(__segname("_DATA"))
#endif

#define HTOFLAT(p,h)                                        \
    {                                                       \
       DWORD _flat* _tp_ = (DWORD _flat*)((h)+0x10000);     \
       (p) = ((void _flat*)*_tp_);                          \
    }

;/*
        endif
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\debugsys.h ===
/*****************************************************************************

   (C) Copyright MICROSOFT Corp., 1988-1992

   Title:      DEBUGSYS.INC - VMM debugging include file

   Version:    1.00

   Date:       13-Jun-1988

   Author:     RAL

------------------------------------------------------------------------------

   Change log:

      DATE     REV                 DESCRIPTION
   ----------- --- -----------------------------------------------------------
   13-Jun-1988 RAL
   24-Oct-1988 RAP changed INT from 2E to 41, and added functions for
                   Windows to notify the debugger about segment selectors
   14-Dec-1988 RAP split services into ones available through INT 41h
                   for non-ring 0 clients and those available through INT 21h
                   for ring 0 clients
   11-Dec-1990 ERH Merged WIN386 copy with file actually used by the
                   debugger.
   11-Dec-1990 ERH Merged file describing real mode services with this
                   one.
   24-Feb-1997 AJO Converted from inc to h, added WDeb98 stuff, PTrace stuff

==============================================================================*/

#ifndef _DEBUGSYS_H
#define _DEBUGSYS_H

/*
 * Note: You must define WDEB98 to use any of the new WDEB98 services...
 *
 */

/******************************************************************************

  Real mode Debugger services:

*/

// hooked by the debugger in real mode.
#define D386_RM_Int             0x68

// debugger identification code
#define D386_Id                 0x0F386

// minimum INT 68 function code
#define D386_MIN                0x43

// returns debugger identification, if debugger loaded
#define D386_Identify           0x43

// partially prepare for protected mode operation.
#define D386_Prepare_PMode      0x44
/*
   A pointer to a procedure is returned so that the IDT can also be set in
   protected mode

   INPUT:
     AL    0  - retail version of Win386
           1  - debugging version
     BX    a valid selector that gives access to all of memory
     CX    first of 2 selectors reserved for WDeb386 to use
     DX    is GDT selector
     DS:SI pointer to working copy of GDT
     ES:DI pointer to working copy of IDT

   RETURN:
     ES:EDI points to a protected mode procedure (selector:offset32) that can
     be called to set the IDT when it has been created. Takes a function
     number in AL. See the PMINIT equates.
*/


// re-init from real mode after entering pmode
#define D386_Real_Mode_Init     0x45

// set debugging switches
#define D386_Set_Switches       0x46
/*
   BL = verbose switch
        - 00b - no segment display
        - 01b - display win386 segments only
        - 10b - display ring 1 segments only
        - 11b - display win386 & ring 1 segs
   BH = conditional brkpts
        0 - off
        1 - on
   -1 for BX means no change (default)
*/

// execute conditional BP (/B option)
#define D386_Execute_Cond       0x47
// ES:SI points to NUL terminated string to print if conditional flag set.

// undefine the real mode segment's symbols
#define D386_Free_Segment       0x48
// BX = real mode segment to undefined

// set com port baud rate
#define D386_Set_Baudrate       0x49
// BX = baud rate

// reinitialize debugger for protected mode
#define D386_Reinit             0x4a
/*
   AL  0  - retail version of Win386
       1  - debugging version of Win386
       2  - 286 DOS extender (3.0)
       3  - 286 DOS extender under VCPI (3.1)
       4  - 286 DOS extender (3.1)
   BX  a valid selector that gives access to all of memory
   CX  first of 2 selectors reserved for wdeb386 to use
   DX  is GDT selector

  This function can after a function 45h only if function 44h was executed in
  the past on the IDT/GDT.
*/

// define debugger's segments
#define D386_Def_Deb_Segs       0x4b

// set com port number
#define D386_Set_Com_Port       0x4c
// BX = com port number
// returns AX != 0, error bad com port

// link sym file map
#define D386_Link_Sym           0x4d
/*

   ES:DI pointer to AddrS struc in front of sym file map.
   BX    loader ID (used to unlink sym file maps)
         A loader ID of 0 is used for all the maps
         wdeb386 loads via /S is ran as a program and
         -1 is used by the device driver version.  All
         loader IDs of 0 are automaticly unlinked when
         wdeb386 exits.
*/




// unlink sym file maps
#define D386_Unlink_Sym         0x4e
/*
   BX = loader ID - this routine looks at all
        of the maps that are currently linked and
        removes the ones that were loaded with this
        ID.
*/




// remove any undefined segments from the name module's symbols
#define D386_Remove_Segs        0x4f
// ES:DI pointer to module name




// defines the actual segment/selector for a loaded segment to allow for
// symbol processing
#define D386_Load_Segment       0x50
/*
   INPUT:
     AL segment type   0  - code selector
                       1  - data selector
                      10h - code segment
                      11h - data segment
                      20h - real-mode EXE
                      40h - code segment & sel
                      41h - data segment & sel
                      80h - device driver code seg
                      81h - device driver data seg
     If AL = 20h then
        CX = paragraph number
        ES:DI pointer to module name
     Else If AL < 80h then
        BX segment #
        CX actual segment/selector
        DX actual selector  (if 40h or 41h)
        ES:DI pointer to module name
     Else
        ES:DI points to D386_Device_Params struc

     RETURN:
       AL = 1, if successful, else 0
*/





// display a character to the debugging terminal
#define D386_Display_Char       0x51
// AL = char to display



// display a string to the debugging terminal
#define D386_Display_Str        0x52
// ES:SI points to NUL terminated string



// returns if debug VxD has been installed
#define D386_IsVxDInstalled     0x53
// AL == 0 if not install, AL != 0 if installed



// sets that the debug VxD installed/uninstalled
#define D386_VxDInstall         0x54
// BL == 0 if uninstall, BL != 0 if installed



// registers dot command
#define D386_RegisterDotCmd     0x55
/*
   INPUTS
     BL    = command letter
     CX:SI = address of dot command routine
     DX:DI = address of help text

   RETURNS
     AX == 0, no errors
     AX != 0, dot command already used or out of dot commands

   Dot command routine:
   -------------------
   CALLED WITH
     AL    = command character
     DS:SI = linear address of command line terminated by a NULL or ";".
     DS,ES = debugger's data selector

   RETURNS
     AX ==0, no errors
     AX !=0, command line or option error
*/




// de-registers dot command
#define D386_DeRegisterDotCmd   0x56
// BL = command letter




// Printf
#define D386_Printf             0x57
/*
   (DS:SI) = address of format string
   (ES:DI) = address of the start of parameters
   set DS_Printf for format char information
   returns (AX) = number of characters printed
*/



// link symbol file with physical address
#define D386_Link_Sym_Phys      0x58
/*
   (DX:CX) = physical address of one extra
             paragraph front of map file image.
   (SI)    = XMS handle (0 if just physical)
   (BX)    = load id
*/




#define D386_CheckMap           0x59
/*
   DX:DI = pointer to module name
   returns AX != 0, map found
           AX == 0, map not found
*/



#define D386_SetAutoLoadSym     0x5a
/*
   (BL) != 0, auto load symbols
   (BL) == 0, don't auto load symbols
*/



#define D386_SetTeftiPort       0x5b
// (BX) = TEFTI port address



// execute debugger command script
#define D386_ExecDebugCommand   0x5c
/*
   (DS:SI) = ptr to debugger command script str
   (CX) = size of script
*/



// makes the debugger copy its code/data high
#define D386_LoadCodeDataHigh   0x5d
// (DX:BX) = physical address to put debugger



// sets Windows version number
#define D386_SetWinVersion      0x5e
// (DI) = Version number (default if this api not called is 0300h).


// scan for character
#define D386_ScanChar           0x5f
// returns AL == 0, no char. AL != 0, char



// ungetchar scaned character
#define D386_UnGetChar          0x60
// AL = char


// stop at the CS:IP specified
#define D386_Stop               0x61
/*
   TOS + 0 = AX
   TOS + 2 = IP
   TOS + 4 = CS
*/

#ifdef WDEB98

// set com port baud rate (beyond 57600)
#define D386_Set_Baudrate_Ex    0x62
// EBX = baud rate, EBX is zero if successful

// programs wdeb with windows info
#define D386_SetBuildInfo       0x63
// DS:EDX points to string of from "4.00.0950" or similar.

// Sets new switches for WDEB
#define D386_Set_Switches_Ex    0x64
// EBX [0:1] controls text packet usage:
//           00 - No change
//           01 - Off
//           10 - On with timeouts (switchbox environment)
//           11 - On with infinite retries
//
// All other bits in EBX are reserved and must be zero.
//


#define D386_MAX                0x64 // maximum INT 68 function code

#else  // WDEB98

#define D386_MAX                0x61 // maximum INT 68 function code

#endif // WDEB98



// D386_Load_Segment type ates:

#define ST_code_sel     0x0           // code selector
#define ST_data_sel     0x1           // data selector
#define ST_code_seg     0x10          // code segment
#define ST_data_seg     0x11          // data segment
#define ST_dual_code    0x40          // code segment and selector
#define ST_dual_data    0x41          // data segment and selector
#define ST_device_code  0x80          // device driver code segment
#define ST_device_data  0x81          // device driver data segment

// D386_Load_Segment device load parameters structure
// Don't let h2inc see FWORD as it doesn't understand FWORD, QWORD, & TWORD

/*XLATOFF*/
struct D386_Device_Params {
   WORD  DD_logical_seg  ;   // logical segment # from map
   WORD  DD_actual_sel   ;   // actual selector value
   DWORD DD_base         ;   // linear address offset for start of segment
   DWORD DD_length       ;   // actual length of segment
   FWORD DD_name         ;   // 16:32 ptr to null terminated device name
   FWORD DD_sym_name     ;   // 16:32 ptr to null terminated symbolic
                             //   module name (i.e. Win386)
   WORD  DD_alias_sel    ;   // alias selector value (0 = none)
  } ;

/*XLATON*/

/* ASM
D386_Device_Params      STRUC
DD_logical_seg          DW      ?
DD_actual_sel           DW      ?
DD_base                 DD      ?
DD_length               DD      ?
DD_name                 DF      ?
DD_sym_name             DF      ?
DD_alias_sel            DW      ?
D386_Device_Params      ENDS
*/

// WDEB int 2f subfunctions (AH = W386_INT_MULTIPLEX, AL = W386_WDEB)
// Entry: BX = subfunction number

#define WDEB_INT2F_STARTING             0x0       // first time starting
#define WDEB_INT2F_ENDING               0x1       // first time ending
#define WDEB_INT2F_NESTED_STARTING      0x2       // start on level of nesting
#define WDEB_INT2F_NESTED_ENDING        0x3       // end one level of nesting

// PMINIT routine functions

#define PMINIT_INIT_IDT                 0x0     // (ES:EDI) = pointer to PM IDT

#define PMINIT_INIT_PAGING              0x1     // (BX) = phys-linear selector
                                                // (ECX) = phys-linear bias

#define PMINIT_ENABLE_DEBUG_QUERYS      0x2     // enables dot commands, etc.

#define PMINIT_INIT_SPARE_PTE           0x3     // (EBX) = lin addr of spare PTE
                                                // (EDX) = lin addr the PTE is

#define PMINIT_SET_ENTER_EXIT_VMM       0x4     // (EBX) = Enter VMM routine addr
                                                // (ECX) = Exit VMM routine addr
                                                // This routines must return
                                                // with a retfd.

#define PMINIT_GET_SIZE_PHYS            0x5     // get debugger size/phys addr
                                                // returns:
                                                //    AL = 0 (don't call AL=1)
                                                //    ECX = size in bytes
                                                //    ESI = starting phys addr
                                                // if this call is ignored
                                                // (AL = 5) then function 1 is
                                                // called with a phys-linear
                                                // region

#define PMINIT_SET_BASE_SPARE_PTE       0x6     // set debugger base/spare PTE
                                                // EBX = laddr of spare PTE
                                                // EDX = laddr the PTE represents
                                                // ESI = starting linear address

#define PMINIT_ENABLE_MEMORY_CONTEXT    0x7     // enables mem context functions

#define PMINIT_MAX                      0x7

/*
   VCPI information, passed to debugger when client is DOS Extender
   running as a VCPI client.  This information is used to get into
   and out of protected mode when running under a VCPI server.


   This structure is also used by the DOS Extender.
*/

// Don't let h2inc see FWORD as it doesn't understand FWORD, QWORD, & TWORD

/*XLATOFF*/
struct WdebVCPIInfo {
   // Enter protected mode information.
   FWORD fnVCPI     ; // VCPI protect mode server entry point
   WORD  rdsVCPI    ; // Selector for VCPI server

   // Enter v86 mode information.
   DWORD laVTP      ; // linear address of data structure containing
                      // values for system registers.
   WORD  Port67     ; // Qualitas magic port for emulating INT 67h
  } ;
/*XLATON*/

/* ASM
WdebVCPIInfo    STRUC
fnVCPI  DF      ?
rdsVCPI DW      ?
laVTP   DD      ?
Port67  DW      ?
WdebVCPIInfo    ENDS
*/


/*
   The following structure contains the system register contents for the
   VCPI server to use when switching to protected mode.  It is taken
   from dxvcpi.inc in the DOSX project, and is part of the VCPI spec.
*/

struct VTP {
   DWORD zaCr3VTP        ; // physical addr of page directory
   DWORD laGdtrVTP       ; // linear addr in first meg of gdtr
   DWORD laIdtrVTP       ; // linear addr in first meg of idtr
   WORD  selLdtVTP       ; // selector of ldt
   WORD  selTrVTP        ; // selector of tr
   WORD  ipVTP           ; // 48-bit address of protect
   WORD  unusedVTP       ; //   mode entry point to xfer to
   WORD  csVTP           ; //
  } ;

#define VCPI_RM_CALLOUT_INT     0x67    // v86 mode call to VCPI server


/*
   Send this value in AX to the VCPI server to request V86 to protected
   mode switch or protected to V86 mode switch.
*/
#define VCPI_PROT_ENTRY         0x0DE0C


/*****************************************************************************

   Protected mode Debugger services:

*/


#define Debug_Serv_Int   0x41 // Interrupt that calls Deb386 to perform
                              // debugging I/O, AX selects the function as
                              // described by the following equates

#define DS_Out_Char      0x0  // function to display the char in DL

#define DS_In_Char       0x1  // function to read a char into AL

#define DS_Out_Str       0x2  // function to display a NUL terminated string
                              // pointed to by DS:ESI

#define DS_Is_Char       0x3  // Non blocking In_Chr

#define DS_Out_Str16     0x12 // function to display a NUL terminated string
                              // pointed to by DS:SI
                              // (same as function 2, but for 16 bit callers)

#define DS_ForcedGO16    0x40 // enter the debugger and perform the equivalent
                              // of a GO command to force a stop at the
                              // specified CS:IP
                              // CX is the desired CS
                              // BX is the desired IP

#define DS_LinkMap       0x45 // DX:(E)DI = ptr to paragraph in front of map

#define DS_UnlinkMap     0x46 // DX:(E)DI = ptr to paragraph in front of map

#define DS_CheckMap      0x47 // DX:(E)DI = pointer to module name
                              // returns AX != 0, map found
                              //         AX == 0, map not found

#define DS_IsAutoLoadSym 0x48 // returns AX != 0, auto load symbols
                              //         AX == 0, don't auto load symbols

#define DS_DebLoaded     0x4F // check to see if the debugger is installed and
                              // knows how to deal with protected mode programs
                              // return AX = F386h, if true

#define DS_DebPresent    0x0F386

#define DS_LoadSeg       0x50 // define a segment value for the
                              //  debugger's symbol handling
                              //  SI type   0  - code selector
                              //            1  - data selector
                              //           80h - code segment
                              //           81h - data segment
                              //  BX segment #
                              //  CX actual segment/selector
                              //  DX data instance
                              //  ES:(E)DI pointer to module name
                              // [PTrace]

#define DS_LoadSeg_32    0x0150 // Define a 32-bit segment for Windows 32
                                //  SI type   0  - code selector
                                //            1  - data selector
                                //  DX:EBX points to a D386_Device_Params STRUC
                                //  with all the necessaries in it

#define DS_MoveSeg       0x51   // notify the debugger that a segment has moved
                                // BX old segment value
                                // CX new segment value
                                // [PTrace]

#define DS_FreeSeg       0x52   // notify the debugger that a segment has been
                                // freed
                                // BX segment value
                                // [PTrace]

#define DS_FreeSeg_32    0x0152 // notify the debugger that a segment has been
                                // freed
                                // BX segment number
                                // DX:EDI pointer to module name

#define DS_DGH           0x56   // register "dump global heap" handler
                                // BX is code offset
                                // CX is code segment
                                // [PTrace]

#define DS_DFL           0x57   // register "dump free list" handler
                                // BX is code offset
                                // CX is code segment
                                // [PTrace]

#define DS_DLL           0x58   // register "dump LRU list" handler
                                // BX is code offset
                                // CX is code segment
                                // [PTrace]

#define DS_StartTask     0x59   // notify debugger that a new task is starting
                                // BX is task handle
                                // task's initial registers are stored on the
                                // stack:
                                //       push    cs
                                //       push    ip
                                //       pusha
                                //       push    ds
                                //       push    es
                                //       push    ss
                                //       push    sp
                                // [PTrace]

#define DS_Kernel_Vars   0x5a   // Used by the Windows kernel to tell the
                                // debugger the location of kernel variables
                                // used in the heap dump commands.
                                // BX = version number of this data (03a0h)
                                // DX:CX points to:
                                //      WORD     hGlobalHeap    ****
                                //      WORD     pGlobalHeap    ****
                                //      WORD     hExeHead       ****
                                //      WORD     hExeSweep
                                //      WORD     topPDB
                                //      WORD     headPDB
                                //      WORD     topsizePDB
                                //      WORD     headTDB        ****
                                //      WORD     curTDB         ****
                                //      WORD     loadTDB
                                //      WORD     LockTDB
                                //      WORD     SelTableLen    ****
                                //      DWORD    SelTableStart  ****
                                //
                                // The starred fields are used by the
                                // heap dump commands which are internal
                                // to WDEB386.


#define DS_VCPI_Notify   0x5b   // notify debugger that DOS extender is
                                // running under a VCPI implementation,
                                // and register VCPI protect mode interface
                                // ES:DI points to a data structure used to
                                // get from V86 mode to Pmode under VCPI.
                                // This is defined in the VCPI version
                                // 1.0 spec.

#define DS_ReleaseSeg    0x5c   // This does the same as a DS_FreeSeg, but
                                // it restores any breakpoints first.
                                // [PTrace]

#define DS_User_Vars     0x5d   // DS:SI = pointer to an array of offsets:
                                // BX = windows version
                                // CX = number of words in array
                                //      WORD = fDebugUser (1 = DEBUG, 0 = RETAIL)
                                //      WORD = 16 bit offset to hHmenuSel
                                //      WORD = 16 bit offset to hHwndSel
                                //      WORD = 16 bit offset to pclsList
                                //      WORD = 16 bit offset to pdceFirst
                                //      WORD = 16 bit offset to hwndDesktop
                                // This array MUST BE COPIED it goes away
                                // when we return from this service.

#define DS_POSTLOAD      0x60   // Used by the RegisterPTrace interface
#define DS_EXITCALL      0x62   // Somebody will fill these in if we ever
#define DS_INT2          0x63   // figure out what they are supposed to do.
#define DS_LOADDLL       0x64
#define DS_DELMODULE     0x65
#define DS_LOGERROR      0x66   // CX==error code, dx:bx = ptr to optional info
#define DS_LOGPARAMERROR 0x67   // ES:BX = ptr to struct { err, lpfn, param } ;

#define DS_RIN           0x09
#define DS_BANKLINE      0x0A
#define DS_NEWTASK       0x0B
#define DS_FLUSHTASK     0x0C
#define DS_SWITCHOUT     0x0D
#define DS_SWITCHIN      0x0E
//#define DS_KEYBOARD      0x0F   // Conflicts with DS_Out_Symbol

#define DS_IntRings      0x20   // function to tell debugger which INT 1's & 3's
                                // to grab
                                // BX == 0, grab only ring 0 ints
                                // BX != 0, grab all ints

#define DS_IncludeSegs   0x21   // function to tell debugger to go ahead and
                                // process INT 1's & 3's which occur in this
                                // DX:DI points to list of selectors
                                //   (1 word per entry)
                                // CX = # of selectors (maximum of 20)
                                // CX = 0, to remove the list of segs
#define MaxDebugSegs    20

#define DS_CondBP       0x0F001 // conditional break pt, if the command line
                                // switch /B is given when the debugger is run
                                // or the conditional flag is later set, then
                                // this int should cause the program to break
                                // into the debugger, else this int should be
                                // ignored!
                                // ESI points to a nul terminated string to
                                // display if break is to happen.

#define DS_ForcedBP     0x0F002 // break pt, which accomplishes the same thing
                                // as an INT 1 or an INT 3, but is a break point
                                // that should be permanently left in the code,
                                // so that a random search of source code would
                                // not result in the accidental removal of this
                                // necessary break_pt

#define DS_ForcedGO     0x0F003 // enter the debugger and perform the equivalent
                                // of a GO command to force a stop at the
                                // specified CS:EIP
                                // CX is the desired CS
                                // EBX is the desired EIP

#define DS_HardINT1     0x0F004 // check to see if INT 1 hooked for all rings
                                // ENTER: nothing
                                // EXIT: AX = 0, if no, 1, if yes

#define DS_Out_Symbol   0x0F    // find the symbol nearest to the address in
                                // CX:EBX and display the result in the format
                                // symbol name <+offset>
                                // the offset is only included if needed, and
                                // no CR&LF is displayed

#define DS_Disasm_Ins   0x10    // function to disassemble the instruction
                                // pointed to by DS:ESI

#define DS_JumpTableStart      0x70

/***     DS_RegisterDotCommand

       This interface is used to register wdeb386 dot commands by FLAT 32
       bit code.  The following conditions apply:

       * The code will be run at ring 0
       * Interrupts may be enabled
       * Must not access any invalid pages or load invalid selectors
       * Must stay on the stack called with when calling INT 41 services
       * Must not change DS or ES from the FLAT selector

       The help text is printed when .? is executed in the order of
       registration.  The text must include CR/LF at the end; nothing
       is added to the help text.

       ENTRY:  (AX) = 0070h
               (BL) = dot command to register
               (ESI) = linear address of dot command routine
                   Dot command routine:
                       ENTRY:  (AL) = command character
                               (DS, ES) = flat data selector

                       EXIT:   (AX) == 0, no errors
                               (AX) != 0, command line or option error

                       NOTE:   MUST return with a 32 bit FAR return (retfd)
               (EDI) = linear address of help text

       EXIT:   (AX) == 0, no errors
               (AX) != 0, dot command already used or out of dot commands
*/

#define DS_RegisterDotCommand      0x70

/***     DS_RegisterDotCommand16

       This interface is used to register wdeb386 dot commands by 16 bit
       code.  The following conditions apply:

       * The code will be run at ring 0 or in real mode
       * Interrupts may not be enabled
       * Must not access any not present pages or load invalid selectors
       * Must stay on the stack called with when calling INT 41 services

       The help text is printed when .? is executed in the order of
       registration.  The text must include CR/LF at the end; nothing
       is added to the help text.

       ENTRY:  (AX) = 0071h
               (BL) = dot command to register
               (CX:SI) = address of dot command routine
                   Dot command routine:
                       ENTRY:  (AL) = command character
                               (DS, ES) = debugger's data selector

                       EXIT:   (AX) == 0, no errors
                               (AX) != 0, command line or option error

                       NOTE:   MUST return with a 16 bit FAR return (retf)
               (DX:DI) = address of help text

       EXIT:   (AX) == 0, no errors
               (AX) != 0, dot command already used or out of dot commands
*/

#define DS_RegisterDotCommand16         0x71

/***     DS_DeRegisterDotCommand

       This interface is used to de-register wdeb386 dot commands registered
       by the above 16 or 32 bit services.  Care should be used not to
       de-register dot commands that weren't registered by your code.

       ENTRY:  (AX) = 0072h
               (BL) = dot command to de-register

       EXIT:   NONE
*/

#define DS_DeRegisterDotCommand         0x72

/***     DS_Printf

       This function allows formatted output with the standard "C"
       printf syntax.

       ENTRY:  (AX) = 0073h
               (DS:ESI) = address of format string
               (ES:EDI) = address of the start of the dword arguments

       EXIT:   (EAX) = number of characters printed

       Supported types are:

       %%                                                      %
       %[l][h]c                                                character
       %[-][+][ ][0][width][.precision][l|h|p|n]d              decimal
       %[-][0][width][.precision][l|h|p|n]u                    unsigned decimal
       %[-][#][0][width][.precision][l|h|p|n]x                 hex
       %[-][#][0][width][.precision][l|h|p|n]X                 hex
       %[-][0][width][.precision][l|h|p|n]o                    octal
       %[-][0][width][.precision][l|h|p|n]b                    binary
       %[-][width][.precision][l|h|a|F|R|P]s                   string
       %[-][width][.precision][l|h|a|p|n|F|L|R|L|H|N|Z]A       address
       %[-][width][.precision][l|h|a|p|n|F|L|R|L|H|N|Z]S       symbol
       %[-][width][.precision][l|h|a|p|n|F|L|R|L|H|N|Z]G       group:symbol
       %[-][width][.precision][l|h|a|p|n|F|L|R|L|H|N|Z]M       map:group:symbol
       %[-][width][.precision][l|h|a|p|n|F|L|R|L|H|N|Z]g       group
       %[-][width][.precision][l|h|a|p|n|F|L|R|L|H|N|Z]m       map

       Where "width" or "precision" is a decimal number or the '*'
       character; '*' causes the field width or precision to be picked
       up from the next parameter. []'ed parameters are optional.


       "\r", "\t", "\n", "\a", "\b", are supported directly.

       Prefixes
       --------

       Used with c,d,u,x,X,o,b:

       Parameter Argument Size
       -----------------------
       word                                    h
       dword                                   l

       Used with s,A,S,G,M,g,m:

       Address Argument Size
       ---------------------
       16 bit DS relative                      h
       16:16 segment:offset                    hF or Fh
       32 bit flat relative                    l
       16:32 segment:offset (2 dwords)         lF or Fl
       pointer to AddrS structure              a
       segment is a real mode segment          R
       segment is a protected mode selector    P

       Default segment type is the current code type.

       Used with A,S,G,M,g,m:

       Address Display Size or Format
       ------------------------------
       16 bit offset                           H
       32 bit offset                           L
       offset only                             N
       no address                              Z

       Default display size depends on the "386env" flag setting.

       Used with S,G,M,g,m:

       gets the previous symbol                p
       gets the next symbol                    n

       Used with A:

       gets the previous symbol address        p
       gets the next symbol address            n

       Used with d,u,x,X,o,b:

       gets the previous symbol offset         p
       gets the next symbol offset             n
*/

#define DS_Printf               0x73

/***     DS_Printf16

       This function allows formatted output with the standard "C"
       printf syntax.

       ENTRY:  (AX) = 0074h
               (DS:SI) = address of format string
               (ES:DI) = address of the start of the word or dword arguments

       EXIT:   (AX) = number of characters printed

       The format options and parameters are the same as DS_Printf except
       the default parameter size is a word (the h option is implicit).
*/

#define DS_Printf16             0x74

/***     DS_GetRegisterSet

       This function copies the current register set.

       ENTRY:  (AX) = 0075h
               (DS:ESI) = address of SaveRegs_Struc structure

       EXIT:   NONE
*/

#define DS_GetRegisterSet       0x75

/***     DS_SetAlternateRegisterSet

       This function temporary sets the debugger's registers to values
       passed in the structure.  If an "r" command is executed or the
       debugged code is returned to (via the "g", "t" or "p" commands),
       the register set reverts to the debugged code's registers.

       ENTRY:  (AX) = 0076h
               (CX) = thread ID, 0 use current thread ID
               (DS:ESI) = address of SaveRegs_Struc structure

       EXIT:   NONE
*/

#define DS_SetAlternateRegisterSet 0x76

/***     DS_GetCommandLineChar

       This services gets the next character off the command line.

       ENTRY:  (AX) = 0077h
               (BL) = 0 just peek the character, don't increment text pointer
                        leading white space isn't ignored
               (BL) = 1 get the character, increment text pointer
                        leading white space is skipped
               (BL) = 2 peek the character, don't increment text pointer
                        leading white space is skipped

       EXIT:   (AL) = command line character
               (AH) == 0 if no more characters (EOL)
               (AH) != 0 if more characters
*/

#define DS_GetCommandLineChar   0x77

/***     DS_EvaluateExpression

       Expressions can be numbers of various radices, symbols, addresses
       or an combination of the above hooked together with various
       operators.  Expressions are separated by blanks or commas.  This
       function is passed a pointer to the beginning of the text of the
       expression (i.e. "%80003444+4232").  The expression is either
       evaluated down into a dword value if there are no addresses or
       into a linear address.

       ENTRY:  (AX) = 0078h

       EXIT:   (AX) == 0, returning a data value
               (AX) != 0, returning a linear address
               (CX) = thread id
               (EBX) = return value

       NOTE:   If the expression is invalid, this service will not
               return.  A message is printed and control returns to
               the command loop.
*/

#define DS_EvaluateExpression   0x78

/***     DS_VerifyMemory

       ENTRY:  (AX) = 0079h
               (ECX) = length of memory region
               (DS:ESI) = address of memory to verify

       EXIT:   (AX) == 0, no errors
               (AX) != 0, invalid memory
*/

#define DS_VerifyMemory         0x79

/***     DS_PrintRegisters

       This function prints (just like the "r" command) the either the
       debugged code's registers or the alternate register set, set with
       DS_SetAlternateRegisterSet function.

       ENTRY:  (AX) = 007ah

       EXIT:   NONE

       NOTE:   If the CS:EIP is invalid, this service will not return
               because of an error when the code is disassembled.  A
               message is printed and control returns to the command loop.
*/

#define DS_PrintRegisters       0x7a

/***     DS_PrintStackDump

       This function prints (just like the "k" command) the stack dump
       based on the current register set that may have been set with
       DS_SetAlternateRegisterSet function.

       ENTRY:  (AX) = 007bh
               (BX) = flags
                       01h - verbose stack dump
                       02h - 16 bit stack dump
                       04h - 32 bit stack dump

       EXIT:   NONE

       NOTE:   If the CS:EIP or SS:EBP are invalid, this service will not
               return because of an error when accessing the stack.  A
               message is printed and control returns to the command loop.
*/

#define DS_PrintStackDump       0x7b

/***     DS_SetThreadID

       This function sets what the debugger thinks the thread ID is
       for memory address in other address contexts.  It stays set
       until the debugged code is returned to (via "g", "t" or "p")
       or set back to 0.

       ENTRY:  (AX) = 007ch
               (CX) = thread ID or 0 for currently executed thread

       EXIT:   NONE
*/

#define DS_SetThreadID          0x7c

/***     DS_ExecDebugCommand

       This service allows any debugger command to be executed.  In can
       be a multi-lined script with the lines separated by CR, LF.  MUST
       have a "g" command at the end of script so the debugger doesn't
       stop while in the INT 41.

       ENTRY:  (AX) = 007dh
               (DS:ESI) = pointer to debugger command script string
               (CX) = size of script

       EXIT:   NONE

       NOTE:   If the any kind of error happens, this service will not
               return.  A message is printed and control returns to the
               command loop.
*/

#define DS_ExecDebugCommand     0x7d

/***     DS_GetDebuggerInfo

       This service returns various debugger info and routines.

       ENTRY:  (AX) = 007eh
               (DS:ESI) = pointer to DebInfoBuf structure
               (ECX) = size of the above buffer.  Only this many bytes are
                       copied to the buffer this allows more info to be
                       passed in future versions without breaking anything.

       EXIT:   (AX) == 0, no errors
               (AX) != 0, error:   (AX) == 007eh, function not implemented
                                   (AX) == anything else, invalid buffer
*/

#define DS_GetDebuggerInfo      0x7e

/***     DS_CheckFault

       This service checks if the debugger wants control on the fault.

       ENTRY:  (AX) = 007fh
               (BX) = fault number
               (CX) = fault type mask
                       DEBUG_FAULT_TYPE_V86
                       DEBUG_FAULT_TYPE_PM
                       DEBUG_FAULT_TYPE_RING0
                       DEBUG_FAULT_TYPE_FIRST
                       DEBUG_FAULT_TYPE_LAST

       EXIT:   (AX) == 0, handle fault normally
               (AX) != 0, handled by debugger
*/

#define DS_CheckFault           0x7f

/***     DS_SetBreak

       This service allows an error break or ctrl-c handler to be
       set.  The old value that is returned must be save and set
       back to remove the break handler.

       ENTRY:  (AX) = 0080h
               (DS:ESI) = pointer to BreakStruc with the CS:EIP and
               SS:ESP values to be used when a error break or ctrl-c
               happens.  The old value is copied into this buffer.

       EXIT:   (AX) == 0, no error
               (AX) != 0, error on BreakStruc address
*/

#define DS_SetBreak             0x80

/***     DS_RedirectExec

       This service redirects the input and output streams to the
       specified buffers for the debugger command line passed.

       ENTRY:  (AX) = 0081h
               (DS:ESI) = pointer to RedirectExecStruc

       EXIT:   (ECX) = number of bytes written
               (AX) == 0, no error
               (AX) != 0, error
                       1 to 10 = memory access error
                       -1      = buffer overflow
                       -2      = invalid parameter, not on a 386, or reentered
*/

#define DS_RedirectExec         0x81

/***     DS_PassOnDebugCommand

       Used to tell the debugger to pass this dot command on to the
       next handler.

       ENTRY:  (AX) = 0082h

       EXIT:   NONE
*/

#define DS_PassOnDebugCommand   0x82

/***     DS_TrapFault

       Allows ring 3 code to send a fault to the debugger

       ENTRY:  (AX) = 0083h
               (BX) = fault number
               (CX) = faulting CS
               (EDX) = faulting EIP
               (ESI) = fault error code
               (EDI) = faulting flags

       EXIT:   (CX) = replacement CS
               (EDX) = replacement EIP
*/

#define DS_TrapFault            0x83

/***     DS_SetStackTraceCallBack

       Sets the "k" command callback filter used to back trace
       thru thunks.

       ENTRY:  (AX) = 0084h
               (EBX) = linear address of call back routine, zero to uninstall
               (ECX) = linear address of the end of the call back routine
               (EDX) = EIP to use for for faults in call back routine

       EXIT:   NONE

       CALLBACK:
               ENTRY:  (EAX) = linear base of SS
                       (EBX) = linear address of SS:EBP
                       (DS, ES) = flat ds
                       (SS) = NOT flat ds !!!!!!!!!

               EXIT:   (EAX) = FALSE, no thunk
                               TRUE, is a thunk
                                       (CX:ESI) = new SS:EBP
                                       (DX:EDI) = new CS:EIP
*/

#define DS_SetStackTraceCallBack 0x84

/***     DS_RemoveSegs

       Removes all the undefined groups from a map file.

       ENTRY:  (AX) = 0085h
               (ES:EDI) pointer to module name

       EXIT:   NONE
*/

#define DS_RemoveSegs            0x85

/***     DS_DefineDebugSegs

       Defines the debugger's code and data symbols.

       ENTRY:  (AX) = 0086h

       EXIT:   NONE
*/

#define DS_DefineDebugSegs       0x86

/***     DS_SetBaudRate

       Sets the com port's baud rate.
       Use DS_SetBaudRateEx to get 115200bps (only on WDEB98 and up)

       ENTRY:  (AX) = 0087h
               (BX) = baud rate

       EXIT:   NONE
*/

#define DS_SetBaudRate           0x87

/***     DS_SetComPort

       Sets the com port's baud rate

       ENTRY:  (AX) = 0088h
               (BX) = com port number

       EXIT:   (AX) == 0, ok
               (AX) != 0, error bad com port
*/

#define DS_SetComPort            0x88

/***     DS_ChangeTaskNum

       Changes a task number to another task number or
       indicates that the task has gone away.

       ENTRY:  (AX) = 0089h
               (CX) = old task number
               (DX) = new task number or -1 if process terminated.

       EXIT:   NONE
*/

#define DS_ChangeTaskNum         0x89

/***     DS_ExitCleanup

       Called when Windows exits.

       ENTRY:  (AX) = 008ah

       EXIT:   NONE
*/

#define DS_ExitCleanup           0x8a

/***     DS_InstallVGAHandler

       Called when the Debug VxD is initializing (during Device Init),
       to specify an alternate I/O handler for VGA.  The handler accepts the
       following inputs:

           BX == subfunction #:
                   0 == save screen state (switch to debugger context)
                        No inputs/outputs
                   1 == restore screen state (switch to windows context)
                        No inputs/outputs
                   2 == display output character (ie, OEMOutputCharCOM)
                        on input, AL == character
                   3 == check for input character (ie, OEMScanCharCOM)
                        on output, ZR if no chars, else NZ and AL == char

       ENTRY:  (AX) = 008bh
               (DX:EDI) == 16:32 address to call, with BX == subfunction above

       EXIT:   NONE
*/

#define DS_InstallVGAHandler    0x8b

/***     DS_GetComBase

       Called when Debug VxD is initializing (during Device Init),
       to get the base of the com port being used by wdeb386.

       Entry:
               (AX) == 008ch

       Exit:
               (AX) = base of COM port.
*/

#define DS_GetComBase           0x8c

/***     DS_GetSymbol

       Looks up a symbol and returns the linear address and segment/offset.

       ENTRY:  (AX) == 008dh
               (DS:ESI) = ptr to null-terminated symbol

       EXIT:   (AX) == 0, no error
               (AX) == 1, symbol not found
               (AX) == 2, memory not loaded yet
               (ECX) = linear address of variable  (if AX == 0)
               (EDX) = seg:offset of variable      (if AX == 0)
*/

#define DS_GetSymbol            0x8d

/***     DS_CopyMem

       Copys memory from one AddrS to another AddrS

       ENTRY:  (AX) == 008eh
               (DS:ESI) = pointer to source AddrS block
               (ES:EDI) = pointer to destination AddrS block
               (CX) = number of bytes

       EXIT:   (AX) == 0, no error
               (AX) != 0, invalid address
*/

#define DS_CopyMem              0x8e

/***     DS_LogPrintf

       Just like DS_Printf except it prints to the log file

       ENTRY: see DS_Printf

*/
#define DS_LogPrintf            0x8f

#ifdef WDEB98

#define DS_Reserved0            0x8f

#define DS_IsCompatibleWDeb     0x90

/***     DS_IsCompatibleWDeb

       Used to determine WDeb version.

       ENTRY:  (AX) = 0090h
               (BX) = WDeb version, major version in hiword, minor version
                      in low word. For example:

                        BH == 98T   BL == 0

       EXIT:   (AX) == 0, version is supported,
               (AX) != 0, version is not supported
*/

#define DS_SetBaudRateEx        0x91

/***     DS_SetBaudRateEx

       Sets the com port's baud rate. Supports >57600kbps
       Only available on WDEB98 and up

       ENTRY:  (AX) = 0091h
               (EBX) = baud rate

       EXIT:   EBX == 0, no error
               EBX != 0, error or not supported function (try DS_SetBaudRate)
*/

#define DS_GetSetDebuggerState  0x92

/***     DS_GetSetDebuggerState

       This function can be used to temporarily change the state of the
       debugger (this function might be called if the comm port were about
       to turn off or on).

       ENTRY:  (AX) = 0092h
               (BX) = Debugger State:

         0 == No state change will occur if this value is used. Use this
              value to retrieve the current state of the debugger.

         1 == Debugger is on and responds to all faults, CTRL-C attempts,
              comm port input requests, and comm port output requests.

         2 == Debugger does not respond to traps, but still responds to all
              CTRL-C attempts, comm port input requests, and comm port
              output requests. This means the Windows Debug Kernel
              "Abort, Retry, ..." messages will still work, but no Win32
              or Ring0 assertions will stop the machine.

         3 == Debugger does not respond to traps, or CTRL-C attempts. Comm
              port input requests, and comm port input and output requests
              are honored still, as above.

         4 == Debugger does not respond to traps, or CTRL-C attempts, or
              comm port input requests. Only comm port output requests are
              processed.

         5 == Debugger does not respond to traps, CTRL-C attempts,
              comm port input requests, or comm port output requests. The
              debugger is essentially "silent". Most other API calls
              (DS_LoadSeg, DS_EvaluateExpression, etc) are still supported.

       EXIT:   AX == 0, if successful. BX is the new state.
               AX != 0, not successful
*/

#define DS_TestDebugComPort       0x93

/***     DS_TestDebugComPort

       This function determines whether the passed in port range is in
       use by WDEB98, and determines the state of Rterm98 on the other
       end of the port. Calling this function can also allow "late" binding
       on WDeb to a com port (useful if the OS needs to "turn on" the
       port range first.) If this function finds an Rterm98, an implicit
       call to DS_GetSetDebuggerState with BX==1 is made.

       ENTRY:  (AX)    = 0093h
               (BX)    = Port range to test (3F8, 2F8, etc)
               (CX==0) - If WDeb has not found it's com port yet (ie, the
                         port is set to auto, or was not available at boot
                         time), WDeb can acquire this port. In the case of
                         auto port selection, this port will be acquired
                         only if Rterm98 is detected on the other side.
               (CX==1) - WDeb will _not_ take this com port if it does not
                         already have one.

       EXIT:   (AX) != 0, API error (for example, called on WDeb386)
               (AX) == 0, then...

               (BH==0)    - Debugger is not on this port.
                  (BL==0)  - Debugger is on another port already
                  (BL==1)  - Debugger does not have a port yet.
                  (BL==2)  - Debugger could not initialize this port
                  (BL==3)  - Debugger could not find an Rterm98 on this port.

               (BH==1)    - Debugger is using this port
                  (BL==0)  - Rterm98 cannot be found, or not responding.
                  (BL==1)  - Rterm98 version is too old.
                  (BL==2)  - WDeb98 version is too old.
                  (BL==3)  - Rterm present and fully compatible.

*/

#define DS_Reserved4            0x94
#define DS_Reserved5            0x95
#define DS_Reserved6            0x96
#define DS_Reserved7            0x97
#define DS_Reserved8            0x98
#define DS_Reserved9            0x99
#define DS_Reserved10           0x9A
#define DS_Reserved11           0x9B
#define DS_Reserved12           0x9C
#define DS_Reserved13           0x9D
#define DS_Reserved14           0x9E
#define DS_Reserved15           0x9F

/***     DS_InstallVxDThunk

       Installs a private callback for WDeb98 and it's accompanying VxD.
       This routine is the 16 -> 32 bit portion of the thunk layer.

       ENTRY:  (AX) = 00A0h
               (DX:EDI) == 16:32 address to call


       BUGBUG: DOC this better!
*/

#define DS_InstallVxDThunk      0xA0

/***     DS_ThunkDownTo16

       Entry into a private callback into 16bit WDeb98 for it's VxD.
       This int is the 32 -> 16 bit portion of the thunk layer.

       ENTRY:  (AX) = 00A1h


       BUGBUG: DOC this better!
*/

#define DS_ThunkDownTo16        0xA1


#define DS_JumpTableEnd         0xA1

#else // WDEB98
#define DS_JumpTableEnd         0x8f

#endif // WDEB98

struct SaveRegs_Struc {
   DWORD Debug_EAX ;
   DWORD Debug_EBX ;
   DWORD Debug_ECX ;
   DWORD Debug_EDX ;
   DWORD Debug_ESP ;
   DWORD Debug_EBP ;
   DWORD Debug_ESI ;
   DWORD Debug_EDI ;
    WORD Debug_ES  ;
    WORD Debug_SS  ;
    WORD Debug_DS  ;
    WORD Debug_FS  ;
    WORD Debug_GS  ;
   DWORD Debug_EIP ;
    WORD Debug_CS  ;
   DWORD dwReserved ;
   DWORD Debug_EFlags ;
   DWORD Debug_CR0 ;
   QWORD Debug_GDT ;
   QWORD Debug_IDT ;
    WORD Debug_LDT ;
    WORD Debug_TR  ;
   DWORD Debug_CR2 ;
   DWORD Debug_CR3 ;
   DWORD Debug_DR0 ;
   DWORD Debug_DR1 ;
   DWORD Debug_DR2 ;
   DWORD Debug_DR3 ;
   DWORD Debug_DR6 ;
   DWORD Debug_DR7 ;
   DWORD Debug_DR7_2 ;
   DWORD Debug_TR6 ;
   DWORD Debug_TR7 ;
    WORD Debug_TrapNumber ; // -1 means no trap number
    WORD Debug_ErrorCode  ; // 0 means no error code
  } ;

// Don't let h2inc see FWORD as it doesn't understand FWORD, QWORD, & TWORD
/*XLATOFF*/
struct DebInfoBuf {
   BYTE DIB_MajorVersion ;
   BYTE DIB_MinorVersion ;
   BYTE DIB_Revision ;
   BYTE DIB_Reserved ;
   DWORD DIB_DebugTrap16 ;  // send 16 bit trap to debugger
   FWORD DIB_DebugTrap32 ;  // send 32 bit trap to debugger
   DWORD DIB_DebugBreak16 ; // 16 bit break in debugger
   FWORD DIB_DebugBreak32 ; // 32 bit break in debugger
   DWORD DIB_DebugCtrlC16 ; // 16 bit check for ctrl C
   FWORD DIB_DebugCtrlC32 ; // 32 bit check for ctrl C
  } ;
/*XLATON*/

/* ASM
DebInfoBuf      STRUC
DIB_MajorVersion        DB      ?
DIB_MinorVersion        DB      ?
DIB_Revision    DB      ?
DIB_Reserved    DB      ?
DIB_DebugTrap16 DD      ?
DIB_DebugTrap32 DF      ?
DIB_DebugBreak16        DD      ?
DIB_DebugBreak32        DF      ?
DIB_DebugCtrlC16        DD      ?
DIB_DebugCtrlC32        DF      ?
DebInfoBuf      ENDS

*/

struct BreakStruc {
   DWORD BS_BreakEIP ; // CS:EIP, SS:ESP to go to on a error or ctrlc break
    WORD BS_BreakCS  ;
   DWORD BS_BreakESP ;
    WORD BS_BreakSS  ;
  } ;

// Don't let h2inc see FWORD as it doesn't understand FWORD, QWORD, & TWORD
/*XLATOFF*/
struct RedirectExecStruc {
   FWORD RDE_fpbufDebugCommand ; // debugger command script
    WORD RDE_cbDebugCommand    ; // debugger command script len
   FWORD RDE_fpszInput         ; // input stream pointer
    WORD RDE_usFlags           ; // reserved (must be 0)
   DWORD RDE_cbOutput          ; // size of output buffer
   FWORD RDE_fpbufOutput       ; // output buffer pointer
  } ;
/*XLATON*/
/* ASM
RedirectExecStruc       STRUC
RDE_fpbufDebugCommand   DF      ?
RDE_cbDebugCommand      DW      ?
RDE_fpszInput   DF      ?
RDE_usFlags     DW      ?
RDE_cbOutput    DD      ?
RDE_fpbufOutput DF      ?
RedirectExecStruc       ENDS
*/

#define REPEAT_FOREVER_CHAR     0x0fe // send next character until
                                      // end of debugger command
// for printf service
struct AddrS {
   DWORD AddrOff ;
    WORD AddrSeg ;
    BYTE AddrType ;
    BYTE AddrSize ;
    WORD AddrTask ;
  } ;

//AddrTypeSize    equ   word ptr AddrType

#define EXPR_TYPE_SEG   0x0001 // 00000001b  address type segment:offset
#define EXPR_TYPE_SEL   0x0009 // 00001001b  address type selector:offset
#define EXPR_TYPE_LIN   0x0002 // 00000010b  address type linear
#define EXPR_TYPE_PHY   0x000A // 00001010b  address type physical
#define EXPR_TYPE_LOG   0x0008 // 00001000b  logical address (no sel yet)
#define EXPR_TYPE_MOD   0x000B // 00001011b  module address (no sel yet)

#define DEBUG_FAULT_TYPE_V86            0x0001 // 00000001b
#define DEBUG_FAULT_TYPE_PM             0x0002 // 00000010b
#define DEBUG_FAULT_TYPE_RING0          0x0004 // 00000100b
#define DEBUG_FAULT_TYPE_FIRST          0x0008 // 00001000b
#define DEBUG_FAULT_TYPE_LAST           0x0010 // 00010000b

//
//   Interrupt and services that Win386 provides to the debugger
//

#define Win386_Query_Int    0x22 // interrupt for Win386 protected mode
                                 // interface requests

#define Win386_Alive        0       // function 0, query Win386 installation
#define Win386_Q_Ack        0x0F386   // good response from func 43h, of
                                      // INT 68h & func 4fh of INT 41h

#define Win386_Query        1       // function 1, query Win386 state
                                    //   ds:esi points to command string
                                    //   that Win386 needs to process
                                    //   ds:edi points to the SaveRegs_Struc
                                    //   that the debugger has stored all the
                                    //   client register state into.
                                    //   (Win386 just writes the query
                                    //   answers directly to the output
                                    //   device, so no response is returned)

#define Win386_PhysToLinr   2       // function 2, have Win386 convert a
                                    //   physical address into a valid
                                    //   linear address that Deb386 can
                                    //   use.  esi is physicaladdress
                                    //   cx is # of bytes required
                                    //   returns esi as linear address
                                    //   returns ax = 1, if okay, else
                                    //   0, if request couldn't be completed


#define Win386_AddrValid    3       // function 3, have Win386 check the
                                    //   validity of a linear address
                                    //   esi is linear address to check
                                    //   cx is # of bytes required
                                    //   returns ax = 1, if address okay
                                    //   else ax = 0

#define Win386_MapVM        4       // function 4, make sure that the VM's
                                    //   low memory is mapped in, in case
                                    //   it is touched (a count is maintained)

#define Win386_UnmapVM      5       // function 5, map out the VM's low
                                    //   memory (dec the count)

#define Win386_GetDLAddr    6       // function 6, return offset of dyna-link
                                    //   service.  EBX = Device ID << 10h +
                                    //   Service #.  Returns EAX = Offset.

#define Win386_GetVXDName   7       // function 7, determines whether an address
                                    //   is within a VXD object.
                                    //   DS:ESI -> buffer to receive object name
                                    //   BX  =  thread number
                                    //   EDX  = linear address to query
                                    //   If EAX == 0, EDX = base address of object
                                    //   If EAX != 0, error

#define Win386_GetPDE       8       // function 8, get pde for a context
                                    //   BX = thread number
                                    //   EDX = linear address
                                    //   if EAX == 0, ECX = PDE
                                    //   if EAX != 0, error

#define Win386_GetFrame     9       // function 9, get phys addr for not pres ptes
                                    //   BX = thread number
                                    //   EDX = linear address
                                    //   ECX = PDE or PTE
                                    //   ESI = 0 if PDE, !0 if PTE
                                    //   if EAX == 0, EDX = physical address
                                    //   if EAX != 0, error

#define Win386_GetLDTAddress 10     // function 10,
                                    //   BX = thread number
                                    //   if EAX == 0,
                                    //     EDI = pointer to LDT
                                    //     ECX = ldt limit
                                    //   if EAX != 0, error

#define Win386_GetThreadID   11     // function 11, AX = Current Thread ID

#define Win386_GetTSHandler  12     // function 12, return offset of transfer-space
                                    //   fault handler.  EBX = 16:16 addr of
                                    //   int 30h.  Returns EAX = Offset or 0.

#define Win386_GetArplHandler 13    // function 12, return offset of ARPL fault
                                    //   fault handler.  Eb = 16:16 addr of
                                    //   ARPL.  Returns EAX = Offset or 0.

#define Max_Win386_Services 13


#endif // _DEBUGSYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\k16thk.h ===
#ifndef _K16THK_H
#define _K16THK_H

#define MEOW_LOGGING        1

#define MEOW_FLAG_HIGH_THUNK            0x00000001
#define MEOW_FLAG_NO_SUSPEND            0x00000002
#define MEOW_FLAG_ME_CREATE_PROCESS     0x00000004
#define MEOW_FLAG_NO_READ_ONLY          0x00000008
#define MEOW_FLAG_FAKE_NO_DEBUG         0x00000010
#define MEOW_FLAG_LOGGING               0x00000020
#define MEOW_FLAG_ON                    0x80000000

#define MEOWTHK_HANDLE      0
#define MEOWTHK_PASSTHRU    1

#ifdef  MEOW_LOGGING

typedef struct _LOGGINGWRAPPER { /* LW */
    CHAR        szNop;
    CHAR        szShortJump[2];
    CHAR        szNop2;
    CHAR        *pszFunctionName;
    PVOID       pOriginalFunction;
    CHAR        szFileName[8];
}  LOGGINGWRAPPER, *PLOGGINGWRAPPER;

#endif  // def MEOW_LOGGING

//
// This number must be a power of 2.
//
#define MEOWTHK_STACK_MAX_PARAM         64

typedef struct _MEOWTHKSTACK { /* MTS */
    DWORD       dwGS;
    DWORD       dwFS;
    DWORD       dwES;
    DWORD       dwDS;
    DWORD       dwEDI;
    DWORD       dwESI;
    DWORD       dwEBP;
    DWORD       dwESP;
    DWORD       dwEBX;
    DWORD       dwEDX;
    DWORD       dwECX;
    DWORD       dwEAX;
    DWORD       dwEFlags;
    DWORD       dwFunction;
    DWORD       dwReturn;
} MEOWTHKSTACK;

typedef MEOWTHKSTACK    *PMEOWTHKSTACK;

#define MEOWTHKSTACK_PARAMS(p)     (PDWORD)(((PBYTE)p)+sizeof(MEOWTHKSTACK))

#ifdef  WOW

#define MEOW_PLEH_SIGNATURE     0x574F454D

#define WOW_FLATCS_SELECTOR 0x1B
#define WOW_FLATDS_SELECTOR 0x23
#define WOW_TIB_SELECTOR    0x3B

#define ERROR_LOADING_NT_DLL    1

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _STACK32 {                  /* k212 */
    DWORD       dwGS;
    DWORD       dwFS;
    DWORD       dwES;
    DWORD       dwDS;
    DWORD       dwEDI;
    DWORD       dwESI;
    DWORD       dwEBP;
    DWORD       dwESP;
    DWORD       dwEBX;
    DWORD       dwEDX;
    DWORD       dwECX;
    DWORD       dwEAX;
    DWORD       dwEFlags;
    DWORD       dwMovedStack;
    DWORD       dwReturnOffset;
    DWORD       dwService;
    DWORD       dwParam0;
    DWORD       dwParam1;
    DWORD       dwParam2;
    DWORD       dwParam3;
    DWORD       dwParam4;
    DWORD       dwParam5;
    DWORD       dwParam6;
    DWORD       dwParam7;
    DWORD       dwParam8;
    DWORD       dwParam9;
    DWORD       dwParam10;
    DWORD       dwParam11;
} STACK32;
typedef STACK32 UNALIGNED *PSTACK32;
typedef PSTACK32 UNALIGNED *PPSTACK32;

typedef struct _LOADKERNEL32 {          /* k213 */
    WORD        wPSPSegment;
    WORD        wPSPSelector;
    WORD        wDOS386ArenaHead;
    WORD        wDOS386PSPSel;
    PVOID       pVxDEntry;
    PVOID       pKrn32LoadBaseAddr;
} LOADKERNEL32;
typedef LOADKERNEL32 UNALIGNED *PLOADKERNEL32;

/* XLATOFF */
#pragma pack()
/* XLATON */

#endif  // def WOW
#endif  // ndef _K16THK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\hgroup.inc ===
; HGROUP.INC
;
; WARNING: This file contains structures used by both 16-bit and 32-bit code.
; Make sure the structures align the same in both!
;
; These structures support *handle groups*. Handle groups are global
; memory blocks that are ganged together so than when one gets freed,
; all get freed automatically. This solves the problems of cleanup when
; a Win32 thunk has to copy a shared block (for say DDE or clipboard)
; to repack a structure or move data into a shared heap. Figuring out
; when to free these intermediate copies is a nightmare (especially for DDE).
; Since the copy and the original are one "virtual block", a better solution
; is to put them in a handle group. Then all copies get cleaned
; up automatically.
;
; A "global block" is either a Win16 global memory block or a native
; Win32 global memory block. Blocks of different types can and do mix in the
; same group. Groups are disjoint.
;
; No attempt is made to keep the blocks in a group consistent. Win32
; apps cannot assume that DDE blocks represent shared memory. These blocks
; are used for short term, one way, read-only data transfer.
;
; If any member of a group is freed by an app (or dll), the memory
; managers nuke the entire group and free all of its members (due
; to implementation reasons, Win32 handles may not be freed till
; later. However, the group itself will disappear.)
; 
; A block can also defect from a group. Blocks defect if they're cleaned
; up as a result of process termination. Since such a cleanup is probably
; unintentional and an abornal event, we prefer the memory leak to 
; causing other apps to crash. Defections don't affect any other member
; of the group.
;
;
;
; For example, suppose a 32-bit DDE server posts a WM_DDE_DATA message. 
; The DDE thunk gets a native Win32 handle that can't be used out of context.
;
; The DDE thunk gamely creates a Win16 copy of the block, creates a
; new group and puts the copy and original in the group. Then it sends
; the Win16 copy to the client. Both blocks (and the group) will get
; cleaned up when either the server or the client frees his block. Neither
; the thunk nor the group manager cares which way it happens.
;
; The DDE thunk can also do this to repack a structure. It can make
; a repacked copy and gang it to the original. All group members act
; as a single "virtual handle" which is what an app would expect to see
; in Win3.1.
;




;-------------------------------------------------------------------------
; This structure contains the global variables (in K16) used by the group
; manager. These globals are locked in linear memory since they're used
; by K32 as well. They're packaged in a structure to simplify commmunication
; between the two kernels.
;
; Access to this structure is synchronized by Win16Lock.
;
;
; hg_wSelHeap:
;    Contains the *selector* of a movable Win16 global block which is an
;    array of HG_NODE structs. Every element is on exactly one of three
;    linked lists: the handle list, the death list and the free list.
;
;    Initial value: 0. Lazily initialized.
;
; hg_wHndList:
;    16-bit offset into wSelHeap of the first node in the handle list (-1
;    if empty). Each node represents a Win32 or Win16 handle that is part 
;    of some existing group. The list is not sorted in any way.
;
;    For implementation reasons, NULL handles can appear on this list for 
;    short times (*)
;
;    Initial value: -1.
;
;
;  hg_wDeathList:
;    16-bit offset into wSelHeap of the first node in the death list (-1
;    if empty). Each node represents a Win32 handle who is logically
;    dead becaues their groups got nuked. The Win32 heap manager walks this
;    list periodically and frees the handles. To keep innocent apps from
;    paying a performance penalty, we set the TDBF_HGCLEANUP flag in
;    the hTask iff the death list contains any handles with that hTask.
;
;    DeathList handles do not have group id's. Their group has already gone.
;
;    Initial value: -1.
;
;  hg_wFreeList:
;    16-bit offset into wSelHeap of the first node in the free list (-1
;    if empty). Basically, all nodes that aren't being used for some other
;    purpose.
;
;
; hg_wDontTouch:
;    normally 0. Set to 1 by certain routines to tell GlobalFree
;    not to examine or modify the HG database. Used to prevent
;    unwanted recursion when destroying groups. This flag is always set
;    and reset within a single Win16 lock session.
;
;
; hg_wDeadGroup:
;    used for communication between free_object and GlobalFree. free_object
;    sets this global to the hgroup of the dying handle (unless
;    hg_wDontTouch is set.) GlobalFree uses this to nuke the group
;    and all its other members.
;
;
; (*) Why do NULL handles appear in the handle list? Because nodes need to
;     defect from their group when they get freed since we can't have
;     invalid handles in the database. But we can't always unlink the node
;     at that time since it may be a group leader. So we null out its
;     handle but leave the node intact to serve as a group leader.
;
;     GrowHGHeap runs a garbage collector that goes and cleans up
;     old groups that have no real handles left (BUGBUG: Not yet.)
;
;
; MAINTENANCE WARNING: If you change this structure, you have to build
; both k16 and k32 again. Also, you must ensure that all fields align
; identically in both 32-bit and 16-bit code.
;
; THIS STRUCTURE IS PROTECTED BY THE crstGHeap16Lock, *not* the
; Win16Mutex! Beware!
; 
;------------------------------------------------------------------------
HG_GLOBALS      STRUCT
  hg_wSelHeap     dw    0
  hg_wHndList     dw    -1      ;Offset into wSelHeap
  hg_wDeathList   dw    -1      ;Offset into wSelHeap
  hg_wFreeList    dw    -1      ;Offset into wSelHeap
  hg_wSlotCnt     dw    0       ;# of HG_NODE slots in hg_wSelHeap

  hg_wDontTouch   dw    0       ;Special use: see above
  hg_wDeadGroup   dw    -1      ;Special use: see above
HG_GLOBALS      ENDS



;------------------------------------------------------------------------
; This structure represents nodes in the group manager's database.
; Each node lives on one of three linked lists: the handle list, the
; death list, and the free list.
;
; hgn_wNext:   Next node in list (as 16-bit offset into hg_wSelHeap).
;
; hgn_wGroup:  Handle-list nodes only: the group id. The group id
;              is the address (16-bit offset into hg_wSelHeap) of
;              a designated group member (called the group leader).
;              All members of a group must use the same group leader.
;
; hgn_hTask16: Win32 handle-list and death-list nodes only: the
;              hTask of the Win32 process that created the handle.
;              Set to 0 for Win16 handles.
;              Native handles are private to each process so they can
;              be disambiguated only by using hTask16.
;
; hgn_wChkMk:  Private field used by CheckHGHeap. 
;
; hgn_dwHnd:   Handle-list and death-list nodes only: the heap handle
;              (either Win32, or a zero-extended Win16 handle). 
;              Death-list nodes can only contain native handles here.
;
; hgn_Flags:   Flag bits
;
;
; MAINTENANCE WARNING: If you change this structure, you have to build
; both k16 and k32 again. Also, you must ensure that all fields align
; identically in both 32-bit and 16-bit code. You must also change
; SCALE_BY_SIZEOF_HGNODE to reflect any size changes.
;
; THIS STRUCTURE IS PROTECTED BY THE crstGHeap16Lock, *not* the
; Win16Mutex! Beware!
;
; 
;------------------------------------------------------------------------
HG_NODE         STRUCT
  hgn_wNext       dw    0       ;Next HG_NODE (offset into wSelHeap)
  hgn_wGroup      dw    0       ;Group leader (offset into wSelHeap)
  hgn_hTask16     dw    0       ;Context of native Win32 handle
  hgn_wChkMk      dw    0       ;For CheckHGHeap's private use.
  hgn_dwHnd       dd    0       ;Win32 handle or 0-extended Win16 handle
  hgn_Flags       dd    0       ;Padding
HG_NODE         ENDS

HGF_CANONICAL   equ     00000001h  ;This handle is a canonical DDE_EXECUTE handle
HGF_BLOWITAWAY  equ     00000002h  ;Used by HGGarbageCollect


SCALE_BY_SIZEOF_HGNODE  macro   reg
        shl     reg,4
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\int2fapi.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1989-1990
 *
 *   Title:     INT2FAPI.INC - Windows/386 V86 Application Program Interface
 *
 *   Version:   3.00
 *
 *   Date:      10-Mar-1989
 *
 *   Author:    RAL
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *      DATE    REV                 DESCRIPTION
 *   ----------- --- ----------------------------------------------------------
 *   10-Mar-1989 RAL Original for 3.0
 *   07-Apr-1989 RAL Added device broadcast equate
 *   19-Jun-1992 RJC Convert to H file
 *
 *=============================================================================
 *
 *   For information on these APIs please refer to the Windows/386 DDK
 *   appendix on the Int 2Fh Application Program Interface.
 *
 *****************************************************************************/

/*
 *   Interrupt 2Fh is used for Windows/386 API calls.
 */
#define W386_API_Int            0x2F

/*
 *   All Windows/386 API Int 2Fh calls must be issued with AH = 16h
 */
#define W386_Int_Multiplex      0x16

/*
 *   Values for AL for all Windows/386 API calls
 */
#define W386_Get_Version        0x00    /* Install check/Get version */
#define W386_Old_Get_VMID_API   0x02    /* Version 2.xx get VMID API call */
#define W386_Startup            0x05    /* Broadcast when Win386 starting */
#define W386_Exit               0x06    /* Broadcast when Win386 exited */
#define W386_Device_Broadcast   0x07    /* Broadcast by virtual device */
#define W386_Startup_Complete   0x08    /* Broadcast when Win386 start is complete */
#define W386_Begin_Exit         0x09    /* Broadcast when Win386 is starting */
                                        /* a NORMAL exit sequence */
#define W386_Windows_ID         0x0A    /* Identify windows ver/type */
#define W386_TSR_Identify       0x0B    /* Identify TSRs */
#define W386_ROM_Detect         0x0C    /* Used by ROM win to detect ROMs */
#define W386_WDEB               0x0D    /* Used by wdeb386 */
#define W386_Logo               0x0E    /* IO.SYS service for logo management */
#define W386_INT10              0x0F    /* IO.SYS service to replace INT 10h hook */
#define W386_Get_Shell          0x11    /* IO.SYS service to return shell info */
#define W386_Get_BIOS_Data      0x12    /* IO.SYS service to return IO.SYS data */
#define W386_Get_SYSDAT_Path    0x13    /* IO.SYS service to return path to SYSTEM.DAT */
#define W386_Set_SYSDAT_Path    0x14    /* IO.SYS service to set path to SYSTEM.DAT */
#define SAVE32_ID               0x1615  /* TSR Id for SAVE32.COM to save 32bit registers */

#define W386_Sleep              0x7F    /* Call Time_Slice_Sleep (DX=#ms) */
#define W386_Release_Time       0x80    /* Release cur VM's time-slice */
#define W386_Begin_Critical     0x81    /* Begin critical section */
#define W386_End_Critical       0x82    /* End critical section */
#define W386_Get_Cur_VMID       0x83    /* Returns BX = ID of current VM */
#define W386_Get_Device_API     0x84    /* Returns ES:DI -> Device API */
#define W386_Switch_And_Call    0x85    /* Change VMs and call-back */
#define W386_Test_Int31_Avail   0x86    /* Returns AX=0 if Int 31 avail */
#define W386_Get_PM_Switch_Addr 0x87    /* Get call-back addr for PM */
#define W386_Get_LDT_Base_Sel   0x88    /* Get selector to LDT */
#define W386_Win_Kernel_Idle    0x89    /* Windows kernel idle call */
#define W386_DPMI_Extension     0x8A    /* DPMI extension Int 2Fh */
#define W386_Set_Focus          0x8B    /* Set focus to specified VM */
#define W386_Restart_Cmd        0x8C    /* Win.Com execs specified app */
#define W386_Get_Win32_API      0x8D    /* Get Win32 API callback */
#define W386_VM_Title           0x8E    /* Assorted VM title APIs */
#define W386_VM_Close           0x8F    /* Assorted VM close APIs */
#define W386_Return_RMD         0x90    /* return RMD list */

/*
 *   Structure for real mode device initialization API.
 */
struct Win386_Startup_Info_Struc {
        BYTE    SIS_Version[2];         /* AINIT <04h,01h> Structure version */
        DWORD   SIS_Next_Ptr;           /* Seg:Off of next dev in list */
        DWORD   SIS_Virt_Dev_File_Ptr;  /* INIT <0> PSZ of file name to load */
        DWORD   SIS_Reference_Data;     /* Data to be passed to device */
        DWORD   SIS_Instance_Data_Ptr;  /* INIT <0> Ptr to instance data list */
        DWORD   SIS_Opt_Instance_Data_Ptr;/* INIT <0> Ptr to opt. instance data list */
        DWORD   SIS_Reclaim_Data_Ptr;   /* INIT <0> Ptr to reclaimable data list */
};

/*
 *   Structure for instance data list.  (List terminated with 0 dword).
 */
struct Instance_Item_Struc {
        DWORD   IIS_Ptr;                /* Seg:Off of instance item */
        WORD    IIS_Size;               /* Size of instance item in bytes */
};

/*
 *   Structure for reclaim data list.  (List terminated with 0 Seg).
 */
struct Reclaim_Item_Struc {
        WORD    RIS_Seg;                /* Seg of reclaimable item */
        WORD    RIS_Paras;              /* Size of item, in paragraphs */
        DWORD   RIS_HookTable;          /* Seg:Off of Reclaim_Hook_Table (0 if none) */
        WORD    RIS_Flags;              /* See RIS_* equates (below) */
};

#define RIS_RECLAIM     0x0001  /* segment can be reclaimed during Init_Complete */
#define RIS_RESTORE     0x0002  /* segment contents must be restored prior to System_Exit */
#define RIS_DOSARENA    0x0004  /* segment is a DOS memory block, add to DOS memory pool */

/*
 *   NOTE: If RIS_HookTable is non-zero, then it is interpreted as a
 *   pointer to a Reclaim_Hook_Table, which provides a means
 *   for the system to automatically unhook a component in a reclaimable
 *   memory block from the rest of the system.  It is also IMPORTANT to note
 *   that if a Reclaim_Hook_Table is specified, then the memory block will
 *   not be reclaimed UNLESS the RHT_DISABLED bit is also set.  In other
 *   words, if the hooks associated with a block have not been disabled
 *   by the time the system attempts to reclaim the memory (Init_Complete),
 *   then the memory containing those hooks cannot be reclaimed.
 *
 *   RHT_Num_Hooks is the number of hooks to be unhooked/rehooked at
 *   reclaim/restore time, RHT_Low_Seg is the segment of "stub code"
 *   that is always resident, RHT_High_Seg is the segment of "driver code"
 *   that is contained within (or identical to) RIS_Seg, and the entire
 *   Reclaim_Hook_Table is followed by an array of Reclaim_Hook_Entry
 *   structures, which contain pairs of offsets to dword vector addresses
 *   that must be exchanged in order to disable or re-enable the hooks.
 *   For each pair of offsets, the first is relative to RHT_Low_Seg and the
 *   second is relative to RHT_High_Seg.  RHT_Num_Hooks is the number of
 *   Reclaim_Hook_Entry structures in the array.
 *
 *   The system will only unhook all the hooks in a Reclaim_Hook_Table if
 *   RHT_DISABLED bit is set and RHT_UNHOOKED is NOT set in RHT_Flags (meaning
 *   that a Vxd or other component has assumed responsibility for the code
 *   inside the hooks and has not unhooked them itself).
 *
 *   Since the Reclaim_Hook_Table must be inside the segment being reclaimed,
 *   it follows that unhooking will occur before memory reclamation, and that
 *   memory restoration will occur before re-hooking.
 *
 *   VxDs are free to perform their own real-mode vector hooking/unhooking
 *   on their own.  This mechanism is used by the DBLSPACE/DRVSPACE drivers,
 *   and is simply exported as a convenience for other drivers.
 */


/*
 *   Structure for reclaim hook table.
 */
struct Reclaim_Hook_Table {
        WORD    RHT_Num_Hooks;          /* number of RHE entries following */
        WORD    RHT_Low_Seg;            /* segment each RHE_Low_Off is relative to */
        WORD    RHT_High_Seg;           /* segment each RHE_High_Off is relative to */
        WORD    RHT_Flags;              /* see RHT_* equates (below) */
};

#define RHT_DISABLED    0x0001  /* hooks are disabled, can be unhooked now */
#define RHT_UNHOOKED    0x0002  /* hooks are currently unhooked */


/*
 *   Structure for reclaim hook entries.  There are RHT_Num_Hooks copies
 *   of this structure immediately following the Reclaim_Hook_Table.
 */
struct Reclaim_Hook_Entry {
        WORD    RHE_Low_Off;
        WORD    RHE_High_Off;
};


/*
 *   Structure for return RMD API.  See RMD.H for RMD definitions.
 */

struct Return_RMD_Struc {
        DWORD   RRS_RMD;                /* Seg:Off of rmd chain */
        DWORD   RRS_Next_Ptr;           /* Seg:Off of next RMD chain in list */
};

/*
 *   Flags passed to the Win_Kernel_Idle call to indicate state of Windows
 *   in the BX register.
 */
#define Win_Idle_Mouse_Busy     1
#define Win_Idle_Mouse_Busy_Bit 0

/*
 * Structure for TSR <-> Windows communication
 * (W386_TSR_Identify call, AL=0Bh)
 */
struct TSR_Info_Struc {
        DWORD   TSR_Next;
        WORD    TSR_PSP_Segment;
        WORD    TSR_API_Ver_ID;         /* INIT <100h> */
        WORD    TSR_Exec_Flags;         /* INIT <0> */
        WORD    TSR_Exec_Cmd_Show;      /* INIT <0> */
        DWORD   TSR_Exec_Cmd;           /* INIT <0> */
        BYTE    TSR_Reserved[4];        /* INIT <0> */
        DWORD   TSR_ID_Block;           /* INIT <0> */
        DWORD   TSR_Data_Block;         /* INIT <0> */
};

/*
 * TSR_Exec_Flags equates
 */
#define TSR_WINEXEC     1
#define TSR_LOADLIBRARY 2
#define TSR_OPENDRIVER  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\k32rc.h ===
/*
//  K32RC.H
//
//      (C) Copyright Microsoft Corp., 1988-1994
//
//      Resource descriptions
//
//  Origin: Chicago
//
//  Change history:
//
//  Date       Who        Description
//  ---------  ---------  -------------------------------------------------
//  15-Feb-94  JonT       Code cleanup, precompiled headers
*/

#define	rcUndefEntry		1	/* Win32 Undefined Entry Point %s */
#define	rcExecApp		2	/* Win32 Exec App */
#define	rcInvHeader		3	/* %s has invalid DOS EXE header */
#define rcDLLNotFound		4	/* Required DLL %s not found */
#define rcFileNotFound          5       /* Cannot find file */
#define rcCannotCreate          6       /* Cannot create file */
#define rcWin32Caption		7	/* Caption to error box */
#define rcUndefDllStr		8
#define rcUndefDllOrd		9
#define rcCorruptExe		10
#define rcInsufMem		11
#define rcNotReloc		12
#define rcInvalidExe		13
#define rcExeVersion		14
#define rcBadAlignment		15
#define rcInitModule		16
#define rcExeIntel		17

#define	IDS_IGNORE_FAULT        100
#define IDS_ABORT_CAPTION       101
#define IDS_ABORT               102
#define IDS_UNKNOWN_MODULE      103
#define IDS_FAULT               104
#define IDS_BAD_FAULT           105
#define IDS_FAULT_LOAD          106
#define IDS_FAULT_X             107
#define IDS_FAULT_0             108
#define IDS_FAULT_6             109
#define IDS_FAULT_B             110
#define IDS_FAULT_C             111
#define IDS_FAULT_D             112
#define IDS_FAULT_E             113
#define IDS_REGISTER_DUMP1      114
#define IDS_REGISTER_DUMP2      115
#define IDS_REGISTER_DUMP3      116
#define IDS_REGISTER_DUMP4      117
#define IDS_CSEIP_DUMP          118
#define IDS_SSESP_DUMP          119
#define IDS_BYTE                120
#define IDS_WORD                121
#define IDS_DWORD               122
#define	IDS_LOG_FILE_HEADER	123
#define IDS_CAD_CLOSING		124
#define IDS_CAD_HUNG		125
#define IDS_CAD_CAPTION		126
#define IDS_SYSERR_CAPTION	127
#define IDS_SYSERR_PROMPT	128
#define IDS_SEB_CONFIRM		129
#define IDS_FAULT_4             130

//
// Fault Dialog Box Control IDs
//

#define DID_FAULT		1
/*  #define IDOK			1 */
/*  #define IDCANCEL			2 */
    #define IDC_FAULT_MESSAGE		3
    #define IDC_FAULT_DETAILS		4
    #define IDC_FAULT_DEBUG             5
    #define IDC_FAULT_HELP              6
    #define IDC_FAULT_DLGBOTTOM		7
    #define IDC_FAULT_EDIT              8
    #define IDC_FAULT_ICON              9

#define DID_TERM		2
/*  #define IDOK			1 */
/*  #define IDCANCEL			2 */
    #define IDC_TASKLISTBOX     	3
    #define IDC_EXITWINDOWS    		4
    #define IDC_WARNING    		5

#define MAXTASKNAMELEN		80
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\k32share.h ===
/*****************************************************************************
 *  K32SHARE.H
 *
 *      Shared interfaces/information between Kernel16 and Kernel32.
 *
 *      This file must be kept in sync with K32SHARE.INC!
 *
 *  Created:  8-Sep-92 [JonT]
 *
 ****************************************************************************/

/* XLATOFF */

typedef struct tagK16SYSVAR {
    DWORD dwSize;
/*    LCRST Win16Lock; */
    DWORD VerboseSysLevel;
    DWORD dwDebugErrorLevel;
    WORD winVer;
    WORD Win_PDB;
} K16SYSVAR;

typedef	struct _tempstackinfo { /**/
    DWORD si_base;		// base of stack
    DWORD si_top;		// top of stack
    union {
	struct {
	    WORD so_offset;
	    WORD so_segment;
	} si_so;
	DWORD si_segoff;	// use with 'lss sp, si_segoff'
    };
} TEMPSTACKINFO;

/* XLATON */

/*ASM
_TEMPSTACKINFO STRUCT
si_base         dd      ?       ; base of stack
si_top          dd      ?       ; top of stack
si_segoff       dd      ?       ; use with 'lss sp, si_segoff'
_TEMPSTACKINFO ENDS

TEMPSTACKINFO TYPEDEF _TEMPSTACKINFO
 */

#define	STACK_GUARD_QUANTUM	8	// 8 guard pages on growable stacks
#define	STACK_THUNK_SIZE	(STACK_GUARD_QUANTUM * 0x1000)

// IFSMgr table of conversion pointers for Unicode/Ansi/OEM conversion
typedef struct _IFSMGR_CTP_STRUCT { /**/
    DWORD cbCTPCount;           // count of pointers in table
    DWORD pUniToWinAnsiTable;
    DWORD pUniToOEMTable;
    DWORD pWinAnsiToUniTable;
    DWORD pOEMToUniTable;
    DWORD pUniToUpperDelta;
    DWORD pUniToUpperTable;
} IFSMGR_CTP_STRUCT;

// Kernel16->Kernel32 structure passed at init time
typedef struct tagK32STARTDATA { /* sd */
    DWORD dwSize;		// DWORD, structure size
    DWORD hCurTDB;		// DWORD, 16 bit hTask of current task
    DWORD selPSP;		// DWORD, selector of current kernel's PSP
    DWORD lpfnVxDCall;		// 16:16 pointer to DOS386 BP
    DWORD selLDT;		// R/W Selector to LDT
    DWORD pLDT;			// Lin address of LDT (assumes not moveable)
    DWORD dwWinVer;		// Windows version
    DWORD pK16CurTask;		// Points to Kernel16's current task var
    DWORD pWinDir;		// Points to the Windows directory
    DWORD pSysDir;		// Points to the Windows system directory
    WORD wcbWinDir;		// Length of windir (not zero terminated)
    WORD wcbSysDir;		// Length of sysdir (not zero terminated)
#ifndef WOW
    struct _tdb **pptdbCur;	// pointer to current thread pointer
#endif  // ndef WOW
    DWORD Win16Lock;		// ptr to Win16 hierarchical critical section
    DWORD pVerboseSysLevel;	// ptr to Enter/LeaveSysLevel verbosity control
#ifdef WOW
    DWORD Krn32BaseLoadAddr;	// Base address KERNEL32 loaded at
#else
    DWORD ppCurTDBX;            // ptr to current 32 bit TDBX
#endif	// ifdef WOW
    DWORD pThkData;             // ptr to shared thunk data
    K16SYSVAR *pK16SysVar;	// ptr to K16 system variables
    DWORD pHGGlobs;		// ptr to K16 HGGlobs structure
    DWORD pK16CurDosDrive;	// ptr to kernel16's curdosdrive variable
    DWORD pK16CurDriveOwner;	// ptr to kernel16's cur_drive_owner variable
    WORD  wSelBurgerMaster;	// BurgerMaster segment
    WORD  wHeadK16FreeList;	// Head of the k16 global free list
    DWORD lpSelTableStart;	// Ptr to K16 SelTableStart variable
    DWORD lpSelTableLen;	// Ptr to K16 SelTableStart variable
    DWORD pK16HeadTDB;          // ptr to head of the 16-bit TDB list
    DWORD fIsSymDebThere;	// Same as KF_SYMDEB flag in K16.
    struct _tempstackinfo *pTermStack; // ptr to win16 termination stack info
    DWORD pIFSMgrCTPStruct;     // pointer to unicode/ansi conversion table
    DWORD pK16ResHandler;       // 16:16 PELoadResourceHandler
    DWORD pK32LangID;           // flat addr of k32's ulLanguageID
    PULONG pulRITEventPending;	// pointer to RITEventPending variable
    WORD  K32HeapSize;		// max size of kernel32's heap
#ifdef  WOW
    WORD  Unused;
#else   // WOW
    WORD  SystemTickCountDS;    // selector of tick count variable
#endif  // else WOW
    DWORD pcrstGHeap16;         // ptr to k16 global heap critical section
    PVOID pcscr16;		// pointer to 16 bit crst code ranges
    DWORD pwHeadSelman16;       // pointer to head of 16-bit selman list
    DWORD dwIdObsfucator;	// XOR mask for obfuscating pids & tids
    DWORD pDiagFlag;		// ptr to diagnostic logging enabled boolean
    DWORD fNovell;		// ver info of Real Netx (ea00 call)
    DWORD pcrstDriveState;      // drive state for DOS calls
#ifndef WOW
    PVOID lpSysVMHighLinear;    // high linear mapping for low mem
#endif  // ndef WOW
#ifdef  WOW
    PVOID AdrK16WantSetSelector;
    DWORD pK16CurDOSPsp;        // ptr to k16 cur_dos_pdb variable
    DWORD pDOSCurPsp;           // ptr to curr pdb variable in DOS
#endif
} K32STARTDATA;

// Thread Info Block
//  Note that this structure is always contained in the TDB
//  This is the only part of the TDB that is known to apps and to Kernel16
//  
//  This is the NT form.  We must match the marked fields:
//  typedef struct _NT_TIB {
//      struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;   **** match!!!
//      PVOID StackBase;                                        **** match!!!
//      PVOID StackLimit;                                       **** match!!!
//      PVOID SubSystemTib;
//      union {
//          PVOID FiberData;                                    **** match!!!
//          ULONG Version;
//      };
//      PVOID ArbitraryUserPointer;                             ?????
//      struct _NT_TIB *Self;                                   **** match!!!
//  } NT_TIB;
//
// typedef struct _TEB {
//    NT_TIB NtTib;
//    PVOID  EnvironmentPointer;
//    CLIENT_ID ClientId;
//    PVOID ActiveRpcHandle;
//    PVOID ThreadLocalStoragePointer;                          **** match!!!
//    PPEB ProcessEnvironmentBlock;                             **** match!!!
//    ULONG LastErrorValue;
//    UCHAR LastErrorString[NT_LAST_ERROR_STRING_LENGTH];
//    ULONG CountOfOwnedCriticalSections;
//    PVOID Sparea;
//    PVOID Spareb;
//    LCID CurrentLocale;
//    ULONG FpSoftwareStatusRegister;
//    PVOID SystemReserved1[55];
//    PVOID Win32ThreadInfo;
//    PVOID SystemReserved2[337];
//    PVOID CsrQlpcStack;
//    ULONG GdiClientPID;
//    ULONG GdiClientTID;
//    PVOID GdiThreadLocalInfo;
//    PVOID User32Reserved0;
//    PVOID User32Reserved1;
//    PVOID UserReserved[315];
//    ULONG LastStatusValue;
//    UNICODE_STRING StaticUnicodeString;
//    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
//    PVOID DeallocationStack;
//    PVOID TlsSlots[TLS_MINIMUM_AVAILABLE];
//    LIST_ENTRY TlsLinks;
//    PVOID Vdm;
//    PVOID ReservedForNtRpc;
//  } TEB;

typedef struct _TIBSTRUCT { /* tib */
    DWORD pvExcept;             // Head of exception record list
    VOID* pvStackUserLimit;     // Top of user stack
    VOID* pvStackUser;          // Base of user stack
#ifdef WOW
    VOID* pvSubSystemTib;
#else   // WOW
    // Replace SubSystemTib with the following 2 WORDs
    WORD hTaskK16;              // Kernel16 hTask associated with this thread
    WORD ss16;                  // 16-bit stack selector, for 32=>16 thunks
#endif  // else WOW

    PVOID pvFiberData;          // Fiber support macros reference this field
    PVOID pvArbitraryUserPointer;
    struct _TIBSTRUCT *ptibSelf;      // Linear address of TIB structure

#ifdef  WOW
    BYTE  bFiller[4096-7*4-2*2-4-7*4];
    WORD hTaskK16;              // Kernel16 hTask associated with this thread
    WORD ss16;                  // 16-bit stack selector, for 32=>16 thunks
    PVOID   pTDB;
#endif  // def WOW
    WORD flags;                 // TIB flags
    WORD Win16LockVCount;       // Count of thunk virtual locks
    struct _DEBDLLCONTEXT *pcontextDeb; // pointer to debug DLL context record
    DWORD *pCurPri;             // ptr to current priority of this thread
    DWORD dwMsgQueue;		// User's per thread queue dword value
    PVOID *ThreadLocalStoragePointer; // pointer to thread local storage array
    struct _pdb* ppdbProc;      // Used as PID for M3 NT compatibility
    VOID *pvFirstDscr;          // Per-thread selman list.
} TIBSTRUCT;

/* XLATOFF */
typedef TIBSTRUCT TIB;
/* XLATON */

// TIB.flags values
#define	 TIBF_WIN32_BIT	0	// this is a Win32 thread
#define	 TIBF_TRAP_BIT	1	// single step trap in DIT has occured

#define  TIBF_WIN32  (1 << TIBF_WIN32_BIT)
#define	 TIBF_TRAP   (1 << TIBF_TRAP_BIT)


//
//  Critical section code range structure.  Contains the start and end
//  linear addresses of the EnterCrst/LeaveCrst code that can't be 
//  interrupted by ring 0 code.
//

typedef struct _CSCR { /**/
   PVOID cscr_pStart;		// starting linear address of crst code
   PVOID cscr_pEnd;		// ending linear address of crst code
   PVOID cscr_pOK;		// this addr in the above range is ok to be at
   PVOID cscr_pNOP;		// linear address of nop to replace with int 3
} CSCR;

typedef CSCR *PCSCR;

#define	NUM_CSCR_16		6
#define NUM_CSCR_32             4
#define NUM_CSCR		(NUM_CSCR_16 + NUM_CSCR_32)

/* ASM
;
; Macro to convert bit flag to bit number
;

BITNUM  MACRO   bitflag:REQ
    LOCAL bit, bitn, val

    bitn = 0
    bit  = 1
    %val = bitflag

    .errnz val AND (val - 1)    ; multiple bits invalid

    REPEAT 32

        IF (val AND bit) NE 0
            EXITM
        ENDIF

        bitn = bitn + 1
        bit  = bit SHL 1

    ENDM
ifndef  WOW
    .erre bitn - 32             ; no bit defined
endif
    EXITM %bitn
ENDM

 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\krnlcmn.h ===
//---------------------------------------------------------------------------
//
//  KrnlCmn.h
//
//  Include file for common private krnl386/kernel32 APIs.
//
//---------------------------------------------------------------------------

//
//  idProcess can be one of:
//      0L                      --  for current process
//      MAKELONG(hTask, 0)      --  for process with task handle hTask
//      idProcess               --  for real PID
//
//  iIndex is:
//      extra DWORD if >= 0
//      kernel thing if negative
//

#define GPD_PPI                 0       // Going away
#define GPD_FLAGS               -4
#define GPD_PARENT              -8
#define GPD_STARTF_FLAGS        -12     // Can be changed
#define GPD_STARTF_POS          -16
#define GPD_STARTF_SIZE         -20
#define GPD_STARTF_SHOWCMD      -24
#define GPD_STARTF_HOTKEY       -28
#define GPD_STARTF_SHELLDATA    -32
#define	GPD_CURR_PROCESS_ID     -36
#define	GPD_CURR_THREAD_ID      -40
#define	GPD_EXP_WINVER          -44
#define GPD_HINST               -48
#define GPD_HUTSTATE		-52
#define GPD_COMPATFLAGS         -56

#define CW_USEDEFAULT_32    0x80000000
#define CW_USEDEFAULT_16    0x00008000

#ifdef WIN32
#define INDEX   LONG
#define OURAPI  APIENTRY
#else
#define INDEX   int
#define OURAPI  API

#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USEHOTKEY        0x00000200  // ;4.0
#define STARTF_HASSHELLDATA     0x00000400  // ;Internal
#endif

DWORD OURAPI GetProcessDword(DWORD idProcess, INDEX iIndex);
BOOL  OURAPI SetProcessDword(DWORD idProcess, INDEX iIndex, DWORD dwValue);

// 
// For GPD_FLAGS
//
#define GPF_DEBUG_PROCESS   0x00000001
#define GPF_WIN16_PROCESS   0x00000008
#define GPF_DOS_PROCESS     0x00000010
#define GPF_CONSOLE_PROCESS 0x00000020
#define GPF_SERVICE_PROCESS 0x00000100


#undef OURAPI
#undef INDEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\kernel32.inc ===
;*  KERNEL32.INC
;*
;*      (C) Copyright Microsoft Corp., 1988-1994
;*
;*      Main .ASM definitions
;*
;*  Origin: Dos Extender
;*
;*  Change history:
;*
;*  Date       Who        Description
;*  ---------  ---------  -------------------------------------------------
;*  16-Feb-94  JonT       Code cleanup
;*


IFNDEF _KERNEL32_
_KERNEL32_	EQU	1

; Calling Convention for internal
KERNENTRY       TEXTEQU <stdcall>

include k16thk.inc

;=====================================================================
;  Debug macros

WOWDEBUG        EQU     1
IFDEF WOWDEBUG

DEB_FATAL  equ  0
DEB_ERR    equ  1
DEB_WARN   equ  2
DEB_TRACE  equ  3

; VOID
PrintFailedAssertion PROTO KERNENTRY,
	iln:SDWORD,
	szFile:PTR SBYTE

; VOID
vDebugOut PROTO C,
        level:SDWORD,
        pfmt:VARARG

Assert	MACRO cond, disable:=<0>

	;; Define file name if it's not already defined
IFNDEF  szSrcFile
            .DATA
% szSrcFile	BYTE	"&@FileCur", 0
            .CODE
ENDIF

IF  disable
	EXITM
ENDIF

	;; Conditionally invoke function to print data
	.IF !(cond)
	INVOKE  PrintFailedAssertion, @Line, ADDR szSrcFile
	.ENDIF
ENDM

    Break  TEXTEQU <int 3>

ELSE ;IFDEF DEBUG

    Assert MACRO cond
    ENDM

    Break  TEXTEQU <>

ENDIF

MAJOR_VERSION   EQU     1
MINOR_VERSION	EQU	0
WIN_VERSION     EQU     0

VERSION         EQU     WIN_VERSION OR \
			(MAJOR_VERSION SHL 8) OR \
			(MINOR_VERSION SHL 12) OR \
                        (OS SHL 15)

; Path name separators and other values that might be localized.

wNetIni         TEXTEQU <WORD PTR '\\'>
chNetIni	TEXTEQU <BYTE PTR '\'>
chExtSep	TEXTEQU <BYTE PTR '.'>
chDirSep	TEXTEQU <BYTE PTR '\'>
chDirSep2	TEXTEQU <BYTE PTR '/'>
chDrvSep	TEXTEQU <BYTE PTR ':'>
wRelDir         TEXTEQU <WORD PTR '..'>
chRelDir	TEXTEQU <BYTE PTR '.'>
chMinDrv	TEXTEQU <BYTE PTR 'A'>
chMaxDrv	TEXTEQU <BYTE PTR 'Z'>
chMinDrvLow	TEXTEQU <BYTE PTR 'a'>
chMaxDrvLow	TEXTEQU <BYTE PTR 'z'>
chEnvSep	TEXTEQU <BYTE PTR ';'>
chWldChr	TEXTEQU <BYTE PTR '?'>
chWldSeq	TEXTEQU <BYTE PTR '*'>
fbUpper 	EQU	11011111b	    ; Mask converts to uppercase

Unused  MACRO   param
    unuseddummysymbol = SIZEOF param
ENDM

;* Constants

cbPage		EQU	4096
fTrue           EQU     1
fFalse          EQU     0

;* DOS maximum for paths and directories. Add one to each for null.

cbNull		EQU	1

cbDirMax	EQU	260	; \dir\subdir\..\file.ext
cbDrvMax	EQU	3	; c:\
cbNetMax	EQU	36	; \\machine\share
cbCompMax   	EQU	255
cbPathMax	EQU	260
cbCmdMax	EQU	100h - 80h  ; All the room in PSP for command line
cbCopyBufMin	EQU	8000h	; 32K default

; The following is a "magic value" that we use on a number of the NET
; int 21h calls. The reason for this has to do with the way the INT 21
; API mapper in DOSMGR.386 works. For INT 21s from protected mode that
; DOSMGR doesn't understand how to map, all of the segment registers in
; the client structure get set to 0 BY DESIGN. To keep the NET layers
; from getting confused, it needs to KNOW that the call is from WIN32
; and the seg registers should just be ignored (all pointers are FLAT).
; We flag this case by putting this special signature in a 32-bit
; register, usually EBP.
;
MAGICWIN32NETINT21SIG	EQU	41524A44h

;* Wait constants

dwWaitForever	EQU	0FFFFFFFFh
dwWaitNone	EQU	0

PATH_INVALID            EQU     (-1)
DRIVE_NO_ROOT           EQU     1
DRIVE_INVALID           EQU     (-2)
PATH_NETWORK            EQU     2
PATH_ROOT_OR_REL_TO_CURDIR               EQU     1
PATH_RELATIVE           EQU     0

FILE_ATTRIBUTE_VALID_FLAGS	EQU	67h

;* Type definitions

SEL		TYPEDEF WORD
HM		TYPEDEF DWORD

; Type for 16:16 and 16:32 far pointers. We only use these internally.
FPVOID16                TYPEDEF FAR16 PTR
FPVOID                  TYPEDEF FAR32 PTR


; Size of reserved memory region above and below stacks.  Thunks always map
; a 64K stack selector, so we should have 64K reserved above the stack.
STACK_BARRIER_SIZE	EQU	10000h

WIN16_TERMINATION_STACK_SIZE	EQU	2000h

; Register State Context Structure.

REGS			STRUCT	4
  regSS                 DWORD   0
  regGS                 DWORD   0
  regFS                 DWORD   0
  regES                 DWORD   0 
  regDS                 DWORD   0
  regEDI                DWORD   0
  regESI                DWORD   0
  regEBP                DWORD   0
  regESP                DWORD   0
  regEBX                DWORD   0
  regEDX                DWORD   0
  regECX                DWORD   0
  regEAX                DWORD   0
  regEIP                DWORD   0
  regCS                 DWORD   0
  regEFL                DWORD   0
REGS                    ENDS

PREGS			typedef	PTR REGS

; Pointers to structures defined first so they can be used in structures

LPNOD                   TYPEDEF PTR NOD
LPLST                   TYPEDEF PTR LST

NOD			STRUCT	4
  pnodNext              LPNOD   0       ; pointer to the next node in the list
  pnodPrev              LPNOD   0       ; pointer to the previous node in the list
  dwData                DWORD   0       ; data element associated with this node
NOD                     ENDS

LST			STRUCT	4
  pnodHead              LPNOD   0       ; pointer to first node in list
  pnodEnd               LPNOD   0       ; pointer to last node in list
  pnodCur               LPNOD   0       ; pointer to current node in list
LST			ENDS

;  16-bit CreateThread 32->16 thunk data
THREAD_STARTUP_THUNK_DATA STRUCT 4
    Param16		DWORD	0
    StartAddress16	DWORD	0
THREAD_STARTUP_THUNK_DATA ENDS

;* ------------------------------------------------------------ *
;*	If objects are not yet included, include them		*
;* ------------------------------------------------------------ *
IFNDEF typObjAny
  INCLUDE OBJECT.INC
ENDIF

cbKernelHeap  EQU	    262144

; The following bits define the per page status information stored
; in the page info table.  This table is an array of DWORDS, where
; each entry contains info bits for 6 pages (with the high two bits
; not used.

mskPageInfo	EQU	3Fh
mskPageProtect	EQU	0Fh
mskPageType	EQU	30h
mskPageRsv	EQU	10h
mskPageCommit	EQU	20h

; This structure is used to keep track of information about each
; memory allocation that the user makes.

VMHD		STRUCT	4
  pvBase        LPVOID  0       ; base address of the memory block
  cbSize        DWORD   0       ; total size of the memory block
  hmDpmi        DWORD   0       ; DPMI memory handle of the block
  pidOwner	DWORD	0	; process ID of memory block owner
  pbPageInfo    LPSTR   0       ; pointer to page info table for object
  flStatus      WORD    0       ; status flags for the memory block
  fGlobal	WORD	0	; flag for global or virtual APIs
VMHD		ENDS
PVMHD           TYPEDEF PTR VMHD
LPVMHD          TYPEDEF PTR VMHD

; *** Global variables ***

ifdef   WOW
    EXTERNDEF   dwMEOWFlags:DWORD
else    ; WOW
ifdef   MEOW_LOGGING
    EXTERNDEF   dwMEOWFlags:DWORD
endif   ; def MEOW_LOGGING
endif   ; def WOW
	EXTERNDEF	selLDT:SEL
	EXTERNDEF	pLDT:PTR DWORD
	EXTERNDEF	dwDscAddrToRing3Sel:DWORD
	EXTERNDEF	selK32Psp:SEL
	EXTERNDEF	lmaUserBase:LPVOID
	EXTERNDEF	szWinDir:LPSTR, szSysDir:LPSTR
ifndef  WOW
	EXTERNDEF	pppdbCur:PTR LPPDB
	EXTERNDEF	pptdbCur:PTR LPTDB
    EXTERNDEF   ppTDBXCur:PTR PTR TDBX
endif   ; ndef WOW
	EXTERNDEF	ppdbKernel:LPPDB
	EXTERNDEF	ptdbWin16:LPTDB
	EXTERNDEF	ptdbSvc:LPTDB
	EXTERNDEF	bBeepControl:BYTE
	EXTERNDEF	Win16Lock:PTR LCRST
	EXTERNDEF	Krn32Lock:PTR LCRST
	EXTERNDEF	selFlatCode:USHORT
	EXTERNDEF	selFlatData:USHORT

;* Function Prototypes

;* THKINIT.ASM

; VOID
ThkInit PROTO KERNENTRY

;* DXKRNL.C

; LPVOID
PvKernelAlloc PROTO KERNENTRY,
	cbSize:DWORD

; VOID *
PvKernelRealloc PROTO KERNENTRY,
        pvMem:LPVOID,
        cbSize:DWORD

; VOID
FKernelFree PROTO KERNENTRY,
        pvMem:LPVOID

; LONG
KernelInit PROTO KERNENTRY,
	pK32Data:DWORD

;VOID
KernelUninit PROTO KERNENTRY

;* KRNLUTIL.ASM

; VOID
FillBytes PROTO KERNENTRY,
        pbDst:LPSTR,
        cb:DWORD,
        bData:DWORD

; DWORD
CbSizeSz PROTO KERNENTRY,
        szStr:LPSTR

; VOID
CopySz PROTO KERNENTRY,
        szDst:LPSTR,
        szSrc:LPSTR

; VOID
AppendSz PROTO KERNENTRY,
        szDst:LPSTR,
        szSrc:LPSTR

; VOID
LCompareSz PROTO KERNENTRY,
        sz1:LPSTR,
        sz2:LPSTR

; VOID
LCompareNSz PROTO KERNENTRY,
        sz1:LPSTR,
        sz2:LPSTR,
	n:DWORD

; VOID
dputs PROTO KERNENTRY,
	sz:LPSTR

; VOID
KInt21 PROTO KERNENTRY

; DWORD
FGetSelBase PROTO KERNENTRY,
        selGet:WORD

;* HEAPMGR.C

; HANDLE
HheapCreateHeap PROTO KERNENTRY,
	flOptions:DWORD,
	cbInitialSize:DWORD,
	cbMaxSize:DWORD

; VOID
HeapInit PROTO KERNENTRY,
	pbHeap:LPVOID,
	flOptions:DWORD,
	cbInitialSize:DWORD,
	cbMaxSize:DWORD

; BOOL
FHeapDestroy PROTO KERNENTRY,
	hheap:HANDLE

; LPVOID
PvAllocHeapMem PROTO KERNENTRY,
	hheap:HANDLE,
	cbSize:DWORD

; LPVOID
PvResizeHeapMem PROTO KERNENTRY,
	hheap:HANDLE,
	pvMem:LPVOID,
	cbNew:DWORD

; BOOL
FFreeHeapMem PROTO KERNENTRY,
	hheap:HANDLE,
	pvMem:LPVOID

; DWORD
CbSizeHeapMem PROTO KERNENTRY,
	hheap:HANDLE,
	pvMem:LPVOID

;* IOUTIL.ASM
DFH_FILE_CREATE             EQU     0010h
DFH_FILE_OPEN               EQU     0001h
DFH_FILE_TRUNCATE           EQU     0002h
DFH_ACTION_OPENED           EQU     0001h
DFH_ACTION_CREATED_OPENED   EQU     0002h
DFH_ACTION_REPLACED_OPENED  EQU     0003h
DFH_MODE_READONLY           EQU     0000h
DFH_MODE_WRITEONLY          EQU     0001h
DFH_MODE_READWRITE          EQU     0002h
DFH_MODE_SHARE_COMPATIBILITY EQU    0000h
DFH_MODE_SHARE_EXCLUSIVE    EQU     0010h
DFH_MODE_SHARE_DENYWRITE    EQU     0020h
DFH_MODE_SHARE_DENYREAD     EQU     0030h
DFH_MODE_SHARE_DENYNONE     EQU     0040h
DFH_MODE_NO_INHERIT         EQU     0080h
DFH_MODE_EXTENDED_SIZE      EQU     1000h
;   DfhOpenFile
;   FCloseFile
;   CbReadFile
;   CbWriteFile
;   CbWriteOutFile
;   LfoSetFilePos

; DWORD
GetDOSExtendedError PROTO KERNENTRY

;* PROCESS.C

;BOOL
CreateProcessKernel	PROTO KERNENTRY, :PTR, :PTR, :PTR, :WORD, :PTR, :PTR
;VOID
TerminateProcessKernel	PROTO KERNENTRY
;VOID
ExitCurrentProcess	PROTO KERNENTRY, :DWORD
;VOID
TerminateProcessOutOfContext PROTO KERNENTRY, ppdb:PTR, dwStatus:DWORD
;VOID
TerminateProcessFinal	PROTO KERNENTRY, ppdb:PTR
;VOID
DisposePDB		PROTO KERNENTRY, ppdb:PTR
;PDB*
NewPDB			PROTO KERNENTRY, ppdbParent:PTR
;void*
MemToHeap		PROTO KERNENTRY, hheap:HANDLE, buf:PTR, len:DWORD
;char*
StrToHeap		PROTO KERNENTRY, hheap:HANDLE, pstr:PTR
;DWORD
CbSizeEnv		PROTO KERNENTRY, :PTR, :WORD
;BOOL
FFindEnvVar		PROTO KERNENTRY, :PTR, :PTR, :PTR
;DWORD
SetPSP			PROTO KERNENTRY, :DWORD
;DWORD
GetPSP			PROTO KERNENTRY

;VOID
GlobalHandleSwitchToK32PSP PROTO KERNENTRY, :HANDLE, :LPDWORD
;VOID
GlobalHandleRestorePSP	PROTO KERNENTRY,  :DWORD

;* thread.c

;void
SetError		PROTO KERNENTRY, dwError:DWORD


; BUGBUG [KevinR] 14-Apr-1993
;       This control-handler stuff is console-specific and should be
;       separately included with wincon.inc.

;*	Interface Definitions for control handlers (BREAK.C)

; Control constants for CONTROL+C and CONTROL+BREAK

ctrlC		EQU	0
ctrlBreak	EQU	1
ctrlNone	EQU	10
ctrlInactive	EQU	20
ctrlTerminate	EQU	30

; Number of control handlers initially and for each new allocation

cbCtrlInc   EQU     8

; typedef VOID (KERNENTRY *PFN_CONTROL)(DWORD CtrlType);
PFN_CONTROL TYPEDEF PTR
CONTROL_HANDLER              TYPEDEF         PROTO STDCALL :DWORD
PCONTROL_HANDLER                TYPEDEF         PTR CONTROL_HANDLER

; Function Prototypes

; VOID
ControlHandlerThread PROTO KERNENTRY

; BOOL
FInitControlHandlers PROTO KERNENTRY :LPPDB

; VOID
DestroyControlHandlers PROTO KERNENTRY :LPPDB

; BOOL
FUpdateControlList PROTO KERNENTRY :LPPDB, :PCONTROL_HANDLER, :BOOL

; VOID
DoControlHandlers PROTO KERNENTRY :DWORD

; VOID

SwitchToControlThread PROTO KERNENTRY pedb:LPPDB, idControl:WORD

;*	Interface Definitions for LE Loader (LELDR.C)			*/

; BOOL
FInitModuleMgr PROTO KERNENTRY

; BOOL
FLoadKernelModule PROTO KERNENTRY,
        :LPPDB,
        :LPSTR

; BOOL
FLoadProgram PROTO KERNENTRY,
        :LPPDB,
        :LPSTR,
        :LPWORD

; BOOL
FLoadLibrary PROTO KERNENTRY,
        :LPPDB,
        :LPSTR,
        :LPWORD

; BOOL
FFreeModule PROTO KERNENTRY,
        :LPPDB,
        :WORD

; BOOL
RemoveProcessImte PROTO KERNENTRY,
        :LPPDB,
        :WORD

; char *
SzFileFromImte PROTO KERNENTRY,
        :WORD

; char *
SzFromImte PROTO KERNENTRY,
        :WORD

; VOID
FreeUnusedModules PROTO KERNENTRY,
        :LPLST

; SHORT
ImteFromSz PROTO KERNENTRY,
        :LPSTR

; SHORT
ImteFromFileSz PROTO KERNENTRY,
        :LPSTR


; BOOL
FGetProcAddr PROTO KERNENTRY,
        imte:SWORD,
        pvName:LPVOID,
        ppvProc:PTR LPVOID

;* DIRUTIL.C

AO_IN    equ    0
AO_OUT   equ    1
AO_INOUT equ    2

AO_CONV_ANSI	equ	0
AO_NO_CONV	equ	1

;LPSTR 
EnterResolveOemToAnsi PROTO KERNENTRY,
	szName:LPSTR, 
	fInOut:DWORD 
;VOID 
LeaveResolveOemToAnsi PROTO KERNENTRY,
	szSrcDest:LPSTR,
	fInOut:DWORD
;VOID 
LeaveResolveOemToAnsiEx PROTO KERNENTRY,
	szSrc:LPSTR,
	szDest:LPSTR,
	nSize:DWORD,
	fInOut:DWORD
;BOOL 
MarkOemToAnsiDone PROTO KERNENTRY,
	fNoConversion:DWORD
;VOID 
UnMarkOemToAnsiDone PROTO KERNENTRY

;* PROCUTIL.ASM

; VOID
ThreadTerminationHandler PROTO KERNENTRY

; BOOL
FBuildEnvArgs PROTO KERNENTRY,
	selPsp:SEL,
        pszProgName:PTR LPSTR,
        pszCmdLine:PTR LPSTR,
	ppchEnv:PTR LPSTR

; DWORD
CbSearchPath PROTO KERNENTRY,
        lpPath:LPSTR,
        lpFileName:LPSTR,
        lpExtension:LPSTR,
        nBufferLength:DWORD,
        lpBuffer:LPSTR,
        lpFilePart:PTR LPSTR

; BOOL
FIsDir	PROTO KERNENTRY,
        lpDirPath:LPSTR

; LONG
LValidateSecurity PROTO KERNENTRY,
	lpSecurity:LPSECURITY_ATTRIBUTES

; LONG
LStrCmpI PROTO KERNENTRY,
        sz1:LPSTR,
        sz2:LPSTR

; LPSTR
SzGetNamePos PROTO KERNENTRY,
	lpPath:LPSTR

; BOOL
FGetFileInfo PROTO KERNENTRY,
        szName:LPSTR,
        fsAttrib:DWORD,
        lpFindFileData:LPWIN32_FIND_DATA

; DWORD
CbAppendExt PROTO KERNENTRY,
	szName:LPSTR,
	szExt:LPSTR,
	cbBuf:DWORD

; BOOL
FFixPathChars PROTO KERNENTRY,
	szPath:LPSTR

; DWORD
CbStrUpr PROTO KERNENTRY,
	lpString:LPSTR

; VOID
BeepOff PROTO KERNENTRY,
	bControl:BYTE

; DWORD
GetPathType PROTO KERNENTRY,
	szPath:LPSTR

; ULONG
GetLongName PROTO KERNENTRY lpFileName:LPCSTR, lpBuffer:LPSTR, cbBuffer:ULONG

; ULONG
GetShortName PROTO KERNENTRY lpFileName:LPCSTR, lpBuffer:LPSTR, cbBuffer:ULONG

;* PROCUTIL.ASM - Internal register based functions

; EDI (LPSTR)
FindEnvVar PROTO KERNENTRY
        ; EDI (LPSTR)

; EAX (LPSTR) and CARRY
StrToBuffer PROTO KERNENTRY
        ; ESI (LPSTR)
        ; EDI (LPSTR)
        ; ECX (DWORD)

; DWORD
CheckDrive PROTO KERNENTRY
        ; EAX (DWORD)

; BOOL
ValidateDrive PROTO KERNENTRY,
        Drive:DWORD

; BOOL
IsDriveFixed PROTO KERNENTRY,
	Drive:DWORD

; DWORD
GetEnvDir PROTO KERNENTRY
	; EDI (LPSTR)
	; ESI (LPSTR)
	; ECX (DWORD)

; Carry
FcExistFile PROTO KERNENTRY
	; ESI

; VOID
SzStrCpy  PROTO KERNENTRY
        ; ESI (LPSTR)
        ; EDI (LPSTR)

; VOID
SzStrCat  PROTO KERNENTRY
        ; ESI (LPSTR)
        ; EDI (LPSTR)

; LPSTR
StrScan PROTO KERNENTRY
        ; EDI (LPSTR)
        ; AL (BYTE)

; LPSTR
StrRScan PROTO KERNENTRY
        ; EDI (LPSTR)
        ; ESI (LPSTR)
        ; AL (BYTE)

;* DIRUTIL.C

; DWORD
CbGetCurDir PROTO KERNENTRY,
        :DWORD,
	:LPSTR

; BOOL
FSetCurDir PROTO KERNENTRY,
        :LPSTR

; DWORD
FMakeFullName PROTO KERNENTRY,
	:LPSTR,
	:LPSTR,
	:LPSTR

; DWORD
DwMakeFullPath PROTO KERNENTRY,
	:LPSTR,
	:LPSTR,
	:LPDWORD,
	:PTR LPSTR

; DWORD
FNextFromDirList PROTO KERNENTRY,
	:PTR LPSTR,
	:LPSTR,
	:LPSTR,
	:LPSTR

; LPSTR
PchGetNetDir PROTO KERNENTRY,
	pch:LPSTR


; KRNINIT.ASM

; BOOL
FGetMediaData PROTO KERNENTRY,
        bDrive:BYTE,
        pvMedia:LPVOID

; VOID
SetCritErrAction PROTO KERNENTRY,
	fFail:WORD

; BOOL
FGetCritErr PROTO KERNENTRY

; DWORD
IdGetClearCritErr PROTO KERNENTRY

; VOID
SetCritErrId PROTO KERNENTRY,
	id:WORD

; DWORD
IdGetControl PROTO KERNENTRY

; VOID
SetControlId PROTO KERNENTRY,
	id:SWORD

; WORD
IdWindows PROTO KERNENTRY

;* FILEHOPS.ASM

; BYTE
ReadChar PROTO KERNENTRY,
	fEcho:BOOL

; DWORD
ReadLine PROTO KERNENTRY,
        lpBuffer:LPSTR,
        cbBuffer:DWORD


;* CTIME.C

; BOOL
FileTimeToDosDateTimeEx PROTO KERNENTRY,
	:PTR,
	:LPWORD,
	:LPWORD,
	:LPWORD


; BOOL
DosDateTimeToFileTimeEx PROTO KERNENTRY,
	:WORD,
	:WORD,
	:WORD,
	:PTR

; ** Utility Macros

; Performance tricks for loading and comparing zero

; Load a register with zero
movz  MACRO reg
    sub   reg, reg
ENDM

; Load a register with -1
movn1 MACRO reg, kind
    IFIDNI <kind>,<small>       ; Small
    sub   reg, reg              ;   2 bytes, 2 clocks
    dec   reg                   ;   1 byte, 2 clocks
    ELSE                        ; Fast
    mov   reg, -1               ;   5 (eax), 4 (ax), 2 (al) bytes, 2 clocks
    ENDIF
ENDM

; Load a register with 1
mov1 MACRO reg, kind
    IFIDNI <kind>,<small>       ; Small
    sub   reg, reg              ;   2 bytes, 2 clocks
    inc   reg                   ;   1 byte, 2 clocks
    ELSE                        ; Fast
    mov   reg, 1                ;   5 (eax), 4 (ax), 2 (al) bytes, 2 clocks
    ENDIF
ENDM

; Compare a register to zero
cmpz  MACRO reg
    or    reg, reg
ENDM

; Drive letter macros
DriveNumToLet MACRO regmem
    IF    ((OPATTR regmem) AND 010y) OR ((OPATTR regmem) AND 010000y)
        add   regmem, 'A'
    ELSE
        .ERR <Must be register or memory>
    ENDIF
ENDM

DriveLetToNum MACRO regmem
    IF    ((OPATTR regmem) AND 010y) OR ((OPATTR regmem) AND 010000y)
        sub   regmem, 'A'
    ELSE
        .ERR <Must be register or memory>
    ENDIF
ENDM

; Localized versions of these may be different.
Upper MACRO regmem
    IF    ((OPATTR regmem) AND 010y) OR ((OPATTR regmem) AND 010000y)
        and     regmem, 11011111y       ; Convert letter to upper case
    ELSE
        .ERR <Must be register or memory>
    ENDIF
ENDM

Lower MACRO regmem
    IF    ((OPATTR regmem) AND 010y) OR ((OPATTR regmem) AND 010000y)
        or      regmem, 00100000y       ; Convert letter to lower case
    ELSE
        .ERR <Must be register or memory>
    ENDIF
ENDM

ErrSet MACRO ecode
    IFIDNI <ecode>, <ax>
	movzx  eax, ax
	INVOKE SetError, eax
    ELSE
	INVOKE SetError, ecode
    ENDIF
ENDM

; Macros to push and pop register lists
pushes MACRO reglist:VARARG
    FOR reg, <reglist>
	push	reg
    ENDM
ENDM

pops MACRO reglist:VARARG
    LOCAL regs
    regs TEXTEQU <>
    FOR reg, <reglist>
        regs CATSTR <reg>, regs
        regs CATSTR <,>, regs
    ENDM
    regs SUBSTR regs, 2
    regs CATSTR <!<>, regs, <!>>
%   FOR reg, regs
        pop reg
    ENDM
ENDM

; Macros for start and end of each API call

  INCLUDE APITRACE.INC

ifdef	DEBUG

ApiEnterTrace  PROTO KERNENTRY, ApiNumber:DWORD

api_entry MACRO	ApiNumber:REQ

	invoke	ApiEnterTrace, ApiNumber

ENDM

else

api_entry MACRO ApiNumber:REQ
ENDM

endif

api_exit MACRO ApiNumber:REQ
ENDM

;* These are values that are passed to PnodGetLstElem to tell it
;* which element to return from the list.
;/

idLstGetFirst	=	0	    ;* get first element of list */
idLstGetNext	=	1	    ;* get next element of the list */
idLstGetPrev	=	2	    ;* get the previous element of the list */
idLstGetLast	=	4	    ;* get the last element of the list */


;* These are values that are passed to AddListElem to tell it where
;* to put an element being added to the list.
;/

idLstAddFirst	=	0	    ;* add at the head of the list */
idLstAddCur	=	1	    ;* add at the current position in the list */

AddLstElem	PROTO	KERNENTRY , :PTR LST, :PTR NOD, :DWORD
PnodGetLstElem	PROTO	KERNENTRY , :PTR LST, :DWORD
PnodRemoveLstElem   PROTO	KERNENTRY , :PTR LST
FIsLstEmpty	PROTO	KERNENTRY,  :PTR LST

;** Macro to get current TDBX pointer
GetCurrentTDBX	MACRO reg
ifdef   WOW
        assume  fs:nothing
ifb <reg>
        mov     eax, fs:[TIBSTRUCT.tib_pTDB]
        mov     eax, [eax].TDB.ptdbx
else
        mov     reg, fs:[TIBSTRUCT.tib_pTDB]
        mov     reg, [reg].TDB.ptdbx
endif
else    ; WOW
ifb <reg>
	mov	eax, [ppTDBXCur]
	mov	eax, [eax]
else
	mov	reg, [ppTDBXCur]
	mov	reg, [reg]
endif
endif   ; else WOW
ENDM

;** Macros to get current TDB pointer and current PDB pointer
GetCurrentTDB	MACRO reg
ifdef   WOW
        assume  fs:nothing
ifb <reg>
        mov     eax, fs:[TIBSTRUCT.tib_pTDB]
else
        mov     reg, fs:[TIBSTRUCT.tib_pTDB]
endif
else    ; WOW
ifb <reg>
	mov	eax, [pptdbCur]
	mov	eax, [eax]
else
	mov	reg, [pptdbCur]
	mov	reg, [reg]
endif
endif   ; else WOW
ENDM

GetCurrentPDB	MACRO reg
ifdef   WOW
        assume  fs:nothing
ifb <reg>
        mov     eax, fs:[TIBSTRUCT.tib_pTDB]
        mov     eax, [eax].TDB.ptib
        mov     eax, [eax].TIBSTRUCT.tib_ppdbProc
else
        mov     reg, fs:[TIBSTRUCT.tib_pTDB]
        mov     reg, [reg].TDB.ptib
        mov     reg, [reg].TIBSTRUCT.tib_ppdbProc
endif
else    ; WOW
ifb <reg>
	mov	eax, [pppdbCur]
	mov	eax, [eax]
else
	mov	reg, [pppdbCur]
	mov	reg, [reg]
endif
endif   ; else WOW
ENDM

;=====================================================================
;  Synchronization routines (SYNC.C)

IFNDEF typObjAny
  INCLUDE OBJECT.INC
ENDIF

; BOOL
bDeliverPendingAPCs PROTO KERNENTRY ;:VOID

; DWORD
BlockThreadEx PROTO KERNENTRY :DWORD, :BOOL

; DWORD
dwWaitMultipleObjects PROTO KERNENTRY :DWORD, :LPOBJ, :DWORD, :DWORD, :BOOL

; DWORD
dwWaitSingleObject PROTO KERNENTRY :LPOBJ, :DWORD, :BOOL

; VOID
DisposeSyncObj PROTO KERNENTRY	:LPSYNCO

; LPSEM
NewPsem PROTO KERNENTRY :DWORD, :DWORD

; BOOL
bReleasePsem PROTO KERNENTRY :LPSEM, :DWORD, :LPLONG

; LPEVT
NewPevt PROTO KERNENTRY :DWORD, :DWORD

; BOOL
bSetPevt PROTO KERNENTRY :LPEVT

; BOOL
bPulsePevt PROTO KERNENTRY :LPEVT

; BOOL
bResetPevt PROTO KERNENTRY :LPEVT

; LPMUTX
NewPmutx PROTO KERNENTRY :DWORD

; BOOL
bReleasePmutx PROTO KERNENTRY :LPMUTX

; VOID
InitCrst PROTO KERNENTRY :LPCRST

; VOID
DestroyCrst PROTO KERNENTRY :LPCRST

; LPNSOBJ
NewNsObject PROTO KERNENTRY :DWORD, :BYTE

; VOID
DisposeNsObject PROTO KERNENTRY :LPNSOBJ

; BOOL
LockMustComplete PROTO KERNENTRY :LPTDB

; VOID
UnlockMustComplete PROTO KERNENTRY :LPTDB


;=====================================================================
; Exception management (EXCEPTC.C, EXCEPTA.ASM)

ExceptStruct	struct	4
SegGs		dd	?
SegFs		dd	?
SegEs		dd	?
SegDs		dd	?
rgEdi		dd	?
rgEsi		dd	?
rgEbp		dd	?
rgEspTmp	dd	?
rgEbx		dd	?
rgEdx		dd	?
rgEcx		dd	?
rgEax		dd	?
dwExceptNum	dd	?
rgRetEip	dd	?
SegRetCs	dd	?
dwErrorCode	dd	?
rgEip		dd	?
SegCs		dd	?
rgEflags	dd	?
rgEsp		dd	?
SegSs		dd	?
ExceptStruct	ends

IEE	struct	4

dwExceptionNum		dd	?
rgRegisters		ExceptStruct	<>

IEE	ends
PIEE	typedef	 PTR IEE

PIeeNew PROTO C

ExceptDispatch PROTO C

NtRaiseException PROTO C,
	ExceptionRecord:LPEXCEPTION_RECORD,
	ContextRecord:LPCONTEXT,
	FirstChance:BOOL

NtContinue PROTO C,
	ContextRecord:LPCONTEXT,
	TestAlert:BOOL

ZwContinue PROTO C,
	ContextRecord:LPCONTEXT,
	TestAlert:BOOL

ZwRaiseException PROTO C,
	ExceptionRecord:LPEXCEPTION_RECORD,
	ContextRecord:LPCONTEXT,
	FirstChance:BOOL


FreePiee    PROTO C,
	piee:DWORD


;=====================================================================
;  Device object management (DEVICE.C)

; FDB *
PfdbNew PROTO KERNENTRY

; PIPDB *
PpipedbNew PROTO KERNENTRY,
	pipszbyts:DWORD,
	IsNmPipe:BOOL

; MSDB *
PmsdbNew PROTO KERNENTRY

; SDB *
PsdbNew PROTO KERNENTRY

; TLHPDB*
PtlhpdbNew PROTO KERNENTRY

; VOID
DisposePtlhpdb PROTO KERNENTRY,
	:PTR TLHPDB

; VOID
DisposePfdb PROTO KERNENTRY,
	:PTR FDB

; VOID
DisposePmsdb PROTO KERNENTRY,
	:PTR MSDB

; VOID
DisposePsdb PROTO KERNENTRY,
	:PTR SDB

; VOID
DisposePpipedb PROTO KERNENTRY,
	:PTR PIPDB

; HANDLE
hSerialNew PROTO KERNENTRY,
	ppdb:PTR SDB,
	handle:DWORD,
	DevNode:DWORD


;; OFSTRUCTEX has a word cBytes instead of a BYTE in OFSTRUCT
;; OpenFileEx16And32 uses this structure for support of OpenFile with
;; LFN support. The Win32 OpenFile calls this and has a wrapper to
;; ensure that we still have a Win32 API that has OFS_MAXPATHNAME of 128.
OFSTRUCTEX struct 1
	cBytes		dw	?
	fFixedDisk	db	?
	nErrCode	dw	?
	Reserved1	dw	?
	Reserved2	dw	?
	szPathName	db	MAX_PATH DUP (?)
OFSTRUCTEX ends



ENDIF	; _KERNEL32_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\kernel32.h ===
//  KERNEL32.H
//
//	(C) Copyright Microsoft Corp., 1988-1994
//
//	Main Kernel32 include file
//
//  Origin: Dos Extender
//
//  Change history:
//
//  Date       Who	  Description
//  ---------  ---------  -------------------------------------------------
//  Jan-91 - Mar-92 GeneA Original Languages Dos Extender work
//  15-Feb-94  JonT	  Code cleanup and precompiled headers

#ifndef __KERNEL32_H
#define __KERNEL32_H

// So that RTL functions don't have declspec import
#ifdef _KERNEL32_
#define _NTSYSTEM_
#endif

// If NT.H was included, we have to undefine some stuff to prevent
// refinitions
#undef MAJOR_VERSION
#undef MINOR_VERSION
#undef FILE_ATTRIBUTE_VALID_FLAGS

#ifndef WOW32_EXTENSIONS
// Include the Win32 windows.h to get all standard definitions
#include <windows.h>

#undef RtlMoveMemory
#undef RtlCopyMemory

// Following is defined in winnt.h only if nt.h is not included.
#ifndef MAXDWORD
#define MAXDWORD MAXULONG
#endif

// These APIs are doc'd to be exported from user32, but we implement them
// in kernel32.  Rename them so we don't get a prototype declaration type
// conflict, due to the non-definition of _USER32_ making them be of type
// import.
#define wsprintfA k32wsprintfA
int WINAPIV wsprintfA( LPSTR lpOut, LPCSTR lpFmt, ...);
#define wvsprintfA k32wvsprintfA
int WINAPI wvsprintfA( LPSTR, LPCSTR, va_list arglist);
#define LoadStringA k32LoadStringA
int WINAPI LoadStringA( HINSTANCE hInstance, UINT uID,
                        LPSTR lpBuffer, int nBufferMax);

#endif	 // ndef WOW32_EXTENSIONS

//====================================================================
// General definitions

#define LOCAL
#define GLOBAL
#ifndef KERNENTRY
#define KERNENTRY   __stdcall
#endif

#define cbPage		4096

#define fTrue		1L
#define fFalse		0L

typedef WORD SEL;
#define IMTE short

// Wait constants
#define dwWaitForever	0xffffffff
#define dwWaitNone	0

#define dwAbort		0xffffffff
#define dwInvalid	0xffffffff

#include <k16thk.h>

#ifndef WOW32_EXTENSIONS

/*XLATOFF*/
#ifdef	WOW
#include <wh.h>
#endif	// def WOW
/*XLATON*/

typedef DEBUG_EVENT*	PDE;

#ifdef  MEOW_LOGGING

VOID WDEBLogDebugString(char *, ...);

#endif  // def MEOW_LOGGING

//====================================================================
// Debug macros

#define WOWDEBUG

#ifdef  WOWDEBUG

VOID ApiEnterTrace(DWORD ApiNumber);

#define api_entry(ApiNumber)	ApiEnterTrace(ApiNumber);

#else

#define api_entry(ApiNumber)

#endif

#define api_exit(ApiNumber)

#ifdef	WOWDEBUG
int	__cdecl     dprintf(const char *, ...);
#define dprintf(s)	dprintf##s
#else
#define dprintf(s)
#endif

GLOBAL	VOID	KERNENTRY   PrintFailedAssertion(int, char *);
GLOBAL	VOID	KERNENTRY   vDebugOut(int level, const char *pfmt, ...);

#ifdef	WOWDEBUG

#define Break()			{ _asm _emit 0xcc }
#ifndef IS_VXD
#define Trap()			{ _asm { _emit 0xcc } }
#define TrapC(c)		{ if (c) { Trap() } }
#endif

#ifdef IS_VXD

#define SetFile() \
    static char __szSrcFile[] = __FILE__; \
    static char __szAssert[] = "Assertion failed:  Line %d File %s";

#define Assert(cond) \
    if (!(cond)) {\
	Debug_Printf(__szAssert,__LINE__,__szSrcFile);\
	Trap(); \
    }

#else

#define SetFile() \
    static char __szSrcFile[] = __FILE__;

#define Assert(cond) \
    if (!(cond)) {\
	PrintFailedAssertion(__LINE__,__szSrcFile);\
    }

#endif

// Used to assert the return code of a function
#define AssertReturn		Assert

#define DebugMsg(sz) dputs(sz)
#define DebugOut(args) vDebugOut args

#define LogMsg(sz) dprintf(((sz "\n")))
#define LogMsgI(sz,I) dprintf(((sz "%d\n",I)))
#define LogMsgX(sz,i) dprintf(((sz "0x%lX\n",i)))
#define LogMsgSz(sz,szData) dprintf(((sz "%s\n",szData)))
#define LogMsgP(args) dprintf((args))
#define LogFailure()  LogMsgI("On " __FILE__ " Failure Path line ", __LINE__)
#define HeapCheck() if (!hpWalk(hheapKernel)) _asm int 3

#else

#define Break()
#ifndef IS_VXD
#define Trap()
#define TrapC(c)
#endif
#define Assert(cond)
#define AssertReturn
#define DebugMsg(sz)
#define DebugOut(args)
#define LogMsg(sz)
#define LogMsgI(sz,i)
#define LogMsgX(sz,i)
#define LogMsgSz(sz,szData)
#define LogMsgP(args)
#define LogFailure()
#define HeapCheck()

#endif

enum { DEB_FATAL, DEB_ERR, DEB_WARN, DEB_TRACE };

#endif	 // ndef WOW32_EXTENSIONS

//====================================================================
// File and path definitions

#define		chExtSep	'.'
#define		szExtSep	"."
#define		chNetIni	'\\'
#define		chDirSep	'\\'
#define		szDirSep	"\\"
#define		chDirSep2	'/'
#define		chDrvSep	':'
#define		chRelDir	'.'
#define		chEnvSep	';'
#define		chWldChr	'?'
#define		chWldSeq	'*'
#define		chMinDrv	'A'
#define		chMaxDrv	'Z'
#define		chMinDrvLow	'a'
#define		chMaxDrvLow	'z'
#define		fbUpper		0xdf	    // Mask converts to uppercase

#define cbNull	    1
#define cbDirMax    260		    /* \dir\subdir\..\file.ext */
#define cbDrvMax    3		    /* c:\	*/
#define cbNetMax    36		    /* \\machine\share */
#define cbCompMax   255		    /* should be same as namemax? */
#define cbPathMax   260
#define cbCmdMax    (0x100 - 0x80)  /* All the room in PSP for command line */

// The following is a "magic value" that we use on a number of the NET
// int 21h calls. The reason for this has to do with the way the INT 21
// API mapper in DOSMGR.386 works. For INT 21s from protected mode that
// DOSMGR doesn't understand how to map, all of the segment registers in
// the client structure get set to 0 BY DESIGN. To keep the NET layers
// from getting confused, it needs to KNOW that the call is from WIN32
// and the seg registers should just be ignored (all pointers are FLAT).
// We flag this case by putting this special signature in a 32-bit
// register, usually EBP.
//
#define MAGICWIN32NETINT21SIG	0x41524A44

// OFSTRUCTEX has a word cBytes instead of a BYTE in OFSTRUCT
// OpenFileEx16And32 uses this structure for support of OpenFile with
// LFN support. The Win32 OpenFile calls this and has a wrapper to
// ensure that we still have a Win32 API that has OFS_MAXPATHNAME of 128.
typedef struct tagOFSTRUCTEX {
    WORD	cBytes;
    BYTE	fFixedDisk;
    WORD	nErrCode;
    WORD	Reserved1;
    WORD	Reserved2;
    BYTE	szPathName[cbPathMax];
} OFSTRUCTEX;
typedef OFSTRUCTEX *LPOFSTRUCTEX;

#define FA_VALID_FLAGS	0x67

//====================================================================
// Linked lists

typedef struct _nod
{
    struct _nod *   pnodNext;	    /* pointer to the next node in the list */
    struct _nod *   pnodPrev;	    /* pointer to the previous node in the list */
    DWORD	    dwData;	    /* data element associated with this node */
} NOD;

typedef struct _lst
{
    NOD *	pnodHead;	    /* pointer to first node in list */
    NOD *	pnodEnd;	    /* pointer to last node in list */
    NOD *	pnodCur;	    /* pointer to current node in list */
} LST;

// These are values that are passed to PnodGetLstElem to tell it
// which element to return from the list.

#define idLstGetFirst	0	    /* get first element of list */
#define idLstGetNext	1	    /* get next element of the list */
#define idLstGetPrev	2	    /* get the previous element of the list */
#define idLstGetLast	4	    /* get the last element of the list */
#define idLstGetCur	5	    /* return the current element of the list */

// These are values that are passed to AddListElem to tell it where
// to put an element being added to the list.

#define idLstAddFirst	0	    /* add at the head of the list */
#define idLstAddCur	1	    /* add at the current position in the list */
#define idLstAddLast	2	    /* add at the end of the list */

// These are the values that are passed to PnodFindLstElem to tell it
// how to search for the requested list element.

#define idLstFindFirst	0
#define idLstFindNext	1
#define idLstFindPrev	2
#define idLstFindLast	3

#ifndef WOW32_EXTENSIONS

LST*	KERNENTRY	PlstNew(LST *);
VOID	KERNENTRY	FreePlst(LST *);
VOID	KERNENTRY	DestroyPlst(LST *);
NOD*	KERNENTRY	PnodNew(VOID);
VOID	KERNENTRY	FreePnod(NOD *);
BOOL	KERNENTRY	FIsLstEmpty(LST *);
NOD*	KERNENTRY	PnodGetLstElem(LST *, int);
VOID	KERNENTRY	SetLstCurElem (LST *, NOD *);
NOD*	KERNENTRY	PnodFindLstElem(LST *, DWORD, int);
NOD*	KERNENTRY	PnodCreateLstElem(LST *, DWORD, int);
VOID	KERNENTRY	AddLstElem(LST *, NOD *, int);
NOD*	KERNENTRY	PnodRemoveLstElem(LST *);
VOID	KERNENTRY	RemoveLstPnod(LST *, NOD *);
VOID	KERNENTRY	DestroyAllLstElem(LST *);
VOID	KERNENTRY	DestroyLstElem(LST *);
VOID	KERNENTRY	AddLst (LST *, LST *, DWORD);
BOOL	KERNENTRY	FCopyLst (LST *, LST *);

#endif	 // ndef WOW32_EXTENSIONS

//====================================================================
// Object definitions
//
// We are out of tls with Picture Publisher which need 66.
// This is a quick fix to bump up to 80. If more conditions
// call for more tls slots, should cosider dynamic expansion .
// 
#undef TLS_MINIMUM_AVAILABLE
#define TLS_MINIMUM_AVAILABLE 80
#include <object.h>

#ifndef WOW32_EXTENSIONS

// Ansi/Oem parameter defines for SetFileApisToOem
#define	AO_IN		0
#define	AO_OUT		1
#define	AO_INOUT	2

// the below flags passed to MarkOemToAnsiDone specify if 
// teh caller can handle ANSI only or ANSI/OEM
#define	AO_CONV_ANSI	0
#define	AO_NO_CONV	1

// fOKToSetThreadOem is set by true OEM support APIs
// the vwin32 int21 dispatcher sets the TCB_OEM bit if this is set
#define IamOEM() ((GetCurrentTdb())->flFlags & fOKToSetThreadOem)

// Macro version of UnMarkOemToAnsi for C code
#define UnMarkOToA() \
        { GetCurrentTdb()->flFlags &= ~(fWasOemNowAnsi | fOKToSetThreadOem); }

// File handle cache strucs/definitions
#include "fhcache.h"

//====================================================================
// Kernel file handle cache routines (FHCACHE.C)
WORD	KERNENTRY GetCachedFileHandle(CFH_ID *,USHORT dfh, BOOL fRing0);
USHORT	KERNENTRY GetDosFileHandle(CFH_ID *,USHORT * pcfh);
void	KERNENTRY UnlockCachedFileHandle(CFH_ID *,USHORT cfh);
LONG	KERNENTRY CloseCachedFileHandle(CFH_ID *,USHORT cfh);
void	KERNENTRY RemoveFromFileHandleCache(CFH_ID *,USHORT cfh);

//====================================================================
// Kernel initialization and heap wrappers (DXKRNL.C)

VOID*	KERNENTRY   PvKernelAlloc(DWORD);
VOID*	KERNENTRY   PvKernelAlloc0(DWORD);
VOID*	KERNENTRY   PvKernelRealloc(VOID*, DWORD);
BOOL	KERNENTRY   FKernelFree(VOID*);
#define malloc(cb)  PvKernelAlloc(cb)
#define malloc0(cb) PvKernelAlloc0(cb)
#define free(p)     FKernelFree(p)

typedef BOOL (KERNENTRY * PFNDEBCB)(PDE, PDB*);

#define cmdIdle		0L
#define cmdExec		1L
#define cmdQuit		2L
#define cmdTermPpdb	3L
#define cmdTermPtdb	4L
#define cmdExecApp	5L
#define cmdCloseHandle	6L
#define	cmdInitComplete	7L
#define cmdLoaderError	8L

VOID	KERNENTRY   SetKrnlCmd(DWORD, PDB *, TDB *, DWORD);

//====================================================================
// Kernel entrypoint and .ASM helper routines (KRNINIT.ASM)

VOID	KERNENTRY   K16WaitEvent(WORD);
VOID	KERNENTRY   K16PostEvent(WORD);
VOID	KERNENTRY   K16Yield(VOID);
WORD	KERNENTRY   K16CreateTask(struct _tdb* ptdb);
WORD	KERNENTRY   K16FixTask(WORD ptdb, WORD hModule);
WORD	KERNENTRY   K16DeleteTask(DWORD hTask);
WORD	KERNENTRY   K16CreateMod(char* pModName, WORD wExpWinVer);
VOID	KERNENTRY   K16DeleteMod(WORD hModule);


//====================================================================
//  Misc .ASM support routines (KRNLUTIL.ASM)

VOID	KERNENTRY   FillBytes  (VOID *, DWORD, BYTE);
DWORD	KERNENTRY   CbSizeSz (const char *);
char*	KERNENTRY   CopySz (char *, const char *);
char*	KERNENTRY   AppendSz (char *, const char *);
BOOL	KERNENTRY   BFileNameTooLong(const char *);
LONG	KERNENTRY   LCompareSz (const char *, const char *);
LONG	KERNENTRY   LCompareNSz(const char *, const char *, DWORD);
LONG	KERNENTRY   LStrCmpI(  LPCSTR lpsz1, LPCSTR lpsz2);
VOID    KERNENTRY   RtlCopyMemory( PVOID Destination, CONST VOID *Source, DWORD Length);

#undef  CopyMemory
#define CopyMemory( a, b, c)   RtlCopyMemory( a, b, c)
// BUGBUG
// We used to have memcpy accidentally mapped to RtlMoveMemory,
// which is wrong. However, memcpy is used in many places and it is
// not obvious that all occurrences have non-overlapping
// arguments. Therefore, we make explicit the old map.
// On a case-by-case basis, we should replace occurrences of
// memcpy by RtlCopyMemory where we are certain the arguments
// do not overlap. In the other cases, we should explicitly use
// RtlMoveMemory.
#define memcpy(dest, src, len) RtlMoveMemory(dest, src, len)    // BUGBUG

#undef  MoveMemory
#define MoveMemory( a, b, c)   RtlMoveMemory( a, b, c)
#define memmov(dest, src, len) RtlMoveMemory(dest, src, len)

#define strlen(s) CbSizeSz(s)
#define strcpy(dest, src) CopySz(dest, src)
#define strcat(dest, src) AppendSz(dest, src)
#define strcmp(s1, s2) LCompareSz(s1, s2)
// #define memset(dest, val, len) FillBytes(dest, len, val)
// note different parameter order - also, compiler would inline memset()

VOID	KERNENTRY   dputs (const char *);
SEL	KERNENTRY   SelGetEnviron (SEL);
VOID	KERNENTRY   SetPspEnviron (SEL, SEL);
int	KERNENTRY   CbOfDosFileTable(WORD);
VOID	KERNENTRY   GetDosFileTable(WORD, DWORD, BYTE *);
void	KERNENTRY   KInt21(void);

// Intel descriptor structure.
typedef struct _dscr
{
    USHORT	dbLimLow;
    USHORT	lmaBaseLow;
    BYTE	lmaBaseMid;
    BYTE	arbAccess;
    BYTE	mbLimHi;
    BYTE	lmaBaseHi;
} DSCR;

VOID	KERNENTRY   InitDscr (DSCR* pdscr, ULONG lmaBase, ULONG dwLimit,
			ULONG arbAccess, ULONG arbExtra);
BOOL	KERNENTRY   FAllocDscr (ULONG cselAlloc, SEL* pselBase);
BOOL	KERNENTRY   FFreeDscr (SEL selFree);
BOOL	KERNENTRY   FSetDscr (SEL selSet, DSCR* pdscrSet);
BOOL	KERNENTRY   FGetDscr (SEL selGet, DSCR* pdscrGet);


//====================================================================
// Virtual memory management (MMAPI.C)

// Undocumented flags for the flAllocationType field in VirtualAlloc
#define MEM_SHARED	0x08000000	// make memory globally visible

//====================================================================
// Heap management (HEAP.C)

// Undocumented flags to HeapCreate
#define HEAP_SHARED	0x04000000		// put heap in shared memory
#define HEAP_LOCKED	0x00000080		// put heap in locked memory

//====================================================================
// File I/O primitives (IOUTIL.ASM)

#endif	 // ndef WOW32_EXTENSIONS

typedef DWORD	DFH;				// Dos File Handle

#define DFH_FILE_CREATE             0x0010
#define DFH_FILE_OPEN               0x0001
#define DFH_FILE_TRUNCATE           0x0002
#define DFH_ACTION_OPENED           0x0001
#define DFH_ACTION_CREATED_OPENED   0x0002
#define DFH_ACTION_REPLACED_OPENED  0x0003
#define DFH_MODE_READONLY           0x0000
#define DFH_MODE_WRITEONLY          0x0001
#define DFH_MODE_READWRITE          0x0002
#define DFH_MODE_SHARE_COMPATIBILITY 0x0000
#define DFH_MODE_SHARE_EXCLUSIVE    0x0010
#define DFH_MODE_SHARE_DENYWRITE    0x0020
#define DFH_MODE_SHARE_DENYREAD     0x0030
#define DFH_MODE_SHARE_DENYNONE     0x0040
#define DFH_MODE_NO_INHERIT         0x0080
#define DFH_MODE_EXTENDED_SIZE      0x1000
#define DFH_MODE_RAND_ACCESS_HINT   0x0008
#define DFH_MODE_SEQ_ACCESS_HINT    0x8000

#ifndef WOW32_EXTENSIONS

DFH	KERNENTRY   DfhOpenFile (char *, DWORD);
DFH	KERNENTRY   DfhCreateFile (char *, DWORD, DWORD, DWORD, LPDWORD);
BOOL	KERNENTRY   FCloseFile (DFH);
DWORD	KERNENTRY   CbReadFile (DFH, DWORD, VOID *);
DWORD	KERNENTRY   CbWriteFile (DFH, DWORD, VOID *);
DWORD	KERNENTRY   CbWriteOutFile (DFH, DWORD, VOID *);
DWORD	KERNENTRY   LfoSetFilePos (DFH, DWORD, DWORD, DWORD *);
DFH	KERNENTRY   DfhDupDfh (DFH);
BOOL	KERNENTRY   FGetDevInfo(DFH, DWORD *);
BOOL	KERNENTRY   FForceDupDfh (DFH, DFH);
DWORD	KERNENTRY   GetDOSDateTime (DWORD);
BOOL	KERNENTRY   FileTimeToDosDateTimeEx (CONST FILETIME *,
					     LPWORD, LPWORD, LPWORD);
BOOL	KERNENTRY   DosDateTimeToFileTimeEx (WORD, WORD, WORD, LPFILETIME);
DWORD	KERNENTRY   SetPSP (DWORD);
DWORD	KERNENTRY   GetPSP (VOID);

VOID	KERNENTRY   GlobalHandleSwitchToK32PSP ( HANDLE, LPDWORD );
VOID	KERNENTRY   GlobalHandleRestorePSP ( DWORD );


//====================================================================
// Process creation/deletion (PROCESS.C)

#define cbStartupInfo31 offsetof(STARTUPINFO, dwHotKey)

#endif	 // ndef WOW32_EXTENSIONS

// 16-bit CreateThread 32->16 thunk data
typedef struct _thread_startup_thunk_data {
    DWORD	Param16;
    DWORD	StartAddress16;
} THREAD_STARTUP_THUNK_DATA;

#ifndef WOW32_EXTENSIONS

BOOL	KERNENTRY   CreateProcessKernel(char *, char *, char *, WORD, WORD *, PVOID);
VOID	KERNENTRY   TerminateProcessKernel(VOID);
VOID	KERNENTRY   ExitCurrentProcess(DWORD);
VOID	KERNENTRY   TerminateProcessOutOfContext(PDB*, DWORD);
VOID	KERNENTRY   TerminateProcessFinal(PDB* ppdb);
PDB*	KERNENTRY   NewPDB(PDB* ppdbParent);
VOID	KERNENTRY   DisposePDB(PDB* ppdb);
DWORD	KERNENTRY   CbSizeEnv(LPCSTR, DWORD);
BOOL	KERNENTRY   FFindEnvVar(char **, char **, char *);
void*	KERNENTRY   MemToHeap(HANDLE hheap, const void *buf, int len);
char*	KERNENTRY   StrToHeap(HANDLE hheap, const char *str);

//====================================================================
// Thread creation/deletion (THREAD.C)

// PtdbNew flags values
#define TDBN_NOEXCEPTIONHANDLER		0x00000001
#define TDBN_NPX_WIN32_EXPT		0x00000002
#define TDBN_NPX_EMULATE		0x00000004
#define TDBN_WIN32			0x00000008
#define TDBN_INITIAL_WIN32_THREAD	0x00000010
#define TDBN_KERNEL_THREAD              0x00000020
#define TDBN_SUSPENDED                  0x00000040
#define TDBN_FIBER                      0x00000080

HANDLE	KERNENTRY   ICreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,
			DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress,
			LPVOID lpParameter, DWORD dwCreationFlags,
			LPDWORD lpThreadId, DWORD flFlags);
TDB *	KERNENTRY   PtdbCreate (PPDB ppdb, int cbStack, DWORD pfnEntry, DWORD dwParam, DWORD flFlags);
TDB *	KERNENTRY   PtdbNew (PDB *, int, DWORD, DWORD, DWORD);
VOID	KERNENTRY   ExitCurrentThread(DWORD);
VOID	KERNENTRY   TerminateCurrentThread(DWORD);
VOID	KERNENTRY   TerminatePtdb(TDB *, DWORD, BOOL);
DWORD	KERNENTRY   IdWaitOnPtdb (TDB *, DWORD);
BOOL	KERNENTRY   FSuspendPtdb (TDB *);
BOOL	KERNENTRY   FResumePtdb (TDB *);
VOID	KERNENTRY   DisposePtdb (TDB *);
VOID	KERNENTRY   BlockAllThreads (VOID);
BOOL	KERNENTRY   SuspendProcessThreads (PDB * ppdb);
BOOL	KERNENTRY   ResumeProcessThreads (PDB * ppdb);
PVOID	KERNENTRY   AllocateStack(PVOID *, PVOID *, DWORD, DWORD, DWORD);
VOID	KERNENTRY   FreeStack(PVOID);
VOID	KERNENTRY   SetError(DWORD);
DWORD	KERNENTRY   SuspendPtdb(TDB *);
DWORD	KERNENTRY   ResumePtdb(TDB *);
DWORD	KERNENTRY   ErcGetError(VOID);

#endif	 // ndef WOW32_EXTENSIONS

// AllocateStack flags
#define	AS_NORMAL	0x0000
#define	AS_TEMPORARY	0x0001

typedef VOID (KERNENTRY *PFN_THREADSTARTUP)(
    PTHREAD_START_ROUTINE pfnEntryPoint,
    LPVOID dwParam,
    DWORD flFlags
    );

#ifndef WOW32_EXTENSIONS

#ifdef  WOW
PTDB    KERNENTRY IGetCurrentTdb(VOID);
#define GetCurrentTdb() IGetCurrentTdb()
#define GetCurrentTdbx() (GetCurrentTdb()->ptdbx)
#define GetCurrentPdb() (GetCurrentTdb()->ptib->ppdbProc)
#else   // WOW
#define GetCurrentPdb() (*pppdbCur)
#define GetCurrentTdb() (*pptdbCur)
#define GetCurrentTdbx() (*ppTDBXCur)
#endif  // else WOW

//====================================================================
// Control handlers (BREAK.C)

// Control constants for CONTROL+C and CONTROL+BREAK
#define ctrlC		0
#define ctrlBreak	1
#define ctrlNone	10
#define ctrlInactive	20
#define ctrlTerminate	30

#define cbCtrlInc   8	// Number of control handlers initially and for each new allocation

VOID	KERNENTRY   ControlHandlerThread(VOID);
BOOL	KERNENTRY   FInitControlHandlers(PDB *);
VOID	KERNENTRY   DestroyControlHandlers(PDB *);
BOOL	KERNENTRY   FUpdateControlList(PDB *, PFN_CONTROL, BOOL);
BOOL	KERNENTRY   DoControlHandlers(DWORD);
VOID	KERNENTRY   SwitchToControlThread(PDB *, WORD);
VOID	KERNENTRY   FieldConsoleCtrlEvent(DWORD, PVOID);

//====================================================================
// Exception management (EXCEPTI.ASM, EXCEPTC.C, EXCEPTA.ASM)

#define LO16_TRAP_INTERCEPT
#define HI16_TRAP_INTERCEPT

#define TRAP_DIVIDE_BY_ZERO		0
#define TRAP_NONMASKABLE_INT		2
#define TRAP_OVERFLOW			4
#define TRAP_INVALID_OPCODE		6
#define TRAP_DEVICE_NOT_AVAILABLE	7
#define TRAP_3E				0x3e
#define TRAP_75				0x75

#define	EXC_STACK_OVERFLOW		0x10E

// Definition for Npx status word error mask

#define FSW_INVALID_OPERATION	1
#define FSW_DENORMAL		2
#define FSW_ZERO_DIVIDE		4
#define FSW_OVERFLOW		8
#define FSW_UNDERFLOW		16
#define FSW_PRECISION		32
#define FSW_STACK_FAULT		64
#define FSW_CONDITION_CODE_0	0x100
#define FSW_CONDITION_CODE_1	0x200
#define FSW_CONDITION_CODE_2	0x400
#define FSW_CONDITION_CODE_3	0x4000

#define FSW_EXCEPTION_MASK	(FSW_INVALID_OPERATION +	\
				 FSW_DENORMAL +			\
				 FSW_ZERO_DIVIDE +		\
				 FSW_OVERFLOW +			\
				 FSW_UNDERFLOW +		\
				 FSW_PRECISION)

typedef struct	ExceptStruct
{
    DWORD	SegGs;
    DWORD	SegFs;
    DWORD	SegEs;
    DWORD	SegDs;
    DWORD	rgEdi;
    DWORD	rgEsi;
    DWORD	rgEbp;
    DWORD	rgEspTmp;
    DWORD	rgEbx;
    DWORD	rgEdx;
    DWORD	rgEcx;
    DWORD	rgEax;
    DWORD	dwExceptNum;
    DWORD	rgRetEip;
    DWORD	SegRetCs;
    DWORD	dwErrorCode;
    DWORD	rgEip;
    DWORD	SegCs;
    DWORD	rgEflags;
    DWORD	rgEsp;
    DWORD	SegSs;
} ExceptStruct;

typedef struct _IEE
{
    DWORD	dwExceptNum;
    ExceptStruct esExcept;
} IEE;
typedef IEE * PIEE;

typedef struct _regs
{
    DWORD	regSS;
    DWORD	regGS;
    DWORD	regFS;
    DWORD	regES;
    DWORD	regDS;
    DWORD	regEDI;
    DWORD	regESI;
    DWORD	regEBP;
    DWORD	regESP;
    DWORD	regEBX;
    DWORD	regEDX;
    DWORD	regECX;
    DWORD	regEAX;
    DWORD	regEIP;
    DWORD	regCS;
    DWORD	regEFL;
} REGS;
typedef REGS *	PREGS;

BOOL	KERNENTRY   Except7(void);
BOOL	KERNENTRY   Load80x87Trap1(void);
BOOL	KERNENTRY   Load80x87Trap2(void);
VOID	KERNENTRY   PageFaultHandler(void);
VOID	KERNENTRY   StackFaultHandler(void);
VOID	KERNENTRY   RtlRaiseException(PEXCEPTION_RECORD ExceptionRecord);
BOOL	KERNENTRY   FInitExceptions(void);
void	KERNENTRY   TerminateExceptions(void);
BOOL	_cdecl	    RetInstruction(VOID);


//====================================================================
// Floating point support (FLOAT.ASM)

BOOL	KERNENTRY   FVmcpdInit(long * pl, short * pver);
BOOL	KERNENTRY   FCoprocRestore(VOID);
BOOL	KERNENTRY   FInstallInt7Handler(VOID);
BOOL	KERNENTRY   FUninstallInt7Handler(VOID);
PVOID	KERNENTRY   GetEmulatorDataOffset(VOID);


//====================================================================
// PE Loader (PELDR.C)

BOOL	KERNENTRY   FLoadKernelModule (PDB *, char *);
BOOL	KERNENTRY   FLoadProgram (PDB *, char *);
char*	KERNENTRY   SzNameFromMR(MODREF *pRef);
MODREF* KERNENTRY   MRFromHLib(HANDLE hLib);


//====================================================================
// Misc. process and kernel utilities (PROCUTIL.ASM)

// Size of reserved memory region above and below stacks.  Thunks always map
// a 64K stack selector, so we should have 64K reserved above the stack.
#define STACK_BARRIER_SIZE	(64*1024)

#define WIN16_TERMINATION_STACK_SIZE	0x2000

VOID	KERNENTRY   ThreadTerminationHandler(VOID);
BOOL	KERNENTRY   FBuildEnvArgs (SEL, char **, char **, void **);
DWORD	KERNENTRY   CbSearchPath(char *, char *, char *, DWORD, char *, char **);
DWORD	KERNENTRY   CbGetCurDir(DWORD, char *);
DWORD	KERNENTRY   CbGetDosCurDir(DWORD, char *);
BOOL	KERNENTRY   FIsDir(LPCSTR);
LONG	KERNENTRY   LStrCmpI(LPCSTR, LPCSTR);
char*	KERNENTRY   SzGetNamePos(char *);
DWORD	KERNENTRY   FGetFileInfo(char *, DWORD, LPWIN32_FIND_DATA);
DWORD	KERNENTRY   CbStrUpr(char *);
char*	KERNENTRY   PchGetNetDir(char *);
BOOL	KERNENTRY   ValidateDrive(DWORD);
BOOL	KERNENTRY   IsDriveFixed(DWORD);
PPDB    KERNENTRY   PidToPDB(DWORD pid);
DWORD   KERNENTRY   PDBToPid(PPDB ppdb);
PTDB    KERNENTRY   TidToTDB(DWORD tid);
DWORD   KERNENTRY   TDBToTid(PTDB ptdb);
PPDB	KERNENTRY   ValidateProcessID(DWORD);
ULONG	KERNENTRY   GetLongName(LPCSTR, LPSTR, ULONG);
ULONG	KERNENTRY   GetShortName(LPCSTR, LPSTR, ULONG);

//====================================================================
// Find Change utilities (FCNAPI.C)
GLOBAL	VOID	    KERNENTRY	DisposePfcndb(FCNDB *pfcndb);

//====================================================================
// Directory utilites (DIRUTIL.C)

DWORD	KERNENTRY   CbGetCurDir(DWORD, char *);
BOOL	KERNENTRY   FSetCurDir(char *);
DWORD	KERNENTRY   FMakeFullName(char *, char *, char *);
DWORD	KERNENTRY   DwMakeFullPath(char *, char *, DWORD *, char **);
DWORD	KERNENTRY   FNextFromDirList(char **, char *, char *, char *);
DWORD	KERNENTRY   CbAppendExt (char *, char *, DWORD);
BOOL	KERNENTRY   FFixPathChars (char * szPath);
VOID	KERNENTRY   BeepOff(BYTE bControl);
DWORD	KERNENTRY   GetPathType(LPSTR szPath);

// helpers for zombie psp management [ SBS inter-psp dup related]
// mmfile.c
VOID KERNENTRY IncRefZombiePSP(WORD psp);
VOID KERNENTRY UnuseZombiePSP(WORD psp);

// Ansi/Oem helper routines for conversion if reqd from Oem-Ansi for
// implemeneting SetFileApisToOem
LPSTR KERNENTRY EnterResolveOemToAnsi(LPSTR szName, int fInOut);
VOID KERNENTRY LeaveResolveOemToAnsi(LPSTR szSrcDest, int fInOut);
BOOL KERNENTRY MarkOemToAnsiDone(BOOL fNoConversion);
VOID KERNENTRY UnMarkOemToAnsiDone();

//====================================================================
// USER Signal routines (SIGNAL.C)

BOOL	KERNENTRY   SignalBroadcast(DWORD dwSignalID, DWORD dwID, WORD hTaskMod16);

//====================================================================
// Sync APIs (SYNC.C)

// delivery of APCs
BOOL	KERNENTRY   bDeliverPendingAPCs( VOID );
DWORD	KERNENTRY   BlockThreadEx( DWORD Timeout, BOOL Alertable );

// thread block/unblock primitives
VOID	KERNENTRY Wait(void);		// wait for/enter a critical section
VOID	KERNENTRY Signal(void);		// leave a critical section
DWORD	KERNENTRY BlockThread(DWORD);
VOID	KERNENTRY WakeThread(TDB *, DWORD);

// general wait multiple and wait single
DWORD	KERNENTRY   dwWaitMultipleObjects(DWORD, OBJ *[], DWORD, DWORD,BOOL);
DWORD	KERNENTRY   dwWaitSingleObject(OBJ *, DWORD, BOOL);

// used for all synchronization objects
VOID	KERNENTRY   DisposeSyncObj(SYNCO *);

// semaphore specific functions
SEM *	KERNENTRY   NewPsem (LONG, LONG);
BOOL	KERNENTRY   bReleasePsem(SEM *, LONG, LPLONG);

// event specific functions
EVT *	KERNENTRY   NewPevt(BOOL, BOOL);
BOOL    KERNENTRY   bSetPevt(EVT *);
BOOL	KERNENTRY   bPulsePevt(EVT *);
BOOL	KERNENTRY   bResetPevt(EVT *);

// mutex specific functions
MUTX *	KERNENTRY   NewPmutx(BOOL);
BOOL	KERNENTRY   bReleasePmutx(MUTX *);
VOID	KERNENTRY   CheckOwnedMutexes( TDB *ptdb );

// critical section specific functions
VOID	KERNENTRY   InitCrst(CRST *);
VOID	KERNENTRY   DestroyCrst(CRST *);
CRST *	KERNENTRY   NewCrst();
VOID	KERNENTRY   DisposeCrst(CRST *);
VOID	KERNENTRY   EnterCrst(CRST *);
VOID	KERNENTRY   LeaveCrst(CRST *);
VOID	KERNENTRY   CheckOwnedCrsts( TDB *ptdb );
VOID	KERNENTRY   DeallocOrphanedCrsts( PDB *ppdb );

// creation and deletion of non-synchronization, waitable objects
NSOBJ * KERNENTRY   NewNsObject( DWORD dwSize, BYTE typObj);
VOID	KERNENTRY   DisposeNsObject( NSOBJ *pnsobj );

// must complete sections for threads
BOOL	KERNENTRY   LockMustComplete( TDB * );
VOID	KERNENTRY   UnlockMustComplete( TDB * );

//====================================================================
// Named object primitives (NAMEDOBJ.C)

OBJNAME*    KERNENTRY	NameObject(OBJ * pobj, LPCSTR ObjName);
OBJ*	KERNENTRY   FindObjectName( LPCSTR Name );
BOOL	KERNENTRY   FreeObjHashName(OBJNAME *ObjName);
HANDLE	KERNENTRY   NewHandleForName( LPCSTR lpName, DWORD typOfObj, DWORD fFlags );


//====================================================================
// System error box defines

int WINAPI SysErrorBox(LPSTR, LPSTR, DWORD, DWORD, DWORD);

#define SEB_OK		1	// Button with "OK".
#define SEB_CANCEL	2	// Button with "Cancel"
#define SEB_YES		3	// Button with "&Yes"
#define SEB_NO		4	// Button with "&No"
#define SEB_RETRY	5	// Button with "&Retry"
#define SEB_ABORT	6	// Button with "&Abort"
#define SEB_IGNORE	7	// Button with "&Ignore"
#define SEB_CLOSE	8	// Button with "Close"
#define SEB_DEFBUTTON	0x8000	// Mask to make this button default

#define SEB_BTN1	1	// Button 1 was selected
#define SEB_BTN2	2	// Button 1 was selected
#define SEB_BTN3	3	// Button 1 was selected


//====================================================================
// Low-level device objects (DEVICE.C)

FDB*	KERNENTRY   PfdbNew (VOID);
PIPDB*	KERNENTRY   PpipedbNew (DWORD pipszbyts, BOOL IsNmPipe);
SDB*	KERNENTRY   PsdbNew (VOID);
DIODB*	KERNENTRY   PdiodbNew (VOID);
VOID	KERNENTRY   DisposePfdb (FDB *);
VOID	KERNENTRY   DisposePfdbObjCleanUp (FDB *);
VOID	KERNENTRY   DisposePfdbDOSClose (FDB *);
VOID	KERNENTRY   DisposePsdb (SDB *);
VOID	KERNENTRY   DisposePpipedb (PIPDB *);
VOID	KERNENTRY   DisposePdiodb (DIODB *);
HANDLE	KERNENTRY   hSerialNew (PDB *ppdb, DWORD handle, DWORD DevNode);
OBJ*	KERNENTRY   PobjCheckDevPhnd (HANDLE *, DWORD, DWORD);
DWORD	KERNENTRY   PfdbDupPfdb (FDB *);
VOID	KERNENTRY   DisposePmsdb (MSDB *);
MSDB*	KERNENTRY   PmsdbNew (VOID);
VOID	KERNENTRY   DisposePtlhpdb (TLHPDB *);
TLHPDB* KERNENTRY   PtlhpdbNew (VOID);
PMSGINDICATORDB  KERNENTRY   PMsgIndicatorDBNew(VOID);
VOID    KERNENTRY   DisposeMsgIndicatorDB( PMSGINDICATORDB);


//====================================================================
// Miscellaneous functions (MISCAPI.C)


void    KERNENTRY   ReleaseSystem(PTDB ptdb);
void    KERNENTRY   ReleaseDisplay(PTDB ptdb);

//====================================================================
// ACCESS RIGHTS BIT DEFINITIONS

// These fields are common to all descriptors
#define AB_PRESENT  0x80	// segment present bit
#define AB_DPL	    0x60	// mask for DPL field
#define AB_DPL0     0x00	// ring 0 DPL
#define AB_DPL1     0x20	// ring 1 DPL
#define AB_DPL2     0x40	// ring 2 DPL
#define AB_DPL3     0x60	// ring 3 DPL
#define AB_SEGMENT  0x10	// user (i.e. non-system) segment
#define AB_SYSTEM   0x00	// system descriptor

#define EB_GRAN     0x80	// granularity bit (segment limit is page granularity)
#define EB_DEFAULT  0x40	// default operand size (USE32 code)
#define EB_BIG	    0x40	// big bit (for data segments)
#define EB_LIMIT    0x0f	// mask for upper bits of segment limit field

// These fields are relevant to code and data segment descriptors
//   (non-system descriptors)
#define AB_DATA     0x10	// data segment
#define AB_STACK    0x14	// expand down data (i.e. stack segment)
#define AB_WRITE    0x02	// writable data
#define AB_CODE     0x18	// code segment
#define AB_CONFORM  0x04	// conforming code
#define AB_READ     0x02	// readable code
#define AB_ACCESSED 0x01	// segment has been accessed

// These are the descriptor types for system descriptors
#define DT_INVAL1   0x00	// invalid descriptor
#define DT_TSS286   0x01	// available 286 task state segment
#define DT_LDT	    0x02	// Local Descriptor Table descriptor
#define DT_TSS286B  0x03	// busy 286 task state segment
#define DT_CALL286  0x04	// 286 style call gate
#define DT_TASK     0x05	// task gate
#define DT_INTR286  0x06	// 286 style interrupt gate
#define DT_TRAP286  0x07	// 286 style trap gate
#define DT_INVAL2   0x08	// invalid descriptor
#define DT_TSS386   0x09	// available 386 task state segment
#define DT_RSVD1    0x0A	// reserved type
#define DT_TSS386B  0x0B	// busy 386 task state segment
#define DT_CALL386  0x0C	// 386 style call gate
#define DT_RSVD2    0x0D	// reserved type
#define DT_INTR386  0x0E	// 386 style interrupt gate
#define DT_TRAP386  0x0F	// 386 style trap gate

// These are some common combinations of the above fields making up
// useful access rights bytes.
#define ARB_CODE0   AB_PRESENT+AB_DPL0+AB_CODE+AB_READ	// ring 0 code
#define ARB_CODE3   AB_PRESENT+AB_DPL3+AB_CODE+AB_READ	// ring 3 code
#define ARB_DATA0NP	       AB_DPL0+AB_DATA+AB_WRITE // illegal segment
#define ARB_DATA0   AB_PRESENT+AB_DPL0+AB_DATA+AB_WRITE // ring 0 r/w data
#define ARB_DATA3   AB_PRESENT+AB_DPL3+AB_DATA+AB_WRITE // ring 3 r/w data

#define LIM_NONE    0xffffffff

#define SELECTOR_MASK	0xFFF8		/* selector index */
#define TABLE_MASK	0x04		/* table bit */
#define RPL_MASK	0x03		/* privilige bits */

// FROM IFS.H
/** Values for fReturnFlags in Duphandle: */
#define WDUP_RMM_DRIVE		0x01			// file mapped on a RMM drive
#define WDUP_NETWARE_HANDLE	0x02			// handle belongs to Netware
  								  
//====================================================================
// System include files

#endif	 // ndef WOW32_EXTENSIONS

#include <ldrdefs.h>
#include <w32base.h>
#define _WINNT_
#include <vmm.h>
#include <deb.h>
#include <coresig.inc>		// dual mode .INC/.H file
#ifndef IS_VXD
#define Not_VxD
#endif
#include <w32sys.h>
#include <vwin32.h>
#include <krnlcmn.h>
#include <vmda.h>
#include <console.h>
#include <syslevel.h>
#include <tdb16.h>
#include <k32rc.h>
#include <heap.h>
#include <dxkrnl.h>
#include <leldr.h>
#ifndef IS_VXD
#include <ring0.h>
#endif
#include <handle.h>
#include <cdis.h>
#include <dbgdot.h>
#include <apitrace.h>

#ifndef WOW32_EXTENSIONS
//====================================================================
// Global variables
#ifdef  WOW
extern  DWORD   dwMEOWFlags;
#else   // WOW
#ifdef  MEOW_LOGGING
extern  DWORD   dwMEOWFlags;
#endif  // def MEOW_LOGGING
#endif  // def WOW
extern	SEL	selLDT;
extern	DWORD*	pLDT;
extern  WORD*   pK16HeadTDB;
#ifndef WOW
extern	PDB**	pppdbCur;
extern	TDB**	pptdbCur;
#endif  // def WOW
extern	TDB*	ptdbSvc;
extern	DWORD	lmaUserBase;
extern	char*	szWinDir;
extern	char*	szSysDir;
extern	WORD	cbWinDir;
extern	WORD	cbSysDir;
extern	LCRST*	Win16Lock;
extern	LCRST*	Krn32Lock;
extern	LCRST*	pcrstDriveState;
extern	BOOL	F80x87Present;
extern	DWORD	CbEmulData;
extern	IMTE	ImteEmulator;
extern	WORD	selK32Psp;	// Selector to PSP of kernel process
extern	PDB *	ppdbKernel;	// pointer to the PDB of the kernel process
extern	TDB *	ptdbWin16;	// pointer to kernel win16 thread
extern	LST *	plstTdb;	// pointer to active thread list
extern	LST *	plstPdb;	// pointer to process list
extern HANDLE	hheapKernel;	// Kernel's shared heap
extern WORD	Dos386PSPSeg;
extern WORD	Dos386PSPSel;
extern VOID *   lpSysVMHighLinear; // high linear mapping of low mem
extern char	WhineLevel;	// debug level indicator
extern USHORT	selFlatCode;
extern USHORT	selFlatData;
extern LEH*	plehKernel;	// Kernel's PE header
extern BYTE	fIsWDebThere;	// Flags if kernel debugger is around
extern DWORD	ercNoThread;	// Err code until first thread
extern PTDB	ptdbFault;
extern HINSTANCE hinstKernel32;
#ifndef WOW
extern TDBX**	ppTDBXCur;
#endif  // ndef WOW
extern BYTE	bBeepControl;
extern	int	K32PSP;
extern MTE	**pmteModTable;
extern IFSMGR_CTP_STRUCT *lpFlatIfsMgrConvertTable;


// Types
typedef enum _FILE_TYPE
{ FT_ERROR, FT_WIN16, FT_DOS, FT_BAT, FT_COM, FT_PIF, FT_WIN32CONSOLE, 
FT_WIN32GUI, FT_WIN32DLL } FILE_TYPE;

#ifdef  WOW
#define GetTIB(ptdb)        (*((ptdb)->ptib))
#else   // WOW
#define GetTIB(ptdb)        ((ptdb)->tib)
#endif  // else WOW

#endif	 // ndef WOW32_EXTENSIONS

#endif // #ifndef __KERNEL32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\leldr.h ===
//  LELDR.H
//
//      (C) Copyright Microsoft Corp., 1988-1994
//
//      Header file for the PE Loader
//
//  Origin: Dos Extender
//
//  Change history:
//
//  Date       Who        Description
//  ---------  ---------  -------------------------------------------------
//   3-Dec-90  GeneA      Created
//  15-Feb-94  JonT       Code cleanup and precompiled headers
/************************************************************************/


/* ------------------------------------------------------------ */
/*		Loader Data Structures				*/
/* ------------------------------------------------------------ */


/* Module table flag definitions.
*/


#define     fModInUse	0x80000000
//#define     fModImports	0x00000001  /* module imports have been done */
#define     fModReloc   0x00000002  /* module not at default RVA */
#define     fModMaster	0x00000004  /* has clone data in another MTE */
#define     fTellGDI	0x00000008  /* notify GDI when it goes away */
#define     fModPreload	0x00000010  /* loaded from floppy, preload it */
#define	    fModNoClone	0x00000020  /* we have renamed this running module, don't clone in other process */

typedef struct _tagMTE {
    WORD	flFlags;	// module status flags
    WORD	usageShared;	// number of copies in 16 bit/global mem arena
    LEH *	plehMod;	// pointer to LE Header for this module
    /*
     * CFH_ID struc in object.h 
     */
    CFH_ID	cfhid;		// cfhid.szFilename and cfhid.fsAccessDos

    char *	szName; 	// module name string (within szFileName)
    WORD	iFileNameLen;	// fast filename search
    WORD	iNameLen;	// fast name search
    DFH		dfhFile;	// handle of open file for paging
    DWORD	NumberOfSections;// count of sections in object
    DWORD **	ppObjReloc;	// pointer to table of pointers
    DWORD	ImageBase;	// desired image base
    WORD        hModuleK16;	// Kernel16 dummy hModule for this module
    WORD	usage;		// Number of processes module used in
    MODREF *	plstPdb;	// List of PDBs using this module 
    char *	szFileName83;	// short name equ. of cfhid.lpFileName
    WORD 	iFileNameLen83;	// "" length
    char *	szName83;	// short name w/o path
    WORD 	iNameLen83;	// its length for quick exclusionary tests
} MTE;

extern MTE ** pmteModTable;
extern IMTE	imteMax;

/* Error location structure.  This is used by FMapErrorLoc to return
** information about the module in which a fault occured.
*/

typedef struct _tagELS {
    WORD	imte;
    DWORD	iote;
    char *	szFileName;
    DWORD	offError;
} ELS;


#define SHARED_BASE_ADDRESS MINSHAREDLADDR /* Start of shared heap */

/* ------------------------------------------------------------ */
/*		    Procedure Declarations			*/
/* ------------------------------------------------------------ */

GLOBAL	BOOL	KERNENTRY   FNotifyProgram(void);
GLOBAL	BOOL	KERNENTRY   ReserveStaticTLS(void);
GLOBAL	VOID	KERNENTRY   FreeUnusedModules(LST *plstProc);
GLOBAL	LEH *	KERNENTRY   PlehFromImte (IMTE imte);
GLOBAL	LEH *   KERNENTRY   PlehFromHLib(HANDLE hLib);
GLOBAL	WORD	KERNENTRY   GetHModK16FromHModK32(HANDLE hmod);
GLOBAL	VOID *	KERNENTRY   PvExportFromOrdinal (LEH *pleh, DWORD ord);
GLOBAL	VOID *	KERNENTRY   PvExportFromName (LEH *pleh, DWORD ipchHint,
						char *szName);
GLOBAL  VOID    KERNENTRY   NotifyThreadAttach(void);
GLOBAL  VOID    KERNENTRY   NotifyThreadDetach(void);
GLOBAL	VOID	KERNENTRY   DetachProcessModules(PDB *ppdb);
GLOBAL	VOID	KERNENTRY   RecycleProcessModules(PDB *ppdb);
GLOBAL	BOOL	KERNENTRY   FMapErrorLoc(VOID *pvErr, ELS *pels);
GLOBAL	VOID	KERNENTRY   DumpStackFrames(DWORD dwErrLoc, DWORD dwFrame);
GLOBAL	VOID	KERNENTRY   LogStackDump(DWORD dwErrLoc, DWORD dwFrame);

#if DEBUG
#define GrabDll() EnterSysLevel(&GetCurrentPdb()->crstLoadLock);
#define GrabMod() EnterSysLevel(Krn32Lock);


GLOBAL	void	KERNENTRY   CheckDll(void);

#define CheckMod()  ConfirmSysLevel(Krn32Lock);
#define CheckNotMod()    CheckNotSysLevel(Krn32Lock);

GLOBAL	void	KERNENTRY   CheckDllOrMod(void);

#else
#define GrabDll()	EnterSysLevel(&GetCurrentPdb()->crstLoadLock);
#define GrabMod()	EnterSysLevel(Krn32Lock);
#define CheckDll()
#define CheckMod()
#define CheckNotMod()
#define CheckDllOrMod()
#endif

#define ReleaseDll()	LeaveSysLevel(&GetCurrentPdb()->crstLoadLock);
#define ReleaseMod()	LeaveSysLevel(Krn32Lock);

/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\object.h ===
/************************************************************************/
/*									*/
/*	OBJECT.H	--  General Object Manager Definitions		*/
/*									*/
/************************************************************************/
/*	Author:     Gene Apperson					*/
/*	Copyright:  1991 Microsoft					*/
/************************************************************************/
/*  File Description:							*/
/*									*/
/*									*/
/************************************************************************/
/*  Revision History:							*/
/*									*/
/*									*/
/************************************************************************/

// This file may have been implicitly included if the client included KERNEL32.H
// If so, we don't need to define and declare everything again. We match this
// directive at the bottom of the file.
#ifndef typObjAny

/* ------------------------------------------------------------ */
/*		Object Type Codes				*/
/* ------------------------------------------------------------ */

#define typObjSemaphore 1
#define typObjEvent	2
#define typObjMutex	3
#define typObjCrst	4
#define	typObjTimer	5
#define typObjProcess	6
#define typObjThread	7
#define typObjFile	8
#define typObjChange	9
#define typObjConsole	10
#define	typObjIO	11
#define typObjConScreenbuf 12
#define typObjMapFile	13
#define typObjSerial	14
#define typObjDevIOCtl	15
#define typObjPipe	16
#define typObjMailslot	17
#define typObjToolhelp	18
#define typObjSocket	19
#define typObjR0ObjExt	20
#define typObjMsgIndicator    21
#ifdef  WOW32_EXTENSIONS
#define typObjTDBX    22
#endif
#define typObjAny	0xffffffff
#define typObjNone	0

// to let us determine what type of object were dealing with in a
// wait condition
#define typObjFirstSync typObjSemaphore
#define typObjLastSync	typObjTimer
#define typObjFirstWait typObjProcess
#define typObjLastWait	typObjIO

#define typObjMaxValid  typObjMsgIndicator
#define typObjShiftAdjust (-1)

/* ------------------------------------------------------------ */
/*		     Common Object Definition			*/
/* ------------------------------------------------------------ */

// This structure defines a generic object.  There is an instance
// of this structure at the head of all objects in the system.  The
// generic object manipulation functions operate on fields in this
// structure and call on the object specific manipulation functions
// based on the object type when necessary.
// IMPORTANT NOTE: all synchronization objects contain a field called
//	pwnWait which must be at the same offset for all types. Since
//	we are constrained by NT compatibility to keep critical section
//	structures a certain size, you cannot change this structure
//	without ensuring that this field is at the same offset in all
//	sync objects and that critical sections are NT compatible in
//	size.
typedef struct _obj {
    BYTE    typObj;             // object type
    BYTE    objFlags;           // object flags
    WORD    cntUses;            // count of this objects usage
} OBJ;

typedef OBJ *POBJ;

#define fObjTypeSpecific        0x80    // meaning depends on object type
#define fObjTypeSpecific2       0x40    // meaning depends on object type
#define fObjTypeSpecific3       0x20    // meaning depends on object type

// type-specific objFlag bits.
#define fNewCrstBlock        fObjTypeSpecific  // (typObjCrst)  high bit for thread blocked while crst owned
#define fEvtManualReset      fObjTypeSpecific  // (typObjEvent) set for manual reset
#define fTimerRing3          fObjTypeSpecific2 // (typObjTimer) timer has ring-3 completion

// Every object type contains a nested generic object as its first member
#define COMMON_OBJECT OBJ objBase;

// This is a generic non-synchronization object which can be waited on
// all of them include a pointer to an event object which is created when
// they are.
#define COMMON_NSOBJECT OBJ objBase; \
	struct _evt *psyncEvt;	// here's the embedded event


// This is the external object structure which is used to
// supply a Win32 handle to an external component's structure.
// e.g. Winsock socket handles

typedef struct _external_obj {
	COMMON_OBJECT		// it is an object
	DWORD	context;	// typically a pointer for use by the external component
} EXTERNAL_OBJ, * PEXTERNAL_OBJ;


/* ------------------------------------------------------------ */
/*		Synchronization Object & Structure Definition	*/
/* ------------------------------------------------------------ */

#define fWaitDefault 0		// default flags
#define fWaitAllFlag 1		// set for wait all, clear for wait any
#define fWaitCrst    2		// special critical section wait

typedef struct _wnod {
	struct _wnod  *pwnNext; // pointer to next in circular list
	struct _wnod  *pwnCirc; // pointer to wait node in next circular list
	struct TDBX   *ptdbxWait; // thread waiting
	struct _synco *pobjWait;  // object being waited on
} WNOD;

// Every object name is stored in a structure like this one. Each hash table entry
// points to a forward linked list of these structures.
typedef struct _objnamestruct {
	struct _objnamestruct *NextOName; // next in hash list
	OBJ	       *ObjPtr;		// named object this refers to
	char	       NameStr[1];	// name string
} OBJNAME;

// This is a generic synchronization object which is a subset of the other
// synchronization objects
typedef struct _synco {
	COMMON_OBJECT
	WNOD	*pwnWait;	// pointer to the wait node for this object
	LONG	cntCur;		// current count to test state, != 0 is signaled
	OBJNAME *NameStruct;	// name structure for this object
} SYNCO;

// A semaphore object
//  IMPORTANT NOTE: This structure must fit inside the NT KSEMAPHORE type, where
//  sizeof(KSEMAPHORE) is 20.
typedef struct _sem {
	COMMON_OBJECT
	WNOD	*pwnWait;	// pointer to the wait node for this object
	LONG	cntCur;		// current count of semaphore availability
	OBJNAME *NameStruct;	// name structure for this object
	LONG	cntMax;		// maximum allowed count
} SEM;

// A Mutex
typedef struct _mutx {
	COMMON_OBJECT
	WNOD	*pwnWait;	// pointer to the wait node for this object
	LONG	cntCur;		// current count of object
	OBJNAME *NameStruct;	// name structure for this object
	struct TDBX *ptdbxOwner; // owner thread
	struct _mutx *SysMutexLst; // system list of mutexes
} MUTX;

typedef MUTX *PMUTX;

// This structure defines a critical section. Although it has the
// typObj field, a critical section is not a true object. This limitation
// is to provide structure size compatibility with NT.
// IMPORTANT NOTE: Since the pwnWait is at a specific offset in order
//	to use generic sync object functions, it is important not to
//	reorder this structure's members unless absolutely necessary.
//	If you do, be sure to look at the OBJ data type and other
//	synchronization object types.
typedef struct _crst {
        BYTE    typObj;         // type of object
        BYTE    objFlags;       // object flags
        WORD    objPadding;     // OBJ.cntUses not needed
        LONG    cntRecur;       // recursion count of ownership
	struct TDBX *ptdbxOwner; // owner thread of this critical section
	struct TDBX *ptdbxWait;  // pointer to the first waiting TDB
	LONG	cntCur;		// count of critical section ownership
	struct _crst *SysCrstLst; // system list of critical sections
	LST	*pdbLst;	// list of owning processes
	struct _crstexport *pextcrst; // pointer to external critical section
} CRST;

// This is the exported critical section structure which is used to
// indirectly access the internal critical section structure and cleanup.
typedef struct _crstexport {
	COMMON_OBJECT		// it is an object
	CRST	*crstInternal;	// pointer to internal critical section
} CRST_EXPORT;

// This structure and defines make up an event object.

//  IMPORTANT NOTE: This structure must fit inside the NT KEVENT type, where
//  sizeof(KEVENT) is 16.
typedef struct _evt {
	COMMON_OBJECT
	WNOD	*pwnWait;	// pointer to the wait node for this object
	LONG	cntCur;		// signaled state
	OBJNAME *NameStruct;	// name structure for this object
} EVT;

typedef EVT *PEVT;

// so we have access to generic NSOBJ's data structure
typedef struct _nsobj {
	COMMON_NSOBJECT
} NSOBJ;

#define LCRST_DEFINED		// disable duplicate definition in syslevel.h

// Include heirarchical critical section support
#include <syslevel.h>


// This is a heirarchical critical section used to ensure
// deadlock resistant code
typedef struct _lcrst {
	CRST	cstSync;
#ifdef SYSLEVELCHECK
	SYSLVL	slLevel;
#endif
} LCRST;

typedef LCRST *LPLCRST;

typedef struct _createdata16 {
        LPVOID  pProcessInfo;   // LPPROCESS_INFORMATION
        LPVOID  pStartupInfo;   // LPSTARTUPINFO
        LPVOID  pCmdLine;       // points to command line
} CREATEDATA16;

// Include the TIB definition
#include <k32share.h>
#include <apc.h>

#define TLS_MINIMUM_AVAILABLE_GLOBAL 8

// Thread Data Block structure.
//
// !!!! BUGBUG !!!!
// This definition is duplicated in object.inc and core\inc\object16.inc
//
typedef struct _tdb
{
    COMMON_NSOBJECT		// standard waitable non-synchronization object
#ifdef  WOW
    TIB	*	    ptib;	// Thread Information Block--from k32share.h
#else   // WOW
    TIB	        tib;	// Thread Information Block--from k32share.h
#endif  ; else WOW
    // opengl32 depend on TslArray at offset 0x88 from pTIB. Someone has remove the ppdbProc
    // and wnodLst probably for good reasons. But to keep apps happy, we will add 2 dowords back
    // currently sizeof(TIB)==56
    //struct _pdb*  ppdbProc;   // DON'T MOVE THIS RELATIVE TO tib!! (for M3 NTcompat)
    DWORD	    cntHandles; // count of handles to this thread
    WORD	    selEmul;	// selector to 80x87 emulator data area
    WORD	    selTib;	// selector to the TIB for this process
    DWORD	    dwStatus;	// thread status/termination code
    DWORD	    flFlags;	// state of thread
    DWORD           dwPad1;     // just to pad

    //WNLST         wnodLst;    // embedded structure for synchronization

    //
    // keep R0ThreadHandle offset at 0x54 for Javasup.vxd
    //
    DWORD	    R0ThreadHandle; // ring 0 thread handle

    // Warning !!! move dwPad2 below cus SAS 6.12 hardcoded pStackBase at offset 0x54 from 
    // pTib. It also used the defunc field pStackTerm ( now dwPad2 ). Whoever gave this
    // internal structure to SAS is a bonehead.
    // Break SAS and see what happen

    WORD	    wMacroThunkSelStack16; // Used to be TIBSTRUCT.selStack16
    WORD	    wPad;
    VOID *	    pvMapSSTable; //Table of 16-bit ss's for flat thunks
    DWORD	    dwCurSS;	//Current default 16-bit ss for flat thunks
    DWORD	    dwCurNegBase; //negative base of current default ss
    VOID *	    pvThunkConnectList; //head of list of in-progress thunk handshakes
    VOID *	    pvExcept16; //Head of 16-bit thread exception handler chain
    PCONTEXT	    tdb_pcontext; // pointer to context. if 0, goto ring 0
    HANDLE	    tdb_ihteDebugger; // thread handle for debugger
    struct _der *   tdb_pderDebugger; // pointer to debugger control block
    DWORD	    ercError;	// extended error code for last thread error
    VOID *	    pvEmulData; // Pointer to emulator data area
    VOID *	    pStackBase; // stack object base address
    struct TDBX *   ptdbx;	// ring 0 per thread data pointer
    // wnodLst is 8 bytes, tib has grown, only need 4 bytes here
    DWORD           dwPad2;      // just to pad, see comment on ppdbProc. 

    LPVOID	    TlsArray[TLS_MINIMUM_AVAILABLE+TLS_MINIMUM_AVAILABLE_GLOBAL]; // thread local storage array
    LONG	    tpDeltaPri;	// delta from base priority class
    TPITERM	    tdb_tpiterm;// tpi and termination data union
    struct _createdata16 * pCreateData16; // ptr to creat data for 16-bit creat
    DWORD	    dwAPISuspendCount;	      // suspend/resume api count
    LPSTR           lpLoadLibExDir; // ptr to LoadLibraryEx() dir
    
    // For 16-bit threads only
    WORD	    wSSBig;	   // selector of optional Big Stack
    WORD	    wPad2;	
    DWORD	    lp16SwitchRec;

    DWORD	    tdb_htoEndTask;
    DWORD	    tdb_cMustCompletely;
    
#ifdef DEBUG
    DWORD	    apiTraceReenterCount;     // api trace reenter count
    PWORD	    pSavedRip;	// pointer to saved rip string from 16 bit krnl
    LPVOID	    
    TlsSetCallerArray[TLS_MINIMUM_AVAILABLE+TLS_MINIMUM_AVAILABLE_GLOBAL]; // caller's to TlsSetValue
#endif
#ifdef  WOW
    HANDLE      hTerminate;
#endif
} TDB;

typedef TDB *PTDB;

#define TDBSTUBSIZE     sizeof(TDB)

/* Flags for fields of TDB.flFlags
*/

#define fCreateThreadEvent	0x00000001
#define fCancelExceptionAbort	0x00000002
#define fOnTempStack		0x00000004
#define fGrowableStack		0x00000008
#define fDelaySingleStep	0x00000010
#define fOpenExeAsImmovableFile	0x00000020
#define fCreateSuspended	0x00000040
#define	fStackOverflow		0x00000080
#define fNestedCleanAPCs        0x00000100
#define	fWasOemNowAnsi		0x00000200
#define	fOKToSetThreadOem	0x00000400
#define fTermCleanupStack       0x00000800
#define fInCreateProcess        0x00001000
#define fHoldDisplay            0x00002000
#define fHoldSystem             0x00004000

/* Flags for fields of PDB.flFlags
*/

#define fDebugSingle		0x00000001
#define fCreateProcessEvent	0x00000002
#define fExitProcessEvent	0x00000004
#define fWin16Process		0x00000008
#define fDosProcess		0x00000010
#define fConsoleProcess		0x00000020
#define fFileApisAreOem		0x00000040
#define fNukeProcess 		0x00000080
#define fServiceProcess		0x00000100
#define fProcessCreated         0x00000200
#define fDllRedirection		0x00000400
#define fLoginScriptHack	0x00000800 //DOS app loaded into existing console and TSR'd

/* These bits can be in either the TDB or the PDB
*/

#define fSignaled		0x80000000
#define fInitError		0x40000000
#define fTerminated		0x20000000
#define fTerminating		0x10000000
#define fFaulted		0x08000000
#define fTHISFLAGISFREE         0x04000000
#define fNearlyTerminating	0x00800000
#define fDebugEventPending	0x00400000
#define fSendDLLNotifications	0x00200000

/* Process Data Block Structure and support defines and structures.
*/

typedef VOID (KERNENTRY *PFN_CONTROL)(DWORD CtrlType);

/* Environment data block for various per-process data including arguments,
** current directories, handles, and environment strings. This data block
** resides in the scratch heap.
*/

typedef struct _edb {
    char *	    pchEnv;		/* environment block (preceded by PchEnvHdr) */
    DWORD	    unused;		/* was cbEnvMax */
    char *	    szCmdA;		/* command line (ANSI copy)*/
    char *	    szDir;		/* current directory of process */
    STARTUPINFO *   lpStartupInfo;	/* pointer to startup information */
    HANDLE	    hStdIn;		/* handle of standard in */
    HANDLE	    hStdOut;		/* handle of standard out */
    HANDLE	    hStdErr;		/* handle of standard error */
    HANDLE	    hProc;		/* handle to the owning process. */
    struct _console * pInheritedConsole; /* Console to inherit if needed */
    DWORD	    ctrlType;		/* ctrlNone, ctrlC, ctrlBreak */
    SEM *	    psemCtrl;		/* Protects access to control data */
    EVT *	    pevtCtrl;		/* Control C or Break event */
    TDB *	    ptdbCtrl;		/* Control handler thread */
    PFN_CONTROL *   rgpfnCtrl;		/* Array of Control C or Break handlers */
    int		    cpfnCtrlMac;	/* Last item in array */
    int		    cpfnCtrlMax;	/* Size of array */
    char *	    rgszDirs[26];	/* array of drive directories */
    LPWSTR 	    szCmdW;		/* command line (Unicode copy)*/
    char *	    szDirO;		/* current directory OEM copy*/

} EDB;


// We need a fake DOS MCB structure at the start of our Win32 environment 
// block, because this block also doubles as the DOS environment for Win16
// apps.
struct _dosMCB {
    BYTE	type;		// Set to 'M'
    BYTE	owner_lo;	// Owner PSP
    BYTE	owner_hi;
    BYTE	size_lo;	// Size (in paragraphs)
    BYTE	size_hi;
    BYTE	unused[11];
};


// PCHENVHDR: This header structure must precede the environment strings
// block pointed to by _edb->pchEnv. It contains the info about the
// block allocation.
typedef struct _pchEnvHdr {
    DWORD	    dwSig;		/* Signature: must be PCHENVHDR_SIG */
    DWORD	    cbReserved;		/* # of bytes reserved (must be page-size divisible) */
    DWORD	    cbCommitted;	/* # of bytes committed (must be page-size divisible) */
    struct _pdb *   ppdb;		/* PDB32 who's context this belongs to. */
    struct _dosMCB  MCB;		/* Fake DOS MCB for compatibility */
    // Do not add any fields after the MCB. The MCB must immediately precede
    // the environment strings for compatibility.
} PCHENVHDR, *LPPCHENVHDR;

#define PCHENVHDR_SIG 0x45484350	/* 'PCHE' */


// MODREF - a double, doubly linked list of module references.
// Each loaded module has its own MODREF record.  Follow the
// nextMod element to get a list of modules owned by the process.
// Follow the nextPdb element to get a list of PDBs that refer
// to this module. 

#define fModRecycle		0x8000	/* This modules read only sections
				** should be recycled in context (i.e. before they go away)
				*/

#define fModRetain      0x400   /* Used to prevent child from getting
                                ** freed before the parent 
                                */


#define fModRefSnapped	0x200	/* This module's IATs are fixed up
				** in this context (so what is 
				** 'fModFixupIAT' below?)
				*/

#define	fModPrivateResource 0x100/* the resource object has been privatized
				** in this process.  Attaches should not be
				** made to the resource object.
				*/
#define fModFixupIAT	0x80	/* the IAT has been already fixed
				** up for debugging
				*/
#define fModNoThrdNotify 0x40	/* doesn't need thread notifications */

#define fModHasStaticTLS 0x20   /* this module has static TLS */

#define fModRefShared	0x10	/* this MODREF is in a shared arena */

#define fModAttach	0x8	/* process attach notification has been sent
				** to this module in this process context
				*/

#define fModDebug	0x4	/* debug notification has been sent
				** to the debugger for this module
				*/

#define fModPrivate	0x2	/* the module has been privatized in this
				** process.  Attaches should not be made.
				*/
#define fModBusy	0x1	/* set to detect dependency loops */

#define MOD_USAGE_MAX	0xffff
typedef struct _tagMODREF {
    struct _tagMODREF
	*	nextMod,		// next module in this process
	*	prevMod,
	*	nextPdb,		// next process linked to this mod
	*	prevPdb;
    IMTE	imte;			// index in module table
    WORD	usage;			// reference count this process to this module
    WORD	flags;			// fModFlags as set above
    WORD	cntRefs;		// count of implicit references
    struct _pdb *ppdb;			// process that owns module
    struct _tagMODREF *refs[1];		// implicit refs of this module, variable length
					// Must be last item in structure
} MODREF;

// Entrypoints into WSOCK32.DLL
struct socket_epts {
    DWORD recv;
    DWORD arecv;
    DWORD send;
    DWORD asend;
    DWORD close;
};

#define MAX_PROCESS_DWORD 1

typedef struct _pdb {
    COMMON_NSOBJECT			// standard waitable non-synchronization object
    DWORD	    dwReserved1;	// so that other offsets don't change
    DWORD	    dwReserved2;	// so that other offsets don't change
    DWORD	    dwStatus;		// process termination status code
    DWORD	    wasDwImageBase;	// Points to header of process (MZ + stub)
    struct heapinfo_s *hheapLocal;	// DON'T MOVE THIS!!! handle to heap in private memeory
    DWORD	    hContext;		// handle to process' private memory context
    DWORD	    flFlags;		// debugging and inheritance flags
    PVOID	    pPsp;		// linear address of PSP
    WORD	    selPsp;		// selector of the PSP for the process
    SHORT	    imte;		// index to module table entry for this process
    SHORT	    cntThreads;		// number of threads in this process
    SHORT	    cntThreadsNotTerminated; // threads not past termination code
    SHORT	    cntFreeLibRecurse;	// keep track of recursion into FreeLibrary
    SHORT	    R0ThreadCount;	// ring 0 version of same
    HANDLE	    hheapShared;	// handle to heap in shared memory
    DWORD	    hTaskWin16;		// associated Win16 task handle
    struct fvd_s *  pFvd;		// ptr to memory mapped file view descriptors
    EDB *	    pedb;		// pointer to environment data block
    struct _htb *   phtbHandles;
    struct _pdb *   ppdbParent;		// pointer to PDB of parent process
    MODREF *	    plstMod;		// pointer to process module table list
    struct _lst *   plstTdb;		// pointer to list of process threads
    struct _dee *   pdb_pdeeDebuggee;	// pointer to debuggee control block
    struct lhandle_s *plhFree;		// Local heap free handle list head ptr
    DWORD	    pid;		// id, same as initial thread id
    LCRST	    crstLoadLock;	// per-process load synch (hierarchical)
    struct _console * pConsole;		// pointer to Console for this process
    DWORD	    TlsIdxMask[((TLS_MINIMUM_AVAILABLE+31)/32)]; // mask of used TLS idxs
    DWORD	adw[MAX_PROCESS_DWORD]; // free-form storage
    struct _pdb *   ppdbPGroup;		// process group this process belongs to (default 0)
    MODREF *	    pModExe;		// parent EXE ModRef record
    LPTOP_LEVEL_EXCEPTION_FILTER pExceptionFilter; // set by SetUnhandledExceptionFilter
    LONG	    pcPriClassBase;	// priority value of this processes' pri class
    struct heapinfo_s *hhi_procfirst;	// linked list of heaps for this process
    struct lharray_s *plhBlock;		// local heap lhandle blocks
    struct socket_epts * psock_epts;	// socket entrypoints
    struct _console * pconsoleProvider;	// pconsole that winoldapp is providing.
    WORD	    wEnvSel;		// selman alloced DOS environment selector
    WORD	    wErrorMode;		// handling of critical errors
    PEVT	    pevtLoadFinished;	// waiting for load to be finished
    WORD	    hUTState;		// UT info
    BYTE            bProcessAcpiFlags;  // ACPI flags for this process, see def below
    BYTE	    bPad3;
    LPCSTR	    lpCmdLineNoQuote;	// Optional unquoted command line (apphack)
} PDB;

//
// Flags def for bProcessAcpiFlags
//
#define PROCESS_ACPI_FLAGS_WAKEUP_LT_DONT_CARE      0x00
#define PROCESS_ACPI_FLAGS_WAKEUP_LT_LOWEST_LATENCY 0x01

#define PDBSTUBSIZE	sizeof(PDB)

typedef PDB *PPDB;

/* File Data Block Structure.
*/

/* SPECIAL  NOTE on memory mapped files and cached file handles
 * CreateFile(filename, FILE_FLAG_MM_CACHED_FILE_HANDLE);
 * In this case the caller indicates an intention to later
 * call CreateFileMapping(hFile, ...) and desires that the file
 * handle we will using be a cached file handle.
 * So we store away the filename and fsAccessDos in the FDB and 
 * in CreateFileMapping() retrieve the filename and flgs for use 
 * in implementing cached file handles, where extended handles are
 * not available. eg. real-mode netware drivers
 */


typedef struct _cfh_id {
    DWORD	    fsAccessDos;	/* dos openfile flgs: used for cached fh
					 * of memory mapped files
					 */
    LPSTR lpFilename;			/* filename stored only for 
					 * cached Memory mapped files 
					 * win32 loader modules and
					 * delete_on_close 
					 */
} CFH_ID;

typedef struct _fdb {
    COMMON_NSOBJECT		// standard waitable non-synchronization object
    WORD	    hdevDos;		/* DOS device handle */
    WORD	    wDupSrcPSPSel;	/* NETX: if inter-process dup'ed
					 * holds the PSP dup'ed from so that
					 * PSP will remain around till this
					 * handle gets closed.
					 */
    CFH_ID	    cfhid;
    DWORD           devNode;            // The devvice node where the handle lives on
    DWORD           dwCountRequestDeviceWakeup;
} FDB, *PFDB;

/* 
 * Spl value for FDB.fsAccessDos to indicate that filename stored should be
 * deleted on close.
 */
#define	DELETE_ON_CLOSE_FILENAME	-1

/* Find Change Notify Data Block Structure.
*/

typedef struct _fcndb {
    COMMON_NSOBJECT			// base of every ns object structure
    DWORD	    hChangeInt;		/* internal change handle */
} FCNDB;

typedef FCNDB *PFCNDB;

/* Pipe Data Block Structure.
*/

typedef struct _pipdb {
    COMMON_OBJECT			// base of every object structure
    BYTE *	     hMem;		// Mem handle of pipe
    DWORD	     hNmPipe;		// Named pipe handle (hInvalid if anon)
    DWORD	     rdRef;		// Ref count on read handle
    DWORD	     wrRef;		// Ref count on write handle
    DWORD	     pszByt;		// Size of hMem (pipe) in bytes
    DWORD	     wPtr;		// write pointer (offset in hMem)
					//   Pointer to last byte written
    DWORD	     rPtr;		// read  pointer (offset in hMem)
					//   Pointer to next byte to read
    EVT *	     wBlkEvnt;		// write event handle (waiting for room to write)
    EVT *	     rBlkEvnt;		// read event handle (waiting for data	to read)
} PIPDB;

/* MailSlot Data Block Structure.
*/

typedef struct _msdb {
    COMMON_OBJECT			// base of every object structure
    LPSTR	     lpMSName;		// Pnt to name of mailslot (== 0 for
					//   read (CreateMailslot) handle)
    DWORD	     hMSDos;		// INT 21 mailslot handle (== 0xFFFFFFFF
					//   for write (CreateFile) handle)
} MSDB;

/* ToolHelp Data Block Structure.
*/

typedef struct _tlhpdb {
    COMMON_OBJECT			// base of every object structure
    DWORD    ClassEntryCnt;
    BYTE   * ClassEntryList;		// actually (CLASSENTRY32 *)
    DWORD    HeapListCnt;
    BYTE   * HeapList;			// actually (HEAPLIST32 *)
    DWORD    ProcessEntryCnt;
    BYTE   * ProcessEntryList;		// actually (PROCESSENTRY32 *)
    DWORD    ThreadEntryCnt;
    BYTE   * ThreadEntryList;		// actually (TREADENTRY32 *)
    DWORD    ModuleEntryCnt;
    BYTE   * ModuleEntryList;		// actually (MODULEENTRY32 *)
} TLHPDB;

/* Device IO Control Object
 */
typedef struct _diodb {
    COMMON_OBJECT			// base of every object structure
    DWORD	    pDDB;	/* VxD/device DDB */
    LPSTR	    lpUnloadOnCloseModuleName; /* delete_on_close for a vxd */
    char	    DDB_Name[8];
} DIODB;

/* Serial Data Block Structure
*/

#define	OVERLAPPED_OPEN		1
#define READEVENT_INUSE		2
#define	WRITEEVENT_INUSE	4

typedef struct _sdb {
    COMMON_OBJECT		// base of every object structure
    DWORD	    SerialHandle;
    EVT	*	    pWriteEvent;
    EVT *	    pReadEvent;
    EVT *	    pWaitEvent;
    DWORD	    Flags;
    DWORD           DevNode;
    DWORD           dwCountRequestDeviceWakeup;
} SDB;

typedef VOID (CALLBACK *PTIMER_APC_ROUTINE)(LPVOID,ULONG,LONG);



// Timer object.
//
//   Notes:
//     The timerdb must ALWAYS be pagelocked. This is consistent
//     with the requirement that the structure passed to KeSetTimer
//     be pagelocked. Furthermore, we use the non-preemptibility of
//     of ring-0 code to serialize access to many parts of the structure
//     (due to the fact that much of this code has to run at event time.)
//     This non-preemptibility is guaranteed only if the structure is
//     locked.
//
//     Timers can be created at ring-0 or ring-3. If a timer is created at
//     ring-3, the memory is always allocated and deallocated by kernel32.
//     Kernel32 also makes sure that an explicit canceltimer is always done
//     on the timer before it is finally freed - we depend on this fact
//     to do the proper cleanup for timerr3apc's.
//
//     Timers created at ring-3 can be passed to Ke* routines.
//
//     Timers created at ring-0 cannot be passed to SetWaitableTimer() at
//     ring-3. (There are some nasty cleanup problems associated with this
//     due to the fact that ring-0 timers are freed by the device driver
//     with no notification given to the system.)
//
//     We use the cntUses field to determine whether a timer was created
//     at ring 3.
//
//   Synchronization:
//
//     typObj          Static, none needed
//     objFlags 
//       fTimerIsRing3 by being in a no-preempt section
//     cntUses         Used by handle manager
//     pwnWait         WaitR0
//     cntCur          WaitR0 [w/ one exception: see [1])
//     NameStruct      Krn32Lock - used only at ring3
//     lpNextTimerDb   by being in a no-preempt section
//     hTimeout	       by being in a no-preempt section
//     DueTime         by being in a no-preempt section
//     Completion      by being in a no-preempt section
//     lPeriod         by being in a no-preempt section
//
//     [1] Because KeSetTimer has to unsignal the timer, and be
//         able to do it at event time, it pokes a zero directly
//         into cntCur. But this is ok because the only code
//         that signals timers is TimerDoTimeout which is
//         non-preemptive.
//
//  Flag descriptions:
//
//     fTimerIsEventHandle
//        hTimeout - a timeout handle
//        
//     fTimerIsRing3
//        If the COMPLETION is non-null, this bit indicates whether the
//        COMPLETION points to a TIMERR3APC (ring-3 completion) or a KDPC
//        (ring-0 completion.) The value of this bit is undefined at any
//        other time.
//
//  Field descriptions:
//
//     <common-obj and common-sync stuff omitted>
//
//     lpNextTimerDb:
//        All active timers that were set with fResume TRUE are linked into
//        TimerSysLst (for the purpose of knowing how to program the power
//        timer.) This field is NULL when the timer is inactive or active
//        without fResume.
//
//     hTimeout:
//        If the timer is active, this field contains the handle to the
//        underlying VMM hTimeout. If the timer is inactive, this
//        field is NULL. If the timer is in the in-progress state,
//        this field is undefined (actually points to a stale VMM timeout
//        handle!)
//
//
//     DueTime:
//        If the timer is active, contains the absolute time that the
//        timer is due to go off. Expressed as a FILETIME converted from
//        GetSystemTime. Undefined if the timer isn't active.
//
//     Completion:
//        Then contains either:
//           NULL          - no completion was set
//           LPTIMERR3APC  - if fTimerIsRing3 is set
//           PKDPC         - if fTimerIsRing3 is not set.
//
//        Note that it is normal for a timer to be inactive and contain
//        a pointer to a TIMERR3APC structure. This case occurs when
//        a timer set with a ring-3 completion fires normally. The
//        TIMERR3APC structure is kept around so that a subsequent
//        CancelWaitableTimer() can retrieve the underlying apc handle
//        embedded in it.
//
//     lPeriod:
//        Contains either 0 for a one-shot timer or a positive value
//        (the firing period in milliseconds.)


typedef struct _timerdb {
    COMMON_OBJECT		     // standard waitable non-synchronization object

// These fields have to appear in this form because a timer is a sync object.
    WNOD	       *pwnWait;     // pointer to the wait node for this object
    LONG	        cntCur;      // signaled state
    OBJNAME            *NameStruct;  // name structure for this object

// These fields are timer-specific.
    struct _timerdb    *lpNextTimerDb; //Link in TimerSysLst (can be NULL)
    DWORD               hTimeout;
    FILETIME            DueTime;
    DWORD               Completion;
    LONG                lPeriod;         //Optional period
// Try not to add new fields. This structure cannot exceed 40 bytes
// or we break compatibility with NT's Ke api. If you try to hang
// another structure off it, remember that the Ke*Timer apis can't
// allocate memory from the heap (system meltdown if these apis
// are called at event time on a system that's paging thru DOS.)

} TIMERDB, *LPTIMERDB;


//
// A dynamic extension to the timerdb that's used whenever a ring-3 timer
// is armed with a completion function. This structure must live in locked
// memory.
//
// Access to this structure is serialized by being in a no-preempt section.
// There are no semaphores guarding it.
//
// This structure is allocated whenever SetWaitableTimer() is called on a
// timer with a non-null completion function. It's stored in the Completion
// field and the fTimerIsRing3 bit is set to indicate that this a TIMERR3APC
// (opposed to a ring-0 DPC.)
//
// This structure is detached from the timerdb on the next call to
// CancelWaitableTimer(). It's also usually freed at this time except
// if a cancel occurs after the last apc has been delivered but TimerApcHandler
// hasn't yet set fHandlerDone to indicate that's it finished using the
// structure. In this case, we can't free it so we instead link it onto
// the TimerDisposalWaitingList. When fHandlerDone does become TRUE,
// it will be available for pickup the next time we need one of these
// structures.
//
// The automatic rearming of a periodic timer reuses the existing
// TIMERR3APC. It checks the fHandleDone: if the handler hasn't
// finished (or begun) on the previous apc, we don't schedule a new
// one (as per specs).
//
// Fields:
//     cRef		 - reference count
//     pfnCompletion     - Ptr to ring-3 completion (never NULL)
//     lpCompletionArg   - uninterpreted argument to pfnCompletion
//     R0ThreadHandle    - thread that called SetWaitableTimer()
//     DueTime           - trigger time to pass to pfnCompletion. This
//                         field isn't set until the timer goes off.
//     dwApcHandle       - if apc has been queued, contains the underlying
//                           apc handle. NULL otherwise. This apc handle gets
//                           freed at the same time we free the TIMERR3APC
//                           (or in the case of a periodic timer, when we
//                           reuse the structure for the next arming.)
//     lpNext            - Used for linking in TimerDisposalWaitingList,
//                         undefined otherwise.
//
//
//
typedef struct _timerr3apc {

   DWORD                     cRef;
   PTIMER_APC_ROUTINE        pfnCompletion;   //completion routine 
   LPVOID                    lpCompletionArg; //arg to pass to pfnCompletion
   DWORD                     ApcTdbx;         //thread that set the timer
   FILETIME                  DueTime;         //the DueTime passed to completion
   DWORD                     dwApcHandle;     //underlying apc handle
   struct _timerr3apc       *lpNext;          //next ptr
   LPTIMERDB                 lpTimerDB;       // back pointer to my TimerDB
} TIMERR3APC, *LPTIMERR3APC;



//  Ring 0 External Object.
//
//  Kernel object used to store data about an externally allocated object.  VxDs
//  can use the VWIN32_AllocExternalHandle service to make a Win32 handle for
//  one of their data structures and return the handle back to a Win32 app.
//  An application may use this handle to communicate with the VxD, ideally
//  through the DeviceIoControl interface.  The VxD can get back to the original
//  object by using the VWIN32_UseExternalObject service.  When the VxD is
//  through using the object, it must call VWIN32_UnuseExternalObject.
//
//  Because the handle returned by VWIN32_AllocExternalHandle is a standard
//  Win32 handle, all of the standard Win32 handle services, such as
//  DuplicateHandle, will work with it.  In addition, when a process terminates,
//  the object cleanup is automatically performed.  Thus, a VxD doesn't have to
//  watch process notification messages just to check if a per-process data
//  structure should be cleaned-up.
//
//  When allocating the Win32 handle, the VxD provides a virtual table (vtbl) of
//  functions to invoke whenever type specific handle operations are performed.
//  For example, when the usage count of an object goes to zero, the vtbl is
//  used to notify the VxD that the external object should be released.

struct _R0OBJTYPETABLE;                 //  Forward reference (in vwin32.h)

typedef struct _r0objext {
    COMMON_NSOBJECT
    DWORD                   cntExternalUses;
    struct _R0OBJTYPETABLE* pR0ObjTypeTable;
    LPVOID                  pR0ObjBody;
    ULONG                   devNode;
} R0OBJEXT, * PR0OBJEXT;


//
// objTypMsgIndicator
//

typedef struct _MsgIndicatorDb {
    COMMON_NSOBJECT
    ULONG       ulMsgCount;
} MSGINDICATORDB, *PMSGINDICATORDB;

/* ------------------------------------------------------------ */
/*		Function Prototypes
/* ------------------------------------------------------------ */

GLOBAL	VOID	    KERNENTRY	UseObject (VOID *);	// incs usage count
GLOBAL  OBJ *       KERNENTRY   NewObject (DWORD, BYTE); // allocates generic obj of size and type
GLOBAL	VOID	    KERNENTRY	DisposeObject (OBJ *);	// deallocates generic object
GLOBAL	BOOL	    KERNENTRY	FUnuseObject (VOID *);	// decs usage count
GLOBAL	OBJ *	    KERNENTRY	PobjDupObject (OBJ *, PDB *, PDB *);	// duplicates pointer to object
GLOBAL	VOID	    KERNENTRY	LockObject(OBJ *);
GLOBAL	VOID	    KERNENTRY	UnlockObject(OBJ *);
GLOBAL	MODREF *    KERNENTRY	MRAlloc(IMTE imte, PDB *ppdb);

#endif

/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/****************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\minivdd.inc ===
ifndef _MINIVDD_H_
_MINIVDD_H_     EQU     1
ifndef Not_VxD
ifdef MINIVDD
ifdef NEC_98
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Register_Mini_VDD
VDD_Service     VDD_Install_IO_Handler
VDD_Service     VDD_Install_Mult_IO_Handlers
VDD_Service     VDD_Enable_Local_Trapping
VDD_Service     VDD_Disable_Local_Trapping
VDD_Service     VDD_Trap_Suspend
VDD_Service     Test_Vid_VM_Handle
VDD_Service     VDD_Set_Core_Graphics
VDD_Service     VDD_Load_AccBIOS
VDD_Service     VDD_Map_AccBIOS
VDD_Service     VDD_Map_VRAM
VDD_Service     VDD_EnableDevice
End_Service_Table VDD
else
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Set_Sleep_Flag_Addr
VDD_Service      VDD_EnableDevice
End_Service_Table VDD
endif
endif
VDD_VerNum      EQU     0400H
VDD_MinVerNum   EQU     030AH
ifdef NEC_98
bVidTextMd      EQU     4
fVidTextMd      EQU     (1 SHL 4)
bVidNTModeFF    EQU     0
fVidNTModeFF    EQU     (1 SHL 0)
bVidNTModeFFC16 EQU     1
fVidNTModeFFC16 EQU     (1 SHL 1)
bVidNTDispRW    EQU     2
fVidNTDispRW    EQU     (1 SHL 2)
bVidNTPal       EQU     3
fVidNTPal       EQU     (1 SHL 3)
bVidNTGDC       EQU     5
fVidNTGDC       EQU     (1 SHL 5)
bVidNTGDCTON    EQU     6
fVidNTGDCTON    EQU     (1 SHL 6)
bVidNTGDCGON    EQU     7
fVidNTGDCGON    EQU     (1 SHL 7)
bVidNTFont      EQU     8
fVidNTFont      EQU     (1 SHL 8)
bVidCRTC        EQU     9
fVidCRTC        EQU     (1 SHL 9)
bVidDispDataXfer        EQU     10
fVidDispDataXfer        EQU     (1 SHL 10)
bVidXFERPlane0  EQU     11
fVidXFERPlane0  EQU     (1 SHL 11)
bVidXFERPlane1  EQU     12
fVidXFERPlane1  EQU     (1 SHL 12)
bVidXFERPlane2  EQU     13
fVidXFERPlane2  EQU     (1 SHL 13)
bVidXFERPlane3  EQU     14
fVidXFERPlane3  EQU     (1 SHL 14)
mVidXFERPlane   EQU     (fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
mVidNTH98       EQU     (fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
else
fVidTxtEmulate  EQU     0001H
fVidNoTrpTxt    EQU     0002H
fVidNoTrpLRGrfx EQU     0004H
fVidNoTrpHRGrfx EQU     0008H
fVidTextMd      EQU     0010H
fVidLowRsGrfxMd EQU     0020H
fVidHghRsGrfxMd EQU     0040H
fVidRetainAllo  EQU     0080H
endif
ifdef NEC_98
REGISTER_DISPLAY_DRIVER EQU     0
PRE_HIRES_TO_VGA        EQU     1
SAVE_REGISTERS  EQU     2
RESTORE_REGISTERS       EQU     3
ENABLE_TRAPS    EQU     4
DISABLE_TRAPS   EQU     5
DISPLAY_DRIVER_DISABLING        EQU     6
ENABLE_ACCELERATER      EQU     7
DISABLE_ACCELERATER     EQU     8
CHECK_UPDATE    EQU     9
CHECK_WINDOWED  EQU     10
ACC_VBE_PM      EQU     11
ACC_VBE_DDC     EQU     12
ACC_INT_10      EQU     13
ACC_GET_CAPABILITIES    EQU     14
ACC_GET_EXT_MODE_INFO   EQU     15
ACC_GET_FLAT_SELECTOR   EQU     16
ACC_ENABLE_BIOS EQU     17
ACC_DISABLE_BIOS        EQU     18
ACC_SET_PALETTE EQU     19
ACC_GET_PALETTE EQU     20
ACC_SET_CURSOR  EQU     21
ACC_SHOW_CURSOR EQU     22
ACC_HIDE_CURSOR EQU     23
ACC_SET_CURSOR_POS      EQU     24
ACC_GET_CURSOR_POS      EQU     25
CM_POWERSTATE_HIBERNATE EQU     00000010H
CM_POWERSTATE_VDD_VALID EQU     <(CM_POWERSTATE_BITS OR CM_POWERSTATE_HIBERNATE)>
NBR_MINI_VDD_FUNCTIONS_40       EQU     26
GET_NUM_UNITS   EQU     26
SET_ADAPTER_POWER_STATE EQU     27
GET_ADAPTER_POWER_STATE_CAPS    EQU     28
SET_MONITOR_POWER_STATE EQU     29
GET_MONITOR_POWER_STATE_CAPS    EQU     30
GET_MONITOR_INFO        EQU     31
I2C_OPEN        EQU     32
I2C_ACCESS      EQU     33
GPIO_OPEN       EQU     34
GPIO_ACCESS     EQU     35
COPYPROTECTION_ACCESS   EQU     36
NBR_MINI_VDD_FUNCTIONS_41       EQU     37
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
else
REGISTER_DISPLAY_DRIVER EQU     0
GET_VDD_BANK    EQU     1
SET_VDD_BANK    EQU     2
RESET_BANK      EQU     3
PRE_HIRES_TO_VGA        EQU     4
POST_HIRES_TO_VGA       EQU     5
PRE_VGA_TO_HIRES        EQU     6
POST_VGA_TO_HIRES       EQU     7
SAVE_REGISTERS  EQU     8
RESTORE_REGISTERS       EQU     9
MODIFY_REGISTER_STATE   EQU     10
ACCESS_VGA_MEMORY_MODE  EQU     11
ACCESS_LINEAR_MEMORY_MODE       EQU     12
ENABLE_TRAPS    EQU     13
DISABLE_TRAPS   EQU     14
MAKE_HARDWARE_NOT_BUSY  EQU     15
VIRTUALIZE_CRTC_IN      EQU     16
VIRTUALIZE_CRTC_OUT     EQU     17
VIRTUALIZE_SEQUENCER_IN EQU     18
VIRTUALIZE_SEQUENCER_OUT        EQU     19
VIRTUALIZE_GCR_IN       EQU     20
VIRTUALIZE_GCR_OUT      EQU     21
SET_LATCH_BANK  EQU     22
RESET_LATCH_BANK        EQU     23
SAVE_LATCHES    EQU     24
RESTORE_LATCHES EQU     25
DISPLAY_DRIVER_DISABLING        EQU     26
SELECT_PLANE    EQU     27
PRE_CRTC_MODE_CHANGE    EQU     28
POST_CRTC_MODE_CHANGE   EQU     29
VIRTUALIZE_DAC_OUT      EQU     30
VIRTUALIZE_DAC_IN       EQU     31
GET_CURRENT_BANK_WRITE  EQU     32
GET_CURRENT_BANK_READ   EQU     33
SET_BANK        EQU     34
CHECK_HIRES_MODE        EQU     35
GET_TOTAL_VRAM_SIZE     EQU     36
GET_BANK_SIZE   EQU     37
SET_HIRES_MODE  EQU     38
PRE_HIRES_SAVE_RESTORE  EQU     39
POST_HIRES_SAVE_RESTORE EQU     40
VESA_SUPPORT    EQU     41
GET_CHIP_ID     EQU     42
CHECK_SCREEN_SWITCH_OK  EQU     43
VIRTUALIZE_BLTER_IO     EQU     44
SAVE_MESSAGE_MODE_STATE EQU     45
SAVE_FORCED_PLANAR_STATE        EQU     46
VESA_CALL_POST_PROCESSING       EQU     47
PRE_INT_10_MODE_SET     EQU     48
NBR_MINI_VDD_FUNCTIONS_40       EQU     49
CM_POWERSTATE_HIBERNATE EQU     00000010H
CM_POWERSTATE_VDD_VALID EQU     <(CM_POWERSTATE_BITS OR CM_POWERSTATE_HIBERNATE)>
GET_NUM_UNITS   EQU     49
TURN_VGA_OFF    EQU     50
TURN_VGA_ON     EQU     51
SET_ADAPTER_POWER_STATE EQU     52
GET_ADAPTER_POWER_STATE_CAPS    EQU     53
SET_MONITOR_POWER_STATE EQU     54
GET_MONITOR_POWER_STATE_CAPS    EQU     55
GET_MONITOR_INFO        EQU     56
I2C_OPEN        EQU     57
I2C_ACCESS      EQU     58
GPIO_OPEN       EQU     59
GPIO_ACCESS     EQU     60
COPYPROTECTION_ACCESS   EQU     61
NBR_MINI_VDD_FUNCTIONS_41       EQU     62
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS  EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
endif
endif
VDD_QUERY_VERSION       EQU     0
MINIVDD_SVC_BASE_OFFSET EQU     80H
VDD_DRIVER_REGISTER     EQU     (0+MINIVDD_SVC_BASE_OFFSET)
VDD_DRIVER_UNREGISTER   EQU     (1+MINIVDD_SVC_BASE_OFFSET)
VDD_SAVE_DRIVER_STATE   EQU     (2+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_DISPLAY_DRIVER_INFO        EQU     (3+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_SSB_FLAGS  EQU     (4+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG  EQU     (5+MINIVDD_SVC_BASE_OFFSET)
VDD_PRE_MODE_CHANGE     EQU     (6+MINIVDD_SVC_BASE_OFFSET)
VDD_POST_MODE_CHANGE    EQU     (7+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_USER_FLAGS      EQU     (8+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_BUSY_FLAG_ADDR  EQU     (9+MINIVDD_SVC_BASE_OFFSET)
VDD_PC98_RESERVED       EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_VBE_PM      EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_ENABLE      EQU     (11+MINIVDD_SVC_BASE_OFFSET)
VDD_GETMEMBASE  EQU     (12+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN        EQU     (13+MINIVDD_SVC_BASE_OFFSET)
VDD_CLOSE       EQU     (14+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN_KEY    EQU     (15+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_POWER_STATE     EQU     (16+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_POWER_STATE_CAPS        EQU     (17+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG2 EQU     8085H
ENABLE_IO       EQU     00000001H
ENABLE_MEM      EQU     00000002H
ENABLE_VGA      EQU     00000030H
ENABLE_ROM      EQU     00000080H
ENABLE_ALL      EQU     000000FFH
ENABLE_NONE     EQU     00000000H
ENABLE_VALID    EQU     000000FFH
ENABLE_ERROR    EQU     0FFFFFFFFH
VDD_OPEN_EXIST  EQU     00000001H
VDD_OPEN_ENUM   EQU     00000002H
VDD_OPEN_LOCK   EQU     00000000H
VDD_OPEN_TEST   EQU     VDD_OPEN_EXIST
VDD_OPEN_KEY_WRITE      EQU     00000001H
VDD_OPEN_KEY_READ       EQU     00000002H
VDD_OPEN_KEY_USER       EQU     00000010H
VDD_OPEN_KEY_GLOBAL     EQU     00000020H
VDD_IOCTL_SET_NOTIFY    EQU     10000001H
VDD_IOCTL_GET_DDHAL     EQU     10000002H
VDD_IOCTL_COPY_PROTECTION       EQU     10000003H
VDD_IOCTL_I2C_OPEN      EQU     10000004H
VDD_IOCTL_I2C_ACCESS    EQU     10000005H

tagVDD_IOCTL_SET_NOTIFY_INPUT   STRUC
NotifyMask      DD      ?
NotifyType      DD      ?
NotifyProc      DD      ?
NotifyData      DD      ?
tagVDD_IOCTL_SET_NOTIFY_INPUT   ENDS
VDD_NOTIFY_START_MODE_CHANGE    EQU     00000001H
VDD_NOTIFY_END_MODE_CHANGE      EQU     00000002H
VDD_NOTIFY_ENABLE       EQU     00000004H
VDD_NOTIFY_DISABLE      EQU     00000008H
VDD_NOTIFY_TYPE_CALLBACK        EQU     1
BYTE_LENGTHED   EQU     1
WORD_LENGTHED   EQU     2
GOING_TO_WINDOWS_MODE   EQU     1
GOING_TO_VGA_MODE       EQU     2
DISPLAY_DRIVER_DISABLED EQU     4
IN_WINDOWS_HIRES_MODE   EQU     8
BLOCK_INT10     EQU     16

DISPLAYINFO     STRUC
diHdrSize       DW      ?
diInfoFlags     DW      ?
diDevNodeHandle DD      ?
diDriverName    DB      16 DUP (?)
diXRes  DW      ?
diYRes  DW      ?
diDPI   DW      ?
diPlanes        DB      ?
diBpp   DB      ?
diRefreshRateMax        DW      ?
diRefreshRateMin        DW      ?
diLowHorz       DW      ?
diHighHorz      DW      ?
diLowVert       DW      ?
diHighVert      DW      ?
diMonitorDevNodeHandle  DD      ?
diHorzSyncPolarity      DB      ?
diVertSyncPolarity      DB      ?
diUnitNumber    DD      ?
diDisplayFlags  DD      ?
diXDesktopPos   DD      ?
diYDesktopPos   DD      ?
diXDesktopSize  DD      ?
diYDesktopSize  DD      ?
DISPLAYINFO     ENDS
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize

RETURNED_DATA_IS_STALE  EQU     0001H
MINIVDD_FAILED_TO_LOAD  EQU     0002H
MINIVDD_CHIP_ID_DIDNT_MATCH     EQU     0004H
REGISTRY_BPP_NOT_VALID  EQU     0008H
REGISTRY_RESOLUTION_NOT_VALID   EQU     0010H
REGISTRY_DPI_NOT_VALID  EQU     0020H
MONITOR_DEVNODE_NOT_ACTIVE      EQU     0040H
MONITOR_INFO_NOT_VALID  EQU     0080H
MONITOR_INFO_DISABLED_BY_USER   EQU     0100H
REFRESH_RATE_MAX_ONLY   EQU     0200H
CARD_VDD_LOADED_OK      EQU     0400H
DEVICE_IS_NOT_VGA       EQU     0800H
NoTrace_VIRTUALIZE_CRTC_IN      EQU     1
NoTrace_VIRTUALIZE_CRTC_OUT     EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_IN EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_OUT        EQU     1
NoTrace_VIRTUALIZE_GCR_IN       EQU     1
NoTrace_VIRTUALIZE_GCR_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_IN       EQU     1
NoTrace_CHECK_HIRES_MODE        EQU     1

ifdef NEC_98







vFlg_Machine_Std        equ                     00000001b
vFlg_Machine_Multi      equ                     00000010b
vFlg_Machine_Mate       equ                     00000100b
vFlg_Machine_H98        equ                     00001000b
vFlg_CRT_New            equ                     00010000b
vFlg_CRT_NonInter       equ                     00100000b
vFlg_GDC_5MHz           equ                     01000000b
vFlg_GDC_Emulate        equ                     10000000b
vFlg_Acc_Internal       equ             0000000100000000b
vFlg_Acc_External       equ             0000001000000000b
vFlg_Acc_PCI            equ             0000010000000000b
vFlg_Acc_ML             equ             0000100000000000b
vFlg_Acc_PVD            equ             0001000000000000b
vFlg_Mode_NH            equ             0010000000000000b
vFlg_Mode_H             equ             0100000000000000b
vFlg_Initialized        equ             1000000000000000b
vFlg_Opt_MFR            equ     000000010000000000000000b
vFlg_Opt_NewMFR         equ     000000100000000000000000b
vFlg_Opt_VDP            equ     000001000000000000000000b
vFlg_Opt_NewVDP         equ     000010000000000000000000b

vFlg_Local              equ     000000000100000010000000b




MaxMiniVDD      equ     16
MaxMiniTrap     equ     32
MaxMultiTrap    equ     3
MaxMultiFunc    equ     MaxMiniVDD





LT_Enable       equ     00000001b
LT_Enable_bit   equ     0
LT_Initialized  equ     10000000b
LT_Initialized_bit equ  7










Vids_struct struc



        Vids_SFlags             dd      ?
        Vids_CB_Offset          dd      ?
        Vids_Msg_Pseudo_VM      dd      ?




        VDD_TGDC_Draw_Off       dd      ?
        VDD_TGDC_Sync_Off       dd      ?
        VDD_TGDC_Sync_On        dd      ?
        VDD_TGDC_FIFO_Empty     dd      ?
        VDD_GGDC_Draw_Off       dd      ?
        VDD_GGDC_Sync_Off       dd      ?
        VDD_GGDC_Sync_On        dd      ?
        VDD_GGDC_FIFO_Empty     dd      ?
        VDD_GGDC_MOD_Emulate    dd      ?




        H98_FLORA_Change        dd      ?
        H98_Clear_Text          dd      ?
        H98_Rest_GCs            dd      ?
        H98_Rest_etc            dd      ?
        H98_Save_ModeFF         dd      ?

Vids_struct ends


Vid_SFlags              equ     <Vids.Vids_SFlags>
VDD_CB_Offset           equ     <Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM       equ     <Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off           equ     <Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off           equ     <Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On            equ     <Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off           equ     <Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty         equ     <Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty         equ     <Vids.VDD_GGDC_FIFO_Empty>





MiniFuncStruct  STRUC
MF_ProcAddr     dd      ?



MiniFuncStruct  ENDS




MiniVDD_Proc_Struct     STRUC
Proc_Address    dd      ?
Proc_Order      dw      ?
Proc_MiniID     db      ?
Proc_Flags      db      ?
MiniVDD_Proc_Struct     ENDS
.errnz  (size MiniVDD_Proc_Struct) mod 4





MiniVDD_GTrap_Struct    STRUC
GTrap_ProcAddr  dd      ?
GTrap_PortAddr  dw      ?
GTrap_NumMini   dw      ?
GTrap_ProcTable db      ((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct    ENDS

MiniVDD_LTrap_Struct    STRUC
LTrap_ProcAddr  dd      ?
LTrap_Status    db      ?
LTrap_Flags     db      MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct    ENDS












EndMiniFunc_    MACRO   n
ifdef   MiniFunc&n
        dd      OFFSET32 MiniFunc&n
else
        dd      0
endif
                ENDM

MiniFunc_       MACRO   FuncID, FuncName
                MiniFunc&FuncID equ <FuncName>
                ENDM

BeginMiniFunc   MACRO   TableName
public  TableName
TableName       label   near
                ENDM

if 1
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS_41
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
else
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
endif

MiniFunc        MACRO   FuncID, FuncName
                MiniFunc_ %(FuncID), <FuncName>
                ENDM




MiniVDDCall     MACRO   FuncID, SetCarry
                local   MiniCall_Loop
                local   MiniCall_Exit

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                mov     ecx, [MiniVDD_NumMini]
MiniCall_Loop:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
                jc      MiniCall_Exit
                add     esi, size MiniVDD_Proc_Struct
                loop    MiniCall_Loop
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall2    MACRO   FuncID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall3    MACRO   FuncID, MiniID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Loop
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                movzx   ecx, MiniID
MiniCall_Loop:
                cmp     ecx, 0
                jz      MiniCall_Proc
                add     esi, size MiniVDD_Proc_Struct
                dec     ecx
                jmp     MiniCall_Loop
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM




MiniVDDFunc     MACRO   TmpReg, FuncID
                mov     TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                ENDM











ExecModeLL      macro   Num
ExecMode_L&Num:
                endm

ExecModeLE      macro   Num
ExecMode_E&Num:
                endm

ExecModeJE      macro   Num
        jmp     ExecMode_E&Num
                endm

ExecModeJZ      macro   Num
        jz      ExecMode_L&Num
                endm

ExecModeJNZ     macro   Num
        jnz     ExecMode_L&Num
                endm

ExecModeJEZ     macro   Num
        jz      ExecMode_E&Num
                endm

ExecModeJENZ    macro   Num
        jnz     ExecMode_E&Num
                endm


ExecModeTest    macro   ModeFlag, CB_Reg
if      ModeFlag and vFlg_Local
ifidni  <CB_Reg>, <Vid>
        push    ebx
        mov     ebx, [Vid_VM_Handle]
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifidni  <CB_Reg>, <Cur>
        push    ebx
        VMMCall Get_Cur_VM_Handle
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifb     <CB_Reg>
        push    ebx
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
        test    [CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
        test    [Vid_SFlags], ModeFlag
endif
        endm


ExecModeChk     macro   HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni  <HdrFlag>, <Jmp>
.erre   FlgExecMode
        ExecModeJE      %EndExecMode
endif
ExecModeLL      %NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb    <ModeFlag>
        ExecModeTest    <ModeFlag>, <CB_Reg>
ifidni  <JmpLabel>, <End>
ifidni  <JmpFlag>, <Not>
        ExecModeJENZ    %EndExecMode
else
        ExecModeJEZ     %EndExecMode
endif
else
ifidni  <JmpFlag>, <Not>
        ExecModeJNZ     %NumExecMode
else
        ExecModeJZ      %NumExecMode
endif
endif
endif
                endm

ExecModeEnd     macro
ExecModeLL      %NumExecMode
ExecModeLE      %EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
                endm





ExecModeJmp     macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jnz     JmpLabel
                endm

ExecModeJmpNot  macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jz      JmpLabel
                endm

ExecMode        macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeNot     macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeOnly    macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
                endm

ExecModeOnlyNot macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
                endm

ExecModeElse    macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeElseNot macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeThru    macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeThruNot macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
                endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else




ifdef MAINVDD
externdef       MiniVDDDispatchTable:dword
endif


MiniVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm


CardVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm


MiniVDDCall             macro   FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi
ifnb    <SaveFlags>
        pushfd
endif
        mov     edi,OFFSET32 MiniVDDDispatchTable
        cmp     dword ptr [edi+(FunctionCode*4)],0
        je      MiniVDDCallLeave
ifnb    <SaveFlags>
        popfd
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb    <SaveFlags>
        jmp     MiniVDDCallExit
endif

MiniVDDCallLeave:
ifnb    <SaveFlags>
        popfd
endif

MiniVDDCallExit:
        pop     edi
endm
endif

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\object.inc ===
;************************************************************************
;*									*
;*	OBJECT.INC	--  General Object Manager Definitions		*
;*									*
;************************************************************************
;*	Author:     Gene Apperson					*
;*	Copyright:  1991 Microsoft					*
;************************************************************************
;*  File Description:							*
;*									*
;*									*
;************************************************************************
;*  Revision History:							*
;*	12/15/92 (miketout) added object definitions from KERNEL32.INC	*
;*									*
;*	NOTE!!!: 2/12/93 (miketout) created WIN\CORE\INC\OBJECT16.INC	*
;*		to provide 16 bit code access to 32 bit object types	*
;*		(yes, it's not encapsulated as well, but it prevents    *
;*		thunking on some critical ops.				*
;*		OBJECT16.INC MUST REMAIN IN SYNC WITH THIS FILE		*
;*									*
;************************************************************************

;* We may be included implicitly by KERNEL32.INC. If we've already been
;* included, skip our declaration and definition. We match this IFNDEF at
;* the bottom of the file.
IFNDEF typObjAny


;* ------------------------------------------------------------ *
;*		Object Type Codes				*
;* ------------------------------------------------------------ *

typObjSemaphore EQU	1
typObjEvent	EQU	2
typObjMutex	EQU	3
typObjCrst	EQU	4
typObjTimer	EQU	5
typObjProcess	EQU	6
typObjThread	EQU	7
typObjFile	EQU	8
typObjChange	EQU	9
typObjConsole	EQU	10
typObjIO	EQU	11
typObjConScreenbuf EQU	12
typObjMapFile	EQU	13
typObjSerial	EQU	14
typObjDevIOCtl	EQU	15
typObjPipe	EQU	16
typObjMailslot	EQU	17
typObjToolhelp	EQU	18
typObjSocket	EQU	19
typObjR0ObjExt	EQU	20
typObjMsgIndicator EQU	21
typObjAny	EQU	0FFFFFFFFh
typObjNone	EQU	0

; to let us determine what type of object were dealing with in a
; wait condition
typObjFirstSync EQU	typObjSemaphore
typObjLastSync	EQU	typObjTimer
typObjFirstWait EQU	typObjProcess
typObjLastWait	EQU	typObjIO

typObjMaxValid  EQU     typObjMsgIndicator
typObjShiftAdjust EQU	(-1)

;* ------------------------------------------------------------ *
;*		Definitions of Object Type Ptrs			*
;* ------------------------------------------------------------ *
LPPDB			TYPEDEF PTR PDB
LPTDB			TYPEDEF PTR TDB
LPFCNDB			TYPEDEF PTR FCNDB
LPSEM			TYPEDEF PTR SEM
LPEVT			TYPEDEF PTR EVT
LPMUTX			TYPEDEF PTR MUTX
LPCRST			TYPEDEF PTR CRST
LPLCRST			TYPEDEF PTR LCRST
LPOBJ			TYPEDEF PTR OBJ
LPSYNCO			TYPEDEF PTR SYNCO
LPNSOBJ			TYPEDEF PTR NSOBJ
LPWNOD			TYPEDEF PTR WNOD
IFNDEF LPTDBX
  LPTDBX		TYPEDEF PTR
ENDIF

; THIS IS TO ALLOW INCLUSION OF THIS FILE IN RING 0 FILES
; WHERE THESE ITEMS ARE NOT DEFINED
IFNDEF LPVOID
  LPVOID		TYPEDEF PTR
ENDIF
IFNDEF LPSTR
  LPSTR			TYPEDEF PTR
ENDIF
IFNDEF LPLST
  LPLST			TYPEDEF PTR
ENDIF
IFNDEF PREGS
  PREGS			TYPEDEF DWORD
ENDIF
IFNDEF HANDLE
  HANDLE		TYPEDEF DWORD
ENDIF
IFNDEF BOOL
  BOOL			TYPEDEF DWORD
ENDIF

IFNDEF TLS_MINIMUM_AVAILABLE
  TLS_MINIMUM_AVAILABLE EQU 80
ENDIF
IFNDEF TLS_MINIMUM_AVAILABLE_GLOBAL
  TLS_MINIMUM_AVAILABLE_GLOBAL EQU 8
ENDIF
IFNDEF KERNENTRY
  KERNENTRY EQU C
ENDIF

;* ------------------------------------------------------------ *
;*		Generic Object Structure			*
;* ------------------------------------------------------------ *

;* This structure defines a generic object.  There is an instance
;* of this structure at the head of all objects in the system.  The
;* generic object manipulation functions operate on fields in this
;* structure and call on the object specific manipulation functions
;* based on the object type when necessary.


OBJ		STRUCT
  typObj        BYTE    0       ;* object type
  objFlags      BYTE    0       ;* object flags
  cntUses       WORD    0       ;* count of references to this object
OBJ             ENDS

fObjTypeSpecific        EQU     80h     ;* meaning depends on object type
fObjTypeSpecific2       EQU     40h
fObjTypeSpecific3       EQU     20h

; Various object-specific type flags.
fEvtManualReset         EQU     fObjTypeSpecific  ; set for manual reset
fNewCrstBlock           EQU     fObjTypeSpecific  ; high bit for thread blkd while crst owned (in typObj)
fTimerIsRing3           EQU     fObjTypeSpecific2 ;

; Common object macro
;	To be included in object structure definitions.
;	This structure should always be a multiple of 4 bytes in length
COMMON_OBJECT MACRO
  typObj        BYTE    0       ;* object type
  objFlags      BYTE    0       ;* object flags
  cntUses       WORD    0       ;* count of references to this object
ENDM

; Common non-synchronization object macro
;	This macro defines data which comprises the base of all
;	waitable objects which are not synchronization objects
COMMON_NSOBJECT MACRO
  typObj        BYTE    0       ;* object type
  objFlags      BYTE    0       ;* object flags
  cntUses       WORD    0       ;* count of references to this object
  psyncEvt      LPEVT   0       ;* synchronization event for this obj
ENDM

; Wait node structure
; This structure is the link which allows threads to wait on multiple
; synchronization types at once
WNOD	STRUC
  pwnNext		LPWNOD	0	; pointer to next in this circular list
  pwnCirc		LPWNOD	0	; next circular list of wait nodes
  ptdbxWait		LPTDBX	0	; waiting thread for this wait node
  pobjWait		LPOBJ	0	; object being waited on
WNOD	ENDS

; Every object name is stored in a structure like this one. Each hash table entry
; for object names points to a forward linked list of these structures.
OBJNAME STRUC
  NextOName		DWORD	0	; next in hash list
  ObjPtr		LPOBJ	0	; named object this refers to
  NameStr		BYTE	0	; name string (one byte)
OBJNAME ENDS

; This structure contains all of the generic fields for synchronization objects
SYNCO	STRUC
  COMMON_OBJECT
  pwnWait		LPWNOD	0	; pointer to first wait node for this object
  cntCur		DWORD	0	; current signaled count
  NameStruct		DWORD	0	; pointer to name
SYNCO	ENDS

; This structure is common to NSOBJ type objects
NSOBJ	STRUC
  COMMON_NSOBJECT
NSOBJ	ENDS

; This defines and structure make up an event object.

; event structure
EVT	STRUC
  COMMON_OBJECT
  pwnWait		LPWNOD	0	; pointer to first wait node
  cntCur		DWORD	0	; current count
  NameStruct		DWORD	0	; name pointer
EVT     ENDS

; semaphore structure
SEM     STRUC
  COMMON_OBJECT
  pwnWait               LPWNOD  0       ; pointer to first wait node
  cntCur                DWORD   0       ; current count
  NameStruct            DWORD   0       ; name pointer
  cntMax                DWORD   0       ; maximum allowed count
SEM     ENDS

; A Mutex
MUTX	STRUC
  COMMON_OBJECT
  pwnWait		LPWNOD	0	; pointer to first wait node
  cntCur		DWORD	0	; own count
  NameStruct		DWORD	0	; pointer to object name
  ptdbxOwner		LPTDBX	0	; thread which owns this mutex
  SysMutexLst		DWORD	0	; link for system mutex list
MUTX	ENDS

; This is the critical section structure
CRST	STRUC
  typObj                BYTE    0       ; typObj already defined
  objFlags              BYTE    0       ; object flags
  objPadding            WORD    0       ; OBJ.cntUses not needed
  cntRecur              DWORD   0       ; recursion count
  ptdbxOwner		LPTDBX	0	; owning tdbx
  ptdbxWait		LPTDBX	0	; waiting tdbxs
  cntCur		DWORD	0	; current count
  SysCrstLst		DWORD	0	; system list of critical sections
  pdbLst		DWORD	0	; list of owning processes
  pextcrst		DWORD	0	; pointer to external critical section
CRST	ENDS

; This is the exported critical section structure which is used to
; indirectly access the internal critical section structure and handle
; cleanup.
CRST_EXPORT STRUC
	COMMON_OBJECT			; it is an object
	crstInternal	DWORD 0		; ptr to internal critical section
CRST_EXPORT ENDS

;-------------------------------------------------------------
;		GET DEFINES FOR HEIRARCHICAL CRITICAL SECTIONS
;-------------------------------------------------------------

LCRST_DEFINED	EQU			; disable duplicate def in syslevel.inc

INCLUDE SYSLEVEL.INC

; Heirachical critical section structure
LCRST	STRUC
  cstSync		CRST <>		; sync object
  IFDEF SYSLEVELCHECK
    slLevel		dd 0		; level defined if sys level checking
  ENDIF
LCRST	ENDS

;-------------------------------------------------------------

CREATEDATA16    STRUC
        pProcessInfo    LPVOID  0       ; LPPROCESS_INFORMATION
        pStartupInfo    LPVOID  0       ; LPSTARTUPINFO
CREATEDATA16    ENDS

;-------------------------------------------------------------
;		INCLUDE TIB DEFINITION
;-------------------------------------------------------------
INCLUDE K32SHARE.INC
INCLUDE APC.INC

; Thread Data Block structure.
;
; !!!! BUGBUG !!!!
; This definition is duplicated in object.h and core\inc\object16.inc
;

TDB			STRUC
  COMMON_NSOBJECT
ifdef   WOW
  ptib                  DWORD   0
else    ; WOW
  tib			TIBSTRUCT <>	; Thread Info Block--see above
endif   ; else WOW
  cntHandles		DWORD	0	; count of handles to this thread
  selEmul		WORD	0	; selector for emulator data
  selTib		WORD	0	; selector for this TDB
  dwStatus		DWORD	0	; thread status/termination code
  flFlags		DWORD	0
  dwPad1		DWORD	0	; See comments in .\object.h

  R0ThreadHandle	DWORD	0	; ring 0 thread handle

  wMacroThunkSelStack16 WORD	0	; Used to be TIBSTRUCT.selStack16
  wPad			WORD	0
  pvMapSSTable		LPVOID	0	; Table of 16-bit ss's for flat thunks
  dwCurSS		DWORD	0	; Current default 16-bit ss for flat thunks
  dwCurNegBase		DWORD	0	; negative base of current default ss
  pvThunkConnectList	LPVOID	0	; head of list of in-progress thunk handshakes
  pvExcept16		LPVOID	0	; head of 16-bit thread exception handler chain
  tdb_pcontext		LPVOID	0	; pointer to context. if 0, goto ring 0
  tdb_ihteDebugger	DWORD	0	; thread handle for debugger
  tdb_pderDebugger	LPVOID	0	; pointer to debugger control block
  ercError		DWORD	0	; extended error code for last thread error
  pvEmulData		LPVOID	0	; Pointer to emulator data area
  pStackBase		LPVOID	0	; stack object base address
  ptdbx			LPTDBX	0	; pointer to the per thread TDBX
  dwPad2		DWORD	0	; see comments in .\object.h

  TlsArray		DWORD	TLS_MINIMUM_AVAILABLE+TLS_MINIMUM_AVAILABLE_GLOBAL dup (0) ; thread local storage array
  tpDeltaPri		DWORD	0	; delta from base priority class
  tdb_tpiterm		TPITERM <>	; tpi/termination data union
  pCreateData16		LPVOID  0       ; ptr to CREATEDATA16 stuct
  dwAPISuspendCount	DWORD	0	; suspend/resume api count
  lpLoadLibExDir	LPVOID	0	; LoadLibraryEx() dir (if any)
  wSSBig		WORD	0	; selector of optional Big Stack
  wPad2			WORD    0
  lp16SwitchRec		DWORD	0
  tdb_htoEndTask	DWORD	0
  tdb_cMustCompletely	DWORD	0
ifdef DEBUG
  apiTraceReenterCount	DWORD   0	; api trace reenter count
  pSavedRip		LPVOID	0	; saved rip string from 16bit krnl
  TlsSetCallerArray	DWORD	TLS_MINIMUM_AVAILABLE+TLS_MINIMUM_AVAILABLE_GLOBAL dup (0) ; caller's of TlsSetValue
endif
ifdef   WOW
  hTerminate        DWORD   0
endif
TDB			ENDS

_TDB	TYPEDEF		TDB

TDBSTUBSIZE	EQU	SIZEOF _TDB



; Flags for TDB.wflFlags
fWaitDefault	EQU 0			; default flags
fWaitAllFlag	EQU 1			; set for wait all, clear for wait any
fWaitCrst	EQU 2			; special critical section wait



; Flags for TDB.flFlags

fCreateThreadEvent	EQU	00000001h
fCancelExceptionAbort	EQU	00000002h
fOnTempStack		EQU	00000004h
fGrowableStack		EQU	00000008h
fDelaySingleStep	EQU	00000010h
fOpenExeAsImmovableFile	EQU	00000020h
fCreateSuspended	EQU	00000040h
fStackOverflow		EQU	00000080h
fNestedCleanAPCs        EQU	00000100h
fWasOemNowAnsi		EQU	00000200h
fOKToSetThreadOem	EQU	00000400h
fTermCleanupStack	EQU	00000800h
fInCreateProcess        EQU	00001000h
fHoldDisplay            EQU 00002000h
fHoldSystem             EQU 00004000h

; Flags for fields of PDB.flFlags

fDebugSingle		EQU	00000001h
fCreateProcessEvent	EQU	00000002h
fExitProcessEvent	EQU	00000004h
fWin16Process		EQU	00000008h
fDosProcess		EQU	00000010h
fConsoleProcess		EQU	00000020h
; fFreeBit
; fFileApisAreOem		EQU	00000040h
fNukeProcess 		EQU	00000080h
fServiceProcess		EQU	00000100h
fProcessCreated         EQU	00000200h
fDllRedirection     EQU 00000400h
fLoginScripthack	EQU	00000800h ;DOS app loaded into existing console and TSR'd

; These bits can be in either the TDB or the PDB

fSignaled		EQU	80000000h
fInitError		EQU	40000000h
fTerminated		EQU	20000000h
fTerminating		EQU	10000000h
fFaulted		EQU	08000000h
fTHISSLOTISFREE		EQU	04000000h
fNearlyTerminating	EQU	00800000h
fDebugEventPending	EQU	00400000h
fSendDLLNotifications	EQU	00200000h

; Environment data block for various per-process data including arguments,
; current directories, handles, and environment strings. This data block
; resides in the scratch heap.

EDB			STRUCT	4
  pchEnv		LPSTR	0	; environment block (preceeded by PchEnvHdr)
  unused		DWORD	0	; was cbEnvMax
  szCmdA		LPSTR	0	; command line (ANSI copy)
  szDir			LPSTR	0	; current directory of process
;  hTaskWin16		DWORD	0	; associated Win16 task handle
  pvStartup		LPVOID	0	; pointer to startup information
  hStdIn		HANDLE	0	; handle of standard in
  hStdOut		HANDLE	0	; handle of standard out
  hStdErr		HANDLE	0	; handle of standard error
  hProc			HANDLE	0	; handle of the owning process
  pInheritedConsole	LPVOID	0	; inherited console
  ctrlType		DWORD	0	; ctrlNone, ctrlC, ctrlBreak
  psemCtrl		LPSEM	0	; Protects access to control data
  pevtCtrl		LPEVT	0	; Control C or Break event
  ptdbCtrl		LPTDB	0	; Control handler thread
  rgpfnCtrl		LPVOID	0	    ; Array of Control handlers
  cpfnCtrlMac		SDWORD	0	    ; Last item in array
  cpfnCtrlMax		SDWORD	0	    ; Size of array
  rgszDirs		LPSTR	26 DUP (0)  ; array of drive directories
  szCmdW		LPSTR	0	; command line (Unicode copy)
  szDirO		LPSTR	0	; current directory OEM copy 
EDB			ENDS
LPEDB			TYPEDEF PTR EDB



;PCHENVHDR: This header structure must precede the environment strings
;block pointed to by _edb->pchEnv. It contains the info about the
;block allocation.

PCHENVHDR		STRUCT 4
  dwSig			DWORD	0	;Signature: must be PCHENVHDR_SIG
  cbReserved		DWORD	0	;# of bytes reserved (must be page-size divisible)
  cbCommitted		DWORD	0	;# of bytes committed (must be page-size divisible)
PCHENVHDR		ENDS
LPPCHENVHDR		TYPEDEF PTR PCHENVHDR

PCHENVHDR_SIG	equ	045484350h	;'PCHE'



; Entrypoints into WSOCK32.DLL
SOCKET_EPTS STRUCT 4
    recv		DWORD	?
    arecv		DWORD	?
    send		DWORD	?
    asend		DWORD	?
    close		DWORD	?
SOCKET_EPTS ENDS

MAX_PROCESS_DWORD  EQU	1

; Process Data Block Structure.

PDB			STRUCT	4
  COMMON_NSOBJECT
  dwReserved1		DWORD	0	; so that other offsets don't change
  dwReserved2		DWORD	0	; so that other offsets don't change
  dwStatus		DWORD	0	;Process termination status code
  wasDwImageBase	DWORD	0	;Points to PE header for process
  hheapLocal		HANDLE	0	;Handle to default local heap for process
  hContext		DWORD	0	;Handle to process' private mem. context
  flFlags		DWORD	0	;Debugging and inheritance flags
  pPsp			LPVOID	0	;Linear address of PSP
  selPsp		WORD	0	;Selector for PSP of the process
  imte			SWORD	0	;Index to module table entry for this process
  cntThreads		SWORD	0	;number of threads in this process
  cntThreadsNotTerminated SWORD 0	;threads not past termination code
  UnusedWord1		SWORD	0	;padding
  R0ThreadCount		SWORD	0	;ring 0 version of same
  hheapShared		HANDLE	0	;Handle to heap in shared memory
  hTaskWin16		DWORD	0	;Associated Win16 task handle
  pFvd			DWORD	0	;Ptr to memory mapped file view descriptors
  pedb			LPEDB	0	;Pointer to environment data block
  phtbHandles		LPVOID	0	;Handle table
  ppdbParent		LPPDB	0	;Pointer to PDB of parent process
  plstMod		LPLST	0	;Pointer to process module table list
  plstTdb		LPLST	0	;Pointer to list of threads
  pdb_pdeeDebuggee	LPVOID	0	;Pointer to debuggee control block
  plhFree		LPVOID	0	;Local heap free handle list head ptr
  pid			DWORD	0	;ID, same as initial thread id
  crstLoadLock		LCRST	<>	;loader synchronization (hierarchical)
  pConsole		LPVOID	0	;Console
  TlsIdxMask		DWORD ((TLS_MINIMUM_AVAILABLE+31)/32) dup(0) ; mask of used TLS idxs
  adw			DWORD	MAX_PROCESS_DWORD dup(0) ;free-form storage
  ppdbPGroup		LPPDB	0	;process group this process belongs to
  pModExe		LPVOID	0	;pointer to ModRef of EXE
  pExceptionFilter	DWORD	0	;set by SetUnhandledExceptionFilter
  pcPriClassBase	DWORD	0	;priority value of this processes' pri class
  hhi_procfirst 	HANDLE	0	;linked list of heaps for this process
  plhBlock		DWORD	0	;local heap lhandle blocks
  psock_epts		DWORD	0	;socket entrypoints
  pconsoleProvider	DWORD	0	;pconsole that winoldapp is providing.
  wEnvSel		WORD	0	;selman-alloced DOS environment selector
  wErrorMode		WORD	0	;handling of critical errors
  pevtLoadFinished	LPEVT	0	;waiting for load to be finished
  hUTState		WORD	0	;UT info
  pad3			WORD	0
  lpCmdLineNoQuote	DWORD	0	;Optional unquoted command line (apphack)
PDB                     ENDS

_PDB	TYPEDEF		PDB

PDBSTUBSIZE	EQU	SIZEOF _PDB

cppdbProcTableInit	EQU 32	; maximum number of processes

;* File Data Block Structure.

FDB			STRUCT	4
  COMMON_NSOBJECT
  hdevDos		WORD	0	; DOS device handle
  wDupSrcPSPSel		WORD	0	; NETX: if inter-PSP dup'ed = src pspseg
  cfhid			DWORD 	0	; (CFH_ID) look in object.h
FDB			ENDS

;* Find Change Notify Structure.

FCNDB			STRUCT	4
  COMMON_NSOBJECT
  hChangeInt		DWORD	0	; internal change handle
FCNDB			ENDS

;* Pipe Data Block Structure.

PIPDB			STRUCT	4
  COMMON_OBJECT
  hMem			DWORD	0	; Mem handle of pipe
  hNmPipe		DWORD	0	; Named pipe handle (hInvalid if anon)
  rdRef 		DWORD	0	; Ref count on read handle
  wrRef 		DWORD	0	; Ref count on write handle
  pszByt		DWORD	0	; Size of hMem (pipe) in bytes
  wPtr			DWORD	0	; write pointer (offset in hMem)
					;   Pointer to last byte written
  rPtr			DWORD	0	; read	pointer (offset in hMem)
					;   Pointer to next byte to read
  wBlkEvnt		DWORD	0	; write event handle (waiting for room to write)
  rBlkEvnt		DWORD	0	; read event handle (waiting for data to read)
PIPDB			ENDS

;* Mailslot Data Block Structure.

MSDB			STRUCT	4
    COMMON_OBJECT
    lpMSName		DWORD	0	; Pnt to name of mailslot (== 0 for
					;   read (CreateMailslot) handle)
    hMSDos		DWORD	0	; INT 21 mailslot handle (== 0FFFFFFFFh
					;   for write (CreateFile) handle)
MSDB			ENDS

;* ToolHelp Data Block Structure.

TLHPDB			  STRUCT  4
    COMMON_OBJECT
    ClassEntryCnt	DWORD	0
    ClassEntryList	DWORD	0
    HeapListCnt		DWORD	0
    HeapList		DWORD	0
    ProcessEntryCnt	DWORD	0
    ProcessEntryList	DWORD	0
    ThreadEntryCnt	DWORD	0
    ThreadEntryList	DWORD	0
    ModuleEntryCnt	DWORD	0
    ModuleEntryList	DWORD	0
TLHPDB			ENDS



;;
;; A dynamic extension to the timerdb that's used whenever a ring-3 timer
;; is armed with a completion function. This structure must live in locked
;; memory.
;;
;; Access to this structure is serialized by being in a no-preempt section.
;; There are no semaphores guarding it.
;;
;; This structure is allocated whenever SetWaitableTimer() is called on a
;; timer with a non-null completion function. It's stored in the Completion
;; field and the fTimerIsRing3 bit is set to indicate that this a TIMERR3APC
;; (opposed to a ring-0 DPC.)
;;
;; This structure is detached from the timerdb on the next call to
;; CancelWaitableTimer(). It's also usually freed at this time except
;; if a cancel occurs after the last apc has been delivered but TimerApcHandler
;; hasn't yet set fHandlerDone to indicate that's it finished using the
;; structure. In this case, we can't free it so we instead link it onto
;; the TimerDisposalWaitingList. When fHandlerDone does become TRUE,
;; it will be available for pickup the next time we need one of these
;; structures.
;;
;; The automatic rearming of a periodic timer reuses the existing
;; TIMERR3APC. It checks the fHandleDone: if the handler hasn't
;; finished (or begun) on the previous apc, we don't schedule a new
;; one (as per specs).
;;
;; Fields:
;;     cRef              - reference count
;;     pfnCompletion     - Ptr to ring-3 completion (never NULL)
;;     lpCompletionArg   - uninterpreted argument to pfnCompletion
;;     R0ThreadHandle    - thread that called SetWaitableTimer()
;;     DueTime           - trigger time to pass to pfnCompletion. This
;;                         field isn't set until the timer goes off.
;;     dwApcHandle       - if apc has been queued, contains the underlying
;;                           apc handle. This apc handle gets recycled at the
;;                           same time we free the TIMERR3APC (or in the case
;;                           of a periodic timer, when we reuse the structure
;;                           for the next arming.)
;;     lpNext            - Used for linking in TimerDisposalWaitingList,
;;                         undefined otherwise.
;;
;;
;;
TIMERR3APC  STRUCT 4

   t3a_cRef    		DWORD   0
   t3a_pfnCompletion    DWORD   0
   t3a_lpCompletionArg  DWORD   0
   t3a_ApcTdbx          DWORD   0
   t3a_DueTime          QWORD   0
   t3a_dwApcHandle      DWORD   0
   t3a_lpNext           DWORD   0
   t3a_lpTimerDB	DWORD	0

TIMERR3APC  ENDS

LPTIMERR3APC      TYPEDEF PTR TIMERR3APC




;; Timer object.
;;
;;   Notes:
;;     The timerdb must ALWAYS be pagelocked. This is consistent
;;     with the requirement that the structure passed to KeSetTimer
;;     be pagelocked. Furthermore, we use the non-preemptibility of
;;     of ring-0 code to serialize access to many parts of the structure
;;     (due to the fact that much of this code has to run at event time.)
;;     This non-preemptibility is guaranteed only if the structure is
;;     locked.
;;
;;     Timers can be created at ring-0 or ring-3. If a timer is created at
;;     ring-3, the memory is always allocated and deallocated by kernel32.
;;     Kernel32 also makes sure that an explicit canceltimer is always done
;;     on the timer before it is finally freed - we depend on this fact
;;     to do the proper cleanup for timerr3apc's.
;;
;;     Timers created at ring-3 can be passed to Ke* routines.
;;
;;     Timers created at ring-0 cannot be passed to SetWaitableTimer() at
;;     ring-3. (There are some nasty cleanup problems associated with this
;;     due to the fact that ring-0 timers are freed by the device driver
;;     with no notification given to the system.)
;;
;;     We use the cntUses field to determine whether a timer was created
;;     at ring 3.
;;
;;   Synchronization:
;;
;;     typObj          Static, none needed
;;     objFlags 
;;       fTimerIsRing3 by being in a no-preempt section
;;     cntUses         Used by handle manager
;;     pwnWait         WaitR0
;;     cntCur          WaitR0 [w/ one exception: see [1])
;;     NameStruct      Krn32Lock - used only at ring3
;;     lpNextTimerDb   by being in a no-preempt section
;;     hTimeout        by being in a no-preempt section
;;     DueTime         by being in a no-preempt section
;;     Completion      by being in a no-preempt section
;;     lPeriod         by being in a no-preempt section
;;
;;     [1] Because KeSetTimer has to unsignal the timer, and be
;;         able to do it at event time, it pokes a zero directly
;;         into cntCur. But this is ok because the only code
;;         that signals timers is TimerDoTimeout which is
;;         non-preemptive.
;;
;;  Flag descriptions:
;;
;;     fTimerIsRing3
;;        If the COMPLETION is non-null, this bit indicates whether the
;;        COMPLETION points to a TIMERR3APC (ring-3 completion) or a KDPC
;;        (ring-0 completion.) The value of this bit is undefined at any
;;        other time.
;;
;;
;;
;;  Field descriptions:
;;
;;     <common-obj and common-sync stuff omitted>
;;
;;     lpNextTimerDb:
;;        All active timers that were set with fResume TRUE are linked into
;;        TimerSysLst (for the purpose of knowing how to program the power
;;        timer.) This field is NULL when the timer is inactive or active
;;        without fResume. It is undefined while the timer is in the INPROGRESS
;;        state.
;;
;;     hTimeout
;;        If the timer is active, this field contains the handle to the
;;        underlying VMM hTimeout. If the timer is inactive, this
;;        field is NULL. If the timer is in the in-progress state,
;;        this field is undefined (actually points to a stale VMM timeout
;;        handle!)
;;
;;
;;     DueTime:
;;        If the timer is active, contains the absolute time that the
;;        timer is due to go off. Expressed as a FILETIME converted from
;;        GetSystemTime. Undefined if the timer isn't active.
;;
;;     Completion:
;;        Then contains either:
;;           NULL          - no completion was set
;;           LPTIMERR3APC  - if fTimerIsRing3 is set
;;           PKDPC         - if fTimerIsRing3 is not set.
;;
;;        Note that it is normal for a timer to be inactive and contain
;;        a pointer to a TIMERR3APC structure. This case occurs when
;;        a timer set with a ring-3 completion fires normally. The
;;        TIMERR3APC structure is kept around so that a subsequent
;;        CancelWaitableTimer() can retrieve the underlying apc handle
;;        embedded in it.
;;
;;     lPeriod:
;;        Contains either 0 for a one-shot timer or a positive value
;;        (the firing period in milliseconds.)

TIMERDB         STRUCT 4
    COMMON_OBJECT               ; standard waitable non-synchronization object

;; These fields have to appear in this form because a timer is a sync object.
    tmr_pwnWait		DWORD	0    ;pointer to the wait node for this object
    tmr_cntCur		DWORD	0    ;signaled state
    tmr_NameStruct	DWORD	0    ;name structure for this object

;; These fields are timer-specific.
    tmr_lpNextTimerDb	DWORD 	0    ;link in TimerSysLst (can be NULL)
    tmr_hTimeout	DWORD	0
    tmr_DueTime		QWORD	0
    tmr_Completion	DWORD	0    ;completion routine (or NULL)
    tmr_lPeriod		DWORD	0

;; Try not to add new fields. This structure cannot exceed 40 bytes
;; or we break compatibility with NT's Ke api. If you try to hang
;; another structure off it, remember that the Ke*Timer apis can't
;; allocate memory from the heap (system meltdown if these apis
;; are called at event time on a system that's paging thru DOS.)

TIMERDB         ENDS


;; Must be no larger than the NT KTIMER structure (which is 40 bytes.)
;; Checking for our exact size so that anyone who changes the size
;; will have to stop and consider.
.errnz SIZEOF TIMERDB - 40


LPTIMERDB       TYPEDEF PTR TIMERDB








;* Console Input Data Block Structure.

CIDB			STRUCT	4
  COMMON_OBJECT
  hdevDos		WORD	0	; DOS device handle
			WORD	0
  flMode		DWORD	0	; Object mode
CIDB			ENDS

;* Console Output Data Block Structure.

CODB			STRUCT	4
  COMMON_OBJECT
  hdevDos		WORD	0	; DOS device handle
			WORD	0
  flMode		DWORD	0	; Object mode

  ; Next fields are the same as CONSOLE_SCREEN_BUFFER
  ; dwSize
  xMax			WORD	0	; Maximum column in buffer
  yMax			WORD	0	; Maximum row in buffer
  ; dwCursorPosition
  xCurPos		WORD	0	; Current cursor column
  yCurPos		WORD	0	; Current cursor row
  ; dwScrollPosition
  xScrollPos		WORD	0	; Column of buffer in window
  yScrollPos		WORD	0	; Row of buffer in window

  wAttrib		WORD	0	; Current color
  ; dwCurrentWindowSize
  xCurWin		WORD	0	; Columns of current window
  yCurWin		WORD	0	; Rows of current window
  ; dwMaximumWindowSize
  xMaxWin		WORD	0	; Maximum window width
  yMaxWin		WORD	0	; Maximum window height
  ; Next two fields are the same as CONSOLE_CURSOR_INFO
  dwSize		DWORD	0	; Percent of cursor fill
  fVisible		BOOL	0	; Visibility of cursor
  ; Remaining fields are private
  wIniAttrib		WORD	0	; Startup color
  wText			WORD	0
  xpChar		WORD	0	; Pixel width of character (not used)
  ypChar		WORD	0	; Pixel height of character

  pvWin			LPVOID	0	; Address of current text window
  pvWinMax		LPVOID	0	; Last valid window address
  cbLine		DWORD	0	; Bytes per row

CODB			ENDS
LPCODB			TYPEDEF PTR CODB

; WARNING!!!
; This must remain consistent with CORE\WIN32\INC\CONSOLE.H and VMDOSAPP\GRABEMU.ASM
;MAXTITLESIZE		EQU	128	; Same as in Winoldap (tty.inc)
;CONSOLE		STRUCT
;  COMMON_NSOBJECT
;  psbActiveScreenBuffer DWORD	0	; Pointer to active screen buffer (if any)
;  cMaxSize		DWORD	0	; Max size of this console (maintained by WinOldAp)
;  flags			DWORD	0	; Various console flags
;  cOriginalSize		DWORD	0	; Size inherited from DOS
;  csCRST		CRST	<>	; critical section for synching access to lists, etc.
;  plstOwners		DWORD	0	; pointer to list of owners (processes)
;  plstBuffers		DWORD	0	; pointer to list of screen buffers
;  dwLastExitCode	DWORD	0	; Most recent exit code by a process in this console group
;  szTitle		BYTE	MAXTITLESIZE DUP(0) ;  Title (displayed by WinOldAp)
;  VID			DWORD	0	; ID used by VCOND
;  hVM			DWORD	0	; Process handle of VM which supports this console for i/o
;  hDisplay		DWORD	0	; hwnd of display port (used by WinOldAp)
;  ppdbControlFocus	LPPDB	0	; Process which holds current control focus for this console
;  ; rest is not currently interesting
;CONSOLE		ENDS


SDB		STRUC

COMMON_OBJECT
SerialHandle	DWORD	0
Flags		DWORD	0

SDB		ENDS

LPSDB		TYPEDEF PTR SDB

;* ------------------------------------------------------------ *
;*		Function Prototypes
;* ------------------------------------------------------------ *

; LPOBJ
NewObject PROTO KERNENTRY, :DWORD, :BYTE

; VOID
DisposeObj PROTO KERNENTRY, :LPVOID

; VOID
UseObject PROTO KERNENTRY, :LPVOID

; BOOL
FUnuseObject PROTO KERNENTRY, :LPVOID

; LPOBJ
PobjDupObject PROTO KERNENTRY, :LPOBJ

; VOID
LockObject PROTO KERNENTRY, :LPOBJ

; VOID
UnlockObject PROTO KERNENTRY, :LPOBJ

;* Matching IFNDEF at top of file
ENDIF

;* ------------------------------------------------------------ *
;* ------------------------------------------------------------ *
;* ------------------------------------------------------------ *
;* ------------------------------------------------------------ *
;* ------------------------------------------------------------ *
;****************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\public.inc ===
;***********************************************************************;
;!!! use public versions -- delete eventually
;
; Stuff in here should come from public include files.
;***********************************************************************;
ifndef	WOW
myDWORD struc
lo  dw  ?
hi  dw  ?
myDWORD ends
endif

MF_POPUP                equ 00000010h
MF_BITMAP		        equ 00000004h
MF_OWNERDRAW		    equ 00000100h
MF_SEPARATOR		    equ 00000800h

WS_CHILD                equ 40000000h
WS_EX_MDICHILD          equ 00000040h

DBWF_LPARAMPOINTER      equ    08000h

LBS_OWNERDRAWFIXED      equ     0010h
LBS_OWNERDRAWVARIABLE   equ     0020h
LBS_HASSTRINGS          equ     0040h

CBS_OWNERDRAWFIXED      equ     0010h
CBS_OWNERDRAWVARIABLE   equ     0020h
CBS_HASSTRINGS          equ     0200h

PROP_FROMWIN32          equ     0002h
GWL_STYLE               equ     (-16)

GW_CHILD        equ     05

LR_MONOCHROME   equ     00001h
LR_LOADFROMFILE equ     00010h
LR_DEFAULTSIZE  equ     00040h
LR_SHARED       equ     08000h

DI_DRAWICON     equ     0000fh

DSI_KERNEL      equ     00001h
DSI_32BIT       equ     00004h
DSI_NOTSHARED   equ     00008h

IMAGE_BITMAP    equ     0
IMAGE_ICON      equ     1
IMAGE_CURSOR    equ     2

SMT_SENDMESSAGE             equ 0
SMT_DEFWINDOWPROC           equ 1
SMT_DEFMDICHILDPROC         equ 2
SMT_DEFDLGPROC              equ 3
SMT_DEFFRAMEPROC            equ 4

PMT_POSTTHREADMESSAGE       equ 0
PMT_POSTMESSAGE             equ 1

TMT_TRANSLATEACCELERATOR    equ 0
TMT_TRANSLATEMDISYSACCEL    equ 1
TMT_ISDIALOGMESSAGE         equ 2
TMT_TRANSLATEMESSAGE        equ 3

CTLCOLOR_MSGBOX         equ 0
CTLCOLOR_EDIT           equ 1
CTLCOLOR_LISTBOX        equ 2
CTLCOLOR_BTN            equ 3
CTLCOLOR_DLG            equ 4
CTLCOLOR_SCROLLBAR      equ 5
CTLCOLOR_STATIC         equ 6

WM_CREATE               equ 001h
WM_DESTROY              equ 002h
WM_CTLCOLOR             equ 019h

WM_CTLCOLORMSGBOX       equ 132h
WM_CTLCOLOREDIT         equ WM_CTLCOLORMSGBOX + CTLCOLOR_EDIT
WM_CTLCOLORLISTBOX      equ WM_CTLCOLORMSGBOX + CTLCOLOR_LISTBOX
WM_CTLCOLORBTN          equ WM_CTLCOLORMSGBOX + CTLCOLOR_BTN
WM_CTLCOLORDLG          equ WM_CTLCOLORMSGBOX + CTLCOLOR_DLG
WM_CTLCOLORSCROLLBAR    equ WM_CTLCOLORMSGBOX + CTLCOLOR_SCROLLBAR
WM_CTLCOLORSTATIC       equ WM_CTLCOLORMSGBOX + CTLCOLOR_STATIC

WM_DDE_INITIATE         equ 3E0h
WM_DDE_TERMINATE        equ 3E1h
WM_DDE_ADVISE           equ 3E2h
WM_DDE_UNADVISE         equ 3E3h
WM_DDE_ACK              equ 3E4h
WM_DDE_DATA             equ 3E5h
WM_DDE_REQUEST          equ 3E6h
WM_DDE_POKE             equ 3E7h
WM_DDE_EXECUTE          equ 3E8h

WM_DROPFILES            equ 233h

WM_USER                 equ 400h

OBJ_BRUSH               equ 2
OBJ_FONT                equ 3
OBJ_BITMAP              equ 5
OBJ_RGN                 equ 6
OBJ_DC                  equ 7


EM_GETSEL       equ     0B0h
LB_ADDSTRING    equ     180h

GWL_WNDPROC     equ    (-4)
GWL_HINSTANCE   equ    (-6)
GWL_HWNDPARENT  equ    (-8)
GWL_ID          equ    (-12)
GWL_STYLE       equ    (-16)
GWL_EXSTYLE     equ    (-20)
GWL_USERDATA    equ    (-21)

DWL_DLGPROC	equ	4

GWW_HINSTANCE   equ    (-6)
GWW_HWNDPARENT  equ    (-8)
GWW_ID          equ    (-12)

; Class field offsets for GetClassLong() and GetClassWord()
GCL_MENUNAME      equ  (-8)
GCW_HBRBACKGROUND equ  (-10)
GCW_HCURSOR       equ  (-12)
GCW_HICON         equ  (-14)
GCW_HMODULE       equ  (-16)
GCW_CBWNDEXTRA    equ  (-18)
GCW_CBCLSEXTRA    equ  (-20)
GCL_WNDPROC       equ  (-24)
GCW_STYLE         equ  (-26)
GCL_STYLE         equ  (-26)
GCW_ATOM          equ  (-32)
GCW_HICONSM       equ  (-34)

FR_DIALOGTERM   equ    00000040h

LB_ERR          equ    (-1)

WM_DDE_FIRST    equ    3E0h
WM_DDE_LAST     equ    3EFh

XTYP_MASK       equ     00F0h
XTYP_SHIFT      equ     4

XTYP_ERROR              equ 0000h
XTYP_ADVDATA            equ 0010h
XTYP_ADVREQ             equ 0020h
XTYP_ADVSTART           equ 0030h
XTYP_ADVSTOP            equ 0040h
XTYP_EXECUTE            equ 0050h
XTYP_CONNECT            equ 0060h
XTYP_CONNECT_CONFIRM    equ 0070h
XTYP_XACT_COMPLETE      equ 0080h
XTYP_POKE               equ 0090h
XTYP_REGISTER           equ 00A0h
XTYP_REQUEST            equ 00B0h
XTYP_DISCONNECT         equ 00C0h
XTYP_UNREGISTER         equ 00D0h
XTYP_WILDCONNECT        equ 00E0h

XTYP_MASK               equ 00F0h
XTYP_SHIFT              equ    4

XCLASS_NOTIFICATION     equ 8000h
XCLASS_FLAGS            equ 4000h
XCLASS_DATA             equ 2000h
XCLASS_BOOL             equ 1000h

DDE_FNOTPROCESSED       equ 0

GMEM_DDESHARE           equ 2000h
GMEM_ZEROINIT		equ 0040h
GMEM_DISCARDED		equ 4000h
GMEM_MOVEABLE           equ 0002h

LMEM_MOVEABLE           equ     2
LPTR			equ	40h
GHND			equ	42h
GPTR			equ	40h

PM_REMOVE               equ 1
PM_NOYIELD              equ 2

;This is here so krnthk.inc doesn't have to load in all of struc.inc.
POINT32 struc
x       dd      ?
y       dd      ?
POINT32 ends

DC_BINS         equ     6
DC_PAPERS       equ     2
DC_PAPERSIZE    equ     3
DC_MINEXTENT    equ     4
DC_MAXEXTENT    equ     5

CF_TEXT		   equ	 1
CF_BITMAP          equ   2
CF_METAFILEPICT    equ   3
CF_DIB             equ   8
CF_PALETTE         equ   9
CF_PENDATA         equ  10
CF_RIFF            equ  11
CF_WAVE            equ  12
CF_UNICODETEXT     equ  13
CF_ENHMETAFILE     equ  14
CF_DSPBITMAP       equ  82h
CF_DSPMETAFILEPICT equ  83h
CF_DSPENHMETAFILE  equ  8Eh
CF_PRIVATEFIRST    equ 200h
CF_PRIVATELAST     equ 2FFh
CF_GDIOBJFIRST     equ 300h
CF_GDIOBJLAST      equ 3FFh


HELP_CONTEXT            equ     00001h
HELP_QUIT               equ     00002h
HELP_INDEX              equ     00003h
HELP_HELPONHELP         equ     00004h
HELP_SETINDEX           equ     00005h
HELP_CONTEXTPOPUP       equ     00008h
HELP_FORCEFILE          equ     00009h

HELP_CONTEXTMENU        equ     0000Ah
HELP_FINDER             equ     0000Bh
HELP_WM_HELP            equ     0000Ch
HELP_TCARD              equ     08000h
HELP_TCARD_DATA         equ     00010h
HELP_TCARD_NEXT         equ     00011h

HELP_KEY                equ     00101h
HELP_COMMAND            equ     00102h
HELP_PARTIALKEY         equ     00105h
HELP_MULTIKEY           equ     00201h
HELP_SETWINPOS          equ     00203h

OFN_ENABLEHOOK                  equ     20h
OFN_ENABLETEMPLATE              equ     40h
OFN_ENABLETEMPLATEHANDLE        equ     80h

CC_ENABLEHOOK                   equ     10h
CC_ENABLETEMPLATE               equ     20h
CC_ENABLETEMPLATEHANDLE         equ     40h

FR_ENABLEHOOK                   equ    100h
FR_ENABLETEMPLATE               equ    200h
FR_ENABLETEMPLATEHANDLE         equ   2000h

CF_ENABLEHOOK                   equ      8h
CF_ENABLETEMPLATE               equ     10h
CF_ENABLETEMPLATEHANDLE         equ     20h

PD_ENABLEPRINTHOOK              equ   1000h
PD_ENABLEPRINTTEMPLATE          equ   4000h
PD_ENABLEPRINTTEMPLATEHANDLE    equ  10000h
PD_ENABLESETUPHOOK              equ   2000h
PD_ENABLESETUPTEMPLATE          equ   8000h
PD_ENABLESETUPTEMPLATEHANDLE    equ  20000h


BI_RGB		equ	0h
BI_BITFIELDS	equ	3h

CBM_INIT	equ	4h

SM_PENWINDOWS   equ     41

DATA_GET        equ     0
DATA_WORD       equ     0
DATA_SET        equ     0001h
DATA_DWORD      equ     0002h
DATA_FROMWIN32  equ     0004h

KEYEVENTF_EXTENDEDKEY equ 0001h
KEYEVENTF_KEYUP       equ 0002h


CS_SHORTCUT     equ     10000000h

;; MsgWaitForMultipleObjectsEx() uses these flags.
MWMO_WAITALL    equ     00000001h
MWMO_ALERTABLE  equ     00000002h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\ldrdefs.h ===
/************************************************************************/
/*                                                                      */
/*      FILENAME.H      --  Standard C Header File Format               */
/*                                                                      */
/************************************************************************/
/*	Author: 							*/
/*	Copyright:							*/
/************************************************************************/
/*  File Description:                                                   */
/*                                                                      */
/*                                                                      */
/************************************************************************/
/*  Revision History:                                                   */
/*                                                                      */
/*  03/27/92 (GeneA): modified to conform to version 3.7 of PE format	*/
/*	spec.								*/
/*                                                                      */
/************************************************************************/


/* ------------------------------------------------------------ */
/*                                                              */
/* ------------------------------------------------------------ */

/* ------------------------------------------------------------ */
/*  Fixup Defintions
*/

typedef struct _fxr {
    DWORD	rvaPage;
    DWORD	cbSize;
    WORD	rgwOffset[1];
} FXR;

/* Fixup record types
*/

#define fxtAbsolute	0
#define fxtHigh 	1
#define fxtLow		2
#define fxtHighLow	3
#define fxtHighAdjust	4

#define fxtMax		5

/* ------------------------------------------------------------ */
/*  Debug Directory Table */

typedef struct _ddt {
    DWORD	flFlags;
    DWORD	idTimeStamp;
    WORD	verMajor;
    WORD	verMinor;
    DWORD	dwType;
    DWORD	dwSize;
    DWORD	rva;
    DWORD	dwSeek;
} DDT;

typedef DDT *PDDT;


/* ------------------------------------------------------------ */
/* Linear EXE Header
*/

#define fimgProgram	0x0000
#define fimgExecutable	0x0002
#define fimgFixed	0x0200
#define fimgLibrary	0x2000

#define fdllPrcInit	0x0001
#define fdllPrcTerm	0x0002
#define fdllThdInit	0x0004
#define fdllThdTerm	0x0008

// Subsystem id
// CONBUG these are probably defined elsewhere, but I never found 'em

#define subidWindows	2
#define subidConsole	3

typedef struct _tagLEH {
    DWORD Signature;		// idExeHdr // "PE\0\0"
    
    WORD    Machine;		// wCpuType // 0x14c == 386
    WORD    NumberOfSections;	// coteObjTable // # of objects following LEH
    DWORD   TimeDateStamp;	// idTimeStamp
    DWORD   PointerToSymbolTable; // bReserved1[8]
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader; // cbOptHdrSize // header from bResv2 until ObjTab
    WORD    Characteristics;	// fsModFlags

    //
    // Standard fields.
    //

    WORD    Magic;			// bReserved2[2]
    BYTE    MajorLinkerVersion;		//verLinkMajor
    BYTE    MinorLinkerVersion;		//verLinkMinor
    DWORD   SizeOfCode;			// bReserved3[12]
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;	// rvaEntryPoint // or NULL
    DWORD   BaseOfCode;			// bReserved4[8]
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;			// dwImageBase // actual value - modified if relocated
    DWORD   SectionAlignment;		// dwObjectAlign
    DWORD   FileAlignment;		// dwFileAlign
    WORD    MajorOperatingSystemVersion;// verOSMajor
    WORD    MinorOperatingSystemVersion;// verOSMinor
    WORD    MajorImageVersion;		// verUserMajor
    WORD    MinorImageVersion;		// verUserMinor
    WORD    MajorSubsystemVersion;	// verSubSysMajor
    WORD    MinorSubsystemVersion;	// verSubSysMinor
    DWORD   Reserved1;			// bReserved5[4]
    DWORD   SizeOfImage;		// cbImageSize
    DWORD   SizeOfHeaders;		// cbHeaderSize
    DWORD   CheckSum;			// dwCheckSum
    WORD    Subsystem;			// idSubSystem
    WORD    DllCharacteristics;		// fsDllFlags
    DWORD   SizeOfStackReserve;		// cbStackReserve
    DWORD   SizeOfStackCommit;		// cbStackCommit
    DWORD   SizeOfHeapReserve;		// cbHeapReserve
    DWORD   SizeOfHeapCommit;		// cbHeapCommit
    DWORD   LoaderFlags;		// bReserved6[4]
    DWORD   NumberOfRvaAndSizes;	// dwRVASizeCount
    IMAGE_DATA_DIRECTORY 		// rgrtb[9]
    	DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; 
} LEH;  


/* ------------------------------------------------------------ */
/* Convert RVA to actual address, based on load address
 * of Linear Exe Header and Relative Virtual Address
 */

/* Pointer version of macro */
#define RVA(leh, rva) (void *)(leh->ImageBase + (DWORD)(rva))

/* Integer (DWORD) version of macro */
#define RVAW(leh, rva) (DWORD)RVA(leh, rva)

/* ------------------------------------------------------------ */
/* Find start of object table given start of LEH
 */

#define POTE(pleh) (OTE *)((char *)&(pleh)->Magic + \
	(pleh)->SizeOfOptionalHeader)

/* ------------------------------------------------------------ */
#define RESOURCE_RVA(pleh) (DWORD)((pleh)-> \
	DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress)

#define RESOURCE_SIZE(pleh) (DWORD)((pleh)-> \
	DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size)

/* ------------------------------------------------------------ */
#define OTE IMAGE_SECTION_HEADER
#define EDT IMAGE_EXPORT_DIRECTORY
#define IDT IMAGE_IMPORT_DESCRIPTOR
#define DXH IMAGE_DOS_HEADER
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

# Make sure this is done before continuing on.
SYNCHRONIZE_BLOCK=1

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\mult.h ===
/*
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1992
 *      All Rights Reserved.
 *
 *
 *      This is intended to supercede MULT.H as the most complete
 *      reference we have on DOS INT 2Fh usage.  The header immediately
 *      below is an attempt to give an overview of all DOS and 3rd-party
 *      INT 2Fhs, but equates which follow are strictly for MS-DOS-specific
 *      functions.
 *
 *      Created 4/28/92 JTP
 */

/*
 * The current set of defined multiplex channels is (* means documented):
 *
 *  Channel(h)  Issuer          Receiver    Function
 *  ----------  ------          --------    --------
 *      00h     server          PSPRINT     print job control
 *     *01h     print/apps      PRINT       Queueing of files
 *      02h     BIOS            REDIR       signal open/close of printers
 *
 *      05h     command         REDIR       obtain text of net int 24 message
 *     *06h     server/assign   ASSIGN      Install check
 *
 *      08h     external driver DRIVER.SYS  interface to internal routines
 *
 *      10h     sharer/server   SHARE       install check
 *      11h     DOS/server      Redir       install check/redirection funcs
 *      12h     sharer/redir    DOS         dos functions and structure maint
 *      13h     MSNET           MSNET       movement of NCBs
 *      13h     external driver IBMBIO      Reset_Int_13, allows installation
 *                                          of alternative INT_13 drivers after
 *                                          boot_up
 *      14h(IBM)DOS             NLSFUNC     down load NLS country info,DOS 3.3
 *      14h(MS) APPS            POPUP       MSDOS 4 popup screen functions
 *
 *  ***> NOTE <***  Yes there are 2 users of 14h but since
 *                  DOS 4.XX doesn't use NLSFUNC, there is no conflict
 *
 *      15h     APPS            MSCDEX      CD-ROM extensions interface
 *      15h     GRAPHICS                    (conflicts)
 *      16h     WIN386          WIN386      Windows communications
 *      17h     Clipboard       WINDOWS     Clipboard interface
 *     *18h     Applications    MS-Manager  Toggle interface to manager
 *      19h     Shell                       DOS 4.x shell only (SHELLB.COM)
 *      1Ah     Ansi.sys
 *      1Bh     Fastopen,Vdisk  IBMBIO      EMS INT 67H stub handler
 *                                          (see IBM's XMA2EMS driver for DOS4)
 *
 *      23h           stolen by DR-DOS 5.0  GRAFTABL
 *      27h           stolen by DR-DOS 6.0  TaskMAX
 *      27h           stolen by Novell DOS7 EMM386
 *      2Ah           stolen by Gammafax    FaxBIOS
 *      2Eh           stolen by Novell DOS7 GRAFTABL
 *      39h           stolen by Kingswood   Some ISV TSR thingie
 *
 *      40h     OS/2
 *      41h     Lanman
 *      42h     Lanman
 *      43h     Himem
 *                                  00h     XMS installation check
 *                                  08h     return A20 handler number
 *                                  09h     return XMS handle table address
 *                                  10h     return XMS entry point address
 *                                  20h     reserved for Mach 20 Himem support
 *                                  30h     reserved for Himem external A20 code
 *                                  E0h-E4h stolen by Novell DPMS
 *      44h     Dosextender
 *      45H     Windows profiler
 *      46h     Windows/286 DOS extender
 *      47h     Basic Compiler Vn. 7.0
 *      48h     Doskey
 *                                  C0h-C5h stolen by PCED
 *      49h     DOS 5.x install             also used by original Compaq
 *                                          Restricted DOS (RDOS)
 *      4Ah     Multi-Purpose
 *               multMULTSWPDSK     00h     Swap Disk in drive A (BIOS)
 *               multMULTGETHMAPTR  01h     Get available HMA & ptr
 *               multMULTALLOCHMA   02h     Allocate HMA (bx == no of bytes)
 *               multMULTTASKSHELL  05h     Shell/switcher API
 *               multMULTRPLTOM     06h     Top Of Memory for RPL support
 *               multSmartdrv       10h
 *               multDblSpace       11h
 *               multMRCIDetect     12h
 *               multMRCIBackPatch  13h
 *               multOpenBootLog    14h
 *               multWriteBootLog   15h
 *               multCloseBootLog   16h
 *               multNWRedir        17h
 *
 *      4Bh     Task Switcher API
 *
 *      4Ch     APPS            APM         Advanced power management (obsolete)
 *
 *      4Dh     Kana Kanji Converter, MSKK
 *      4Eh     Kana Kanji Converter, MSKK
 *      4Fh     Multilingual DOS, MSKK
 *
 *      50h     SETNLS                      (new for DOS 7.00 (Jaguar))
 *
 *      51h     ODI real mode support driver (for Chicago)
 *
 *      52h     Reserved by MS for Stac Electronics
 *                    (but stolen by JAM Real-Time Data Compression)
 *
 *      53h     POWER(APM)                  For broadcasting APM events
 *      54h     APPS            POWER(APM)  To control POWER status from apps
 *                                  53h     (stolen by TesSeRact TSR library)
 *
 *      55h     COMMAND.COM
 *               multCOMFIRST       00h     API to determine whether 1st
 *                                          instance of command.com
 *      56h     INTERLINK
 *      57h     IOMEGA
 *
 *      58h     ChiNet          ChiNet      transition interface used in
 *                                          loading Chicago from a remote drive
 *
 *      5Dh     (stolen by Award PCDISK.EXE v1.02c PCMCIA/ATA driver)
 *      60h     (stolen by IPLAY by Prime and Excalibur)
 *      62h     (stolen by PC Tools virus protector)
 *
 *      70h     APPS            APPS        for software licensing
 *
 *      7Ah     Novell                      (hey, how'd they get in our range?)
 *
 *  End of Microsoft-reserved range
 *
 *      ABh     Unspecified IBM use
 *      ACh     Graphics
 *      ADh     NLS (toronto)               (DISPLAY.SYS and KEYB.COM)
 *      AEh     COMMAND.COM                 Installable command support
 *      AFh     Mode
 *      B0h     GRAFTABL        GRAFTABL
 *      B7h     APPEND
 *      B8h     Networks        Misc
 *      B9h     PC Network
 *      BCh     EGA.SYS
 *      BFh     PC LAN Program
 *
 *  End of IBM-reserved range (although it seems to have become a jointly
 *  reserved range....)
 *
 *      D7h     Banyan VINES
 *      D8h     Novell
 *
 *  Old guidelines governing use and future assignment of multiplex #'s
 *  (they must be old because no one seems to have paid them much attention)
 *
 *  MUX 00-3F reserved for IBM
 *  MUX 80-BF reserved for IBM
 *  MUX 40-7F reserved for Microsoft
 *  MUX C0-FF users
 *
 *  New guidelines governing use and future assignment of multiplex #'s
 *
 *    + Just keep new MS multiplex assignments below 80h, ok?
 */


#define INT_MULT            0x2F


/* PRINT services
 */
#define I2F_PSPRINT         0x00
#define I2FPSPRINT_YIELD            0x80

#define I2F_PRINT           0x01
#define I2FPRINT_INSTALLCHECK       0x00
#define I2FPRINT_QUEUEFILE          0x01
#define I2FPRINT_REMOVEFILE         0x02
#define I2FPRINT_REMOVEALL          0x03
#define I2FPRINT_FREEZEQUEUE        0x04
#define I2FPRINT_THAWQUEUE          0x05
#define I2FPRINT_GETDEVICE          0x06

#define I2F_PCLAN_REDIR     0x02

#define I2F_HARDERR         0x05
#define I2FHARDERR_INSTALLCHECK     0x00
#define I2FHARDERR_EXPAND_EXTERR    0x01
#define I2FHARDERR_EXPAND_PARMERR   0x02

#define I2F_ASSIGN          0x06
#define I2FASSIGN_INSTALLCHECK      0x00
#define I2FASSIGN_GET_DRIVE_ASSIGNS 0x01

#define I2F_DRIVER          0x08
#define I2FDRIVER_INSTALLCHECK      0x00
#define I2FDRIVER_ADD_DEVICE        0x01
#define I2FDRIVER_EXEC_REQUEST      0x02
#define I2FDRIVER_GET_DRIVE_DATA    0x03

#define MultSHARE           0x10            // old-style definition
#define I2F_SHARE           0x10
#define I2FSHARE_INSTALLCHECK       0x00    // gshare.asm:  MFT_Enter
#define I2FSHARE_MAKEENTRY          0x01    // gshare.asm:  MFT_Enter
#define I2FSHARE_CLOSE              0x02    // gshare.asm:  MFTClose
#define I2FSHARE_CLOSEBYUID         0x03    // gshare.asm:  MFTClu
#define I2FSHARE_CLOSEBYPID         0x04    // gshare.asm:  MFTCloseP
#define I2FSHARE_CLOSEBYNAME        0x05    // gshare.asm:  MFTCloN
#define I2FSHARE_SETBYTELOCK        0x06    // gshare.asm:  Set_Mult_Block
#define I2FSHARE_CLRBYTELOCK        0x07    // gshare.asm:  Clr_Mult_Block
#define I2FSHARE_CHKBYTELOCK        0x08    // gshare.asm:  Chk_Block
#define I2FSHARE_GETENTRY           0x09    // gshare2.asm: MFT_Get
#define I2FSHARE_SAVESFTTOFCB       0x0A    // gshare2.asm: ShSave
#define I2FSHARE_CHKFCB             0x0B    // gshare2.asm: ShChk
#define I2FSHARE_COLLAPSESFTS       0x0C    // gshare2.asm: ShCol
#define I2FSHARE_CLOSEFILE          0x0D    // gshare2.asm: ShCloseFile
#define I2FSHARE_UPDATESFTS         0x0E    // gshare2.asm: ShSU

#define MultNET             0x11            // old-style definitions
#define MultIFS             0x11
#define I2F_REDIR           0x11
#define I2FREDIR_INSTALLCHECK       0x00
#define I2FREDIR_RMDIR              0x01
#define I2FREDIR_SEQ_RMDIR          0x02
#define I2FREDIR_MKDIR              0x03
#define I2FREDIR_SEQ_MKDIR          0x04
#define I2FREDIR_CHDIR              0x05
#define I2FREDIR_CLOSE              0x06
#define I2FREDIR_COMMIT             0x07
#define I2FREDIR_READ               0x08
#define I2FREDIR_WRITE              0x09
#define I2FREDIR_LOCK               0x0A
#define I2FREDIR_UNLOCK             0x0B
#define I2FREDIR_DISK_INFO          0x0C
#define I2FREDIR_SET_FILE_ATTR      0x0D
#define I2FREDIR_SEQ_SET_FILE_ATTR  0x0E
#define I2FREDIR_GET_FILE_INFO      0x0F
#define I2FREDIR_SEQ_GET_FILE_INFO  0x10
#define I2FREDIR_RENAME             0x11
#define I2FREDIR_SEQ_RENAME         0x12
#define I2FREDIR_DELETE             0x13
#define I2FREDIR_SEQ_DELETE         0x14
#define I2FREDIR_OPEN               0x15
#define I2FREDIR_SEQ_OPEN           0x16
#define I2FREDIR_CREATE             0x17
#define I2FREDIR_SEQ_CREATE         0x18
#define I2FREDIR_SEQ_SEARCH_FIRST   0x19
#define I2FREDIR_SEQ_SEARCH_NEXT    0x1A
#define I2FREDIR_SEARCH_FIRST       0x1B
#define I2FREDIR_SEARCH_NEXT        0x1C
#define I2FREDIR_ABORT              0x1D
#define I2FREDIR_ASSOPER            0x1E
#define I2FREDIR_PRINTER_SET_STRING 0x1F
#define I2FREDIR_FLUSHBUF           0x20
#define I2FREDIR_BUFWRITE           0x21
#define I2FREDIR_RESETENVIRONMENT   0x22
#define I2FREDIR_SPOOLCHECK         0x23
#define I2FREDIR_SPOOLCLOSE         0x24
#define I2FREDIR_DEVICEOPER         0x25
#define I2FREDIR_SPOOLECHOCHECK     0x26
#define I2FREDIR_UNUSED1            0x27
#define I2FREDIR_UNUSED2            0x28
#define I2FREDIR_UNUSED3            0x29
#define I2FREDIR_CLOSEFILES_FOR_UID 0x2A
#define I2FREDIR_DEVICE_IOCTL       0x2B
#define I2FREDIR_UPDATE_CB          0x2C
#define I2FREDIR_FILE_XATTRIBUTES   0x2D
#define I2FREDIR_XOPEN              0x2E
#define I2FREDIR_DEPENDENT_IOCTL    0x2F
#define I2FREDIR_PIPE_PEEK	     0x31

#define MultDOS             0x12            // old-style definition
#define I2F_DOS             0x12            // DOS call back
#define I2FDOS_INSTALLCHECK         0x00
#define I2FDOS_CLOSE                0x01
#define I2FDOS_RECSET               0x02
#define I2FDOS_GET_DOSGROUP         0x03
#define I2FDOS_PATHCHRCMP           0x04
#define I2FDOS_OUT                  0x05
#define I2FDOS_NET_I24_ENTRY        0x06
#define I2FDOS_PLACEBUF             0x07
#define I2FDOS_FREE_SFT             0x08
#define I2FDOS_BUFWRITE             0x09
#define I2FDOS_SHARE_VIOLATION      0x0A
#define I2FDOS_SHARE_ERROR          0x0B
#define I2FDOS_SET_SFT_MODE         0x0C
#define I2FDOS_DATE16               0x0D
#define I2FDOS_UNUSED1              0x0E    // (was SETVISIT)
#define I2FDOS_SCANPLACE            0x0F
#define I2FDOS_UNUSED2              0x10    // (was SKIPVISIT)
#define I2FDOS_STRCPY               0x11
#define I2FDOS_STRLEN               0x12
#define I2FDOS_UCASE                0x13
#define I2FDOS_POINTCOMP            0x14
#define I2FDOS_CHECKFLUSH           0x15
#define I2FDOS_SFFROMSFN            0x16
#define I2FDOS_GETCDSFROMDRV        0x17
#define I2FDOS_GET_USER_STACK       0x18
#define I2FDOS_GETTHISDRV           0x19
#define I2FDOS_DRIVEFROMTEXT        0x1A
#define I2FDOS_SETYEAR              0x1B
#define I2FDOS_DSUM                 0x1C
#define I2FDOS_DSLIDE               0x1D
#define I2FDOS_STRCMP               0x1E
#define I2FDOS_INITCDS              0x1F
#define I2FDOS_PJFNFROMHANDLE       0x20
#define I2FDOS__NAMETRANS           0x21
#define I2FDOS_CAL_LK               0x22
#define I2FDOS_DEVNAME              0x23
#define I2FDOS_IDLE                 0x24
#define I2FDOS_DSTRLEN              0x25
#define I2FDOS_NLS_OPEN             0x26    // DOS 3.3
#define I2FDOS__CLOSE               0x27    // DOS 3.3
#define I2FDOS_NLS_LSEEK            0x28    // DOS 3.3
#define I2FDOS__READ                0x29    // DOS 3.3
#define I2FDOS_FASTINIT             0x2A    // (for FASTOPEN; see fastopen.inc)
#define I2FDOS_NLS_IOCTL            0x2B    // DOS 3.3
#define I2FDOS_GETDEVLIST           0x2C    // DOS 3.3
#define I2FDOS_NLS_GETEXT           0x2D    // DOS 3.3
#define I2FDOS_MSG_RETRIEVAL        0x2E    // DOS 4.0
#define I2FDOS_FAKE_VERSION         0x2F    // DOS 4.0
#define I2FDOS_FndSFTPathInfo       0x30    // Return SFT path/cluster info
#define I2FDOS_SetFAT32Flgs         0x31    // Signal FAT32 win support and TSR flags

#define I2F_DISK            0x13
#define I2FDISK_SET_INT_HDLR        0x1300

#define NLSFUNC             0x14            // old-style definition
#define I2F_NLSFUNC         0x14            // NLSFUNC CALLS, DOS 3.3
#define I2FNLSFUNC_INSTALLCHECK     0x00
#define I2FNLSFUNC_CHGCODEPAGE      0x01
#define I2FNLSFUNC_GETEXTINFO       0x02
#define I2FNLSFUNC_SETCODEPAGE      0x03
#define I2FNLSFUNC_GETCNTRY         0x04

#define I2F_MSCDEX          0x15

#define I2F_DOS386          0x16
#define I2FDOS386_Logo              0x0E    // IO.SYS service for logo management
#define I2FDOS386_INT10             0x0F    // IO.SYS service to replace INT 10h hook
#define I2FDOS386_Get_Shell         0x11    // IO.SYS service to return shell info

// Flags returned in BX by the I2FDOS386_Get_Shell call

#define SHELLFLAG_CLEAN                 0x01
#define SHELLFLAG_DOSCLEAN              0x02
#define SHELLFLAG_NETCLEAN              0x04
#define SHELLFLAG_INTERACTIVE           0x08
#define SHELLFLAG_NOAUTO                0x20
#define SHELLFLAG_DISABLELOADTOP        0x40
#define SHELLFLAG_MSDOSMODE             0x80

#define I2FDOS386_Get_BIOS_Data     0x12    // IO.SYS service to return IO.SYS data
#define I2FDOS386_Get_SYSDAT_Path   0x13    // IO.SYS service to return path to SYSTEM.DAT
#define I2FDOS386_Set_SYSDAT_Path   0x14    // IO.SYS service to set path to SYSTEM.DAT

#define I2F_CLIPBOARD       0x17

#define I2F_MSMANAGER       0x18            // used by old MS-DOS Manager program

#define I2F_DOS4SHELL       0x19

#define MultANSI            0x1A            // old-style definition
#define I2F_ANSI            0x1A            // ANSI.SYS multiplex #
#define I2FANSI_INSTALLCHECK        0x00    // install check for ANSI
#define I2FANSI_IOCTL               0x01    // INT 2Fh interface to IOCTL
#define I2FANSI_DA_INFO             0x02    // information passing to ANSI

#define I2F_XMA2EMS         0x1B            // is this no longer used???

#define I2F_OS2_3XBOX       0x40
#define I2F3XBOX_SWITCHBGND         0x01
#define I2F3XBOX_SWITCHFGND         0x02

#define I2F_LANMAN41        0x41
#define I2F_LANMAN42        0x42

#define I2F_XMS             0x43            // see HIMEM.SYS for details
#define I2FXMS_INSTALLCHECK         0x00
#define I2FXMS_GETADDRESS           0x10
                                            // private functions:
                                            //  08h - return A20 handler
                                            //  09h - return XMS handle table address
                                            //  20h - used for Mach20 version
                                            //  30h - check for external A20 handler

#define I2F_DOSX            0x44            // what is this exactly???

#define I2F_WINPROFILE      0x45            // what is this exactly???

#define I2F_WIN30           0x46
#define I2FWIN30_INSTALLCHECK       0x80

#define I2F_BASCOM7         0x47

#define I2F_DOSKEY          0x48
#define I2FDOSKEY_INSTALLCHECK      0x00    // AL == non-zero if installed
#define I2FDOSKEY_READLINE          0x10    // DS:DX -> line input buffer

#define I2F_DOSINSTALL      0x49

#define MultMULT            0x4A            // old-style definition
#define I2F_MULTIPURPOSE    0x4A

    //  0h  Swap disk function for single floppy drive m/cs
    //      BIOS broadcasts with cx==0, and apps who handle
    //      swap disk messaging set cx == -1. BIOS sets dl == requested
    //      drive
    //
    //  1h  Get available HMA & pointer to it. Returns in BX & ES:DI
    //
    //  2h  Allocate HMA. BX == number of bytes in HMA to be allocated
    //      returns pointer in ES:DI
    //
    //  3h  Allocate HMA high. BX == number of bytes in HMA to be allocated
    //      returns pointer in ES:DI
    //
    //  4h  Query HMA arena header. ES:DI points to first HMA arena header.
    //
    //  5h  Switcher API
    //
    //  6h  Top of Memory for RPL
    //          BIOS issues INT 2Fh/AX=4A06 & DX=top of mem and any RPL
    //          code present in TOM should respond with a new TOM in DX
    //          to protect itself from MSLOAD & SYSINIT tromping over it.
    //          SYSINIT builds an arena with owner type 8 & name 'RPL' to
    //          protect the RPL code from COMMAND.COM transient protion.
    //          It is the responsibility of RPL program to release the mem.
    //
    //  7h  Reserved for PROTMAN support
    // 10h  smartdrv 4.0
    // 11h  dblspace api
    // 12h  MRCI     api
    // 13h  MRCI backpatch

#define MultMULTSWPDSK              0x00    // old-style definitions
#define MultMULTGETHMAPTR           0x01    //
#define MultMULTALLOCHMA            0x02    //
#define MultMULTALLOCHMAEXT         0x03    //
#define MultMULTGETHMAARENA         0x04    //
#define MultMULTRPLTOM              0x06    //

#define I2FMULT_SWPDSK              0x00    // swap Disk in drive A (BIOS)
#define I2FMULT_GETHMAPTR           0x01    // get available HMA & ptr
#define I2FMULT_SUBALLOCHMA         0x02    // allocate HMA (bx == # bytes)
#define I2FMULT_SHELL               0x05    // shell/switcher API
#define I2FMULT_RPLTOM              0x06    // top-of-memory for RPL support
#define I2FMULT_SMARTDRV            0x10    // interface to SmartDrv
    // Following values go in the BX register for I2FMULT_SMARTDRV
    #define MULT_SMARTDRV_GET_STATS                         0x0000
    #define MULT_SMARTDRV_COMMIT_ALL                        0x0001
    #define MULT_SMARTDRV_REINITIALIZE                      0x0002
    #define MULT_SMARTDRV_CACHE_DRIVE                       0x0003
        // These are the MULT_SMARTDRV_CACHE_DRIVE sub-sub-sub functions that go in DL
        #define MULT_SMARTDRVCACHE_DRIVE_GET                    0x00
        #define MULT_SMARTDRVCACHE_DRIVE_READ_ENABLE            0x01
        #define MULT_SMARTDRVCACHE_DRIVE_READ_DISABLE           0x02
        #define MULT_SMARTDRVCACHE_DRIVE_WRIT_ENABLE           0x03
        #define MULT_SMARTDRVCACHE_DRIVE_WRIT_DISABLE          0x04
    #define MULT_SMARTDRV_GET_INFO                          0x0004
    #define MULT_SMARTDRV_GET_ORIGINAL_DD_HEADER            0x0007
    #define MULT_SMARTDRV_SETGET_PROMPTFLUSH                0x0008
    #define MULT_SMARTDRV_UNHOOK                            0x0009
    #define MULT_SMARTDRV_SHOW_SDISKERR                     0x1234
#define I2FMULT_DBLSPACE            0x11    // interface to DblSpace
#define I2FMULT_MRCI                0x12    // interface to MRCI
#define I2FMULT_MRCIBackPatch       0x13    // interface to MRCI backpatch

#define I2FMULT_MULTEMM386       0x15    // Used by EMM386 for IOPORTTRAP

#define I2FMULT_OpenBootLog	0x16    // Open BootLog file
#define I2FMULT_WriteBootLog	0x17    // Write to BootLog File
#define I2FMULT_CloseBootLog	0x18    // Close BootLog File
#define I2FMULT_NWRedir		0x19    // NWRedir control
#define	I2FMULT_MRCIBroadcast	0x20	// MRCI detection broadcast
//#define I2FMULT_FlushBootLog	0x21	// Obsolete since no dblspace drive anymore

#define I2FMULT_EXECOVLY	0x30	// Overlay exec broadcast

#define I2FMULT_SetByte         0x31    // Set a byte in OS data area
#define I2FMULT_LogoServices    0x32    // Alias to logo services (AX=160Eh)
#define I2FMULT_ShellServices   0x33    // Alias to shell services (AX=1611h)

    // The following are subfunctions of I2FMULT_TASKSHELL (specified in SI)

#define I2FMULTSHELL_CINIT_PROGRAM_LIST         0x00
#define I2FMULTSHELL_CADD_PROGRAM_TO_LIST       0x01
#define I2FMULTSHELL_CGO_Z_NEXT                 0x02
#define I2FMULTSHELL_CGO_Z_PREV                 0x03
#define I2FMULTSHELL_CDELETE_PROGRAM_FROM_LIST  0x04
#define I2FMULTSHELL_CGO_NEXT                   0x05
#define I2FMULTSHELL_CGET_ITH_PROGRAM_STRING    0x06
#define I2FMULTSHELL_CGET_LIST_LENGTH           0x07
#define I2FMULTSHELL_CGET_GLOBAL_SWITCH_DATA    0x08
#define I2FMULTSHELL_CGET_ITH_ENTRY_DATA        0x09
#define I2FMULTSHELL_MAX_HANDLER_CALL           0x09
#define I2FMULTSHELL_CADD_PARAMS                0x0A
#define I2FMULTSHELL_CGET_EXITCODE              0x0B
#define I2FMULTSHELL_CTOTOP_ITH_LIST_PE         0x0C

#define I2FMULT_SystemBootTime	0x50	// System boot timestamp


#define I2F_TASKAPI         0x4B
#define I2FTASK_BUILD_CHAIN         0x01
#define I2FTASKBC_INIT_SWITCHER                 0x00
#define I2FTASKBC_QUERY_SUSPEND                 0x01
#define I2FTASKBC_SUSPEND                       0x02
#define I2FTASKBC_RESUME                        0x03
#define I2FTASKBC_SESSION_ACTIVE                0x04
#define I2FTASKBC_CREATE                        0x05
#define I2FTASKBC_DESTROY                       0X06
#define I2FTASKBC_SWITCHER_EXIT                 0x07
#define I2FTASK_DETECT_SWITCHER     0x02
#define I2FTASKDS_GETVERSION                    0x00
#define I2FTASKDS_TESTMEMORYREGION              0x01
#define I2FTASKDS_SUSPEND_SWITCHER              0x02
#define I2FTASKDS_RESUME_SWITCHER               0x03
#define I2FTASKDS_HOOK_CALLOUT                  0x04
#define I2FTASKDS_UNHOOK_CALLOUT                0x05
#define I2FTASKDS_QUERY_API_SUPPORT             0x06
#define I2FTASK_ALLOCATE_SW_ID      0x03
#define I2FTASK_FREE_SW_ID          0x04
#define I2FTASK_GET_INST_DATA       0x05
#define I2FTASK_RESTART_CMD         0x20
#define I2FTASK_GET_STARTTIME       0x22
#define I2FTASK_GET_REG_CODE_PAGE   0x28
#define I2FTASK_GET_REGISTRY_CACHE	0x29


/*
 * These are obselete functions for APM
 * See functions 0x53 & 0x54
 */
#define MultAPM             0x4C        // old-style definition
#define I2F_APM             0x4C
#define I2FAPM_VERCHK                   0x00
#define I2FAPM_SUSSYSREQ                0x01
#define I2FAPM_APM_SUS_RES_BATT_NOTIFY  0xFF


#define I2F_KKC4D           0x4D
#define I2F_KKC4E           0x4E
#define I2F_MULTILANGDOS    0x4F

#define I2F_SETNLS          0x50        // used by SETNLS

#define I2F_ODI             0x51

#define I2F_STAC            0x52        // reserved by MS for Stac Electronics


/*
 * 0x53 & 0x54 are used by POWER.EXE for broadcasting APM events
 * and to control POWER.EXE's status from application programs
 * For details about sub-function numbers refer to ROMDOS 5.0 Technical
 * Specification document
 */
#define MultPwr_BRDCST      0x53        // old-style definitions
#define MultPwr_API         0x54        //
#define I2F_POWER_BRDCST    0x53        // used by POWER.EXE to broadcast APM events
#define I2F_POWER_API       0x54        // used for accessing POWER.EXE's API


#define I2F_COMMAND         0x55        // used by COMMAND.COM


/*
 * 0x56 - assigned to Sewell Development (InterLnk)
 * 0x57 - assigned to Iomega Corp.
 */
#define I2F_INTERLNK        0x56
#define I2F_IOMEGA          0x57


/*
 *
 * 0x58 - assigned to Chicago network transition interface
 *        This supports loading Chicago from a remote drive.
 */
#define I2F_NETLOAD         0x58

#define I2F_SWLICENSING     0x70


#define I2F_NOVELL          0x7A        // hey, how'd they get in our range?

/****************************************************************************/
/* End of MS-reserved range                                                 */
/****************************************************************************/


#define I2F_IBMRESERVED     0xAB


/* GRAPHICS services
 */
#define I2F_GRAPHICS        0xAC
#define I2F_INSTALLCHECK            0x00


/* NLS services
 */
#define I2F_NLS             0xAD
#define I2FNLS_INSTALLCHECK         0x00
#define I2FNLS_UNKNOWN1             0x01
#define I2FNLS_UNKNOWN2             0x02
#define I2FNLS_UNKNOWN3             0x03
#define I2FNLS_UNKNOWN4             0x04
#define I2FNLS_UNKNOWN5             0x10
#define I2FNLS_UNKNOWN6             0x40    // called by PRINT.COM (4.01)

#define I2FKEYB_INSTALLCHECK        0x80
#define I2FKEYB_SETKBCP             0x81
#define I2FKEYB_SETKBMAP            0x82
#define I2FKEYB_GETKBMAP            0x83


/* COMMAND call-outs
 *
 * Note: APPEND hooks this call to avoid execing the actual APPEND utility
 */

#define I2F_INSTCMD         0xAE            // (DX must be -1)
#define I2FINSTCMD_INSTALLCHECK     0x00    // AL == 0FFh if private command
#define I2FINSTCMD_EXECUTE          0x01    //


#define I2F_MODE            0xAF


/* GRAFTABL services
 */
#define I2F_GRAFTABL        0xB0
#define I2FGRAFTABL_INSTALLCHECK    0x00
#define I2FGRAFTABL_GETFONT         0x01


/* APPEND services
 */
#define I2F_APPEND          0xB7
#define I2FAPPEND_INSTALLCHECK      0x00    // AL == -1 if installed
#define I2FAPPEND_OLDDIRPTR         0x01    // (not supported anymore)
#define I2FAPPEND_APPVER            0x02    // AX == -1 ("not network version")
#define I2FAPPEND_DISABLE           0x03    // Disable APPEND (was for TopView)
#define I2FAPPEND_DIRPTR            0x04    // ES:DI -> directory list
#define I2FAPPEND_GETSTATE          0x06    // APPEND flags only (BX)
#define I2FAPPEND_SETSTATE          0x07    // APPEND flags only (BX)
#define I2FAPPEND_VERSION           0x10    // APPEND flags (AX) and version (DX)
#define I2FAPPEND_TRUENAME          0x11    // set one-shot true-name return

#define I2FAPPENDF_ENABLE           0x0001
#define I2FAPPENDF_DRIVEOVERRIDE    0x1000
#define I2FAPPENDF_PATHOVERRIDE     0x2000
#define I2FAPPENDF_APPENDENV        0x4000
#define I2FAPPENDF_SRCHEXECOVERRIDE 0x8000


/* EGA.SYS services (in DOS5, WINDOWS3)
 */
#define I2F_EGASYS          0xBC
#define I2FEGASYS_INSTALLCHECK      0x00
#define I2FEGASYS_GETVERSION        0x06


/****************************************************************************/
/* End of IBM-reserved range                                                */
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\regstr.inc ===
ifndef _INC_REGSTR
_INC_REGSTR     EQU     1
REGSTR_KEY_CLASS        EQU     <"Class">
REGSTR_KEY_CONFIG       EQU     <"Config">
REGSTR_KEY_ENUM EQU     <"Enum">
REGSTR_KEY_ROOTENUM     EQU     <"Root">
REGSTR_KEY_BIOSENUM     EQU     <"BIOS">
REGSTR_KEY_ACPIENUM     EQU     <"ACPI">
REGSTR_KEY_PCMCIAENUM   EQU     <"PCMCIA">
REGSTR_KEY_PCIENUM      EQU     <"PCI">
REGSTR_KEY_VPOWERDENUM  EQU     <"VPOWERD">
ifndef NEC_98
REGSTR_KEY_ISAENUM      EQU     <"ISAPnP">
REGSTR_KEY_EISAENUM     EQU     <"EISA">
else
REGSTR_KEY_ISAENUM      EQU     <"C98PnP">
REGSTR_KEY_EISAENUM     EQU     <"NESA">
endif
REGSTR_KEY_LOGCONFIG    EQU     <"LogConfig">
REGSTR_KEY_SYSTEMBOARD  EQU     <"*PNP0C01">
REGSTR_KEY_APM  EQU     <"*PNP0C05">
REGSTR_KEY_INIUPDATE    EQU     <"IniUpdate">
REG_KEY_INSTDEV EQU     <"Installed">
REGSTR_KEY_DOSOPTCDROM  EQU     <"CD-ROM">
REGSTR_KEY_DOSOPTMOUSE  EQU     <"MOUSE">
REGSTR_DEFAULT_INSTANCE EQU     <"0000">
REGSTR_PATH_MOTHERBOARD EQU     <REGSTR_KEY_SYSTEMBOARD"\\"REGSTR_DEFAULT_INSTANCE>
REGSTR_PATH_SETUP       EQU     <"Software\Microsoft\Windows\CurrentVersion">
REGSTR_PATH_SETUP_SETUP EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup">
REGSTR_PATH_SETUP_MIGRATION     EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\Migration">
REGSTR_PATH_SETUP_OC    EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents">
REGSTR_PATH_SETUP_OC_MULTILANGUAGE      EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\MultilanguageTop">
REGSTR_PATH_SETUP_OC_BALTIC     EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\Baltic">
REGSTR_PATH_SETUP_OC_CE EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\CE">
REGSTR_PATH_SETUP_OC_CYRILLIC   EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\Cyrillic">
REGSTR_PATH_SETUP_OC_GREEK      EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\Greek">
REGSTR_PATH_SETUP_OC_TURKISH    EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents\Turkish">
REGSTR_PATH_SETUPX      EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\SetupX">
REGSTR_PATH_SETUPX_CERT EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\SetupX\Cert">
REGSTR_PATH_INF_INTERNET        EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\SetupX\INF\Internet">
REGSTR_PATH_INF_OEMNAME EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\SetupX\INF\OEM Name">
REGSTR_PATH_CATALOGS    EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\SetupX\Catalogs">
REGSTR_PATH_DRIVERSIGN  EQU     <"Software\Microsoft\Driver Signing">
REGSTR_PATH_DRIVERSIGN_CLASSES  EQU     <"Software\Microsoft\Driver Signing\Classes">
REGSTR_PATH_DRIVERSIGN_CLASSES_HWID     EQU     <"Software\Microsoft\Driver Signing\Classes\HWID">
REGSTR_PATH_REG1STBOOTCLEAN     EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\Reg1stBootClean">
REGSTR_PATH_SRCPATHS    EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\SourcePaths">
REGSTR_PATH_VERSION_CONFLICT    EQU     <"Software\Microsoft\VersionConflictManager">
REGSTR_PATH_VERSION_CONFLICT_FILES      EQU     <"Software\Microsoft\VersionConflictManager\Files">
REGSTR_PATH_PIFCONVERT  EQU     <"Software\Microsoft\Windows\CurrentVersion\PIFConvert">
REGSTR_PATH_MSDOSOPTS   EQU     <"Software\Microsoft\Windows\CurrentVersion\MS-DOSOptions">
REGSTR_PATH_MSDOSEMU    EQU     <"Software\Microsoft\Windows\CurrentVersion\MS-DOS Emulation">
REGSTR_PATH_NEWDOSBOX   EQU     <"Software\Microsoft\Windows\CurrentVersion\MS-DOS Emulation\AppCompat">
REGSTR_PATH_RUNONCE     EQU     <"Software\Microsoft\Windows\CurrentVersion\RunOnce">
REGSTR_PATH_RUNONCE_SETUP       EQU     <"Software\Microsoft\Windows\CurrentVersion\RunOnce\Setup">
REGSTR_PATH_RUN EQU     <"Software\Microsoft\Windows\CurrentVersion\Run">
REGSTR_PATH_RUNSERVICESONCE     EQU     <"Software\Microsoft\Windows\CurrentVersion\RunServicesOnce">
REGSTR_PATH_RUNSERVICES EQU     <"Software\Microsoft\Windows\CurrentVersion\RunServices">
REGSTR_PATH_EXPLORER    EQU     <"Software\Microsoft\Windows\CurrentVersion\Explorer">
REGSTR_PATH_DETECT      EQU     <"Software\Microsoft\Windows\CurrentVersion\Detect">
REGSTR_PATH_APPPATHS    EQU     <"Software\Microsoft\Windows\CurrentVersion\App Paths">
REGSTR_PATH_UNINSTALL   EQU     <"Software\Microsoft\Windows\CurrentVersion\Uninstall">
REGSTR_PATH_REALMODENET EQU     <"Software\Microsoft\Windows\CurrentVersion\Network\Real Mode Net">
REGSTR_PATH_NETEQUIV    EQU     <"Software\Microsoft\Windows\CurrentVersion\Network\Equivalent">
REGSTR_PATH_CVNETWORK   EQU     <"Software\Microsoft\Windows\CurrentVersion\Network">
REGSTR_PATH_REINSTALL   EQU     <"Software\Microsoft\Windows\CurrentVersion\Reinstall">
REGSTR_PATH_SETUP_PRESERVE      EQU     <"Software\Microsoft\Windows\CurrentVersion\Setup\Preserve">
REGSTR_PATH_ASD EQU     <"System\CurrentControlSet\Control\ASD">
REGSTR_PATH_ASD_PROB    EQU     <"System\CurrentControlSet\Control\ASD\Prob">
REGSTR_PATH_ASD_LIST    EQU     <"System\CurrentControlSet\Control\ASD\List">
REGSTR_VAL_PRODUCTKEY   EQU     <"ProductKey">
REGSTR_VAL_DIGITALPRODUCTID     EQU     <"DigitalProductId">
REGSTR_PATH_VOLUMECACHE EQU     <"Software\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches">
REGSTR_VAL_DISPLAY      EQU     <"display">
REGSTR_VAL_ADVANCEDBUTTONTEXT   EQU     <"AdvancedButtonText">
REGSTR_VAL_BITMAPDISPLAY        EQU     <"BitmapDisplay">
REGSTR_VAL_URL  EQU     <"URL">
REGSTR_VAL_FOLDER       EQU     <"folder">
REGSTR_VAL_FILELIST     EQU     <"FileList">
REGSTR_VAL_LASTACCESS   EQU     <"LastAccess">
REGSTR_VAL_FLAGS        EQU     <"Flags">
REGSTR_VAL_CLEANUPSTRING        EQU     <"CleanupString">
REGSTR_VAL_FAILIFPROCESSRUNNING EQU     <"FailIfProcessRunning">
REGSTR_PATH_IDCONFIGDB  EQU     <"System\CurrentControlSet\Control\IDConfigDB">
REGSTR_PATH_CLASS       EQU     <"System\CurrentControlSet\Services\Class">
REGSTR_PATH_DEVICECLASSES       EQU     <"System\CurrentControlSet\Control\DeviceClasses">
REGSTR_PATH_DISPLAYSETTINGS     EQU     <"Display\Settings">
REGSTR_PATH_FONTS       EQU     <"Display\Fonts">
REGSTR_PATH_ENUM        EQU     <"Enum">
REGSTR_PATH_ROOT        EQU     <"Enum\Root">
REGSTR_PATH_SERVICES    EQU     <"System\CurrentControlSet\Services">
REGSTR_PATH_VXD EQU     <"System\CurrentControlSet\Services\VxD">
REGSTR_PATH_NTKERN      EQU     <"System\CurrentControlSet\Services\NTKern">
REGSTR_PATH_CONFIGMG    EQU     <"System\CurrentControlSet\Services\VxD\ConfigMg">
REGSTR_VAL_PRELOAD_SUPPORT      EQU     <"PreloadSupport">
REGSTR_VAL_DEEP_SLEEP   EQU     <"DeepSleep">
REGSTR_PATH_IOS EQU     <"System\CurrentControlSet\Services\VxD\IOS">
REGSTR_PATH_VMM EQU     <"System\CurrentControlSet\Services\VxD\VMM">
REGSTR_PATH_PCI EQU     <"System\CurrentControlSet\Services\VxD\PCI">
REGSTR_PATH_BIOS        EQU     <"System\CurrentControlSet\Services\VxD\BIOS">
REGSTR_PATH_VPOWERD     EQU     <"System\CurrentControlSet\Services\VxD\VPOWERD">
REGSTR_PATH_VNETSUP     EQU     <"System\CurrentControlSet\Services\VxD\VNETSUP">
REGSTR_PATH_NWREDIR     EQU     <"System\CurrentControlSet\Services\VxD\NWREDIR">
REGSTR_PATH_NCPSERVER   EQU     <"System\CurrentControlSet\Services\NcpServer\Parameters">
REGSTR_PATH_SPANNABLEBUS        EQU     <"System\CurrentControlSet\Services\VxD\ConfigMg\SpannableBus">
REGSTR_PATH_PNPBUS      EQU     <"System\CurrentControlSet\Services\VxD\ConfigMg\PnPBus">
REGSTR_PATH_PREINSTALL  EQU     <"System\CurrentControlSet\Services\VxD\ConfigMg\PreInstall">
REGSTR_PATH_PREINSTALL_SOFTWARE EQU     <"SoftWare">
REGSTR_PATH_PREINSTALL_HARDWARE EQU     <"HardWare">
REGSTR_PATH_VCOMM       EQU     <"System\CurrentControlSet\Services\VxD\VCOMM">
REGSTR_PATH_IOARB       EQU     <"System\CurrentControlSet\Services\Arbitrators\IOArb">
REGSTR_PATH_ADDRARB     EQU     <"System\CurrentControlSet\Services\Arbitrators\AddrArb">
REGSTR_PATH_DMAARB      EQU     <"System\CurrentControlSet\Services\Arbitrators\DMAArb">
REGSTR_PATH_IRQARB      EQU     <"System\CurrentControlSet\Services\Arbitrators\IRQArb">
REGSTR_VAL_DONTUSEMEM   EQU     <"DontAllocLastMem">
REGSTR_PATH_RESERVED_RANGELIST  EQU     <"ReservedRangeList">
REGSTR_PATH_CODEPAGE    EQU     <"System\CurrentControlSet\Control\Nls\Codepage">
REGSTR_PATH_LOCALE      EQU     <"System\CurrentControlSet\Control\Nls\Locale">
REGSTR_PATH_FILESYSTEM  EQU     <"System\CurrentControlSet\Control\FileSystem">
REGSTR_PATH_FILESYSTEM_CACHEDIRS        EQU     <"System\CurrentControlSet\Control\FileSystem\CacheDirectories">
REGSTR_RELPATH_FILESYSTEM_CACHEDIRS     EQU     <"CacheDirectories">
REGSTR_PATH_FILESYSTEM_NOVOLTRACK       EQU     <"System\CurrentControlSet\Control\FileSystem\NoVolTrack">
REGSTR_PATH_CDFS        EQU     <"System\CurrentControlSet\Control\FileSystem\CDFS">
REGSTR_PATH_UDF EQU     <"System\CurrentControlSet\Control\FileSystem\UDF">
REGSTR_PATH_WINBOOT     EQU     <"System\CurrentControlSet\Control\WinBoot">
REGSTR_PATH_INSTALLEDFILES      EQU     <"System\CurrentControlSet\Control\InstalledFiles">
REGSTR_PATH_INSTALLEDFILES_RENAME       EQU     <"System\CurrentControlSet\Control\InstalledFiles\Rename">
REGSTR_PATH_VMM32FILES  EQU     <"System\CurrentControlSet\Control\VMM32Files">
REGSTR_PATH_SETUPFLAGS  EQU     <"Software\Microsoft\Windows\CurrentVersion">
REGSTR_MAX_VALUE_LENGTH EQU     256
REGSTR_VAL_BITSPERPIXEL EQU     <"BitsPerPixel">
REGSTR_VAL_RESOLUTION   EQU     <"Resolution">
REGSTR_VAL_DPILOGICALX  EQU     <"DPILogicalX">
REGSTR_VAL_DPILOGICALY  EQU     <"DPILogicalY">
REGSTR_VAL_DPIPHYSICALX EQU     <"DPIPhysicalX">
REGSTR_VAL_DPIPHYSICALY EQU     <"DPIPhysicalY">
REGSTR_VAL_REFRESHRATE  EQU     <"RefreshRate">
REGSTR_VAL_DISPLAYFLAGS EQU     <"DisplayFlags">
REGSTR_VAL_SCREENRES    EQU     <"ScreenResolution">
REGSTR_VAL_DESKTOPSIZE  EQU     <"DesktopSize">
REGSTR_VAL_DESKTOPPOS   EQU     <"DesktopPos">
REGSTR_VAL_BACKUPDIR    EQU     <"BackupDirectory">
REGSTR_VAL_LASTINSTALLSTATUS    EQU     <"LastInstallStatus">
REGSTR_VAL_REBOOTSTATUS EQU     <"RebootStatus">
REGSTR_VAL_REINSTALL_DISPLAYNAME        EQU     <"DisplayName">
REGSTR_VAL_REINSTALL_HARDWAREID EQU     <"HardwareID">
REGSTR_VAL_REINSTALL_REINSTALLSTRING    EQU     <"ReinstallString">
REGSTR_PATH_CONTROLPANEL        EQU     <"Control Panel">
REGSTR_PATH_CONTROLSFOLDER      EQU     <"Software\Microsoft\Windows\CurrentVersion\Controls Folder">
REGSTR_VAL_DOSCP        EQU     <"OEMCP">
REGSTR_VAL_WINCP        EQU     <"ACP">
REGSTR_VAL_DOSVMCP      EQU     <"DOSCP">
REGSTR_VAL_DOSCC        EQU     <"OEMCC">
REGSTR_VAL_DOSKT        EQU     <"KYBTYPE">
REGSTR_VAL_DOSKL        EQU     <"KYBLAYOUT">
REGSTR_VAL_DOSLID       EQU     <"LANGID">
REGSTR_VAL_DOSCFN       EQU     <"COUNTRYFNAME">
REGSTR_VAL_DOSCPFN      EQU     <"CODEPAGEFNAME">
REGSTR_VAL_DOSKFN       EQU     <"KYBFNAME">
REGSTR_VAL_INSTALLED    EQU     <"Installed">
REGSTR_PATH_DYNA_ENUM   EQU     <"Config Manager\Enum">
REGSTR_PATH_DYNA_GLOBAL EQU     <"Config Manager\Global">
REGSTR_VAL_HARDWARE_KEY EQU     <"HardWareKey">
REGSTR_VAL_ALLOCATION   EQU     <"Allocation">
REGSTR_VAL_PROBLEM      EQU     <"Problem">
REGSTR_VAL_STATUS       EQU     <"Status">
REGSTR_VAL_CHILD        EQU     <"Child">
REGSTR_VAL_SIBLING      EQU     <"Sibling">
REGSTR_VAL_PARENT       EQU     <"Parent">
REGSTR_VAL_PAGER_TYPE   EQU     <"Pager">
REGSTR_VAL_DEVNODES_CHANGED     EQU     <"Changed">
REGSTR_VAL_SYSTEMROOT   EQU     <"SystemRoot">
REGSTR_VAL_BOOTCOUNT    EQU     <"BootCount">
REGSTR_VAL_REALNETSTART EQU     <"RealNetStart">
REGSTR_VAL_MEDIA        EQU     <"MediaPath">
REGSTR_VAL_CONFIG       EQU     <"ConfigPath">
REGSTR_VAL_DEVICEPATH   EQU     <"DevicePath">
REGSTR_VAL_OTHERDEVICEPATH      EQU     <"OtherDevicePath">
REGSTR_VAL_DRIVERUPDATEPATH     EQU     <"DriverUpdatePath">
REGSTR_VAL_REMMEDIA_RECURSE     EQU     <"RemovableMediaSearchRoot">
REGSTR_VAL_OLDWINDIR    EQU     <"OldWinDir">
REGSTR_VAL_OLDWINVER    EQU     <"OldWinVer">
REGSTR_VAL_SETUPFLAGS   EQU     <"SetupFlags">
REGSTR_VAL_REGOWNER     EQU     <"RegisteredOwner">
REGSTR_VAL_REGORGANIZATION      EQU     <"RegisteredOrganization">
REGSTR_VAL_LICENSINGINFO        EQU     <"LicensingInfo">
REGSTR_VAL_OLDMSDOSVER  EQU     <"OldMSDOSVer">
REGSTR_VAL_FIRSTINSTALLDATETIME EQU     <"FirstInstallDateTime">
REGSTR_VAL_INSTALLTYPE  EQU     <"InstallType">
REGSTR_VAL_WRAPPER      EQU     <"Wrapper">
REGSTR_VAL_HWSETUP      EQU     <"HWSetup">
REGSTR_VAL_VERSION      EQU     <"Version">
REGSTR_VAL_VERSIONNUMBER        EQU     <"VersionNumber">
REGSTR_VAL_SUBVERSIONNUMBER     EQU     <"SubVersionNumber">
REGSTR_VAL_KEYBOARDID   EQU     <"KeyboardID">
REGSTR_VAL_PORTABLE     EQU     <"Portable">
REGSTR_VAL_LEGACYFREE   EQU     <"LegacyFree">
REGSTR_VAL_AUDITINPROGRESS      EQU     <"AuditInProgress">
IT_COMPACT      EQU     0000H
IT_TYPICAL      EQU     0001H
IT_PORTABLE     EQU     0002H
IT_CUSTOM       EQU     0003H
REGSTR_KEY_SETUP        EQU     <"\Setup">
REGSTR_KEY_VAR_LDID     EQU     <"VarLDID">
REGSTR_VAL_BOOTDIR      EQU     <"BootDir">
REGSTR_VAL_WINBOOTDIR   EQU     <"WinbootDir">
REGSTR_VAL_WINDIR       EQU     <"WinDir">
REGSTR_VAL_SHOWEBDPAGE  EQU     <"EBDPage">
REGSTR_VAL_REGCLEAN_ROOTKEY     EQU     <"RootKey">
REGSTR_VAL_REGCLEAN_SUBKEY      EQU     <"SubKey">
REGSTR_VAL_REGCLEAN_VALUE       EQU     <"ValueName">
REGSTR_VAL_REGCLEAN_DATA        EQU     <"DataString">
REGSTR_VAL_BACKUP_DIRTY EQU     <"Dirty">
REGSTR_VAL_BACKUP_DATE  EQU     <"BackupDate">
REGSTR_VAL_BACKUP_CONFLICT_TYPE EQU     <"ConflictType">
REGSTR_VAL_BACKUP_RESTORE       EQU     <"Restore">
REGSTR_VAL_INSTALL_CLASSES      EQU     <"InstallClasses">
SPT_OTHER       EQU     00000000H
SPT_CDROM       EQU     00000001H
SPT_FLOPPY      EQU     00000002H
SPT_NETWORK     EQU     00000004H
SPT_FIXEDDISK   EQU     00000008H
REGSTR_VAL_SRCPATH      EQU     <"SourcePath">
REGSTR_VAL_SRCPATHTYPE  EQU     <"InstallPathType">
REGSTR_VAL_PRECOPY_SRCPATH      EQU     <"PostDetectSrcPath">
REGSTR_VAL_SUWIN_CMDLINE        EQU     <"CommandLine">
REGSTR_VAL_SETUPBINARY  EQU     <"SetupBinary">
REGSTR_VAL_APPINSTPATH  EQU     <"AppInstallPath">
REGSTR_VAL_OLSSRCPATH   EQU     <"OLSSrcPath">
REGSTR_PATH_EBD EQU     <REGSTR_PATH_SETUPREGSTR_KEY_SETUP"\\EBD">
REGSTR_KEY_EBDFILESLOCAL        EQU     <"EBDFilesLocale">
REGSTR_KEY_EBDFILESKEYBOARD     EQU     <"EBDFilesKeyboard">
REGSTR_KEY_EBDAUTOEXECBATLOCAL  EQU     <"EBDAutoexecBatLocale">
REGSTR_KEY_EBDAUTOEXECBATKEYBOARD       EQU     <"EBDAutoexecBatKeyboard">
REGSTR_KEY_EBDCONFIGSYSLOCAL    EQU     <"EBDConfigSysLocale">
REGSTR_KEY_EBDCONFIGSYSKEYBOARD EQU     <"EBDConfigSysKeyboard">
REGSTR_PATH_ACTIVE_SETUP        EQU     <"Software\Microsoft\Active Setup">
REGSTR_PATH_AS_INSTALLED        EQU     <REGSTR_PATH_ACTIVE_SETUP"\\InstalledComponents">
REGSTR_VAL_AS_ISINSTALLED       EQU     <"IsInstalled">
REGSTR_VAL_AS_VERSION   EQU     <"Version">
REGSTR_VAL_AS_LOCALE    EQU     <"Locale">
REGSTR_VAL_AS_STUBPATH  EQU     <"StubPath">
REGSTR_VAL_AS_COMPONENTID       EQU     <"ComponentID">
REGSTR_VAL_AS_DONTASK   EQU     <"DontAsk">
REGSTR_VAL_POLICY       EQU     <"Policy">
DRIVERSIGN_NONE EQU     00000000H
DRIVERSIGN_WARNING      EQU     00000001H
DRIVERSIGN_BLOCKING     EQU     00000002H
REGSTR_VAL_PATH EQU     <"Path">
REGSTR_VAL_MSDOSMODE    EQU     <"MSDOSMode">
REGSTR_VAL_MSDOSMODEDISCARD     EQU     <"Discard">
REGSTR_VAL_DOSOPTGLOBALFLAGS    EQU     <"GlobalFlags">
DOSOPTGF_DEFCLEAN       EQU     00000001H
REGSTR_VAL_DOSOPTFLAGS  EQU     <"Flags">
REGSTR_VAL_OPTORDER     EQU     <"Order">
REGSTR_VAL_CONFIGSYS    EQU     <"Config.Sys">
REGSTR_VAL_AUTOEXEC     EQU     <"Autoexec.Bat">
REGSTR_VAL_STDDOSOPTION EQU     <"StdOption">
REGSTR_VAL_DOSOPTTIP    EQU     <"TipText">
DOSOPTF_DEFAULT EQU     00000001H
DOSOPTF_SUPPORTED       EQU     00000002H
DOSOPTF_ALWAYSUSE       EQU     00000004H
DOSOPTF_USESPMODE       EQU     00000008H
DOSOPTF_PROVIDESUMB     EQU     00000010H
DOSOPTF_NEEDSETUP       EQU     00000020H
DOSOPTF_INDOSSTART      EQU     00000040H
DOSOPTF_MULTIPLE        EQU     00000080H
SUF_FIRSTTIME   EQU     00000001H
SUF_EXPRESS     EQU     00000002H
SUF_BATCHINF    EQU     00000004H
SUF_CLEAN       EQU     00000008H
SUF_INSETUP     EQU     00000010H
SUF_NETSETUP    EQU     00000020H
SUF_NETHDBOOT   EQU     00000040H
SUF_NETRPLBOOT  EQU     00000080H
SUF_SBSCOPYOK   EQU     00000100H
SUF_NODEVINSTALL        EQU     00000200H
SUF_MIGRATEDLLS EQU     00000400H
SUF_CUSTOMINSTALL       EQU     00000800H
REGSTR_VAL_DOSPAGER     EQU     <"DOSPager">
REGSTR_VAL_VXDGROUPS    EQU     <"VXDGroups">
REGSTR_VAL_RELEASE_IDLES        EQU     <"ReleaseIdles">
REGSTR_VAL_NTMPDRIVER   EQU     <"NTMPDriver">
REGSTR_VAL_VPOWERDFLAGS EQU     <"Flags">
VPDF_DISABLEPWRMGMT     EQU     00000001H
VPDF_FORCEAPM10MODE     EQU     00000002H
VPDF_SKIPINTELSLCHECK   EQU     00000004H
VPDF_DISABLEPWRSTATUSPOLL       EQU     00000008H
VPDF_DISABLERINGRESUME  EQU     00000010H
VPDF_SHOWMULTIBATT      EQU     00000020H
VPDF_DONTDISABLEDEVPM   EQU     00000100H
VPDF_SUSPENDWORKSWRONG  EQU     00000200H
VPDF_PERMSUSPENDWORKSWRONG      EQU     00000400H
VPDF_HIBERNATEWORKSWRONG        EQU     00000800H
VPDF_PERMHIBERNATEWORKSWRONG    EQU     00001000H
REGSTR_VAL_SUSPENDFLAG  EQU     <"SuspendFlag">
REGSTR_VAL_SUSPENDWORKEDFLAG    EQU     <"SuspendHasWorkedFlag">
REGSTR_VAL_LASTBIOSDATE EQU     <"BiosDate">
REGSTR_VAL_HIBERFLAG    EQU     <"HiberFlag">
REGSTR_VAL_HIBERNATEWORKEDFLAG  EQU     <"HibernateHasWorkedFlag">
REGSTR_VAL_DELAYOFFONHIBERNATE  EQU     <"HiberDelayOff">
REGSTR_VAL_REBOOTONHIBERNATE    EQU     <"HiberReboot">
REGSTR_VAL_PERFHIBERNATE        EQU     <"HiberPerf">
REGSTR_VAL_BAD32BITAPMS5        EQU     <"Skip32BitAPMS5">
REGSTR_VAL_USES4OS      EQU     <"UseS4OS">
REGSTR_VAL_DISABLE_LEGACY_WAKEUP        EQU     <"DisableLegacyWakeUp">
REGSTR_PATH_POWERCFG    EQU     <"Control Panel\PowerCfg">
REGSTR_VAL_CURRENTPOWERPOLICY   EQU     <"CurrentPowerPolicy">
REGSTR_VAL_WORKGROUP    EQU     <"Workgroup">
REGSTR_VAL_DIRECTHOST   EQU     <"DirectHost">
REGSTR_VAL_FILESHARING  EQU     <"FileSharing">
REGSTR_VAL_PRINTSHARING EQU     <"PrintSharing">
REGSTR_VAL_FIRSTNETDRIVE        EQU     <"FirstNetworkDrive">
REGSTR_VAL_MAXCONNECTIONS       EQU     <"MaxConnections">
REGSTR_VAL_APISUPPORT   EQU     <"APISupport">
REGSTR_VAL_MAXRETRY     EQU     <"MaxRetry">
REGSTR_VAL_MINRETRY     EQU     <"MinRetry">
REGSTR_VAL_SUPPORTLFN   EQU     <"SupportLFN">
REGSTR_VAL_SUPPORTBURST EQU     <"SupportBurst">
REGSTR_VAL_SUPPORTTUNNELLING    EQU     <"SupportTunnelling">
REGSTR_VAL_FULLTRACE    EQU     <"FullTrace">
REGSTR_VAL_READCACHING  EQU     <"ReadCaching">
REGSTR_VAL_SHOWDOTS     EQU     <"ShowDots">
REGSTR_VAL_GAPTIME      EQU     <"GapTime">
REGSTR_VAL_SEARCHMODE   EQU     <"SearchMode">
REGSTR_VAL_SHELLVERSION EQU     <"ShellVersion">
REGSTR_VAL_MAXLIP       EQU     <"MaxLIP">
REGSTR_VAL_PRESERVECASE EQU     <"PreserveCase">
REGSTR_VAL_OPTIMIZESFN  EQU     <"OptimizeSFN">
REGSTR_VAL_NCP_BROWSEMASTER     EQU     <"BrowseMaster">
REGSTR_VAL_NCP_USEPEERBROWSING  EQU     <"Use_PeerBrowsing">
REGSTR_VAL_NCP_USESAP   EQU     <"Use_Sap">
REGSTR_VAL_VCOMM_POWER  EQU     <"EnablePowerManagement">
REGSTR_VAL_PCCARD_WAKEUP        EQU     <"EnableWakeUp">
REGSTR_VAL_DISABLE_WAKEUP       EQU     <"DisableWakeUp">
REGSTR_VAL_AUTOMOUNT    EQU     <"AutoMountDrives">
REGSTR_VAL_COMPRESSIONMETHOD    EQU     <"CompressionAlgorithm">
REGSTR_VAL_COMPRESSIONTHRESHOLD EQU     <"CompressionThreshold">
REGSTR_VAL_DOUBLEBUFFER EQU     <"DoubleBuffer">
REGSTR_VAL_FORCEPMIO    EQU     <"ForcePMIO">
REGSTR_VAL_NAMENUMERICTAIL      EQU     <"NameNumericTail">
REGSTR_VAL_READAHEADTHRESHOLD   EQU     <"ReadAheadThreshold">
REGSTR_VAL_SOFTCOMPATMODE       EQU     <"SoftCompatMode">
REGSTR_VAL_WIN31FILESYSTEM      EQU     <"Win31FileSystem">
REGSTR_VAL_ACDRIVESPINDOWN      EQU     <"ACDriveSpinDown">
REGSTR_VAL_ASYNCFILECOMMIT      EQU     <"AsyncFileCommit">
REGSTR_VAL_BATDRIVESPINDOWN     EQU     <"BatDriveSpinDown">
REGSTR_VAL_BUFFAGETIMEOUT       EQU     <"BufferAgeTimeout">
REGSTR_VAL_BUFFIDLETIMEOUT      EQU     <"BufferIdleTimeout">
REGSTR_VAL_CONTIGFILEALLOC      EQU     <"ContigFileAllocSize">
REGSTR_VAL_FLOPPYFASTBOOT       EQU     <"FloppyFastBoot">
REGSTR_VAL_DRIVESPINDOWN        EQU     <"DriveSpinDown">
REGSTR_VAL_DRIVEWRITEBEHIND     EQU     <"DriveWriteBehind">
REGSTR_VAL_FORCERMIO    EQU     <"ForceRMIO">
REGSTR_VAL_LASTBOOTPMDRVS       EQU     <"LastBootPMDrvs">
REGSTR_VAL_ACSPINDOWNPREVIOUS   EQU     <"ACSpinDownPrevious">
REGSTR_VAL_BATSPINDOWNPREVIOUS  EQU     <"BatSpinDownPrevious">
REGSTR_VAL_MAXLOADREAD  EQU     <"MaxLoadRead">
REGSTR_VAL_NAMECACHECOUNT       EQU     <"NameCache">
REGSTR_VAL_NETWAREPATHSEMANTICS EQU     <"NetwarePathSemantics">
REGSTR_VAL_NOGANGLOAD   EQU     <"NoGangLoad">
REGSTR_VAL_PATHCACHECOUNT       EQU     <"PathCache">
REGSTR_VAL_PRESERVELONGNAMES    EQU     <"PreserveLongNames">
REGSTR_VAL_SHUTDOWNSTATUS       EQU     <"ShutdownStatus">
REGSTR_VAL_SRVNAMECACHE EQU     <"ServerNameCache">
REGSTR_VAL_SRVNAMECACHECOUNT    EQU     <"ServerNameCacheMax">
REGSTR_VAL_SRVNAMECACHENETPROV  EQU     <"ServerNameCacheNumNets">
REGSTR_VAL_VIRTUALHDIRQ EQU     <"VirtualHDIRQ">
REGSTR_VAL_VOLIDLETIMEOUT       EQU     <"VolumeIdleTimeout">
REGSTR_VAL_GETDEVPARMSIOCTLAPI  EQU     <"GetDevParmsIoctl">
REGSTR_VAL_MAX_FAT32_TOTAL_SPACE        EQU     <"MaxFAT32TotalSpace">
REGSTR_VAL_MAX_FAT32_FREE_SPACE EQU     <"MaxFAT32FreeSpace">
REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE     EQU     <"DisableLowDiskSpaceBroadcast">
REGSTR_VAL_DISABLE_SCANDISK_ON_BOOT     EQU     <"DisableScandiskOnBoot">
REGSTR_VAL_WINDRIVE_LOW_DISK_SPACE      EQU     <"WindowsDriveLowDiskSpace">
REGSTR_VAL_CDCACHESIZE  EQU     <"CacheSize">
REGSTR_VAL_CDPREFETCH   EQU     <"Prefetch">
REGSTR_VAL_CDPREFETCHTAIL       EQU     <"PrefetchTail">
REGSTR_VAL_CDRAWCACHE   EQU     <"RawCache">
REGSTR_VAL_CDEXTERRORS  EQU     <"ExtendedErrors">
REGSTR_VAL_CDSVDSENSE   EQU     <"SVDSense">
REGSTR_VAL_CDSHOWVERSIONS       EQU     <"ShowVersions">
REGSTR_VAL_CDCOMPATNAMES        EQU     <"MSCDEXCompatNames">
REGSTR_VAL_CDNOREADAHEAD        EQU     <"NoReadAhead">
REGSTR_VAL_UDFCONTROLFLAG       EQU     <"ControlFlag">
REGSTR_VAL_SCSI EQU     <"SCSI\">
REGSTR_VAL_ESDI EQU     <"ESDI\">
REGSTR_VAL_FLOP EQU     <"FLOP\">
REGSTR_VAL_DISK EQU     <"GenDisk">
REGSTR_VAL_CDROM        EQU     <"GenCD">
REGSTR_VAL_TAPE EQU     <"TAPE">
REGSTR_VAL_SCANNER      EQU     <"SCANNER">
REGSTR_VAL_FLOPPY       EQU     <"FLOPPY">
REGSTR_VAL_SCSITID      EQU     <"SCSITargetID">
REGSTR_VAL_SCSILUN      EQU     <"SCSILUN">
REGSTR_VAL_REVLEVEL     EQU     <"RevisionLevel">
REGSTR_VAL_PRODUCTID    EQU     <"ProductId">
REGSTR_VAL_PRODUCTTYPE  EQU     <"ProductType">
REGSTR_VAL_DEVTYPE      EQU     <"DeviceType">
REGSTR_VAL_REMOVABLE    EQU     <"Removable">
REGSTR_VAL_CURDRVLET    EQU     <"CurrentDriveLetterAssignment">
REGSTR_VAL_USRDRVLET    EQU     <"UserDriveLetterAssignment">
REGSTR_VAL_SYNCDATAXFER EQU     <"SyncDataXfer">
REGSTR_VAL_AUTOINSNOTE  EQU     <"AutoInsertNotification">
REGSTR_VAL_AUTOINSERT_CAPABLE   EQU     <"AutoInsertNotificationCapable">
REGSTR_VAL_AUTOINSNOTE_DRIVE    EQU     <"AutoInsertNotificationDrive">
REGSTR_VAL_DISCONNECT   EQU     <"Disconnect">
REGSTR_VAL_INT13        EQU     <"Int13">
REGSTR_VAL_PMODE_INT13  EQU     <"PModeInt13">
REGSTR_VAL_USERSETTINGS EQU     <"AdapterSettings">
REGSTR_VAL_NOIDE        EQU     <"NoIDE">
REGSTR_VAL_NODMA        EQU     <"NoDMA">
REGSTR_VAL_IDE_DMA      EQU     <"IDEDMADRIVE">
REGSTR_VAL_GOOD_OEM1_DMA        EQU     <"GOODOEM1DMA">
REGSTR_VAL_DMA_IN_USE   EQU     <"DMACurrentlyUsed">
REGSTR_VAL_DMA_UNSUPPORTED      EQU     <"DMAUnsupported">
REGSTR_VAL_IDE_MASTER_DRIVE     EQU     <"IDEMaster">
REGSTR_VAL_NO_EXT_INT13 EQU     <"NoExtInt13">
ifdef NEC_98
REGSTR_VAL_IDE_PRIMARY_CHANNEL  EQU     <"IDEPrimary">
REGSTR_VAL_NO_DWORD_PIO EQU     <"No32bitPIO">
endif
REGSTR_VAL_DISKCLASSNAME        EQU     <"DiskDrive">
REGSTR_VAL_CDROMCLASSNAME       EQU     <"CDROM">
REGSTR_VAL_FORCELOAD    EQU     <"ForceLoadPD">
REGSTR_VAL_FORCEFIFO    EQU     <"ForceFIFO">
REGSTR_VAL_FORCECL      EQU     <"ForceChangeLine">
REGSTR_VAL_LEAVERM      EQU     <"LeaveRealMode">
REGSTR_VAL_FASTBOOT     EQU     <"FloppyFastBoot">
REGSTR_VAL_MAXSCAN      EQU     <"FloppyMaxScan">
REGSTR_VAL_FLOPPYENUM   EQU     <"FloppyEnumerate">
REGSTR_VAL_NOUSECLASS   EQU     <"NoUseClass">
REGSTR_VAL_NOINSTALLCLASS       EQU     <"NoInstallClass">
REGSTR_VAL_NODISPLAYCLASS       EQU     <"NoDisplayClass">
REGSTR_VAL_SILENTINSTALL        EQU     <"SilentInstall">
REGSTR_VAL_SILENTNOTIFY EQU     <"SilentInstallNotify">
REGSTR_VAL_CLASSORDER   EQU     <"ClassProcessingOrder">
REGSTR_KEY_PCMCIA_CLASS EQU     <"PCMCIA">
REGSTR_KEY_SCSI_CLASS   EQU     <"SCSIAdapter">
REGSTR_KEY_PORTS_CLASS  EQU     <"ports">
REGSTR_KEY_MEDIA_CLASS  EQU     <"MEDIA">
REGSTR_KEY_DISPLAY_CLASS        EQU     <"Display">
REGSTR_KEY_KEYBOARD_CLASS       EQU     <"Keyboard">
REGSTR_KEY_MOUSE_CLASS  EQU     <"Mouse">
REGSTR_KEY_MONITOR_CLASS        EQU     <"Monitor">
REGSTR_KEY_MODEM_CLASS  EQU     <"Modem">
REGSTR_KEY_HDC_CLASS    EQU     <"HDC">
REGSTR_KEY_DISKDRIVE_CLASS      EQU     <"DiskDrive">
REGSTR_VAL_SKIPWIZARD   EQU     <"SkipWizardForBatchSetup">
REGSTR_VAL_PCMCIA_OPT   EQU     <"Options">
PCMCIA_OPT_HAVE_SOCKET  EQU     00000001H
PCMCIA_OPT_AUTOMEM      EQU     00000004H
PCMCIA_OPT_NO_SOUND     EQU     00000008H
PCMCIA_OPT_NO_AUDIO     EQU     00000010H
PCMCIA_OPT_NO_APMREMOVE EQU     00000020H
PCMCIA_OPT_LEAVE_PWR_ON EQU     00000040H
PCMCIA_OPT_NO_MODEM_WAKE        EQU     00000100H
PCMCIA_OPT_DEVICE_WAKEUP        EQU     00000200H
REGSTR_VAL_PCMCIA_MEM   EQU     <"Memory">
PCMCIA_DEF_MEMBEGIN     EQU     000C0000H
PCMCIA_DEF_MEMEND       EQU     00FFFFFFH
PCMCIA_DEF_MEMLEN       EQU     00001000H
REGSTR_VAL_PCMCIA_ALLOC EQU     <"AllocMemWin">
REGSTR_VAL_PCMCIA_ATAD  EQU     <"ATADelay">
REGSTR_VAL_PCMCIA_CNFGD EQU     <"ConfigDelay">
REGSTR_VAL_PCMCIA_SHARE EQU     <"EnableIRQSharing">
REGSTR_VAL_PCMCIA_SIZ   EQU     <"MinRegionSize">
PCMCIA_DEF_MIN_REGION   EQU     00010000H
REGSTR_VAL_PCMCIA_TFFS  EQU     <"TFFSOption">
PCMCIA_OPT_TFFS_DEFAULT EQU     00000001H
REGSTR_VAL_P1284MDL     EQU     <"Model">
REGSTR_VAL_P1284MFG     EQU     <"Manufacturer">
ifndef NEC_98
REGSTR_VAL_ISAPNP       EQU     <"ISAPNP">
else
REGSTR_VAL_ISAPNP       EQU     <"C98PNP">
endif
REGSTR_VAL_ISAPNP_RDP_OVERRIDE  EQU     <"RDPOverRide">
REGSTR_ISAPNP_OPTIONS   EQU     <"Options">
ISAPNP_FLAG_NO_ENUM     EQU     00000001H
ISAPNP_FLAG_ALWAYS_ON   EQU     00000002H
ISAPNP_FLAG_NO_BOOT_CONFIG      EQU     00000004H
ISAPNP_FLAG_DONT_STOP   EQU     00000008H
REGSTR_VAL_PCI  EQU     <"PCI">
REGSTR_PCI_OPTIONS      EQU     <"Options">
REGSTR_VAL_BIOS_ATTRIBUTES      EQU     <"Attributes">
REGSTR_VAL_REMOVE_DOCK_ON_SUSPEND       EQU     <"RemoveDockOnSuspend">
REGSTR_PCI_DUAL_IDE     EQU     <"PCIDualIDE">
REGSTR_KEY_IDE_MINIPORTS        EQU     <"IDEMiniports">
REGSTR_KEY_IRQ_ROUTING_TABLE    EQU     <"IRQRoutingTable">
REGSTR_VAL_CURRENT_ROUTING      EQU     <"CurrentRouting">
REGSTR_KEY_IRQ_MINIPORTS        EQU     <"IRQMiniports">
REGSTR_VAL_IRQTABLESTATUS       EQU     <"IRQTableStatus">
REGSTR_VAL_IRQMINIPORTDATASTATUS        EQU     <"IRQMiniportDataStatus">
REGSTR_VAL_IRQMINIPORTSTATUS    EQU     <"IRQMINIPORTStatus">
REGSTR_VAL_IRQ_ROUTING_TABLE_PREFIX     EQU     <"IRQORT">
REGSTR_KEY_GART_MINIPORTS       EQU     <"GARTMiniports">
REGSTR_VAL_PCIDEVICE    EQU     <"PCIDevice">
PCI_DEVICE_ROOT_BUS     EQU     00000000H
PCI_DEVICE_IRQ_HOLDER   EQU     00000001H
REGSTR_VAL_MINIPORT_NAME        EQU     <"Name">
REGSTR_VAL_MINIPORT_PATH        EQU     <"Path">
REGSTR_VAL_MINIPORT_INSTANCE    EQU     <"Instance">
PCI_BIOS_BAD_ROUTING_TABLE      EQU     00000001H
PCI_BIOS_FAILS_PROTECTED_MODE_CALL      EQU     00000002H
PCI_BIOS_FAILS_REAL_MODE_CALL   EQU     00000004H
PCI_BIOS_TURN_OFF_PARITY        EQU     00000008H
PCI_OPTION_USE_BIOS     EQU     00000001H
PCI_OPTION_USE_IRQ_STEERING     EQU     00000002H
PCI_OPTION_OVERRIDE_BRIDGES     EQU     00000004H
PCI_OPTION_DONT_OVERRIDE_GAT    EQU     00000008H
PCI_OPTION_GAT_ON       EQU     00000010H
PCI_OPTION_GET_IRQ_TABLE_FROM_BIOS      EQU     00000020H
PCI_OPTION_IGNORE_PREFETCH      EQU     00000040H
PCI_OPTION_DONT_GET_IRQ_TABLE_FROM_REALMODE_BIOS        EQU     00000080H
PCI_OPTION_DONT_GET_IRQ_TABLE_FROM_SPEC_BIOS    EQU     00000100H
PCI_OPTION_CANNOT_USE_PM_INTERFACE      EQU     00000200H
PCI_OPTION_CANNOT_USE_RM_INTERFACE      EQU     00000400H
PCI_OPTION_DONT_GET_IRQ_TABLE_FROM_ACPI EQU     00000800H
PCI_IRQ_OPTIONS_MASK    EQU     (PCI_OPTION_DONT_GET_IRQ_TABLE_FROM_ACPI OR PCI_OPTION_DONT_GET_IRQ_TABLE_FROM_SPEC_BIOS OR PCI_OPTION_DONT_GET_IRQ_TABLE_FROM_REALMODE_BIOS OR PCI_OPTION_GET_IRQ_TABLE_FROM_BIOS OR PCI_OPTION_USE_IRQ_STEERING)
PCI_OPTIONS_REBOOT_MASK EQU     (PCI_IRQ_OPTIONS_MASK OR PCI_OPTION_USE_BIOS OR PCI_OPTION_OVERRIDE_BRIDGES)
PCI_FLAG_NO_VIDEO_IRQ   EQU     00000001H
PCI_FLAG_PCMCIA_WANT_IRQ        EQU     00000002H
PCI_FLAG_DUAL_IDE       EQU     00000004H
PCI_FLAG_NO_ENUM_AT_ALL EQU     00000008H
PCI_FLAG_ENUM_NO_RESOURCE       EQU     00000010H
PCI_FLAG_NEED_DWORD_ACCESS      EQU     00000020H
PCI_FLAG_SINGLE_FUNCTION        EQU     00000040H
PCI_FLAG_ALWAYS_ENABLED EQU     00000080H
PCI_FLAG_IS_IDE EQU     00000100H
PCI_FLAG_IS_VIDEO       EQU     00000200H
PCI_FLAG_FAIL_START     EQU     00000400H
PCI_FLAG_GHOST  EQU     00000800H
PCI_FLAG_DOUBLE_DECKER  EQU     00001000H
PCI_FLAG_ONE_CHILD      EQU     00002000H
PCI_FLAG_PRESERVE_COMMAND       EQU     00004000H
PCI_FLAG_IS_VGA EQU     00008000H
PCI_FLAG_CB_SHARE_CMD_BITS      EQU     00010000H
PCI_FLAG_STRAIGHT_IRQ_ROUTING   EQU     00020000H
PCI_FLAG_SUBTRACTIVE_DECODE     EQU     00040000H
PCI_FLAG_FDMA_ISA       EQU     00080000H
PCI_FLAG_EXCLUSIVE      EQU     00100000H
PCI_FLAG_EDGE   EQU     00200000H
PCI_FLAG_NO_SUBSYSTEM   EQU     00400000H
PCI_FLAG_NO_WPE EQU     00800000H
PCI_FLAG_OLD_ID EQU     01000000H
PCI_FLAG_DONT_SHRINK_BRIDGE     EQU     02000000H
PCI_FLAG_TURN_OFF_PARITY        EQU     04000000H
PCI_FLAG_NO_NON_PCI_CHILD_BAR   EQU     08000000H
PCI_FLAG_NO_ENUM_WITH_DISABLE   EQU     10000000H
PCI_FLAG_NO_PM_CAPS     EQU     20000000H
PCI_FLAG_NO_BRIDGE_RESET        EQU     40000000H
PCI_TABLE_STATUS_NOT_FOUND      EQU     00000000H
PCI_TABLE_STATUS_FAILED_SANITY_CHECK    EQU     00000001H
PCI_TABLE_STATUS_BAD_ROUTING_BIOS       EQU     00000002H
PCI_TABLE_STATUS_FAILS_PROTECTED_MODE_CALL      EQU     00000003H
PCI_TABLE_STATUS_ERROR_MAX      EQU     00000020H
PCI_TABLE_STATUS_REGISTRY       EQU     00000020H
PCI_TABLE_STATUS_MS_ROUTING_TABLE       EQU     00000021H
PCI_TABLE_STATUS_PCIBIOS        EQU     00000022H
PCI_TABLE_STATUS_REALMODE_PCIBIOS       EQU     00000023H
PCI_TABLE_STATUS_ACPI   EQU     00000024H
PCI_MINIPORTDATA_STATUS_BAD_DATA        EQU     00000000H
PCI_MINIPORTDATA_STATUS_NO_KEY  EQU     00000001H
PCI_MINIPORTDATA_STATUS_NOT_FOUND       EQU     00000002H
PCI_MINIPORTDATA_STATUS_ERROR_MAX       EQU     00000020H
PCI_MINIPORTDATA_STATUS_SUCCESS EQU     00000020H
PCI_MINIPORT_STATUS_LOAD_ERROR  EQU     00000000H
PCI_MINIPORT_STATUS_INVALID_MINIPORT    EQU     00000001H
PCI_MINIPORT_STATUS_ERROR_INITIALIZING  EQU     00000002H
PCI_MINIPORT_STATUS_ERROR_VALIDATING    EQU     00000003H
PCI_MINIPORT_STATUS_ERROR_MAX   EQU     00000020H
PCI_MINIPORT_STATUS_SUCCESS     EQU     00000020H
PCI_MINIPORT_STATUS_REGISTRY_ERROR      EQU     00000100H
PCI_MINIPORT_STATUS_ALREADY_INITIALIZED EQU     00000200H
REGSTR_VAL_USE_FDMA     EQU     <"UseFDMA">
REGSTR_VAL_CHANNEL_OPTIONS      EQU     <"ChannelOptions">
PCIIDE_CHANNELS_NONE    EQU     00H
PCIIDE_CHANNELS_PRI_ONLY        EQU     01H
PCIIDE_CHANNELS_SEC_ONLY        EQU     02H
PCIIDE_CHANNELS_PRI_SEC EQU     03H
REGSTR_VAL_BIOS EQU     <"BIOS">
REGSTR_VAL_BIOS_OPTIONS EQU     <"Options">
REGSTR_VAL_BIOS_DONT_REMOVE_PCIC        EQU     <"DontRemovePCIC">
BIOS_OPTION_NO_NVRAM    EQU     00000001H
REGSTR_KEY_CRASHES      EQU     <"Crashes">
REGSTR_KEY_DANGERS      EQU     <"Dangers">
REGSTR_KEY_DETMODVARS   EQU     <"DetModVars">
REGSTR_KEY_NDISINFO     EQU     <"NDISInfo">
REGSTR_VAL_PROTINIPATH  EQU     <"ProtIniPath">
REGSTR_VAL_RESOURCES    EQU     <"Resources">
REGSTR_VAL_CRASHFUNCS   EQU     <"CrashFuncs">
REGSTR_VAL_CLASS        EQU     <"Class">
REGSTR_VAL_DEVDESC      EQU     <"DeviceDesc">
REGSTR_VAL_BOOTCONFIG   EQU     <"BootConfig">
REGSTR_VAL_DETFUNC      EQU     <"DetFunc">
REGSTR_VAL_DETFLAGS     EQU     <"DetFlags">
REGSTR_VAL_COMPATIBLEIDS        EQU     <"CompatibleIDs">
REGSTR_VAL_DETCONFIG    EQU     <"DetConfig">
REGSTR_VAL_VERIFYKEY    EQU     <"VerifyKey">
REGSTR_VAL_COMINFO      EQU     <"ComInfo">
REGSTR_VAL_INFNAME      EQU     <"InfName">
REGSTR_VAL_CARDSPECIFIC EQU     <"CardSpecific">
REGSTR_VAL_NETOSTYPE    EQU     <"NetOSType">
REGSTR_DATA_NETOS_NDIS  EQU     <"NDIS">
REGSTR_DATA_NETOS_ODI   EQU     <"ODI">
REGSTR_DATA_NETOS_IPX   EQU     <"IPX">
REGSTR_VAL_MFG  EQU     <"Mfg">
REGSTR_VAL_DRIVERVER_STRING     EQU     <"DriverVersion">
REGSTR_VAL_DRIVERDATE_STRING    EQU     <"DriverDate">
REGSTR_VAL_DRIVERSIGNER_STRING  EQU     <"SignedBy">
REGSTR_VAL_OEMID        EQU     <"OEMID">
REGSTR_VAL_RSDPTRADDR   EQU     <"RSDPTRAddr">
REGSTR_VAL_RSDTADDR     EQU     <"RSDTAddr">
REGSTR_VAL_MATCHINGDEVID        EQU     <"MatchingDeviceId">
REGSTR_VAL_FAILREASONSTRING     EQU     <"FailReasonString">
REGSTR_VAL_FAILREASONID EQU     <"FailReasonID">
REGSTR_VAL_SCAN_ONLY_FIRST      EQU     <"ScanOnlyFirstDrive">
REGSTR_VAL_SHARE_IRQ    EQU     <"ForceIRQSharing">
REGSTR_VAL_NONSTANDARD_ATAPI    EQU     <"NonStandardATAPI">
REGSTR_VAL_IDE_FORCE_SERIALIZE  EQU     <"ForceSerialization">
REGSTR_VAL_MAX_HCID_LEN EQU     1024
REGSTR_VAL_HWREV        EQU     <"HWRevision">
REGSTR_VAL_ENABLEINTS   EQU     <"EnableInts">
REGSTR_VAL_ACPIOPTION   EQU     <"ACPIOption">
REGSTR_VAL_ACPICHECKDATE        EQU     <"ACPICheckDate">
REGDF_NOTDETIO  EQU     00000001H
REGDF_NOTDETMEM EQU     00000002H
REGDF_NOTDETIRQ EQU     00000004H
REGDF_NOTDETDMA EQU     00000008H
REGDF_NOTDETALL EQU     (REGDF_NOTDETIO OR REGDF_NOTDETMEM OR REGDF_NOTDETIRQ OR REGDF_NOTDETDMA)
REGDF_NEEDFULLCONFIG    EQU     00000010H
REGDF_GENFORCEDCONFIG   EQU     00000020H
REGDF_TOPLEVEL_BUS      EQU     00000040H
REGDF_NODETCONFIG       EQU     00008000H
REGDF_CONFLICTIO        EQU     00010000H
REGDF_CONFLICTMEM       EQU     00020000H
REGDF_CONFLICTIRQ       EQU     00040000H
REGDF_CONFLICTDMA       EQU     00080000H
REGDF_CONFLICTALL       EQU     (REGDF_CONFLICTIO OR REGDF_CONFLICTMEM OR REGDF_CONFLICTIRQ OR REGDF_CONFLICTDMA)
REGDF_MAPIRQ2TO9        EQU     00100000H
REGDF_NOTVERIFIED       EQU     80000000H
REGSTR_VAL_UNIQUE_ID    EQU     <"UniqueID">
REGSTR_VAL_APMBIOSVER   EQU     <"APMBiosVer">
REGSTR_VAL_APMFLAGS     EQU     <"APMFlags">
REGSTR_VAL_SLSUPPORT    EQU     <"SLSupport">
REGSTR_VAL_MACHINETYPE  EQU     <"MachineType">
REGSTR_VAL_SETUPMACHINETYPE     EQU     <"SetupMachineType">
REGSTR_MACHTYPE_UNKNOWN EQU     <"Unknown">
REGSTR_MACHTYPE_IBMPC   EQU     <"IBM PC">
REGSTR_MACHTYPE_IBMPCJR EQU     <"IBM PCjr">
REGSTR_MACHTYPE_IBMPCCONV       EQU     <"IBM PC Convertible">
REGSTR_MACHTYPE_IBMPCXT EQU     <"IBM PC/XT">
REGSTR_MACHTYPE_IBMPCXT_286     EQU     <"IBM PC/XT 286">
REGSTR_MACHTYPE_IBMPCAT EQU     <"IBM PC/AT">
REGSTR_MACHTYPE_IBMPS2_25       EQU     <"IBM PS/2-25">
REGSTR_MACHTYPE_IBMPS2_30_286   EQU     <"IBM PS/2-30 286">
REGSTR_MACHTYPE_IBMPS2_30       EQU     <"IBM PS/2-30">
REGSTR_MACHTYPE_IBMPS2_50       EQU     <"IBM PS/2-50">
REGSTR_MACHTYPE_IBMPS2_50Z      EQU     <"IBM PS/2-50Z">
REGSTR_MACHTYPE_IBMPS2_55SX     EQU     <"IBM PS/2-55SX">
REGSTR_MACHTYPE_IBMPS2_60       EQU     <"IBM PS/2-60">
REGSTR_MACHTYPE_IBMPS2_65SX     EQU     <"IBM PS/2-65SX">
REGSTR_MACHTYPE_IBMPS2_70       EQU     <"IBM PS/2-70">
REGSTR_MACHTYPE_IBMPS2_P70      EQU     <"IBM PS/2-P70">
REGSTR_MACHTYPE_IBMPS2_70_80    EQU     <"IBM PS/2-70/80">
REGSTR_MACHTYPE_IBMPS2_80       EQU     <"IBM PS/2-80">
REGSTR_MACHTYPE_IBMPS2_90       EQU     <"IBM PS/2-90">
REGSTR_MACHTYPE_IBMPS1  EQU     <"IBM PS/1">
REGSTR_MACHTYPE_PHOENIX_PCAT    EQU     <"Phoenix PC/AT Compatible">
REGSTR_MACHTYPE_HP_VECTRA       EQU     <"HP Vectra">
REGSTR_MACHTYPE_ATT_PC  EQU     <"AT&T PC">
REGSTR_MACHTYPE_ZENITH_PC       EQU     <"Zenith PC">
REGSTR_VAL_APMMENUSUSPEND       EQU     <"APMMenuSuspend">
APMMENUSUSPEND_DISABLED EQU     0
APMMENUSUSPEND_ENABLED  EQU     1
APMMENUSUSPEND_UNDOCKED EQU     2
APMMENUSUSPEND_NOCHANGE EQU     80H
REGSTR_VAL_APMACTIMEOUT EQU     <"APMACTimeout">
REGSTR_VAL_APMBATTIMEOUT        EQU     <"APMBatTimeout">
APMTIMEOUT_DISABLED     EQU     0
REGSTR_VAL_APMSHUTDOWNPOWER     EQU     <"APMShutDownPower">
REGSTR_VAL_BUSTYPE      EQU     <"BusType">
REGSTR_VAL_CPU  EQU     <"CPU">
REGSTR_VAL_NDP  EQU     <"NDP">
REGSTR_VAL_PNPBIOSVER   EQU     <"PnPBIOSVer">
REGSTR_VAL_PNPSTRUCOFFSET       EQU     <"PnPStrucOffset">
REGSTR_VAL_PCIBIOSVER   EQU     <"PCIBIOSVer">
REGSTR_VAL_HWMECHANISM  EQU     <"HWMechanism">
REGSTR_VAL_LASTPCIBUSNUM        EQU     <"LastPCIBusNum">
REGSTR_VAL_CONVMEM      EQU     <"ConvMem">
REGSTR_VAL_EXTMEM       EQU     <"ExtMem">
REGSTR_VAL_COMPUTERNAME EQU     <"ComputerName">
REGSTR_VAL_BIOSNAME     EQU     <"BIOSName">
REGSTR_VAL_BIOSVERSION  EQU     <"BIOSVersion">
REGSTR_VAL_BIOSDATE     EQU     <"BIOSDate">
REGSTR_VAL_MODEL        EQU     <"Model">
REGSTR_VAL_SUBMODEL     EQU     <"Submodel">
REGSTR_VAL_REVISION     EQU     <"Revision">
REGSTR_VAL_FIFODEPTH    EQU     <"FIFODepth">
REGSTR_VAL_RDINTTHRESHOLD       EQU     <"RDIntThreshold">
REGSTR_VAL_WRINTTHRESHOLD       EQU     <"WRIntThreshold">
REGSTR_VAL_PRIORITY     EQU     <"Priority">
REGSTR_VAL_DRIVER       EQU     <"Driver">
REGSTR_VAL_FUNCDESC     EQU     <"FunctionDesc">
REGSTR_VAL_FORCEDCONFIG EQU     <"ForcedConfig">
REGSTR_VAL_CONFIGFLAGS  EQU     <"ConfigFlags">
REGSTR_VAL_CSCONFIGFLAGS        EQU     <"CSConfigFlags">
REGSTR_VAL_DEVICEVXDS   EQU     <"DeviceVxDs">
REGSTR_KEY_BINDINGS     EQU     <"Bindings">
REGSTR_VAL_PORTDRIVER   EQU     <"PortDriver">
REGSTR_VAL_USERCHANGEDDRV       EQU     <"UserChangedDriver">
REGSTR_VAL_CLASSGUID    EQU     <"ClassGUID">
REGSTR_VAL_PARENT_UNIQUE_ID     EQU     <"ParentUniqueID">
REGSTR_VAL_CONFIGMG_UNIQUE_ID   EQU     <"ConfigMGUniqueID">
REGSTR_VAL_UPPER_FILTERS        EQU     <"UpperFilters">
REGSTR_VAL_LOWER_FILTERS        EQU     <"LowerFilters">
REGSTR_VAL_PRELOAD      EQU     <"PreloadDrivers">
REGSTR_VAL_NTDEVICEPATHS        EQU     <"NTDevicePaths">
REGSTR_VAL_SERVICE      EQU     <"Service">
REGSTR_VAL_CONFIGURATION        EQU     <"Configuration">
REGSTR_VAL_CONFIGURATIONVECTOR  EQU     <"ConfigurationVector">
REGSTR_VAL_LOCATIONINFORMATION  EQU     <"LocationInformation">
REGSTR_VAL_DEVICEOBJECTNAME     EQU     <"DeviceObjectName">
REGSTR_VAL_CAPABILITIES EQU     <"Capabilities">
REGSTR_VAL_UINUMBER     EQU     <"UINumber">
REGSTR_VAL_POWERENABLE  EQU     <"PowerEnable">
REGSTR_VAL_DISABLEHIBERNATE     EQU     <"DisHiber">
CONFIGFLAG_DISABLED     EQU     00000001H
CONFIGFLAG_REMOVED      EQU     00000002H
CONFIGFLAG_MANUAL_INSTALL       EQU     00000004H
CONFIGFLAG_IGNORE_BOOT_LC       EQU     00000008H
CONFIGFLAG_NET_BOOT     EQU     00000010H
CONFIGFLAG_REINSTALL    EQU     00000020H
CONFIGFLAG_FAILEDINSTALL        EQU     00000040H
CONFIGFLAG_CANTSTOPACHILD       EQU     00000080H
CONFIGFLAG_NOREMOVEEXIT EQU     00000200H
CONFIGFLAG_CANGOAWAY    EQU     00000400H
CONFIGFLAG_MANUAL_DRIVER        EQU     00000800H
CONFIGFLAG_NOUPDATECANGOAWAY    EQU     00001000H
CONFIGFLAG_NOBROADCAST  EQU     00004000H
CONFIGFLAG_NOPOWERMGMT  EQU     00008000H
CONFIGFLAG_NOWAKEUP     EQU     00010000H
CONFIGFLAG_USING_COMPAT_ID      EQU     00020000H
CSCONFIGFLAG_BITS       EQU     0000000FH
CSCONFIGFLAG_DISABLED   EQU     00000001H
CSCONFIGFLAG_DO_NOT_CREATE      EQU     00000002H
CSCONFIGFLAG_DO_NOT_START       EQU     00000004H
CSCONFIGFLAG_DO_NOT_SHOW_IN_DM  EQU     00000008H
DMSTATEFLAG_APPLYTOALL  EQU     00000001H
REGSTR_VAL_ROOT_DEVNODE EQU     <"HTREE\ROOT\0">
REGSTR_VAL_RESERVED_DEVNODE     EQU     <"HTREE\RESERVED\0">
REGSTR_PATH_READDATAPORT        EQU     <REGSTR_KEY_ISAENUM"\\ReadDataPort\\0">
REGSTR_PATH_PCIIRQHOLDER        EQU     <REGSTR_KEY_PCIENUM"\\IRQHolder\\">
REGSTR_PATH_ACPIIRQHOLDER       EQU     <REGSTR_KEY_ACPIENUM"\\*PNP0C0F\\">
REGSTR_PATH_MULTI_FUNCTION      EQU     <"MF">
REGSTR_VAL_RESOURCE_MAP EQU     <"ResourceMap">
REGSTR_VAL_VARYING_RESOURCE_MAP EQU     <"VaryingResourceMap">
REGSTR_PATH_CHILD_PREFIX        EQU     <"Child">
REGSTR_PATH_SUBCHILD_PREFIX     EQU     <"SubChild">
NUM_RESOURCE_MAP        EQU     256
REGSTR_VAL_MF_FLAGS     EQU     <"MFFlags">
MF_FLAGS_EVEN_IF_NO_RESOURCE    EQU     00000001H
MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       EQU     00000002H
MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       EQU     00000004H
MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    EQU     00000008H
MF_FLAGS_ADD_VRM_EVEN_IF_NO_RESOURCE    EQU     00000010H
MF_FLAGS_NO_FILL_IN_UNKNOWN_VRM EQU     00000020H
ifndef NEC_98
REGSTR_VAL_EISA_RANGES  EQU     <"EISARanges">
REGSTR_VAL_EISA_FUNCTIONS       EQU     <"EISAFunctions">
REGSTR_VAL_EISA_FUNCTIONS_MASK  EQU     <"EISAFunctionsMask">
REGSTR_VAL_EISA_FLAGS   EQU     <"EISAFlags">
REGSTR_VAL_EISA_SIMULATE_INT15  EQU     <"EISASimulateInt15">
else
REGSTR_VAL_EISA_RANGES  EQU     <"NESARanges">
REGSTR_VAL_EISA_FUNCTIONS       EQU     <"NESAFunctions">
REGSTR_VAL_EISA_FUNCTIONS_MASK  EQU     <"NESAFunctionsMask">
REGSTR_VAL_EISA_FLAGS   EQU     <"NESAFlags">
REGSTR_VAL_EISA_SIMULATE_INT15  EQU     <"NESASimulateInt15">
endif
EISAFLAG_NO_IO_MERGE    EQU     00000001H
EISAFLAG_SLOT_IO_FIRST  EQU     00000002H
EISA_NO_MAX_FUNCTION    EQU     0FFH
NUM_EISA_RANGES EQU     4
REGSTR_VAL_DRVDESC      EQU     <"DriverDesc">
REGSTR_VAL_DEVLOADER    EQU     <"DevLoader">
REGSTR_VAL_STATICVXD    EQU     <"StaticVxD">
REGSTR_VAL_PROPERTIES   EQU     <"Properties">
REGSTR_VAL_MANUFACTURER EQU     <"Manufacturer">
REGSTR_VAL_EXISTS       EQU     <"Exists">
REGSTR_VAL_CMENUMFLAGS  EQU     <"CMEnumFlags">
REGSTR_VAL_CMDRIVFLAGS  EQU     <"CMDrivFlags">
REGSTR_VAL_ENUMERATOR   EQU     <"Enumerator">
REGSTR_VAL_DEVICEDRIVER EQU     <"DeviceDriver">
REGSTR_VAL_PORTNAME     EQU     <"PortName">
REGSTR_VAL_INFPATH      EQU     <"InfPath">
REGSTR_VAL_INFSECTION   EQU     <"InfSection">
REGSTR_VAL_POLLING      EQU     <"Polling">
REGSTR_VAL_DONTLOADIFCONFLICT   EQU     <"DontLoadIfConflict">
REGSTR_VAL_PORTSUBCLASS EQU     <"PortSubClass">
REGSTR_VAL_NETCLEAN     EQU     <"NetClean">
REGSTR_VAL_IDE_NO_SERIALIZE     EQU     <"IDENoSerialize">
REGSTR_VAL_NOCMOSORFDPT EQU     <"NoCMOSorFDPT">
REGSTR_VAL_CD_MSN       EQU     <"TurnOnCDMsn">
REGSTR_VAL_COMVERIFYBASE        EQU     <"COMVerifyBase">
REGSTR_VAL_CERTIFICATE_FILE     EQU     <"CertificationFile">
REGSTR_VAL_LINK EQU     <"Link">
REGSTR_VAL_REINSTALLCLASS       EQU     <"ReinstallClass">
REGSTR_KEY_OVERRIDE     EQU     <"Override">
REGSTR_VAL_CONFIGMG     EQU     <"CONFIGMG">
REGSTR_VAL_SYSDM        EQU     <"SysDM">
REGSTR_VAL_PRIVATE      EQU     <"Private">
REGSTR_VAL_DETECT       EQU     <"Detect">
REGSTR_VAL_ASKFORCONFIG EQU     <"AskForConfig">
REGSTR_VAL_WAITFORUNDOCK        EQU     <"WaitForUndock">
REGSTR_VAL_REMOVEROMOKAY        EQU     <"RemoveRomOkay">
REGSTR_VAL_ADD_FUNC     EQU     <"Func">
REGSTR_VAL_DONTSHAREISAIRQS     EQU     <"DontShareISAIRQs">
REGSTR_VAL_DONTFORCED3ONROOTDEVICES     EQU     <"NoForcedD3">
REGSTR_VAL_CURCONFIG    EQU     <"CurrentConfig">
REGSTR_VAL_FRIENDLYNAME EQU     <"FriendlyName">
REGSTR_VAL_CURRENTCONFIG        EQU     <"CurrentConfig">
REGSTR_VAL_MAP  EQU     <"Map">
REGSTR_VAL_ID   EQU     <"CurrentID">
REGSTR_VAL_DOCKED       EQU     <"CurrentDockedState">
REGSTR_VAL_CHECKSUM     EQU     <"CurrentChecksum">
REGSTR_VAL_HWDETECT     EQU     <"HardwareDetect">
REGSTR_VAL_INHIBITRESULTS       EQU     <"InhibitResults">
REGSTR_VAL_PROFILEFLAGS EQU     <"ProfileFlags">
REGSTR_KEY_PCMCIA       EQU     <"PCMCIA\">
REGSTR_KEY_PCUNKNOWN    EQU     <"UNKNOWN_MANUFACTURER">
REGSTR_KEY_PCMDEV       EQU     <"-DEV">
REGSTR_VAL_PCSSDRIVER   EQU     <"Driver">
REGSTR_KEY_PCMTD        EQU     <"MTD-">
REGSTR_VAL_PCMTDRIVER   EQU     <"MTD">
REGSTR_VAL_HARDWAREID   EQU     <"HardwareID">
REGSTR_VAL_HARDWARE_LOCATION    EQU     <"Location">
REGSTR_VAL_INSTALLER    EQU     <"Installer">
REGSTR_VAL_INSICON      EQU     <"Icon">
REGSTR_VAL_ENUMPROPPAGES        EQU     <"EnumPropPages">
REGSTR_VAL_BASICPROPERTIES      EQU     <"BasicProperties">
REGSTR_VAL_PRIVATEPROBLEM       EQU     <"PrivateProblem">
REGSTR_VAL_ENUMDRVSTACK EQU     <"EnumDriverStack">
REGSTR_KEY_CURRENT      EQU     <"Current">
REGSTR_KEY_DEFAULT      EQU     <"Default">
REGSTR_KEY_MODES        EQU     <"Modes">
REGSTR_KEY_INFO EQU     <"Info">
REGSTR_VAL_MODE EQU     <"Mode">
REGSTR_VAL_BPP  EQU     <"BPP">
REGSTR_VAL_HRES EQU     <"HRes">
REGSTR_VAL_VRES EQU     <"VRes">
REGSTR_VAL_FONTSIZE     EQU     <"FontSize">
REGSTR_VAL_DRV  EQU     <"drv">
REGSTR_VAL_GRB  EQU     <"grb">
REGSTR_VAL_VDD  EQU     <"vdd">
REGSTR_VAL_VER  EQU     <"Ver">
REGSTR_VAL_MAXRES       EQU     <"MaxResolution">
REGSTR_VAL_DPMS EQU     <"DPMS">
REGSTR_VAL_RESUMERESET  EQU     <"ResumeReset">
REGSTR_VAL_MINIVDD      EQU     <"minivdd">
REGSTR_VAL_DESCRIPTION  EQU     <"Description">
REGSTR_KEY_SYSTEM       EQU     <"System">
REGSTR_KEY_USER EQU     <"User">
REGSTR_VAL_DPI  EQU     <"dpi">
REGSTR_VAL_PCICOPTIONS  EQU     <"PCICOptions">
REGSTR_VAL_PCICFLAGS    EQU     <"PCICFlags">
PCICFLAGS_TRUST_VSPINS  EQU     00000001H
PCICFLAGS_CL_RESET_BFS  EQU     00000002H
REGSTR_VAL_PCIC_EXCASAVE        EQU     <"PCICEXCAContextRanges">
REGSTR_VAL_PCIC_CLEXTSAVE       EQU     <"PCICCLExtContextRanges">
ifndef NEC_98
PCIC_DEFAULT_IRQMASK    EQU     4EB8H
else
PCIC_DEFAULT_IRQMASK    EQU     1468H
endif
PCIC_DEFAULT_NUMSOCKETS EQU     0
REGSTR_VAL_PCICIRQMAP   EQU     <"PCICIRQMap">
REGSTR_VAL_CBSSOPTIONS  EQU     <"CBSSOptions">
REGSTR_VAL_CBSSIRQMAP   EQU     <"CBSSIRQMap">
REGSTR_VAL_CBSSFLAGS    EQU     <"CBSSFlags">
REGSTR_VAL_CBSS_COMPATID        EQU     <"CBSSCompatID">
REGSTR_VAL_CBSS_ISAIRQS EQU     <"CBSSISAIRQs">
REGSTR_VAL_CBSS_VENDOR_CTXT     EQU     <"CBSSVendorContext">
REGSTR_VAL_CBSS_DEVINIT EQU     <"CBSSDevInit">
REGSTR_VAL_CBSS_ZVENABLE        EQU     <"CBSSZVEnable">
REGSTR_VAL_CBSS_ZVDISABLE       EQU     <"CBSSZVDisable">
REGSTR_VAL_CBSS_ZVCAPABLE       EQU     <"CBSSZVCapable">
REGSTR_PATH_APPEARANCE  EQU     <"Control Panel\Appearance">
REGSTR_PATH_LOOKSCHEMES EQU     <"Control Panel\Appearance\Schemes">
REGSTR_VAL_CUSTOMCOLORS EQU     <"CustomColors">
REGSTR_PATH_SCREENSAVE  EQU     <"Control Panel\Desktop">
REGSTR_VALUE_USESCRPASSWORD     EQU     <"ScreenSaveUsePassword">
REGSTR_VALUE_SCRPASSWORD        EQU     <"ScreenSave_Data">
REGSTR_VALUE_LOWPOWERTIMEOUT    EQU     <"ScreenSaveLowPowerTimeout">
REGSTR_VALUE_POWEROFFTIMEOUT    EQU     <"ScreenSavePowerOffTimeout">
REGSTR_VALUE_LOWPOWERACTIVE     EQU     <"ScreenSaveLowPowerActive">
REGSTR_VALUE_POWEROFFACTIVE     EQU     <"ScreenSavePowerOffActive">
REGSTR_PATH_WINDOWSAPPLETS      EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets">
REGSTR_PATH_SYSTRAY     EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\SysTray">
REGSTR_VAL_SYSTRAYSVCS  EQU     <"Services">
REGSTR_VAL_SYSTRAYBATFLAGS      EQU     <"PowerFlags">
REGSTR_VAL_SYSTRAYPCCARDFLAGS   EQU     <"PCMCIAFlags">
REGSTR_PATH_3MODE       EQU     <"System\CurrentControlSet\Control\3mode">
REGSTR_VAL_3MODE        EQU     <"3modeDrv">
REGSTR_PATH_NETWORK_USERSETTINGS        EQU     <"Network">
REGSTR_KEY_NETWORK_PERSISTENT   EQU     <"\Persistent">
REGSTR_KEY_NETWORK_RECENT       EQU     <"\Recent">
REGSTR_VAL_REMOTE_PATH  EQU     <"RemotePath">
REGSTR_VAL_USER_NAME    EQU     <"UserName">
REGSTR_VAL_PROVIDER_NAME        EQU     <"ProviderName">
REGSTR_VAL_CONNECTION_TYPE      EQU     <"ConnectionType">
REGSTR_VAL_UPGRADE      EQU     <"Upgrade">
REGSTR_KEY_LOGON        EQU     <"\Logon">
REGSTR_VAL_MUSTBEVALIDATED      EQU     <"MustBeValidated">
REGSTR_VAL_RUNLOGINSCRIPT       EQU     <"ProcessLoginScript">
REGSTR_KEY_NETWORKPROVIDER      EQU     <"\NetworkProvider">
REGSTR_PATH_NW32NETPROVIDER     EQU     <REGSTR_PATH_SERVICES"\\NWNP32"REGSTR_KEY_NETWORKPROVIDER>
REGSTR_PATH_MS32NETPROVIDER     EQU     <REGSTR_PATH_SERVICES"\\MSNP32"REGSTR_KEY_NETWORKPROVIDER>
REGSTR_VAL_AUTHENT_AGENT        EQU     <"AuthenticatingAgent">
REGSTR_VAL_PREFREDIR    EQU     <"PreferredRedir">
REGSTR_VAL_AUTOSTART    EQU     <"AutoStart">
REGSTR_VAL_AUTOLOGON    EQU     <"AutoLogon">
REGSTR_VAL_OLDAUTOLOGON EQU     <"OldAutoLogon">
REGSTR_VAL_SETBYSETUP   EQU     <"SetBySetup">
REGSTR_VAL_NETCARD      EQU     <"Netcard">
REGSTR_VAL_TRANSPORT    EQU     <"Transport">
REGSTR_VAL_DYNAMIC      EQU     <"Dynamic">
REGSTR_VAL_TRANSITION   EQU     <"Transition">
REGSTR_VAL_STATICDRIVE  EQU     <"StaticDrive">
REGSTR_VAL_LOADHI       EQU     <"LoadHi">
REGSTR_VAL_LOADRMDRIVERS        EQU     <"LoadRMDrivers">
REGSTR_VAL_SETUPN       EQU     <"SetupN">
REGSTR_VAL_SETUPNPATH   EQU     <"SetupNPath">
REGSTR_VAL_WRKGRP_FORCEMAPPING  EQU     <"WrkgrpForceMapping">
REGSTR_VAL_WRKGRP_REQUIRED      EQU     <"WrkgrpRequired">
REGSTR_PATH_CURRENT_CONTROL_SET EQU     <"System\CurrentControlSet\Control">
REGSTR_VAL_CURRENT_USER EQU     <"Current User">
REGSTR_PATH_PWDPROVIDER EQU     <"System\CurrentControlSet\Control\PwdProvider">
REGSTR_VAL_PWDPROVIDER_PATH     EQU     <"ProviderPath">
REGSTR_VAL_PWDPROVIDER_DESC     EQU     <"Description">
REGSTR_VAL_PWDPROVIDER_CHANGEPWD        EQU     <"ChangePassword">
REGSTR_VAL_PWDPROVIDER_CHANGEPWDHWND    EQU     <"ChangePasswordHwnd">
REGSTR_VAL_PWDPROVIDER_GETPWDSTATUS     EQU     <"GetPasswordStatus">
REGSTR_VAL_PWDPROVIDER_ISNP     EQU     <"NetworkProvider">
REGSTR_VAL_PWDPROVIDER_CHANGEORDER      EQU     <"ChangeOrder">
REGSTR_PATH_POLICIES    EQU     <"Software\Microsoft\Windows\CurrentVersion\Policies">
REGSTR_PATH_UPDATE      EQU     <"System\CurrentControlSet\Control\Update">
REGSTR_VALUE_ENABLE     EQU     <"Enable">
REGSTR_VALUE_VERBOSE    EQU     <"Verbose">
REGSTR_VALUE_NETPATH    EQU     <"NetworkPath">
REGSTR_VALUE_DEFAULTLOC EQU     <"UseDefaultNetLocation">
REGSTR_KEY_NETWORK      EQU     <"Network">
REGSTR_KEY_SYSTEM       EQU     <"System">
REGSTR_KEY_PRINTERS     EQU     <"Printers">
REGSTR_KEY_WINOLDAPP    EQU     <"WinOldApp">
REGSTR_VAL_NOFILESHARING        EQU     <"NoFileSharing">
REGSTR_VAL_NOPRINTSHARING       EQU     <"NoPrintSharing">
REGSTR_VAL_NOFILESHARINGCTRL    EQU     <"NoFileSharingControl">
REGSTR_VAL_NOPRINTSHARINGCTRL   EQU     <"NoPrintSharingControl">
REGSTR_VAL_HIDESHAREPWDS        EQU     <"HideSharePwds">
REGSTR_VAL_DISABLEPWDCACHING    EQU     <"DisablePwdCaching">
REGSTR_VAL_ALPHANUMPWDS EQU     <"AlphanumPwds">
REGSTR_VAL_NETSETUP_DISABLE     EQU     <"NoNetSetup">
REGSTR_VAL_NETSETUP_NOCONFIGPAGE        EQU     <"NoNetSetupConfigPage">
REGSTR_VAL_NETSETUP_NOIDPAGE    EQU     <"NoNetSetupIDPage">
REGSTR_VAL_NETSETUP_NOSECURITYPAGE      EQU     <"NoNetSetupSecurityPage">
REGSTR_VAL_SYSTEMCPL_NOVIRTMEMPAGE      EQU     <"NoVirtMemPage">
REGSTR_VAL_SYSTEMCPL_NODEVMGRPAGE       EQU     <"NoDevMgrPage">
REGSTR_VAL_SYSTEMCPL_NOCONFIGPAGE       EQU     <"NoConfigPage">
REGSTR_VAL_SYSTEMCPL_NOFILESYSPAGE      EQU     <"NoFileSysPage">
REGSTR_VAL_DISPCPL_NODISPCPL    EQU     <"NoDispCPL">
REGSTR_VAL_DISPCPL_NOBACKGROUNDPAGE     EQU     <"NoDispBackgroundPage">
REGSTR_VAL_DISPCPL_NOSCRSAVPAGE EQU     <"NoDispScrSavPage">
REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE     EQU     <"NoDispAppearancePage">
REGSTR_VAL_DISPCPL_NOSETTINGSPAGE       EQU     <"NoDispSettingsPage">
REGSTR_VAL_SECCPL_NOSECCPL      EQU     <"NoSecCPL">
REGSTR_VAL_SECCPL_NOPWDPAGE     EQU     <"NoPwdPage">
REGSTR_VAL_SECCPL_NOADMINPAGE   EQU     <"NoAdminPage">
REGSTR_VAL_SECCPL_NOPROFILEPAGE EQU     <"NoProfilePage">
REGSTR_VAL_PRINTERS_HIDETABS    EQU     <"NoPrinterTabs">
REGSTR_VAL_PRINTERS_NODELETE    EQU     <"NoDeletePrinter">
REGSTR_VAL_PRINTERS_NOADD       EQU     <"NoAddPrinter">
REGSTR_VAL_WINOLDAPP_DISABLED   EQU     <"Disabled">
REGSTR_VAL_WINOLDAPP_NOREALMODE EQU     <"NoRealMode">
REGSTR_VAL_NOENTIRENETWORK      EQU     <"NoEntireNetwork">
REGSTR_VAL_NOWORKGROUPCONTENTS  EQU     <"NoWorkgroupContents">
REGSTR_VAL_NO_CLEARTEXT_NET_PWD EQU     <"NoClearTextNetPassword">
REGSTR_VAL_MINPWDLEN    EQU     <"MinPwdLen">
REGSTR_VAL_PWDEXPIRATION        EQU     <"PwdExpiration">
REGSTR_VAL_WIN31PROVIDER        EQU     <"Win31Provider">
REGSTR_VAL_DISABLEREGTOOLS      EQU     <"DisableRegistryTools">
REGSTR_VAL_DEVICEMANAGER        EQU     <"sysdm.cpl">
REGSTR_PATH_SYSDM       EQU     <"Software\Microsoft\Windows\CurrentVersion\SysDM">
REGSTR_VAL_REBOOTFLAGS  EQU     <"RebootFlags">
REGSTR_VAL_SEARCHFLAGS  EQU     <"SearchFlags">
REGSTR_VAL_SEARCHLOCATION       EQU     <"SearchLocation">
BY_TYPE EQU     0
BY_CONNECTION   EQU     1
REGSTR_PATH_WINLOGON    EQU     <"Software\Microsoft\Windows\CurrentVersion\Winlogon">
REGSTR_VAL_LEGALNOTICECAPTION   EQU     <"LegalNoticeCaption">
REGSTR_VAL_LEGALNOTICETEXT      EQU     <"LegalNoticeText">
REGSTR_VAL_DRIVE_SPINDOWN       EQU     <"NoDispSpinDown">
REGSTR_VAL_RESTRICTRUN  EQU     <"RestrictRun">
REGSTR_KEY_POL_USERS    EQU     <"Users">
REGSTR_KEY_POL_COMPUTERS        EQU     <"Computers">
REGSTR_KEY_POL_USERGROUPS       EQU     <"UserGroups">
REGSTR_KEY_POL_DEFAULT  EQU     <".default">
REGSTR_KEY_POL_USERGROUPDATA    EQU     <"GroupData\UserGroups\Priority">
REGSTR_PATH_TIMEZONE    EQU     <"System\CurrentControlSet\Control\TimeZoneInformation">
REGSTR_VAL_TZBIAS       EQU     <"Bias">
REGSTR_VAL_TZDLTBIAS    EQU     <"DaylightBias">
REGSTR_VAL_TZSTDBIAS    EQU     <"StandardBias">
REGSTR_VAL_TZACTBIAS    EQU     <"ActiveTimeBias">
REGSTR_VAL_TZDLTFLAG    EQU     <"DaylightFlag">
REGSTR_VAL_TZSTDSTART   EQU     <"StandardStart">
REGSTR_VAL_TZDLTSTART   EQU     <"DaylightStart">
REGSTR_VAL_TZDLTNAME    EQU     <"DaylightName">
REGSTR_VAL_TZSTDNAME    EQU     <"StandardName">
REGSTR_VAL_TZNOCHANGESTART      EQU     <"NoChangeStart">
REGSTR_VAL_TZNOCHANGEEND        EQU     <"NoChangeEnd">
REGSTR_VAL_TZNOAUTOTIME EQU     <"DisableAutoDaylightTimeSet">
REGSTR_PATH_FLOATINGPOINTPROCESSOR      EQU     <"HARDWARE\DESCRIPTION\System\FloatingPointProcessor">
REGSTR_PATH_FLOATINGPOINTPROCESSOR0     EQU     <"HARDWARE\DESCRIPTION\System\FloatingPointProcessor\0">
REGSTR_PATH_COMPUTRNAME EQU     <"System\CurrentControlSet\Control\ComputerName\ComputerName">
REGSTR_VAL_COMPUTRNAME  EQU     <"ComputerName">
REGSTR_PATH_SHUTDOWN    EQU     <"System\CurrentControlSet\Control\Shutdown">
REGSTR_VAL_FORCEREBOOT  EQU     <"ForceReboot">
REGSTR_VAL_SETUPPROGRAMRAN      EQU     <"SetupProgramRan">
REGSTR_VAL_DOES_POLLING EQU     <"PollingSupportNeeded">
REGSTR_VAL_FAST_REBOOT  EQU     <"FastReboot">
REGSTR_PATH_KNOWNDLLS   EQU     <"System\CurrentControlSet\Control\SessionManager\KnownDLLs">
REGSTR_PATH_KNOWN16DLLS EQU     <"System\CurrentControlSet\Control\SessionManager\Known16DLLs">
REGSTR_PATH_CHECKVERDLLS        EQU     <"System\CurrentControlSet\Control\SessionManager\CheckVerDLLs">
REGSTR_PATH_WARNVERDLLS EQU     <"System\CurrentControlSet\Control\SessionManager\WarnVerDLLs">
REGSTR_PATH_HACKINIFILE EQU     <"System\CurrentControlSet\Control\SessionManager\HackIniFiles">
REGSTR_PATH_CHECKBADAPPS        EQU     <"System\CurrentControlSet\Control\SessionManager\CheckBadApps">
REGSTR_PATH_CHECKBADAPPS400     EQU     <"System\CurrentControlSet\Control\SessionManager\CheckBadApps400">
REGSTR_PATH_APPPATCH    EQU     <"System\CurrentControlSet\Control\SessionManager\AppPatches">
REGSTR_PATH_KNOWNVXDS   EQU     <"System\CurrentControlSet\Control\SessionManager\KnownVxDs">
REGSTR_PATH_GLOBAL_ENV  EQU     <"System\CurrentControlSet\Control\SessionManager\Environment">
REGSTR_VAL_GLOBAL_ENV_ACT       EQU     <"EnvAction">
REGSTR_VAL_GLOBAL_ENV_ACT_NOP   EQU     00000000H
REGSTR_VAL_GLOBAL_ENV_ACT_IMP   EQU     00000001H
REGSTR_VAL_GLOBAL_ENV_ACT_EXP   EQU     00000002H
REGSTR_VAL_GLOBAL_ENV_ACT_SYNC  EQU     00000003H
REGSTR_VAL_GLOBAL_ENV_ACT_RECON EQU     00000004H
REGSTR_VAL_GLOBAL_ENV_ACT_DEL   EQU     00000005H
REGSTR_VAL_REG_ENV_CRC  EQU     <"RegEnvCRC">
REGSTR_VAL_REG_ENV_SIZE EQU     <"RegEnvSize">
REGSTR_VAL_CONFIG_ENV_CRC       EQU     <"ConfigEnvCRC">
REGSTR_VAL_CONFIG_ENV_SIZE      EQU     <"ConfigEnvSize">
REGSTR_VAL_CONFIG_ENV_MOD       EQU     <"ConfigEnvMod">
REGSTR_VAL_AUTOEXEC_ENV_CRC     EQU     <"AutoexecEnvCRC">
REGSTR_VAL_AUTOEXEC_ENV_SIZE    EQU     <"AutoexecEnvSize">
REGSTR_VAL_AUTOEXEC_ENV_MOD     EQU     <"AutoexecEnvMod">
REGSTR_VAL_SPEC_OPS_FLAGS       EQU     <"SpecOpsFlags">
REGSTR_VAL_SPEC_OPS_RETAIN_VCOMM_PWR_MGMT       EQU     00000001H
REGSTR_VAL_UNINSTALLER_DISPLAYNAME      EQU     <"DisplayName">
REGSTR_VAL_UNINSTALLER_COMMANDLINE      EQU     <"UninstallString">
REGSTR_PATH_DESKTOP     EQU     <REGSTR_PATH_SCREENSAVE>
REGSTR_PATH_MOUSE       EQU     <"Control Panel\Mouse">
REGSTR_PATH_KEYBOARD    EQU     <"Control Panel\Keyboard">
REGSTR_PATH_COLORS      EQU     <"Control Panel\Colors">
REGSTR_PATH_SOUND       EQU     <"Control Panel\Sound">
REGSTR_PATH_METRICS     EQU     <"Control Panel\Desktop\WindowMetrics">
REGSTR_PATH_ICONS       EQU     <"Control Panel\Icons">
REGSTR_PATH_CURSORS     EQU     <"Control Panel\Cursors">
REGSTR_PATH_CHECKDISK   EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Check Drive">
REGSTR_PATH_CHECKDISKSET        EQU     <"Settings">
REGSTR_PATH_CHECKDISKUDRVS      EQU     <"NoUnknownDDErrDrvs">
REGSTR_PATH_DEFRAG      EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Defrag">
REGSTR_PATH_DEFRAG_WIZARD       EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Defrag\Wizard">
REGSTR_PATH_DEFRAG_SET  EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Defrag\Settings">
REGSTR_PATH_DEFRAG_SET_METH     EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Defrag\Settings\method">
REGSTR_PATH_DEFRAG_SET_SCANDSK  EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Defrag\Settings\scandisk">
REGSTR_PATH_DEFAULT_DESKTOP     EQU     <".Default\Control Panel\Desktop">
REGSTR_PATH_FAULT       EQU     <"Software\Microsoft\Windows\CurrentVersion\Fault">
REGSTR_VAL_FAULT_LOGFILE        EQU     <"LogFile">
REGSTR_PATH_AEDEBUG     EQU     <"Software\Microsoft\Windows NT\CurrentVersion\AeDebug">
REGSTR_VAL_AEDEBUG_DEBUGGER     EQU     <"Debugger">
REGSTR_VAL_AEDEBUG_AUTO EQU     <"Auto">
REGSTR_PATH_GRPCONV     EQU     <"Software\Microsoft\Windows\CurrentVersion\GrpConv">
REGSTR_VAL_REGITEMDELETEMESSAGE EQU     <"Removal Message">
REGSTR_PATH_LASTCHECK   EQU     <"Software\Microsoft\Windows\CurrentVersion\Explorer\LastCheck">
REGSTR_PATH_LASTOPTIMIZE        EQU     <"Software\Microsoft\Windows\CurrentVersion\Explorer\LastOptimize">
REGSTR_PATH_LASTBACKUP  EQU     <"Software\Microsoft\Windows\CurrentVersion\Explorer\LastBackup">
REGSTR_PATH_CHKLASTCHECK        EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Check Drive\LastCheck">
REGSTR_PATH_CHKLASTSURFAN       EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Check Drive\LastSurfaceAnalysis">
REGSTR_PATH_DEFRAG_APPSTART     EQU     <"Software\Microsoft\Windows\CurrentVersion\Applets\Defrag\AppStartRegions">
REGSTR_VAL_DEFRAG_APPLOGFILTER  EQU     <"ApplogFilter">

_DSKTLSYSTEMTIME        STRUC
wYear   DW      ?
wMonth  DW      ?
wDayOfWeek      DW      ?
wDay    DW      ?
wHour   DW      ?
wMinute DW      ?
wSecond DW      ?
wMilliseconds   DW      ?
wResult DW      ?
_DSKTLSYSTEMTIME        ENDS
DTRESULTOK      EQU     0
DTRESULTFIX     EQU     1
DTRESULTPROB    EQU     2
DTRESULTPART    EQU     3
REGSTR_KEY_SHARES       EQU     <"Software\Microsoft\Windows\CurrentVersion\Network\LanMan">
REGSTR_VAL_SHARES_FLAGS EQU     <"Flags">
REGSTR_VAL_SHARES_TYPE  EQU     <"Type">
REGSTR_VAL_SHARES_PATH  EQU     <"Path">
REGSTR_VAL_SHARES_REMARK        EQU     <"Remark">
REGSTR_VAL_SHARES_RW_PASS       EQU     <"Parm1">
REGSTR_VAL_SHARES_RO_PASS       EQU     <"Parm2">
REGSTR_PATH_PRINT       EQU     <"System\CurrentControlSet\Control\Print">
REGSTR_PATH_PRINTERS    EQU     <"System\CurrentControlSet\Control\Print\Printers">
REGSTR_PATH_PROVIDERS   EQU     <"System\CurrentControlSet\Control\Print\Providers">
REGSTR_PATH_MONITORS    EQU     <"System\CurrentControlSet\Control\Print\Monitors">
REGSTR_PATH_ENVIRONMENTS        EQU     <"System\CurrentControlSet\Control\Print\Environments">
REGSTR_VAL_START_ON_BOOT        EQU     <"StartOnBoot">
REGSTR_VAL_PRINTERS_MASK        EQU     <"PrintersMask">
REGSTR_VAL_DOS_SPOOL_MASK       EQU     <"DOSSpoolMask">
REGSTR_KEY_CURRENT_ENV  EQU     <"\Windows 4.0">
REGSTR_KEY_DRIVERS      EQU     <"\Drivers">
REGSTR_KEY_PRINT_PROC   EQU     <"\Print Processors">
REGSTR_PATH_EVENTLABELS EQU     <"AppEvents\EventLabels">
REGSTR_PATH_SCHEMES     EQU     <"AppEvents\Schemes">
REGSTR_PATH_APPS        EQU     <REGSTR_PATH_SCHEMES"\\Apps">
REGSTR_PATH_APPS_DEFAULT        EQU     <REGSTR_PATH_SCHEMES"\\Apps\\.Default">
REGSTR_PATH_NAMES       EQU     <REGSTR_PATH_SCHEMES"\\Names">
REGSTR_PATH_MULTIMEDIA  EQU     <REGSTR_PATH_SETUP"\\Multimedia">
REGSTR_PATH_MULTIMEDIA_AUDIO    EQU     <"Software\Microsoft\Multimedia\Audio">
REGSTR_PATH_MEDIARESOURCES      EQU     <REGSTR_PATH_CURRENT_CONTROL_SET"\\MediaResources">
REGSTR_PATH_MEDIAPROPERTIES     EQU     <REGSTR_PATH_CURRENT_CONTROL_SET"\\MediaProperties">
REGSTR_PATH_PRIVATEPROPERTIES   EQU     <REGSTR_PATH_MEDIAPROPERTIES"\\PrivateProperties">
REGSTR_PATH_PUBLICPROPERTIES    EQU     <REGSTR_PATH_MEDIAPROPERTIES"\\PublicProperties">
REGSTR_PATH_JOYOEM      EQU     <REGSTR_PATH_PRIVATEPROPERTIES"\\Joystick\\OEM">
REGSTR_PATH_JOYCONFIG   EQU     <REGSTR_PATH_MEDIARESOURCES"\\Joystick">
REGSTR_KEY_JOYCURR      EQU     <"CurrentJoystickSettings">
REGSTR_KEY_JOYSETTINGS  EQU     <"JoystickSettings">
REGSTR_VAL_JOYUSERVALUES        EQU     <"JoystickUserValues">
REGSTR_VAL_JOYCALLOUT   EQU     <"JoystickCallout">
REGSTR_VAL_JOYNCONFIG   EQU     <"Joystick%dConfiguration">
REGSTR_VAL_JOYNOEMNAME  EQU     <"Joystick%dOEMName">
REGSTR_VAL_JOYNOEMCALLOUT       EQU     <"Joystick%dOEMCallout">
REGSTR_VAL_JOYOEMCALLOUT        EQU     <"OEMCallout">
REGSTR_VAL_JOYOEMNAME   EQU     <"OEMName">
REGSTR_VAL_JOYOEMDATA   EQU     <"OEMData">
REGSTR_VAL_JOYOEMXYLABEL        EQU     <"OEMXYLabel">
REGSTR_VAL_JOYOEMZLABEL EQU     <"OEMZLabel">
REGSTR_VAL_JOYOEMRLABEL EQU     <"OEMRLabel">
REGSTR_VAL_JOYOEMPOVLABEL       EQU     <"OEMPOVLabel">
REGSTR_VAL_JOYOEMULABEL EQU     <"OEMULabel">
REGSTR_VAL_JOYOEMVLABEL EQU     <"OEMVLabel">
REGSTR_VAL_JOYOEMTESTMOVEDESC   EQU     <"OEMTestMoveDesc">
REGSTR_VAL_JOYOEMTESTBUTTONDESC EQU     <"OEMTestButtonDesc">
REGSTR_VAL_JOYOEMTESTMOVECAP    EQU     <"OEMTestMoveCap">
REGSTR_VAL_JOYOEMTESTBUTTONCAP  EQU     <"OEMTestButtonCap">
REGSTR_VAL_JOYOEMTESTWINCAP     EQU     <"OEMTestWinCap">
REGSTR_VAL_JOYOEMCALCAP EQU     <"OEMCalCap">
REGSTR_VAL_JOYOEMCALWINCAP      EQU     <"OEMCalWinCap">
REGSTR_VAL_JOYOEMCAL1   EQU     <"OEMCal1">
REGSTR_VAL_JOYOEMCAL2   EQU     <"OEMCal2">
REGSTR_VAL_JOYOEMCAL3   EQU     <"OEMCal3">
REGSTR_VAL_JOYOEMCAL4   EQU     <"OEMCal4">
REGSTR_VAL_JOYOEMCAL5   EQU     <"OEMCal5">
REGSTR_VAL_JOYOEMCAL6   EQU     <"OEMCal6">
REGSTR_VAL_JOYOEMCAL7   EQU     <"OEMCal7">
REGSTR_VAL_JOYOEMCAL8   EQU     <"OEMCal8">
REGSTR_VAL_JOYOEMCAL9   EQU     <"OEMCal9">
REGSTR_VAL_JOYOEMCAL10  EQU     <"OEMCal10">
REGSTR_VAL_JOYOEMCAL11  EQU     <"OEMCal11">
REGSTR_VAL_JOYOEMCAL12  EQU     <"OEMCal12">
REGSTR_PATH_DeviceObjects       EQU     <"System\CurrentControlSet\Services\Device Objects">
REGSTR_KEY_DeviceObjects_CLSID  EQU     <"CLSID">
REGSTR_VAL_KernelObject EQU     <"Kernel Object">
REGSTR_VAL_UserObject   EQU     <"User Object">
REGSTR_VAL_UserProxyKernelObject        EQU     <"User Proxy Kernel Object">
REGSTR_VAL_UserProxyRemoteObject        EQU     <"User Proxy Remote Object">
REGSTR_VAL_KernelStubKernelObject       EQU     <"Kernel Stub Kernel Object">
REGSTR_KEY_KernelServer EQU     <"Kernel Server">
REGSTR_VAL_ObjectServer EQU     <"Object Server">
REGSTR_PATH_CPUID       EQU     <"Hardware\Description\System\CentralProcessor\0">
REGSTR_CPUID_KEY        EQU     <"VendorIdentifier">
REGSTR_VAL_CPUTYPE      EQU     <"Identifier">
REGSTR_VAL_CPUMMX       EQU     <"MMXIdentifier">
REGSTR_NX_GENERIC       EQU     <"NexGenDriven">
REGSTR_CYRIX    EQU     <"CyrixInstead">
REGSTR_INTEL    EQU     <"GenuineIntel">
REGSTR_AMD      EQU     <"AuthenticAMD">
REGSTR_PATH_CERTMGR     EQU     <"Software\Microsoft\Certificate Mgr">
REGSTR_PATH_CERTMGR_KEYS        EQU     <REGSTR_PATH_CERTMGR"\\Keys">
REGSTR_PATH_CERTMGR_CERTS       EQU     <REGSTR_PATH_CERTMGR"\\Certificates">
REGSTR_VAL_SERIALNO     EQU     <"SerialNo">
REGSTR_VAL_CANSIGN      EQU     <"CanSign">
REGSTR_VAL_CRYPTOTYPE   EQU     <"CryptoType">
REGSTR_VAL_PUBLICKEY    EQU     <"PublicKey">
REGSTR_VAL_CERT EQU     <"Certificate">
REGSTR_VAL_COUNT        EQU     <"Count">
REGSTR_VAL_SYMBOLICLINK EQU     <"SymbolicLink">
REGSTR_VAL_REGDONE      EQU     <"Regdone">
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\ring0.h ===
/*****************************************************************************
 *  RING0.H
 *
 *	Ring 0 equates to be used with VxDCall#
 *
 *	This file should be replaced by references into the file
 *	dev\inc\vmmwin32.inc once vmm.h is fixed to allow the No_VxD
 *	option to include the Begin_Win32_Services macro.
 *
 *  Created:
 *	9-Sep-92 [JonT]
 *  History:
 *	25-Sep-92 [FelixA] Added defines and macros for the exported mem funcs
 *	25-Sep-92 [JonT] Added equates for VWin32.386
 *
 ****************************************************************************/

// Equates for VCOND functions

#ifdef  WOW
#define MEOW_NEED_BOP               0x80000000
#define MEOW_NO_SUSPEND_OTHERS      0x40000000
#else   // WOW
#define MEOW_NEED_BOP               0x00000000
#define MEOW_NO_SUSPEND_OTHERS      0x00000000
#endif  // else WOW

// VCOMM.386 ID numbers
// (its device ID is 0x002B
#define	VCOMM_Device_ID		0x002B
#define	VCOMM_GetVersion	(VCOMM_Device_ID << 16)
#define	VCOMM_OpenComm		VCOMM_GetVersion + 1
#define	VCOMM_SetupComm		VCOMM_OpenComm + 1
#define	VCOMM_EscapeCommFunction VCOMM_SetupComm + 1
#define	VCOMM_GetCommMask	VCOMM_EscapeCommFunction + 1
#define	VCOMM_GetCommProp	VCOMM_GetCommMask + 1
#define	VCOMM_GetCommState	VCOMM_GetCommProp + 1
#define	VCOMM_GetCommTimeouts	VCOMM_GetCommState + 1
#define	VCOMM_PurgeComm		VCOMM_GetCommTimeouts + 1
#define	VCOMM_SetCommMask	VCOMM_PurgeComm + 1
#define	VCOMM_SetCommState	VCOMM_SetCommMask + 1
#define	VCOMM_SetCommTimeouts	VCOMM_SetCommState + 1
#define	VCOMM_TransmitCommChar	VCOMM_SetCommTimeouts + 1
#define	VCOMM_WaitCommEvent	VCOMM_TransmitCommChar + 1
#define	VCOMM_GetCommModemStatus VCOMM_WaitCommEvent + 1
#define VCOMM_WriteComm		VCOMM_GetCommModemStatus+1
#define	VCOMM_ReadComm		VCOMM_WriteComm+1
#define	VCOMM_ClearCommError	VCOMM_ReadComm + 1
#define	VCOMM_CloseComm		VCOMM_ClearCommError + 1
#define	VCOMM_GetLastError	VCOMM_CloseComm + 1
#define	VCOMM_DequeueRequest	VCOMM_GetLastError + 1
#define	VCOMM_QueryFriendlyName	VCOMM_DequeueRequest + 1
#define	VCOMM_GetCommConfig	VCOMM_QueryFriendlyName + 1
#define	VCOMM_SetCommConfig	VCOMM_GetCommConfig + 1
#define	VCOMM_GetWin32Error	VCOMM_SetCommConfig + 1
#define	VCOMM_FlushFileBuffers	VCOMM_GetWin32Error + 1
#define	VCOMM_DeviceIOControl	VCOMM_FlushFileBuffers + 1

#ifndef NTKERN_DEVICE_ID
#define	NTKERN_DEVICE_ID	0x004B
#endif

#define	NtKern_Get_Version	(NTKERN_DEVICE_ID << 16)
#define	Nt_CreateFile		(NtKern_Get_Version + 1)
#define	Nt_CloseHandle		(Nt_CreateFile + 1)
#define	Nt_WriteFile		(Nt_CloseHandle + 1)
#define	Nt_ReadFile		(Nt_WriteFile + 1)
#define	Nt_IoControl		(Nt_ReadFile + 1)
#define	Nt_FlushBuffersFile	(Nt_IoControl + 1)
#define Nt_CancelIo             (Nt_FlushBuffersFile + 1)
#define Nt_GetDevnodeFromFileHandle (Nt_CancelIo + 1 )
#define Nt_RequestWakeupLatency (Nt_GetDevnodeFromFileHandle + 1)

//
// Now define calls to ACPI
//
#ifndef ACPI_DEVICE_ID
#define ACPI_DEVICE_ID 0x004c
#endif

#define Acpi_GetVersion (ACPI_DEVICE_ID << 16 )
#define Acpi_SetSystemIndicator ( Acpi_GetVersion + 1 )

#define AcpiGetVersion() VxDCall0( Acpi_GetVersion )
#define AcpiSetSystemIndicator( Indicator, Value )\
                VxDCall2( Acpi_SetSystemIndicator, Indicator, Value )

//
// definition for indicator
//
#define SystemStatus 0
#define MessageWaiting 1


#define VCOND_GETVERSION			0x00380000
#define VCOND_EMITSTRING			0x00380001
#define VCOND_CREATECONSOLE			0x00380002
#define VCOND_READCHARINFO			0x00380003
#define VCOND_READCHARS 			0x00380004
#define VCOND_READATTRS 			0x00380005
#define VCOND_WRITECHARINFO			0x00380006
#define VCOND_WRITECHARS			0x00380007
#define VCOND_WRITEATTRS			0x00380008
#define VCOND_FILLATTRS 			0x00380009
#define VCOND_GETCURPOS 			0x0038000a
#define VCOND_GETCURATTR			0x0038000b
#define VCOND_SETCURPOS 			0x0038000c
#define VCOND_SETCURATTR			0x0038000d
#define VCOND_SETINPUTMODE			0x0038000e
#define VCOND_GETINPUTMODE			0x0038000f
#define VCOND_READINPUT 			0x00380010
#define VCOND_PEEKINPUT 			0x00380011
#define VCOND_WRITEINPUT			0x00380012
#define VCOND_ATTACHPROCESS			0x00380013
#define VCOND_DETACHPROCESS			0x00380014
#define VCOND_DELETECONSOLE			0x00380015
#define VCOND_GETNUMBEROFINPUTEVENTS		0x00380016
#define VCOND_POSTMESSAGE			0x00380017
#define VCOND_GETSCREENSIZE			0x00380018
#define VCOND_FILLCHARS 			0x00380019
#define VCOND_FLUSHINPUT			0x0038001A
#define VCOND_SETATTRIBUTE			0x0038001B
#define VCOND_GETBUTTONCOUNT			0x0038001C
#define VCOND_SETSCREENSIZE			0x0038001D
#define VCOND_MATCHSCREENSIZE			0x0038001E
#define VCOND_WAITFORNEWCONSOLE 		0x0038001F
#define VCOND_SPAWN				0x00380020
#define VCOND_GETENVIRONMENT			0x00380021
#define VCOND_GETLAUNCHINFO			0x00380022
#define VCOND_INITAPCS				0x00380023
#define VCOND_GRBREPAINTRECT			0x00380024
#define VCOND_GRBMOVERECT			0x00380025
#define VCOND_GRBSETWINDOWSIZE			0x00380026
#define VCOND_GRBSETWINDOWORG			0x00380027
#define VCOND_GRBSETSCREENSIZE			0x00380028
#define VCOND_GRBSETCURSORPOSITION		0x00380029
#define VCOND_GRBSETCURSORINFO			0x0038002A
#define VCOND_GRBNOTIFYWOA			0x0038002B
#define VCOND_GRBSYNC				0x0038002C
#define VCOND_GRBTERMINATE			0x0038002D
#define VCOND_DP32_CREATE			0x0038002E
#define VCOND_DP32_GETWORK			0x0038002F
#define VCOND_DP32_TERMINATE			0x00380030
#define VCOND_DP32_WAITWORK			0x00380031
#define VCOND_REDIRECTIONCOMPLETE		0x00380032
#define VCOND_DP32_DESTROY			0x00380033
#define VCOND_UNBLOCKRING3WITHFAILURE		0x00380034
#ifdef BILINGUAL_CONSOLE
#define VCOND_GETCP				0x00380035
#endif

// Special "exit-code" value for VCOND_Detach: This value means
// "do not set the exit code."
#define VCD_NOEXITCODE ((DWORD)0xffffffff)

// Equates for VMM virtual memory functions

#define W32_PageReserve 			0x00010000
#define W32_PageCommit				0x00010001
#define W32_PageDecommit			0x00010002
#define W32_PagerRegister			0x00010003
#define W32_PagerQuery				0x00010004
#define W32_HeapAllocate			0x00010005
#define W32_ContextCreate			0x00010006
#define W32_ContextDestroy			0x00010007
#define W32_PageAttach				0x00010008
#define W32_PageFlush				0x00010009
#define W32_PageFree				0x0001000a
#define W32_ContextSwitch			0x0001000b
#define W32_HeapReAllocate			0x0001000c
#define W32_PageModifyPermissions		0x0001000d
#define W32_PageQuery				0x0001000e
#define W32_GetCurrentContext			0x0001000f
#define W32_HeapFree				0x00010010
#define W32_RegOpenKey				0x00010011
#define W32_RegCreateKey			0x00010012
#define W32_RegCloseKey 			0x00010013
#define W32_RegDeleteKey			0x00010014
#define W32_RegSetValue 			0x00010015
#define W32_RegDeleteValue			0x00010016
#define W32_RegQueryValue			0x00010017
#define W32_RegEnumKey				0x00010018
#define W32_RegEnumValue			0x00010019
#define W32_RegQueryValueEx			0x0001001a
#define W32_RegSetValueEx			0x0001001b
#define W32_RegFlushKey 			0x0001001c
#define W32_RegQueryInfoKey16			0x0001001d
#define W32_GetDemandPageInfo			0x0001001e
#define W32_BlockOnID				0x0001001f
#define W32_SignalID				0x00010020
#define W32_RegLoadKey				0x00010021
#define W32_RegUnLoadKey			0x00010022
#define W32_RegSaveKey				0x00010023
#define W32_RegRemapPreDefKey			0x00010024
#define W32_PageChangePager			0x00010025
#define W32_RegQueryMultipleValues		0x00010026
#define W32_RegReplaceKey			0x00010027
#define W32_BoostFileCache			0x00010028

#ifdef GANGLOAD
#define W32_CacheAndDecommitPages		(W32_BoostFileCache+1)
#define W32_RegNotifyChangeKeyValue		(W32_CacheAndDecommitPages+1)
#else
#define W32_RegNotifyChangeKeyValue		(W32_BoostFileCache+1)
#endif

#define W32_PageOutPages			(W32_RegNotifyChangeKeyValue+1)
#define W32_mmSetCacheMidPoint                  (W32_PageOutPages+1)

#ifdef WRITE_WATCH
#define W32_mmGetWriteWatch                     (W32_mmSetCacheMidPoint+1)
#define W32_mmResetWriteWatch                   (W32_mmGetWriteWatch+1)
#endif // WRITE_WATCH

// DEBUG Win32 API (debug device id is 0x0002)

#define DEBUG_WIN32_FAULT			0x00020000

// REBOOT.386 Win32 API (reboot device id is 0x0009)

#define REBOOT_WIN32_INIT			0x00090000
#define REBOOT_CHANGE_PHASE			0x00090001

// VWIN32.386 ID numbers (vwin32 device ID is 0x002a)

#define VW32_GetVersion 			0x002A0000
#define VW32_GetPager				0x002A0001
#define VW32_GetTickCount			0x002A0002
#define VW32_EnableExceptions			0x002A0003
#define VW32_AllocSyncPrimitive 		0x002A0006
#define VW32_CreateThread			(0x002A0008+MEOW_NEED_BOP)
#define VW32_BlockThread			0x002A0009
#define VW32_WakeThread 			0x002A000A
#define VW32_TerminateThread			0x002A000B
#define VW32_Initialize 			0x002A000C
#define VW32_QueueUserAPC			0x002A000D
#define VW32_CleanAPCList			0x002A000E
#define VW32_QueueKernelAPC			0x002A000F
#define VW32_Int21Dispatch			(0x002A0010+MEOW_NO_SUSPEND_OTHERS)
#define VW32_IFSMGR_DupHandle			0x002A0011
#define VW32_AdjustThreadPri			0x002A0013
#define VW32_GetThreadContext			0x002A0014
#define VW32_SetThreadContext			0x002A0015
#define VW32_ReadProcessMemory			0x002A0016
#define VW32_WriteProcessMemory 		0x002A0017
#define VW32_GetCR0State			0x002A0018
#define VW32_SetCR0State			0x002A0019
#define VW32_SuspendThread			0x002A001A
#define VW32_ResumeThread			0x002A001B
#define VW32_DeliverPendingKernelAPCs		(0x002A001C+MEOW_NEED_BOP)
#define VW32_WaitCrst				0x002A001D
#define VW32_WakeCrst				0x002A001E
#define VW32_DeviceIOCtl			0x002A001F
#define VW32_GetVMCPDVersion			0x002A0020
#define VW32_SetWin32Priority			0x002A0021
#define VW32_AttachThreadToGroup		0x002A0026
#define VW32_Int31Dispatch			0x002A0029
#define VW32_Int41Dispatch			(0x002A002A+MEOW_NO_SUSPEND_OTHERS)
#define VW32_BlockForTermination		0x002A002B
#define VW32_TerminationHandler2		(0x002A002C+MEOW_NEED_BOP)
#define VW32_BlockThreadEx			0x002A002D
#define VW32_ReleaseSyncObject			0x002A0030
#define VW32_UndoCrst				0x002A0032
#ifndef WOW
#define VW32_Ring0ThreadStart			0x002A0034
#endif  // ndef WOW
#define VW32_EnableAPCService			0x002A0036
#define VW32_FaultPop				0x002A0037
#define VW32_ForceCrsts 			0x002A0038
#define VW32_RestoreCrsts			0x002A0039
#define VW32_FreezeAllThreads			0x002A003A
#define VW32_UnFreezeAllThreads 		0x002A003B
#define VW32_IFSMGR_CloseHandle 		0x002A003C
#define VW32_AttachConappThreadToVM		0x002A003D
#define VW32_ActiveTimeBiasSet			0x002A003E
#define VW32_ModifyPagePermission		0x002A003F
#define VW32_QueryPage				0x002A0040
#define VW32_ForceLeaveCrst			0x002A0041
#define VW32_ForceEnterCrst			0x002A0042
#define VW32_Get_FP_Instruction_Size		0x002A0043
#define VW32_QueryPerformanceCounter		0x002A0044
#define VW32_SetDeviceFocus			0x002A0045
#define VW32_UnFreezeThread			0x002A0046
#define VW32_VMM_Replace_Global_Env		0x002A0047
#define VW32_SendKernelShutdown 		0x002A0048
#define VW32_RestoreSysCrst			0x002A0049
#define VW32_AddSysCrst 			0x002A004A
#define VW32_SetTimeOut 			0x002A004B
#define VW32_CancelTimeOut			0x002A004C
#define VW32_ThrowException			0x002A004D
#define VW32_SimCtrlC				0x002A004E
#define VW32_VMM_SystemControl                  0x002A004F
#define VW32_SetTimer                           0x002A0050
#define VW32_CancelTimer                        0x002A0051
#define VW32_GetNextResumeDueTime               0x002A0052
#define VW32_BiosSupportsResumeTimers           0x002A0053
#define VW32_SetResumeTimer                     0x002A0054
#define VW32_QueueUserApcEx                     0x002A0055
#define VW32_DisposeObject			0x002A0056
#define VW32_DuplicateObject			0x002A0057
#define VW32_UnuseTdbx  			0x002A0058
#define VW32_InterlockedAdd386			0x002A0059
#define VW32_InterlockedCmpxchg386		0x002A005A
#define VW32_InterlockedXadd386 		0x002A005B
#define VW32_WaitSingleObject 			0x002A005C
#define VW32_WaitMultipleObjects 		0x002A005D
#define VW32_ReleaseSem				0x002A005E
#define VW32_ReleaseMutex			0x002A005F
#define VW32_SetEvent				0x002A0060
#define VW32_PulseEvent				0x002A0061
#define VW32_ResetEvent				0x002A0062
#define VW32_DisposeTimerR3Apc			0x002A0063
#define VW32_SetWin32PriorityClass		0x002A0064

#ifdef  WOW
#define MEOWService(dwID)                       ((dwID & 0x3FFF0000)==0x3FFF0000)
#define MEOW_SetSelector                         0x3FFF0000
#define MEOW_LoadLibrary                         0x3FFF0001
#define MEOW_GetProcAddress                      0x3FFF0002
#define MEOW_FreeLibrary                         0x3FFF0003
#endif  // def WOW

// Allows use of MM* rather than VxDCall#( ..k

#if !defined(WINBASEAPI)
#if !defined(_KERNEL32_)
#define WINBASEAPI  __declspec(dllimport)
#else
#define WINBASEAPI
#endif
#endif


extern WINBASEAPI DWORD __stdcall VxDCall0( ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall1( ULONG ,ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall2( ULONG ,ULONG ,ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall3( ULONG ,ULONG ,ULONG ,ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall4( ULONG ,ULONG ,ULONG ,ULONG ,ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall5( ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall6( ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall7( ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall8( ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall9( ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG, ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall10( ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG, ULONG, ULONG );
extern WINBASEAPI DWORD __stdcall VxDCall11( ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG ,ULONG, ULONG, ULONG, ULONG );
/* ASM
VxDCall0    PROTO   STDCALL, :DWORD
VxDCall1    PROTO   STDCALL, :DWORD, :DWORD
VxDCall2    PROTO   STDCALL, :DWORD, :DWORD, :DWORD
VxDCall3    PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD
VxDCall4    PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
VxDCall5    PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
VxDCall6    PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
VxDCall7    PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
VxDCall8    PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
VxDCall9    PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
VxDCall10   PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
VxDCall11   PROTO   STDCALL, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
*/

#define PageReserve(page, npages, flags)	VxDCall3(W32_PageReserve,page, npages, flags)

#ifdef WRITE_WATCH
#define R0GetWriteWatch( ulFlags, pBaseAddr, dwRegionSize, pulAddr, pdwCount, pdwGranularity) \
            VxDCall6( W32_mmGetWriteWatch, ulFlags, pBaseAddr, dwRegionSize, pulAddr, pdwCount, pdwGranularity)
#define R0ResetWriteWatch( pBaseAddr, dwRegionSize ) \
            VxDCall2( W32_mmResetWriteWatch, pBaseAddr, dwRegionSize )
#endif // WRITEWATCH

extern BOOL PageCommit(ULONG page, ULONG npages, ULONG hpd, ULONG pagerdata, ULONG flags);
#define PageDecommit(page, npages, flags)	VxDCall3(W32_PageDecommit, page, npages, flags)
#define PagerRegister(ppd)			VxDCall1(W32_PagerRegister, (ULONG)ppd)
#define PagerQuery(hpd, ppd)		VxDCall2(W32_PagerQuery, (ULONG)hpd, (ULONG)ppd)
#define PageChangePager(page, npages, hpd, pagerdata, flags) \
	VxDCall5(W32_PageChangePager, (ULONG)page, (ULONG)npages, (ULONG)hpd, \
		(ULONG)pagerdata, (ULONG)flags)
#define ContextCreate() 		VxDCall0(W32_ContextCreate)
#define GetCurrentContext()		VxDCall0(W32_GetCurrentContext)
#define VMMHeapFree(p, f)		VxDCall2(W32_HeapFree, (ULONG)(p), f)
#define VMMHeapAllocate(p, f)		VxDCall2(W32_HeapAllocate, (ULONG)(p), f)
#define VMMHeapReAllocate(p, cb, f)	VxDCall3(W32_HeapReAllocate, (ULONG)(p), cb, f)
#define VMMBlockOnID(id, f)		VxDCall2(W32_BlockOnID, (ULONG)(id), f)
#define VMMSignalID(id) 		VxDCall1(W32_SignalID, (ULONG)(id))
#define ContextDestroy(hcd)		VxDCall1(W32_ContextDestroy, hcd)
#define ContextSwitch(hcd)		VxDCall1(W32_ContextSwitch, hcd)
#define PageQuery(pbase, pmbi, cbmbi)	VxDCall3(W32_PageQuery, (ULONG)pbase, (ULONG)pmbi, cbmbi)

#define PageAttach(pagesrc, hcontextsrc, pagedst, cpg)	    VxDCall4(W32_PageAttach, pagesrc, hcontextsrc, pagedst, cpg)
#define PageFlush(page, npages) 		VxDCall2(W32_PageFlush, page, npages)
#define PageFree(laddr, flags)			 VxDCall2(W32_PageFree, (ULONG)laddr, flags)
#define GetDemandPageInfo(laddr, flags) 	VxDCall2(W32_GetDemandPageInfo, (ULONG)laddr, flags)
#define EnableExceptions(handler, selCS, selDS, hdlr1, hdlr2, hdlr3, hdlr4, thcb) \
	VxDCall8(VW32_EnableExceptions, (ULONG)handler, (ULONG)selCS, \
		(ULONG)selDS, (ULONG)hdlr1, (ULONG)hdlr2, (ULONG)hdlr3, \
		(ULONG)hdlr4, (ULONG)thcb)
#define InitializeWin32VxD(pcdis) \
	VxDCall1(VW32_Initialize, (DWORD) pcdis)

#ifdef  WOW
#define W32CreateThread(ThreadHandle, ProcessHandle, ContextHandle, \
			ThreadFlags, regEIP, pContext, dwStackSize, \
                        ppStackTop, pptib, ppTDBX ) \
	VxDCall10(VW32_CreateThread, (ULONG)ThreadHandle, (ULONG)ProcessHandle, \
		 (ULONG) ContextHandle, (ULONG) ThreadFlags, \
		 (ULONG) regEIP, (ULONG) pContext, (ULONG) dwStackSize, \
                 (ULONG) ppStackTop, (ULONG) pptib, (ULONG) ppTDBX )
#else   // WOW
#define W32CreateThread(ThreadHandle, ProcessHandle, ContextHandle, \
			ThreadFlags, regCS, regEIP, regSS, regESP, ppTDBX ) \
	VxDCall9(VW32_CreateThread, (ULONG)ThreadHandle, (ULONG)ProcessHandle, \
		 (ULONG) ContextHandle, (ULONG) ThreadFlags, (ULONG) regCS, \
		 (ULONG) regEIP, (ULONG) regSS, (ULONG) regESP, (ULONG) ppTDBX )
#endif  // else WOW

#define VxDTerminateThread(ThreadHandle, ApcData) \
	VxDCall2(VW32_TerminateThread, (DWORD) ThreadHandle, (DWORD) ApcData)

#define VxDSuspendThread(ThreadHandle) \
	VxDCall1(VW32_SuspendThread, (DWORD) ThreadHandle)

#define VxDResumeThread(ThreadHandle) \
	VxDCall1(VW32_ResumeThread, (DWORD) ThreadHandle)

#define VW32DeliverPendingKernelAPCs() \
	VxDCall0(VW32_DeliverPendingKernelAPCs)

// Registry Macros

#define W32RegOpenKey(hKey,SubKey,lphKey)	VxDCall3(W32_RegOpenKey,(ULONG)hKey,(ULONG)SubKey,(ULONG)lphKey)
#define W32RegCreateKey(hKey,SubKey,lphKey)	VxDCall3(W32_RegCreateKey,(ULONG)hKey,(ULONG)SubKey,(ULONG)lphKey)

#define W32RegCloseKey(hKey)	VxDCall1(W32_RegCloseKey,(ULONG)hKey)
#define W32RegFlushKey(hKey)	VxDCall1(W32_RegFlushKey,(ULONG)hKey)

#define W32RegDeleteKey(hKey,SubKey)	VxDCall2(W32_RegDeleteKey,(ULONG)hKey,(ULONG)SubKey)
#define W32RegDeleteValue(hKey,ValName) VxDCall2(W32_RegDeleteValue,(ULONG)hKey,(ULONG)ValName)

#define W32RegEnumKey(hKey,dwIdx,lpbBuf,dwcbBuf)	VxDCall4(W32_RegEnumKey,(ULONG)hKey,dwIdx,(ULONG)lpbBuf,dwcbBuf)

#define W32RegQueryValue(hKey,szSubKey,lpszVal,lpcbVal) VxDCall4(W32_RegQueryValue,(ULONG)hKey,(ULONG)szSubKey,(ULONG)lpszVal,(ULONG)lpcbVal)

#define W32RegSetValue(hKey,szSubKey,dwType,lpszVal,cbVal) VxDCall5(W32_RegSetValue,(ULONG)hKey,(ULONG)szSubKey,dwType,(ULONG)lpszVal,cbVal)

#define W32RegEnumValue(hKey,iVal,lpszVal,lpcbVal,lpdwRes,lpdwType,lpbData,lpcbData)	\
	VxDCall8(W32_RegEnumValue,(ULONG)hKey,(ULONG)iVal,(ULONG)lpszVal,(ULONG)lpcbVal,(ULONG)lpdwRes,(ULONG)lpdwType,(ULONG)lpbData,(ULONG)lpcbData)

#define W32RegQueryValueEx(hKey,lpszVal,lpdwRes,lpdwType,lpbData,lpcbData)	\
	VxDCall6(W32_RegQueryValueEx,(ULONG)hKey,(ULONG)lpszVal,(ULONG)lpdwRes,(ULONG)lpdwType,(ULONG)lpbData,(ULONG)lpcbData)

#define W32RegSetValueEx(hKey,lpszVal,dwRes,dwType,lpbData,lpcbData)	\
	VxDCall6(W32_RegSetValueEx,(ULONG)hKey,(ULONG)lpszVal,dwRes,dwType,(ULONG)lpbData,(ULONG)lpcbData)

#define W32RegQueryInfoKey( hKey, lpcSubKeys, lpcbMaxSubKeyLen, \
	 lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen)	\
	VxDCall6(W32_RegQueryInfoKey16, (ULONG)hKey,(ULONG) lpcSubKeys, \
	 (ULONG) lpcbMaxSubKeyLen,(ULONG) lpcValues, \
	  (ULONG) lpcbMaxValueNameLen,(ULONG) lpcbMaxValueLen)

#define W32RegLoadKey(hKey, lpszSubKey, lpszFile) \
	VxDCall3(W32_RegLoadKey, (ULONG)hKey, (ULONG)lpszSubKey, (ULONG)lpszFile)
#define W32RegUnLoadKey(hKey, lpszSubKey) \
	VxDCall2(W32_RegUnLoadKey, (ULONG)hKey, (ULONG)lpszSubKey)
#define W32RegSaveKey(hKey, lpszFile, lpsa) \
	VxDCall3(W32_RegSaveKey, (ULONG)hKey, (ULONG)lpszFile, (ULONG)lpsa)
#define W32RegRemapPreDefKey(hKey,hkRootKey)	VxDCall2(W32_RegRemapPreDefKey,(ULONG)hKey,(ULONG)hkRootKey)


#define W32RegQueryMultipleValues(hKey, val_list, num_vals, \
					lpValueBuf, ldwTotsize)\
	VxDCall5(W32_RegQueryMultipleValues, (ULONG)hKey, (ULONG)val_list, \
	(ULONG)num_vals, (ULONG)lpValueBuf, (ULONG)ldwTotsize)

#define W32RegReplaceKey(hKey, lpszSubKey, lpszReplaceFile, lpszBackupFile) \
	VxDCall4(W32_RegReplaceKey, (ULONG)hKey, (ULONG)lpszSubKey, \
	    (ULONG)lpszReplaceFile, (ULONG)lpszBackupFile)

#define W32BoostFileCache() VxDCall0(W32_BoostFileCache)

#define W32RegNotifyChangeKeyValue(hKey, fWatchSubtree, dwNotifyFilter, hEvent) \
	VxDCall4(W32_RegNotifyChangeKeyValue, (ULONG)hKey, (ULONG)fWatchSubtree, \
	    (ULONG)dwNotifyFilter, (ULONG)hEvent)

// low level APC function interface
#define W32CleanAPCList() VxDCall0( VW32_CleanAPCList )
#define W32QueueUserAPC( pfnRing3APC, dwParam, ThreadHandle ) \
	VxDCall3( VW32_QueueUserAPC, (ULONG)(pfnRing3APC), \
	(ULONG)(dwParam), (ULONG)(ThreadHandle) )

#define W32QueueKernelAPC( pfnRing0APC, dwParam, ThreadHandle, ulFlags ) \
	VxDCall4( VW32_QueueKernelAPC, (ULONG)pfnRing0APC, dwParam, \
	(ULONG)ThreadHandle, ulFlags )

#define W32QueueUserApcEx( pfnRing3APC, dwParam, ThreadHandle, R0RunDown ) \
	VxDCall4( VW32_QueueUserApcEx, (ULONG)(pfnRing3APC), \
	(ULONG)(dwParam), (ULONG)(ThreadHandle), (ULONG)(R0RunDown))

// Thread priority adjusting
#define AdjustThreadPriority( R0ThreadHandle, PriBoost ) \
		VxDCall2(VW32_AdjustThreadPri,R0ThreadHandle,(DWORD)(PriBoost))

// Way to get to IFSMGR's Win32_DupHandle thru vwin32
#define W32_IFSMGR_DupHandle(pdbSrc, pdbDst, phandle, flags, \
			       bogusnetxattachhandle, pfSpecialNetxDup) \
		VxDCall6(VW32_IFSMGR_DupHandle, pdbSrc, pdbDst, phandle, \
			    flags, bogusnetxattachhandle, pfSpecialNetxDup)

// Close a ring0 file handle
#define W32_IFSMGR_CloseHandle(handle) \
		VxDCall1(VW32_IFSMGR_CloseHandle, handle)

// Prototype #define's for VWin32 functions

#define VWIN32GetVersion() \
		((USHORT)VxDCall0(VW32_GetVersion))

#define FVW32GetPager(pR0_dwWaitSingleObject, \
			pR0_bSetPevt, \
			pR0_EnterCrst, pR0_LeaveCrst, \
			pR0_BlockOnID, pR0_SignalID, \
			pR0_OpenFile, pR0_CloseDosFileHandle, pmmfPageOut, \
			ppfmdArray) \
		VxDCall10(VW32_GetPager, pR0_dwWaitSingleObject, \
			pR0_bSetPevt, \
			pR0_EnterCrst, pR0_LeaveCrst, \
			pR0_BlockOnID, pR0_SignalID, \
			pR0_OpenFile, pR0_CloseDosFileHandle, pmmfPageOut, \
			ppfmdArray)

#define PageModifyPermissions(page, npages, permand, permor) VxDCall4(W32_PageModifyPermissions, page, npages, permand, permor)
#define ModifyPagePermission(R0Thread, lpvAddr, cbSize, fperAnd, fperOr) \
		VxDCall5(VW32_ModifyPagePermission,	\
			 (DWORD)R0Thread,		\
			 (DWORD)lpvAddr,		\
			 cbSize,			\
			 fperAnd,			\
			 fperOr)

#define VWIN32QueryPage(R0Thread, lpvAddr, lpvBuffer, cbSize) \
		VxDCall4(VW32_QueryPage,		\
			 (DWORD)R0Thread,		\
			 (DWORD)lpvAddr,		\
			 (DWORD)lpvBuffer,		\
			 cbSize)

#define VxDBlockForTermination() \
		VxDCall0(VW32_BlockForTermination)

#define VxDTerminationHandler2(ptermdata) \
                VxDCall1(VW32_TerminationHandler2, (ULONG)(ptermdata))

// Defines for Win32 VxD debug api support services

#define VxDGetThreadContext(ptcb, pcontext) \
                VxDCall2(VW32_GetThreadContext, (DWORD)(ptcb), (DWORD)(pcontext))

#define VxDSetThreadContext(ptcb, pcontext) \
                VxDCall2(VW32_SetThreadContext, (DWORD)(ptcb), (DWORD)(pcontext))

#define VxDReadProcessMemory(ptcb, pBaseAddress, pBuffer, cbRead, pcbRead) \
		VxDCall5(VW32_ReadProcessMemory, (ptcb), \
		(ULONG)(pBaseAddress), (ULONG)(pBuffer), (cbRead), \
		(ULONG)(pcbRead))

#define VxDWriteProcessMemory(ptcb, pBaseAddress, pBuffer, cbWrite, pcbWritten)\
		VxDCall5(VW32_WriteProcessMemory, (ptcb), \
		(ULONG)(pBaseAddress), (ULONG)(pBuffer), (cbWrite), \
		(ULONG)(pcbWritten))

// Defines for floating point Cr0 flag support (EM, MP)

#define GetCR0State(ptcb) \
		VxDCall1(VW32_GetCR0State, (ptcb))

#define SetCR0State(ptcb, state) \
		VxDCall2(VW32_SetCR0State, (ptcb), (state))

#define WaitCrst( pcrst ) VxDCall1( VW32_WaitCrst, (DWORD)pcrst )
#define WakeCrst( pcrst ) VxDCall1( VW32_WakeCrst, (DWORD)pcrst )
#define UndoCrst( pcrst ) VxDCall1( VW32_UndoCrst, (DWORD)pcrst )

// support for DeviceIOControl API; go to ring0 with this
#define DeviceIOCtl(VxdDDB, dwIoControlCode, lpvInBuffer, \
			   cbInBuffer, lpvOutBuffer, cbOutBuffer, \
			   lpcbBytesReturned, lpoOverlapped, hDevice,\
			   ppdb, lpDDBName) \
	VxDCall11(VW32_DeviceIOCtl, (DWORD) VxdDDB, \
		 (DWORD) dwIoControlCode, (DWORD) lpvInBuffer, \
		 (DWORD) cbInBuffer, (DWORD) lpvOutBuffer, \
		 (DWORD) cbOutBuffer, (DWORD) lpcbBytesReturned, \
		 (DWORD) lpoOverlapped, (DWORD)hDevice,\
		 (DWORD) ppdb, lpDDBName)


#define SetWin32Priority( r0ThHandle, PriVal ) \
	VxDCall2( VW32_SetWin32Priority, (DWORD)r0ThHandle, (DWORD)PriVal )

#define SetWin32PriorityClass( ThreadArray, NumOfElements ) \
	VxDCall2( VW32_SetWin32PriorityClass, (DWORD)(ThreadArray), (DWORD)(NumOfElements) )

#define AttachThreadToGroup( r0ThToAttach, r0ThInGroup ) \
	VxDCall2( VW32_AttachThreadToGroup, (DWORD)r0ThToAttach, (DWORD) r0ThInGroup )

#define VW32BlockThread( Timeout ) \
	VxDCall1( VW32_BlockThread, Timeout)

#define VW32BlockThreadEx( Timeout, Alertable ) \
	VxDCall2( VW32_BlockThreadEx, Timeout, Alertable )

#define ReleaseSyncObj( pSyncObj, bAbandoned ) \
	VxDCall2( VW32_ReleaseSyncObject, (DWORD)pSyncObj, bAbandoned )

#ifndef WOW
#define Ring0ThreadStart( R0TParmBlk ) VxDCall1( VW32_Ring0ThreadStart, (DWORD)R0TParmBlk )
#endif  // ndef WOW

#define EnableAPCService( KSvcR0Handle ) VxDCall1( VW32_EnableAPCService, KSvcR0Handle )

#define VW32FaultPop(pcontext, ulExceptionNumber, fDebug) \
	VxDCall3(VW32_FaultPop, (DWORD)pcontext, ulExceptionNumber, fDebug)

#define VW32ForceCrsts() \
	VxDCall0(VW32_ForceCrsts)

#define VW32RestoreCrsts(h, ptdb) \
	VxDCall2(VW32_RestoreCrsts, (DWORD)(h), (DWORD)(ptdb))

#define VW32FreezeAllThreads() \
	VxDCall0(VW32_FreezeAllThreads)

#define VW32UnFreezeAllThreads() \
	VxDCall0(VW32_UnFreezeAllThreads)

#define VW32ForceLeaveCrst(pcrst, ptdb) \
	VxDCall2(VW32_ForceLeaveCrst, (DWORD)pcrst, (DWORD)ptdb)

#define VW32ForceEnterCrst(pcrst, ptdb, recur) \
	VxDCall3(VW32_ForceEnterCrst, (DWORD)pcrst, (DWORD)ptdb, (DWORD)recur)

extern	Get_FP_Instruction_Size(ULONG, ULONG);

#define AttachConappThreadToVM( R0ThreadHandle, hVM ) \
	VxDCall2( VW32_AttachConappThreadToVM, (DWORD)R0ThreadHandle, (DWORD)hVM )

#define ActiveTimeBiasSet()  VxDCall0(VW32_ActiveTimeBiasSet)

#define VW32SetDeviceFocus() \
	VxDCall0(VW32_SetDeviceFocus)

#define VW32UnFreezeThread(ptcb) \
	VxDCall1(VW32_UnFreezeThread, (DWORD)(ptcb))

#define VW32SendKernelShutdown() \
	VxDCall0(VW32_SendKernelShutdown)

#define VW32RestoreSysCrst(pcrst, ptdb, count) \
	VxDCall3(VW32_RestoreSysCrst, (DWORD)pcrst, (DWORD)ptdb, (DWORD)count)

#define VW32AddSysCrst(plcrst, order) \
	VxDCall2(VW32_AddSysCrst, (DWORD)(plcrst), (DWORD)(order))

#define VW32SetTimeOut(pfn, ms, data) \
	VxDCall3(VW32_SetTimeOut, (DWORD)(pfn), (DWORD)(ms), (DWORD)(data))

#define VW32CancelTimeOut(hto) \
	VxDCall1(VW32_CancelTimeOut, (DWORD)(hto))

#define VW32ThrowException(type) \
	VxDCall1(VW32_ThrowException, (DWORD)(type))

#define VW32VMMSystemControl(dwControlMsg, dwEDXParam, dwESIParam, dwEDIParam) \
        VxDCall4(VW32_VMM_SystemControl, (DWORD)(dwControlMsg), (DWORD)(dwEDXParam), (DWORD)(dwESIParam), (DWORD)(dwEDIParam))

#define VW32SetTimer(lpTimerDb, lpDueTime, lPeriod, pfnCompletion, lpCompletionArg, fResume) \
        VxDCall6(VW32_SetTimer, (DWORD)(lpTimerDb), (DWORD)(lpDueTime), (DWORD)(lPeriod), (DWORD)(pfnCompletion), (DWORD)(lpCompletionArg), (DWORD)(fResume))

#define VW32CancelTimer(lpTimerDb) \
	VxDCall1(VW32_CancelTimer, (DWORD)(lpTimerDb))

#define VW32GetNextResumeDueTime(lpFileTime) \
	VxDCall1(VW32_GetNextResumeDueTime, (DWORD)(lpFileTime))

#define VW32BiosSupportsResumeTimers() \
	VxDCall0(VW32_BiosSupportsResumeTimers)

#define VW32SetResumeTimer(lpSystemTime) \
	VxDCall1(VW32_SetResumeTimer, (DWORD)(lpSystemTime))

#define VW32DisposeObject(pobj) \
	VxDCall1(VW32_DisposeObject, (DWORD)(pobj))

#define VW32DuplicateObject(pobj, ppdbSrc, ppdbDest) \
	VxDCall3(VW32_DuplicateObject, (DWORD)(pobj), (DWORD)(ppdbSrc), (DWORD)(ppdbDest))

#define VW32InterlockedAdd386(paddend, quantity) \
	VxDCall2(VW32_InterlockedAdd386,(DWORD)(paddend),(DWORD)(quantity))

#define VW32InterlockedCmpxchg386(pdest, exchange, comperand) \
	VxDCall3(VW32_InterlockedCmpxchg386,(DWORD)(pdest),(DWORD)(exchange),(DWORD)(comperand))

#define VW32InterlockedXadd386(paddend, exchange) \
	VxDCall2(VW32_InterlockedXadd386,(DWORD)(paddend),(DWORD)(exchange))

#define VW32UnuseTdbx(ptdbx) \
        VxDCall1(VW32_UnuseTdbx, (DWORD)(ptdbx))

#define VW32WaitSingleObject(pObj, dwTimeout, fAlertable) \
        VxDCall3(VW32_WaitSingleObject, (DWORD)(pObj),(dwTimeout),(fAlertable))

#define VW32WaitMultipleObjects(cObj, paObj, dwTimeout, dwFlags, fAlertable) \
        VxDCall5(VW32_WaitMultipleObjects, (cObj), (DWORD)(paObj), (dwTimeout), (dwFlags), (fAlertable))

#define VW32ReleaseSem(psem, cRel, plPrev) \
        VxDCall3(VW32_ReleaseSem, (DWORD)(psem), (DWORD)(cRel), (DWORD)(plPrev))

#define VW32ReleaseMutex(pmutx) \
        VxDCall1(VW32_ReleaseMutex, (DWORD)(pmutx))

#define VW32SetEvent(pevt) \
        VxDCall1(VW32_SetEvent, (DWORD)(pevt))

#define VW32PulseEvent(pevt) \
        VxDCall1(VW32_PulseEvent, (DWORD)(pevt))

#define VW32ResetEvent(pevt) \
        VxDCall1(VW32_ResetEvent, (DWORD)(pevt))

#define VW32DisposeTimerR3Apc(ptimerr3apc) \
        VxDCall1(VW32_DisposeTimerR3Apc, (DWORD)(ptimerr3apc))

// Send a fault to kernel debugger

#define DEBUG_Win32Fault(faultnum, errorcd, pcontext) \
	VxDCall3(DEBUG_WIN32_FAULT, (faultnum), (errorcd), (ULONG)(pcontext))

#define REBOOT_Win32Init(pfnTermDialogBox, thcbFault) \
	VxDCall2(REBOOT_WIN32_INIT,(DWORD)(pfnTermDialogBox),(DWORD)(thcbFault))

#define REBOOT_ChangePhase(bPhase, dwData) \
	VxDCall2(REBOOT_CHANGE_PHASE,(DWORD)(bPhase),(DWORD)(dwData))

// VCOND interface
#define VCOND_GetLaunchInfo(conID, cmdline, curdir, flag) VxDCall4(VCOND_GETLAUNCHINFO, conID, (ULONG)cmdline, (ULONG)curdir, (ULONG)flag)
#define VCOND_EmitString(conID, pString, len)	VxDCall3(VCOND_EMITSTRING, conID, (ULONG)pString, len)
#define VCOND_CreateConsole(hvm, pConsole) VxDCall2(VCOND_CREATECONSOLE, (ULONG) hvm, (ULONG) pConsole)
#define VCOND_ReadCharInfo(conID, bufptr, len, coord) VxDCall4(VCOND_READCHARINFO, conID, (ULONG)bufptr, len, (ULONG)coord)
#define VCOND_ReadChars(conID, bufptr, coord, len) VxDCall4(VCOND_READCHARS, conID, (ULONG)bufptr, (ULONG)coord, len)
#define VCOND_ReadAttrs(conID, bufptr, coord, len, wantbytes) VxDCall5(VCOND_READATTRS, conID, (ULONG)bufptr, (ULONG)coord, len, wantbytes)
#define VCOND_WriteCharInfo(conID, bufptr, len, coord) VxDCall4(VCOND_WRITECHARINFO, conID, (ULONG)bufptr, len, (ULONG)coord)
#define VCOND_WriteChars(conID, bufptr, coord, len) VxDCall4(VCOND_WRITECHARS, conID, (ULONG)bufptr, (ULONG)coord, len)
#define VCOND_WriteAttrs(conID, bufptr, coord, len, wantbytes) VxDCall5(VCOND_WRITEATTRS, conID, (ULONG)bufptr, (ULONG)coord, len, wantbytes)
#define VCOND_FillAttrs(conID, attr, coord, len) VxDCall4(VCOND_FILLATTRS, conID, (ULONG)attr, (ULONG)coord, len)
#define VCOND_GetCurPos(conID) VxDCall1(VCOND_GETCURPOS, conID)
#define VCOND_GetCurAttr(conID) VxDCall1(VCOND_GETCURATTR, conID)
#define VCOND_SetCurPos(conID, coord) VxDCall2(VCOND_SETCURPOS, conID, (ULONG)coord)
#define VCOND_SetCurAttr(conID, attr) VxDCall2(VCOND_SETCURATTR, conID, (ULONG)attr)
#define VCOND_SetInputMode(conID, mode) VxDCall2(VCOND_SETINPUTMODE, conID, (ULONG)mode)
#define VCOND_GetInputMode(conID) VxDCall1(VCOND_GETINPUTMODE, conID)
#define VCOND_ReadInput(conID, lpBuffer, nEvents, bFile) VxDCall4(VCOND_READINPUT, conID, (ULONG)lpBuffer, (ULONG)nEvents, (ULONG)bFile)
#define VCOND_PeekInput(conID, lpBuffer, nEvents, bFile) VxDCall4(VCOND_PEEKINPUT, conID, (ULONG)lpBuffer, (ULONG)nEvents, (ULONG)bFile)
#define VCOND_WriteInput(conID, lpBuffer, nEvents) VxDCall3(VCOND_WRITEINPUT, conID, (ULONG)lpBuffer, (ULONG)nEvents)
#define VCOND_AttachProcess(conID) VxDCall1(VCOND_ATTACHPROCESS, conID)
#define VCOND_DetachProcess(conID, exitCode) VxDCall2(VCOND_DETACHPROCESS, conID, ( (DWORD)(exitCode) ) & 0xff)
#define VCOND_DetachProcess_NoEC(conID) VxDCall2(VCOND_DETACHPROCESS, conID, VCD_NOEXITCODE)
#define VCOND_DeleteConsole(conID)	VxDCall1(VCOND_DELETECONSOLE, conID)
#define VCOND_GetNumberOfInputEvents(conID)	VxDCall1(VCOND_GETNUMBEROFINPUTEVENTS, conID)
#define VCOND_PostMessage(hvm, msg, wparam)	VxDCall3(VCOND_POSTMESSAGE, (ULONG)hvm, (ULONG)msg, (ULONG)wparam)
#define VCOND_InitAPCs(nAPCs, ConAPCs, szPath)	VxDCall3(VCOND_INITAPCS, nAPCs, (ULONG)ConAPCs , (ULONG)szPath)
#define VCOND_GetScreenSize(conID)		VxDCall1(VCOND_GETSCREENSIZE, conID)
#define VCOND_FillChars(conID, c, coord, len) VxDCall4(VCOND_FILLCHARS, conID, (ULONG)c, (ULONG)coord, len)
#define VCOND_FlushInput(conID) VxDCall1(VCOND_FLUSHINPUT, conID)
#define VCOND_SetAttribute(conID, attr) VxDCall2(VCOND_SETATTRIBUTE, conID, (ULONG)attr)
#define VCOND_GetButtonCount()		VxDCall0(VCOND_GETBUTTONCOUNT)
#define VCOND_SetScreenSize(conID, cSize)	VxDCall2(VCOND_SETSCREENSIZE, conID, (ULONG)cSize)
#define VCOND_MatchScreenSize(conID, cSize)	VxDCall2(VCOND_MATCHSCREENSIZE, conID, (ULONG)cSize)
#define VCOND_WaitForNewConsole()	VxDCall0(VCOND_WAITFORNEWCONSOLE)
#define VCOND_UnblockRing3WithFailure() VxDCall0(VCOND_UNBLOCKRING3WITHFAILURE)


//#define VCOND_Spawn(conID, lpszImageName, lpszCurrentDirectory,
//		      lpszCommandLine, lpszEnvironment, lpdwExitCode
// (line too long...)

#define VCOND_Spawn(a1, a2, a3, a4, a5, a6) \
	VxDCall6(VCOND_SPAWN, (ULONG) a1, (ULONG) a2, \
		 (ULONG) a3, (ULONG) a4, (ULONG) a5, (ULONG) a6)

#define VCOND_GetEnvironment(conID, pEnv, len)	VxDCall3(VCOND_GETENVIRONMENT, conID, (ULONG) pEnv, len)

#define VCOND_GrbRepaintRect(conID, lpConsoleWindow) VxDCall2(VCOND_GRBREPAINTRECT, conID, (ULONG) lpConsoleWindow)
#define VCOND_GrbMoveRect(conID, psrSrcRect, cDestOrg) VxDCall3(VCOND_GRBMOVERECT, conID, (ULONG) psrSrcRect, (ULONG) cDestOrg)
#define VCOND_GrbSetWindowSize(conID, dwSize) VxDCall2(VCOND_GRBSETWINDOWSIZE, conID, dwSize)
#define VCOND_GrbSetWindowOrg(conID, dwOrg) VxDCall2(VCOND_GRBSETWINDOWORG, conID, dwOrg)
#define VCOND_GrbSetScreenSize(conID, dwSize) VxDCall2(VCOND_GRBSETSCREENSIZE, conID, dwSize)
#define VCOND_GrbSetCursorPosition(conID, dwLoc) VxDCall2(VCOND_GRBSETCURSORPOSITION, conID, (ULONG) dwLoc)
#define VCOND_GrbSetCursorInfo(conID, dwInfo) VxDCall2(VCOND_GRBSETCURSORINFO, conID, dwInfo)
#define VCOND_GrbNotifyWOA(conID)	VxDCall1(VCOND_GRBNOTIFYWOA, conID)
#define VCOND_GrbSync(conID)	VxDCall1(VCOND_GRBSYNC, conID)
#define VCOND_GrbTerminate(conID)	VxDCall1(VCOND_GRBTERMINATE, conID)
#define VCOND_DP32_Create(pExename, pCmdline, pCurdir, pStdxInfo, pspseg) \
	VxDCall5(VCOND_DP32_CREATE, (ULONG) pExename, \
	(ULONG) pCmdline, (ULONG) pCurdir, (ULONG) pStdxInfo, (ULONG) pspseg)
#define VCOND_DP32_Getwork(pRedir)	 VxDCall1(VCOND_DP32_GETWORK, (ULONG) pRedir)
#define VCOND_DP32_Terminate(pRedir) VxDCall1(VCOND_DP32_TERMINATE, (ULONG) pRedir)
#define VCOND_DP32_Waitwork(pRedir)	 VxDCall1(VCOND_DP32_WAITWORK, (ULONG) pRedir)
#define VCOND_RedirectionComplete(conID, redirFlags)	 VxDCall2(VCOND_REDIRECTIONCOMPLETE, conID, redirFlags)
#define VCOND_DP32_Destroy(pRedir) VxDCall1(VCOND_DP32_DESTROY, (ULONG) pRedir)
#ifdef BILINGUAL_CONSOLE
#define VCOND_GetCP(conID) VxDCall1(VCOND_GETCP, conID)
#endif

#ifdef  WOW
#define MEOWLoadLibrary(pszLibraryName) VxDCall1(MEOW_LoadLibrary, (ULONG)pszLibraryName)
#define MEOWGetProcAddress(hModule, pszFunctionName, dwOrdinal) VxDCall3(MEOW_GetProcAddress, (ULONG)hModule, (ULONG)pszFunctionName, (ULONG)dwOrdinal)
#define MEOWFreeLibrary(hModule) VxDCall1(MEOW_FreeLibrary, (ULONG)hModule)
#endif  // def WOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\syslevel.h ===
//**********************************************************************
//
//  SYSLEVEL.H - System Synchronization Support Include File
//
//**********************************************************************
//  Author:	Michael Toutonghi
//
//  Copyright:	1993 Microsoft
//
//  Description:
//
//  This file provides the interface to the heirarchical critical
//  section support for system synchronization. For further information
//  see the associated .C file. This include file works both for 16 bit
//  and 32 bit code.
//
//  Revision History:
//	2/2/92: created (miketout)
//**********************************************************************

// if this is defined, we will do system heirarchical level checking
#ifdef DEBUG
#define SYSLEVELCHECK
#endif

// These are the currently supported critical section levels
#define SL_LOAD         0
#define SL_WIN16        1
#define SL_KRN32        2
#define SL_PRIVATE      3
#define SL_TOTAL        4

typedef DWORD SYSLVL;

// This is another duplicate definition of the LCRST structure.  It must be
// kept in sync with the definitions in core\inc\syslvl16.*,
// core\inc\object16.*, and core\win32\inc\object.*.
// It exists so that modules other than krnl386 and kernel32 do not have to
// include all of the various private kernel header files.
#ifndef	LCRST_DEFINED
  typedef struct _lcrst {
	  long	crst[5];
  #ifdef SYSLEVELCHECK
	  SYSLVL	slLevel;
  #endif
  } LCRST;

  typedef LCRST *LPLCRST;
#endif

#ifndef WOW32_EXTENSIONS

#ifndef SYSLEVELCHECK
  #define CheckSysLevel( plcCrst )
#else
  void __stdcall _CheckSysLevel( struct _lcrst *plcCrst );
  #define CheckSysLevel( plcCrst ) _CheckSysLevel( plcCrst )
#endif

#ifndef SYSLEVELCHECK
  #define ConfirmSysLevel( plcCrst )
#else
  void __stdcall _ConfirmSysLevel( struct _lcrst *plcCrst );
  #define ConfirmSysLevel( plcCrst ) _ConfirmSysLevel( plcCrst )
#endif

#ifndef SYSLEVELCHECK
  #define CheckNotSysLevel( plcCrst )
#else
  void __stdcall _CheckNotSysLevel( struct _lcrst *plcCrst );
  #define CheckNotSysLevel( plcCrst ) _CheckNotSysLevel( plcCrst )
#endif

void __stdcall _InitSysLevel( struct _lcrst *plcCrst, SYSLVL slLevel );
#define InitSysLevel( plcCrst, slLevel ) _InitSysLevel( plcCrst, slLevel )

void __stdcall _EnterSysLevel( struct _lcrst *plcCrst );
#define EnterSysLevel( plcCrst ) _EnterSysLevel( plcCrst )

void __stdcall _LeaveSysLevel( struct _lcrst *plcCrst );
#define LeaveSysLevel( plcCrst ) _LeaveSysLevel( plcCrst )

void KERNENTRY _EnterMustComplete( void );
#define	EnterMustComplete()	_EnterMustComplete()

void KERNENTRY _LeaveMustComplete( void );
#define LeaveMustComplete()	_LeaveMustComplete()

#endif // ndef WOW32_EXTENSIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\tdb16.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  TDB.H
 *  16-bit Kernel Task Data Block
 *
 *  History:
 *  Created 11-Feb-1992 by Matt Felton (mattfe) - from 16 bit tdb.inc
 *       7-apr-1992 mattfe updated to be win 3.1 compatible
 *
--*/

/* XLATOFF */
#ifndef __TDB16_H
#define __TDB16_H
/* XLATON */

/*
 * NewExeHdr struct offsets. WOW32 uses these for getting expected winversion
 * directly from the exehdr.
 *
 */

#define NE_LOWINVER_OFFSET 0x3e
#define NE_HIWINVER_OFFSET 0x0c
#define FLAG_NE_PROPFONT   0x2000

/*
 * Task Data Block - 16 Bit Kernel Data Structure
 *
 *   Contains all 16 bit task specific data.
 *
 */

#define numTaskInts 7
#define THUNKELEM   8   // (62*8) = 512-16 (low arena overhead)
#define THUNKSIZE   8

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct TDB  {       /* tdb16 */

     WORD TDB_next    ;     // next task in dispatch queue
     WORD TDB_taskSP      ;     // Saved SS:SP for this task
     WORD TDB_taskSS      ;     //
     WORD TDB_nEvents     ;     // Task event counter
     BYTE TDB_priority    ;     // Task priority (0 is highest)

#ifdef  WOWONLY

     BYTE TDB_thread_ordinal  ;     // ordinal number of this thread
     WORD TDB_thread_next   ;       // next thread
     WORD TDB_thread_tdb      ; // the real TDB for this task
     WORD TDB_thread_list   ;       // list of allocated thread structures

#else   // WOWONLY

     BYTE TDB_iMonitor; // USER maintains this field for multiple monitor support
     WORD TDB_Unused2;  // BUGBUG - this field was only used for old looking glass (os/2 app support) stuff and should be removed
     DWORD TDB_Unused3; // BUGBUG - this field was only used for old looking glass (os/2 app support) stuff and should be removed

#endif  // else WOWONLY


     DWORD TDB_ptrace_appentry; // used for cvw support to break at app's entry

//
//     COMPATIBILITY WARNING: the above field(s) used to be
//
//     WORD TDB_thread_free   ;       // free list of availble thread structures
//     WORD TDB_thread_count  ;       // total count of tread structures

     WORD TDB_FCW         ; // Floating point control word
     BYTE TDB_flags   ;     // Task flags
     BYTE TDB_filler      ;     // keep word aligned
     WORD TDB_ErrMode     ;     // Error mode for this task
     WORD TDB_ExpWinVer   ;     // Expected Windows version for this task
     WORD TDB_Module      ;     // Task module handle to free in killtask
     WORD TDB_pModule     ;     // Pointer to the module database.
     WORD TDB_Queue   ;     // Task Event Queue pointer
     WORD TDB_Parent      ;     // TDB of the task that started this up

#ifdef WOWONLY

     WORD TDB_SigAction   ;     // Action for app task signal
     DWORD TDB_ASignalProc   ;      // App's Task Signal procedure address

#else   // WOWONLY

     WORD TDB_Unused5;  // BUGBUG - this field was only used for old looking glass (os/2 app support) stuff and should be removed
     DWORD TDB_Unused6; // BUGBUG - this field was only used for old looking glass (os/2 app support) stuff and should be removed

#endif  // else WOWONLY

     DWORD TDB_USignalProc   ;      // User's Task Signal procedure address
     DWORD TDB_GNotifyProc    ; // Task global discard notify proc.
     DWORD TDB_INTVECS[numTaskInts] ;   // Task specfic harare interrupts
     WORD TDB_CompatFlags ;     // Compatibility flags
     WORD TDB_CompatFlags2 ;        // Upper 16 bits

//
//   SEVERE COMPATIBILITY WARNING: The following five fields were
//   used by NT WOW, and stomps some MEoW fields, namely:
//   TDB_selTIB, TDB_ThreadHandle, TDB_selHeap32 and TDB_Unused7.
//   Those fields have been put at the end.
//
#ifdef  WOW

     WORD TDB_CompatHandle ;    // for dBase bug
     WORD TDB_WOWCompatFlagsEx ;     // More WOW Compatibility flags
     WORD TDB_WOWCompatFlagsEx2 ;        // Upper 16 bits
     BYTE TDB_Free[3] ;         // Filler to keep TDB size unchanged
     BYTE TDB_cLibrary    ;     // tracks  add/del of ALL libs in system EMS

#else   // WOW

     WORD TDB_selTIB;   // Selector to thread/task's TIB
     DWORD TDB_ThreadHandle; // Win32 thread handle
     WORD TDB_selHeap32;   // Win32 16-bit heap, for atoms
     WORD TDB_Unused7;  // Filler to keep TDB size unchanged

#endif  // else WOW


     DWORD TDB_PHT        ; // (HANDLE:OFFSET) to private handle table
     WORD TDB_PDB         ; // MSDOS Process Data Block (PDB)
     DWORD TDB_DTA        ; // MSDOS Disk Transfer Address
     BYTE TDB_Drive  ;      // MSDOS current drive
     BYTE TDB_Directory[65] ;       // *** not used starting with win95
// TDB_Directory is not used anymore and is not tracked
// use TDB_LFNDirectory at end of structure.
// This field is still kept intact as OLE might be depending on this

#ifdef  WOWONLY

     WORD TDB_Validity    ;     // initial AX to be passed to a task

#else   // WOWONLY

     WORD TDB_Unused8;  // BUGBUG - this field was only used for old looking glass (os/2 app support) stuff and should be removed

#endif  // else WOWONLY

     WORD TDB_Yield_to    ;     // DirectedYield arg stored here
     WORD TDB_LibInitSeg      ; // segment address of libraries to init
     WORD TDB_LibInitOff      ; // MakeProcInstance thunks live here.
     WORD TDB_MPI_Sel     ;     // Code selector for thunks
     WORD TDB_MPI_Thunks[((THUNKELEM*THUNKSIZE)/2)]; //
     BYTE TDB_ModName[8] ;      // Name of Module.
     WORD TDB_sig         ; // Signature word to detect bogus code

#ifndef WOW

     DWORD TDB_LastError;   // Last error

#endif  // ndef WOW

#ifdef   WOW

     DWORD TDB_ThreadID   ;     // 32-Bit Thread ID for this Task (use TDB_Filler Above)
     DWORD TDB_hThread    ; // 32-bit Thread Handle for this task
     WORD  TDB_WOWCompatFlags;  // WOW Compatibility flags
     WORD  TDB_WOWCompatFlags2; // WOW Compatibility flags
#ifdef FE_SB
     WORD  TDB_WOWCompatFlagsJPN;  // WOW Compatibility flags for JAPAN
     WORD  TDB_WOWCompatFlagsJPN2; // WOW Compatibility flags for JAPAN
#endif // FE_SB
     DWORD TDB_vpfnAbortProc;   // printer AbortProc

#endif  // def WOW

     BYTE TDB_LFNDirectory[260]; // Long directory name

#ifdef  WOW
#ifndef WOWONLY

     WORD TDB_selTIB;   // Selector to thread/task's TIB
     DWORD TDB_ThreadHandle; // Win32 thread handle
     WORD TDB_selHeap32;   // Win32 16-bit heap, for atoms
     WORD TDB_Unused7;  // Filler to keep TDB size unchanged

#endif  // ndef WOWONLY
#endif  // def WOW


} TDB16;
typedef TDB16 UNALIGNED *PTDB16;
typedef TDB16 *LPTDB16;

#ifndef __KERNEL32_H

/*ASM

TDBsize = SIZE TDB
*/
#endif  // ndef__KERNEL32_H


/* XLATOFF */

#ifndef __KERNEL32_H
#ifndef WOW32_EXTENSIONS

typedef TDB16   TDB;
typedef TDB UNALIGNED *PTDB;

#endif  // ndef WOW32_EXTENSIONS
#endif  // ndef__KERNEL32_H

// NEW_EXE1 struc from core\inc\newexe.inc

typedef struct tagNEW_EXE1 {
    WORD    ne_blah1;
    WORD    ne_usage;
    WORD    ne_blah2;
    WORD    ne_pnextexe;
    WORD    ne_pautodata;
    WORD    ne_pfileinfo;       // OFSTRUCTEX offset in TDB_pModule
} NEW_EXE1;


// PDB16 comes from core\inc\pdb.inc

typedef struct tagPDB16 {
    WORD    PDB16_Exit_Call;
    WORD    PDB16_block_len;
    BYTE    PDB16_pad1;
    BYTE    PDB16_CPM_Call[5];
    DWORD   PDB16_Exit;
    DWORD   PDB16_Ctrl_C;
    DWORD   PDB16_Fatal_Abort;
    WORD    PDB16_Parent_PID;
    BYTE    PDB16_JFN_Table[20];
    WORD    PDB16_environ;
    DWORD   PDB16_User_stack;
    WORD    PDB16_JFN_Length;
    DWORD   PDB16_JFN_Pointer;
    DWORD   PDB16_Next_PDB;
    BYTE    PDB16_InterCon;
    BYTE    PDB16_Append;
    BYTE    PDB16_Novell_Used[2];
    WORD    PDB16_Version;
    WORD    PDB16_Chain;
    WORD    PDB16_Partition;
    WORD    PDB16_NextPDB;
    DWORD   PDB16_GlobalHeap;
    DWORD   PDB16_Entry_stack;
    BYTE    PDB16_Call_system[5];
    BYTE    PDB16_PAD2[5];
    WORD    PDB16_DupRefCount;
    BYTE    PDB16_5C_FCB[0x10];
    BYTE    PDB16_6C_FCB[0x14];
    BYTE    PDB16_DEF_DTA[0x80];
} PDB16;

/* XLATON */

// signature word used to check validity of a TDB

#define TDB_SIGNATURE  'DT'

// TDB flags

// GDI will clear the TDBF_HOOKINT2F bit when enabling/disabling the
// DISPLAY driver, *dont* change or remove this bit without changing
// GDI.  Toddla
//

#define TDBF_WINOLDAP   01     /* This app is WinOldAp. */
#define TDBF_EMSSHARE   02     /* This app shares EMS banks with MSDOS EXEC. */
#define TDBF_CACHECHECK 04     /* Used in CacheCompact to prevent revisitation. */
#ifdef  WOWONLY
#define TDBF_OS2APP     0x08    // This is an OS/2 app.
#define TDBF_WIN32S     0x10    // This is Win32S app.
#else    ; WOWONLY
#define TDBF_NEWTASK    0x08    // This task has not yet been scheduled
#endif   ; WOWONLY
#define TDBF_KERNEL32   0x10     /* This is a Kernel32 thread */
#define TDBF_HGCLEANUP  0x20    /* Win32 app has ganged handles to clean up */
#define TDBF_HOOKINT21  0x40    // app hooks int 21H
#define TDBF_HOOKINT2F  0x80    // app hooks int 2FH

// This bit is defined for the TDB_Drive field
#define TDB_DIR_VALID 0x80



// NOTE TDB_ThreadID MUST be DWORD aligned or else it will fail on MIPS

/* XLATOFF */
#pragma pack()
/* XLATON */

/* XLATOFF */
#endif  // ndef __TDB16_H
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\syslevel.inc ===
;**********************************************************************
;
;	SYSLEVEL.H - System Synchronization Support Include File
;
;**********************************************************************
;  Author:	Michael Toutonghi
;
;  Copyright:	1993 Microsoft
;
;  Description:
;
;  This file provides the interface to the heirarchical critical
;  section support for system synchronization. For further information
;  see the associated .C file (for 16 bit, CRITSECT.ASM). This file
;  works with both 16 and 32 bit code.
;
;  Revision History:
;	2/3/92: created (miketout)
;
;**********************************************************************

; If this is defined, we will do system heirarchical level checking
ifdef DEBUG
SYSLEVELCHECK	EQU
endif

; These are the currently supported critical section levels
SL_LOAD                 EQU 0
SL_WIN16		EQU 1
SL_KRN32		EQU 2
SL_PRIVATE		EQU 3
SL_TOTAL		EQU 4

; This is another duplicate definition of the LCRST structure.  It must be
; kept in sync with the definitions in core\inc\object16.*, and
; core\win32\inc\object.*.
; It exists so that modules other than krnl386 and kernel32 do not have to
; include all of the various private kernel header files.
IFNDEF	LCRST_DEFINED
  LCRST	STRUC
      crst	dd 5 dup(0)
  IFDEF SYSLEVELCHECK
      slLevel	dd 0
  ENDIF
  LCRST	ENDS

  LPLCRST typedef PTR LCRST
ENDIF

; if we have system level checking enabled, the macro will actually
; do a call, otherwise, it does nothing
IFDEF SYSLEVELCHECK
  _CheckSysLevel PROTO stdcall :LPLCRST
  CheckSysLevel MACRO plcCrst:VARARG
      FOR Arg:REQ, <plcCrst>
  	INVOKE _CheckSysLevel, Arg	;; check sys level through function
      ENDM
  ENDM
ELSE
  CheckSysLevel	MACRO plcCrst
  ENDM
ENDIF

; if we have system level checking enabled, the macro will actually
; do a call, otherwise, it does nothing
IFDEF SYSLEVELCHECK
  _ConfirmSysLevel PROTO stdcall :LPLCRST
  ConfirmSysLevel MACRO plcCrst:VARARG
      FOR Arg:REQ, <plcCrst>
  	INVOKE _ConfirmSysLevel, Arg	;; confirm sys level
      ENDM
  ENDM
ELSE
  ConfirmSysLevel	MACRO plcCrst
  ENDM
ENDIF

; We can have a macro with the same name as the prototype since
; MASM will munge the function name to be different than the macro
_InitSysLevel PROTO stdcall :LPLCRST, :DWORD
InitSysLevel	MACRO plcCrst, Level
	INVOKE _InitSysLevel, plcCrst, Level ;; init critical section
ENDM

_EnterSysLevel PROTO stdcall :LPLCRST
EnterSysLevel	MACRO plcCrst:VARARG
      FOR Arg:REQ, <plcCrst>
	INVOKE _EnterSysLevel, Arg	;; enter critical section
      ENDM
ENDM

_LeaveSysLevel PROTO stdcall :LPLCRST
LeaveSysLevel	MACRO plcCrst:VARARG
      FOR Arg:REQ, <plcCrst>
	INVOKE _LeaveSysLevel, Arg	;; leave critical section
      ENDM
ENDM

_EnterMustComplete PROTO KERNENTRY
EnterMustComplete MACRO
	INVOKE _EnterMustComplete
ENDM

_LeaveMustComplete PROTO KERNENTRY
LeaveMustComplete MACRO
	INVOKE _LeaveMustComplete
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\tdbx.h ===
//-----------------------------------------------------------------------
//
// TDBX.H - TDBX data structure definition
//
//-----------------------------------------------------------------------
//  File Description:
//      Provides a definition of the TDBX data structure which is a
//      non-pageable data structure used for storage of thread specific
//      data which must be accessed from ring 0 at event or thread switch
//      time.
//
//-----------------------------------------------------------------------
//  Revision History:
//      5/21/93 - created (miketout)
//
//-----------------------------------------------------------------------

/* XLATOFF */
#pragma pack(1)
/* XLATON */

#define MEOW_BOP_STACK_SIZE     (48*1024)
#define MEOW_BOP_STACK_FILL     0x5A

typedef struct WNLST {
        struct  _wnod *wnlst_pwnCirc;   // 1 node in circular wait node list
        DWORD   wnlst_flFlags;          // wait flags for any or all, etc.
} WNLST;

typedef struct TDBX {
#ifdef  WOW
        BYTE    tdbxType;
        BYTE    tdbxUnused;
        WORD    tdbxCntUses;            // Ref count
#else   // WOW
        DWORD   tdbxCntUses;            // Ref count
#endif  // else WOW
        WNLST   tdbxWaitNodeList;       // wait node list
        DWORD   tdbxR0ThreadHandle;     // ring 0 thread handle
        DWORD   tdbxContextHandle;      // ring 0 memory context handle
        DWORD   tdbxProcessHandle;      // ring 3 process handle
#ifdef  WOW
        struct _tdb    *tdbxThreadHandle;       // ring 3 thread handle
#else   // WOW
        DWORD   tdbxThreadHandle;       // ring 3 thread handle
#endif  // else WOW

        DWORD   tdbxMustCpltCount;      // nested must-complete count
        DWORD   tdbxSuspendHandle;      // suspend apc handle
        DWORD   tdbxSuspendCount;       // nested suspend count
#ifdef  WOW
        LONG    tdbxBlockState;         // -1 = blkd, 0 = norm, 1 = wake pending
        HANDLE  tdbxBlockHandle;        // handle to thread's private semaphore
#else   // WOW
        DWORD   tdbxBlockState;         // -1 = blkd, 0 = norm, 1 = wake pending
        DWORD   tdbxBlockHandle;        // handle to thread's private semaphore
#endif  // else WOW
        DWORD   tdbxWakeParam;          // caller defined wakeup parameter
        DWORD   tdbxTimeOutHandle;      // handle from Set_Global_Time_Out
        DWORD   tdbxCreateDestroyData;  // create/destroy parameter

        KERNELAPCREC tdbxkernelapcrec;  // apc record for terminate and freeze
        volatile DWORD tdbxBlockedOnID; // if the thread is blocked on id
        DWORD   tdbxpPMPSPSelector;     // ptr to TCB_PMPSPSelector field in TCB
        DWORD   tdbxKernAPCList;        // pointer to first kernel APC
#ifdef  WOW
        struct _userapcrec *tdbxUserAPCList;        // pointer to first user APC in list
#else   // WOW
        DWORD   tdbxUserAPCList;        // pointer to first user APC in list
#endif  // else WOW
        DWORD   tdbxQueuedSyncAPCs;     // waiting till out of nested Wait()
        DWORD   tdbxSyncWaitCount;      // nested Wait() count
        volatile DWORD tdbxWaitExFlags; // bit mask used for alertable waits

        DWORD   tdbxTraceEventHandle;   // trace out event handle
        DWORD   tdbxTraceCallBack;      // trace out call back function
        DWORD   tdbxTraceRefData;       // trace out reference data
        WORD    tdbxDosPDBSeg;          // DOS PDB segment value for this thread
        WORD    tdbxK16Task;            // actual sel for K16 TDB of this TDB

        DWORD   tdbxDR7;                // debug registers
        DWORD   tdbxDR6;
        DWORD   tdbxDR3;
        DWORD   tdbxDR2;
        DWORD   tdbxDR1;
        DWORD   tdbxDR0;
#ifdef SYSLEVELCHECK
        LONG    tdbxLvlCounts[SL_TOTAL]; // to keep track of CRST level
        LPLCRST tdbxOwnedCrsts[SL_TOTAL]; // ptrs to crit sections owned
#endif
        WORD    tdbxTraceOutLastCS;     // trace out last CS
        WORD    tdbxK16PDB;             // selector for PDB
        BYTE    tdbxExceptionCount;     // number of nested exceptions
        BYTE    tdbxSavedIrql;          // irql saved by VWIN32_SaveIrql
        BYTE    tdbxSavedIrqlCount;     // INIT <-1>
#ifdef  WOW
        BYTE    tdbxAlign;
        struct  TDBX *tdbxNext;
        HANDLE  tdbxNTThreadHandle;
        HANDLE  tdbxVxDBlockOnIDEvent;
        DWORD   tdbxVxDBlockOnIDID;
        WORD    tdbxCurrentPSP;
        WORD    tdbxAlign2;
        DWORD   tdbxVxDMutexTry;
        DWORD   tdbxVxDMutexGrant;
#endif  // def WOW
} TDBX;

typedef struct TDBX *PTDBX;

// bit numbers of flags in tdbxWaitExFlags
#define TDBX_WAITEXBIT                  0       // wait includes APCs
#define TDBX_WAITEXBIT_MASK             (1 << TDBX_WAITEXBIT)
#define TDBX_WAITACKBIT                 1       // set once during wake
#define TDBX_WAITACKBIT_MASK            (1 << TDBX_WAITACKBIT)
#define TDBX_SUSPEND_APC_PENDING        2       // kernel mode APC pending
#define TDBX_SUSPEND_APC_PENDING_MASK   (1 << TDBX_SUSPEND_APC_PENDING)
#define TDBX_SUSPEND_TERMINATED         3       // thread has resumed
#define TDBX_SUSPEND_TERMINATED_MASK    (1 << TDBX_SUSPEND_TERMINATED)
#define TDBX_BLOCKED_FOR_TERMINATION    4       // thread is blocked for term
#define TDBX_BLOCKED_FOR_TERMINATION_MASK (1 << TDBX_BLOCKED_FOR_TERMINATION)
#define TDBX_EMULATE_NPX                5       // thread is using FP emulator
#define TDBX_EMULATE_NPX_MASK           (1 << TDBX_EMULATE_NPX)
#define TDBX_WIN32_NPX                  6       // thread uses Win32 FP model
#define TDBX_WIN32_NPX_MASK             (1 << TDBX_WIN32_NPX)
#define TDBX_EXTENDED_HANDLES           7       // uses extended file handles
#define TDBX_EXTENDED_HANDLES_MASK      (1 << TDBX_EXTENDED_HANDLES)
#define TDBX_FROZEN                     8       // thread is frozen
#define TDBX_FROZEN_MASK                (1 << TDBX_FROZEN)
#define TDBX_DONT_FREEZE                9       // don't frozen the thread
#define TDBX_DONT_FREEZE_MASK           (1 << TDBX_DONT_FREEZE)
#define TDBX_DONT_UNFREEZE              10      // keep the thread frozen
#define TDBX_DONT_UNFREEZE_MASK         (1 << TDBX_DONT_UNFREEZE)
#define TDBX_DONT_TRACE                 11      // don't trace the thread
#define TDBX_DONT_TRACE_MASK            (1 << TDBX_DONT_TRACE)
#define TDBX_STOP_TRACING               12      // stop tracing the thread
#define TDBX_STOP_TRACING_MASK          (1 << TDBX_STOP_TRACING)
#define TDBX_WAITING_FOR_CRST_SAFE      13      // waiting thread to get safe
#define TDBX_WAITING_FOR_CRST_SAFE_MASK (1 << TDBX_WAITING_FOR_CRST_SAFE)
#define TDBX_CRST_SAFE                  14      // we know this thread is safe
#define TDBX_CRST_SAFE_MASK             (1 << TDBX_CRST_SAFE)
#define TDBX_WTUSROWNMTX                15      // thread waited in user with VxD Mutex Owned
#define TDBX_WTUSROWNMTX_MASK           (1 << TDBX_WTUSROWNMTX)
#define TDBX_THREAD_NOT_INIT            17      // thread init not complete
#define TDBX_THREAD_NOT_INIT_MASK       (1 << TDBX_THREAD_NOT_INIT)
#define TDBX_BLOCK_TERMINATE_APC        18
#define TDBX_BLOCK_TERMINATE_APC_MASK   (1 << TDBX_BLOCK_TERMINATE_APC)
#define TDBX_TERMINATING                19
#define TDBX_TERMINATING_MASK           (1 << TDBX_TERMINATING)

// Special block ids (added to tdbx address)
#define TDBX_BLOCK_TERMINATE_APC_ID     0x00569595
#define TDBX_BLOCKED_FOR_TERMINATION_ID 0x00289816

// Equates for thread priority boosting by ring 3 code
#define HIGH_PRI_DEVICE_BOOST   0x00001000
#define LOW_PRI_DEVICE_BOOST    0x00000010
#define KERNEL_EXIT_PRI_BOOST   8

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\uni.inc ===
page    ,132            ; :ts=8
        TITLE   Unicode Translation Descriptions

;----------------------------------------------------------------------------
;  TITLE:
;    UNI.INC
;    Microsoft Confidential
;    Copyright (C) Microsoft Corporation 1993
;    All Rights Reserved.
;
;  DESCRIPTION:
;    The file contains the structures and equates used by the Unicode
;    translation and parsing code.
;
;  MODIFICATION HISTORY:
;----------------------------------------------------------------------------

;--------------------------------------------------------------------------
; Flags returned by UniToBCS, BCSToUni, UniToBCSPath, MapUniToBCS
; MapBCSToUni.  The flags indicate whether a mapping from UNICODE
; to BCS, or BCS to UNICODE have lost information.  This occurs
; whenever a char cannot be mapped.
;--------------------------------------------------------------------------
MAP_FLAG_LOSS          equ     00001h
MAP_FLAG_TRUNCATE      equ     00002h

;--------------------------------------------------------------------------
;   Equates used to identify special character types
;--------------------------------------------------------------------------
BCS_REPL_CHAR   equ     '_'
UNI_REPL_CHAR   equ     0fffdh

;--------------------------------------------------------------------------
;   Equates used in the construction of auto-generated names
;--------------------------------------------------------------------------
AUTO_BASIS_SEP  equ     '~'
AUTO_MIN_TAIL   equ     1
AUTO_MAX_TAIL   equ     9999999

OEM_INDEX       equ     1               ; Equate defining the entry in the translation
                                        ; table ptr array (utbPtrTable) to be used as
                                        ; the default OEM codepage when auto-generating
                                        ; short names.

MAX_CHAR_SETS   equ     2               ; Maximum # of entries in utbPtrTable array.

;--------------------------------------------------------------------------
;   Auto-generation flags returned from CreateBasis()
;--------------------------------------------------------------------------
UFLG_LOSS       equ     00000010h
UFLG_TRUNC      equ     00000020h
UFLG_UPCASE     equ     00000040h


;--------------------------------------------------------------------------
;       translation table structures
;--------------------------------------------------------------------------
tTree           struct
  Lnode         dw      ?       ; Offset, relative to tTree[0], of the
                                ; left child of this tree node.
  Rnode         dw      ?       ; Offset, relative to tTree[0], of the
                                ; right child of this tree node.
  Lval          dw      ?       ; Value of the left-hand (ordinally low)
                                ; inclusive endpoint of the encoding run
                                ; represented by this tree node.
  Rval          dw      ?       ; Value of the right-hand (ordinally high)
                                ; inclusive endpoint of the encoding run
                                ; represented by this tree node.
  RunOffset     dd      ?       ; Offset, relative to tTree[0], of the start
                                ; of the encoding run for this tree node.
tTree           ends

;--------------------------------------------------------------------------
;       BCS->UNICODE mapping struct
;--------------------------------------------------------------------------
btuTreeStruct   struct
  btuCodeSize   dd      (256/32) dup (?)
  btuTree       tTree   <>      
btuTreeStruct   ends

;--------------------------------------------------------------------------
;       UNICODE->BCS mapping struct
;--------------------------------------------------------------------------
utbTreeStruct   struct
  utbTree       tTree   <>      
utbTreeStruct   ends


LAST_CASE_MAPPED_UNI_CHAR       equ     0586h


;* Token values for the UniToUpperTable.

NUL equ 0       ; nul terminator
PTH equ 1       ; path separator (\ or /)
INV equ 2       ; invalid character
SPC equ 3       ; space
STAR equ 4      ; asterisk (*)
QUST equ 5      ; question mark (?)
DOT equ 6       ; period (.) character
OKL equ 7       ; OK in long names
OKA equ 8       ; OK in all names
LC_BASE equ 10
L_1 equ LC_BASE
L_2 equ LC_BASE + 1*2
L20 equ LC_BASE + 2*2
L26 equ LC_BASE + 3*2
L2f equ LC_BASE + 4*2
L30 equ LC_BASE + 5*2
L36 equ LC_BASE + 6*2
L39 equ LC_BASE + 7*2
L3e equ LC_BASE + 8*2
L3f equ LC_BASE + 9*2
L40 equ LC_BASE + 10*2
L4f equ LC_BASE + 11*2
L50 equ LC_BASE + 12*2
L56 equ LC_BASE + 13*2
L8c equ LC_BASE + 14*2
Lca equ LC_BASE + 15*2
Lcb equ LC_BASE + 16*2
Lcd equ LC_BASE + 17*2
Lce equ LC_BASE + 18*2
Lcf equ LC_BASE + 19*2
Ld1 equ LC_BASE + 20*2
Ld2 equ LC_BASE + 21*2
Ld3 equ LC_BASE + 22*2
Ld5 equ LC_BASE + 23*2
Ld6 equ LC_BASE + 24*2
Ld9 equ LC_BASE + 25*2
Lda equ LC_BASE + 26*2
Ldb equ LC_BASE + 27*2
Le8 equ LC_BASE + 28*2
Lff87 equ LC_BASE + 29*2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\spoolipc.inc ===
;/* spoolmsg.inc
if 0

 Description:

 Created: Chia-Chi Teng

*/
// ----------------------------------------------------------------
// C stuff goes here

#define SPOOL_PROCESS_CLASS             "SpoolProcessClass"

#define MAX_PARAM                       10

#define WM_OPENPRINTER                  WM_USER + 1
#define WM_STARTDOCPRINTER              WM_USER + 2
#define WM_STARTPAGEPRINTER             WM_USER + 3
#define WM_WRITEPRINTER                 WM_USER + 4
#define WM_ENDPAGEPRINTER               WM_USER + 5
#define WM_ENDDOCPRINTER                WM_USER + 6
#define WM_CLOSEPRINTER                 WM_USER + 7
#define WM_ABORTPRINTER                 WM_USER + 8

#define WM_ENUMPRINTERS                 WM_USER + 9
#define WM_SETJOB                       WM_USER + 10

#define WM_GETJOB                       WM_USER + 11
#define WM_ENUMJOBS                     WM_USER + 12
#define WM_ADDPRINTER                   WM_USER + 13
#define WM_DELETEPRINTER                WM_USER + 14
#define WM_ADDPRINTERCONNECTION         WM_USER + 15
#define WM_DELETEPRINTERCONNECTION      WM_USER + 16
#define WM_SETPRINTER                   WM_USER + 17
#define WM_GETPRINTER                   WM_USER + 18
#define WM_ADDPRINTERDRIVER             WM_USER + 19
#define WM_ENUMPRINTERDRIVERS           WM_USER + 20

#define WM_GETPRINTERDRIVER             WM_USER + 21
#define WM_GETPRINTERDRIVERDIRECTORY    WM_USER + 22
#define WM_DELETEPRINTERDRIVER          WM_USER + 23
#define WM_ADDPRINTPROCESSOR            WM_USER + 24
#define WM_ENUMPRINTPROCESSORS          WM_USER + 25
#define WM_GETPRINTPROCESSORDIRECTORY   WM_USER + 26
#define WM_ENUMPRINTPROCESSORDATATYPES  WM_USER + 27
#define WM_READPRINTER                  WM_USER + 28
#define WM_ADDJOB                       WM_USER + 29
#define WM_SCHEDULEJOB                  WM_USER + 30

#define WM_GETPRINTERDATA               WM_USER + 31
#define WM_SETPRINTERDATA               WM_USER + 32
#define WM_WAITFORPRINTERCHANGE         WM_USER + 33
#define WM_ENUMPORTS                    WM_USER + 34
#define WM_ENUMMONITORS                 WM_USER + 35
#define WM_ADDPORT                      WM_USER + 36
#define WM_CONFIGUREPORT                WM_USER + 37
#define WM_PRINTERMESSAGEBOX            WM_USER + 38
#define WM_ADDMONITOR                   WM_USER + 39
#define WM_DELETEMONITOR                WM_USER + 40

#define WM_DELETEPRINTPROCESSOR         WM_USER + 41
#define WM_ADDPRINTPROVIDOR             WM_USER + 42
#define WM_DELETEPRINTPROVIDOR          WM_USER + 43
#define WM_DELETEPORT                   WM_USER + 44

#define WM_ENUMPORTSEX                  WM_USER + 45
#define WM_ADDPORTEX                    WM_USER + 46
#define WM_ABORTANDCLOSEPRINTER         WM_USER + 47

// this is for the real IPC
#define SPOOL_MUTEX                     "SpoolMutex"
#define SPOOL_DATA_EVENT                "SpoolDataEvent"
#define SPOOL_RETURN_EVENT              "SpoolReturnEvent"

typedef struct _SPOOLER_IPC_DATA {
    DWORD dwProcID;
    HANDLE hMutex;
    HANDLE hDataEvent;
    HANDLE hReturnEvent;
    struct _SPOOLER_IPC_DATA *pNext;
    DWORD flFlags;
    DWORD dwReserved1;
    DWORD dwReserved2;
} SPOOLER_IPC_DATA, *PSPOOLER_IPC_DATA;


/*
endif
; ----------------------------------------------------------------
; ASM stuff goes here

WM_OPENPRINTER          EQU     0401h
WM_CLOSEPRINTER         EQU     0407h

SPOOLSTRUC      struc
spool_id        dd      ?               ;ProcessID
spool_h1        dd      ?               ;Handle
spool_h2        dd      ?               ;Handle
spool_h3        dd      ?               ;Handle
spool_pnext     dd      ?               ;Pointer to Next
spool_flfalgs   dd      ?               ;flFlags
spool_resv1     dd      ?               ;reserved
spool_resv2     dd      ?               ;reserved
SPOOLSTRUC      ends

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\thkshare.inc ===
;*****************************************************************************
;*  THKSHARE.INC
;*
;*      Thunk shared data between Kernel16 and Kernel32.
;*
;*  Created: 23-Aug-93 [KevinR]
;*
;****************************************************************************

;
; Thunk shared data between Kernel16 and Kernel32.
;
THUNKDATA STRUC
td_dwSize               dd  ?  ;Used for version checking
td_pfnC32ThkSL          dd  ?  ;0:32 ptr to 32-bit setup code for 16=>32 thunks
td_pfnC32ThkSL01        dd  ?  ;0:32 ptr to 32-bit setup code for 16=>32 thunks
td_pfnKrn32ThkSL        dd  ?  ;0:32 ptr, krnthksl entry pt., 16=>32 thk
td_TargetTable16ThkLSF  dd  ?  ;16:16 ptr, krnfthk target table, 32=>16 flat thk
td_pfnCommon16ThkLSF    dd  ?  ;16:16 ptr to 16-bit cleanup, 32=>16 flat thk
td_pfnCommon16ThunkFTLSFWin32Lock       dd  ?  ;16:16 ptr to 16-bit cleanup, 32=>16 flat thk
td_pfnCommon16ThunkQTLSFWin32Lock       dd  ?  ;16:16 ptr to 16-bit cleanup, 32=>16 flat thk
td_pfnCommon16ThunkFTLSFWin16Lock       dd  ?  ;16:16 ptr to 16-bit cleanup, 32=>16 flat thk
td_pfnCommon16ThunkQTLSFWin16Lock       dd  ?  ;16:16 ptr to 16-bit cleanup, 32=>16 flat thk
td_pfnCommon16ThunkQTLSFWin32NoLock     dd  ?  ;16:16 ptr to 16-bit cleanup, 32=>16 flat thk
td_pfLogLS              dd  ?  ;16:16 addr of flag to control API logging
td_Checksum16SL         dd  ?  ;kernel16 16=>32 checksum
td_Checksum16LSF        dd  ?  ;kernel16 flat 32=>16 checksum
td_pfnOleDispatchLS     dd  ?  ;flat addr of k32's OLE LS dispatch wrapper
td_pfnK16LateBind       dd  ?  ;16:16 address of K16 late-bind fixup routine.
td_lpThunkWhineLevel    dd  ?  ;16:16 addr of K16 thunk debugging variable
td_pfnWOWCallback16Helper dd ? ;16:16 addr of K16 WOWCalback16 stub
td_lpCountFreeSel       dd  ?  ;16:16 addr of K16 CountFreeSel variable
td_lpwLRThresh          dd  ?  ;16:16 addr of K16 wLRThresh variable
td_lpSCallRet           dd  ?  ;16:16 addr of K16 SCallRet label
THUNKDATA ENDS




;
; Structure of a version 'LS01' common data block:
;

TDLS_01_VERSION equ     3130534ch

TDLS32_01  STRUCT
dwVersion       dd      ?       ;Statically set to "LS01"
dwChecksum      dd      ?       ;Statically set to checksum
lpJumpTable     dd      ?       ;Dynamically set to flat address of jump table
dwLBSig         dd      ?       ;Statically set to "LB01"
dwFlags         dd      ?       ;Flags
dwUnused1       dd      ?       
dwUnused2       dd      ?
lpRelQTP        dd      ?       ;Self-relative ptr to QT_Thunk_* patch area
lpRelFPP        dd      ?       ;Self-relative ptr to FT_Prolog_* patch area
TDLS32_01  ENDS

TDLS16_01  STRUCT
dwVersion       dd      ?       ;Statically set to "LS01"
dwChecksum      dd      ?       ;Statically set to checksum
lpJumpTable     dd      ?       ;Statically set to segmented address of jump table
dwFlags         dd      ?       ;Flags
TDLS16_01  ENDS

TDLS16_01F_JumpTableFixed equ 000000001h ;Run-time flag to indicate the jump table has been 
                                       ;  GlobalFixed
TDLS16_01F_TC16Ran        equ 000000002h ;Run-time flag to indicate successful ThunkConnect16




;
; Structure of a version 'SL01' common data block:
;

TDSL_01_VERSION equ     31304c53h

MAX_THKDLL_NAME equ     255

TDSL16_01  STRUCT
dwVersion       dd      ?       ;Statically set to "SL01"
dwChecksum      dd      ?       ;Statically set to checksum
dwFlags         dd      ?       ;Flags
dwApiTable      dd      ?       ;16:16 ptr to api information table
hMod16          dw      ?       ;hModule of 16-bit dll
wBaseTable      dw      ?       ;Win16 movable global handle -- multi-base mode
dwNEntries      dd      ?       ;# of entries avaialble in MBA table.
dwNUsed         dd      ?       ;# of entries used in MBA table.
dwExFlags       dd      ?       ;More flags
pszDll16Name    db      (MAX_THKDLL_NAME+1) dup(0)   ;0-terminated dll16 name
pszDll32Name    db      (MAX_THKDLL_NAME+1) dup(0)   ;0-terminated dll16 name
TDSL16_01  ENDS



; This is the version that's passed into ThunkConnect16. Since
; this block lives in the dll's dgroup, we don't want to lock it

TDSL16_01P  STRUCT
tsl16p_dwVersion        dd      ?       ;Statically set to "SL01"
tsl16p_dwChecksum       dd      ?       ;Statically set to checksum
tsl16p_dwFlags          dd      ?       ;Flags (Statically set)
tsl16p_dwUnused1        dd      ?       ;Reserved (set to 0)
tsl16p_lp32TD16         dd      ?       ;32:0 address to TDSL16_01 structure
tsl16p_lp16TD16         dd      ?       ;16:0 ptr to TDSL16_01 (some old code needs this)
tsl16p_dwUnused2        dd      ?       ;Reserved (set to 0)
tsl16p_dwLBSig          dd      ?       ;Statically set to "LB01" sig
tsl16p_dwExFlags        dd      ?       ;Reserved (set to 0)
tsl16p_dwUnused4        dd      ?       ;Reserved (set to 0)
tsl16p_dwApiTable       dd      ?       ;16:16 ptr to api information table
TDSL16_01P  ENDS


TDSL16_01F_TC16Ran      equ 000000001h ;Set on *successful* completion of ThunkConnect16 (INC)

TDSL16_01FEx_fPreload   equ 080000000h ;Set by thunk compiler to eagerly load
                                       ;  Win32 partner
TDSL16_01FEx_fWin31     equ 040000000h ;Mark for win3.1 legacy dll's

MBA_USAGE_COUNT_CUTOFF  equ 010000h    ;MBA entries smaller than this
                                       ; are virtual ref counts, rather than
                                       ; base addresses.




TDSL32_01  STRUCT
dwVersion       dd      ?       ;Statically set to "SL01"
dwChecksum      dd      ?       ;Statically set to checksum
lpOldJunk       dd      ?       ;Not used anymore. MUST IGNORE
lpThkData16     dd      ?       ;Flat address of ThunkData16
dwLBSig         dd      ?       ;Statically set to "LB01"
dwFlags         dd      ?       ;Flags 
dwUnused1       dd      ?       ;Statically set to 0
dwUnused2       dd      ?       ;Statically set to 0
dwRelJumpTable  dd      ?       ;Jump Table ptr relative to name export string
TDSL32_01  ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\vmda.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1988-1990
 *
 *   Title:	VMDA.H - Include file for VMDOSAPP/GRABBER SHELL interaction
 *
 *   Version:	1.00
 *
 *   Date:	05-May-1988
 *
 *   Author:	ARR
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *      DATE	REV		    DESCRIPTION
 *   ----------- --- ----------------------------------------------------------
 *   05-May-1988 ARR Original
 *   15-Jul-1982 rjc Converted from vmda.inc to vmda.h
 *
 *****************************************************************************/

/*
 * EQUATES for VMDOSAPP device calls
 */
#define	SHELL_Call_Dev_VDD	0x0000A	/* Actually GRABBER services */

/*
 * SHELL VMDA interface services.  All services not listed here are reserved
 * for internal use.
 */
#define	SHELL_Debug_Out 	   8

/*
 * THIS IS THE MAXIMUM SIZE IN BYTES OF THE INFO RETURNED ON
 *	VDD CALLS OTHER THAN GET CONTOLLER STATE MADE BY THE GRABBER
 *
 * This is the size of an area reserved for use on grabber calls
 */
#ifdef NEC_98
#define	VDD_MOD_MAX		320
#else	// NEC
#define	VDD_MOD_MAX		256
#endif	// NEC

/*
 * THIS IS THE MAXIMUM SIZE IN BYTES OF THE INFO RETURNED ON
 *	THE GET CONTOLLER STATE VDD CALL MADE BY THE GRABBER
 *
 * This is the size of an area reserved for use on this grabber call
 */
#ifdef NEC_98	// NEC 940323 AVFrameMaxOff,AVFrameMaxAddr Add
#define	VDD_CTRL_STATE_MAX	1310
#else	// NEC
#define	VDD_CTRL_STATE_MAX	128
#endif	// NEC

/*
 * Stuff specific to VMDA events
 */

#define	WMX_USER		  0x0400

/* ASM
INCLUDE VDDGRB.INC
*/
/* ASM
.ERRE VDA_Type_Chng	EQ	((WMX_USER+20)+2) ; Defined in VDDGRB.INC!!
.ERRE VDA_Display_Event EQ	((WMX_USER+20)+6) ; Defined in VDDGRB.INC!!
*/

/* All other VDA_* values are reserved for internal use */

/*
 * lParam is ALWAYS the "Event ID". This is used on the VMDOSAPP call backs
 *  to the shell to identify the event which is being processed.
 */

/*
 * On VDA_Display_Message event, wParam == 0 if normal message
 *				       != 0 if ASAP or SYSMODAL message
 *   VMDOSAPP instance which gets the message is messaging VM
 */

/*
 * On VDA_Type_Chng event, wParam is not used
 *   VMDOSAPP instance which gets the message has had its type changed by
 *   protected mode code
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\w32base.h ===
//	w32base.h
//
//	Base address of kernel32.dll
//
//      If you change this file, you must change core\win32\coffbase.txt
//      to match.

#define DLLMaxImageSize (0x0009f000)

#ifndef WOW

#ifdef  WOW
#define DLLMemoryBase   (0x5e000000)
#else   // WOW
#define DLLMemoryBase   (0xbff60000)
#endif  // else WOW
#define Kernel32Base	(DLLMemoryBase)
#define Kernel32Limit	(Kernel32Base + DLLMaxImageSize)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\vmdapriv.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1988-1995
 *
 *   Title:	VMDAPRIV.H - Include file for VMDOSAPP/SHELL interaction
 *
 *   Version:	2.00
 *
 *   Date:	13-Aug-1994
 *
 *   Author:	rjc
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *      DATE	REV		    DESCRIPTION
 *   ----------- --- ----------------------------------------------------------
 *   05-May-1988 ARR Original
 *   15-Jul-1982 rjc Converted from vmda.inc to vmda.h
 *   13-Aug-1992 rjc Split private stuff into vmdapriv.h
 *   11-Nov-1994 rjc Moved inter-module msgsrv32 stuff here, too.
 *
 *****************************************************************************/

/******************************************************************************
 ******************************************************************************
 *
 *	MSGSRV32
 *
 ******************************************************************************
 *****************************************************************************/

/******************************************************************************
 *
 * SZMESSAGESERVERCLASS is the class name for the message server.
 * There is no title.
 *
 * To locate the message server, just do a
 *
 *	static char CODESEG szMessageServer[] = SZMESSAGESERVER;
 *	hwnd = FindWindow(szMessageServer, 0);
 *
 *****************************************************************************/

#define SZMESSAGESERVERCLASS	    "Windows 32-bit VxD Message Server"

/******************************************************************************
 *
 * INH_DEVICEBROADCAST -- Broadcast a message to VxDs.
 *
 *	wParam = not used
 *      lParam = far pointer to INTERNALBROADCASTSYSMSG
 *
 *****************************************************************************/

#if 0
    typedef WORD WPARAM;
    typedef LONG LPARAM;
#endif

/* H2INCSWITCHES -t */

typedef struct INTERNALBROADCASTSYSMSG {   /* bsm */
    WORD        uiMessage;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       dwFlags;
} INTERNALBROADCASTSYSMSG, FAR *LPINTERNALBROADCASTSYSMSG;

/* H2INCSWITCHES -t- */

/*ASM
DBWF_LPARAMPOINTER	= 8000h
 */

#define INH_DEVICEBROADCAST	0x0500

/******************************************************************************
 *
 * INH_LOGONTONET -- Posted from user to msgsrvr to log onto net and run
 *                   the shell.  Also used to exec the shell if it faults.
 *	wParam = if 0, logon to net. if 1, just exec the shell.
 *      lParam = not used
 *
 *****************************************************************************/

#define INH_LOGONTONET		0x0501

/******************************************************************************
 *
 * INH_CHECKSYSTEMDLLS - Posted from user to msgsrvr to tell us to check
 *                       system dlls if they have been bogusly replaced
 *	wParam = not used
 *      lParam = not used
 *
 *****************************************************************************/

#define INH_CHECKSYSTEMDLLS	0x0502

/******************************************************************************
 *
 * INH_USEME503	-- Not used, please recycle
 * INH_USEME504 -- Not used, please recycle
 *
 *****************************************************************************/

#define INH_USEME503		0x0503
#define INH_USEME504		0x0504

/******************************************************************************
 *
 * INH_APPYTIME -- It is now 'Appy-time
 *
 *	wParam = not used
 *      lParam = not used
 *
 *****************************************************************************/

#define INH_APPYTIME     	0x0505

/******************************************************************************
 *
 * INH_FORWARDTOSHELL -- Forward a WM_SHELLNOTIFY to the current shell window
 *
 *	wParam = forwarded to GetShellWindow()
 *	lParam = forwarded to GetShellWindow()
 *
 *****************************************************************************/

#define INH_FORWARDTOSHELL	0x0506

/******************************************************************************
 *
 * INH_FREEDRIVERS - Message posted from user telling us to free installable
 *                   drivers for compatibility with Win3.1
 *	wParam = id code we pass back to user's UnloadInstallableDrivers
 *		 function
 *      lParam = not used
 *
 *****************************************************************************/

#define INH_FREEDRIVERS  	0x0507

/******************************************************************************
 *
 * INH_PLAYEXITSOUND - Message posted from user telling us to play the exit 
 *                     Windows sound.
 *	wParam = not used
 *      lParam = not used
 *
 *****************************************************************************/

#define INH_PLAYEXITSOUND  	0x0508

/******************************************************************************
 *
 * INH_UNIDRVLOADED - Message posted from unidrv to us so that we can
 *			cache the printer driver after it loads.
 *            
 *	wParam = INH_UNIDRVLOADED_WPARAM (signature)
 *      lParam = INH_UNIDRVLOADED_LPARAM (signature)
 *
 *****************************************************************************/

#define INH_UNIDRVLOADED  	0x0509
#define INH_UNIDRVLOADED_WPARAM     0
#define INH_UNIDRVLOADED_LPARAM     0

/******************************************************************************
 *
 * INH_UNIDRVUNLOAD - Message sent from print installer to us so that we can
 *		      forceably tell msgsrvr to uncache this.
 *            
 *	wParam = INH_UNIDRVUNLOAD_WPARAM (signature)
 *      lParam = INH_UNIDRVUNLOAD_LPARAM (signature)
 *
 *****************************************************************************/

#define INH_UNIDRVUNLOAD  	0x050A
#define INH_UNIDRVUNLOAD_WPARAM     0
#define INH_UNIDRVUNLOAD_LPARAM     0


/******************************************************************************
 ******************************************************************************
 *
 *	VMDOSAPP / SHELL / USER
 *
 ******************************************************************************
 *****************************************************************************/


/*
 * This file contains manifest constants for VMDOSAPP/SHELL interaction
 * which are private to DOS386 and should not be exposed in the DDK.
 */

/*
 * EQUATES for VMDOSAPP device calls
 */
#define	SHELL_Call_Dev_VMD	0x0000C
#define	SHELL_Call_Dev_VKD	0x0000D
#define	SHELL_Call_Dev_SHELL	0x00017
#define	SHELL_Call_Dev_VCOND	0x00038
#ifdef FE_VIME
#define	SHELL_Call_Dev_VIME	0x00064
#endif

/*
 * SHELL VMDA interface services
 */
#define	SHELL_Get_Ver		   0
#define	SHELL_Get_Sys_VM_Info	   1	/* Used by 3.1 control panel (stub) */
#define	SHELL_Set_Sys_VM_Info	   2	/* Used by 3.1 control panel (stub) */
#define	SHELL_Create_VM		   3	/* Stupid C7 uses this; go figure */
					/* Brown has rev-engineered it, too */
#define	SHELL_Destroy_VM	   4
#define	SHELL_Set_Focus 	   5
#define	SHELL_Get_VM_State	   6
#define	SHELL_Set_VM_State	   7
/* #define SHELL_Debug_Out 	   8 */	/* Defined in vmda.h */
#define	SHELL_VMDA_Init 	   9
#define	SHELL_VMDA_Exit 	  10
#define	SHELL_Get_Message_Text	  11
#define	SHELL_Event_Complete	  12
#define	SHELL_Get_Contention_Info 13
#define	SHELL_Get_Clip_Info	  14
#define	SHELL_Set_Paste 	  15
#define	SHELL_Switcher_Assist	  16
#define	SHELL_Do_Not_Use 	  17	/* Do not recycle */
#define	SHELL_Query_Destroy	  18
/*
 * WARNING: The following two entries are used by Windows KERNEL/USER.
 *	   Do not change them without also changing KERNEL/USER.
 */
#define	SHELL_SetFocus_Cur_VM	  19
#define	SHELL_User_Busy		  20	 /* Old name (not used) */
#define SHELL_Set_Hotkey_Info	  20	 /* New name */

#define	SHELL_Chng_Hot_Key	  21	 /* Old name (not used) */
#define	SHELL_Get_Hotkey_Info	  21	 /* New name */
#define	SHELL_Get_TermInfo	  22

#define SHELL_Check_Hotkey_Allowed 23	 /* See if a focus change is ok */
#define SHELL_UseMe24		  24	 /* Available for use */

/*
 * These are used by the WShell server during system startup
 * for various reasons...
 */
#define SHELL_AppyRegister	  25	/* 'Appy-time status report */
#define SHELL_Get_VM_Descriptor	  26
#define SHELL_DispatchAppyEvents  27	/* It is now 'Appy time */
#define SHELL_DispatchBroadcastHooks 28	/* Goofy broadcast received */

#define SHELL_GetServerHwnd	  29	/* Called by USER! */

#define SHELL_GetSet_VM_Title	  30
#define SHELL_Get_Close_Flags	  31
#define SHELL_Initiate_Close	  32
#define SHELL_Cancel_Close	  33

#define SHELL_Grab_Failed	  34

#define SHELL_Get_Protection_Info 35

#define SHELL_Freeze_VM		  36
#define SHELL_Thaw_VM		  37

#define SHELL_Set_Focus_Sys_VM	  38	/* Used by Win31.exe */

#define SHELL_Final_VM_Cleanup	  39

/*
 * NOTE!  When adding a new service code, add them here, *before* the
 * DOS7 ordinals.  (Renumber the DOS7 ordinals accordingly.)
 */

#ifdef	DOS7
#define SHELL_Get_New_VM_Handle   ??	/* VM enumeration for inheriting */
#define SHELL_Get_Next_VM_Handle  ??
#define SHELL_Get_Clipboard_Size  ??	/* Clipboard importation */
#define SHELL_Copy_Clipboard_Data ??
#endif

/******************************************************************************
 *
 * Window private bytes...
 *
 *  WindowLong(GWL_TTY_PID) =
 *	process ID for process currently running in DOS box
 *
 *  WindowLong(GWL_TTY_TID) =
 *	thread ID for process currently running in DOS box
 *
 *  Valid only if window class is the top-level unowned window for WinOldAp
 *  (classname = "tty").
 *
 *****************************************************************************/

#define GWL_TTY_PID	0
#define GWL_TTY_TID	4


/******************************************************************************
 *
 * Message numbers
 *
 *****************************************************************************/

#define	WMX_USER		  0x0400


/******************************************************************************
 *
 * Messages WMX_USER+0 through WMX_USER+19 are reserved for
 * internal use by WinOldAp.
 *
 *****************************************************************************/

/******************************************************************************
 *
 * Messages WMX_USER+20 through WMX_USER+255 are reserved for
 * WinOldAp / WShell interaction, with exceptions as noted below.
 *
 *****************************************************************************/

/*
 * Messages WMX_USER+20 through WMX_USER+255 are reserved
 *
 * Be extra careful not to change the meanings of any of the
 * messages from WMX_USER+20 through WMX_USER+20+13, because
 * those messages were used by Windows 3.1 and were documented
 * in the DDK (What were we thinking!?!!?), so some hosebags
 * might actually send them.
 *
 * VDA_Terminated is sent by the 3DPC screen saver.  What's more,
 * they send it incorrectly!  So watch out when you process it...
 */

#define VDA_First		(WMX_USER+20+0)

/******** BEGIN -- DO NOT CHANGE THESE -- BEGIN ********/

#define	VDA_Hot_Key		(WMX_USER+20+0)
#define	VDA_Switch_Context	(WMX_USER+20+1)
#ifndef VDA_Type_Chng
#define VDA_Type_Chng		(WMX_USER+20+2) /* Defined in VDDGRB.INC */
#endif
#define	VDA_ClipBrd_Event	(WMX_USER+20+3)
#define	VDA_Terminated		(WMX_USER+20+4)
#define	VDA_Display_Message	(WMX_USER+20+5)
#ifndef VDA_Display_Event
#define VDA_Display_Event	(WMX_USER+20+6) /* Defined in VDDGRB.INC */
#endif
#define	VDA_Crash_Event 	(WMX_USER+20+7) /* OBSOLETE!  DO NOT RECYCLE */
#define	VDA_Paste_Complete	(WMX_USER+20+8)
#define	VDA_Contention		(WMX_USER+20+9)
#define	VDA_Start_SwitchScn	(WMX_USER+20+10)
#define VDA_FileSysChange	(WMX_USER+20+11) /* OBSOLETE! DO NOT RECYCLE */
#define	VDA_CheckFocus		(WMX_USER+20+12)
#define	VDA_Switch_CntxtPanic	(WMX_USER+20+13)

/******** END -- DO NOT CHANGE THESE -- END ********/

#define	VDA_Simulate_Hotkey	(WMX_USER+20+14)
#define VDA_Set_VM_Title	(WMX_USER+20+15)
#define VDA_Cancel_Close	(WMX_USER+20+16)
#define VDA_Change_CodePage	(WMX_USER+20+17) /* Used by JAPAN */
#define VDA_VM_Started		(WMX_USER+20+18)
#define VDA_Protection_Event    (WMX_USER+20+19)
#define VDA_Close_Clipboard	(WMX_USER+20+20)
#define VDA_Flash_Icon		(WMX_USER+20+21)
#define VDA_Notify_Close_Change (WMX_USER+20+22)
#define VDA_DynaWindow		(WMX_USER+20+23)
#define VDA_Screensave 		(WMX_USER+20+24)
#define VDA_SystemSleep		(WMX_USER+20+25)
#define VDA_MonitorPower    (WMX_USER+20+26)

#ifdef	DOS7
#define	VDA_Inherit_New_VM	?
#endif

#define VDA_Last		VDA_MonitorPower


/******************************************************************************
 *
 * Messages WMX_USER+256 through WMX_USER+511 are reserved for
 * WinOldAp / VConD interaction.
 *
 *****************************************************************************/

#define VDA_Console_Spawn		(WMX_USER+256)
#define VDA_Console_Set_Title		(WMX_USER+257)
#define VDA_Console_State_Change	(WMX_USER+258)
#define VDA_Console_Update_Window	(WMX_USER+259)

/* flags for Update Console Window message sent by Console code to WinOldAp*/
#define UCW_HSCROLL	0x0001
#define UCW_VSCROLL 	0x0002
#define UCW_SIZE     	0x0004

/* messages for native grabber in WinOldAp */
#define GRABMSG_NOMSG		0x0000	// Nothing to do
#define GRABMSG_REPAINT		0x0001	// Repaint a rectangle
#define	GRABMSG_MOVERECT	0x0002	// Move a rectangle
#define	GRABMSG_SETSCREEN	0x0004	// Set virtual screen size
#define	GRABMSG_SETCURPOS	0x0008	// Set virtual screen position
#define	GRABMSG_SETCURINFO	0x0010	// Set cursor (caret) position/size
#define	GRABMSG_CURTRACK	0x0020	// Position cursor in window
#define	GRABMSG_TERMINATE	0x0040	// Screen buffer is terminating

/* Display event codes for notification of VCOND by WOA.*/
#define DE_ICONIZE		1	// iconized
#define DE_SIZECHANGE		2	// user changed window size
#define DE_WINDOW		3	// changed from fullscreen to window
#define DE_FULLSCREEN		4	// changed from window to fullscreen
#define DE_BEGINSELECT		5	// begin selection
#define DE_ENDSELECT		6	// end selection
#define DE_NATIVEMODE		7	// enter native mode
#define DE_PHYSICALMODE		8	// enter physical mode

#ifdef FE_VIME
/******************************************************************************
 *
 * Messages WMX_USER+512 through WMX_USER+767 are reserved for
 * WinOldAp / VIME interaction.
 *
 *****************************************************************************/

#define VDA_Process_Key_Event		(WMX_USER+512)
#define VDA_Control_IME			(WMX_USER+513)
#define VDA_Init_VIMEUI			(WMX_USER+514)
#define VDA_Get_Keyboard_Layout		(WMX_USER+515)

/* Functions for VDA_Control_IME */
#define	VIME_CIME_SetOpenStatus		1
#define	VIME_CIME_SetCandidatePageStart	2
#define	VIME_CIME_SetCandidatePageSize	3
#define	VIME_CIME_EnableIME		4

/* Protect Mode API */
#define VIME_CMD_GetOption	2
#define VIME_CMD_Composition	3
#define VIME_CMD_CandOpen	4
#define VIME_CMD_CandClose	10
#define VIME_CMD_Draw		5
#define VIME_CMD_Return		6
#define VIME_CMD_Char		7
#define VIME_CMD_StartComp	8
#define VIME_CMD_EndComp	9
#define	VIME_CMD_OpenStatus	11
#define	VIME_CMD_ConversionMode	12
#define	VIME_CMD_SentenceMode	13
#define VIME_CMD_WindowState	14
#define VIME_CMD_KeyDown	15
#define VIME_CMD_CandChange	16
#define VIME_CMD_Paste		17
#define VIME_CMD_ReqChangeKL	18
#define VIME_CMD_KeyboardLayout	19
#define VIME_CMD_InstallVIME	20
#define VIME_CMD_GetSync	21

/* detail info for VIME_CMD_ChangeIME */
#define VIME_CHG_NonIME		1
#define VIME_CHG_OldIME		2
#define VIME_CHG_NonNative	3

#endif // FE_VIME

/*
 * This is a special "VMDOSAPP message" which actually results in no
 *   message being sent to VMDOSAPP. It is used internally by the SHELL
 *   to give the SYS VM a Boost, just as it does for normal events, but
 *   without sending VMDOSAPP a message.
 */
#define VDA_Nul_Boost_Event	0x0FFFF

/*
 * lParam is ALWAYS the "Event ID". This is used on the VMDOSAPP call backs
 *  to the shell to identify the event which is being processed.
 */

/*
 * On VDA_Hot_Key event wParam is the Key identifier (See following EQUs)
 *   VMDOSAPP instance which gets the message is the "target" of the hot key
 */
#define	VDA_HK_ALTSPACE 	0
#define	VDA_HK_ALTENTER 	1
#define	VDA_HK_DIRVM		2

/*
 * On VDA_Terminated event wParam is 0 if this is a normal termination. If it is
 *   non-zero, use SHELL_Get_TermInfo to get error information.
 *   VMDOSAPP instance which gets the message has terminated.
 */

/*
 * NOTE that VDA_Crash_Event is very much like VDA_Terminated, the only
 *   real difference being the reason for the termination.
 *   Use SHELL_Get_TermInfo to get error information.
 *   wParam is not used
 *   VMDOSAPP instance which gets the message has crashed
 */

/*
 * On VDA_ClipBrd_Event, wParam is the Client_AX identifying the call.
 *   VMDOSAPP instance which gets the message had a clipboard event
 */

/* This next one is documented in vmda.h */
/*
 * On VDA_Display_Message event, wParam == 0 if normal message
 *				       != 0 if ASAP or SYSMODAL message
 *   VMDOSAPP instance which gets the message is messaging VM
 */

/*
 * On VDA_Paste_Complete event, wParam == 0 if normal completion
 *				      == 1 if paste canceled by user
 *				      == 2 if paste canceled for other reason
 *   VMDOSAPP instance which gets the message has completed paste
 */

/*
 * On VDA_Switch_Context event, wParam == 0 if context is switched to
 *   VMDOSAPP instance which gets the message (that VM now has focus)
 *   if wParam != 0, SYS VM now has the focus
 * VDA_Switch_CntxtPanic is an alternate form that should only occur with
 *   wParam != 0 and indicates that the Windows activation should be moved
 *   away from any VM (in other words, only a Windows app should be active
 *   now).
 */

/* This next one is documented in vmda.h */
/*
 * On VDA_Type_Chng event, wParam is not used
 *   VMDOSAPP instance which gets the message has had its type changed by
 *   protected mode code
 */

/*
 * On VDA_FileSysChange, SEE SHELLFSC.INC
 */

/*
 * VDA_CheckFocus This is sent as part of the Contention handling to deal with
 *   a case where the the Focus is manipulated and needs to get reset.
 *   wParam is not used.
 */

/* Reference data for VDA_Protection_Event
 */
#ifndef _WINNT_
typedef struct FAULTINFO {
        DWORD   FI_VM;
        DWORD   FI_CS;
        DWORD   FI_EIP;
        DWORD   FI_Addr;
} FAULTINFO;

typedef FAULTINFO *PFAULTINFO;
#endif

#ifdef _WSHIOCTL_H

/*****************************************************************************
 *
 * SHELL_Create_VM
 *
 * ES:EDI -> struct VM_Descriptor (see shellvm.h)
 * DS:SI -> struct VM_AppWizInfo
 *
 *  szProgram = program name, e.g., "C:\FOO.BAT" or "D:\BAR.EXE"
 *  szParams = command tail
 *  szDir = current directory at time of exec, e.g., C:\GAME
 *  szPifFile = PIF file that controls this app
 *		null string if PIF file belongs to command.com
 *		space if app didn't have a custom PIF (need to create one)
 *
 */

/* H2INCSWITCHES -t */

typedef struct VMAPPWIZINFO {		/* awi */
    char	szProgram[MAXVMPROGSIZE];
    char	szParams[MAXVMCMDSIZE];
    char	szDir[MAXVMDIRSIZE];
    char	szPifFile[MAXPIFPATHSIZE];
    BYTE	aAppFlags[4];		 /* 1 dword of flags */
} VMAPPWIZINFO, *PVMAPPWIZINFO;
/* H2INCSWITCHES -t- */

#endif /* _WSHIOCTL_H */

//
//  Flags for app hack bits
//
#define DAHF_SPECIALSETTINGS	    0x00000001	// App requires separate VM
#define DAHF_SPECIALSETTINGS_BIT    0		// (Winlie, SDAM, XMS cap...)
#define DAHF_NOPAGELOCKS	    0x00000002	// Ignore DPMI PageLocks
#define DAHF_NOPAGELOCKS_BIT	    1		// if not paging through DOS
#define DAHF_NOMSDOSWARN	    0x00000004	// Do not suggest SDAM
#define DAHF_NOMSDOSWARN_BIT	    2
#define DAHF_VALIDATELOCKS	    0x00000008	// Do not let DPMI app lock
#define DAHF_VALIDATELOCKS_BIT	    3		// memory it didn't allocate
#define DAHF_TRACESEGLOAD	    0x00000010	// Enable trace flag hack for
#define DAHF_TRACESEGLOAD_BIT	    4		// segment load faults
#ifdef	NEC_98
#define DAHF_MAXENVSIZE		    0x00000020	// Use maximize environment
#define DAHF_MAXENVSIZE_BIT	    5		// size(=0xffff) for apps like
						// Justsystem
#endif	//NEC_98


/*****************************************************************************
 *
 * SHELL_Get_TermInfo
 *
 * Private structure used to get detailed information when a VM crashed.
 *
 * If the VM terminated because the initial EXEC failed, the termination
 * error code will have high word zero and low byte equal to the DOS error
 * code.
 */

/* H2INCSWITCHES -t */

typedef struct VMFaultInfo2 {	/* VMFI2 */

    ULONG fl;			/* Flags (this lives in the same place
				 * as the TermVMHnd)
				 */

/* These fields form a TermStruc */

    ULONG TermErrCd;		/* Error code for termination */
    ULONG TermErrCdRef;		/* Reference data for termination */
    ULONG TermExitCode;		/* Application exit code */

/* These fields form a VMFaultInfo, meaningful only if we crashed. */
    ULONG EIP;			/* faulting EIP */
    WORD  CS;			/* faulting CS */
    WORD  Ints;			/* interrupts in service, if any */

/* These fields are valid only if the VM terminated by crashing */
    char  szCrashText[80];	/* Location of crash (if in a VxD) */
    char  VxdReported[9];	/* name of VxD who reported the crash */
} VMFAULTINFO2;

/*
 * Flags for vmfi2_fl.
 */
#define VMFI2FL_BLANKSCREEN	1	/* Screen is blank */
#define VMFI2FL_RING0CRASH	2	/* Crashed at ring 0 */

/* Error codes.
 *
 *  For VDAE_InsMemDev and VDAE_DevNuke the error ref data points to
 *	the 8 character device name.
 */
#define	VDAE_PrivInst		0x00010001	/* Privledged instruction */
#define	VDAE_InvalInst		0x00010002	/* Invalid instruction */
#define	VDAE_InvalPgFlt 	0x00010003	/* Invalid page fault */
#define	VDAE_InvalGpFlt 	0x00010004	/* Invalid GP fault */
#define	VDAE_InvalFlt		0x00010005	/* Invalid fault, not any of abv */
#define	VDAE_UserNuke		0x00010006	/* User requested NUKE of running */
						/*    VM */
#define	VDAE_DevNuke		0x00010007	/* Device specific problem */
#define	VDAE_DevNukeHdwr	0x00010008	/* Device specific prob, HW prgm */
#define	VDAE_NukeNoMsg		0x00010009	/* Supress WINOA message */
#define	VDAE_OkNukeMask 	0x80000000	/* "Good" nuke bit */


#define VDAE_InsMemGeneric	0x00020000	/* Unknown VxD failed create */
#define	VDAE_InsMemV86		0x00020001	/* base V86 mem	   - V86MMGR */
#define	VDAE_InsV86Space	0x00020002	/* Kb Req too large - V86MMGR */
#define	VDAE_InsMemXMS		0x00020003	/* XMS Kb Req	   - V86MMGR */
#define	VDAE_InsMemEMS		0x00020004	/* EMS Kb Req	   - V86MMGR */
#define	VDAE_InsMemV86Hi	0x00020005	/* Hi DOS V86 mem   - DOSMGR */
						/*		     V86MMGR */
#define	VDAE_InsMemVid		0x00020006	/* Base Video mem   - VDD */
#define	VDAE_InsMemVM		0x00020007	/* Base VM mem	   - VMM */
						/*    CB, Inst Buffer */
#define	VDAE_InsMemDev		0x00020008	/* Couldn't alloc base VM */
#define	VDAE_CrtNoMsg		0x00020009	/* Supress WINOA message */

/*****************************************************************************
 *
 * On SHELL_Set_Hotkey_Info, USER calls us with
 *
 *	DS:AX -> array of HOTKEYSTRUCT structures
 *         CX =  number of entries in array (possibly zero)
 *	DS:BX -> linked list of GLOBALHOTKEY structures
 *
 */

/* HOTKEYSTRUCT - Hotkeys of type 1
 *
 *	This structure is used with the WM_(SET/GET)HOTKEY messages
 *	and the SC_HOTKEY syscommand.
 *
 *	WARNING:  Both USER and WinOlDAp use this structure
 */

#define HKFL_SHIFT  1		/* Either shift key down */
#define HKFL_CTRL   2		/* Either Ctrl key down */
#define HKFL_ALT    4		/* Either Alt key down */
#define HKFL_EXT    8		/* This is an extended key */
#define HKFL_WIN    16		/* Either Nexus flappy-window down */

/* XLATOFF */
#ifdef	HOTKEYF_SHIFT
#if HKFL_SHIFT != HOTKEYF_SHIFT || \
    HKFL_CTRL  != HOTKEYF_CONTROL || \
    HKFL_ALT   != HOTKEYF_ALT || \
    HKFL_EXT   != HOTKEYF_EXT
#error "Hotkey state bits don't match!"
#endif
#endif
/* XLATON */

typedef struct HOTKEYSTRUCT {	/* hk */
#ifdef USER_IS_INCLUDING_VMDA
    HWND_16    hwnd16;		/* window that owns the hotkey */
#else   
    WORD    hwnd16;		/* window that owns the hotkey */
#endif          
    WORD    key;		/* LOBYTE = Window virtual key */
				/* HIBYTE = Keystate modifieds (HKFL_*) */
    WORD    scan;		/* OEM scan code for key (used by Shell.VxD) */
} HOTKEYSTRUCT;
typedef HOTKEYSTRUCT NEAR *PHOTKEYSTRUCT;

/* GLOBALHOTKEY - Hotkeys of type 2
 *
 *	This structure is used with the (Un)RegisterHotkey functions
 *	and the WM_HOTKEY message.
 *
 *	WARNING:  USER has its own definition for this structure.
 *
 *	DOUBLE WARNING:  The modifier states are *different* from those
 *	for hotkeys of type 1!  Aigh!
 */

#define GHKFL_ALT    1		/* Either Alt key down */
#define GHKFL_CTRL   2		/* Either Ctrl key down */
#define GHKFL_SHIFT  4		/* Either shift key down */
#define GHKFL_WIN    8		/* Either Nexus flappy-window down */

/* XLATOFF */
#ifdef	MOD_WIN
#if GHKFL_SHIFT != MOD_SHIFT || \
    GHKFL_CTRL  != MOD_CONTROL || \
    GHKFL_ALT   != MOD_ALT || \
    GHKFL_WIN   != MOD_WIN
#error "Global hotkey state bits don't match!"
#endif
#endif
/* XLATON */

typedef struct GLOBALHOTKEY	{ /* ghk */
#ifdef USER_IS_INCLUDING_VMDA
    struct GLOBALHOTKEY NEAR *phkNext;
#else
    WORD    phkNext;
#endif
    WORD    hq;
    DWORD   id;
    WORD    hwnd16;
    WORD    fsModifiers;
    WORD    vk;
    WORD    scan;
} GLOBALHOTKEY, NEAR *PGLOBALHOTKEY;

/*****************************************************************************/


/* H2INCSWITCHES -t- */

#ifdef	VK_NUMPAD0
#if (VK_NUMPAD0 != 0x60) || (VK_NUMPAD9 != 0x69)
#error "VK_ codes don't match!"
#endif
#else
#define VK_NUMPAD0      0x60
#define VK_NUMPAD9      0x69
#endif

/*****************************************************************************
 *
 * Undocumented flag bits for SHELL_Event.
 *
 */

#if 0                                           // Historical purposes

#define SE_WP_SetFocusBoost     0x00010000      // Boost the SYS VM till a
#define SE_WP_SetFocusBoostBit  16              //  Set_Focus call
                                                //
#define SE_WP_SwitcherBoost     0x00020000      // Leftover from 3.1
#define SE_WP_SwitcherBoostBit  17              //
                                                //
#define SE_WP_FilSysChgBoost    0x00040000      // Leftover from 3.1
#define SE_WP_FilSysChgBoostBit 18              //
                                                //
#define SE_WP_ClipAPIBoost      0x00080000      // Boost the SYS VM during clipbrd
#define SE_WP_ClipAPIBoostBit   19              //  API

#else                                           // There is only one type of
                                                // boost, so everybody shares.
#define SE_WP_SetFocusBoost     SE_WP_PrtScBoost
#define SE_WP_SetFocusBoostBit  SE_WP_PrtScBoostBit

#define SE_WP_ClipAPIBoost      SE_WP_PrtScBoost
#define SE_WP_ClipAPIBoostBit   SE_WP_PrtScBoostBit

#define SE_WP_Zombie		0x80000000	// Dead event but must linger
#define SE_WP_ZombieBit		31		// for buggy 3.1 VDDs

#endif


/* SE_WP_PrtScBoost is defined in shell.h */
/* SE_WP_DispUpdBoost is defined in shell.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\vmm.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1988-1990
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:	1.00
 *
 *   Date:  05-May-1988
 *
 *   Author:	RAL
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *   DATE    REV DESCRIPTION
 *   ----------- --- -----------------------------------------------------------
 *   05-May-1988 RAL Original
 *   13-Nov-1991 PBS C version
 *   17-Dec-1993     Adds Far East VxDs identifiers
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.	Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE	    0	    // False
#define VMM_TRUE    (~FALSE)	// The opposite of False!

#define DEBLEVELRETAIL	0
#define DEBLEVELNORMAL	1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#ifndef WIN40COMPAT
#define WIN403SERVICES		/*OPK-3 Services*/
#define WIN41SERVICES
#ifndef WIN41COMPAT
#define WIN49SERVICES
#endif
#endif
#endif

#ifdef	WIN42SERVICES
#define	WIN41SERVICES
#define	WIN403SERVICES
#define	WIN40SERVICES
#endif

#ifdef	WIN41SERVICES
#define	WIN403SERVICES
#define	WIN40SERVICES
#endif

#ifdef	WIN403SERVICES
#define	WIN40SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef	NEWSTRUCTS	; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *	    EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID	    0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID	    0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID	    0x0000A
#define VSD_DEVICE_ID	    0x0000B
#define VMD_DEVICE_ID	    0x0000C
#define VKD_DEVICE_ID	    0x0000D
#define VCD_DEVICE_ID	    0x0000E
#define VPD_DEVICE_ID	    0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define IOS_DEVICE_ID       BLOCKDEV_DEVICE_ID
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID	    0x0001B
#define VDD2_DEVICE_ID	    0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID	    0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID	    0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID	    0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID	0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID 	0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID	0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID	0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID	0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS	*/
/* #define VNB_DEVICE_ID	   0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID	   0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID	*/

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID	    0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID	   0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F	/* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID	    0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID	    0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */

#define AWREDIR_DEVICE_ID   0x00049 /* AtWork Network FSD */
#define DDS_DEVICE_ID	    0x0004A /* Device driver services */
#define NTKERN_DEVICE_ID    0x0004B /* NT kernel device id */
#define VDOSKEYD_DEVICE_ID  0x0004B /* DOSKEY device id */
#define ACPI_DEVICE_ID      0x0004C /* Advanced Configuration and Power Interfacec */
#define UDF_DEVICE_ID       0x0004D /* UDF FSD device id */
#define SMCLIB_DEVICE_ID    0x0004E /* Smart Card port driver */
#define NTMAP_DEVICE_ID     0x0004F /* WDM storage mapper */
#define NTMAPHLP_DEVICE_ID	0x00050
#define USBNTMAP_DEVICE_ID  0x00051 /* USB WDM storage mapper */
#define USBMPHLP_DEVICE_ID  0x00052 /* USB WDM storage helper */

/*
 *   Far East DOS support VxD ID
 */

#define ETEN_Device_ID	    0x00060 /* ETEN DOS (Taiwan) driver */
#define CHBIOS_Device_ID    0x00061 /* CHBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */
#define VIME_Device_ID	    0x00064 /* Virtual DOS IME */
#define VHBIOSD_Device_ID   0x00065 /* HBIOS (Korean) for HWin31 driver */
#define VPBIOSD_DEVICE_ID   0x00066 /* PRC DOS driver */
#define VXDMON_DEVICE_ID    0x00067 /* SFP/SR IFSHook VxD */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.	Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER	    0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER	0x000000000 /*	but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER		0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER	    0x014000000
#define VWIN32_INIT_ORDER   0x014100000
#define VXDLDR_INIT_ORDER   0x016000000
#define NTKERN_INIT_ORDER   0x016200000 /* Must be after VxDLdr and before configmg */

#define CONFIGMG_INIT_ORDER 0x016400000	/* Must now be before enumerators */
#define ENUMERATOR_INIT_ORDER	0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER	    ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define ACPI_INIT_ORDER     ENUMERATOR_INIT_ORDER+2 /* To simplify reenumeration */
#define NTMAP_INIT_ORDER    ENUMERATOR_INIT_ORDER+3 /* To simplify reenumeration */
#define USBNTMAP_INIT_ORDER    ENUMERATOR_INIT_ORDER+4 /* To simplify reenumeration */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER	    0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER	    0x028000000
#define VSD_INIT_ORDER	    0x02C000000

#define VCD_INIT_ORDER	    0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER	    0x034000000
#define VKD_INIT_ORDER	    0x038000000
#define VPD_INIT_ORDER	    0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER	0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER	0x080000000
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order	    0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER	    0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;	    /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;		/* Client's EDI */
    ULONG Pushad_ESI;		/* Client's ESI */
    ULONG Pushad_EBP;		/* Client's EBP */
    ULONG Pushad_ESP;		/* ESP before pushad */
    ULONG Pushad_EBX;		/* Client's EBX */
    ULONG Pushad_EDX;		/* Client's EDX */
    ULONG Pushad_ECX;		/* Client's ECX */
    ULONG Pushad_EAX;		/* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)	// turn off redefinition warning

typedef unsigned char	UCHAR;
typedef unsigned short	USHORT;

#pragma warning (default:4209)	// turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)	__##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define Declare_SCService(service, args, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG	    code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG	    data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG	code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG	data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DB1CODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DB2DATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG	code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG	code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG	code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG	code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG	code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG	code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG	code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG	code_seg("LOCKABLE", "LOCKABLECODE")
#define VxD_LOCKABLE_DATA_SEG	data_seg("LOCKABLE_DATA", "LOCKABLECODE")

#define VxD_LOCKED_CONST_SEG const_seg("_LCONST", "LCODE")
#define VxD_INIT_CONST_SEG   const_seg("_ICONST", "ICODE")
#define VxD_PAGEABLE_CONST_SEG	const_seg("_PCONST", "PCODE")
#define VxD_LOCKABLE_CONST_SEG	const_seg("LOCKABLE_CONST", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =	1
??_ICODE    =	2
??_PCODE    =	3
??_SCODE    =	4
??_DBOCODE  =	5
??_16ICODE  =	6
??_RCODE    =	7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE	equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF	MASM6
_FLAT	EQU FLAT
ELSE
_FLAT	EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT	    ENDS

_TEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT	    ENDS

;*  32 bit pageable code
_PTEXT	    SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT	    ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB	<classname>
    segname	SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname	SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
	ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB	<grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM		;; End for each segment

    ENDM

MakeCodeSeg <L0CKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***	DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_L0CKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_L0CKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***	DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***	CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
	extrn	name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***	MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***	MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or	??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT	    ENDS

;*  32 bit locked data
_LDATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA	    ENDS

_DATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA	    ENDS

;*  32 bit pageable data
_PDATA	    SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA	    ENDS

;*  32 Bit initialization data
_IDATA	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA	    ENDS

;*  Created by C8
_BSS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS	    ENDS

CONST	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST	    ENDS

_TLS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS	    ENDS

;*  32 Bit static code for DL-VxDs
_STEXT	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT	    ENDS

;*  32 Bit static data for DL-VxDs
_SDATA	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA	    ENDS

;*	dummy segment for IsDebugOnlyLoaded
_DB0START   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB0START   ENDS

;*	32 bit debug only code; loaded only if debugger is present
_DB1CODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB1CODE    ENDS

;*	32 bit debug only data; loaded only if debugger is present
_DB2DATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB2DATA    ENDS

if DEBLEVEL
;*  Start of 32 bit path coverage data
_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS

;*  32 bit path coverage data
_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS

;*  End of 32 bit path coverage data
_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE	    SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE	    ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DB0START, _DB1CODE, _DB2DATA
IF DEBLEVEL
_PGROUP   GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;	. . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table	VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1		; Only in module where table is
;   INCLUDE	VxD.INC 	; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF	Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID	= 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName	Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName	MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table


Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition, StdCallBytes, fastcall
LOCAL $$&Procedure, extrnproc, tableproc

  extrnproc MACRO
    IFNB <fastcall>
      IFB <StdCallBytes>
	.err	;StdCallBytes required
      ENDIF
      EXTRN @&&Procedure&&@&&StdCallBytes:NEAR
    ELSE
      IFNB <StdCallBytes>
	EXTRN _&&Procedure&&@&&StdCallBytes:NEAR
      ELSE
	EXTRN Procedure:NEAR
      ENDIF
    ENDIF
    ENDM

  tableproc MACRO
    IFNB <fastcall>
      dd  OFFSET32 @&&Procedure&&@&&StdCallBytes
    ELSE
      IFNB <StdCallBytes>
	dd  OFFSET32 _&&Procedure&&@&&StdCallBytes
      ELSE
	dd  OFFSET32 Procedure
      ENDIF
    ENDIF
    ENDM

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	extrnproc
      ELSE
	tableproc
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    IFDIFI <Local_Seg>, <RESERVED>
      PUBLIC _&&Procedure
       IF1
      _&&Procedure LABEL DWORD
       IFNB <fastcall>
      PUBLIC __&&Procedure
       __&&Procedure LABEL DWORD
       ENDIF
       ENDIF
       IFDIFI <Local_Seg>, <LOCAL>
      IFNB <Local_Seg>
Local_Seg&&_SEG
         ELSE
Def_Segment&_CODE_SEG
      ENDIF
        IFNB <Condition>
      $$&&Procedure extern
         ELSE
      extrnproc
      ENDIF
      IFNB <Local_Seg>
Local_Seg&&_ENDS
      ELSE
Def_Segment&_CODE_ENDS
      ENDIF
       ENDIF
        IFNB <Condition>
    $$&&Procedure
        ELSE
    tableproc
        ENDIF

        IFDEF Device_Name&_Name_Based
      @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
        ELSE
      @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
        ENDIF
    ELSE
      dd  0
    ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    Purge extrnproc
    Purge tableproc
    ENDM

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4
    ??_standardccall&&_Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4, TRUE
    ??_fastcall&&_Procedure = Args
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF	Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM

ENDIF

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_standardccall_&&Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_fastcall_&&Procedure = Args
    ENDM

ENDIF

    ENDM


;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal	macro	reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress	macro	reg,service
    mov reg,OFFSET32 service
    endm


;***	Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.	If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName	- the name of the VxD; it is assumed
;		  that a corresponding Device_ID is
;		  also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;	accepts a service name as its only parameter.
;	This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd	csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
	.erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
	dd  OFFSET32 Name,cparm&&Name
    endif
	@32&&Name equ	((VxDName&_Device_ID SHL 16) + ??w32svcno)
	??w32svcno = ??w32svcno + 1
	ENDM
    ENDM


;***	End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName	- the same name passed to
;		  Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***	Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name	- the service name
;	cParms	    - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***	Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service	- the name of the service
;	CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)	service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp	VxDJmp

#define SERVICE 	__cdecl
#define ASYNC_SERVICE	__cdecl
#define WIN32_SERVICE	void __stdcall

#ifndef FASTCALL
#define FASTCALL	__fastcall
#endif
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
	ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status; 	/* VM status flags */
    ULONG CB_High_Linear;	/* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56	/* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT	0x00	/* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE	(1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT	0x01	/* VM runs in background */
#define VMSTAT_BACKGROUND	(1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING 	(1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT	0x03	/* VM not scheduled */
#define VMSTAT_SUSPENDED	(1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE	(1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC		(1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP		(1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32 	(1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC 	(1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09	/* High pri background */
#define VMSTAT_HIGH_PRI_BACK	(1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED		(1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT	0x0B	/* Woke up after blocked */
#define VMSTAT_AWAKENING	(1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT	0x0C	/* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT	VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86	(1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D	/* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED	(1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E	/* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT	(1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT 	0x0F	/* VM has released time slice */
#define VMSTAT_IDLE		(1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING		(1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11	/* VM suspended by */
#define VMSTAT_TS_SUSPENDED	(1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT	0x12	/* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI	(1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;		/* Thread status flags */
    ULONG   TCB_Reserved1;	/* Used internally by VMM */
    ULONG   TCB_Reserved2;	/* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;	/* Client registers of thread */
    ULONG   TCB_VMHandle;	/* VM that thread is part of */
    USHORT  TCB_ThreadId;	/* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;	    /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;	    /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;	/* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;		/* reusable; for dword align */
    UCHAR   TCB_pad2;		/* reusable; for dword align */
    UCHAR   TCB_extErrLocus;	    /* extended error Locus */
    USHORT  TCB_extErr; 	/* extended error Code */
    UCHAR   TCB_extErrAction;	    /*	    "   "   Action */
    UCHAR   TCB_extErrClass;	    /*	    "   "   Class */
    ULONG   TCB_extErrPtr;	/*	"   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD	    0x42434854	  // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT	    0x03   // Thread not scheduled
#define THFLAG_SUSPENDED		   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE		   (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION		   (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED		   (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_RING0_THREAD_BIT     0x1C   // thread runs only at ring 0
#define THFLAG_RING0_THREAD		   (1L << THFLAG_RING0_THREAD_BIT)
#define THFLAG_ASYNC_THREAD_BIT	    0x1F   // thread is asynchronous
#define THFLAG_ASYNC_THREAD	       	   (1L << THFLAG_ASYNC_THREAD_BIT)
#define THFLAG_CHARSET_BITS	0x10   // Default character set
#define THFLAG_CHARSET_MASK	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI	       (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM	       (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE		   (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED 	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES 	   (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13	 // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE		 (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;		// faulting EIP
    WORD  VMFI_CS;		// faulting CS
    WORD  VMFI_Ints;		// interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *		V M M	S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#define VMM_StdCall_Service Declare_SCService
#define VMM_FastCall_Service Declare_SCService
#pragma warning (disable:4003)	    // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)	// MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

//
// Flags affecting the returned block
//

#define HEAPZEROINIT        0x00000001
#define HEAPZEROREINIT      0x00000002
#define HEAPNOCOPY          0x00000004

//
// Alignment flags
//

#define HEAPALIGN_SHIFT     16
#define HEAPALIGN_MASK      0x000F0000

#define HEAPALIGN_4         0x00000000                // dword aligned
#define HEAPALIGN_8         0x00000000                // quadword aligned
#define HEAPALIGN_16        0x00000000                // paragraph aligned
#define HEAPALIGN_32        0x00010000                // etc.
#define HEAPALIGN_64        0x00020000
#define HEAPALIGN_128       0x00030000
#define HEAPALIGN_256       0x00040000
#define HEAPALIGN_512       0x00050000
#define HEAPALIGN_1K        0x00060000
#define HEAPALIGN_2K        0x00070000
#define HEAPALIGN_4K        0x00080000
#define HEAPALIGN_8K        0x00090000
#define HEAPALIGN_16K       0x000A0000
#define HEAPALIGN_32K       0x000B0000
#define HEAPALIGN_64K       0x000C0000
#define HEAPALIGN_128K      0x000D0000

//
// Flags indicating which system heap to use.  There are four bits reserved
// to identify the heap to use.  Four are currently defined by the system.
//

#define HEAPTYPESHIFT       8
#define HEAPTYPEMASK        0x00000700

#define HEAPLOCKEDHIGH      0x00000000
#define HEAPLOCKEDIFDP      0x00000100
#define HEAPSWAP            0x00000200
#define HEAPINIT            0x00000400  // will be automatically freed after
                                        // init complete

//
// other flags
//

#define HEAPCLEAN           0x00000800
#define HEAPCONTIG          0x00001000  // memory must be physically contiguous
#define HEAPFORGET          0x00002000  // this memory will never be freed

//
// Combinations of flags understood by HeapAllocateEx
//

#define HEAPLOCKEDLOW       0x00000300
#define HEAPSYSVM           0x00000500
#define HEAPPREEMPT         0x00000600  // code in this heap is preemptable

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT		0x00000001
#define PAGEUSEALIGN		0x00000002
#define PAGECONTIG		0x00000004
#define PAGEFIXED		0x00000008
#define PAGEDEBUGNULFAULT	0x00000010
#define PAGEZEROREINIT		0x00000020
#define PAGENOCOPY		0x00000040
#define PAGELOCKED		0x00000080
#define PAGELOCKEDIFDP		0x00000100
#define PAGESETV86PAGEABLE	0x00000200
#define PAGECLEARV86PAGEABLE	0x00000400
#define PAGESETV86INTSLOCKED	0x00000800
#define PAGECLEARV86INTSLOCKED	0x00001000
#define PAGEMARKPAGEOUT 	0x00002000
#define PAGEPDPSETBASE		0x00004000
#define PAGEPDPCLEARBASE	0x00008000
#define PAGEDISCARD		0x00010000
#define PAGEPDPQUERYDIRTY	0x00020000
#define PAGEMAPFREEPHYSREG	0x00040000
#define PAGEPHYSONLY		0x04000000
//efine PAGEDONTUSE		0x08000000  // ;Internal
#define PAGENOMOVE		0x10000000
#define PAGEMAPGLOBAL		0x40000000
#define PAGEMARKDIRTY		0x80000000

/****************************************************
 *
 *	Flags for _PhysIntoV86,
 *	_MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP	0x00000001

/****************************************************
 *
 *	Flags for MapPhysToLinear
 *
 *
 ***************************************************/

#define	MPL_NonCached			0x00000000
#define	MPL_HardwareCoherentCached	0x00000001
#define	MPL_FrameBufferCached		0x00000002
#define	MPL_Cached			0x00000004
#define	MPL_Undoable			0x00000008
#define	MPL_Flags			0x0000000F	// OR of the above

// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
*   Flag equates for _Allocate_GDT_Selector
*/
#define ALLOCFROMEND    0x40000000


/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL	0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE	0x00000002
#define MMGRHMADISABLE	0x00000004
#define MMGRHMAQUERY	0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT	    0
#define LF_ASYNC	(1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP	(1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR	    (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP 	(LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area)
VMM_Service (_Free_Temp_V86_Data_Area)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign	    0x00000001
#define GVDADWordAlign	    0x00000002
#define GVDAParaAlign	    0x00000004
#define GVDAPageAlign	    0x00000008
#define GVDAInstance	    0x00000100
#define GVDAZeroInit	    0x00000200
#define GVDAReclaim	0x00000400
#define GVDAInquire	0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE	    260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT	0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT	0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT	0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT	0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT	0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)
#define GMIF_80586_BIT  0x15
#define GMIF_80586  (1 << GMIF_80586_BIT)

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (RESERVED_Set_System_Exit_Code, RESERVED)	// Obsoleted in 4.90

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *	    D E B U G G I N G	E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)	// Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)	// for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz	@@Test_DBCS_Lead_Byte - 100D1h	 ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
// 4.90: AFPP_SWAPOUT is no longer interesting: we no longer restore to DOS
//#define AFPP_SWAPOUT	 0x0001 // physical memory that must be swapped out
//				// and subsequently restored at system exit
#define AFPP_MAPNUL	 0x0002 // 4.90: Memory must be map nul (for V86 pages)

/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY	    0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS	 0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001	/* Privledged instruction */
#define GSDVME_INVALINST    0x00010002	/* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003	/* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004	/* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005	/* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006	/* User requested NUKE of VM */
#define GSDVME_DEVNUKE	    0x00010007	/* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008	/* Device specific problem:
			 *   invalid hardware fiddling
			 *   by VM (invalid I/O)
			 */
#define GSDVME_NUKENOMSG    0x00010009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */
#define GSDVME_OKNUKEMASK   0x80000000	/* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001	/* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002	/* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003	/* XMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004	/* EMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005	/* Hi DOS V86 mem   - DOSMGR
			 *	     V86MMGR
			 */
#define GSDVME_INSMEMVID    0x00020006	/* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007	/* Base VM mem	   - VMM
			 *   CB, Inst Buffer
			 */
#define GSDVME_INSMEMDEV    0x00020008	/* Couldn't alloc base VM
			 * memory for device.
			 */
#define GSDVME_CRTNOMSG     0x00020009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001	/* Page directory entry not-present */
#define IPF_V86PG   0x00000002	/* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004	/* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008	/* page has invalid not present type */
#define IPF_PGERR   0x00000010	/* pageswap device failure */
#define IPF_REFLT   0x00000020	/* re-entrant page fault */
#define IPF_VMM     0x00000040	/* Page fault caused by a VxD */
#define IPF_PM	    0x00000080	/* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100	/* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (RESERVED_Set_Delete_On_Exit_File, RESERVED)	/* STOP WORKING IN 4.90 */
VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT	0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)	// Debugging only
VMM_Service (Disable_Touch_1st_Meg)	// Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz	 @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT	    0
#define DFS_LOG 	    (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT 	1
#define DFS_PROFILE	    (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT	2
#define DFS_TEST_CLD		(1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT	    3
#define DFS_NEVER_REENTER	(1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT	    4
#define DFS_TEST_REENTER	(1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT	    5
#define DFS_NOT_SWAPPING	(1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT	6
#define DFS_TEST_BLOCK		(1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES   0xFFFFFF80

#define DFS_EXIT_NOBLOCK	(DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC  (DFS_RARE_SERVICES+1)
#define DFS_WIMP_DEBUG      (DFS_RARE_SERVICES+2)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service (Test_VM_Ints_Enabled)
VMM_Service (_BlockOnID)

VMM_Service (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define MUTEX_MUST_COMPLETE	1L
#define MUTEX_NO_CLEANUP_THREAD_STATE	2L

/*MACROS*/
VMM_Service (_CreateMutex)

VMM_Service (_DestroyMutex)
VMM_Service (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service (VMMCreateThread)
VMM_Service (_GetThreadExecTime)
VMM_Service (VMMTerminateThread)

VMM_Service (Get_Cur_Thread_Handle)
VMM_Service (Test_Cur_Thread_Handle)
VMM_Service (Get_Sys_Thread_Handle)
VMM_Service (Test_Sys_Thread_Handle)
VMM_Service (Validate_Thread_Handle)
VMM_Service (Get_Initial_Thread_Handle)
VMM_Service (Test_Initial_Thread_Handle)
VMM_Service (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service (Cancel_Call_When_Thread_Switched)
VMM_Service (Get_Next_Thread_Handle)
VMM_Service (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service (_EnterMutex)
VMM_Service (_LeaveMutex)
VMM_Service (Simulate_VM_IO)
VMM_Service (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service (_EnterMustComplete)
VMM_Service (_LeaveMustComplete)
VMM_Service (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND	    1L
#define THREAD_TERM_STATUS_NUKE_PEND	    2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service (_GetThreadTerminationStatus)
VMM_Service (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE	0	/* no data instanced in range */
#define INSTINFO_SOME	1	/* some data instanced in range */
#define INSTINFO_ALL	2	/* all data instanced in range */

/*MACROS*/
VMM_Service (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service (Call_Priority_Thread_Event)
VMM_Service (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ	    // define only if not there already

#define REG_SZ	    0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT	0x80000000
#define HKEY_CURRENT_USER	0x80000001
#define HKEY_LOCAL_MACHINE	0x80000002
#define HKEY_USERS		0x80000003
#define HKEY_PERFORMANCE_DATA	0x80000004
#define HKEY_CURRENT_CONFIG	0x80000005
#define HKEY_DYN_DATA		0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service (_LocalizeSprintf)
VMM_Service (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE	0	/* no pages in the specified range exist */
#define PHYSINFO_SOME	1	/* some pages in the specified range exist */
#define PHYSINFO_ALL	2	/* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service (Time_Slice_Sys_VM_Idle)
VMM_Service (Time_Slice_Sleep)
VMM_Service (Boost_With_Decay)
VMM_Service (Set_Inversion_Pri)
VMM_Service (Reset_Inversion_Pri)
VMM_Service (Release_Inversion_Pri)
VMM_Service (Get_Thread_Win32_Pri)
VMM_Service (Set_Thread_Win32_Pri)
VMM_Service (Set_Thread_Static_Boost)
VMM_Service (Set_VM_Static_Boost)
VMM_Service (Release_Inversion_Pri_ID)
VMM_Service (Attach_Thread_To_Group)
VMM_Service (Detach_Thread_From_Group)
VMM_Service (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM	0
#define REGTYPE_CLASS	1
#define REGTYPE_VXD	2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN		    0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD	    0x00000000
#define ASSERT_RANGE_NULL_OK	    0x00000001
#define ASSERT_RANGE_IS_ASCIIZ	    0x00000002
#define ASSERT_RANGE_IS_NOT_ASCIIZ  0x00000000
#define ASSERT_RANGE_NO_DEBUG	    0x80000000
#define ASSERT_RANGE_BITS	    0x80000003

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQueryMultipleValues)

// Additional timeslicer services
VMM_Service (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN		0x00000001
#define BOOT_DOSCLEAN		0x00000002
#define BOOT_NETCLEAN		0x00000004
#define BOOT_INTERACTIVE	0x00000008

/*MACROS*/
VMM_Service (Get_Boot_Flags)
VMM_Service (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service (_AddReclaimableItem)
VMM_Service (_SetReclaimableItem)
VMM_Service (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service (Time_Slice_Wake_Sys_VM)
VMM_Service (VMM_Replace_Global_Environment)
VMM_Service (Begin_Non_Serial_Nest_V86_Exec)
VMM_Service (Get_Nest_Exec_Status)
/*ENDMACROS*/

// Bootlogging services

/*MACROS*/
VMM_Service (Open_Boot_Log)
VMM_Service (Write_Boot_Log)
VMM_Service (Close_Boot_Log)
VMM_Service (EnableDisable_Boot_Log)
VMM_Service (_Call_On_My_Stack)
/*ENDMACROS*/

// Another instance data service

/*MACROS*/
VMM_Service (Get_Inst_V86_Int_Vec_Base)
/*ENDMACROS*/

// Case insensitive functions -- SEE WARNINGS IN DOCS BEFORE USING!
/*MACROS*/
VMM_Service (_lstrcmpi)
VMM_Service (_strupr)
/*ENDMACROS*/

/*MACROS*/
VMM_Service (Log_Fault_Call_Out)
VMM_Service (_AtEventTime)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

#ifdef WIN403SERVICES

//
// 4.03 Services
//

/*MACROS*/
VMM_Service (_PageOutPages)
/*ENDMACROS*/

// Flag definitions for _PageOutPages

#define PAGEOUT_PRIVATE 0x00000001
#define PAGEOUT_SHARED	0x00000002
#define PAGEOUT_SYSTEM	0x00000004
#define PAGEOUT_REGION	0x00000008
#define PAGEOUT_ALL	(PAGEOUT_PRIVATE | PAGEOUT_SHARED | PAGEOUT_SYSTEM)

/*MACROS*/
VMM_Service (_Call_On_My_Not_Flat_Stack)
VMM_Service (_LinRegionLock)
VMM_Service (_LinRegionUnLock)
VMM_Service (_AttemptingSomethingDangerous)
VMM_Service (_Vsprintf)
VMM_Service (_Vsprintfw)
VMM_Service (Load_FS_Service)
VMM_Service (Assert_FS_Service)
VMM_StdCall_Service (ObsoleteRtlUnwind, 4)		
VMM_StdCall_Service (ObsoleteRtlRaiseException, 1)
VMM_StdCall_Service (ObsoleteRtlRaiseStatus, 1)		

VMM_StdCall_Service (ObsoleteKeGetCurrentIrql, 0)
VMM_FastCall_Service (ObsoleteKfRaiseIrql, 1)
VMM_FastCall_Service (ObsoleteKfLowerIrql, 1)

VMM_Service (_Begin_Preemptable_Code)
VMM_Service (_End_Preemptable_Code)
VMM_FastCall_Service (Set_Preemptable_Count, 1)

VMM_StdCall_Service (ObsoleteKeInitializeDpc, 3)
VMM_StdCall_Service (ObsoleteKeInsertQueueDpc, 3)
VMM_StdCall_Service (ObsoleteKeRemoveQueueDpc, 1)

VMM_StdCall_Service (HeapAllocateEx, 4)
VMM_StdCall_Service (HeapReAllocateEx, 5)
VMM_StdCall_Service (HeapGetSizeEx, 2)
VMM_StdCall_Service (HeapFreeEx, 2)
VMM_Service (_Get_CPUID_Flags)
VMM_StdCall_Service (KeCheckDivideByZeroTrap, 1)

/*ENDMACROS*/

#define	GCIF_FPU_BIT	0
#define	GCIF_FPU	(1 << GCIF_FPU_BIT)
#define	GCIF_VME_BIT	1
#define	GCIF_VME	(1 << GCIF_VME_BIT)
#define	GCIF_DE_BIT	2
#define	GCIF_DE		(1 << GCIF_DE_BIT)
#define	GCIF_PSE_BIT	3
#define	GCIF_PSE	(1 << GCIF_PSE_BIT)
#define	GCIF_TSC_BIT	4
#define	GCIF_TSC	(1 << GCIF_TSC_BIT)
#define	GCIF_MSR_BIT	5
#define	GCIF_MSR	(1 << GCIF_MSR_BIT)
#define	GCIF_PAE_BIT	6
#define	GCIF_PAE	(1 << GCIF_PAE_BIT)
#define	GCIF_MCE_BIT	7
#define	GCIF_MCE	(1 << GCIF_MCE_BIT)
#define	GCIF_CXS_BIT	8
#define	GCIF_CXS	(1 << GCIF_CXS_BIT)
#define	GCIF_APIC_BIT	9
#define	GCIF_APIC	(1 << GCIF_APIC_BIT)
//
// Bit 10 and 11 are apparently Intel reserved
//
#define	GCIF_MTTR_BIT	12
#define	GCIF_MTTR	(1 << GCIF_MTTR_BIT)
#define	GCIF_PGE_BIT	13
#define	GCIF_PGE	(1 << GCIF_PGE_BIT)
#define	GCIF_MCA_BIT	14
#define	GCIF_MCA	(1 << GCIF_MCA_BIT)
#define	GCIF_CMOV_BIT	15
#define	GCIF_CMOV	(1 << GCIF_CMOV_BIT)

#endif /* WIN403SERVICES */

#ifdef	WIN41SERVICES

/*MACROS*/
VMM_Service (_RegisterGARTHandler)
VMM_Service (_GARTReserve)
VMM_Service (_GARTCommit)
VMM_Service (_GARTUnCommit)
VMM_Service (_GARTFree)
VMM_Service (_GARTMemAttributes)
VMM_StdCall_Service (KfRaiseIrqlToDpcLevel, 0)
VMM_Service (VMMCreateThreadEx)
VMM_Service (_FlushCaches)
/*ENDMACROS*/

/*
 * Flags for the VMM GART services.
 * WARNING: THESE FLAGS SHOULD HAVE SAME VALUE AS THE VMM FLAGS DEFINED IN PCI.H
 * IF YOU CHANGE THE VALUE AT EITHER PLACE, YOU NEED TO UPDATE THE OTHER.
 */
#define	PG_UNCACHED		0x00000001		// Uncached memory
#define	PG_WRITECOMBINED	0x00000002		// Write combined memory

/*
 * Flags for the FlushCaches service.
 */
#define FLUSHCACHES_NORMAL              	0x00000000
#define FLUSHCACHES_GET_CACHE_LINE_PTR  	0x00000001
#define FLUSHCACHES_GET_CACHE_SIZE_PTR  	0x00000002
#define FLUSHCACHES_TAKE_OVER           	0x00000003
#define FLUSHCACHES_FORCE_PAGES_OUT     	0x00000004
#define FLUSHCACHES_LOCK_LOCKABLE       	0x00000005
#define FLUSHCACHES_UNLOCK_LOCKABLE     	0x00000006
#define FLUSHCACHES_CRASH_DUMP			0x00000007	// VMM 4.90
#define FLUSHCACHES_PREPARE_S2_OR_S3		0x00000008	// VMM 4.90

//
// The following four are for VPOWERD only. All services return 0 on success,
// -1 on failure.
//
// PREPARE_FOR_HIBERNATE is called in between the pageable and locked suspend
// phases during a S4 sleep state. It allocates about half of memory and do
// other pageable things to prepare for hibernate. If someone else fails the
// hibernation UNPREPARE_FOR_HIBERNATE should be called to free the stuff.
//
// BUILD_HIBNERNATE_FILE is called after the locked phase (ie with inetrrupts
// disabled. The code builds an hibernation file into the other half of
// memory. This service cannot fail since all allocation have already been
// done. This service return twice: 0 when we properly completed this phase.
// and -1 when we are resuming.
// 
// Once the hibernate file is done, the machine actually does the resume
// locked phase of suspend, to get the paging/boot device going. Then
// WRITE_HIBERNATE_FILE is called to actually write the file. If that succeed,
// VPOWERD will enter S5. If it fails, the file will get deleted.
//
// UNPREPARE_FOR_HIBERNATE should be called on the resume path. 
//
#define	FLUSHCACHES_PREPARE_FOR_HIBERNATE	0x00000009	// VMM 4.90
#define	FLUSHCACHES_BUILD_HIBERNATE_FILE	0x0000000A	// VMM 4.90
#define	FLUSHCACHES_WRITE_HIBERNATE_FILE	0x0000000B	// VMM 4.90
#define	FLUSHCACHES_UNPREPARE_FOR_HIBERNATE	0x0000000C	// VMM 4.90

//
// This is for any dirver that needs to get a pointer to the ACPI tables.
//
#define	FLUSHCACHES_GET_ACPI_TABLES		0x0000000D	// VMM 4.90

//
// PREALLOC for hibernate should be only called by VPOWERD. It is called
// very only on the suspend process, if done for hibernate
//
#define	FLUSHCACHES_PREALLOC_HIBERNATE_FILE	0x0000000E	// VMM 4.90

// Free hibernate block should only be called by VPOWERD.  It is called
// upon returning from hibernation just after leaving the ints off phase.
#define FLUSHCACHES_FREE_HIBERNATE_BLOCK    0x0000000F  // VMM 4.90


/*MACROS*/
VMM_Service (Set_Thread_Win32_Pri_NoYield)
VMM_Service (_FlushMappedCacheBlock)
VMM_Service (_ReleaseMappedCacheBlock)
VMM_Service (Run_Preemptable_Events)
VMM_Service (_MMPreSystemExit)
VMM_Service (_MMPageFileShutDown)
VMM_Service (_Set_Global_Time_Out_Ex)

VMM_Service (Query_Thread_Priority)

/*ENDMACROS*/

#endif /* WIN41SERVICES */

#ifdef	WIN49SERVICES

/*MACROS*/

//
// In order to properly undo a _MapPhysToLinear, you must have pass the
// MPL_Undoable flag and you must pass the linear address you got back
// as well as the size.
//
VMM_Service (_UnmapPhysToLinear)
VMM_Service (_VmmRtInfo)

// IMPORTANT NOTE:  Since the following MP services are commented out for now,
// if you are adding any services to VMM, add them above this comment,
// BEFORE the MP services.

/*ENDMACROS*/
#ifdef	MULTI_PROC_SUPPORT
/*MACROS*/

//
// Warning: MP initializes at VMM's device init. Do not call before device
// init.
//
VMM_Service (_MPGetProcessorCount)
VMM_Service (_MPEnterSingleProcessor)
VMM_Service (_MPLeaveSingleProcessor)

/*ENDMACROS*/
#endif
/*MACROS*/


/*ENDMACROS*/

#endif	/* WIN49SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning

#ifndef try
#define try				__try
#define except				__except
#define finally 			__finally
#define leave				__leave
#ifndef exception_code
#define exception_code			__exception_code
#endif
#endif

#ifndef EXCEPTION_EXECUTE_HANDLER
#define EXCEPTION_EXECUTE_HANDLER	1
#define EXCEPTION_CONTINUE_SEARCH	0
#define EXCEPTION_CONTINUE_EXECUTION	-1
#endif
/*XLATON*/

#define COMNFS_FLAT	0xFFFFFFFF

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM		0x00000001
#define RS_RESTORE		0x00000002
#define RS_DOSARENA		0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;			// low (< 1meg) address of item
    ULONG   RS_Bytes;			// size of item in bytes
    ULONG   RS_CallBack;		// callback, if any (zero if none)
    ULONG   RS_RefData; 		// reference data for callback, if any
    ULONG   RS_HookTable;		// real-mode hook table (zero if none)
    ULONG   RS_Flags;			// 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
typedef struct DemandInfoStruc {
    ULONG DILin_Total_Count;	/* # pages in linear address space */
    ULONG DIPhys_Count; 	/* Count of phys pages */
    ULONG DIFree_Count; 	/* Count of free phys pages */
    ULONG DIUnlock_Count;	/* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;	/* Base of pageable address space */
    ULONG DILin_Total_Free;	/* Total Count of free linear pages */

    /*
     *	The following 5 fields are all running totals, kept from the time
     *	the system was started
     */
    ULONG DIPage_Faults;	/* total page faults */
    ULONG DIPage_Ins;		/* calls to pagers to page in a page */
    ULONG DIPage_Outs;		/* calls to pagers to page out a page*/
    ULONG DIPage_Discards;	/* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;	/* instance page faults */

    ULONG DIPagingFileMax;	/* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;	/* # of pages of paging file currently in use */

    ULONG DICommit_Count;	/* Total committed memory, in pages */

    ULONG DIReserved[2];	/* Reserved for expansion */
} DEMANDINFOSTRUC;

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;	    /* INIT <0> RESERVED */
    ULONG InstLinkB;	    /* INIT <0> RESERVED */
    ULONG InstLinAddr;	    /* Linear address of start of block */
    ULONG InstSize;	    /* Size of block in bytes */
    ULONG InstType;	    /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD	0x100	/* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD	0x200	/* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD	0x400	/* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;	    /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;	    /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400	/* anywhere in private arena */
#define PR_SHARED   0x80060000	/* anywhere in shared arena */
#define PR_SYSTEM   0x80080000	/* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008	/* don't move during PageReAllocate */
#define PR_4MEG     0x00000001	/* allocate on 4mb boundary */
#define PR_STATIC   0x00000010	/* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001	/* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002	/* swappable uninitialized pages */
#define PD_FIXEDZERO	0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004	/* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008	/* pages are permanently locked */
#define PC_LOCKED   0x00000080	/* pages are made present and locked*/
#define PC_LOCKEDIFDP	0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE	0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000	/* make the pages ring 3 accessible */
#define PC_INCR     0x40000000	/* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000	/* make pages initially present */
#define PC_STATIC   0x20000000	/* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000	/* make pages initially dirty */
#define PC_CACHEDIS 0x00100000  /* Allocate uncached pages - new for WDM */
#define PC_CACHEWT  0x00080000  /* Allocate write through cache pages - new for WDM */
#define PC_PAGEFLUSH 0x00008000 /* Touch device mapped pages on alloc - new for WDM */

#ifdef WRITE_WATCH
#define PC_WRITE_WATCH 0x00200000 /* to request write_watch in this region */
#endif // WRITE_WATCH

/* PageCommitContig additional flags */
#define PCC_ZEROINIT	0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000	/* don't map to any linear address */


/*MTRR type flags */
#define MTRR_UC 0
#define MTRR_WC 1
#define	MTRR_WT 4
#define	MTRR_WP 5
#define	MTRR_WB 6

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS	       0x01
#define PAGE_READONLY	       0x02
#define PAGE_READWRITE	       0x04
#define MEM_COMMIT	     0x1000
#define MEM_RESERVE	     0x2000
#define MEM_FREE	    0x10000
#define MEM_PRIVATE	    0x20000
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *	clean - page has not been written to since its last page out
 *	dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *	virgin - page has never been written to since it was committed
 *	tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *	For 32-bit EXE code or read-only data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = 0
 *	  pd_cleanout = 0
 *	  pd_dirtyout = 0
 *	  pd_virginfree = 0
 *    pd_taintedfree = 0
 *    pd_dirty = 0
 *	  pd_type = PD_PAGERONLY
 *
 *	For 32-bit EXE writeable data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 *
 *	For zero-initialized swappable data:
 *
 *	  pd_virginin = routine to zero-fill a page
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *	The following four fields are entry points in the pager which
     *	we call to page in or page out a page.	The following parameters
     *	are passed to the pager during these calls:
     *
     *	ppagerdata - pointer to the pager-specific dword of data
     *		 stored with the virtual page.	The pager is
     *		 free to modify the contents of this dword
     *		 DURING the page in or out, but not afterwards.
     *
     *	ppage - pointer to page going in or out (a ring 0 alias
     *	    to the physical page).  The pager should use this
     *	    address to access the contents of the page.
     *
     *	faultpage - faulting linear page number for page-ins, -1 for
     *		page-outs.  This address should not be accessed
     *		by the pager.  It is provided for information
     *		only.  Note that a single page can be mapped at
     *		more than one linear address because of the
     *		MapIntoV86 and LinMapIntoV86 services.
     *
     *	The pager should return non-0 if the page was successfully
     *	paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *	The pd_*free routines are used to inform the pager when the last
     *	reference to a virtual page controlled by the pager is
     *	decommitted.  A common use of this notification is to
     *	free space in a backing file, or write the page contents
     *	into the backing file.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions, but no return value is recognized.  The "ppage"
     *	and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *	The pd_dirty routine is used to inform the pager when the
     *	memory manager detects that a page has been written to.  The memory
     *	manager does not detect the write at the instant it occurs, so
     *	the pager should not depend upon prompt notification.  A common
     *	use of this notification might be to invalidate cached data.
     *	If the page was dirtied in more than one memory context,
     *	the pager's pd_dirty routine will be called once for each
     *	context.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions except that the "ppage" parameter isn't valid and
     *	no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *	The pd_type field gives the sytem information about the
     *	overcommit characteristics of pages controlled by this pager.
     *	The following are allowable values for the field:
     *
     *	PD_SWAPPER - under some conditions, pages of this type
     *	    may be paged out into the swap file
     *	PD_PAGERONLY - pages controlled by this pager will never
     *	    be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *	    functions perform nested excecution or block using the
     *	    BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *	    specified if the pager does any sort of file i/o to anything
     *	    other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER  0	/* pages need direct accounting in swap file */
#define PD_PAGERONLY	1   /* pages will never be swapped */
#define PD_NESTEXEC 2	/* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

/* XLATOFF */    
#ifndef PAGE
#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#endif
/* XLATON */

#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR	    ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR	    ((ULONG) 0xc0000000)    /* 3 gig */
#ifdef WOW
#define MAXSHAREDLADDR	    ((ULONG) 0x7fffffff)
#define MINSHAREDLADDR	    ((ULONG) 0x40000000)    /* 1   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x3fffffff)
#else
#define MAXSHAREDLADDR	    ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR	    ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#endif
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR	((ULONG) 0x003fffff)
#define MINDOSLADDR	((ULONG) 0x00000000)

#define MAXSYSTEMPAGE	    (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE	    (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE	    (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE	    (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE	    (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE	    (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE	(MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE	(MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE	(1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED	(1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM	(1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS		(1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE	(1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED	(1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM	(1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS		(1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC	(max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC	(max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar	EQU NEAR PTR
ELSE
DebFar	EQU SHORT
ENDIF
*/

#define ASD_MAX_REF_DATA    256	    // If bigger than this, a checksum is used

struct	_vmmguid {
unsigned long Data1;
unsigned short Data2;
unsigned short Data3;
unsigned char Data4[8];
};

typedef struct _vmmguid VMMGUID;
typedef VMMGUID     *VMMREFIID;

typedef DWORD		ASD_RESULT;

#define ASD_ERROR_NONE	    0x00000000
#define ASD_CHECK_FAIL	    0x00000001	// The flag is set that this failed before
#define ASD_CHECK_SUCCESS   0x00000002	// The flag is set that this succeeded before
#define ASD_CHECK_UNKNOWN   0x00000003	// No flag is set
#define ASD_ERROR_BAD_TIME  0x00000004	// Under cli
#define ASD_REGISTRY_ERROR  0x00000005	// Unknown registry error
#define ASD_CLEAN_BOOT	    0x00000006	// Clean booting fails everything
#define ASD_OUT_OF_MEMORY   0x00000007	// Ran out of memory (extremely rare)
#define ASD_FILE_ERROR	    0x00000008	// Int 21 to flush the info file failed
#define ASD_ALREADY_SET     0x00000009	// ASD_CHECK* done twice on same vgOperation/pRefData
#define ASD_MISSING_CHECK   0x0000000A	// ASD_DONE* on something not set
#define ASD_BAD_PARAMETER   0x0000000B	// Invalid operation, refiid or ref pointer

#define ASD_OP_CHECK_AND_WRITE_FAIL_IF_UNKNOWN	0x00000000
#define ASD_OP_CHECK_AND_ALWAYS_WRITE_FAIL	0x00000001
#define ASD_OP_CHECK				0x00000002
#define ASD_OP_DONE_AND_SET_SUCCESS		0x00000003
#define ASD_OP_SET_FAIL 			0x00000004
#define ASD_OP_SET_SUCCESS			0x00000005
#define ASD_OP_SET_UNKNOWN			0x00000006
#define ASD_OP_DONE				0x00000007

#define ASD_FLAG_STRING     0x00000001

#ifndef Not_VxD

/******************************************************************************
 *
 *	     EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.	Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000	/* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT	0x0001	    /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.	Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE	    0x0002	/* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT	0x0003	    /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */
#define SYS_VM_TERMINATE    0x0004	/* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT	0x0005	    /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.	SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006	/* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM	0x0007

/*
 *  Second phase of Create_VM.	EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT 	0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE	    0x000A	/* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.	VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B	/* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.	EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM	0x000C	    /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00	/* VM was crashed */
#define VNE_CRASHED	(1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT	    0x01	/* VM was destroyed while active */
#define VNE_NUKED	(1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02	/* Some device failed Create_VM */
#define VNE_CREATEFAIL	    (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03	/* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL	    (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04	/* Some device failed VM_Init */
#define VNE_INITFAIL	    (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT	    0x05
#define VNE_CLOSED	(1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND	0x000D	    /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME	0x000E	    /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.	Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012	/* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY	    0x0013	/* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY	0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP	    0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT	0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP	0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY	0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *	  CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT	0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD	0x001D

/*
 *  Second phase of creating a thread.	EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT	0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 * BUGBUG: need more doc here, describing the interface
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN	DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2	    0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2	    0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2	0x0029
#define VM_SUSPEND2	0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2	0x002C
#define DEVICE_REBOOT_NOTIFY2	0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER	0x0030

#define KERNEL32_INITIALIZED	0x0031

#define KERNEL32_SHUTDOWN	0x0032

#define CREATE_PROCESS		0x0033
#define DESTROY_PROCESS 	0x0034

#ifndef WIN40COMPAT
#define SYS_DYNAMIC_DEVICE_REINIT 0x0035
#endif
#define SYS_POWER_DOWN		0x0036

#define MAX_SYSTEM_CONTROL	0x0036

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL 0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

		    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
		    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT	    0x10000000
		    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
		    /* INIT_COMPLETE is broadcast */
		    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
		    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
		    /* All initialization completed */
		    /* System running normally */
		    /* System shutdown initiated */
		    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
		    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
		    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT	    0xE0000000
		    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
		    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
		    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
		    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
		    /* Return to real mode */
		    /* Alternate path: CAD reboot */
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
		    /* DEVICE_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PRECRITREBOOT	    0xFFFFF000
		    /* CRIT_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PREREBOOTCPU	    0xFFFFFF00
		    /* REBOOT_PROCESSOR is broadcast */
		    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC		; Used outside this module (default)
;   LOCAL		; Local to this module
;   HIGH_FREQ		; DWORD align procedure
;   SERVICE		; Routine is called via VxDCall
;   ASYNC_SERVICE	    ; Same as "SERVICE" plus routine can
;		    ;	be called under interrupt.
;   HOOK_PROC		; Proc is a handler installed with
;		    ;	with a call to Hook_xxx_Fault
;		    ;	or Hook_Device_Service.  The
;		    ;	following parameter must be
;		    ;	the label of a DWORD location
;		    ;	which will hold the ptr to next
;		    ;	hook proc. e.g.
;
;		   ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG		; Disable Queue_Out call logging
;   NO_PROFILE		; Disable DynaLink profile counts
;   NO_TEST_CLD 	; Disable direction flag check
;
;   TEST_BLOCK		; Trap if in NOBLOCK state
;		    ;  (default if in pageable code seg)
;   TEST_REENTER	    ; Trap if Get_VMM_Reenter_Count != 0
;		    ;  (default for non-async services)
;   NEVER_REENTER	    ; Trap if VMM has been reentered
;   NOT_SWAPPING	    ; Trap if this thread is swapping
;
;   NO_PROLOG		; Disable all prolog tests
;
;   ESP 	    ; Use ESP instead of EBP for stack
;		    ;  frame base
;   PCALL		; pascal calling convention
;   SCALL		; stdcall calling convention
;   FASTCALL		; stdcall, but first 2 parameters are passed in ECX & EDX
;   CCALL		; "C" calling convention
;   ICALL		; default calling convention
;   W32SVC		; Win32 service
;
;   segment type	    ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type	    ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1	;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed	equ 2	    ;; ArgVars were used
??_pf_Entered	equ 4	    ;; EnterProc performed
??_pf_Left  equ 8	;; LeaveProc performed
??_pf_Returned	equ    16		;; Return performed

??_inline	=	0		; Inline the service
??_inline_end	equ	<>		; End of code to inline
??_pushed	=	0		; For WIN31COMPAT
??_align	=	0		; For WIN31COMPAT
??_ends		equ	<>		; BeginProc segment

INLINE_MAGIC_W	equ	02EBh		; Inline service magic number (JMP $+4)
INLINE_MAGIC_B	equ	0F1h		; Inline service magic number

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0		;; local frame base
    ??_aframe = 0		;; argument frame base
    ??_taframe = 0		;; true argument frame base
    ??_initaframe = 0		;; initial aframe value
    ??_numargs = 0		;; number of argvars
    ??_numlocals = 0		;; number of localvars
    ??_numlocalsymbols = 0	;; number of local symbols
    ??_procflags = 0		;; misc. Enter/LeaveProc flags
    ??_esp = 0			;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0		;; number of bytes pushed
    ??_align = 0		;; set if proc should be dword aligned
    ??_hook = 0 		;; set if proc is a Hook_Proc
    ??_inline = 0		;; Assume not inlined
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG		;; logging on by default
    ??_profile = DFS_PROFILE	;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD	;; test that direction is clear
ELSE
    ??_log = 0			;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE	;; service profiling on by default
ELSE
    ??_profile = 0		;; service profiling off
ENDIF
ELSE
    ??_profile = 0		;; service profiling off
ENDIF
ELSE
    ??_profile = 0		;; service profiling off
ENDIF
    ??_test_cld = 0		;; test that direction is clear
ENDIF
    ??_might_block = 0		;; entering fn might cause VM to block
    ??_test_reenter = 0 	;; don't test for VMM reentry
    ??_never_reenter = 0	;; don't test for genuine VMM reentry
    ??_not_swapping = 0 	;; don't test that we're not swapping
    ??_prolog_disabled = 0	;; use a prolog by default
    ??_public = 1		;; everything's public by default
    ??_cleanoff = 0		;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_fastcall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0		;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
	if ??_hookarg
	    ??_hookarg = 0
	    ??_hookvar equ <arg>
	elseifdef ?&&arg&&_BeginProc
	    ?&&arg&&_BeginProc
	elseifdef VxD_&&arg&&_CODE_SEG
	    ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
	    VxD_&&arg&&_CODE_SEG
	else
	    .err <Bad param "&arg" to BeginProc>
	endif
    endm
    ife ??_service
	??_inline = 0		;; Only services can be inlined
    endif

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
    ife ??_service
	ifndef profileall
	  ??_profile = 0      ;; only services can be profiled
	endif
	ifdef VMMSYS
	??_prolog_disabled = 1
	endif
    else
	??_test_cld = DFS_TEST_CLD
    endif	; ife ??_service

    ife ?_16ICODE
	??_prolog_disabled = 1
    else
    ife ?_RCODE 	    ;; if real-mode code segment
	??_prolog_disabled = 1	;; don't do anything stupid
    else		;; else protected mode code segment
	ife ?_PCODE	;; if swappable code
	??_might_block = DFS_TEST_BLOCK
	endif
	if ??_service
	ife ??_async_service
	    ??_test_reenter = DFS_TEST_REENTER
	endif
	endif
    endif	; ife ?_RCODE
    endif	; ife ?_16ICODE
    endif   ; Not_VxD

    if ??_esp
    ;; just return address on stack
    ??_basereg equ <esp+??_pushed>
    ??_initaframe = 4
    else
    ;; ret addr and EBP on stack
    ??_basereg equ <ebp>
    ??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall or ??_fastcall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
	 ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
	??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

    if ??_hook
	if ??_align
	Dword_Align
	endif
	prelabeldata:
	ifndef ??_hookvar
	.err <HOOK_PROC requires next arg to be name of dword location>
	endif
	jmp short Name
	jmp [??_hookvar]
	ifdef DEBUG
	Profile_Data dd  0
	endif
	if ??_align
	.errnz ($ - prelabeldata) mod 4
	endif
    endif

    ifdef DEBUG
	?prolog_&Name label near
	if (??_service OR ??_profile) AND (??_hook EQ 0)
	jmp short Name
	if ??_align
	Dword_Align	; This also aligns the proc
	endif		;   since Profile_Data is a dd

	IF ?_ICODE
	ifdef profileall
	  ?ProfileHeader_BeginProc Profile_Data, %@filename
	else
	  Profile_Data dd 0
	endif
	ELSE
	  Profile_Data dd 0
	ENDIF

	endif
    endif

    if ??_align
	Dword_Align
    endif

    endif   ; Not_VxD

    Name proc near	;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;	     Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall or ??_fastcall    ;; if no munging
	if ??_public
	    public Name
	else
	    ifdef DEBUG
		% ?merge @FileName,$,Name,:
		% ?merge public,,,,,@FileName,$,Name
	    endif
	endif
    endif
    if ??_ccall
	if ??_public
	    _&Name equ Name
	ifdef Not_VxD
	 public C Name
	else
		 public _&Name
	endif
	endif
    endif
    if ??_pcall
	if ??_public
	    ?toupper Name
	    ?merge  public,,,,%?upper
	endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;	     DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service

    ife ??_scall or ??_fastcall or ??_inline
    ?_BeginProc_Debug_Prologue
    endif

    ;; Phase 7:  Post-label code
    if ??_inline
	??_inline_end textequ <__&Name&_END__>
	dw	INLINE_MAGIC_W
	db	INLINE_MAGIC_B
	db	??_inline_end - ($ + 1)
    endif
endm

?_BeginProc_Debug_Prologue MACRO
    ifndef Not_VxD
    ifdef DEBUG
	if ??_dfs EQ DFS_LOG
	VMMCall Log_Proc_Call	;; no test, just log
	else
	if ??_dfs EQ DFS_TEST_REENTER
	VMMCall Test_Reenter	;; no log, just reenter
	else
	if ??_dfs or ?_LOCKABLECODE eq 0
	ifdef WIN31COMPAT
	    if ??_dfs AND DFS_LOG
	    VMMCall Log_Proc_Call
	    endif
	    if ??_dfs AND DFS_TEST_REENTER
	    VMMCall Test_Reenter
	    endif
	else
	    ife ?_LOCKABLECODE
	    ifdef ??_debug_flags
	    push    ??_debug_flags
	    if ??_dfs
	    pushfd
	    or	dword ptr [esp+4],??_dfs
	    popfd
	    endif
	    VMMCall _Debug_Flags_Service
	    elseif ??_dfs
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	    else
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	endif
	else
	  ifdef profileall
	IncProfileCount
	  endif
	endif		;if ??_dfs
	endif		; if ??_dfs EQ DFS_TEST_REENTER
	endif		; if ??_dfs EQ DFS_LOG
    endif ; DEBUG
    endif ; Not_VxD
ENDM

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?INLINE_BeginProc macro
    ??_inline = 1
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
    .erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
    .erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?FASTCALL_BeginProc macro
    ??_fastcall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
	inc dword ptr [??_name-4]
    else
	ifndef profileall
	.err <IncProfileCount can be used only in services.>
	endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***	ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;	 to indicate that the argument will not be used
;	 by the procedure.
;

ArgVar	macro	name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
	?mkarg	<name>, <length>, <used>, %??_numargs
    else
	?arg <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg	macro	name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
	?argvar <name>, <length>, <used>
	&endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro	name,length,used
    local   a
    a = ??_taframe
    ??_aframe =  ??_aframe + 4
    ??_taframe =  ??_taframe + 4
    ifidni  <length>,<BYTE>
	?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
	?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
	?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
	?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
	??_aframe =  ??_aframe - 4 + ((length + 3)/4)*4
	??_taframe =  ??_taframe - 4 + ((length + 3)/4)*4
	?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

?arg macro   name,length,used
  if ??_fastcall
    if ??_numargs le 2
      if length gt 4
	.err <First 2 parameters are dwords (ecx,edx) for fastcall functions>
      endif
      ??_aframe =  ??_aframe + 4
      if ??_numargs eq 1
	?merge ecx_,name,,,equ,ecx
      else
	?merge edx_,name,,,equ,edx
      endif
    else
      ?argvar name, length, used
    endif
  else
    ?argvar name, length, used
  endif
endm

;***	?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
	name equ _inaccessible_NOTUSED_
    else
	name equ value
	??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***	LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;	 to suppress the usual padding and aligning of variables
;	 PACK is typically used when declaring a bunch of
;	 byte or word variables.  Make sure that the total
;	 size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
	??_pad = 0
    endif
    ifidni  <length>,<BYTE>
	??_frame = ??_frame + 1 + 3 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
	??_frame =  ??_frame + 2 + 2 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
	??_frame = ??_frame + 4
	a = ??_frame
	?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
	name equ dword ptr [??_basereg-a]
	name&l equ word ptr [??_basereg-a]
	name&ll equ byte ptr [??_basereg-a]
	name&lh equ byte ptr [??_basereg-a+1]
	name&h equ word ptr [??_basereg-a+2]
	name&hl equ byte ptr [??_basereg-a+2]
	name&hh equ byte ptr [??_basereg-a+3]
    else
	??_frame =  ??_frame + ((length + 3)/4)*4
	a = ??_frame
	?deflocal <name>
	name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
	??_numlocalsymbols = ??_numlocalsymbols + 1
	?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
	name	equ <__inaccessible__NOTINSCOPE__>
	&endm
    endm
    .xcref  ?dodeflocal

;***	EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	_,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,_,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_fastcall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	@,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,@,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_pcall
	??_aframe = 0
	?count = ??_numargs
	rept	??_numargs
	    ?invprg <?MKA>,%?count
	    ?count = ?count - 1
	endm
    endif
    ??_fleave = FALSE
    if ??_esp
	if  ??_frame
	    sub esp, ??_frame
	    ??_pushed = ??_pushed + ??_frame
	    ??_fleave = VMM_TRUE
	endif
    else
	if  ??_frame eq 0
	    if (??_taframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
		ifdef DEBUG
		    push    ebp
		    mov ebp,esp
		    ??_fleave = VMM_TRUE
		endif
	    else
		push	ebp
		mov ebp,esp
		??_fleave = VMM_TRUE
	    endif
	else
	    enter   ??_frame, 0
	    ??_fleave = VMM_TRUE
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***	LeaveProc - removes stack frame on exit
;
;   NOTE:   If there are localvar and ESP kind of stack frame
;	LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;	flag is given.	PRESERVE_FLAGS generates bigger, slower
;	code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;	 the internal stack depth for the local frame.	This is
;	 to allow jumping around the LeaveProc/Return to code
;	 after the LeaveProc/Return to use args/local variables,
;	 but code that uses the stack frame executed after the
;	 LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
	if ??_esp
	    ifidni <flags>,<PRESERVE_FLAGS>
		lea esp,[esp + ??_frame]
	    else
		add esp,??_frame
	    endif
	else
	    leave
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***	Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return	macro
    if	??_cleanoff OR ??_w32svc
	if ??_inline
	    .err <Service cannot be inlined!>
	endif
	if  ??_w32svc AND (??_taframe LT 8)
	    ret 8
	else
	    ret ??_taframe
	endif
    else
	if ??_inline
	    ??_inline_end LABEL NEAR
	    ??_inline = 0
	endif
	ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***	EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp		;; Masm will provide error msg for us
if ??_w32svc
    if ??_taframe lt 8
	cparm&Name equ 0
    else
	cparm&Name equ (??_taframe/4 - 2)
    endif
endif
if ??_inline
    .err <Return macro missing in INLINEd procedure Name>
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi	<Flag>,<NOCHECK>
    if ??_pushed ne 0
	%out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
	ife ??_procflags AND ??_pf_Entered
	    %out Warning: ArgVar/LocalVar without EnterProc in Name
	endif
	ife ??_procflags AND ??_pf_Left
	    %out Warning: ArgVar/LocalVar without LeaveProc in Name
	endif
	ife ??_procflags AND ??_pf_Returned
	    %out Warning: ArgVar/LocalVar without Return in Name
	endif
    endif
endif
ifdifi	<Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
	?count = ?count + 1
	?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    ??_inline_end equ <>
    endm

;***	cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall	macro	name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    ifdef ??_nonstandardccall_&name
    PushCParams <arglst>, <FAST>
    else
    PushCParams <arglst>, <flags>
    endif
    call    name
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    endm
    .xcref  cCall

;***	pCall - pascal call
;
;   Arguments pushed in pascal order, callee cleans stack
;

pCall	macro	name, arglst
    local   ??saved
    ife .TYPE name
	?toupper name
    else
	?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
	push	x
	??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***	sCall - standard call
;
;   Arguments pushed in "C" order, callee cleans stack,
;   @argc appended to name
;

sCall	macro	name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  _, name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***	fCall - fastcall call
;
;   Arguments pushed in "C" order (except first two parms,
;   which are passed in ECX and EDX), callee cleans stack, and
;   @argc appended to name.
;
;   The only useful value for flags is PRESERVE_FLAGS,
;   which can also be achieved by simply declaring the function
;   as non-standard, like so:
;
;	DeclareNonstandardCcallService <functionname>
;

fCall	macro	name, arglst, flags
    local   ??saved
    ??saved = ??_pushed
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <FASTCALL>
    ?scall  @, name, %(??_argc * 4)
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    ??_pushed = ??saved
    endm
    .xcref  fCall

;***	iCall - internal routine call
;
;   Set to whatever type we want to use as a default.

iCall	equ <sCall>

;***	PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;	the word FAST if we should prefer speed over size
;
;	The default flag is SMALL, unless the current procedure
;	is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF	STANDARD_CCALL
NONSTANDARD_CCALL = 1		;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    LOCAL ??_pushedargs

    ??_argc = 0 	;; number of dwords on stack (global)
IFDEF	NONSTANDARD_CCALL
    ??_popargs = 0		;; establish default
ELSE
    ??_popargs = ??_align EQ 0	;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
	??_popargs = 1		;; size, not speed
    elseifidni <flags>, <FAST>
	??_popargs = 0		;; speed, not size
    elseifidni <flags>, <FASTCALL>
	??_popargs = 0		;; speed, not size
    endif

    irp x,<arglst>
	??_argc = ??_argc + 1
	ifidni <flags>, <FASTCALL>
	  if ??_argc eq 1
	    ifdifi <x>, <ecx>
	      .err <first parameter must be ECX for fastcall functions>
	    endif
	  elseif ??_argc eq 2
	    ifdifi <x>, <edx>
	      .err <first parameter must be EDX for fastcall functions>
	    endif
	  else
	    ?marg   <x>,%??_argc
	  endif
	else
	  ?marg   <x>,%??_argc
	endif
    endm
    ?count = ??_argc
    ifidni <flags>, <FASTCALL>
      ??_pushedargs = ??_argc-2
    else
      ??_pushedargs = ??_argc
    endif
    if ??_pushedargs GT 0
      rept    ??_argc
	?invprg <?AM>,%?count
	?count = ?count - 1
      endm
    endif
    endm

;***	ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;   If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;   This will generate bigger, slower code, so use it only when
;   necessary.

ClearCParams macro fPreserveFlags
    if	??_argc ne 0
	if (??_popargs) AND (??_argc LE 2)
	  rept ??_argc
	  pop ecx
	  endm
	elseifidni <fPreserveFlags>, <PRESERVE_FLAGS>
	  lea esp, [esp][??_argc * 4]
	else
	  add esp,??_argc * 4
	endif
    endif
    ??_pushed = ??_pushed - (??_argc * 4)
    endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg	macro	name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
	push	name
	??_pushed = ??_pushed + 4
	&endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro	name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall	macro	prefix, name1, name2
    CondExtern prefix&name1&@&name2, near
    call    prefix&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge	macro	l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
	if '&x' GE 'a'
	  if '&x' LE 'z'
	?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
	?upper catstr ?upper,?t1
	  else
	?upper catstr ?upper,<&x>
	  endif
	else
	  ?upper catstr ?upper,<&x>
	endif
      endm
    endm
    .xcref

;***	CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
	ifndef name
	externdef name:dist
	endif
    else
	if2
	ifndef name
	    extrn name:dist
	endif
	endif
    endif
endm

;***	SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro	reglist 	;; push those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    pushfd
	    ??_pushed = ??_pushed + 4
	else
	ifidni <reg>, <ad>
	    pushad
	    ??_pushed = ??_pushed + SIZE Pushad_Struc
	else
	    push    reg
	    ??_pushed = ??_pushed + 4
	endif
	endif
    endm
endm

;***	RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist	;; pop those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    popfd
	    ??_pushed = ??_pushed - 4
	else
	ifidni <reg>, <ad>
	    popad
	    ??_pushed = ??_pushed - SIZE Pushad_Struc
	else
	    pop reg
	    ??_pushed = ??_pushed - 4
	endif
	endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.	Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db	'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd	OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd	0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *	   S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST	0x00000010
#define HIGH_PRI_DEVICE_BOOST	0x00001000
#define CRITICAL_SECTION_BOOST	0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S	 F O R	 C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT	    0
#define PEF_WAIT_FOR_STI	(1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT	    1
#define PEF_WAIT_NOT_CRIT	(1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT	    2
#define PEF_DONT_UNBOOST	(1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT	    3
#define PEF_ALWAYS_SCHED	(1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT	4
#define PEF_TIME_OUT		(1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT	(1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT	6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT	7
#define PEF_WAIT_IN_PM		(1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT	    8
#define PEF_THREAD_EVENT	(1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT	    10
#define PEF_RING0_EVENT 	(1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	11
#define PEF_WAIT_CRIT	    (1 << PEF_WAIT_CRIT_BIT)

#define PEF_WAIT_CRIT_VM_BIT	    12
#define PEF_WAIT_CRIT_VM    (1 << PEF_WAIT_CRIT_VM_BIT)

#define PEF_PROCESS_LAST_BIT	    13
#define PEF_PROCESS_LAST    (1 << PEF_PROCESS_LAST_BIT)

#define PEF_WAIT_PREEMPTABLE_BIT    14
#define PEF_WAIT_PREEMPTABLE (1 << PEF_WAIT_PREEMPTABLE_BIT)

#define PEF_WAIT_FOR_PASSIVE_BIT	    15
#define	PEF_WAIT_FOR_PASSIVE     (1 << PEF_WAIT_FOR_PASSIVE_BIT)

//
// The next two are equivalent of SHELL_Call_At_Appy_Time and ExQueueWorkItem,
// they are mostly to be used by _Set_Global_Time_Out_Ex. No other flag can be
// set with them. Note that the dispatching of the callback of these two new
// PEF (with both Call_Restricted_Event and _Set_Global_Time_Out_Ex) follow
// the original convention but EDX (the ref data) is CDECL pushed/pop on the
// stack, so that the callback function can be a standard
// VOID CDECL FOO(ULONG BAR);
//
	
#define PEF_WAIT_FOR_APPY_BIT	    16
#define	PEF_WAIT_FOR_APPY     (1 << PEF_WAIT_FOR_APPY_BIT)

#define PEF_WAIT_FOR_WORKER_BIT	    17
#define	PEF_WAIT_FOR_WORKER     (1 << PEF_WAIT_FOR_WORKER_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT	     PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK	 PEF_WAIT_NOT_NESTED_EXEC

//
// If you may want to call CONFIGMG synchronously at some point.
//
#define	PEF_WAIT_FOR_CONFIGMG_CALLABLE	PEF_WAIT_FOR_WORKER

//
// If you will want to call CONFIGMG synchronously (slower callback, but no
// context switch in CONFIGMG).
//
#define	PEF_WAIT_FOR_CONFIGMG_QUICK	PEF_WAIT_FOR_APPY

/******************************************************************************
 *	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *			     E N T E R _ M U T E X
 *	       A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT	0
#define BLOCK_SVC_INTS		(1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT	1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT	    2
#define BLOCK_ENABLE_INTS	(1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT		3
#define BLOCK_POLL	    (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT		4
#define BLOCK_THREAD_IDLE		(1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT	5
#define BLOCK_FORCE_SVC_INTS	    (1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;		/* Client's EDI */
    ULONG Client_ESI;		/* Client's ESI */
    ULONG Client_EBP;		/* Client's EBP */
    ULONG Client_res0;		/* ESP at pushall */
    ULONG Client_EBX;		/* Client's EBX */
    ULONG Client_EDX;		/* Client's EDX */
    ULONG Client_ECX;		/* Client's ECX */
    ULONG Client_EAX;		/* Client's EAX */
    ULONG Client_Error; 	/* Dword error code */
    ULONG Client_EIP;		/* EIP */
    USHORT Client_CS;		/* CS */
    USHORT Client_res1; 	/*   (padding) */
    ULONG Client_EFlags;	/* EFLAGS */
    ULONG Client_ESP;		/* ESP */
    USHORT Client_SS;		/* SS */
    USHORT Client_res2; 	/*   (padding) */
    USHORT Client_ES;		/* ES */
    USHORT Client_res3; 	/*   (padding) */
    USHORT Client_DS;		/* DS */
    USHORT Client_res4; 	/*   (padding) */
    USHORT Client_FS;		/* FS */
    USHORT Client_res5; 	/*   (padding) */
    USHORT Client_GS;		/* GS */
    USHORT Client_res6; 	/*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;		/* Client's DI */
    USHORT Client_res13;	/*   (padding) */
    USHORT Client_SI;		/* Client's SI */
    USHORT Client_res14;	/*   (padding) */
    USHORT Client_BP;		/* Client's BP */
    USHORT Client_res15;	/*   (padding) */
    ULONG Client_res16; 	/* ESP at pushall */
    USHORT Client_BX;		/* Client's BX */
    USHORT Client_res17;	/*   (padding) */
    USHORT Client_DX;		/* Client's DX */
    USHORT Client_res18;	/*   (padding) */
    USHORT Client_CX;		/* Client's CX */
    USHORT Client_res19;	/*   (padding) */
    USHORT Client_AX;		/* Client's AX */
    USHORT Client_res20;	/*   (padding) */
    ULONG Client_res21; 	/* Dword error code */
    USHORT Client_IP;		/* Client's IP */
    USHORT Client_res22;	/*   (padding) */
    ULONG Client_res23; 	/* CS */
    USHORT Client_Flags;	/* Client's flags (low) */
    USHORT Client_res24;	/*   (padding) */
    USHORT Client_SP;		/* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];	/* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;		/* Client's BL */
    UCHAR Client_BH;		/* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;		/* Client's DL */
    UCHAR Client_DH;		/* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;		/* Client's CL */
    UCHAR Client_CH;		/* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;		/* Client's AL */
    UCHAR Client_AH;		/* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc	  CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0	/* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT	0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;   Declare services as conforming to the C calling convention
;   for parameter-passing, but *not* conforming to the C calling
;   convention for register usage.
;
;   Services which do not use the C calling convention for
;   parameter-passing need not be declared as nonstandard.
;
;   arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
    irp x,<arglst>
	??_nonstandardccall_&&x = 1
    endm
endm

;
; The following VMM services are nonstandard:
;	_BlockOnID and _LocalizeSprintf modify no registers except flags.
;	_SetLastV86Page modifies no registers except EAX and flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints	; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd	OFFSET32 vt[sn+jf]
ENDM

GenDD	MACRO	P, vid, snum, jflag
    LOCAL   vtable
IFDEF	@@VxDName&vid
    Deftable	vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd	@@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)

    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

VxDJmp	MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

WDMCall MACRO P, Param, flags
    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    mov	eax,WDM@@&P
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

WDMJmp	MACRO P, Param
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to WDMJmp>
    endif
    mov	eax, WDM@@&P+WDM_DL_Jmp_Mask
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ENDM

WDM_DL_Jmp_Mask	EQU	80000000h
WDM_DL_Jmp_Bit	EQU	31

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;VxD_LOCKED_CODE_SEG	defines start of always present code segment
;VxD_LOCKED_CODE_ENDS	defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG	defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT	 ENDS
	ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT	 ENDS
	ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DB1CODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
	ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DB1CODE    ENDS
	ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT	ENDS
	ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
	ENDM


;   Protected mode initialization data

VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
	ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
	ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA	 ENDS
	ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT	 ENDS
	ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA	 ENDS
	ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DB2DATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DB2DATA    ENDS
	ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
	  ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
	   ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
	  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
	   ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A	    /* 3.10 */
#else  // WIN31COMPAT

#ifdef WIN40COMPAT
#define DDK_VERSION 0x400	    /* 4.00 */
#else  // WIN40COMPAT

#ifdef WIN41COMPAT
#define DDK_VERSION 0x40A	    /*Memphis is 4.1 */
#else  // WIN41COMPAT

#define DDK_VERSION 0x45A	    /*Millennium is 4.90 */

#endif // WIN41COMPAT

#endif // WIN40COMPAT

#endif // WIN31COMPAT

#endif // DDK_VERSION

struct VxD_Desc_Block {
    ULONG DDB_Next;	    /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;	/* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <DDK_VERSION SHR 8> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <DDK_VERSION AND 0FFh> Minor device number */
    USHORT DDB_Flags;		/* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];		/* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;	/* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;	/* Offset of control procedure */
    ULONG DDB_V86_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;	    /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;	    /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Size;	/* INIT <SIZE(VxD_Desc_Block)> Reserved */
    ULONG DDB_Reserved1;	/* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;	/* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;	/* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block	    *PVMMDDB;
typedef PVMMDDB 	    *PPVMMDDB;

#ifndef Not_VxD

/* XLATOFF */

typedef (_cdecl * VXD_C_SERVICE)();
typedef VXD_C_SERVICE VXD_SERVICE_TABLE[];

#define	Declare_Virtual_Device(quote_name, name, ctrl_proc, device_num, init_order, V86_proc, PM_proc, ref_data) \
struct VxD_Desc_Block name##_DDB={ \
0, \
DDK_VERSION, \
device_num, \
DDK_VERSION >> 8, \
DDK_VERSION & 0XFF, \
0, \
quote_name, \
init_order, \
(ULONG)ctrl_proc, \
(ULONG)V86_proc, \
(ULONG)PM_proc, \
0, \
0, \
ref_data, \
0, \
0, \
0, \
0, \
sizeof(struct VxD_Desc_Block), \
'Rsv1', \
'Rsv2', \
'Rsv3' \
};

#define	Declare_Virtual_Device_With_Table(quote_name, name, ctrl_proc, device_num, init_order, V86_proc, PM_proc, ref_data, table_ptr) \
struct VxD_Desc_Block name##_DDB={ \
0, \
DDK_VERSION, \
device_num, \
DDK_VERSION >> 8, \
DDK_VERSION & 0XFF, \
0, \
quote_name, \
init_order, \
(ULONG)ctrl_proc, \
(ULONG)V86_proc, \
(ULONG)PM_proc, \
0, \
0, \
ref_data, \
(ULONG)table_ptr, \
(ULONG)(sizeof(table_ptr)/sizeof(VXD_C_SERVICE)), \
0, \
0, \
sizeof(struct VxD_Desc_Block), \
'Rsv1', \
'Rsv2', \
'Rsv3' \
};

/* XLATON */

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE	    (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE	    (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT	    14
#define DDB_HAS_WIN32_SVCS	(1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT	15
#define DDB_DYNAMIC_VXD 	(1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED	    (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB	<Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
	Ref_Data_Offset EQU 0
ELSE
	Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db	0dh, 0ah, 'D_E_B_U_G===>'
	db	"&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
	     OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
	     ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd	OFFSET32 ??_cd_&&num
ELSE
    dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc 	    ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz	Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT	0x014

#define OUTPUT_BIT  2
#define OUTPUT	    (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT	4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT	5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO	    (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT	7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT	8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT	0x10		/* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb	In_Proc
ELSE
    je	Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw	Table_Name&_Entries
ELSE
    dw	?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw	Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw	Port
    dd	OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
	ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	   If compiled with debugging then this will generate a call
;	   followed by a return.  If non-debugging version then the
;	   specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   CallJmp -- Call procedure then jump to label.  For debugging purposes only.
;	   If compiled with debugging then this will generate a call
;	   followed by a jmp.  If non-debugging version then the desired return
;          address will be pushed on the stack and the specified label will
;          be jumped to.
;
;   PARAMETERS:
;   Function_Name = Procedure to be called
;   Return_Label  = Address to return to
;
;   EXIT:
;
;------------------------------------------------------------------------------
EndDoc

CallJmp MACRO Function_Name, Return_Label
IFDEF DEBUG
    call    Function_Name
    jmp     Return_Label
ELSE
    push    Return_Label
    jmp     Function_Name
ENDIF
    ENDM


BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF	DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
	VMMCall _ExecVxDIntMustComplete
    ENDM

Load_FS 	macro
	VMMCall Load_FS_Service
endm
*/

/*XLATOFF*/
#define Load_FS VMMCall(Load_FS_Service)
/*XLATON*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0	/* loaded */
#define DUPLICATE_DEVICE_ID	(1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1	/* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F	    (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT	    2	/* in the INT 2F device list */
#define LOADING_FROM_INT2F	(1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK	    0	/* load protected mode portion */
#define ABORT_DEVICE_LOAD   1	/* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2	/* fatal-error: abort load of Win386 */
#define DEVICE_NOT_NEEDED   3	/* don't load protected mode portion */
				/* b/c the driver's presence is not needed */



#define NO_FAIL_MESSAGE_BIT 15	/* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0	/* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING	1   /* search for next string */
#define LDRSRV_RESERVED 	2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3	/* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT	4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5	/* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6	/* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO	    7	/* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey	0x100
#define LDRSRV_RegCreateKey	0x101
#define LDRSRV_RegCloseKey	0x102
#define LDRSRV_RegDeleteKey	0x103
#define LDRSRV_RegSetValue	0x104
#define LDRSRV_RegQueryValue	    0x105
#define LDRSRV_RegEnumKey	0x106
#define LDRSRV_RegDeleteValue	    0x107
#define LDRSRV_RegEnumValue	0x108
#define LDRSRV_RegQueryValueEx	    0x109
#define LDRSRV_RegSetValueEx	    0x10A
#define LDRSRV_RegFlushKey	0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT	1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED	2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE	    3	/* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*	    Also Init type objects should be added to the second part of the
*	    list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ	-1

#define LCODE_OBJ	0x01
#define LDATA_OBJ	0x02
#define PCODE_OBJ	0x03
#define PDATA_OBJ	0x04
#define SCODE_OBJ	0x05
#define SDATA_OBJ	0x06
#define CODE16_OBJ	0x07
#define LMSG_OBJ	0x08
#define PMSG_OBJ	0x09

#define DBOC_OBJ    0x0B
#define DBOD_OBJ    0x0C

#define PLCODE_OBJ	0x0D
#define PPCODE_OBJ	0x0F

#define ICODE_OBJ	0x11
#define IDATA_OBJ	0x12
#define ICODE16_OBJ	0x13
#define IMSG_OBJ	0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  25

/*****************************************************************************
 *
 *	Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT	    0	/* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT	    1	/* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT	    2	/* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT	    3	/* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT	    4	/* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT	    31	/* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT	    0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT	    2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT	    4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT	    6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT	    7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT	    8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT	    9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT	    10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT	    11	/* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT	    14	/* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT	    16	/* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT	    17	/* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT	    18	/* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19	/* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20	/* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *		PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE	    0x1000	/* page size */

/******************************************************************************
 *
 *		PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES	    (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER	    (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC	    (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM	    0
#define PG_SYS	    1
#define PG_RESERVED1	2
#define PG_PRIVATE  3
#define PG_RESERVED2	4
#define PG_RELOCK   5	    /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES	    0x080	/* present in memory */
#define D_NOTPRES   0	    /* not present in memory */

#define D_DPL0	    0	    /* Ring 0 */
#define D_DPL1	    0x020	/* Ring 1 */
#define D_DPL2	    0x040	/* Ring 2 */
#define D_DPL3	    0x060	/* Ring 3 */

#define D_SEG	    0x010	/* Segment descriptor */
#define D_CTRL	    0	    /* Control descriptor */

#define D_GRAN_BYTE 0x000	/* Segment length is byte granular */
#define D_GRAN_PAGE 0x080	/* Segment length is page granular */
#define D_DEF16     0x000	/* Default operation size is 16 bits */
#define D_DEF32     0x040	/* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE	    0x08	/* code */
#define D_DATA	    0	    /* data */

#define D_X	0	/* if code, exec only */
#define D_RX	    0x02	/* if code, readable */
#define D_C	0x04	    /* if code, conforming */

#define D_R	0	/* if data, read only */
#define D_W	0x02	    /* if data, writable */
#define D_ED	    0x04	/* if data, expand down */

#define D_ACCESSED  1	    /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE	(D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK	0xFFF8	    /* selector index */
#define SEL_LOW_MASK	0xF8	    /* mask for low byte of sel indx */
#define TABLE_MASK  0x04	/* table bit */
#ifndef WOW32_EXTENSIONS
#define RPL_MASK    0x03	/* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */
#endif  // ndef WOW32_EXTENSIONS

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()	{__asm cli}

#define SAVE_FLAGS(flags) {\
_asm pushfd \
_asm pop flags \
}

#define RESTORE_FLAGS(flags) {\
_asm push flags \
_asm popfd \
}

#define IO_Delay() {\
_asm _emit 0xeb \
_asm _emit 0x00 \
}

#define Touch_Register(Register) {_asm xor Register, Register}

typedef DWORD	HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)	// turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;	// count of milliseconds

#pragma warning (default:4209)	// turn on redefine warning (with basedef.h)

typedef DWORD	VMM_SEMAPHORE;

typedef struct _HEAP_ALLOCATE_INFO {
    DWORD   StructSize;
    PVOID   CallerAddress;
    ULONG   Tag;
} HEAP_ALLOCATE_INFO, *PHEAP_ALLOCATE_INFO;

PVOID
_stdcall
HeapAllocateEx(
    ULONG cBytes,
    PVOID Reserved,
    PHEAP_ALLOCATE_INFO AllocateInfo,
    ULONG Flags
    );

VOID
_stdcall
HeapFreeEx(
    PVOID MemBlk,
    PVOID Reserved
    );

#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\vtdapi.h ===
/*****************************************************************************
//;
//  VTDAPI.INC
//;
//  VTDAPI service equates and structures
//;
*****************************************************************************/

#define MULTIMEDIA_OEM_ID       0x0440                 // MS Reserved OEM # 34
#define VTDAPI_DEVICE_ID        MULTIMEDIA_OEM_ID + 2  // VTD API Device

/* VTDAPI_Get_Version
//;
//   ENTRY:
//      AX = 0
//      ES:BX = pointer to VTDAPI_Get_Version_Parameters structure
//
//   RETURNS:
//      SUCCESS: AX == TRUE
//      ERROR:   AX == FALSE
*/
#define VTDAPI_Get_Version      0

/* VTDAPI_Begin_Min_Int_Period
//;
//   ENTRY:
//      AX = 1
//      CX = interrupt period in ms
//
//   RETURNS:
//      SUCCESS: AX != 0
//      ERROR:   AX == 0
*/
#define VTDAPI_Begin_Min_Int_Period     1

/* VTDAPI_End_Min_Int_Period
//;
//   ENTRY:
//      AX = 2
//      ES:BX = pointer to word interrupt period in ms
//;
//   RETURNS:
//      SUCCESS: AX == TIMERR_NOERROR
//      ERROR:   AX == TIMERR_NOCANDO
*/
#define VTDAPI_End_Min_Int_Period       2

/* VTDAPI_Get_Int_Period
//;
//   ENTRY:
//      AX = 3
//;
//   RETURNS:
//      DX:AX = current period (resolution) in ms
*/
#define VTDAPI_Get_Int_Period   3

/* VTDAPI_Get_Sys_Time
//;
//   ENTRY:
//      AX = 4
//;
//   RETURNS:
//      DX:AX = current time in ms
*/
#define VTDAPI_Get_Sys_Time     4

/* VTDAPI_Timer_Start
//;
//   ENTRY:
//      AX = 5
//      ES:BX = pointer to VTDAPI_Timer_Parameters structure
//;
//   RETURNS:
//      SUCCESS: AX != 0, 16 bit timer handle
//      ERROR:   AX == 0
*/
#define VTDAPI_Timer_Start      5

/* VTDAPI_Timer_Stop
//;
//   ENTRY:
//      AX = 6
//      CX = 16 bit timer handle from VTDAPI_Timer_Start
//;
//   RETURNS:
//      SUCCESS: AX == TIMERR_NOERROR
//      ERROR:   AX == TIMERR_NOCANDO, invalid timer handle
*/
#define VTDAPI_Timer_Stop       6

/* VTDAPI_Start_User_Timer
//;
//   ENTRY:
//      AX = 7
//      ES:BX = pointer to VTDAPI_Timer_Parameters structure
//;
//   RETURNS:
//      SUCCESS: EAX != 0, 32 bit timer handle
//      ERROR:   EAX == 0
*/
#define VTDAPI_Start_User_Timer 7

/* VTDAPI_Stop_User_Timer
//;
//   ENTRY:
//      AX = 8
//      ES:BX = pointer to 32 bit timer handle from VTDAPI_Start_User_Timer
//;
//   RETURNS:
//      SUCCESS: AX == 0
//      ERROR:   AX != 0
*/
#define VTDAPI_Stop_User_Timer  8

/* VTDAPI_Get_System_Time_Selector
//;
//   ENTRY:
//      AX = 9
//;
//   RETURNS:
//      SUCCESS: AX = R/O selector to a dword of running ms
//      ERROR:   AX == 0
*/
#define VTDAPI_Get_System_Time_Selector 9

/* VTDAPI_Cleanup_Timers
//;
//   ENTRY:
//      AX = 10
//      CX = CS selector
//;
//   RETURNS:
//      NONE
*/
#define VTDAPI_Cleanup_Timers   10

typedef struct VTDAPI_Get_Version_Parameters {
        DWORD   VTDAPI_Version;
        DWORD   VTDAPI_Min_Period;
        DWORD   VTDAPI_Max_Period;
} VTDAPI_Get_Version_Parameters;

typedef struct VTDAPI_Timer_Parameters {
        WORD    VTDAPI_Timer_Period;
        WORD    VTDAPI_Timer_Resolution;
        DWORD   VTDAPI_Timer_IPCS;
        DWORD   VTDAPI_Timer_Inst;
        WORD    VTDAPI_Timer_Flags;
        DWORD   VTDAPI_Timer_Ring0_Thread;      /* ;Internal */
        DWORD   VTDAPI_Timer_Handle;            /* ;Internal */
} VTDAPI_Timer_Parameters;

#ifndef TIME_ONESHOT
#define TIME_ONESHOT            0x0000  // program timer for single event
#define TIME_PERIODIC           0x0001  // program for continuous periodic event
#endif
#define TIME_PERIODIC_BIT       0x00                                    /* ;Internal */
#define TIME_SYSCB              0x0002  // use windows timer events     /* ;Internal */
#define TIME_EVENT_SET          0x0010  // Set event                    /* ;Internal */
#define TIME_EVENT_PULSE        0x0020  // Pulse event                  /* ;Internal */
#define TIME_APC                0x0040  // APC callback                 /* ;Internal */
#define TIME_VALID_FLAGS        0x0073  // Valid flags                  /* ;Internal */

#ifndef TIMERR_BASE
#define TIMERR_BASE     96
#define TIMERR_NOERROR  0                // no error
#define TIMERR_NOCANDO  (TIMERR_BASE+1)  // the operation wasn't executed
#endif

#define VTDAPI_IOCTL_Get_Version                0               /* ;Internal */
#define VTDAPI_IOCTL_Get_Resolution             1               /* ;Internal */
#define VTDAPI_IOCTL_Begin_Min_Int_Period       2               /* ;Internal */
#define VTDAPI_IOCTL_End_Min_Int_Period         3               /* ;Internal */
#define VTDAPI_IOCTL_Get_Int_Period             4               /* ;Internal */
#define VTDAPI_IOCTL_Get_Sys_Time               5               /* ;Internal */
#define VTDAPI_IOCTL_Timer_Start                6               /* ;Internal */
#define VTDAPI_IOCTL_Timer_Stop                 7               /* ;Internal */
#define VTDAPI_IOCTL_Timer_Rundown              8               /* ;Internal */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\vint.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    VINT.H

Abstract:

    This module contains macro support for manipulating virtual
    interrupt bit from v86 mode and 16bit protect mode. FCLI/FST/FIRET
    result in exact behavior of these instructions on the chip without
    trapping.

Author:

    Sudeepb 08-Dec-1992 Created

Revision History:
    sudeepb 16-Mar-1993 added FIRET

--*/

/*
See \nt\private\inc\vdm.h for a complete list
of the NTVDM state flag bit definitions

INTERRUPT_PENDING_BIT - set if interrupts pending
VIRTUAL_INTERRUPT_BIT - This bit always correctly reflects the interrupt
                        disbale/enable state of the vDM while in 16bit land.

MIPS_BIT_MASK         - tells whether VDM is running on x86/mips
EXEC_BIT_MASK         - tells if DOS is in int21/exec operation.
*/

#define  INTERRUPT_PENDING_BIT      0x0003
#define  VDM_INTS_HOOKED_IN_PM      0x0004
#define  VIRTUAL_INTERRUPT_BIT      0x0200

#define  MIPS_BIT_MASK              0x400
#define  EXEC_BIT_MASK              0x800
#define  RM_BIT_MASK                0x1000
#define  RI_BIT_MASK                0x2000

#define  FIXED_NTVDMSTATE_SEGMENT   0x70
#define  FIXED_NTVDMSTATE_OFFSET    0x14
#define  FIXED_NTVDMSTATE_LINEAR    ((FIXED_NTVDMSTATE_SEGMENT << 4) + FIXED_NTVDMSTATE_OFFSET)
#define  FIXED_NTVDMSTATE_REL40     0x314

#define  FIXED_NTVDMSTATE_SIZE	    4
#define  NTIO_LOAD_SEGMENT	    0x70
#define  NTIO_LOAD_OFFSET           0
#define  pNtVDMState                ((PULONG)FIXED_NTVDMSTATE_LINEAR)

#define  VDM_TIMECHANGE             0x00400000

/* ASM
ifdef   WOW

; FCLI macro should be used in v86mode/16bit  preotect mode code to replace
; costly cli's. Please note that this macro could destroy the Overflow
; bit in the flag.

FCLI	macro
    local a,b,c
    push    ds
    push    ax
    mov     ax,40h
    mov     ds,ax
    lahf
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b
    lock    and	word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
a:
    sahf
    pop     ax
    pop     ds
    jmp     short c
b:
    cli
    jmp     short a
c:
endm

;
; FSTI macro should be used in v86mode or 16bit protectmode code to replace
; costly sti's. Please note that this macro could destroy the Overflow bit
; in the flag.

FSTI   macro
    local a,b,c
    push    ds
    push    ax
    mov     ax,40h
    mov     ds,ax
    lahf
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, INTERRUPT_PENDING_BIT
    jnz     short b
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b
    lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
a:
    sahf
    pop     ax
    pop     ds
    jmp     short c
b:
    sti
    jmp     short a
c:
endm

FIRET MACRO
    local a,b,d,e,f,g,i,j,k
    push    ds
    push    ax

;; Do real IRET on MIPS or if interrupts are pending

    mov     ax,40h
    mov     ds,ax
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b

;; running on x86 can assume 386 or above instructions
    push    bp
    mov     bp,sp
    mov     ax,[bp+10]      ; get flags
    pop     bp
    test    ax,100h         ; test if trap flag is set
    jnz     short b         ; if so, do iret

    test    ax,200h         ; test if interrupt flag is set
    jz      short i         ; ZR -> flag image has IF not set
    lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, INTERRUPT_PENDING_BIT
    jnz     short b
j:
    xchg    ah,al           ; AH=low byte AL=high byte
    cld
    test    al,4            ; check direction flag
    jnz     short d         ;
e:
    test    al,8            ; check overflow flag
    jnz     short f         ; go to f if flag image has OF set
    jo      short k         ; go to k to reset OF
g:
    sahf                    ; set low byte of flags from ah
    pop     ax
    pop     ds
    retf    2               ; IRET and discard flags
i:
    lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
    jmp     short j
f:
    jo      short g         ; all OK if OF bit set in real flag
    ; set the overflow bit in real flag
    push    ax
    mov     al,127
    add     al,2            ; will set OF
    pop     ax
    jmp     short g

k:
    ; reset the OF
    push    ax
    xor     al,al           ; will reset OF
    pop     ax
    jmp     short g
d:
    std
    jmp     short e
b:
    pop     ax
    pop     ds
    iret
endm

else    ; WOW

FCLI    macro
        cli
        endm

FSTI    macro
        sti
        endm

FIRET   macro
        iret
        endm

endif   ; else WOW
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\vwin32.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp.  All Rights Reserved, 1989-1995
 *
 *   Title: vwin32.h -
 *
 *   Version:   4.00
 *
 *   Date:  24-May-1993
 *
 ******************************************************************************/

/*INT32*/

#ifndef _VWIN32_H_
#define _VWIN32_H_

// ;BeginInternal
// Note that this ID has been reserved for us in VMM.H

#define VWIN32_DEVICE_ID    0x0002A

#define VWIN32_VER_MAJOR    0x04
#define VWIN32_VER_MINOR    0x0A

// ;EndInternal

#define THREAD_TYPE_WIN32 VWIN32_DEVICE_ID

#ifndef Not_VxD

/*XLATOFF*/
#define VWIN32_Service  Declare_Service
#define VWIN32_StdCall_Service Declare_SCService
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VWIN32)

VWIN32_Service  (VWIN32_Get_Version, LOCAL)
VWIN32_Service  (VWIN32_DIOCCompletionRoutine, LOCAL)
VWIN32_Service  (_VWIN32_QueueUserApc)
VWIN32_Service  (_VWIN32_Get_Thread_Context)
VWIN32_Service  (_VWIN32_Set_Thread_Context)
VWIN32_Service  (_VWIN32_CopyMem, LOCAL)
VWIN32_Service  (_VWIN32_Npx_Exception)
VWIN32_Service  (_VWIN32_Emulate_Npx)
VWIN32_Service  (_VWIN32_CheckDelayedNpxTrap)
VWIN32_Service  (VWIN32_EnterCrstR0)
VWIN32_Service  (VWIN32_LeaveCrstR0)
VWIN32_Service  (_VWIN32_FaultPopup)
VWIN32_Service  (VWIN32_GetContextHandle)
VWIN32_Service  (VWIN32_GetCurrentProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_SetWin32Event)
VWIN32_Service  (_VWIN32_PulseWin32Event)
VWIN32_Service  (_VWIN32_ResetWin32Event)
VWIN32_Service  (_VWIN32_WaitSingleObject)
VWIN32_Service  (_VWIN32_WaitMultipleObjects)
VWIN32_Service  (_VWIN32_CreateRing0Thread)
VWIN32_Service  (_VWIN32_CloseVxDHandle)
VWIN32_Service  (VWIN32_ActiveTimeBiasSet, LOCAL)
VWIN32_Service  (VWIN32_GetCurrentDirectory, LOCAL)
VWIN32_Service  (VWIN32_BlueScreenPopup)
VWIN32_Service  (VWIN32_TerminateApp)
VWIN32_Service  (_VWIN32_QueueKernelAPC)
VWIN32_Service  (VWIN32_SysErrorBox)
VWIN32_Service  (_VWIN32_IsClientWin32)
VWIN32_Service  (VWIN32_IFSRIPWhenLev2Taken, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Event)
VWIN32_Service  (_VWIN32_InitWin32Mutex)
VWIN32_Service  (_VWIN32_ReleaseWin32Mutex)
VWIN32_Service  (_VWIN32_BlockThreadEx)
VWIN32_Service  (VWIN32_GetProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Semaphore)
VWIN32_Service  (_VWIN32_SignalWin32Sem)
VWIN32_Service  (_VWIN32_QueueUserApcEx)
VWIN32_Service	(_VWIN32_OpenVxDHandle)
VWIN32_Service	(_VWIN32_CloseWin32Handle)
VWIN32_Service	(_VWIN32_AllocExternalHandle)
VWIN32_Service	(_VWIN32_UseExternalHandle)
VWIN32_Service	(_VWIN32_UnuseExternalHandle)
VWIN32_StdCall_Service	(KeInitializeTimer, 1)
VWIN32_StdCall_Service	(KeSetTimer, 4)
VWIN32_StdCall_Service	(KeCancelTimer, 1)
VWIN32_StdCall_Service	(KeReadStateTimer, 1)
VWIN32_Service	(_VWIN32_ReferenceObject)
VWIN32_Service	(_VWIN32_GetExternalHandle)
VWIN32_StdCall_Service	(VWIN32_ConvertNtTimeout, 1)
VWIN32_Service	(_VWIN32_SetWin32EventBoostPriority)
VWIN32_Service	(_VWIN32_GetRing3Flat32Selectors)
VWIN32_Service	(_VWIN32_GetCurThreadCondition)
VWIN32_Service  (VWIN32_Init_FP)
VWIN32_StdCall_Service  (R0SetWaitableTimer, 5)

End_Service_Table(VWIN32)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)      // turn on not enough params warning

PVOID VXDINLINE
VWIN32OpenVxDHandle(ULONG Handle,ULONG dwType)
{
    PVOID ul;
    
    _asm push [dwType]
    _asm push [Handle]
    VxDCall(_VWIN32_OpenVxDHandle)
    _asm add esp, 8
    _asm mov [ul], eax
	    
    return(ul);
}

WORD VXDINLINE
VWIN32_Get_Version(VOID)
{
	WORD	w;
	VxDCall(VWIN32_Get_Version);
	_asm mov [w], ax
	return(w);
}

/*XLATON*/

#endif // Not_VxD

//
// For _VWIN32_GetCurThreadCondition
//
#define	THREAD_CONDITION_DOS_BOX		0x00000000l
#define	THREAD_CONDITION_V86_NEST		0x00000001l
#define	THREAD_CONDITION_WDM			0x00000002l
#define	THREAD_CONDITION_INDETERMINATE		0x00000003l
#define	THREAD_CONDITION_LOCKED_STACK		0x00000004l
#define	THREAD_CONDITION_PURE_WIN16		0x00000005l
#define	THREAD_CONDITION_THUNKED_WIN16		0x00000006l
#define	THREAD_CONDITION_THUNKED_WIN32		0x00000007l
#define	THREAD_CONDITION_PURE_WIN32		0x00000008l
#define	THREAD_CONDITION_APPY_TIME		0x00000009l
#define	THREAD_CONDITION_RING0_APPY_TIME	0x0000000Al
#define	THREAD_CONDITION_EXIT			0x0000000Bl
#define	THREAD_CONDITION_INVALID_FLAGS		0xFFFFFFFFl

#define	THREAD_CONDITION_NORMAL_FLAGS		0x00000000l

// ;BeginInternal

// PM API list

#define VWIN32_GET_VER      0
#define VWIN32_THREAD_SWITCH    1   // ECX = wake param, EBX = ring 0 handle
#define VWIN32_DPMI_FAULT   2   // SS:BP = FAULTSTACKFRAME, AL = ignore
#define VWIN32_MMGR_FUNCTIONS   3
#define VWIN32_EVENT_CREATE 4
#define VWIN32_EVENT_DESTROY    5
#define VWIN32_EVENT_WAIT   6
#define VWIN32_EVENT_SET    7
#define VWIN32_RealNetx_Info    8
#define VWIN32_THREAD_BOOST_PRI 9
#define VWIN32_WAIT_CRST    10
#define VWIN32_WAKE_CRST    11
#define VWIN32_SET_FAULT_INFO   12
#define VWIN32_EXIT_TIME    13
#define VWIN32_BOOST_THREAD_GROUP 14
#define VWIN32_BOOST_THREAD_STATIC 15
#define VWIN32_WAKE_IDLE_SYS    16
#define VWIN32_MAKE_IDLE_SYS    17
#define VWIN32_DELIVER_PENDING_KERNEL_APCS 18
#define VWIN32_SYS_ERROR_BOX    19
#define VWIN32_GET_IFSMGR_XLAT_PTR 20
#define VWIN32_BOOST_THREAD_DECAY 21
#define VWIN32_LAST_CMD     21

#define VWIN32_MMGR_RESERVE ((VWIN32_MMGR_FUNCTIONS << 8) + 0)
#define VWIN32_MMGR_COMMIT  ((VWIN32_MMGR_FUNCTIONS << 8) + 1)
#define VWIN32_MMGR_DECOMMIT    ((VWIN32_MMGR_FUNCTIONS << 8) + 2)
#define VWIN32_MMGR_PAGEFREE    ((VWIN32_MMGR_FUNCTIONS << 8) + 3)

//
// Current Win32 thread/process handles.
//
// Updated every context switch.
//

#ifndef WOW

typedef struct _K32CURRENT {
    DWORD   CurThreadHandle;    // win32 thread handle
    DWORD   CurProcessHandle;   // win32 process handle
    DWORD   CurTDBX;        // current TDBX
    DWORD   pCurK16Task;        // flat pointer to kernel 16 CurTDB
    DWORD   CurContextHandle;   // win32 memory context handle
} K32CURRENT;

#endif  // ndef WOW

//
// Flag values for CreateThread
//
#define VWIN32_CT_EMULATE_NPX   0x01    // set EM bit in CR0 for thread
#define VWIN32_CT_WIN32_NPX 0x02    // use Win32 FP exception model
#define VWIN32_CT_WIN32     0x04    // thread is Win32 (not Win16)

//
// Return values from VWIN32_CheckDelayedNpxTrap
//
#define CX_RAISE    0       // instruction raises exception
#define CX_IGNORE   1       // instruction ignores exception
#define CX_CLEAR    2       // instruction clears or masks exception

// flags to use for win32 blocking
#define WIN32_BLOCK_FLAGS (BLOCK_FORCE_SVC_INTS+BLOCK_SVC_INTS+BLOCK_THREAD_IDLE+BLOCK_ENABLE_INTS)

//
// Flags for VWIN32_BlueScreenPopup
//

#define VBSP_CANCEL     0x00000001
#define VBSP_DISPLAY_VXD_NAME   0x00000002

//
// Fault stack frame structure
//

typedef struct fsf_s {
    WORD fsf_GS;
    WORD fsf_FS;
    WORD fsf_ES;
    WORD fsf_DS;
    DWORD fsf_EDI;
    DWORD fsf_ESI;
    DWORD fsf_EBP;
    DWORD fsf_locked_ESP;
    DWORD fsf_EBX;
    DWORD fsf_EDX;
    DWORD fsf_ECX;
    DWORD fsf_EAX;
    WORD fsf_num;       // Fault number
    WORD fsf_prev_IP;   // IP of previous fault handler
    WORD fsf_prev_CS;   // CS of previous fault handler
    WORD fsf_ret_IP;    // DPMI fault handler frame follows
    WORD fsf_ret_CS;
    WORD fsf_err_code;
    WORD fsf_faulting_IP;
    WORD fsf_faulting_CS;
    WORD fsf_flags;
    WORD fsf_SP;
    WORD fsf_SS;
} FAULTSTACKFRAME;

typedef FAULTSTACKFRAME *PFAULTSTACKFRAME;

// ;EndInternal

//
// structure for VWIN32_SysErrorBox
//

typedef struct vseb_s {
    DWORD vseb_resp;
    WORD vseb_b3;
    WORD vseb_b2;
    WORD vseb_b1;
    DWORD vseb_pszCaption;
    DWORD vseb_pszText;
} VSEB;

typedef VSEB *PVSEB;

#define SEB_ANSI    0x4000      // ANSI strings if set on vseb_b1
#define SEB_TERMINATE   0x2000      // forces termination if button pressed

// VWIN32_QueueKernelAPC flags

#define KERNEL_APC_IGNORE_MC        0x00000001
#define KERNEL_APC_STATIC       0x00000002
#define KERNEL_APC_WAKE         0x00000004

// for DeviceIOControl support
// On a DeviceIOControl call vWin32 will pass following parameters to
// the Vxd that is specified by hDevice. hDevice is obtained thru an
// earlier call to hDevice = CreateFile("\\.\vxdname", ...);
// ESI = DIOCParams STRUCT (defined below)
typedef struct DIOCParams   {
    DWORD   Internal1;      // ptr to client regs
    DWORD   VMHandle;       // VM handle
    DWORD   Internal2;      // DDB
    DWORD   dwIoControlCode;
    DWORD   lpvInBuffer;
    DWORD   cbInBuffer;
    DWORD   lpvOutBuffer;
    DWORD   cbOutBuffer;
    DWORD   lpcbBytesReturned;
    DWORD   lpoOverlapped;
    DWORD   hDevice;
    DWORD   tagProcess;
} DIOCPARAMETERS;

typedef DIOCPARAMETERS *PDIOCPARAMETERS;

// dwIoControlCode values for vwin32's DeviceIOControl Interface
// all VWIN32_DIOC_DOS_ calls require lpvInBuffer abd lpvOutBuffer to be
// struct * DIOCRegs
#define VWIN32_DIOC_GETVERSION DIOC_GETVERSION
#define VWIN32_DIOC_DOS_IOCTL       1
#define VWIN32_DIOC_DOS_INT25       2
#define VWIN32_DIOC_DOS_INT26       3
#define VWIN32_DIOC_DOS_INT13       4
#define VWIN32_DIOC_SIMCTRLC        5
#define VWIN32_DIOC_DOS_DRIVEINFO   6
#define VWIN32_DIOC_CLOSEHANDLE DIOC_CLOSEHANDLE

// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs {
    DWORD   reg_EBX;
    DWORD   reg_EDX;
    DWORD   reg_ECX;
    DWORD   reg_EAX;
    DWORD   reg_EDI;
    DWORD   reg_ESI;
    DWORD   reg_Flags;      
} DIOC_REGISTERS;

// if we are not included along with winbase.h
#ifndef FILE_FLAG_OVERLAPPED
  // OVERLAPPED structure for DeviceIOCtl VxDs
  typedef struct _OVERLAPPED {
          DWORD O_Internal;
          DWORD O_InternalHigh;
          DWORD O_Offset;
          DWORD O_OffsetHigh;
          HANDLE O_hEvent;
  } OVERLAPPED;
#endif

//  Parameters for _VWIN32_OpenVxDHandle to validate the Win32 handle type.
#define OPENVXD_TYPE_SEMAPHORE  0
#define OPENVXD_TYPE_EVENT      1
#define OPENVXD_TYPE_MUTEX      2
#define	OPENVXD_TYPE_ANY	3
  
// ;BeginInternal
#define OPENVXD_TYPE_MAXIMUM    3
// ;EndInternal

//
//  Object type table declaration for _VWIN32_AllocExternalHandle
//
/*XLATOFF*/
#define R0OBJCALLBACK           __stdcall
typedef VOID    (R0OBJCALLBACK *R0OBJFREE)(PVOID pR0ObjBody);
typedef PVOID   (R0OBJCALLBACK *R0OBJDUP)(PVOID pR0ObjBody, DWORD hDestProc);
/*XLATON*/
/* ASM
R0OBJFREE   TYPEDEF     DWORD
R0OBJDUP    TYPEDEF     DWORD
*/

typedef struct _R0OBJTYPETABLE {
    DWORD       ott_dwSize;             //  sizeof(R0OBJTYPETABLE)
    R0OBJFREE   ott_pfnFree;            //  called by Win32 CloseHandle
    R0OBJDUP    ott_pfnDup;             //  called by Win32 DuplicateHandle
} R0OBJTYPETABLE, *PR0OBJTYPETABLE;
/* ASM
R0OBJTYPETABLE  typedef _R0OBJTYPETABLE;
*/

#define R0EHF_INHERIT   0x00000001      //  Handle is inheritable
#define R0EHF_GLOBAL    0x00000002      //  Handle is valid in all contexts
// ;BeginInternal
#define R0EHF_ALL       (R0EHF_INHERIT | R0EHF_GLOBAL)
// ;EndInternal

// ;BeginInternal

/* ASM

FSF_CLEANUP_RETURN  EQU fsf_ret_IP - fsf_num
FSF_CLEANUP_CHAIN   EQU fsf_prev_IP - fsf_num

ifndef WOW

K32CURRENT typedef _K32CURRENT

endif

;***LT  W32Fun - macro to make a function callable from Kernel32
;
;   This macro will create a stub of the format that the Ring0/Ring3
;   Win32 calling interface likes.
;   It plays around with the stack so that the arguments are set
;   up right and clean off right and it also sets the ring 3
;   registers to reflect the outcome of the operation.
;
;   This macro is taken from VMM's memory manager, file: mma.asm
;
;   ENTRY:  fun - function name
;       cargs - number of dword arguments it has
;       prefix - prefix for function
;   EXIT:   none
;
;   Note that when the function is called:
;       EBX is the VM handle
;       ESI points to client registers
;       EDI points to the return address
;   THESE REGISTERS MUST NOT BE TRASHED!
;
W32Fun  MACRO   fun, cbargs, prefix

BeginProc   VW32&fun, esp, W32SVC, public
    ArgVar  pcrs,dword
    ArgVar  hvm,dword
    x = 0
    REPT    cbargs
        x = x + 1
        ArgVar  arg&x,dword
    ENDM

    EnterProc
    pop edi     ;Save and remove return address
    pop esi     ;Save and remove client regs
    pop ebx     ;Save and remove hvm

    call    prefix&fun  ;Call function somewhere in VxD
                ;Note that this function may be a C function

    mov [esi].Client_EAX,eax    ;Put return values into client regs

    push    ebx     ;Put hvm back on stack
    push    esi     ;Put client regs back on stack
    push    edi     ;Restore return address

    LeaveProc
    Return
EndProc VW32&fun

ENDM
*/

// ;EndInternal

// ;BeginInternal
//
// Used by SetPriorityClass API in priority.c
//
typedef struct _ThreadNewPriority{
    HANDLE R0ThHandle;
    int    NewPriority;
} TH_NEW_PRIORITY, *PTH_NEW_PRIORITY;    

// ;EndInternal

#endif  // _VWIN32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\wh.h ===
#ifdef  WOW

HANDLE
__stdcall
WhCreateEventW(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPTSTR);

BOOL
__stdcall
WhDuplicateHandle(HANDLE, HANDLE, HANDLE, LPHANDLE, DWORD, BOOL, DWORD);

VOID
__stdcall
WhEnterCriticalSection(LPCRITICAL_SECTION);

VOID
__stdcall
WhExitProcess(UINT);

HANDLE
__stdcall
WhGetCurrentProcess(VOID);

HANDLE
__stdcall
WhGetCurrentThread(VOID);

DWORD
__stdcall
WhGetCurrentThreadId(VOID);

PVOID
__stdcall
WhGlobalAlloc(UINT, DWORD);

VOID
__stdcall
WhInitializeCriticalSection(LPCRITICAL_SECTION);

VOID
__stdcall
WhLeaveCriticalSection(LPCRITICAL_SECTION);

VOID
__stdcall
WhSetEvent(HANDLE);

DWORD
__stdcall
WhWaitForMultipleObjects(DWORD, LPHANDLE, BOOL, DWORD);

DWORD
__stdcall
WhWaitForSingleObject(HANDLE, DWORD);

#endif  // WOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\w32sys.h ===
/*	w32sys.h
 *
 *	Definitions of various quantities associated with the
 *	Win32 system DLLs.  Used during Win32 boot.
 *
 *	NOTE that these are NOT general PE DLL stats.
 */

/*
 *  Minimum granularity of PE objects is 512 bytes
 */

#define	SectorShift	9
#define	SectorSize	512
#define	SectorMask	(SectorSize - 1)

/*
 * DLLHeaderSize must be at least as large as the largest system dll header.
 */
#define	DLLHeaderSize	PAGESIZE

/*
 * The following define the bit fields of the pager dword associated with each
 * page of memory.
 *
 *	31                              0
 *	 xxxxxxxxxxyyyzzzzzzzzzzzzzzzzzzz
 *
 *	where 'x' is a 10 bit module index,
 *	      'y' is a 3 bit count of zero fill sectors at the end of the page,
 *	      'z' is a 19 bit file seek offset in unit sectors.
 *
 *	this value is then rotated left 3 bits prior to passing it to the
 *	memory manager so that when it increments it by one, the sector number
 *	is actually incremented by 8 (# of sectors in a page).
 *
 *	x = DLLIndexMask
 *	y = DLLZFillMask
 *	z = DLL
 */

#define	DLLIndexShift	22
#define	DLLIndexMask	(0x3ff << DLLIndexShift)
#define	DLLZFillShift	19
#define	DLLZFillMask	(7 << DLLZFillShift)
#define	DLLSectorShift	0
#define	DLLSectorMask	(0x7ffff << DLLSectorShift)

#define	DLLIncrShift	(PAGESHIFT - SectorShift)

// Fault information block used between vwin32 and kernel32

#define MAX_FI_CRSTS	(SL_TOTAL + 8)
#define CB_FI_CSEIP	16
#define CB_FI_SSESP	(16*4)

typedef struct faultinfo_s {
    struct TDBX *fi_ptdbx;
    ULONG fi_ulExceptionNumber;
    ULONG fi_ulErrorCode;
    CONTEXT fi_context;
    LONG fi_acCrsts[MAX_FI_CRSTS];
#ifdef SYSLEVELCHECK
    LONG fi_laLvlCounts[SL_TOTAL];
    struct _lcrst *fi_plcaOwnedCrsts[SL_TOTAL];
#endif
    ULONG fi_cMustComplete;
    LONG fi_cbCSEIP;
    BYTE fi_abCSEIP[CB_FI_CSEIP];
    LONG fi_cbSSESP;
    ULONG fi_aulSSESP[CB_FI_SSESP/4];
    volatile DWORD fi_dwFaultResp;
    WORD fi_wWin16LockVCount;
    BYTE fi_fFlags;
} FAULTINFO;

typedef FAULTINFO *PFAULTINFO;

// fi_fFlags and flag parameter to VWIN32_PMAPI_DPMI_Fault

#define FI_FIGNORE	0x01	// allow ignore (put up ignore error box)
#define FI_FDEBUG	0x02	// allow debug on normal popup
#define FI_FTERMINATE	0x04	// do terminate if selected
#define FI_FFREEITLATER	0x08	// delay freeing the fi block

// fi_bFaultResp flags and return code to VWIN32_PMAPI_DPMI_Fault

#define FI_TERMINATE	0	// terminate the app
#define FI_DEBUG	1	// send to debugger
#define FI_IGNORE	2	// ignore instruction

// special fi_ulExceptionNumber values

#define	FI_LOAD_SEGMENT_ERROR	0xffffffff

// VWIN32_CallWhenCrstSafe structure

typedef struct cwcs {
	struct cwcs *cwcs_pcwcsNext;	// link
	ULONG cwcs_pfn; 		// call back address
	ULONG cwcs_ulRef; 		// refernce data
} CWCS;

// VWIN32_ForceCrsts/RestoreCrsts structures

typedef struct frcrst {
    struct frcrst *pfrcrstNext;		// INIT <0> next frcrst on list
    struct _crst *pcrst; 		// INIT <0> pointer to crst
    struct _tdb *ptdbTraced;		// thread that was single-stepped
    struct TDBX *ptdbxCrstOwner;	// original owner
    ULONG ulOrder;			// INIT <0> order to add crsts to list
    ULONG cRecur;			// original recursion count
    ULONG htimeout;			// time out handle
    ULONG cMustComplete;		// must complete count of owner
    struct cwcs cwcsData;		// VWIN32_CallWhenCrstSafe data
} FRCRST;

typedef FRCRST *PFRCRST;

typedef struct frinfo {
    struct frcrst *pfrcrstHead;		// points to fcrstLoadLock
    struct frcrst frcrstLoadLock;	// for the current process's load crst
    struct vmmfrinfo vmmfrinfoData;	// VMM force/restore mutex info struct
} FRINFO;

typedef FRINFO *PFRINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\w32func.inc ===
;;	W32func.inc
;
;	Definitions for 32-bit system functions available to 16-bit system
;	code.
;

;	CALL32
;
;	Macro to call a 32-bit function from 16-bit code.
;
;	Usage:	CALL32 ProtoOrdinal, arg1, arg2, ..., argN
;
;	ProtoOrdinal is a textequ of the format: "type, ordinal",
;	where type is a typedef of the function prototype.
;
;	Example:
;
;	   BlockThreadFun	typedef proto far stdcall TimeOut:dword
;	   BlockThreadOrd	equ 7
;
;	   ThkBlockThread	textequ <BlockThreadFun, BlockThreadOrd>
;
;	   CALL32 ThkBlockThread, -1
;
;
;	The stack is dword aligned, parameters are pushed, and a common
;	routine is called to setup flat selectors and translate the 16-bit
;	segmented stack pointer to flat.
;
;	Note that parameters are NOT thunked, ie. it is the caller's
;	responsibility to ensure parameters are suitable for the target
;	function.
;
;	Also note that registers EBX, ESI, and EDI are destroyed.  The
;	return value from the 32-bit function (in eax) is passed through
;	unchanged.
;

CALL32	macro	ProtoOrdinal:req, arg:vararg
	local	comma, ord, fun
;
; Parse ProtoOrdinal into its two components.
;
comma	instr	ProtoOrdinal, <,>		; find the delimiter
fun	substr	ProtoOrdinal, 1, &comma - 1	; function prototype
ord	substr	ProtoOrdinal, &comma + 1	; ordinal

	push	fs:[TIBSTRUCT.tib_ss16]	; save fs:[ss16]
	mov	fs:[TIBSTRUCT.tib_ss16], ss	; set new fs:[ss16]
	mov	bx, sp			; save the current sp value
	and	sp, 0fffcH		; dword align sp
	push	ebx			; save the old, unaligned, sp value

	mov	bx, ord
    ifnb <arg>
	invoke	fun ptr SystemThunk32, arg
    else
	invoke	fun ptr SystemThunk32
    endif
	assume	ds:nothing, es:nothing, fs:nothing, gs:nothing

	pop	sp			; restore unaligned sp
	pop	fs:[TIBSTRUCT.tib_ss16]	; restore fs:[ss16]
endm



ALIGNSTACK	macro

	mov	ax,sp			; save current sp value
	and	sp,0fffch		; dword align sp
	push	eax			; save unaligned sp value

	endm


UNALIGNSTACK	macro

	pop	sp			; restore unaligned sp value

	endm

CCALL32 macro	ordinal, arg

	mov	bx,ordinal
	cCall	SystemThunk32, <arg>, C
	assume	ds:nothing, es:nothing, fs:nothing, gs:nothing

	endm

;
; The Kernel32 export table is located at the beginning of the first object
; in the dll.  Note that we don't have a way to enforce the specific location,
; we're just relying on the linker being consistent.
;

KrnExportTableOffs	equ	1000H
ifndef	WOW
KrnExportTable		equ	Kernel32Base + KrnExportTableOffs
endif
KrnExportSignature	equ	05058454BH	; "KEXP"

;
; The procedure for adding an export to the private kernel32 export table:
;
;   1. If you're doing this to add a 16->32 internal thunk, please reconsider.
;      These thunks are slow and it's usually much easier to
;      add a compiled thunk to krnthksl.thk. Ask AtsushiK how to
;      do this if you don't know how.
;   2. Pick an available ordinal in the following list of ordinals.
;   3. Create a prototype typedef for the function in the list below
;      (not necessary for data exports).
;   4. It's really better to use the thunk compiler. Are you sure you want
;      to do this?
;   5. Create a ProtoOrdinal in the list below (not necessary for data exports).
;   6. Add the address of the function/data being exported to the kernel32
;      export table defined in win32\kernel\krninit.asm.
;
;  Ordinals of private 32-bit system entry points.
;

KrnSignature		equ	0	; first slot is the signature
KrnThunk16EntryTable	equ	1	; ptr to ptr to 16->32 thunk table
KrnpptdbCur		equ	2	; ptr to ptr to current thread
KrnInitialize		equ	3	; start up initialization
KrnUninit		equ	5	; Called at Windows exit time
KrnInitCrst		equ    18	; initialize critical section
KrnDestroyCrst		equ    19	; destroy critical section
KrnFT_RT_Win32Lock	equ    24
KrnQT_RT_Win32Lock      equ    25
KrnFT_RT_Win16Lock      equ    26
KrnQT_RT_Win16Lock	equ    27
KrnQT_RT_Win32NoLock    equ    28

;
; Prototypes of 16->32 thunks
;
fnInitialize		typedef proto far stdcall :dword
fnUninit		typedef proto far stdcall
fnInitCrst		typedef proto far stdcall :dword
fnDestroyCrst		typedef proto far stdcall :dword

;
; ProtoOrdinals for use with the CALL32 macro
;

ThkInitialize		textequ	<fnInitialize, KrnInitialize>
ThkUninit		textequ	<fnUninit, KrnUninit>
ThkInitCrst		textequ	<fnInitCrst, KrnInitCrst>
ThkDestroyCrst		textequ	<fnDestroyCrst, KrnDestroyCrst>


;;	CALL16
;
;	Macro to call a 16-bit function from 32-bit code.
;
;	Usage:	CALL16	ordinal
;
;	The stack pointer is switched to 16:16, and all registers are
;	unmodified on both to/from 16-bit code.
;
;	Note that Thunk16EntryTable points to the KERNEL16 (krnl386)
;	entry table, which is below 1M.  This memory is addressible by
;	CS, but NOT DS.
;

CALL16	macro	ordinal
local	a
	push	cs
	push	offset a		; save our return address

	push	eax
	mov	eax, Thunk16EntryTable
	mov	eax, cs:[eax][ordinal*4]
	xchg	eax, [esp]
	db	066H, 0cbH		; far 16:16 ret
a:
endm


;
;  Private 16-bit system entry points used by KERNEL32
;

Krn16Int41		equ	0	; wdeb386 interface
Krn16Int21		equ	1	; DOS interface
;;;Krn16Int31		equ	2	; DPMI interface
Krn16WOW		equ	3	; for WOW
Krn16BopUnsimulate      equ     4       ; for WOW
Krn16FreeAll            equ     9       ; gfreeall
Krn16AllocSelArray	equ	10	; Allocs selectors
Krn16FreeSel		equ	11	; FreeSelector()
Krn16ThreadStartup	equ	12	; 16-bit entry point for CreateThread

nKrn16Entries		equ	16	; the actual number of entries

;
; Wait termination status codes.  BUGBUG--defined in multiple places.
;

idWaitOK		equ	0000h
idWaitExit		equ	0f01h
idWaitIdle		equ	0f02h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\win31err.inc ===
IFNDEF  _WIN31ERR_
_WIN31ERR_      EQU     1

;* Windows3.1 possible return value

W31RET_0                        EQU     0
W31RET_1                        EQU     1
W31RET_2                        EQU     2
W31RET_3                        EQU     3
W31RET_11                       EQU    11
W31RET_FFFF                     EQU    -1

ENDIF ; _WIN31ERR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\win32c.inc ===
;*  Win32c.INC
;*
;*      Private header file for all Win32c.DLL ASM files

ifndef WIN32_STRUCTSONLY
        page    66,132
        .386

        OPTION SEGMENT:USE16

        .MODEL LARGE,PASCAL

;** Segmentation

;We use _DATADWALIGN for some things instead of _DATA because it's DWORD-aligned
_DATADWALIGN SEGMENT DWORD USE16 PUBLIC 'DATA'
_DATADWALIGN ENDS

DGROUP  GROUP _DATADWALIGN      ;Add _DATADWALIGN to DGROUP

_TEXTINIT SEGMENT BYTE USE16 PUBLIC 'CODE'
_TEXTINIT ENDS

_TEXTFIXED SEGMENT BYTE USE16 PUBLIC 'CODE'
_TEXTFIXED ENDS

_TEXTMOVE SEGMENT BYTE USE16 PUBLIC 'CODE'
_TEXTMOVE ENDS

;** General Equates

KERN16ENTRY     TEXTEQU <FAR PASCAL>
PRIVENTRY       TEXTEQU <FAR PASCAL>
NEARENTRY       TEXTEQU <NEAR PASCAL>
APIENTRY        TEXTEQU <FAR PASCAL>

;** Global variables
externdef FlatData:WORD

;** Macros

SetDS MACRO
        push    DGROUP
        pop     ds
        assume  ds:DGROUP
ENDM

CheckDS MACRO
IFDEF DEBUG
        push    ax
        mov     ax, ds
        cmp     ax, DGROUP
        je      @F
        int     3
@@:     pop     ax
ENDIF
ENDM

endif   ; WIN32_STRUCTSONLY

ifndef WIN32_STRUCTSONLY
;** Prototypes

; Kernel16

;WORD
LocalInit               PROTO KERN16ENTRY hHeapSeg:WORD, wHeapStart:WORD, wHeapEnd:WORD
;VOID*
MapSL                   PROTO KERN16ENTRY lpSegOffset:DWORD
;VOID FAR*
MapLS                   PROTO KERN16ENTRY lpFlat:DWORD
;VOID FAR*
MapLSLimit              PROTO KERN16ENTRY lpFlat:DWORD, lpMaxAddress:DWORD
;void
UnMapLS                 PROTO KERN16ENTRY lpSegOffset:DWORD
;void
FreeSelector            PROTO KERN16ENTRY wSel:WORD
;WORD
AllocDStoCSAlias        PROTO KERN16ENTRY wSel:WORD
;WORD
GetCurrentTask          PROTO KERN16ENTRY
;void
OutputDebugString       PROTO KERN16ENTRY segMsg:WORD, offMsg:word
;void
SetLastError            PROTO KERN16ENTRY Error:DWORD
;HANDLE
GetHModK16FromImte      PROTO KERN16ENTRY hMem:WORD
;HANDLE
GlobalAlloc             PROTO KERN16ENTRY dwSize:DWORD, wFlags:WORD
;HANDLE
GlobalReAlloc           PROTO KERN16ENTRY hMem:WORD, wOffset:WORD, wSize:WORD, wFlags:WORD
;void
GlobalFree              PROTO KERN16ENTRY hMem:WORD
;DWORD
GlobalSize              PROTO KERN16ENTRY hMem:WORD
;void
GlobalLock              PROTO KERN16ENTRY hMem:WORD
;void
GlobalUnlock            PROTO KERN16ENTRY hMem:WORD
;void
SetOwner                PROTO KERN16ENTRY hMem:WORD
;HANDLE
GetExePtr               PROTO KERN16ENTRY hMem:WORD
;ATOM
AddAtom                 PROTO KERN16ENTRY lpszString:DWORD
;UINT
GetAtomName             PROTO KERN16ENTRY atom:WORD, lpszBuffer:DWORD, cbBuffer:WORD
;void
Win32CStartup           PROTO KERN16ENTRY

; INIT.ASM

;BOOL (_TEXTINIT)
Win32CInit              PROTO APIENTRY
;BOOL (_TEXTFIXED)
WEP                     PROTO APIENTRY wParam:WORD

; T16UTIL.ASM

externdef selFlatDS:WORD
externdef selFlatCS:WORD
externdef hinstWin32c:WORD

;void (_TEXTMOVE)
StackLinearToSegmented  PROTO APIENTRY
;void (_TEXTMOVE)
UnMapStackAndMakeFlat   PROTO APIENTRY
;WORD (_TEXT)
Map32To16               PROTO APIENTRY val32:DWORD
;DWORD (_TEXT)
DelMap                  PROTO APIENTRY key16:WORD
;SELECTOR (_TEXT)
GetCSAlias              PROTO APIENTRY selDS:WORD
;void (_TEXT)
FreeCSAlias             PROTO APIENTRY wSel:WORD
;DWORD (_TEXT)
SelectorOffsetToLinear  PROTO APIENTRY sel:WORD, off:WORD
;void (_TEXT)
MemCpy32                PROTO APIENTRY dest:DWORD, src:DWORD, count:DWORD
;void (_TEXT)
ResCpy32                PROTO APIENTRY NEdest:DWORD, PEsrc:DWORD, dwSize:DWORD
;void (_TEXT)
SetLastError16          PROTO APIENTRY dwError:DWORD
;void (_TEXT)
CALLBACK_BODY_16        PROTO APIENTRY

; PEAUX.ASM

;WORD (_TEXT)
GetHmodFromWindows      PROTO APIENTRY
;BOOL (_TEXT)
CreatePEModInst         PROTO APIENTRY hModule16:WORD, hModule32:DWORD,
                                szFileName:DWORD,
                                pNEResTable:DWORD, cbNEResTable:WORD,
                                pPERes32:DWORD, pPE32:DWORD
;void (_TEXT)
DestroyPEModInst        PROTO APIENTRY hInst:WORD
;WORD (_TEXT)
GetCurrentHeap          PROTO APIENTRY 
;WORD (_TEXT)
GetNullhInst            PROTO APIENTRY 

endif   ; WIN32_STRUCTSONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\oemuni\oem.h ===
/*
 *  private macros for oemuni lib
 *  18-Jan-1993 Jonle created
 */

#define InitOemString(dst,src) RtlInitString((PSTRING) dst, src)
#define BaseSetLastNTError(stat) SetLastError(RtlNtStatusToDosError(stat))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\winerror.inc ===
IFNDEF  _WINERROR_
_WINERROR_      EQU     1

;* DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
;* API functions.

; ** Error codes

NO_ERROR                        EQU     0

ERROR_INVALID_FUNCTION          EQU     1
ERROR_FILE_NOT_FOUND            EQU     2
ERROR_PATH_NOT_FOUND            EQU     3
ERROR_TOO_MANY_OPEN_FILES       EQU     4
ERROR_ACCESS_DENIED             EQU     5
ERROR_INVALID_HANDLE            EQU     6
ERROR_ARENA_TRASHED             EQU     7
ERROR_NOT_ENOUGH_MEMORY         EQU     8
ERROR_INVALID_BLOCK             EQU     9
ERROR_BAD_ENVIRONMENT           EQU     10
ERROR_BAD_FORMAT                EQU     11
ERROR_INVALID_ACCESS            EQU     12
ERROR_INVALID_DATA              EQU     13

ERROR_INVALID_DRIVE             EQU     15
ERROR_CURRENT_DIRECTORY         EQU     16
ERROR_NOT_SAME_DEVICE           EQU     17
ERROR_NO_MORE_FILES             EQU     18

; These are the universal int 24 mappings for the old INT 24 set of errors
ERROR_WRITE_PROTECT             EQU     19
ERROR_BAD_UNIT                  EQU     20
ERROR_NOT_READY                 EQU     21
ERROR_BAD_COMMAND               EQU     22
ERROR_CRC                       EQU     23
ERROR_BAD_LENGTH                EQU     24
ERROR_SEEK                      EQU     25
ERROR_NOT_DOS_DISK              EQU     26
ERROR_SECTOR_NOT_FOUND          EQU     27
ERROR_OUT_OF_PAPER              EQU     28
ERROR_WRITE_FAULT               EQU     29
ERROR_READ_FAULT                EQU     30
ERROR_GEN_FAILURE               EQU     31

; These are the new 3.0 error codes reported through INT 24
ERROR_SHARING_VIOLATION         EQU     32
ERROR_LOCK_VIOLATION            EQU     33
ERROR_WRONG_DISK                EQU     34
; ERROR_FCB_UNAVAILABLE		 EQU	 35
; ERROR_SHARING_BUFFER_EXCEEDED	 EQU	 36
; End of INT 24 reportable errors

ERROR_HANDLE_EOF		EQU	38
ERROR_HANDLE_DISK_FULL		EQU	39


; Network related errors
ERROR_NOT_SUPPORTED		EQU	50 ; Network request not supported
ERROR_REM_NOT_LIST              EQU     51 ; Remote computer not listening
ERROR_DUP_NAME                  EQU     52 ; Duplicate name on network
ERROR_BAD_NETPATH               EQU     53 ; Network path not found
ERROR_NETWORK_BUSY              EQU     54 ; Network busy
ERROR_DEV_NOT_EXIST             EQU     55 ; Network device no longer exists
ERROR_TOO_MANY_CMDS             EQU     56 ; Net BIOS command limit exceeded
ERROR_ADAP_HDW_ERR              EQU     57 ; Network adapter hardware error
ERROR_BAD_NET_RESP              EQU     58 ; Incorrect response from network
ERROR_UNEXP_NET_ERR             EQU     59 ; Unexpected network error
ERROR_BAD_REM_ADAP              EQU     60 ; Incompatible remote adapter
ERROR_PRINTQ_FULL               EQU     61 ; Print queue full
ERROR_NO_SPOOL_SPACE            EQU     62 ; Not enough space for print file
ERROR_PRINT_CANCELLED           EQU     63 ; Print file was cancelled
ERROR_NETNAME_DELETED           EQU     64 ; Network name was deleted
ERROR_NETWORK_ACCESS_DENIED     EQU     65 ; Access denied
ERROR_BAD_DEV_TYPE              EQU     66 ; Network device type incorrect
ERROR_BAD_NET_NAME              EQU     67 ; Network name not found
ERROR_TOO_MANY_NAMES            EQU     68 ; Network name limit exceeded
ERROR_TOO_MANY_SESS             EQU     69 ; Net BIOS session limit exceeded
ERROR_SHARING_PAUSED            EQU     70 ; Sharing temporarily paused
ERROR_REQ_NOT_ACCEP             EQU     71 ; Network request not accepted
ERROR_REDIR_PAUSED              EQU     72 ; Print|disk redirection is paused
ERROR_FILE_EXISTS               EQU     80
; ERROR_DUP_FCB			 EQU	 81
ERROR_CANNOT_MAKE               EQU     82
ERROR_FAIL_I24                  EQU     83

; New 3.0 network related error codes
ERROR_OUT_OF_STRUCTURES         EQU     84
ERROR_ALREADY_ASSIGNED          EQU     85
ERROR_INVALID_PASSWORD          EQU     86
ERROR_INVALID_PARAMETER         EQU     87
ERROR_NET_WRITE_FAULT           EQU     88

; New error codes for 4.0
ERROR_NO_PROC_SLOTS		EQU	89 ; no process slots available

; ERROR_NOT_FROZEN		 EQU	 90
; ERR_TSTOVFL			  EQU	  91 ; timer service table overflow
; ERR_TSTDUP			  EQU	  92 ; timer service table duplicate
; ERROR_NO_ITEMS		  EQU	  93 ; no items to operate upon
; ERROR_INTERRUPT		  EQU	  95 ; interrupted system call
; ERROR_DEVICE_IN_USE		  EQU	  99 ; Device in use by another thread
ERROR_TOO_MANY_SEMAPHORES       EQU     100
ERROR_EXCL_SEM_ALREADY_OWNED    EQU     101
ERROR_SEM_IS_SET                EQU     102
ERROR_TOO_MANY_SEM_REQUESTS     EQU     103
ERROR_INVALID_AT_INTERRUPT_TIME EQU     104
ERROR_SEM_OWNER_DIED            EQU     105 ; waitsem found owner died
ERROR_SEM_USER_LIMIT            EQU     106 ; too many procs have this sem
ERROR_DISK_CHANGE		EQU	107 ; insert disk b into drive a
ERROR_DRIVE_LOCKED              EQU     108 ; drive locked by another process
ERROR_BROKEN_PIPE               EQU     109 ; write on pipe with no reader

; New error codes for OS/2 */
ERROR_OPEN_FAILED               EQU     110 ; open/created failed due to
                                            ; explicit fail command
ERROR_BUFFER_OVERFLOW           EQU     111 ; buffer passed to system call
                                            ;  is too small to hold return
                                            ;  data.
ERROR_DISK_FULL                 EQU     112 ; not enough space on the disk
                                            ;  (DOSNEWSIZE/w_NewSize)
ERROR_NO_MORE_SEARCH_HANDLES    EQU     113 ; can't allocate another search
                                            ;  structure and handle.
                                            ;  (DOSFINDFIRST/w_FindFirst)
ERROR_INVALID_TARGET_HANDLE     EQU     114 ; Target handle in DOSDUPHANDLE
                                            ;  is invalid
; ERROR_PROTECTION_VIOLATION	  EQU	  115 ; Bad user virtual address
; ERROR_VIOKBD_REQUEST		  EQU	  116
ERROR_INVALID_CATEGORY	  EQU	  117 ; Category for DEVIOCTL in not
					      ;  defined
ERROR_INVALID_VERIFY_SWITCH     EQU     118 ; invalid value passed for
                                            ;  verify flag
ERROR_BAD_DRIVER_LEVEL          EQU     119 ; DosDevIOCTL looks for a level
                                            ;  four driver. If the driver
                                            ;  is not level four we return
                                            ;  this code
ERROR_CALL_NOT_IMPLEMENTED      EQU     120 ; returned from stub api calls.
                                            ;  This call will disappear when
                                            ;  all the api's are implemented.
ERROR_SEM_TIMEOUT               EQU     121 ; Time out happened from the
                                            ;  semaphore api functions.
ERROR_INSUFFICIENT_BUFFER       EQU     122 ; Some calls require the
                                            ;  application to pass in a buffer
                                            ;  filled with data.  This error is
                                            ;  returned if the data buffer is too
                                            ;  small.  For example: DosSetFileInfo
                                            ;  requires 4 bytes of data.  If a
                                            ;  two byte buffer is passed in then
                                            ;  this error is returned.
                                            ;  error_buffer_overflow is used when
                                            ;  the output buffer in not big enough.
ERROR_INVALID_NAME              EQU     123 ; illegal character or malformed
                                            ; file system name
ERROR_INVALID_LEVEL             EQU     124 ; unimplemented level for info
                                            ; retrieval or setting
ERROR_NO_VOLUME_LABEL           EQU     125 ; no volume label found with
                                            ; DosQFSInfo command
ERROR_MOD_NOT_FOUND             EQU     126 ; w_getprocaddr,w_getmodhandle
ERROR_PROC_NOT_FOUND            EQU     127 ; w_getprocaddr
; ERROR_WAIT_NO_CHILDREN	 EQU	 128 ; CWait finds to children
ERROR_CHILD_NOT_COMPLETE        EQU     129 ; CWait children not dead yet
ERROR_DIRECT_ACCESS_HANDLE      EQU     130 ; handle operation is invalid
                                            ; for direct disk access
                                            ; handles
ERROR_NEGATIVE_SEEK             EQU     131 ; application tried to seek
                                            ; with negitive offset
ERROR_SEEK_ON_DEVICE            EQU     132 ; application tried to seek
                                            ; on device or pipe

; The following are errors generated by the join and subst workers
ERROR_IS_JOIN_TARGET            EQU     133
ERROR_IS_JOINED                 EQU     134
ERROR_IS_SUBSTED                EQU     135
ERROR_NOT_JOINED                EQU     136
ERROR_NOT_SUBSTED               EQU     137
ERROR_JOIN_TO_JOIN              EQU     138
ERROR_SUBST_TO_SUBST            EQU     139
ERROR_JOIN_TO_SUBST             EQU     140
ERROR_SUBST_TO_JOIN             EQU     141
ERROR_BUSY_DRIVE                EQU     142
ERROR_SAME_DRIVE                EQU     143
ERROR_DIR_NOT_ROOT              EQU     144
ERROR_DIR_NOT_EMPTY             EQU     145
ERROR_IS_SUBST_PATH             EQU     146
ERROR_IS_JOIN_PATH              EQU     147
ERROR_PATH_BUSY                 EQU     148
ERROR_IS_SUBST_TARGET           EQU     149
ERROR_SYSTEM_TRACE              EQU     150 ; system trace error
ERROR_INVALID_EVENT_COUNT       EQU     151 ; DosMuxSemWait errors
ERROR_TOO_MANY_MUXWAITERS       EQU     152
ERROR_INVALID_LIST_FORMAT       EQU     153
ERROR_LABEL_TOO_LONG            EQU     154
ERROR_TOO_MANY_TCBS             EQU     155
ERROR_SIGNAL_REFUSED            EQU     156
ERROR_DISCARDED                 EQU     157
ERROR_NOT_LOCKED                EQU     158
ERROR_BAD_THREADID_ADDR         EQU     159
ERROR_BAD_ARGUMENTS             EQU     160
ERROR_BAD_PATHNAME              EQU     161
ERROR_SIGNAL_PENDING            EQU     162
; ERROR_UNCERTAIN_MEDIA		 EQU	 163
ERROR_MAX_THRDS_REACHED         EQU     164
; ERROR_MONITORS_NOT_SUPPORTED	 EQU	 165

ERROR_LOCK_FAILED		EQU	167
ERROR_BUSY			EQU	170

ERROR_INVALID_SEGMENT_NUMBER	EQU	180
; ERROR_INVALID_CALLGATE		EQU	181
ERROR_INVALID_ORDINAL		EQU	182
ERROR_ALREADY_EXISTS		EQU	183
; ERROR_NO_CHILD_PROCESS		EQU	184
; ERROR_CHILD_ALIVE_NOWAIT	EQU	185
ERROR_INVALID_FLAG_NUMBER	EQU	186
ERROR_SEM_NOT_FOUND		EQU	187

; following error codes have added to make the loader error
; messages distinct

ERROR_INVALID_STARTING_CODESEG	EQU	188
ERROR_INVALID_STACKSEG		EQU	189
ERROR_INVALID_MODULETYPE	EQU	190
ERROR_INVALID_EXE_SIGNATURE	EQU	191
ERROR_EXE_MARKED_INVALID	EQU	192
ERROR_BAD_EXE_FORMAT		EQU	193
ERROR_ITERATED_DATA_EXCEEDS_64k EQU	194
ERROR_INVALID_MINALLOCSIZE	EQU	195
ERROR_DYNLINK_FROM_INVALID_RING EQU	196
ERROR_IOPL_NOT_ENABLED		EQU	197
ERROR_INVALID_SEGDPL		EQU	198
ERROR_AUTODATASEG_EXCEEDS_64k	EQU	199
ERROR_RING2SEG_MUST_BE_MOVABLE	EQU	200
ERROR_RELOC_CHAIN_XEEDS_SEGLIM	EQU	201
ERROR_INFLOOP_IN_RELOC_CHAIN	EQU	202

ERROR_ENVVAR_NOT_FOUND		EQU	203
ERROR_NOT_CURRENT_CTRY		EQU	204
ERROR_NO_SIGNAL_SENT		EQU	205
ERROR_FILENAME_EXCED_RANGE	EQU	206 ; if filename > 8.3
ERROR_RING2_STACK_IN_USE	EQU	207 ; for FAPI
ERROR_META_EXPANSION_TOO_LONG	EQU	208 ; if "*a" > 8.3

ERROR_INVALID_SIGNAL_NUMBER	EQU	209
ERROR_THREAD_1_INACTIVE 	EQU	210
; ERROR_INFO_NOT_AVAIL		EQU	211 ; PTM 5550
ERROR_LOCKED			EQU	212
; ERROR_BAD_DYNALINK		EQU	213 ; PTM 5760
ERROR_TOO_MANY_MODULES		EQU	214
; ERROR_NESTING_NOT_ALLOWED	EQU	215

; Error codes 230 - 249 are reserved for MS Networks
ERROR_BAD_PIPE			EQU	230
ERROR_PIPE_BUSY 		EQU	231
ERROR_NO_DATA			EQU	232
ERROR_PIPE_NOT_CONNECTED	EQU	233
ERROR_MORE_DATA 		EQU	234
ERROR_VC_DISCONNECTED		EQU	240
ERROR_INVALID_EA_NAME		EQU	254
ERROR_NO_MORE_ITEMS		EQU	259
ERROR_DIRECTORY 		EQU	267
ERROR_EAS_DIDNT_FIT		EQU	275
ERROR_EAS_NOT_SUPPORTED 	EQU	282
ERROR_NOT_OWNER 		EQU	288
ERROR_TOO_MANY_POSTS		EQU	298
ERROR_MR_MID_NOT_FOUND		EQU	317
ERROR_INVALID_ADDRESS		EQU	487
ERROR_ARITHMETIC_OVERFLOW	EQU	534
ERROR_IO_INCOMPLETE		EQU	996
ERROR_IO_PENDING		EQU	997
ERROR_NOACCESS			EQU	998
ERROR_SWAPERROR 		EQU	999

; Errors added for DOS Extender

ERROR_SYS_INTERNAL		EQU	328

ENDIF ; _WINERROR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\oemuni\file.c ===
/*  file.c
 *  OemUnicode win32 thunks
 *  - file and debug apis
 *
 *  14-Jan-1993 Jonle
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <oemuni.h>
#include "oem.h"



BOOL
CheckForSameCurdir(
    PUNICODE_STRING PathName
    )
{
    PCURDIR CurDir;
    UNICODE_STRING CurrentDir;
    BOOL rv;


    CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);

    if (CurDir->DosPath.Length > 6 ) {
        if ( (CurDir->DosPath.Length-2) != PathName->Length ) {
            return FALSE;
            }
        }
    else {
        if ( CurDir->DosPath.Length != PathName->Length ) {
            return FALSE;
            }
        }

    RtlAcquirePebLock();

    CurrentDir = CurDir->DosPath;
    if ( CurrentDir.Length > 6 ) {
        CurrentDir.Length -= 2;
        }
    rv = FALSE;

    if ( RtlEqualUnicodeString(&CurrentDir,PathName,TRUE) ) {
        rv = TRUE;
        }
    RtlReleasePebLock();

    return rv;
}



HANDLE
WINAPI
CreateFileOem(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    OEM thunk to CreateFileW

--*/

{

    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;
    HANDLE   hFile;
    DWORD    dw;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpFileName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return INVALID_HANDLE_VALUE;
        }


       /*
        *  Dos allows change of attributes (time\date etc)
        *  on files opend for generic read, so we add
        *  FILE_WRITE_ATTRIBUTES to the Desired access.
        */
    hFile = CreateFileW( Unicode->Buffer,
                         dwDesiredAccess == GENERIC_READ
                             ? dwDesiredAccess | FILE_WRITE_ATTRIBUTES
                             : dwDesiredAccess,
                         dwShareMode,
                         lpSecurityAttributes,
                         dwCreationDisposition,
                         dwFlagsAndAttributes,
                         hTemplateFile
                         );


       /*
        *  However, NT may fail the request because of the
        *  extra FILE_WRITE_ATTRIBUTES. Common example
        *  is a generic read open on a read only net share.
        *  Retry the Createfile without FILE_WRTIE_ATTRIBUTES
        */
    if (hFile == INVALID_HANDLE_VALUE && dwDesiredAccess == GENERIC_READ)
      {
        hFile = CreateFileW( Unicode->Buffer,
                             dwDesiredAccess,
                             dwShareMode,
                             lpSecurityAttributes,
                             dwCreationDisposition,
                             dwFlagsAndAttributes,
                             hTemplateFile
                             );
        }

    return hFile;
}



BOOL
APIENTRY
SetFileAttributesOem(
    LPSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    Oem thunk to SetFileAttributesW

--*/

{
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpFileName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }
    return ( SetFileAttributesW(
                Unicode->Buffer,
                dwFileAttributes
                )
            );
}



DWORD
APIENTRY
GetFileAttributesOem(
    LPSTR lpFileName
    )

/*++

Routine Description:

    OEM thunk to GetFileAttributesW

--*/

{

    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&OemString,lpFileName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return 0xFFFFFFFF;
        }
    return ( GetFileAttributesW(Unicode->Buffer) );
}



BOOL
APIENTRY
DeleteFileOem(
    LPSTR lpFileName
    )

/*++

Routine Description:

    Oem thunk to DeleteFileW

--*/

{
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpFileName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }
    return ( DeleteFileW(Unicode->Buffer) );
}




BOOL
APIENTRY
MoveFileOem(
    LPSTR lpExistingFileName,
    LPSTR lpNewFileName
    )

/*++

Routine Description:

    OEM thunk to MoveFileW

--*/

{

    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodeNewFileName;
    OEM_STRING OemString;
    NTSTATUS Status;
    BOOL ReturnValue;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpExistingFileName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }

    if (ARGUMENT_PRESENT( lpNewFileName )) {
        InitOemString(&OemString,lpNewFileName);
        Status = RtlOemStringToUnicodeString(&UnicodeNewFileName,&OemString,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        UnicodeNewFileName.Buffer = NULL;
        }

    ReturnValue = MoveFileExW(Unicode->Buffer,
                              UnicodeNewFileName.Buffer,
                              MOVEFILE_COPY_ALLOWED);

    if (UnicodeNewFileName.Buffer != NULL) {
        RtlFreeUnicodeString(&UnicodeNewFileName);
        }

    return ReturnValue;
}


BOOL
APIENTRY
MoveFileExOem(
    LPSTR lpExistingFileName,
    LPSTR lpNewFileName,
    DWORD fdwFlags
    )

/*++

Routine Description:

    OEM thunk to MoveFileExW

--*/

{

    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodeNewFileName;
    OEM_STRING OemString;
    NTSTATUS Status;
    BOOL ReturnValue;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpExistingFileName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }

    if (ARGUMENT_PRESENT( lpNewFileName )) {
        InitOemString(&OemString,lpNewFileName);
        Status = RtlOemStringToUnicodeString(&UnicodeNewFileName,&OemString,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        UnicodeNewFileName.Buffer = NULL;
        }

    ReturnValue = MoveFileExW(Unicode->Buffer,
                              UnicodeNewFileName.Buffer,
                              fdwFlags);

    if (UnicodeNewFileName.Buffer != NULL) {
        RtlFreeUnicodeString(&UnicodeNewFileName);
        }

    return ReturnValue;
}


HANDLE
APIENTRY
FindFirstFileOem(
    LPSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    )

/*++

Routine Description:

    OEM thunk to FindFirstFileW

--*/

{
    HANDLE ReturnValue;
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpFileName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return INVALID_HANDLE_VALUE;
        }
    ReturnValue = FindFirstFileW(Unicode->Buffer,&FindFileData);
    if ( ReturnValue == INVALID_HANDLE_VALUE ) {
        return ReturnValue;
        }
    RtlMoveMemory(
        lpFindFileData,
        &FindFileData,
        (ULONG)((ULONG)&FindFileData.cFileName[0] - (ULONG)&FindFileData)
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    OemString.Buffer = lpFindFileData->cFileName;
    OemString.MaximumLength = MAX_PATH;
    Status = RtlUnicodeStringToOemString(&OemString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        OemString.Buffer = lpFindFileData->cAlternateFileName;
        OemString.MaximumLength = 14;
        Status = RtlUnicodeStringToOemString(&OemString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        FindClose(ReturnValue);
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }
    return ReturnValue;
}




BOOL
APIENTRY
FindNextFileOem(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    )

/*++

Routine Description:

    Oem thunk to FindFileDataW

--*/

{

    BOOL ReturnValue;
    OEM_STRING OemString;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;

    ReturnValue = FindNextFileW(hFindFile,&FindFileData);
    if ( !ReturnValue ) {
        return ReturnValue;
        }
    RtlMoveMemory(
        lpFindFileData,
        &FindFileData,
        (ULONG)((ULONG)&FindFileData.cFileName[0] - (ULONG)&FindFileData)
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    OemString.Buffer = lpFindFileData->cFileName;
    OemString.MaximumLength = MAX_PATH;
    Status = RtlUnicodeStringToOemString(&OemString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        OemString.Buffer = lpFindFileData->cAlternateFileName;
        OemString.MaximumLength = 14;
        Status = RtlUnicodeStringToOemString(&OemString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return ReturnValue;
}




DWORD
APIENTRY
GetFullPathNameOem(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    )

/*++

Routine Description:

    Oem thunk to GetFullPathNameW

--*/

{

    NTSTATUS Status;
    ULONG UnicodeLength;
#ifdef FE_SB
    ULONG FilePartLength;
    UNICODE_STRING UnicodeFilePart;
#endif
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeResult;
    OEM_STRING OemString;
    OEM_STRING OemResult;
    PWSTR Ubuff;
    PWSTR FilePart;
    PWSTR *FilePartPtr;

    if ( ARGUMENT_PRESENT(lpFilePart) ) {
        FilePartPtr = &FilePart;
        }
    else {
        FilePartPtr = NULL;
        }

    RtlInitString(&OemString,lpFileName);
    Status = RtlOemStringToUnicodeString(&UnicodeString,&OemString,TRUE);
    if ( !NT_SUCCESS(Status) ){
        RtlFreeUnicodeString(&UnicodeString);
        BaseSetLastNTError(Status);
        return 0;
        }

    Ubuff = RtlAllocateHeap(RtlProcessHeap(), 0,(MAX_PATH<<1) + sizeof(UNICODE_NULL));
    if ( !Ubuff ) {
        RtlFreeUnicodeString(&UnicodeString);
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }

    UnicodeLength = RtlGetFullPathName_U(
                        UnicodeString.Buffer,
                        (MAX_PATH<<1),
                        Ubuff,
                        FilePartPtr
                        );
#ifdef FE_SB
    // BugFix: can't listed with file open dialog of MS's app 1995.3.7 V-HIDEKK
    RtlInitUnicodeString( &UnicodeFilePart, Ubuff );
    UnicodeLength = RtlUnicodeStringToOemSize( &UnicodeFilePart );
#else
    UnicodeLength >>= 1;
#endif
    if ( UnicodeLength && UnicodeLength < nBufferLength ) {
        RtlInitUnicodeString(&UnicodeResult,Ubuff);
        Status = RtlUnicodeStringToOemString(&OemResult,&UnicodeResult,TRUE);
        if ( NT_SUCCESS(Status) ) {
#ifdef FE_SB
            RtlMoveMemory(lpBuffer,OemResult.Buffer,UnicodeLength);
#else
            RtlMoveMemory(lpBuffer,OemResult.Buffer,UnicodeLength+1);
#endif
            RtlFreeOemString(&OemResult);

            if ( ARGUMENT_PRESENT(lpFilePart) ) {
                if ( FilePart == NULL ) {
                    *lpFilePart = NULL;
                    }
                else {
#ifdef FE_SB
                    RtlInitUnicodeString(&UnicodeFilePart,FilePart);
                    FilePartLength = RtlUnicodeStringToOemSize( &UnicodeFilePart );
                    *lpFilePart = (PSZ)(UnicodeLength - FilePartLength);
#else
                    *lpFilePart = (PSZ)(FilePart - Ubuff);
#endif
                    *lpFilePart = *lpFilePart + (ULONG)lpBuffer;
                    }
                }
            }
        else {
            BaseSetLastNTError(Status);
            UnicodeLength = 0;
            }
        }
    else {
        if ( UnicodeLength ) {
            UnicodeLength++;
            }
        }
    RtlFreeUnicodeString(&UnicodeString);
    RtlFreeHeap(RtlProcessHeap(), 0,Ubuff);

    return (DWORD)UnicodeLength;
}


DWORD
APIENTRY
GetCurrentDirectoryOem(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )

/*++

Routine Description:

   Oem thunk to GetCurrentDirectoryW

--*/

{
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;
    DWORD ReturnValue;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    Unicode->Length = (USHORT)RtlGetCurrentDirectory_U(
                                    Unicode->MaximumLength,
                                    Unicode->Buffer
                                    );

#ifdef FE_SB
    ReturnValue = RtlUnicodeStringToOemSize( Unicode );
    if ( nBufferLength > ReturnValue-1 ) {

#else
    if ( nBufferLength > (DWORD)(Unicode->Length>>1) ) {
#endif
        OemString.Buffer = lpBuffer;
        OemString.MaximumLength = (USHORT)(nBufferLength+1);
        Status = RtlUnicodeStringToOemString(&OemString,Unicode,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            ReturnValue = 0;
            }
        else {
            ReturnValue = OemString.Length;
            }
        }
#ifndef FE_SB
    else {
        ReturnValue = ((Unicode->Length)>>1)+1;
        }
#endif

    return ReturnValue;
}





BOOL
APIENTRY
SetCurrentDirectoryOem(
    LPSTR lpPathName
    )

/*++

Routine Description:

    Oem thunk to SetCurrentDirectoryW

--*/

{

    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpPathName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }

    if (!CheckForSameCurdir(Unicode))  {
        Status = RtlSetCurrentDirectory_U(Unicode);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }

    return TRUE;
}


BOOL
APIENTRY
CreateDirectoryOem(
    LPSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    Oem thunk to CreateDirectoryW

--*/

{
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpPathName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }
    return ( CreateDirectoryW(Unicode->Buffer,lpSecurityAttributes) );
}



BOOL
APIENTRY
RemoveDirectoryOem(
    LPSTR lpPathName
    )

/*++

Routine Description:

    Oem thunk to RemoveDirectoryW

--*/

{

    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpPathName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }
    return ( RemoveDirectoryW(Unicode->Buffer) );
}





UINT
APIENTRY
GetDriveTypeOem(
    LPSTR lpRootPathName
    )

/*++

Routine Description:

    OEM thunk to GetDriveTypeW

--*/

{
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(
        &OemString,
        ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : "\\"
        );

    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return 1;
        }
    return (GetDriveTypeW(Unicode->Buffer));
}




BOOL
APIENTRY
GetDiskFreeSpaceOem(
    LPSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )

/*++

Routine Description:

    Oem thunk to GetDiskFreeSpaceW

--*/

{
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(
        &OemString,
        ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : "\\"
        );
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }
    return ( GetDiskFreeSpaceW(
                Unicode->Buffer,
                lpSectorsPerCluster,
                lpBytesPerSector,
                lpNumberOfFreeClusters,
                lpTotalNumberOfClusters
                )
            );
}



BOOL
APIENTRY
GetVolumeInformationOem(
    LPSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    )

/*++

Routine Description:

    Oem thunk to GetVolumeInformationW

--*/

{
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;
    UNICODE_STRING UnicodeVolumeName;
    UNICODE_STRING UnicodeFileSystemName;
    OEM_STRING OemVolumeName;
    OEM_STRING OemFileSystemName;
    BOOL ReturnValue;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(
        &OemString,
        ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : "\\"
        );

    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }

    UnicodeVolumeName.Buffer = NULL;
    UnicodeFileSystemName.Buffer = NULL;
    UnicodeVolumeName.MaximumLength = 0;
    UnicodeFileSystemName.MaximumLength = 0;
    OemVolumeName.Buffer = lpVolumeNameBuffer;
    OemVolumeName.MaximumLength = (USHORT)(nVolumeNameSize+1);
    OemFileSystemName.Buffer = lpFileSystemNameBuffer;
    OemFileSystemName.MaximumLength = (USHORT)(nFileSystemNameSize+1);

    try {
        if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
            UnicodeVolumeName.MaximumLength = OemVolumeName.MaximumLength << 1;
            UnicodeVolumeName.Buffer = RtlAllocateHeap(
                                            RtlProcessHeap(), 0,
                                            UnicodeVolumeName.MaximumLength
                                            );

            if ( !UnicodeVolumeName.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
                }
            }

        if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
            UnicodeFileSystemName.MaximumLength = OemFileSystemName.MaximumLength << 1;
            UnicodeFileSystemName.Buffer = RtlAllocateHeap(
                                                RtlProcessHeap(), 0,
                                                UnicodeFileSystemName.MaximumLength
                                                );

            if ( !UnicodeFileSystemName.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
                }
            }

        ReturnValue = GetVolumeInformationW(
                            Unicode->Buffer,
                            UnicodeVolumeName.Buffer,
                            nVolumeNameSize,
                            lpVolumeSerialNumber,
                            lpMaximumComponentLength,
                            lpFileSystemFlags,
                            UnicodeFileSystemName.Buffer,
                            nFileSystemNameSize
                            );

        if ( ReturnValue ) {

            if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
                RtlInitUnicodeString(
                    &UnicodeVolumeName,
                    UnicodeVolumeName.Buffer
                    );

                Status = RtlUnicodeStringToOemString(
                            &OemVolumeName,
                            &UnicodeVolumeName,
                            FALSE
                            );

                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }

            if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
                RtlInitUnicodeString(
                    &UnicodeFileSystemName,
                    UnicodeFileSystemName.Buffer
                    );

                Status = RtlUnicodeStringToOemString(
                            &OemFileSystemName,
                            &UnicodeFileSystemName,
                            FALSE
                            );

                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            }
        }
    finally {
        if ( UnicodeVolumeName.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(), 0,UnicodeVolumeName.Buffer);
            }
        if ( UnicodeFileSystemName.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(), 0,UnicodeFileSystemName.Buffer);
            }
        }

    return ReturnValue;
}






VOID
APIENTRY
OutputDebugStringOem(
    LPCSTR lpOutputString
    )

/*++

Routine Description:

    OEM thunk to OutputDebugStringA

--*/

{
    UNICODE_STRING Unicode;
    OEM_STRING     OemString;
    ANSI_STRING    AnsiString;
    NTSTATUS Status;


    Unicode.Buffer = NULL;
    AnsiString.Buffer = NULL;
    try {
        InitOemString(&OemString, lpOutputString);
        Status = RtlOemStringToUnicodeString(&Unicode, &OemString, TRUE);
        if ( !NT_SUCCESS(Status) ) {
            goto try_exit;
            }

        Status = RtlUnicodeStringToAnsiString(&AnsiString,&Unicode,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            goto try_exit;
            }

        OutputDebugStringA(AnsiString.Buffer);

try_exit:;
        }
    finally {
        if (Unicode.Buffer != NULL) {
            RtlFreeUnicodeString( &Unicode );
            }
        if (AnsiString.Buffer != NULL) {
            RtlFreeAnsiString( &AnsiString);
            }
        }
}

BOOL
APIENTRY
GetComputerNameOem(
    LPSTR lpBuffer,
    LPDWORD nSize
    )

/*++

Routine Description:

    Oem thunk to GetComputerNameW

--*/

{
    UNICODE_STRING UnicodeString;
    OEM_STRING     OemString;
    LPWSTR UnicodeBuffer;

    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = RtlAllocateHeap(RtlProcessHeap(), 0, *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Set up an ANSI_STRING that points to the user's buffer
    //

    OemString.MaximumLength = (USHORT) *nSize;
    OemString.Length = 0;
    OemString.Buffer = lpBuffer;

    //
    // Call the UNICODE version to do the work
    //

    if (!GetComputerNameW(UnicodeBuffer, nSize)) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return(FALSE);
    }

    //
    // Now convert back to Oem for the caller
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);
    RtlUnicodeStringToOemString(&OemString, &UnicodeString, FALSE);

    *nSize = OemString.Length;
    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(TRUE);

}


BOOL
WINAPI
RemoveFontResourceOem(
    LPSTR   lpFileName
    )

/*++

Routine Description:

    Oem thunk to RemoveFontResourceW

--*/

{
    PUNICODE_STRING Unicode;
    OEM_STRING OemString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpFileName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }
    return ( RemoveFontResourceW(Unicode->Buffer) );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\oemuni\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=mvdm
MINORCOMP=oemuni

TARGETNAME=oemuni
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\;..\..\inc;

SOURCES=..\file.c \
        ..\process.c

W32_SB=1

UMTYPE=console
UMTEST=toemuni
UMLIBS=$(O)\oemuni.lib
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\oemuni\toemuni.c ===
/*
 *  Sniff Test for oemuni.lib
 *  14-Jan-1993 Jonle , created
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <oemuni.h>


void TestDirNode(PCHAR DirName, PCHAR FName);
VOID SetDirectory( PCHAR Name);
VOID SetEnvironment(PCHAR Name,PCHAR Value);
void Pause(void);


#define MAXSTR MAX_PATH *2
char achEnvTMP[MAXSTR+1];
char achWinDir[MAXSTR+1];
char achSysDir[MAXSTR+1];
char achCurDir[MAXSTR+1];
char ach[MAXSTR+1];
char achTmp[MAXSTR+1];


DWORD
__cdecl
main( void)
{
   DWORD dw;

   dw = GetEnvironmentVariableOem("TMP", achEnvTMP, MAXSTR);
   if (!dw || dw > MAXSTR-1)
       printf("GetEnvironmentVariableOem(TMP) failed dw=%ld\n",dw);
   else
       printf("TMP=<%s>\n",achEnvTMP);

   dw = GetWindowsDirectoryOem(achWinDir, MAXSTR);
   if (!dw || dw > MAXSTR-1)
       printf("GetWindowsDirectory failed dw=%ld\n",dw);
   else
       printf("WinDir=<%s>\n",achWinDir);

   dw = GetSystemDirectoryOem(achSysDir, MAXSTR);
   if (!dw || dw > MAXSTR-1)
       printf("GetSystemDirectory(achSysDir failed dw=%ld\n",dw);
   else
       printf("SysDir=<%s>\n",achWinDir);

   dw = GetCurrentDirectory(MAXSTR, achCurDir);
   if (!dw || dw > MAXSTR-1)
       printf("GetCurrentDirectory(achCurDir dw=%ld\n",dw);
   else
       printf("CurDir=<%s>\n",achWinDir);

   SetDirectory(achEnvTMP);
   SetDirectory(achWinDir);
   SetDirectory(achSysDir);
   SetDirectory(achCurDir);
   Pause();

   strcpy(ach, achCurDir);
   strcat(ach, "\\foo");
   TestDirNode(ach, "foo.foo");
   SetDirectory(achCurDir);
   Pause();


   dw = GetTempPathOem(MAXSTR, ach);
   if (!dw || dw > MAXSTR)
       printf("GetTempPathOem - Failed\n");
   else {
       printf("GetTempPathOem<%s>\n",ach);

       if (!GetTempFileNameOem(".", "OEM", 0, achTmp))
           printf("GetTempFileNameOem - Failed\n");
       else
           printf("GetTempFileNameOem<%s>\n",ach);

       TestDirNode(ach, achTmp);
       }

   SetDirectory(achCurDir);
   Pause();


}





void TestDirNode(PCHAR DirName, PCHAR FName)
{
   HANDLE hFile;

   if (CreateDirectoryOem( DirName, NULL))
       printf("CreateDirectoryOem <%s>\n",DirName);
   else
       printf("CreateDirectoryOem <%s>- Fail\n",DirName);

   SetDirectory(DirName);

   hFile = CreateFileOem( FName,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          CREATE_NEW,
                          FILE_ATTRIBUTE_NORMAL,
                          0);
   if (hFile == (HANDLE) 0xFFFFFFFF) {
       printf("CreateFileOem<%s>- Fail\n", FName);
       }
   else {
       printf("CreateFileOem<%s>\n", FName);
       CloseHandle(hFile);
       }

   if (DeleteFileOem(FName))
       printf("DeleteFileOem <%s>\n",FName);
   else
       printf("DeleteFileOem <%s>- Fail\n",FName);


   SetDirectory("\\");
   if (RemoveDirectoryOem(DirName))
       printf("RemoveDirectoryOem <%s>\n",DirName);
   else
       printf("RemoveDirectoryOem <%s>- Fail\n",DirName);
}



VOID
SetDirectory(
    PCHAR Name
    )
{
    CHAR achValue[512];

    if (SetCurrentDirectoryOem( Name))
        printf( "SetCurrentDirectoryOem <%s>\n", Name ? Name : "NULL");
    else
        printf( "SetCurrentDirectoryOem- failed\n");

    if (GetCurrentDirectoryOem( sizeof(achValue)-1, achValue))
        printf( "GetCurrentDirectoryOem <%s>\n", achValue);
    else
        printf( "GetCurrentDirectoryOem - failed\n");
}



VOID
SetEnvironment(
    PCHAR Name,
    PCHAR Value
    )
{
    CHAR achValue[512];

    if (SetEnvironmentVariableOem( Name, Value ))
        printf( "SetEnvironmentVariableOem <%s=%s>\n", Name, Value ? Value : "NULL");
    else
        printf( "SetEnvironmentVariableOem - failed\n" );


    if (GetEnvironmentVariableOem( Name, achValue, sizeof(achValue)-1))
        printf( "GetEnvironmentVariableOem <%s=%s>\n", Name, achValue ? achValue : "NULL");
    else
        printf( "GetEnvironmentVariableOem - failed\n");
}



void Pause(void)
{
  printf("Press any key ....\n");
  getch();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\sim16\incs.inc ===
include     segdefs.inc 			 ; segment definitions
include     sim16.inc
include     sim16.mac

.386
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\sim16\segdefs.inc ===
MAIN_CODE      SEGMENT	   WORD    PUBLIC  'CODE'
MAIN_CODE      ENDS

DGROUP	    GROUP	MAIN_DATA

MAIN_DATA      SEGMENT	   WORD    PUBLIC  'DATA'
MAIN_DATA      ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\oemuni\process.c ===
/*  process.c
 *  OemUnicode win32 thunks
 *  - process\env stuff
 *
 *  14-Jan-1993 Jonle
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <oemuni.h>
#include "oem.h"
#include <vdmapi.h>
UINT
APIENTRY
GetSystemDirectoryOem(
                     LPSTR lpBuffer,
                     UINT uSize
                     )

/*++

Routine Description:

    OEM thunk to GetSystemDirectoryW

--*/

{
    OEM_STRING OemString;
    UNICODE_STRING Unicode;
    NTSTATUS Status;

    Unicode.MaximumLength = (USHORT)((uSize<<1)+sizeof(UNICODE_NULL));
    Unicode.Buffer = RtlAllocateHeap(
                                    RtlProcessHeap(), 0,
                                    Unicode.MaximumLength
                                    );
    if ( !Unicode.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
    }

    Unicode.Length = GetSystemDirectoryW(Unicode.Buffer,
                                         (Unicode.MaximumLength-sizeof(UNICODE_NULL))/2
                                        )*2;

    if ( Unicode.Length > (USHORT)(Unicode.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,Unicode.Buffer);
        return Unicode.Length>>1;
    }
    OemString.Buffer = lpBuffer;
    OemString.MaximumLength = (USHORT)(uSize+1);
    Status = RtlUnicodeStringToOemString(&OemString,&Unicode,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,Unicode.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
    }
    return OemString.Length;
}



UINT
APIENTRY
GetWindowsDirectoryOem(
                      LPSTR lpBuffer,
                      UINT uSize
                      )

/*++

Routine Description:

    OEM thunk to GetWindowsDirectoryW

--*/

{
    OEM_STRING OemString;
    UNICODE_STRING Unicode;
    NTSTATUS Status;

    Unicode.MaximumLength = (USHORT)((uSize<<1)+sizeof(UNICODE_NULL));
    Unicode.Buffer = RtlAllocateHeap(
                                    RtlProcessHeap(), 0,
                                    Unicode.MaximumLength
                                    );
    if ( !Unicode.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
    }

    Unicode.Length = GetWindowsDirectoryW(Unicode.Buffer,
                                          (Unicode.MaximumLength-sizeof(UNICODE_NULL))/2
                                         )*2;

    if ( Unicode.Length > (USHORT)(Unicode.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,Unicode.Buffer);
        return Unicode.Length>>1;
    }
    OemString.Buffer = lpBuffer;
    OemString.MaximumLength = (USHORT)(uSize+1);
    Status = RtlUnicodeStringToOemString(&OemString,&Unicode,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,Unicode.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
    }
    return OemString.Length;
}


DWORD
APIENTRY
SearchPathOem (
              LPCSTR lpPath,
              LPCSTR lpFileName,
              LPCSTR lpExtension,
              DWORD nBufferLength,
              LPSTR lpBuffer,
              LPSTR *lpFilePart
              )

/*++

Routine Description:

    Oem thunk to SearchPathW

--*/

{

    UNICODE_STRING xlpPath;
    PUNICODE_STRING Unicode;
    UNICODE_STRING xlpExtension;
    PWSTR xlpBuffer;
    DWORD ReturnValue=0;
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    PWSTR FilePart;
    PWSTR *FilePartPtr;

    if ( ARGUMENT_PRESENT(lpFilePart) ) {
        FilePartPtr = &FilePart;
    } else {
        FilePartPtr = NULL;
    }

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    InitOemString(&OemString,lpFileName);

    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return 0;
    }

    if ( ARGUMENT_PRESENT(lpExtension) ) {
        InitOemString(&OemString,lpExtension);
        Status = RtlOemStringToUnicodeString(&xlpExtension,&OemString,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return 0;
        }
    } else {
        xlpExtension.Buffer = NULL;
    }

    if ( ARGUMENT_PRESENT(lpPath) ) {
        InitOemString(&OemString,lpPath);
        Status = RtlOemStringToUnicodeString(&xlpPath,&OemString,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            if ( ARGUMENT_PRESENT(lpExtension) ) {
                RtlFreeUnicodeString(&xlpExtension);
            }
            BaseSetLastNTError(Status);
            return 0;
        }
    } else {
        xlpPath.Buffer = NULL;
    }

    xlpBuffer = RtlAllocateHeap(RtlProcessHeap(), 0,nBufferLength<<1);
    if ( !xlpBuffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        goto bail0;
    }
    ReturnValue = SearchPathW(
                             xlpPath.Buffer,
                             Unicode->Buffer,
                             xlpExtension.Buffer,
                             nBufferLength,
                             xlpBuffer,
                             FilePartPtr
                             );

#ifdef FE_SB
    if ( ReturnValue ) {
        RtlInitUnicodeString(&UnicodeString,xlpBuffer);
        ReturnValue = RtlUnicodeStringToOemSize(&UnicodeString) - 1;
#endif

        if (ReturnValue && ReturnValue <= nBufferLength ) {
#ifndef FE_SB
            RtlInitUnicodeString(&UnicodeString,xlpBuffer);
#endif
            OemString.MaximumLength = (USHORT)(nBufferLength+1);
            OemString.Buffer = lpBuffer;
            Status = RtlUnicodeStringToOemString(&OemString,&UnicodeString,FALSE);
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnValue = 0;
            } else {
                if ( ARGUMENT_PRESENT(lpFilePart) ) {
                    if ( FilePart == NULL ) {
                        *lpFilePart = NULL;
                    } else {
                        *lpFilePart = (LPSTR)(FilePart - xlpBuffer);
                        *lpFilePart = *lpFilePart + (DWORD)lpBuffer;
                    }
                }
            }
        }
#ifdef FE_SB
    }
#endif

    RtlFreeHeap(RtlProcessHeap(), 0,xlpBuffer);
    bail0:
    if ( ARGUMENT_PRESENT(lpExtension) ) {
        RtlFreeUnicodeString(&xlpExtension);
    }

    if ( ARGUMENT_PRESENT(lpPath) ) {
        RtlFreeUnicodeString(&xlpPath);
    }
    return ReturnValue;
}


DWORD
APIENTRY
GetTempPathOem(
              DWORD nBufferLength,
              LPSTR lpBuffer
              )

/*++

Routine Description:

    OEM thunk to GetTempPathW

--*/

{
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    UnicodeString.MaximumLength = (USHORT)((nBufferLength<<1)+sizeof(UNICODE_NULL));
    UnicodeString.Buffer = RtlAllocateHeap(
                                          RtlProcessHeap(), 0,
                                          UnicodeString.MaximumLength
                                          );
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
    }
    UnicodeString.Length = (USHORT)GetTempPathW(
                                               (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2,
                                               UnicodeString.Buffer
                                               )*2;
    if ( UnicodeString.Length > (USHORT)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);
        return UnicodeString.Length>>1;
    }
    OemString.Buffer = lpBuffer;
    OemString.MaximumLength = (USHORT)(nBufferLength+1);
    Status = RtlUnicodeStringToOemString(&OemString,&UnicodeString,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
    }
    return OemString.Length;
}



UINT
APIENTRY
GetTempFileNameOem(
                  LPCSTR lpPathName,
                  LPCSTR lpPrefixString,
                  UINT uUnique,
                  LPSTR lpTempFileName
                  )

/*++

Routine Description:

    Oem thunk to GetTempFileNameW

--*/

{
    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodePrefix;
    OEM_STRING OemString;
    NTSTATUS Status;
    UINT ReturnValue;
    UNICODE_STRING UnicodeResult;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;

    InitOemString(&OemString,lpPathName);
    Status = RtlOemStringToUnicodeString(Unicode,&OemString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return 0;
    }

    InitOemString(&OemString,lpPrefixString);
    Status = RtlOemStringToUnicodeString(&UnicodePrefix,&OemString,TRUE);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
    }
    UnicodeResult.MaximumLength = (USHORT)((MAX_PATH<<1)+sizeof(UNICODE_NULL));
    UnicodeResult.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0,UnicodeResult.MaximumLength);
    if ( !UnicodeResult.Buffer ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RtlFreeUnicodeString(&UnicodePrefix);
        return 0;
    }

    ReturnValue = GetTempFileNameW(
                                  Unicode->Buffer,
                                  UnicodePrefix.Buffer,
                                  uUnique,
                                  UnicodeResult.Buffer
                                  );
    if ( ReturnValue ) {
        RtlInitUnicodeString(&UnicodeResult,UnicodeResult.Buffer);
        OemString.Buffer = lpTempFileName;
        OemString.MaximumLength = MAX_PATH+1;
        Status = RtlUnicodeStringToOemString(&OemString,&UnicodeResult,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            ReturnValue = 0;
        }
    }
    RtlFreeUnicodeString(&UnicodePrefix);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeResult.Buffer);

    return ReturnValue;
}


#if 0  // unused
BOOL
WINAPI
CreateProcessOem(
                LPCSTR lpApplicationName,
                LPCSTR lpCommandLine,
                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                BOOL bInheritHandles,
                DWORD dwCreationFlags,
                LPVOID lpEnvironment,
                LPSTR lpCurrentDirectory,
                LPSTARTUPINFOA lpStartupInfo,
                LPPROCESS_INFORMATION lpProcessInformation
                )

/*++

    OEM thunk to CreateProcessW

--*/

{
    NTSTATUS Status;
    PUNICODE_STRING CommandLine;
    UNICODE_STRING ApplicationName;
    UNICODE_STRING CurrentDirectory;
    STARTUPINFOW StartupInfo;
    OEM_STRING OemString;
    UNICODE_STRING Unicode;
    UNICODE_STRING DynamicCommandLine;
    BOOL ReturnStatus;

    CommandLine = &NtCurrentTeb()->StaticUnicodeString;

    if (ARGUMENT_PRESENT (lpCommandLine)) {
        InitOemString(&OemString,lpCommandLine);
        if ( OemString.Length<<1 < NtCurrentTeb()->StaticUnicodeString.MaximumLength ) {
            DynamicCommandLine.Buffer = NULL;
            Status = RtlOemStringToUnicodeString(CommandLine,&OemString,FALSE);
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
            }
        } else {
            Status = RtlOemStringToUnicodeString(&DynamicCommandLine,&OemString,TRUE);
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
            }
        }
    } else {
        DynamicCommandLine.Buffer = NULL;
        CommandLine->Buffer = NULL;
    }

    ApplicationName.Buffer = NULL;
    ApplicationName.Buffer = NULL;
    CurrentDirectory.Buffer = NULL;
    RtlMoveMemory(&StartupInfo,lpStartupInfo,sizeof(*lpStartupInfo));
    ASSERT(sizeof(StartupInfo) == sizeof(*lpStartupInfo));
    StartupInfo.lpReserved = NULL;
    StartupInfo.lpDesktop = NULL;
    StartupInfo.lpTitle = NULL;

    try {
        if (ARGUMENT_PRESENT(lpApplicationName)) {
            InitOemString(&OemString,lpApplicationName);
            Status = RtlOemStringToUnicodeString(&ApplicationName,&OemString,TRUE);
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnStatus = FALSE;
                goto tryexit;
            }
        }

        if (ARGUMENT_PRESENT(lpCurrentDirectory)) {
            InitOemString(&OemString,lpCurrentDirectory);
            Status = RtlOemStringToUnicodeString(&CurrentDirectory,&OemString,TRUE);
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnStatus = FALSE;
                goto tryexit;
            }
        }

        if (ARGUMENT_PRESENT(lpStartupInfo->lpReserved)) {
            InitOemString(&OemString,lpStartupInfo->lpReserved);
            Unicode.MaximumLength = (USHORT)RtlOemStringToUnicodeSize(&OemString) ;
            StartupInfo.lpReserved = RtlAllocateHeap(RtlProcessHeap(), 0, Unicode.MaximumLength);
            if ( !StartupInfo.lpReserved ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                ReturnStatus = FALSE;
                goto tryexit;
            }
            Unicode.Buffer = StartupInfo.lpReserved;
            Status = RtlOemStringToUnicodeString(&Unicode,&OemString,FALSE);
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnStatus = FALSE;
                goto tryexit;
            }
        }

        if (ARGUMENT_PRESENT(lpStartupInfo->lpDesktop)) {
            InitOemString(&OemString,lpStartupInfo->lpDesktop);
            Unicode.MaximumLength = (USHORT)RtlOemStringToUnicodeSize(&OemString) ;
            StartupInfo.lpDesktop = RtlAllocateHeap(RtlProcessHeap(), 0, Unicode.MaximumLength);
            if ( !StartupInfo.lpDesktop ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                ReturnStatus = FALSE;
                goto tryexit;
            }
            Unicode.Buffer = StartupInfo.lpDesktop;
            Status = RtlOemStringToUnicodeString(&Unicode,&OemString,FALSE);
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnStatus = FALSE;
                goto tryexit;
            }
        }

        if (ARGUMENT_PRESENT(lpStartupInfo->lpTitle)) {
            InitOemString(&OemString,lpStartupInfo->lpTitle);
            Unicode.MaximumLength = (USHORT)RtlOemStringToUnicodeSize(&OemString) ;
            StartupInfo.lpTitle = RtlAllocateHeap(RtlProcessHeap(), 0, Unicode.MaximumLength);
            if ( !StartupInfo.lpTitle ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                ReturnStatus = FALSE;
                goto tryexit;
            }
            Unicode.Buffer = StartupInfo.lpTitle;
            Status = RtlOemStringToUnicodeString(&Unicode,&OemString,FALSE);
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnStatus = FALSE;
                goto tryexit;
            }
        }
        ReturnStatus = CreateProcessW(
                                     ApplicationName.Buffer,
                                     DynamicCommandLine.Buffer ? DynamicCommandLine.Buffer : CommandLine->Buffer,
                                     lpProcessAttributes,
                                     lpThreadAttributes,
                                     bInheritHandles,
                                     dwCreationFlags,
                                     lpEnvironment,
                                     CurrentDirectory.Buffer,
                                     &StartupInfo,
                                     lpProcessInformation
                                     );
        tryexit:;
    } finally {
        if (DynamicCommandLine.Buffer) {
            RtlFreeUnicodeString(&DynamicCommandLine);
            DynamicCommandLine.Buffer = NULL;
        }

        if (ApplicationName.Buffer) {
            RtlFreeUnicodeString(&ApplicationName);
            ApplicationName.Buffer = NULL;
        }

        if (CurrentDirectory.Buffer) {
            RtlFreeUnicodeString(&CurrentDirectory);
            CurrentDirectory.Buffer = NULL;
        }

        if (StartupInfo.lpReserved) {
            RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpReserved);
            StartupInfo.lpReserved = NULL;
        }

        if (StartupInfo.lpDesktop) {
            RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpDesktop);
            StartupInfo.lpDesktop = NULL;
        }

        if (StartupInfo.lpTitle) {
            RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpTitle);
            StartupInfo.lpTitle = NULL;
        }
    }
    return ReturnStatus;

}
#endif



DWORD
WINAPI
GetEnvironmentVariableOem(
                         LPSTR lpName,
                         LPSTR lpBuffer,
                         DWORD nSize
                         )
/*++

    OEM thunk to GetEnvironmentVariableW

--*/
{
    NTSTATUS Status;
    UNICODE_STRING Unicode;
    OEM_STRING     OemString;
    ANSI_STRING Name, Buffer;
    DWORD ReturnValue;

    Unicode.Buffer = NULL;
    Name.Buffer = NULL;
    Buffer.Buffer = NULL;
    ReturnValue = 0;
    try {

        InitOemString(&OemString,lpName);
        Status = RtlOemStringToUnicodeString(&Unicode, &OemString, TRUE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
            } else {
                BaseSetLastNTError(Status);
            }
            return 0;
        }

        Status = RtlUnicodeStringToAnsiString( &Name, &Unicode, TRUE );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            goto try_exit;
        }

        Buffer.MaximumLength = (USHORT)nSize;
        Buffer.Buffer = (PCHAR)
                        RtlAllocateHeap( RtlProcessHeap(), 0, Buffer.MaximumLength );
        if (Buffer.Buffer == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            goto try_exit;
        }

        ReturnValue = GetEnvironmentVariableA( Name.Buffer,
                                               Buffer.Buffer,
                                               Buffer.MaximumLength
                                             );
        if (ReturnValue != 0) {
            if ( ReturnValue < nSize ) {
                Buffer.Length = (USHORT)ReturnValue;
                RtlFreeUnicodeString( &Unicode );
                Unicode.Buffer = NULL;
                Status = RtlAnsiStringToUnicodeString( &Unicode, &Buffer, TRUE );
                if (!NT_SUCCESS( Status )) {
                    BaseSetLastNTError( Status );
                    ReturnValue = 0;
                }

                OemString.Buffer        = lpBuffer;
                OemString.MaximumLength = (USHORT)nSize;
                Status = RtlUnicodeStringToOemString( &OemString, &Unicode, FALSE );
                if (!NT_SUCCESS( Status )) {
                    BaseSetLastNTError( Status );
                    ReturnValue = 0;
                }
            }
        }
        try_exit:;
    } finally {
        if (Unicode.Buffer != NULL) {
            RtlFreeUnicodeString( &Unicode );
        }

        if (Name.Buffer != NULL) {
            RtlFreeAnsiString( &Name );
        }

        if (Buffer.Buffer != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, Buffer.Buffer );
        }
    }

    return ( ReturnValue );
}




BOOL
WINAPI
SetEnvironmentVariableOem(
                         LPSTR lpName,
                         LPSTR lpValue
                         )
/*++

    OEM thunk to SetEnvironmentVariableW

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Unicode;
    OEM_STRING     OemString;
    ANSI_STRING Name, Value;
    DWORD ReturnValue;

    Unicode.Buffer = NULL;
    Name.Buffer = NULL;
    Value.Buffer = NULL;
    ReturnValue = 0;
    try {
        InitOemString(&OemString, lpName);
        Status = RtlOemStringToUnicodeString(&Unicode, &OemString, TRUE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
            } else {
                BaseSetLastNTError(Status);
            }
            return 0;
        }

        Status = RtlUnicodeStringToAnsiString( &Name, &Unicode, TRUE );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            goto try_exit;
        }
        RtlFreeUnicodeString( &Unicode );
        Unicode.Buffer = NULL;

        if (ARGUMENT_PRESENT( lpValue )) {
            InitOemString(&OemString, lpValue);
            Status = RtlOemStringToUnicodeString(&Unicode, &OemString, TRUE);
            if ( !NT_SUCCESS(Status) ) {
                if ( Status == STATUS_BUFFER_OVERFLOW ) {
                    SetLastError(ERROR_FILENAME_EXCED_RANGE);
                } else {
                    BaseSetLastNTError(Status);
                }
                return 0;
            }

            Status = RtlUnicodeStringToAnsiString( &Value, &Unicode, TRUE );
            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError( Status );
                goto try_exit;
            }

        }

        ReturnValue = SetEnvironmentVariableA( Name.Buffer,
                                               Value.Buffer
                                             );
        try_exit:;
    } finally {
        if (Unicode.Buffer != NULL) {
            RtlFreeUnicodeString( &Unicode );
        }

        if (Name.Buffer != NULL) {
            RtlFreeAnsiString( &Name );
        }

        if (Value.Buffer != NULL) {
            RtlFreeAnsiString( &Value );
        }
    }

    return ( ReturnValue );
}



DWORD
WINAPI
ExpandEnvironmentStringsOem(
                           LPSTR lpSrc,
                           LPSTR lpDst,
                           DWORD cchDst
                           )
/*++

    OEM thunk to ExpandEnvironmentStrings

--*/

{

    NTSTATUS Status;
    UNICODE_STRING Unicode;
    OEM_STRING     OemString;
    ANSI_STRING Name, Value;
    DWORD ReturnValue;

    if (!ARGUMENT_PRESENT(lpSrc)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    Unicode.Buffer = NULL;
    Name.Buffer = NULL;
    Value.Buffer = NULL;
    ReturnValue = 0;
    try {
        InitOemString(&OemString, lpSrc);
        Status = RtlOemStringToUnicodeString(&Unicode, &OemString, TRUE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
            } else {
                BaseSetLastNTError(Status);
            }
            return 0;
        }

        Status = RtlUnicodeStringToAnsiString( &Name, &Unicode, TRUE );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            goto try_exit;
        }
        RtlFreeUnicodeString( &Unicode );
        Unicode.Buffer = NULL;

        ReturnValue = ExpandEnvironmentStrings( Name.Buffer,
                                                lpDst,
                                                cchDst
                                              );
        if (ReturnValue != 0 && ReturnValue <= cchDst) {
            RtlInitString(&Value, lpDst);
            Status = RtlAnsiStringToUnicodeString(&Unicode, &Value, TRUE);
            if ( !NT_SUCCESS(Status) ) {
                if ( Status == STATUS_BUFFER_OVERFLOW ) {
                    SetLastError(ERROR_FILENAME_EXCED_RANGE);
                } else {
                    BaseSetLastNTError(Status);
                }
                goto try_exit;
            }
            Status = RtlUnicodeStringToOemString( &Value, &Unicode, TRUE );
            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError( Status );
                goto try_exit;
            }

        }
        try_exit:;
    } finally {
        if (Unicode.Buffer != NULL) {
            RtlFreeUnicodeString( &Unicode );
        }

        if (Name.Buffer != NULL) {
            RtlFreeAnsiString( &Name );
        }

        if (Value.Buffer != NULL) {
            RtlFreeAnsiString( &Value );
        }
    }

    return ( ReturnValue );
}


UINT
WINAPI
GetShortPathNameOem(
                   LPSTR lpSrc,
                   LPSTR lpDst,
                   DWORD cchDst
                   )
/*++

    OEM thunk to GetShortPathNameW

--*/

{

    UNICODE_STRING  UString = {0}, UStringRet;
    OEM_STRING     OemString;
    NTSTATUS        Status;
    LPWSTR      lpDstW = NULL;
    DWORD       ReturnValue = 0;

    if (lpSrc == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }
    try {
        InitOemString(&OemString, lpSrc);
        Status = RtlOemStringToUnicodeString(&UString,
                                             &OemString,
                                             TRUE
                                            );
        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            leave;
        }
        if (ARGUMENT_PRESENT(lpDst) && cchDst > 0) {
            lpDstW = RtlAllocateHeap(RtlProcessHeap(), 0,
                                     cchDst * sizeof(WCHAR)
                                    );
            if (lpDstW == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                leave;
            }
        } else {
            lpDstW = NULL;
            cchDst = 0;
        }
        ReturnValue = GetShortPathNameW(UString.Buffer,
                                        lpDstW,
                                        cchDst
                                       );
        if (ReturnValue != 0 && ReturnValue <= cchDst) {
            if (ARGUMENT_PRESENT(lpDst)) {
                OemString.Buffer = lpDst;
                OemString.MaximumLength = (USHORT)(cchDst * sizeof(WCHAR));
                UStringRet.Buffer = lpDstW;
                UStringRet.Length = (USHORT)(ReturnValue * sizeof(WCHAR));
                Status = RtlUnicodeStringToOemString(&OemString,
                                                     &UStringRet,
                                                     FALSE
                                                    );
                if (!NT_SUCCESS(Status)) {
                    BaseSetLastNTError(Status);
                    ReturnValue = 0;
                    leave;
                }
            }
        }
    } finally {
        RtlFreeUnicodeString(&UString);
        if (lpDstW)
            RtlFreeHeap(RtlProcessHeap(), 0, lpDstW);
    }
    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\sim16\sim16.asm ===
;******************************************************************************
;
;		Simulator 16
;
;		Author : Chandan Chauhan
;
;		Date : 1/28/91
;
;******************************************************************************

include incs.inc			    ; segment definitions


MAXSIZE     EQU     1024		    ; 1k length

Arg1	    EQU     [bp+6]
Arg2	    EQU     [bp+8]

WOW32_Buffer EQU    [bp+6]		    ; buffer address
WOW32_Size  EQU     [bp+8]		    ; length of VDM memory
WOW32_Off   EQU     [bp+10]		    ; off of VDM memory
WOW32_Sel   EQU     [bp+12]		    ; sel of VDM memory
WOWStackNP  EQU     [bp+6]		    ; WOWStack
WOWStackOff EQU     [bp+6]
WOWStackSel EQU     [bp+8]

    extrn   Initialize:near

MAIN_DATA   SEGMENT
	    PUBLIC  TransmitPkt, ReceivePkt, ReceivePktPtr, RespPkt, ToWOW32Pkt
	    PUBLIC  ACKPkt, NAKPkt, GetMemPkt, SetMemPkt, WAKEUPPkt
	    PUBLIC  fReceive, fRxCount, fRxError, RxPktLen
	    PUBLIC  fTxCount, fTransmitting
	    PUBLIC  fInitTime
	    PUBLIC  VDMAddress
	    PUBLIC  WOWStack, WOW32Buffer

    Reserved	    DB	    16 DUP (0)	    ; reserved

    TransmitPkt     DD	    -1		    ; packet being transmitted
    TransmitPktLen  DW	    0		    ; packet being transmitted
    TransmitPktPtr  DW	    0		    ; byte to Tx

    ReceivePkt	    DB	    MAXSIZE DUP (0FFh)	; packet being received
    ReceivePktPtr   DW	    0		    ; packet being received

    RespPkt	    DB	    MAXSIZE DUP (0FFh)	; packet being transmitted

    ToWOW32Pkt	    DB	    9 DUP (?)	    ; ToWOW32 packet
		    DB	    0

    WAKEUPPkt	    DB	    9 DUP (0)	    ; WAKEUP packet
		    DB	    0

    ACKPkt	    DB	    5 DUP (?)	    ; ACK packet
		    DB	    0

    NAKPkt	    DB	    5 DUP (?)	    ; NAK packet
		    DB	    0

    GetMemPkt	    DB	    MAXSIZE DUP (?)	 ;***************
    SetMemPkt	    DB	    MAXSIZE DUP (?)	 ;***************


    VDMAddress	    DD	    -1		    ; stores VDM sel:off
    VDMLength	    DW	    -1		    ; number of bytes

    WOW32Buffer     DD	    -1		    ; ptr caller's buffer
    WOWStack	    DD	    -1		    ; ptr to caller's WOWStack

    fTxCount	    DW	    0
    fTransmitting   DW	    0

    fReceive	    DW	    0
    fRxCount	    DW	    0
    fRxError	    DW	    0

    fInitTime	    DW	    0
    fInitDLL	    DW	    0

    RxPktLen	    DW	    0

    Stack	DW	256 DUP (?)
    StackTop	DW	?
    OldSS	DW	?
    OldSP	DW	?
    Scratch	DW	?
    fStackUse	DW	-1

    IntRoutines LABEL	WORD
	    DW	    COMISR_MSR
	    DW	    COMISR_Transmit
	    DW	    COMISR_Receive
	    DW	    COMISR_LSR

    HelloString DB  cr, lf, 'WOW Simulator *****', cr, lf, lf
		DB  'Hello, this is a test string !!!!!!!!!!', cr, lf
    HelloStringLen  EQU      $ - HelloString

MAIN_DATA   ENDS



MAIN_CODE   SEGMENT
	    ASSUME  CS:MAIN_CODE, DS:MAIN_DATA, ES:NOTHING

;*****************************************************************************
;		S I M U L A T O R    L A Y E R
;*****************************************************************************

;*****************************************************************************
;
;   Sim32SendSim16
;
;*****************************************************************************

;***************

PROCEDURE   Sim32SendSim16  PUBLIC, FAR

    push    bp				    ; save stack frame
    mov     bp, sp

    pusha				    ; temps...
    push    ds				    ; temps...
    push    es				    ; temps...

    mov     bx, ds

    mov     ax, SEG MAIN_DATA
    mov     ds, ax
    mov     si, OFFSET WAKEUPPkt	    ; DS:SI -> WAKEUP packet


    mov     ax, WOWStackNP
    mov     WOWStack._off, ax
    mov     WOWStack._sel, bx

    cmp     fInitTime, 0
    je	    Sim32SendSim16_Init


    les     bx, WOWStack		    ; ES:BX -> SS:SP of WOW VDM task
    mov     ax, es:[bx]._off		    ; get SP
    mov     [si].MEM_OFF, ax
    mov     ax, es:[bx]._sel		    ; get SS
    mov     [si].MEM_SEL, ax

    call    Xceive

Sim32SendSim16_Ret:
    les     bx, WOWStack		    ; ES:BX -> SS:SP of WOW VDM task
    mov     di, OFFSET ReceivePkt
    mov     ax, [di].ToWOW32_OFF
    mov     es:[bx]._off, ax
    mov     ax, [di].ToWOW32_SEL
    mov     es:[bx]._sel, ax


    pop     es				    ; temps...
    pop     ds				    ; temps...
    popa				    ; temps...

    mov     sp, bp
    pop     bp

    ret     2

Sim32SendSim16_Init:
    call    Receive
    inc     fInitTime
    call    Initialize
    jmp     SHORT Sim32SendSim16_Ret


Sim32SendSim16 ENDP


;*****************************************************************************
;
;   Sim32GetVDMMemory
;
;*****************************************************************************

;***************

PROCEDURE   Sim32GetVDMMemory  PUBLIC, FAR

    push    bp				    ; save stack frame
    mov     bp, sp

    pusha				    ; temps...
    push    ds				    ; temps...
    push    es				    ; temps...

    mov     bx, ds

    mov     ax, SEG MAIN_DATA
    mov     ds, ax
    mov     si, OFFSET GetMemPkt	    ; DS:SI -> ToWOW32 packet

    mov     ax, WOW32_Buffer		    ; get buffer's address
    mov     WOW32Buffer._off, ax
    mov     ax, bx
    mov     WOW32Buffer._sel, ax

    mov     ax, WOW32_Off
    mov     [si].MEM_OFF, ax

    mov     ax, WOW32_Sel
    mov     [si].MEM_SEL, ax

    mov     cx, WOW32_Size		    ; get the length

    cmp     cx, 3B6h
    jg	    Sim32GetMem_Error

    mov     [si].MEM_LENGTH, cx

    call    Xceive			    ; send GetMem packet and pickup
					    ; the response
    mov     cx, WOW32_Size

    les     di, WOW32Buffer		    ; ES:DI -> WOW32 buffer
    mov     si, OFFSET ReceivePkt+4

    rep movsb

    pop     es				    ; temps...
    pop     ds				    ; temps...
    popa				    ; temps...

    mov     sp, bp
    pop     bp

    ret     8


Sim32GetMem_Error:
    int     3

Sim32GetVDMMemory ENDP

;*****************************************************************************
;
;   Sim32SetVDMMemory
;
;*****************************************************************************

;***************

PROCEDURE   Sim32SetVDMMemory  PUBLIC, FAR

    push    bp				    ; save stack frame
    mov     bp, sp

    pusha				    ; temps...
    push    ds				    ; temps...
    push    es				    ; temps...

    mov     bx, ds

    mov     ax, SEG MAIN_DATA
    mov     ds, ax
    mov     di, OFFSET SetMemPkt	    ; DS:DI -> SetMem packet

    mov     ax, WOW32_Buffer		    ; get buffer's address
    mov     WOW32Buffer._off, ax
    mov     ax, bx
    mov     WOW32Buffer._sel, ax

    mov     ax, WOW32_Off
    mov     [di].MEM_OFF, ax

    mov     ax, WOW32_Sel
    mov     [di].MEM_SEL, ax

    mov     cx, WOW32_Size

    cmp     cx, 3B6h
    jg	    Sim32SetMem_Error

    mov     [di].MEM_LENGTH, cx
    mov     bx, 11
    add     bx, cx
    mov     [di].Len, bx
    add     di, 0Ah
    mov     bx, ds
    mov     es, bx

    lds     si, WOW32Buffer		    ; DS:SI -> Buffer
    rep  movsb
    mov     BYTE PTR es:[di], EOT

    mov     ds, bx
    mov     si, OFFSET SetMemPkt	    ; DS:SI -> SetMem packet

    call    Xceive

    pop     es				    ; temps...
    pop     ds				    ; temps...
    popa				    ; temps...

    mov     sp, bp
    pop     bp

    ret     8

Sim32SetMem_Error:
    int     3

Sim32SetVDMMemory ENDP


;*****************************************************************************
;
;   Sim16SendSim32
;
;*****************************************************************************

PROCEDURE   Sim16SendSim32  PUBLIC, FAR

    push    bp				    ; save stack frame
    mov     bp, sp

    pusha				    ; temps...
    push    ds				    ; temps...
    push    es				    ; temps...

    mov     bx, ds
    mov     ax, SEG MAIN_DATA
    mov     ds, ax
    mov     si, OFFSET ToWOW32Pkt	    ; DS:SI -> ToWOW32 packet

    cmp     fInitDLL, 0
    jne     @f

    pusha
    call    Initialize
    popa

    inc     fInitDLL

@@:

    ; prepare ToWOW32 packet

    mov     ax, WOWStackOff
    mov     [si].ToWOW32_OFF, ax	    ;
    mov     ax, WOWStackSel
    mov     [si].ToWOW32_SEL, ax	    ;

    ; send it

    call    Xceive			    ; send ToWOW32 packet and pick up
					    ; the response

Sim16SendSim32_Loop:

    mov     di, OFFSET Receivepkt
    mov     ax, [di].MEM_OFF		    ; get sel:off and length from
    mov     VDMAddress._off, ax 	    ; packet
    mov     ax, [di].MEM_SEL
    mov     VDMAddress._sel, ax
    mov     ax, [di].MEM_LENGTH
    mov     VDMLength, ax


Sim16SendSim32_GetMem:

    cmp     [di].Command, GETMEM
    jne     Sim16SendSim32_SetMem

    call    GetVDMMemory		    ; get vdm memory

    call    Xceive			    ; send response and get next packet

    jmp     SHORT Sim16SendSim32_Loop


Sim16SendSim32_SetMem:

    cmp     [di].Command, SETMEM
    jne     Sim16SendSim32_PszLen

    call    SetVDMMemory		    ; get vdm memory

    call    Xceive			    ; send response and get next packet

    jmp     SHORT Sim16SendSim32_Loop


Sim16SendSim32_PszLen:

    cmp     [di].Command, PSZ
    jne     Sim16SendSim32_WakeUp

    call    PszLen

    call    Xceive			    ; send response and get next packet

    jmp     SHORT Sim16SendSim32_Loop


Sim16SendSim32_WakeUp:

    cmp     [di].Command, WAKEUP
    jne     Sim16SendSim32_Error


Sim16SendSim32_Done:

    pop     es				    ; temps...
    pop     ds				    ; temps...
    popa				    ; temps...

    IFDEF STACKSWITCH
    cli
    mov     sp, VDMAddress._off
    mov     ss, VDMAddress._sel 	    ; could be a task switch !
    sub     sp, 8
    sti
    ENDIF

    pop     bp

    ret     4

Sim16SendSim32_Error:

    int     3
    mov     si, OFFSET NAKPkt
    call    Xceive
    jmp     SHORT Sim16SendSim32_Loop

Sim16SendSim32	ENDP


;*****************************************************************************
;
;   GetVDMMemory
;
;*****************************************************************************

PROCEDURE GetVDMMemory, PUBLIC
	ASSUME	CS:MAIN_CODE, DS:DGROUP

    push    di
    push    es
    push    ds

    mov     ax, ds
    mov     es, ax

    mov     di, OFFSET RespPkt+4	    ; ES:DI -> Response Packet

    mov     cx, VDMLength
    lds     si, VDMAddress		    ; DS:SI -> memory to get

    rep movsb

    pop     ds
    pop     es
    pop     di

    mov     si, OFFSET RespPkt		    ; DS:SI -> Resp packet
    mov     ax, si

    mov     cx, VDMLength
    add     cx, 5
    mov     [si].Len, cx
    add     si, cx
    dec     si
    mov     [si], BYTE PTR EOT

    mov     si, ax			    ; DS:SI -> Resp packet

    ret

GetVDMMemory   ENDP


;*****************************************************************************
;
;   SetVDMMemory
;
;*****************************************************************************

PROCEDURE SetVDMMemory, PUBLIC
	ASSUME	CS:MAIN_CODE, DS:DGROUP

    push    di
    push    es

    lea     si, ReceivePkt.DataM	       ; DS:SI -> Data to set

    mov     cx, VDMLength
    les     di, VDMAddress		    ; DS:SI -> memory to set

    rep movsb

    mov     si, OFFSET RespPkt		    ; DS:DI -> Response Packet

    mov     [si].Len, 7
    mov     [si].MEM_OFF, 0AAh
    mov     BYTE PTR [si].MEM_SEL, EOT

    pop     es
    pop     di

    ret

SetVDMMemory   ENDP



;*****************************************************************************
;
;   PszLen
;
;   This routine returns the length of the null terminated string
;   address specified by VDMAddress.
;
;*****************************************************************************

PROCEDURE PszLen, PUBLIC
	ASSUME	CS:MAIN_CODE, DS:DGROUP

    push    di
    push    es

    les     di, VDMAddress		    ; ES:DI -> String
    mov     cx, 0FFFFh

    sub     ax, ax			    ; look for null
    repne   scasb
    jnz     PszLen_Notfound

    xor     cx, 0FFFFh			    ; CX = length of string
    mov     si, OFFSET RespPkt		    ; DS:DI -> Response Packet

    mov     [si].Len, 7
    mov     [si].MEM_OFF, cx
    mov     BYTE PTR [si].MEM_SEL, EOT

    pop     es
    pop     di

    ret


PszLen_Notfound:

    int     3

    pop     es
    pop     di

    ret


PszLen	 ENDP




;*****************************************************************************
;		T R A N S P O R T   L A Y E R
;*****************************************************************************


;*****************************************************************************
;
;   Xceive - TransCeive
;
;	DS:SI -> Packet to be transmitted
;
;*****************************************************************************

PROCEDURE Xceive, PUBLIC
	ASSUME	CS:MAIN_CODE, DS:DGROUP

    mov     RxPktLen, -1
    mov     ReceivePktPtr, 0
    mov     fReceive, 0
    mov     fRxCount, 0
    mov     fRxError, 0

    call    StartTransmitter

Xceive_Loop:
    cmp     fReceive, 0
    je	    Xceive_Loop

    mov     fReceive, 0

    cmp     fRxError, 0
    jne     Xceive_NAK

    cmp     ReceivePkt, SOH
    jne     Xceive_NAK

    mov     bx, ReceivePkt.Len
    dec     bx

    cmp     ReceivePkt.[bx], EOT
    jne     Xceive_NAK

    xor     ax, ax
    ret

Xceive_NAK:
    cmp     fRxCount, MAXCOUNT
    jg	    Xceive_Error

    inc     fRxCount

    mov     si, OFFSET NAKPkt

    jmp     SHORT  Xceive_Loop

Xceive_Error:

    int     3
    mov     ax, 1
    ret

Xceive	ENDP


;*****************************************************************************
;
;   Receive
;
;*****************************************************************************

PROCEDURE Receive, PUBLIC
	ASSUME	CS:MAIN_CODE, DS:DGROUP

    mov     RxPktLen, -1
    mov     ReceivePktPtr, 0
    mov     fReceive, 0
    mov     fRxCount, 0

Receive_Loop:
    cmp     fReceive, 0
    je	    Receive_Loop

    mov     fReceive, 0

    cmp     fRxError, 0
    jne     Receive_NAK

    xor     ax, ax
    ret

Receive_NAK:

    cmp     fRxCount, MAXCOUNT
    jg	    Receive_Error

    inc     fRxCount

    mov     si, OFFSET NAKPkt

    call    StartTransmitter

    jmp     SHORT  Receive

Receive_Error:

    int     3
    mov     ax, 1
    ret

Receive ENDP



;*****************************************************************************
;		S E R I A L    D R I V E R
;*****************************************************************************


;*****************************************************************************
;
;   Start Transmitter
;
;*****************************************************************************

PROCEDURE StartTransmitter, PUBLIC
	ASSUME	CS:MAIN_CODE, DS:DGROUP

StartTransmitter_Loop:
    cmp     fTransmitting, 1
    je	    StartTransmitter_Loop

    mov     TransmitPkt._sel, ds
    mov     TransmitPkt._off, si
    mov     ax, [si].Len		    ; get packet length
    mov     TransmitPktLen, ax
    mov     TransmitPktPtr, 0

    mov     fTransmitting, 1

    cmp     TransmitPktLen, 0
    je	    StartTransmitter_Ret

    mov     dx, SERIALPORT		    ; COM1 or COM2
    mov     dl, IER			    ; turn on interrupts on 8250
    in	    al, dx
    DELAY

    or	    al, TxInt
    out     dx, al
    DELAY

StartTransmitter_Ret:
    ret

StartTransmitter    ENDP


;*****************************************************************************
;
;   Interrupt Routine
;
;*****************************************************************************

PUBLIC	COMISR, COMISR_LSR, COMISR_Receive, COMISR_Transmit, COMISR_MSR

COMISR:
	push	ax
	push	ds

	mov	ax, SEG DGROUP
	mov	ds, ax

	DISABLE

	call	NewStack

	pusha
	push	es

COMISR_More:
	mov	dx, SERIALPORT
	mov	dl, IIR
	in	al, dx
	test	al, IntPending		    ; is int pending ?
	jnz	COMISR_Ret		    ; no int is pending

	xor	ah, ah
	mov	di, ax
	shr	di, 1
	add	di, di
	jmp	[di].IntRoutines	    ; service int


COMISR_LSR:
	INT3
	mov	fRxError, 1
	mov	dx, SERIALPORT
	mov	dl, LSR
	in	al, dx
	DELAY

	jmp	SHORT COMISR_More

COMISR_Receive:
	mov	dx, SERIALPORT
	in	al, dx
	DELAY

	mov	bx, ReceivePktPtr
	mov	[bx].ReceivePkt, al
	inc	ReceivePktPtr

	cmp	bx, 03
	jne	COMISR_ReceiveNext

	mov	ax, WORD PTR ReceivePkt+2
	dec	ax
	mov	RxPktLen, ax

COMISR_ReceiveNext:
	cmp	bx, RxPktLen
	jne	@f

	mov	fReceive, 1		    ; receive Done !
@@:
	jmp	SHORT COMISR_More


COMISR_Transmit:
	cmp	TransmitPktLen, 0
	jne	COMISR_Send

	mov	dx, SERIALPORT
	mov	dl, IER 			; turn off interrupts on 8250
	in	al, dx
	DELAY

	and	al, NOT TxInt
	out	dx, al
	DELAY

	mov	fTransmitting, 0

	jmp	SHORT COMISR_More

COMISR_Send:
	les	bx, DWORD PTR TransmitPkt
	mov	di, TransmitPktPtr
	mov	al, BYTE PTR es:[bx][di]
	mov	dx, SERIALPORT
	out	dx, al
	DELAY
	inc	TransmitPktPtr
	dec	TransmitPktLen

	jmp	COMISR_More


COMISR_MSR:
	INT3
	mov	fRxError, 1
	mov	dx, SERIALPORT
	mov	dl, MSR
	in	al, dx
	DELAY

	jmp	COMISR_More


COMISR_Ret:
	DELAY

	pop	es
	popa

	call	OldStack

	DISABLE

	mov	al, EOI
	out	PIC, al
	pop	ds
	pop	ax
	iret


;*****************************************************************************
;
;   New Stack
;
;*****************************************************************************

PROCEDURE NewStack, PUBLIC
	ASSUME	CS:MAIN_CODE, DS:DGROUP

	inc	fStackUse
	jnz	NewStack_Ret

	pop	Scratch
	mov	OldSS, ss
	mov	OldSP, sp
	push	ds
	pop	ss
	mov	sp, OFFSET StackTop
	push	Scratch

NewStack_Ret:
	ret

NewStack    ENDP


;*****************************************************************************
;
;   Old Stack
;
;*****************************************************************************

PROCEDURE OldStack, PUBLIC
	ASSUME	CS:MAIN_CODE, DS:DGROUP

	DISABLE
	cmp	fStackUse, 0
	jne	OldStack_Ret

	pop	Scratch
	mov	ss, OldSS
	mov	sp, OldSP
	push	Scratch

OldStack_Ret:
	dec	fStackUse
	ENABLE
	ret

OldStack    ENDP


MAIN_CODE   ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\sim16\siminit.asm ===
include incs.inc

    extrn   LocalInit:FAR

    extrn   __acrtused:abs	 ; pull in windows startup code

MAIN_DATA   SEGMENT
    extrn   RespPkt:BYTE
    extrn   ToWOW32Pkt:BYTE
    extrn   WAKEUPPkt:BYTE
    extrn   ACKPkt:BYTE
    extrn   NAKPkt:BYTE
    extrn   GetMemPkt:BYTE
    extrn   SetMemPkt:BYTE
MAIN_DATA   ENDS


MAIN_CODE   SEGMENT
	    ASSUME CS:MAIN_CODE, DS:MAIN_DATA

    extrn   COMISR:NEAR

;*****************************************************************************
;
;   LibEntry, called when DLL is loaded
;
;*****************************************************************************

	    PUBLIC  LibEntry
LibEntry    PROC    FAR

    int     3

    jcxz    LibEntry_Initialize

    push    ds			; heap segment
    xor     ax, ax		;
    push    ax
    push    cx			; heap size
    call    LocalInit		; initialize heap
    or	    ax, ax
    jz	    LibEntry_Fail

LibEntry_Initialize:
    call    Initialize		; initialize com port and buffers

LibEntry_Fail:
    ret

LibEntry    ENDP


;*****************************************************************************
;
;   Initialize com port and memory
;
;*****************************************************************************

	    PUBLIC  Initialize
Initialize  PROC    NEAR

    call    Init_Com		; initialize com port
    or	    ax, ax
    jz	    Initialize_Fail

    push    ax
    call    Init_Mem		; initialize memory
    pop     ax

    ret

Initialize_Fail:
    int     3
    ret

Initialize  ENDP

;*****************************************************************************
;
;   WEP, called when DLL is unloaded
;
;*****************************************************************************

	PUBLIC	WEP

WEP	PROC	FAR

    nop
    ret

WEP	ENDP

;*****************************************************************************
;
;   Initialization of the Port
;
;*****************************************************************************

Init_Com    PROC    NEAR

    mov     dx, SERIALPORT
    mov     dl, LCR
    mov     al, DLAB			    ; turn on divisor latch
    out     dx, al
    DELAY

    mov     dl, RxBuf
    mov     ax, BaudRate		    ; set baud rate
    out     dx, al
    DELAY

    inc     dx
    mov     al, ah
    out     dx, al
    DELAY

    mov     dl, LCR			    ; set LCR
    mov     al, InitLCR
    out     dx, al
    DELAY

    mov     dl, IER			    ; turn on interrupts on 8250
    mov     al, AllInt
    out     dx, al
    DELAY

    mov     dl, MCR			    ; set MCR
    mov     al, InitMCR
    out     dx, al

Init_ClearRegisters:
    mov     dl, LSR
    in	    al, dx
    mov     dl, RxBuf
    in	    al, dx
    mov     dl, MSR
    in	    al, dx
    mov     dl, IIR
    in	    al, dx
    in	    al, dx
    test    al, 1
    jz	    Init_ClearRegisters

    ;
    ; install interrupt handler
    ;

    cli
    mov     al, 0Ch
    push    ds
    mov     dx, SEG MAIN_CODE
    mov     ds, dx
    mov     dx, OFFSET COMISR
    mov     ah, 25h
    int     21h
    pop     ds

    in	    al, PIC_IntEnable
    and     al, 0E7h
    DELAY

    out     PIC_IntEnable, al
    sti

    mov     al, EOI
    out     PIC, al

    mov     ax, 1			; return sucess !

    ret

Init_Com    ENDP


;*****************************************************************************
;
;   Initialize memory ie, allocate buffers and packets
;
;*****************************************************************************

	    PUBLIC  Init_Mem

Init_Mem    PROC    NEAR

    mov     bx, OFFSET RespPkt
    mov     [bx].Start, SOH		    ; start of header
    mov     [bx].Command, RESP		    ; Resp packet

    mov     bx, OFFSET ToWOW32Pkt	    ; ToWOW32 packet
    mov     [bx].Start, SOH		    ; start of header
    mov     [bx].Command, ToWOW32	    ; ToWOW32 packet
    mov     [bx].Len, 9 		    ; length of entire packet
    mov     BYTE PTR [bx+8], EOT	    ; end of transmission

    mov     bx, OFFSET WAKEUPPkt	    ; WAKEUP packet
    mov     [bx].Start, SOH		    ; start of header
    mov     [bx].Command, WAKEUP	    ; WAKEUP packet
    mov     [bx].Len, 9 		    ; length of entire packet
    mov     BYTE PTR [bx+8], EOT	    ; end of transmission

    mov     bx, OFFSET ACKPkt		    ; ACK packet
    mov     [bx].Start, SOH		    ; start of header
    mov     [bx].Command, ACK		    ; ACK packet
    mov     [bx].Len, 5 		    ; length of entire packet
    mov     BYTE PTR [bx+4], EOT	    ; end of transmission

    mov     bx, OFFSET NAKPkt		    ; NAK packet
    mov     [bx].Start, SOH		    ; start of header
    mov     [bx].Command, NAK		    ; NAK packet
    mov     [bx].Len, 5 		    ; length of entire packet
    mov     BYTE PTR [bx+4], EOT	    ; end of transmission

    mov     bx, OFFSET GetMemPkt	    ; GetMem packet
    mov     [bx].Start, SOH		    ; start of header
    mov     [bx].Command, GETMEM	    ; GETMEN packet
    mov     [bx].Len, 11		    ; length of entire packet
    mov     BYTE PTR [bx+10], EOT	     ; end of transmission

    mov     bx, OFFSET SetMemPkt	    ; SetMem packet
    mov     [bx].Start, SOH		    ; start of header
    mov     [bx].Command, SETMEM	    ; SETMEM packet
    mov     [bx].Len, 11		    ; length of entire packet
    mov     BYTE PTR [bx+10], EOT	     ; end of transmission


    ret

Init_Mem    ENDP


MAIN_CODE   ENDS


    END LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\sim16\sim16.inc ===
;
;
;   Serial driver for COM1 to be used by Sim16 layer.
;
;
CharDev     EQU     8000h
StatusError EQU     8000h
StatusBusy  EQU     0200h
StatusDone  EQU     0100h
ErrorGenF   EQU     12

;
;   PIC Addresses
;

PIC	    EQU     20h
PIC_IntEnable EQU   21h
EOI	    EQU     20h

;
;   UART Port Addresses
;

SERIALPORT  EQU     3F8h	; default serial port to be used, change this
				; to 2F8h if you want to use COM2.

RxBuf	    EQU     0F8h	; base address
Baud1	    EQU     RxBuf+1	; baud divisor high byte
IER	    EQU     RxBuf+1	; int. enable register
IIR	    EQU     RxBuf+2	; int. identification register
LCR	    EQU     RxBuf+3	;
MCR	    EQU     RxBuf+4	;
LSR	    EQU     RxBuf+5	;
MSR	    EQU     RxBuf+6	;

;   UART Interrupt Identification Register Equates

IntPending  EQU     00000001b	; interrupt is pending

;   UART Line Control Register Equates

DLAB	    EQU     10000000b	; divisor latch access bit
SetBrk	    EQU     01000000b	; send break control bit
StkParity   EQU     00100000b	; stick parity control bit
EvenParity  EQU     00010000b	; even parity bit
GenParity   EQU     00001000b	; generate parity bit
XStopBit    EQU     00000100b	; extra stop bit
WordLen8    EQU     00000011b	; word len = 8
WordLen7    EQU     00000010b	; word len = 7
WordLen6    EQU     00000001b	; word len = 6

;   UART Line Status Register Equates

TransShReg  EQU     01000000b	; tranmit shift register empty
TransHReg   EQU     00100000b	; transmit holding register empty
BrkRcv	    EQU     00010000b	; break received
FrameErr    EQU     00001000b	; framing error
ParityErr   EQU     00000100b	; parity error
OverRunErr  EQU     00000010b	; overrun error
RcvData     EQU     00000001b	; received data ready

RcvError    EQU     BrkRcv+FrameErr+ParityErr+OverRunErr

;   UART Modem Control Register Equates

OUT1	    EQU     00000100b	;
OUT2	    EQU     00001000b	; allow 8250 ints in
SetRTS	    EQU     00000010b	; set RTS
SetDTR	    EQU     00000001b	; set DTR


;   UART Modem Status Register Equates

CD	    EQU     10000000b	; carrier detect
RI	    EQU     01000000b	; ring indicator
DSR	    EQU     00100000b	; data set ready
CTS	    EQU     00010000b	; CTS
CDC	    EQU     00001000b	; carrier dectect change
RIC	    EQU     00000100b	; ring indicator change
DSRC	    EQU     00000010b	; DSR change
CTSC	    EQU     00000001b	; CTS change

;   UART Interrupt Enable Register Equates

RxInt	    EQU     00000001b	; receive interrupt
TxInt	    EQU     00000010b	; transmit interrupt
LSInt	    EQU     00000100b	; line status interrupt
MSInt	    EQU     00001000b	; modem status interrupt
AllInt	    EQU     RxInt+LSInt+MSInt

CR	    EQU     0dh
LF	    EQU     0ah
EOM	    EQU     '$'


INT21	    =	21h
DISPLAY_FUNCTION    =	9h
DOS_OPEN    =	3Dh
DOS_CLOSE   =	3Eh
DOS_DONE    =	0100h
DOS_SUCCESS =	0h
DOS_ERROR   =	8000h
DOS_GENFAIL =	0Ch
EXPR_TYPE_SEG		equ	0001b	    ; address type segment:offset
OPEN_FLAG   = 40h

InitLCR     EQU      03h		    ; initial LCR settings
InitMCR     EQU      OUT2+SetRTS+SetDTR     ; initial MCR settings
BaudRate    EQU     12			    ; set it to 9600 BPS

SOH	    EQU     1			   ; start of header
EOT	    EQU     4			   ; end of transmission
ToWOW32     EQU     1
GETMEM	    EQU     2
SETMEM	    EQU     3
WAKEUP	    EQU     4
RESP	    EQU     5
ACK	    EQU     6
NAK	    EQU     7
PSZ	    EQU     8

MAXCOUNT    EQU     10

Packet1 STRUC
    Start   DB	    ?
    Command DB	    ?
    Len     DW	    ?
    ToWOW32_OFF DW  ?
    ToWOW32_SEL DW  ?
Packet1 ENDS

Packet2 STRUC
	    DD	    ?
    MEM_OFF DW	    ?
    MEM_SEL DW	    ?
    MEM_LENGTH DW   ?
    DataM   DB	    ?
Packet2 ENDS

junk1	STRUC
    _off    DW	?
    _sel    DW	?
junk1	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\sim32\sim32.c ===
#include <nt.h>
#include <ntddtx.h>
#include <malloc.h>

#include "sim32.h"

UCHAR		TransmitPkt[MAXSIZE];
UCHAR		ReceivePkt[MAXSIZE];

HANDLE		DeviceHandle;
IO_STATUS_BLOCK IoStatusBlock;
NTSTATUS	Status;


/*****************************************************************************
*
*	Sim32GetVDMMemory
*
*	This routine gets 'Size' bytes from WOW VDM starting at address
*	specified by 'Address'. These bytes are returned to the caller in
*	the Buffer (which is owned by the caller).
*
*****************************************************************************/


USHORT Sim32GetVDMMemory (IN ULONG Address,
		       IN USHORT  Size,
		       IN OUT PVOID Buffer)

{
    if (Size < MAXSIZE-11) {
	TransmitPkt[0] = SOH;
	TransmitPkt[1] = GETMEM;
	TransmitPkt[2] = 11;
	TransmitPkt[3] = 0;
	TransmitPkt[4] = (UCHAR) FIRSTBYTE(Address);
	TransmitPkt[5] = (UCHAR) SECONDBYTE(Address);
	TransmitPkt[6] = (UCHAR) THIRDBYTE(Address);
	TransmitPkt[7] = (UCHAR) FOURTHBYTE(Address);
	TransmitPkt[8] = (UCHAR) FIRSTBYTE(Size);
	TransmitPkt[9] = (UCHAR) SECONDBYTE(Size);
	TransmitPkt[10] = EOT;

	if (!Xceive((USHORT)(Size+5), 11)) {
	    DbgPrint ("Sim32GetVDMMemory.....BAD Memory \a\n");
	    return (BAD);
	}

	RtlMoveMemory(Buffer, &ReceivePkt[4], Size);

	return(GOOD);

    }
    else {
	DbgPrint ("Bad Packet Size %d\n", Size);
	return (BADSIZE);
    }
}


/*****************************************************************************
*
*	Sim32SetVDMMemory
*
*	This routine sets 'Size' bytes in WOW VDM starting at address
*	specified by 'Address' to the values in Buffer.
*
*****************************************************************************/


USHORT Sim32SetVDMMemory (IN ULONG Address,
		       IN USHORT  Size,
		       IN OUT PVOID Buffer)
{
    if (Size < MAXSIZE-11) {
	TransmitPkt[0] = SOH;
	TransmitPkt[1] = SETMEM;
	TransmitPkt[2] = (UCHAR) (Size+11);
	TransmitPkt[3] = 0;
	TransmitPkt[4] = (UCHAR) FIRSTBYTE(Address);
	TransmitPkt[5] = (UCHAR) SECONDBYTE(Address);
	TransmitPkt[6] = (UCHAR) THIRDBYTE(Address);
	TransmitPkt[7] = (UCHAR) FOURTHBYTE(Address);
	TransmitPkt[8] = (UCHAR) FIRSTBYTE(Size);
	TransmitPkt[9] = (UCHAR) SECONDBYTE(Size);
	TransmitPkt[10+Size] = EOT;

	RtlMoveMemory(&TransmitPkt[10], Buffer, Size);

	if (!Xceive(7, (USHORT)(Size+11))) {
	    DbgPrint ("Sim32SetVDMMemory... could not set : \a\n");
	    return (BAD);
	}

	return(GOOD);

    }
    else  {
	DbgPrint ("Bad Packet Size %d\n", Size);
	return (BADSIZE);
    }
}



/*****************************************************************************
*
*	Sim32GetVDMPSZPointer
*
*	This routine returns a pointer to a null terminated string in the WOW
*	VDM at the specified address.
*
*	This routine does the following,
*	    allocates a sufficient size buffer,
*	    gets the string from SIM16,
*	    copies the string into buffer,
*	    returns a pointer to the buffer.
*
*****************************************************************************/


PSZ  Sim32GetVDMPSZPointer (IN ULONG Address)
{
    USHORT  Size;
    PSZ     Ptr;


    TransmitPkt[0] = SOH;
    TransmitPkt[1] = PSZLEN;
    TransmitPkt[2] = 9;
    TransmitPkt[3] = 0;
    TransmitPkt[4] = (UCHAR) FIRSTBYTE(Address);
    TransmitPkt[5] = (UCHAR) SECONDBYTE(Address);
    TransmitPkt[6] = (UCHAR) THIRDBYTE(Address);
    TransmitPkt[7] = (UCHAR) FOURTHBYTE(Address);
    TransmitPkt[8] = EOT;

    if (!Xceive(7, 9)) {
	DbgPrint ("Sim32GetVDMPSZPointer.....Attempt to get PSZ length failed \a\a\n");
	return NULL;
    }

    Size = *(PUSHORT)(ReceivePkt+4);


    //
    //	allocate buffer to copy string into
    //

    Ptr = (PSZ) malloc(Size);

    if (!Ptr) {
	DbgPrint ("Sim32GetVDMPSZPointer...,  malloc failed \a\a\n");
    }


    //
    // get null terminated string
    //

    if (Size < MAXSIZE-11) {
	TransmitPkt[1] = GETMEM;
	TransmitPkt[2] = 11;
	TransmitPkt[3] = 0;
	TransmitPkt[8] = (UCHAR) FIRSTBYTE(Size);
	TransmitPkt[9] = (UCHAR) SECONDBYTE(Size);
	TransmitPkt[10] = EOT;

	if (!Xceive((USHORT)(Size+5), 11)) {
	    DbgPrint ("Sim32GetVDMPSZPointer.....Unsuccessful \a\a\n");
	    return NULL;
	}

	RtlMoveMemory(Ptr, &ReceivePkt[4], Size);
    } else {
	DbgPrint ("Sim32GetVDMPSZPointer.....Size of the string too big Size = %d\a\a\n", Size);
	return NULL;
    }

    return Ptr;

}



/*****************************************************************************
*
*	Sim32FreeVDMPointer
*
*	This routine frees the buffer which was allocated earlier.
*
*****************************************************************************/


VOID Sim32FreeVDMPointer (PVOID Ptr)
{
    free (Ptr);
}



/*****************************************************************************
*
*	Sim32SendSim16
*
*	This routine specifies the stack of the WOW VDM task and asks the
*	WOW 16 to make that task run.
*
*****************************************************************************/


USHORT Sim32SendSim16 (IN OUT ULONG *WOWStack)
{
    static  USHORT fInit = 0;

    if (fInit) {
	TransmitPkt[0] = SOH;
	TransmitPkt[1] = WAKEUP;
	TransmitPkt[2] = 9;
	TransmitPkt[3] = 0;
	TransmitPkt[4] = (UCHAR) FIRSTBYTE(*WOWStack);
	TransmitPkt[5] = (UCHAR) SECONDBYTE(*WOWStack);
	TransmitPkt[6] = (UCHAR) THIRDBYTE(*WOWStack);
	TransmitPkt[7] = (UCHAR) FOURTHBYTE(*WOWStack);
	TransmitPkt[8] = EOT;

	if (!Xceive(9, 9)) {
	    return (BAD);
	}

	*WOWStack = *(PULONG)(ReceivePkt+4);

	return(GOOD);
    }
    else {
	Initialize(9);
	*WOWStack = *(PULONG)(ReceivePkt+4);
	fInit = 1;
	return (GOOD);
    }
}


/*****************************************************************************
*
*	Xceive
*
*	This routine transmits a packet and waits for the data from the remote
*	side to come. When this routine returns, the ReceivePkt has the data
*	sent by the remote machine.
*
*****************************************************************************/


USHORT Xceive(IN USHORT Length_In, IN USHORT Length_Out)
{
    BOOLEAN Done = FALSE;
    USHORT     i = 0;

    while ((i < MAXTRY) && (!Done)) {

	Status = NtDeviceIoControlFile(
		DeviceHandle,
		NULL,
		NULL,
		NULL,
		&IoStatusBlock,
		IOCTL_TRNXT_XCEIVE,
		TransmitPkt,
		(ULONG) Length_Out,
		ReceivePkt,
		(ULONG) Length_In
		);

	//
	// check error condition
	// if no error, then
	//

	if (ReceivePkt[0] == SOH) {
	    if (ReceivePkt[1] != NAK) {
		i = *(PUSHORT)(ReceivePkt+2);
		if (ReceivePkt[(--i)] == EOT) {
		    Done = TRUE;
		}
		else {
		    DbgPrint ("EOT is missing from the packet, *ERROR*, Do Not Proceed Further !\a\a\n");
		}
	    }
	    else {
		DbgPrint ("It is a NAK packet, *ERROR*, Do Not Proceed Further !\a\a\n");
	    }
	}
	else {
	    DbgPrint ("SOH is missing from the packet, *ERROR*, Do Not Proceed Further !\a\a\n");
	}

	if (!Done) {
	    i++;
	    DbgPrint ("\nSTOP STOP STOP !!!\a\a\a\a\a\n");
	}
    }

    if (Done) {
	return (GOOD);
    }
    else {
	return (BAD);
    }

}

void Initialize (IN USHORT Length_In)
{
    OBJECT_ATTRIBUTES	ObjectAttributes;

    STRING		DeviceName;
    USHORT		j;
    char		TestPkt[] = "WOW 32 Simulator on NT\n\r";

    RtlInitString(&DeviceName, "\\Device\\Serial1");

    //
    // set attributes
    //

    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = &DeviceName;
    ObjectAttributes.Attributes = OBJ_INHERIT;
    ObjectAttributes.SecuriAR) SECONDBYTE(Size);
	TransmitPkt[10] = EOT;

	if (!Xceive((USHORT)(Size+5), 11)) {
	    DbgPrint ("Sim32GetVDMPSZPointer.....Unsuccessful \a\a\n");
	    return NULL;
	}

	RtlMoveMemory(Ptr, &ReceivePkt[4], Size);
    } else {
	DbgPrint ("Sim32GetVDMPSZPointer.....Size of the string too big Size = %d\a\a\n", Size);
	return NULL;
    }

    return Ptr;

}



/*****************************************************************************
*
*	Sim32FreeVDMPointer
*
*	This routine frees the buffer which was allocated earlier.
*
*****************************************************************************/


VOID Sim32FreeVDMPointer (PVOID Ptr)
{
    free (Ptr);
}



/******************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\build_id.c ===
/*[
 * 	=======================================================================
 *
 *      Name:           build_id.c 
 *
 *      Derived from:   (original)
 *
 *      Author:         John Box
 *
 *      Created on:     May 26th 1994
 *
 *      SccsID:         @(#)build_id.c	1.2 07/18/94  
 *
 *	Coding Stds:	2.2
 *
 *      Purpose:        This file contains  the routine required for returning
 *                      Build ID Nos. 
 *
 *
 *      (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
 * 	=======================================================================
]*/
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include CpuH
#include "sas.h"

#include "build_id.h"
enum
{
	BASE_MODULE = 1
};
/*
 * The following module names must be terminated by a '$'. The Dos print utility
 * recognises this as end of string. The length should include the '$'.
 */
LOCAL	char base_name[] = {"Base$"};
#define base_name_len	5
/*(
=======================================Get_build_id ============================
PURPOSE:
	Returns a modules' Build IDs 

INPUT:
	Module No. passed in AL.

OUTPUT:
	Module name written to DS:CX
	The BUILD ID is returned in BX in the form YMMDD
		(See build_id.h for details)
	Next Module No. returned in AH. ( 0 if AL is the last one ).
	0 returned in AL to indicate no errors.
	(Note: A SoftPC that doesn't support this Bop will leave AL set to the
	INPUT module Number, thus indicating an error in the call ).
================================================================================
)*/
GLOBAL void Get_build_id IFN0( )

{

/*
 *	The name of the module needs to be written to Intel space at DS:CX
 */

	switch( getAL() )
	{
		case BASE_MODULE:
			write_intel_byte_string( getDS(), getCX(), (host_addr)base_name, base_name_len );
			setBX( BUILD_ID_CODE );
			setAX( 0 );
			break;
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\sim32\sim32.h ===
/* SIM v1.0
 *
 * SIM32.H
 * SIM32 constants and prototypes
 *
 * History
 * Created 05-Feb-91 by Chandan Chauhan and Jeff Parsons
 */


/* Public function prototypes
 *
 * These functions are true pascal functions in the 16-bit case,
 * but conform to the default convention (cdecl) for the 32-bit case.
 */
#ifndef FAR
#define FAR
#endif
#ifndef PASCAL
#define PASCAL
#endif

USHORT FAR PASCAL Sim32SendSim16(PULONG);
USHORT FAR PASCAL Sim32GetVDMMemory(ULONG, USHORT, PVOID);
USHORT FAR PASCAL Sim32SetVDMMemory(ULONG, USHORT, PVOID);
PSZ    FAR PASCAL Sim32GetVDMPSZPointer(ULONG);
VOID   FAR PASCAL Sim32FreeVDMPointer(PVOID);

/* Private function prototypes
 */
VOID   Initialize();
USHORT Xceive(IN USHORT, IN USHORT);


/* Simulator replacement macros
 */
#define SENDVDM(pvp)		WOW32Receive()
#define RECEIVEVDM(pvp) 	Sim32SendSim16(pvp)

#ifdef	ALLOCA
#define GETPTR(vp,cb,p) 	((p=alloca(cb))?Sim32GetVDMMemory(vp, (USHORT)(cb), p):FALSE)
#define GETARGPTR(vp,cb,p)	if (p=alloca(cb)) { Sim32GetVDMMemory(vp+OFFSETOF(VDMFRAME,bArgs), (USHORT)(cb), p)
#ifdef	WIN_16
#define EQNULL
#define GETPSZPTR(vp,pcb,p)	if (vp) if (p=alloca(*pcb=128)) Sim32GetVDMMemory(vp, (USHORT)*pcb, p); else goto Error
#define FREEPSZPTR(p)
#else
#define EQNULL	= NULL
#define GETPSZPTR(vp,pcb,p)	if (vp) if (!(p=Sim32GetVDMPSZPointer(vp))) goto Error
#define FREEPSZPTR(p)		if (p) Sim32FreeVDMPointer(p)
#endif
#define FLUSHPTR(vp,cb,p)	Sim32SetVDMMemory(vp, (USHORT)(cb), p)
#define FREEPTR(p)
#define FREEARGPTR(p)		;}
#else
#define EQNULL	= NULL
#define GETPTR(vp,cb,p) 	((p=malloc(cb))?Sim32GetVDMMemory(vp, (USHORT)(cb), p):FALSE)
#define GETARGPTR(vp,cb,p)	if (p=malloc(cb)) { Sim32GetVDMMemory(vp+OFFSETOF(VDMFRAME,bArgs), (USHORT)(cb), p)
#ifdef	WIN_16
#define GETPSZPTR(vp,pcb,p)	if (vp) if (p=malloc(*pcb=128)) Sim32GetVDMMemory(vp, (USHORT)*pcb, p); else goto Error
#define FREEPSZPTR(p)		if (p) free(p)
#else
#define GETPSZPTR(vp,pcb,p)	if (vp) if (!(p=Sim32GetVDMPSZPointer(vp))) goto Error
#define FREEPSZPTR(p)		if (p) Sim32FreeVDMPointer(p)
#endif
#define FLUSHPTR(vp,cb,p)	Sim32SetVDMMemory(vp, (USHORT)(cb), p)
#ifndef DEBUG
#define FREEPTR(p)		free(p)
#define FREEARGPTR(p)		free(p);}
#else
#define FREEPTR(p)		free(p); p=NULL
#define FREEARGPTR(p)		free(p); p=NULL;}
#endif
#endif

#define GETOPTPTR(vp,cb,p)	if (vp) if (p=malloc(cb)) Sim32GetVDMMemory(vp, (USHORT)(cb), p); else goto Error
#define GETVDMPTR(vp,cb,p)	if (p=malloc(cb)) Sim32GetVDMMemory(vp, (USHORT)(cb), p); else goto Error
#define ALLOCVDMPTR(vp,cb,p)	if (!(p=malloc(cb))) goto Error
#define FLUSHVDMPTR(vp,cb,p)	Sim32SetVDMMemory(vp, (USHORT)(cb), p)
#ifndef DEBUG
#define FREEVDMPTR(p)		if (p) free(p)
#else
#define FREEVDMPTR(p)		if (p) {free(p); p=NULL;}
#endif

#define GETVDMMEMORY(vp,cb,p)	Sim32GetVDMMemory(vp, (USHORT)(cb), p)
#define SETVDMMEMORY(vp,cb,p)	Sim32SetVDMMemory(vp, (USHORT)(cb), p)


#ifdef SIM_32			// BUGBUG -- Use the macros in nt header files
#undef FIRSTBYTE
#undef SECONDBYTE
#undef THIRDBYTE
#undef FOURTHBYTE
#endif

#define FIRSTBYTE(VALUE)  (VALUE & LO_MASK)
#define SECONDBYTE(VALUE) ((VALUE >> 8) & LO_MASK)
#define THIRDBYTE(VALUE)  ((VALUE >> 16) & LO_MASK)
#define FOURTHBYTE(VALUE) ((VALUE >> 24) & LO_MASK)
#define LO_MASK     0x000000FF

#define MAXSIZE     1024	// maximum buffer size
#define MAXTRY	    10		// for Transport


/* Packet Codes
 */
#define SOH	    1	       // start of header ie Pkt
#define EOT	    4	       // end of transmission
#define ToWOW32     1
#define GETMEM	    2
#define SETMEM	    3
#define WAKEUP	    4
#define RESP	    5
#define ACK	    6
#define NAK	    7
#define PSZLEN	    8

#define GOOD	    1
#define BAD	    0
#define BADSIZE     2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\bootstra.c ===
#include "insignia.h"
#include "host_def.h"
#ifdef SECURE
#include "xt.h"
#include "config.h"
#endif
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Bios bootstrap function
 *
 * Description	: This function is called by the BIOS reset function, using
 *		  the bop call, to load the first sector of DOS into memory
 *		  and then jump to this loaded section.
 *
 *		  The bootstrap function uses other parts of the Bios.  Since
 *		  at the time this code is run it is impossible for anyone
 *		  to have patched the interrupt vector table, you would have
 *		  thought we could call the Bios C code directly (using bop()).
 *		  However, this is only true if the C code we are calling does
 *		  not use interrupts itself.  The Bios disk/diskette code does
 *		  of course use interrupts and hence we must call this via a
 *		  software interrupt.  It is therefore split into a number 
 *		  of functions order that the CPU can service the interrupt 
 *		  before procceeding to the next part.
 *
 *		  Software interrupts to the disk_io function are loaded 
 *		  into Intel memory by sas_init(), viz
 *
 *		  BOP bootstrap()
 *		  INT disk_io()
 *		  BOP bootstrap1()
 *		  INT disk_io()
 *		  BOP bootstrap2()
 *		  INT disk_io()
 *		  BOP bootstrap3()
 *
 * Author	: Henry Nash
 *
 * Notes	: The Jump to DOS is actually coded as an 8088 instruction
 *		  in memory following the above BOPs.
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)bootstrap.c	1.9 09/19/94 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif



/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "bios.h"
#include "sas.h"
#include CpuH

#ifdef SECURE
LOCAL IBOOL boot_has_finished = FALSE;
GLOBAL void end_secure_boot IFN0()
{
	boot_has_finished = TRUE;
}
GLOBAL IBOOL has_boot_finished IFN0()
{
	return boot_has_finished;
}
#endif

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

void bootstrap()
{
    /*
     * First reset the disk and diskette. 
     */

#ifdef SECURE
    boot_has_finished = FALSE;
#endif
    setAX(0);			/* reset floppy */
    setDX(0x80);		/* drive 0 */
}

void bootstrap1()
{
    /*
     * Try and read the first sector off the diskette
     */

    setAH(2);			/* read */
    setAL(1);			/* 1 block */
#ifdef SECURE
    if ((IBOOL) config_inquire(C_SECURE, NULL))
    {
	setDH(0);		/* Head 0 */
	setDL(0x80);		/* on Hard Disk */
    }
    else
    {
        setDX(0);		/* head 0 on drive 0 (floppy)*/
    }
#else
    setDX(0);			/* head 0 on drive 0 (floppy)*/
#endif
    setCX(1);			/* track 0, sector 1 */
    setES(DOS_SEGMENT);		/* Load address */
    setBX(DOS_OFFSET);	
}


void bootstrap2()
{
    /*
     * If the Carry Flag is set then the previous read failed and we go and
     * try the hard disk.
     */

    if (getCF())
    {
	/*
	 * Load up the registers to call the disk routine that will load
	 * the first sector of DOS into memory.  This ALWAYS resides on the
	 * first sector of the disk.
	 */

	setAH(2);				/* Read sector	*/
	setAL(1);				/* 1 block	*/
	setCH(0);				/* Cylinder 0   */
	setCL(1);				/* Sector 1	*/
	setDH(0);				/* Head 0	*/
	setDL(0x80);				/* Hard disk	*/
	setES(DOS_SEGMENT);			/* Load address */
	setBX(DOS_OFFSET);	
    }
}

void bootstrap3()
{
    char *p;
    char error_str[80];

    if (getCF())
    {
  	/*
         * Write error on PC screen - assumes reset has positioned the
	 * cursor for us.  Note that we can call the video using a BOP since
	 * the video code does not itself use interrupts.
	 */

	sprintf(error_str,"DOS boot error - cannot open hard disk file");
	p = error_str;
	while (*p != '\0')
	{
	    setAH(14);
	    setAL(*p++);
	    bop(BIOS_VIDEO_IO);
	}
    }

    /*
     * enable hardware interrupts before we jump to DOS
     */

    setIF(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\bios.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * VPC-XT Revision 1.0
 *
 * Title	: bios
 *
 * Description	: Vector of BOP calls which map to appropriate BIOS functions
 *
 * Author	: Rod MacGregor
 *
 * Notes	: hard disk int (0D) and command_check (B0) added DAR
 *
 * Mods: (r2.14): Replaced the entry against BOP 18 (not_supported())
 *                with the dummy routine rom_basic().
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)bios.c	1.64 06/28/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "BIOS_SUPPORT.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "bios.h"
#include CpuH
#include "host.h"
#include "cntlbop.h"

#include "host_hfx.h"
#include "hfx.h"
#include "virtual.h"
#include "gispsvga.h"
#ifdef SWIN_HFX
#include "winfiles.h"
#endif


#ifdef RDCHK
extern void get_lar IPT0();
#endif /* RDCHK */

#ifdef CPU_40_STYLE
#define SWAP_INSTANCE virtual_swap_instance()
#else
#define SWAP_INSTANCE
#endif

/*
   Traps for BOP's requiring virtualisation.
 */
#ifdef SWIN_HFX
LOCAL void v_SwinRedirector	IFN0() { SWAP_INSTANCE; SwinRedirector(); }
#endif
LOCAL void v_mouse_install1	IFN0() { SWAP_INSTANCE; mouse_install1(); }
LOCAL void v_mouse_install2	IFN0() { SWAP_INSTANCE; mouse_install2(); }
LOCAL void v_mouse_io_interrupt	IFN0() { SWAP_INSTANCE; mouse_io_interrupt(); }
LOCAL void v_mouse_io_language  IFN0() { SWAP_INSTANCE; mouse_io_language(); }
LOCAL void v_mouse_video_io	IFN0() { SWAP_INSTANCE; mouse_video_io(); }
LOCAL void v_mouse_int1		IFN0() { SWAP_INSTANCE; mouse_int1(); }
LOCAL void v_mouse_int2		IFN0() { SWAP_INSTANCE; mouse_int2(); }
#if defined(XWINDOW) || defined(NTVDM)
LOCAL void v_host_mouse_install1 IFN0() {SWAP_INSTANCE; host_mouse_install1(); }
LOCAL void v_host_mouse_install2 IFN0() {SWAP_INSTANCE; host_mouse_install2(); }
#endif /* XWINDOW || NTVDM */
#ifdef HFX
LOCAL void v_test_for_us	IFN0() { SWAP_INSTANCE; test_for_us(); }
LOCAL void v_redirector		IFN0() { SWAP_INSTANCE; redirector(); }
#endif	/* HFX */
LOCAL void v_mouse_EM_callback	IFN0() { SWAP_INSTANCE; mouse_EM_callback(); }

#ifdef PROFILE
extern void dump_profile IPT0();
extern void reset_profile IPT0();
#endif

#ifdef SIGNAL_PROFILING
extern void Start_sigprof IPT0();
extern void Stop_sigprof IPT0();
extern void Dump_sigprof IPT0();
#endif

#if !defined(PROD) && defined(CPU_40_STYLE)
extern void FmDebugBop IPT0();
#endif

#if defined(CPU_40_STYLE) && !defined(NTVDM)
extern void VDD_Func IPT0();
#endif

#ifndef PROD
extern void trace_msg_bop IPT0();
extern void dvr_bop_trace IPT0();
#endif

#ifdef NTVDM
void rtc_int(void);
#endif

#ifndef MAC_LIKE

void (*BIOS[])() = {
			reset,	 	/* BOP 00 */
			dummy_int,   	/* BOP 01 */
			unexpected_int,	/* BOP 02 */
#ifdef DOS_APP_LIC
			DOS_AppLicense, /* BOP 03 */
#else
			illegal_bop,   	/* BOP 03 */
#endif	/* DOS_APP_LIC */
#ifdef WDCTRL_BOP
			wdctrl_bop,   	/* BOP 04 */
#else   /* WDCTRL_BOP */
			illegal_bop,	/* BOP 04 */
#endif	/* WDCTRL_BOP */
#if !defined(PROD) && defined(CPU_40_STYLE)
			FmDebugBop,	/* BOP 05 */
#else
			illegal_bop,	/* BOP 05 */
#endif	/* !PROD && CPU_40_STYLE */
#if defined(NEC_98)
                        illegal_bop,    /* BOP 06 */
                        illegal_bop,    /* BOP 07 */
                        time_int,       /* BOP 08 */
                        keyboard_int,   /* BOP 09 */
                        illegal_bop,    /* BOP 0A */
                        illegal_bop,    /* BOP 0B */
                        illegal_bop,    /* BOP 0C */
                        illegal_bop,    /* BOP 0D */
                        illegal_bop,    /* BOP 0E */
                        illegal_bop,    /* BOP 0F */
                        illegal_bop,    /* BOP 10 */
                        illegal_bop,    /* BOP 11 */
                        illegal_bop,    /* BOP 12 */
                        illegal_bop,    /* BOP 13 */
                        illegal_bop,    /* BOP 14 */
                        illegal_bop,    /* BOP 15 */
                        int_287,        /* BOP 16 */
                        illegal_bop,    /* BOP 17 */
                        video_io,       /* BOP 18 */
                        illegal_bop,    /* BOP 19 */
                        illegal_bop,    /* BOP 1A */
                        disk_io,        /* BOP 1B */
                        time_of_day,    /* BOP 1C */
#else  // !NEC_98
			illegal_op_int,	/* BOP 06 */
			illegal_dvr_bop,/* BOP 07 */
#if defined(NTVDM) || defined(CPU_40_STYLE)
			illegal_bop,   	/* BOP 08 */
#else /* !(NTVDM || CPU_40_STYLE) */
			time_int,   	/* BOP 08 */
#endif /* !(NTVDM || CPU_40_STYLE) */
			keyboard_int,  	/* BOP 09 */
			illegal_bop,   	/* BOP 0A */
			illegal_bop,   	/* BOP 0B */
			illegal_bop,   	/* BOP 0C */
			/* disk interrupts on vector 76 .. no BOP required though!
			 * diskbios() uses re-entrant CPU to get disk interrupt
			 * and the disk ISR is pure Intel assembler (with no BOPs)
		 	 */
			illegal_bop,   	/* BOP 0D */
			diskette_int,  	/* BOP 0E */
			illegal_bop,   	/* BOP 0F */
			video_io,	/* BOP 10 */
			equipment, 	/* BOP 11 */
			memory_size, 	/* BOP 12 */
			disk_io, 	/* BOP 13 */
			rs232_io,       /* BOP 14 */
			cassette_io,    /* BOP 15 */
			keyboard_io,	/* BOP 16 */
			printer_io,	/* BOP 17 */
			rom_basic,	/* BOP 18 */
#ifdef NTVDM
/* NT port, kill vdm instance, instead of warmbooting */
			terminate,
#else
			bootstrap,	/* BOP 19 */
#endif
			time_of_day,	/* BOP 1A */
			illegal_bop,	/* BOP 1B */
			illegal_bop,	/* BOP 1C */
#endif // !NEC_98
			kb_idle_poll,	/* BOP 1D */
			illegal_bop,	/* BOP 1E */
			illegal_bop,	/* BOP 1F */
#if  defined(RDCHK) && !defined(PROD)
			get_lar,        /* BOP 20, used to debug read checks */
#else
			illegal_bop,	/* BOP 20 */
#endif
			Get_build_id,	/* BOP 21 */
#ifdef WIN_VTD
			VtdTickSync,	/* BOP 22 */
#else
			illegal_bop,	/* BOP 22 */
#endif /* WIN_VTD */
			illegal_bop,	/* BOP 23 */
			illegal_bop,	/* BOP 24 */
#if defined(CPU_40_STYLE) && !defined(NTVDM)
			VDD_Func,	/* BOP 25 */
#else
			illegal_bop,	/* BOP 25 */
#endif /* CPU_40_STYLE */
			illegal_bop,	/* BOP 26 */
			illegal_bop,	/* BOP 27 */
			illegal_bop,	/* BOP 28 */
			illegal_bop,	/* BOP 29 */
			illegal_bop,	/* BOP 2A */
#ifndef NTVDM
                        cmd_install,    /* BOP 2B */
                        cmd_load,       /* BOP 2C */
#else /* NTVDM */
                        illegal_bop,    /* BOP 2B */
                        illegal_bop,    /* BOP 2C */
#endif /* NTVDM */
			illegal_bop,	/* BOP 2D */
#ifdef HFX
			v_test_for_us,	/* BOP 2E */ /* test_for_us */
			v_redirector,	/* BOP 2F */ /* redirector */
#else
			illegal_bop,	/* BOP 2E */
			illegal_bop,	/* BOP 2F */
#endif
#ifdef DPMI
			DPMI_2F,	/* BOP 30 */
			DPMI_31,	/* BOP 31 */
			DPMI_general,	/* BOP 32 */
			DPMI_int,	/* BOP 33 */
#else
			illegal_bop,	/* BOP 30 */
			illegal_bop,	/* BOP 31 */
			illegal_bop,	/* BOP 32 */
			illegal_bop,	/* BOP 33 */
#endif /* DPMI */
#ifdef NOVELL
			DriverInitialize,		/* BOP 34 */
			DriverReadPacket,		/* BOP 35 */
			DriverSendPacket,		/* BOP 36 */
			DriverMulticastChange,		/* BOP 37 */
			DriverReset,			/* BOP 38 */
			DriverShutdown,			/* BOP 39 */
			DriverAddProtocol,		/* BOP 3A */
			DriverChangePromiscuous, 	/* BOP 3B */
			DriverOpenSocket, 		/* BOP 3C */
			DriverCloseSocket,	 	/* BOP 3D */
#ifdef NOVELL_CFM
			DriverCheckForMore,		/* BOP 3E */
#else
			illegal_bop,	 /* Spare	   BOP 3E */
#endif
#ifdef V4CLIENT
			DriverChangeIntStatus,	/* BOP 3F */
#else
			illegal_bop,	 		/* Spare  BOP 3F */
#endif	/* V4CLIENT */
#else	/* NOVELL */
			illegal_bop,	/* BOP 34 */
			illegal_bop,	/* BOP 35 */
			illegal_bop,	/* BOP 36 */
			illegal_bop,	/* BOP 37 */
			illegal_bop,	/* BOP 38 */
			illegal_bop,	/* BOP 39 */
			illegal_bop,	/* BOP 3A */
			illegal_bop,	/* BOP 3B */
			illegal_bop,	/* BOP 3C */
			illegal_bop,	/* BOP 3D */
			illegal_bop,	/* BOP 3E */
			illegal_bop,	/* BOP 3F */
#endif	/* NOVELL */
#if defined(NEC_98)
                        illegal_bop,    /* BOP 40 */
#else  // !NEC_98
			diskette_io,	/* BOP 40 */
#endif // !NEC_98
			illegal_bop,	/* BOP 41 */
#ifdef EGG
			ega_video_io,	/* BOP 42 */
#else
			illegal_bop,	/* BOP 42 */
#endif
#if defined(NEC_98)
                        illegal_bop,    /* BOP 43 */
#else  // !NEC_98
#ifdef JAPAN
                        MS_DosV_bop,    /* BOP 43 - for MS-DOS/V */
#elif defined(KOREA) // !JAPAN
/* The basic function of Korean Hangul DOS BOP is similary with Japanese DOS/V.
   But, We just change the name.
*/
                        MS_HDos_bop,    /* BOP 43 - for MS-HDOS */
#else // !KOREA
			illegal_bop,	/* BOP 43 */
#endif // !KOREA
#endif // !NEC_98
			illegal_bop,	/* BOP 44 */
			illegal_bop,	/* BOP 45 */
			illegal_bop,	/* BOP 46 */
			illegal_bop,	/* BOP 47 */
			illegal_bop,	/* BOP 48 */
#ifdef DPMI
			DPMI_r0_int,	/* BOP 49 */
			DPMI_exc,	/* BOP 4A */
			DPMI_4B,	/* BOP 4B */
#else
			illegal_bop,	/* BOP 49 */
			illegal_bop,	/* BOP 4A */
			illegal_bop,	/* BOP 4B */
#endif /* DPMI */
			illegal_bop,	/* BOP 4C */
			illegal_bop,	/* BOP 4D */
			illegal_bop,	/* BOP 4E */
			illegal_bop,	/* BOP 4F */
#ifdef NTVDM
/*
   Note that this precludes SMEG and NT existing together which seems
   reasonable given the Unix & X dependencies of SMEG
*/
			MS_bop_0,	/* BOP 50 - MS reserved */
			MS_bop_1,	/* BOP 51 - MS reserved */
			MS_bop_2,	/* BOP 52 - MS reserved */
			MS_bop_3,	/* BOP 53 - MS reserved */
			MS_bop_4,	/* BOP 54 - MS reserved */
			MS_bop_5,	/* BOP 55 - MS reserved */
			MS_bop_6,	/* BOP 56 - MS reserved */
			MS_bop_7,	/* BOP 57 - MS reserved */
			MS_bop_8,	/* BOP 58 - MS reserved */
			MS_bop_9,	/* BOP 59 - MS reserved */
			MS_bop_A,	/* BOP 5A - MS reserved */
			MS_bop_B,	/* BOP 5B - MS reserved */
			MS_bop_C,	/* BOP 5C - MS reserved */
			MS_bop_D,	/* BOP 5D - MS reserved */
			MS_bop_E,	/* BOP 5E - MS reserved */
			MS_bop_F,	/* BOP 5F - MS reserved */
#else
#ifdef SMEG
			smeg_collect_data,/* BOP 50 */
			smeg_freeze_data,	/* BOP 51 */
#else
			illegal_bop,	/* BOP 50 */
			illegal_bop,	/* BOP 51 */
#endif /* SMEG */
#if defined(IRET_HOOKS) && defined(GISP_CPU)
			Cpu_hook_bop,	/* BOP 52 */
#else
			illegal_bop,	/* BOP 52 */
#endif /* IRET_HOOKS  && GISP_CPU */
#ifdef GISP_SVGA
			romMessageAddress,	/* BOP 53 */
#else
			illegal_bop,	/* BOP 53 */
#endif
			illegal_bop,	/* BOP 54 */
			illegal_bop,	/* BOP 55 */
			illegal_bop,	/* BOP 56 */
			illegal_bop,	/* BOP 57 */
			illegal_bop,	/* BOP 58 */
			illegal_bop,	/* BOP 59 */
			illegal_bop,	/* BOP 5A */
			illegal_bop,	/* BOP 5B */
			illegal_bop,	/* BOP 5C */
			illegal_bop,	/* BOP 5D */
			illegal_bop,	/* BOP 5E */
			illegal_bop,	/* BOP 5F */
#endif /* NTVDM */
			softpc_version,	/* BOP 60 */
			illegal_bop,	/* BOP 61 */
			illegal_bop,	/* BOP 62 */
#ifdef PTY
			com_bop_pty,	/* BOP 63 */
#else
			illegal_bop,	/* BOP 63 */
#endif
			illegal_bop,	/* BOP 64 */
#ifdef PC_CONFIG
			pc_config,	/* BOP 65 */
#else
			illegal_bop,	/* BOP 65 */
#endif
#ifdef LIM
			emm_init,	/* BOP 66 */
			emm_io,		/* BOP 67 */
			return_from_call, /* BOP 68 */
#else			
			illegal_bop,	/* BOP 66 */
			illegal_bop,	/* BOP 67 */
			illegal_bop,	/* BOP 68 */
#endif			
#ifdef SUSPEND
			suspend_softpc,	/* BOP 69 */
			terminate,	/* BOP 6A */
#else
			illegal_bop,	/* BOP 69 */
			illegal_bop,	/* BOP 6A */
#endif
#ifdef GEN_DRVR
			gen_driver_io,	/* BOP 6B */
#else
			illegal_bop,	/* BOP 6B */
#endif
#ifdef SUSPEND
			send_script,	/* BOP 6C */
#else
			illegal_bop,	/* BOP 6C */
#endif
			illegal_bop,	/* BOP 6D */
			illegal_bop,	/* BOP 6E */
#ifdef CDROM
			bcdrom_io,	/* BOP 6F */
#else
			illegal_bop,	/* BOP 6F */
#endif

#if defined(NEC_98)
                        illegal_bop,    /* BOP 70 */
                        illegal_bop,    /* BOP 71 */
                        illegal_bop,    /* BOP 72 */
                        illegal_bop,    /* BOP 73 */
                        illegal_bop,    /* BOP 74 */
                        illegal_bop,    /* BOP 75 */
                        illegal_bop,    /* BOP 76 */
                        illegal_bop,    /* BOP 77 */
#else  // !NEC_98
#ifdef NTVDM
                        rtc_int,        /* BOP 70 */
#else
                        illegal_bop,    /* BOP 70 */
#endif
                        re_direct,      /* BOP 71 */
			D11_int,	/* BOP 72 */
			D11_int,	/* BOP 73 */
			D11_int,	/* BOP 74 */
			int_287,	/* BOP 75 */
			D11_int,	/* BOP 76 */
			D11_int,	/* BOP 77 */
#endif // !NEC_98
#ifndef NTVDM
			worm_init,	/* BOP 78 */
			worm_io,	/* BOP 79 */
#else /* NTVDM */
			illegal_bop,	/* BOP 78 */
			illegal_bop,	/* BOP 79 */
#endif /* NTVDM */
			illegal_bop,	/* BOP 7A */
			illegal_bop,	/* BOP 7B */
			illegal_bop,	/* BOP 7C */
			illegal_bop,	/* BOP 7D */
			illegal_bop,	/* BOP 7E */
			illegal_bop,	/* BOP 7F */
			illegal_bop,    /* BOP 80 */
			illegal_bop,    /* BOP 81 */
			illegal_bop,    /* BOP 82 */
			illegal_bop,    /* BOP 83 */
			illegal_bop,    /* BOP 84 */
			illegal_bop,    /* BOP 85 */
			illegal_bop,    /* BOP 86 */
			illegal_bop,    /* BOP 87 */
			illegal_bop,    /* BOP 88 */
			illegal_bop,	/* BOP 89 */
			illegal_bop,	/* BOP 8A */
			illegal_bop,	/* BOP 8B */
			illegal_bop,	/* BOP 8C */
			illegal_bop,	/* BOP 8D */
			illegal_bop,	/* BOP 8E */
			illegal_bop,	/* BOP 8F */

#ifdef NTVDM
/* No bootstrap on NT */
			illegal_bop,	 /* BOP 90 */
			illegal_bop,	 /* BOP 91 */
			illegal_bop,	 /* BOP 92 */
#else
			bootstrap1,	/* BOP 90 */
			bootstrap2,	/* BOP 91 */
			bootstrap3,	/* BOP 92 */
#endif

#ifdef SWINAPI
			Gdi_call,	/* BOP 93 */
			User_call,	/* BOP 94 */
                        Swinapi_bop,    /* BOP 95 */
#else /* SWINAPI */

			illegal_bop,	/* BOP 93 */
			illegal_bop,	/* BOP 94 */
			illegal_bop,	/* BOP 95 */
#endif /* SWINAPI */

			illegal_bop,	/* BOP 96 */
			illegal_bop,	/* BOP 97 */
#ifdef MSWDVR
			ms_windows,		/* BOP 98 */
			msw_mouse,	      /* BOP 99 */
			msw_copy,		/* BOP 9A */
			msw_keybd,		/* BOP 9B */
#else
			illegal_bop,	/* BOP 98 */
			illegal_bop,	/* BOP 99 */
			illegal_bop,	/* BOP 9A */
			illegal_bop,	/* BOP 9B */
#endif
#if	defined(SOFTWIN_API) || defined(SWIN_HFX)
			SoftWindowsInit,	/* BOP 9C */
			SoftWindowsTerm,	/* BOP 9D */
#else
			illegal_bop,	/* BOP 9C */
			illegal_bop,	/* BOP 9D */
#endif	/* SOFTWIN_API or SWIN_HFX */
#if	defined(SOFTWIN_API)
			SoftWindowsApi,	/* BOP 9E */
#else
			illegal_bop,	/* BOP 9E */
#endif	/* SOFTWIN_API */
#ifdef SWIN_HAW
			msw_sound,	/* BOP 9F */
#else
			illegal_bop,	/* BOP 9F */
#endif /* SWIN_HAW */

#ifdef	NOVELL_IPX
			IPXResInit,	/* BOP A0 */
			IPXResEntry,	/* BOP A1 */
			IPXResInterrupt,/* BOP A2 */
			illegal_bop,	/* BOP A3 */
#else	/* NOVELL_IPX */
			illegal_bop,	/* BOP A0 */
			illegal_bop,	/* BOP A1 */
			illegal_bop,	/* BOP A2 */
			illegal_bop,	/* BOP A3 */
#endif	/* NOVELL_IPX */

#ifdef	NOVELL_TCPIP
			TCPResInit,	/* BOP A4 */
			TCPResEntry,	/* BOP A5 */
#else	/* NOVELL_TCPIP */

			illegal_bop,	/* BOP A4 */
			illegal_bop,	/* BOP A5 */

#endif	/* NOVELL_TCPIP */

#ifdef WINSOCK
                        ISWSEntry,      /* BOP A6 */
                        illegal_bop,    /* BOP A7 */
#else /* WINSOCK */
                        illegal_bop,    /* BOP A6 */
                        illegal_bop,    /* BOP A7 */
#endif /* WINSOCK */
			illegal_bop,	/* BOP A8 */
			illegal_bop,	/* BOP A9 */
#ifdef SWIN_HFX
			v_SwinRedirector,   /* BOP AA */ /* SwinRedirector */
			SwinFileOpened,	/* BOP AB */
			SwinHfxTaskTerm,	/* BOP AC */
#else
			illegal_bop,	/* BOP AA */
			illegal_bop,	/* BOP AB */
			illegal_bop,	/* BOP AC */
#endif

#ifdef	MSWDVR
			msw_copyInit,	/* BOP AD */
			illegal_bop,	/* BOP AE */
			illegal_bop,	/* BOP AF */
			illegal_bop,	/* BOP B0 */
#else
			illegal_bop,	/* BOP AD */
			illegal_bop,	/* BOP AE */
			illegal_bop,	/* BOP AF */
			illegal_bop,	/* BOP B0 */
#endif

#ifdef CPU_40_STYLE
			virtual_device_trap,	/* BOP B1 */
#else
			illegal_bop,	/* BOP B1 */
#endif
			illegal_bop,	/* BOP B2 */
			illegal_bop,	/* BOP B3 */
			illegal_bop,	/* BOP B4 */
			illegal_bop,	/* BOP B5 */
			illegal_bop,	/* BOP B6 */
			illegal_bop,	/* BOP B7 */
			v_mouse_install1,	/* BOP B8 */ /* mouse_install1 */
			v_mouse_install2,	/* BOP B9 */ /* mouse_install2 */
			v_mouse_int1,		/* BOP BA */ /* mouse_int1 */
			v_mouse_int2,		/* BOP BB */ /* mouse_int2 */
			v_mouse_io_language,	/* BOP BC */ /* mouse_io_language */
			v_mouse_io_interrupt,	/* BOP BD */ /* mouse_io_interrupt */
			v_mouse_video_io,      	/* BOP BE */ /* mouse_video_io */
			v_mouse_EM_callback,	/* BOP BF */ /* mouse_EM_callback */
			illegal_bop,	/* BOP C0 */
			illegal_bop,	/* BOP C1 */
			illegal_bop,	/* BOP C2 */
			illegal_bop,	/* BOP C3 */
			illegal_bop,	/* BOP C4 */
			illegal_bop,	/* BOP C5 */
			illegal_bop,	/* BOP C6 */
			illegal_bop,	/* BOP C7 */
#if defined(XWINDOW) || defined(NTVDM)
			v_host_mouse_install1,	/* BOP C8 */ /* host_mouse_install1 */
			v_host_mouse_install2,	/* BOP C9 */ /* host_mouse_install2 */
#else
#ifdef GISP_SVGA
			mouse_install1,
			mouse_install2,
#else /* GISP_SVGA */
			illegal_bop,	/* BOP C8 */
			illegal_bop,	/* BOP C9 */
#endif /* GISP_SVGA */
#endif /* defined(XWINDOW) || defined(NTVDM) */
			illegal_bop,	/* BOP CA */
			illegal_bop,	/* BOP CB */
			illegal_bop,	/* BOP CC */
			illegal_bop,	/* BOP CD */
			illegal_bop,	/* BOP CE */
			illegal_bop,	/* BOP CF */
#ifdef PROFILE
			reset_profile,	/* BOP D0 */
			dump_profile,	/* BOP D1 */
#else
			illegal_bop,	/* BOP D0 */
			illegal_bop,	/* BOP D1 */
#endif
			illegal_bop,	/* BOP D2 */
			illegal_bop,	/* BOP D3 */
#ifdef SIGNAL_PROFILING
			Start_sigprof,	/* BOP D4 */
			Stop_sigprof,	/* BOP D5 */
			Dump_sigprof,	/* BOP D6 */
#else
			illegal_bop,	/* BOP D4 */
			illegal_bop,	/* BOP D5 */
			illegal_bop,	/* BOP D6 */
#endif
			illegal_bop,	/* BOP D7 */
			illegal_bop,	/* BOP D8 */
			illegal_bop,	/* BOP D9 */
			illegal_bop,	/* BOP DA */
			illegal_bop,	/* BOP DB */
			illegal_bop,	/* BOP DC */
			illegal_bop,	/* BOP DD */
			illegal_bop,	/* BOP DE */
			illegal_bop,	/* BOP DF */
			illegal_bop,	/* BOP E0 */
			illegal_bop,	/* BOP E1 */
			illegal_bop,	/* BOP E2 */
			illegal_bop,	/* BOP E3 */
			illegal_bop,	/* BOP E4 */
			illegal_bop,	/* BOP E5 */
			illegal_bop,	/* BOP E6 */
			illegal_bop,	/* BOP E7 */
			illegal_bop,	/* BOP E8 */
			illegal_bop,	/* BOP E9 */
			illegal_bop,	/* BOP EA */
			illegal_bop,	/* BOP EB */
			illegal_bop,	/* BOP EC */
			illegal_bop,	/* BOP ED */
			illegal_bop,	/* BOP EE */
			illegal_bop,	/* BOP EF */
			illegal_bop,	/* BOP F0 */
			illegal_bop,	/* BOP F1 */
			illegal_bop,	/* BOP F2 */
			illegal_bop,	/* BOP F3 */
			illegal_bop,	/* BOP F4 */
			illegal_bop,	/* BOP F5 */
			illegal_bop,	/* BOP F6 */
			illegal_bop,	/* BOP F7 */

#ifndef PROD
			dvr_bop_trace,	/* BOP F8 */
			trace_msg_bop,	/* BOP F9 -- pic*/
#else
			illegal_bop,	/* BOP F8 */
			illegal_bop,	/* BOP F9 */
#endif
#ifndef GISP_CPU
			illegal_bop,	/* BOP FA */
			illegal_bop,	/* BOP FB */
			illegal_bop,	/* BOP FC */
#if defined(NTVDM) && defined(MONITOR)
                        switch_to_real_mode,	/* BOP FD */
#else
                        illegal_bop,    /* BOP FD */
#endif	/* NTVDM && MONITOR */
#if !defined(LDBIOS) && !defined(CPU_30_STYLE)
                        host_unsimulate,/* BOP FE */
#else
#if defined(NTVDM) && defined(MONITOR)
                        host_unsimulate,	/* BOP FE */
#else
                        illegal_bop,    /* BOP FE */
#endif	/* NTVDM && MONITOR */
#endif	/* !LDBIOS && !CPU_30_STYLE */

#else /* ndef GISP_CPU */

/* In the GISP technology,  BOPs FA, FC, FD and FE are
   assumed to be handled directly by the host operating system and cannot
   be used inside SoftPC.
 */
			illegal_bop,	/* BOP FA */
			hg_bop_handler,	/* BOP FB */ /* in hg_cpu.c */
			illegal_bop,	/* BOP FC */
			illegal_bop,	/* BOP FD */
			illegal_bop,	/* BOP FE */
			
#endif	/* GISP_CPU */

                        control_bop     /* BOP FF */
			/* Don't put anymore entries after FF because
			   we only have a byte quantity */
		};
#endif /* MAC_LIKE */



#ifndef PROD
#ifdef	MAC_LIKE
GLOBAL char *bop_name IFN1(IU8, bop_num)
{
	return (NULL);
}
#else	/* !MAC_LIKE */

typedef void (*BOP_proc) IPT0();
struct BOP_name {
	BOP_proc	proc;
	char		*name;
};
#define BOP_NAME(proc)	{ proc,	STRINGIFY(proc)	}

LOCAL struct BOP_name BOP_names[] = {
	BOP_NAME(reset),
	BOP_NAME(illegal_op_int),
#if !defined(NTVDM) && !defined(CPU_40_STYLE)
	BOP_NAME(time_int),
#endif /* !NTVDM && !CPU_40_STYLE */
	BOP_NAME(keyboard_int),
	BOP_NAME(diskette_int),
	BOP_NAME(video_io),
	BOP_NAME(equipment),
	BOP_NAME(memory_size),
	BOP_NAME(disk_io),
	BOP_NAME(rs232_io),
	BOP_NAME(cassette_io),
	BOP_NAME(keyboard_io),
#ifndef NEC_98
	BOP_NAME(printer_io),
#endif //!NEC_98
	BOP_NAME(rom_basic),
	BOP_NAME(softpc_version),
	BOP_NAME(diskette_io),
	BOP_NAME(time_of_day),
	BOP_NAME(kb_idle_poll),
#ifndef NTVDM
	BOP_NAME(cmd_install),
	BOP_NAME(cmd_load),
#endif /* NTVDM */
	BOP_NAME(diskette_io),
	BOP_NAME(v_mouse_install1),
	BOP_NAME(v_mouse_install2),
	BOP_NAME(v_mouse_int1),
	BOP_NAME(v_mouse_int2),
	BOP_NAME(v_mouse_io_language),
	BOP_NAME(v_mouse_io_interrupt),
	BOP_NAME(v_mouse_video_io),
	BOP_NAME(v_mouse_EM_callback),
#ifdef PROFILE
	BOP_NAME(reset_profile),
	BOP_NAME(dump_profile),
#endif
#ifdef SIGNAL_PROFILING
	BOP_NAME(Start_sigprof),
	BOP_NAME(Stop_sigprof),
	BOP_NAME(Dump_sigprof),
#endif
	BOP_NAME(re_direct),
	BOP_NAME(D11_int),
	BOP_NAME(D11_int),
	BOP_NAME(D11_int),
	BOP_NAME(int_287),
	BOP_NAME(D11_int),
	BOP_NAME(D11_int),
#ifndef NTVDM
	BOP_NAME(worm_init),
	BOP_NAME(worm_io),
#endif /* NTVDM */

#if  defined(RDCHK) && !defined(PROD)
	BOP_NAME(get_lar),
#endif
#ifdef HFX
	BOP_NAME(v_test_for_us),
	BOP_NAME(v_redirector),
#endif
#ifdef DPMI
	BOP_NAME(DPMI_2F),		BOP_NAME(DPMI_31),
	BOP_NAME(DPMI_general),		BOP_NAME(DPMI_int),
	BOP_NAME(DPMI_r0_int),		BOP_NAME(DPMI_exc),
	BOP_NAME(DPMI_4B),
#endif /* DPMI */
#ifdef DOS_APP_LIC
	BOP_NAME(DOS_AppLicense),
#endif
#ifdef NOVELL
	BOP_NAME(DriverInitialize),	BOP_NAME(DriverReadPacket),
	BOP_NAME(DriverSendPacket),	BOP_NAME(DriverMulticastChange),
	BOP_NAME(DriverReset),		BOP_NAME(DriverShutdown),
	BOP_NAME(DriverAddProtocol),	BOP_NAME(DriverChangePromiscuous),
	BOP_NAME(DriverOpenSocket),	BOP_NAME(DriverCloseSocket),
#endif
#ifdef EGG
	BOP_NAME(ega_video_io),
#endif
#ifdef NTVDM
	BOP_NAME(MS_bop_0),		BOP_NAME(MS_bop_1),
	BOP_NAME(MS_bop_2),		BOP_NAME(MS_bop_3),
	BOP_NAME(MS_bop_4),		BOP_NAME(MS_bop_5),
	BOP_NAME(MS_bop_6),		BOP_NAME(MS_bop_7),
	BOP_NAME(MS_bop_8),		BOP_NAME(MS_bop_9),
	BOP_NAME(MS_bop_A),		BOP_NAME(MS_bop_B),
	BOP_NAME(MS_bop_C),		BOP_NAME(MS_bop_D),
	BOP_NAME(MS_bop_E),		BOP_NAME(MS_bop_F),
	BOP_NAME(terminate),
#else
	BOP_NAME(bootstrap),		BOP_NAME(bootstrap1),
	BOP_NAME(bootstrap2),		BOP_NAME(bootstrap3),
#endif /* NTVDM */
#ifdef SMEG
	BOP_NAME(smeg_collect_data),	BOP_NAME(smeg_freeze_data),
#endif /* SMEG */
#if defined(IRET_HOOKS) && defined(GISP_CPU)
	BOP_NAME(Cpu_hook_bop),
#endif /* IRET_HOOKS  && GISP_CPU */
#ifdef GISP_SVGA
	BOP_NAME(romMessageAddress),
#endif
#ifdef PTY
	BOP_NAME(com_bop_pty),
#endif
#ifdef PC_CONFIG
	BOP_NAME(pc_config),
#endif
#ifdef LIM
	BOP_NAME(emm_init),		BOP_NAME(emm_io),
	BOP_NAME(return_from_call),
#endif			
#ifdef SUSPEND
	BOP_NAME(suspend_softpc),	BOP_NAME(terminate),
#endif
#ifdef GEN_DRVR
	BOP_NAME(gen_driver_io),
#endif
#ifdef SUSPEND
	BOP_NAME(send_script),
#endif
#ifdef CDROM
	BOP_NAME(bcdrom_io),
#endif
#ifdef SWINAPI
	BOP_NAME(Gdi_call),		BOP_NAME(User_call),
	BOP_NAME(Swinapi_bop),
#endif /* SWINAPI */
#ifdef MSWDVR
	BOP_NAME(ms_windows),		BOP_NAME(msw_mouse),
	BOP_NAME(msw_copy),		BOP_NAME(msw_keybd),
	BOP_NAME(msw_copyInit),
#endif
#if	defined(SOFTWIN_API) || defined(SWIN_HFX)
	BOP_NAME(SoftWindowsInit),	BOP_NAME(SoftWindowsTerm),
#endif	/* SOFTWIN_API or SWIN_HFX */
#ifdef	SOFTWIN_API
	BOP_NAME(SoftWindowsApi),
#endif	/* SOFTWIN_API */
#ifdef	NOVELL_IPX
	BOP_NAME(IPXResInit),		BOP_NAME(IPXResEntry),
	BOP_NAME(IPXResInterrupt),
#endif	/* NOVELL_IPX */

#ifdef	NOVELL_TCPIP
	BOP_NAME(TCPResInit),		BOP_NAME(TCPResEntry),
#endif	/* NOVELL_TCPIP */
#ifdef SWIN_HFX
	BOP_NAME(v_SwinRedirector),	BOP_NAME(SwinFileOpened),
	BOP_NAME(SwinHfxTaskTerm),
#endif
#if defined(XWINDOW) || defined(NTVDM)
	BOP_NAME(v_host_mouse_install1),
	BOP_NAME(v_host_mouse_install2),
#else
#ifdef GISP_SVGA
	BOP_NAME(mouse_install1),
	BOP_NAME(mouse_install2),
#endif /* GISP_SVGA */
#endif /* defined(XWINDOW) || defined(NTVDM) */
#if defined(NTVDM) && defined(MONITOR)
	BOP_NAME(switch_to_real_mode),
#endif	/* NTVDM && MONITOR */
	BOP_NAME(control_bop),
#ifdef WDCTRL_BOP
	BOP_NAME(wdctrl_bop),
#endif	/* WDCTRL_BOP */
#ifndef PROD
	BOP_NAME(trace_msg_bop),
	BOP_NAME(dvr_bop_trace),
#endif
	BOP_NAME(illegal_bop),
	{ 0, NULL }
};

GLOBAL char *bop_name IFN1(IU8, bop_num)
{
	struct BOP_name *bnp = BOP_names;
	BOP_proc proc = BIOS[bop_num];

	if (bop_num == 0xFE)
		return "UNSIMULATE";

	while ((bnp->name != NULL) && (proc != bnp->proc))
		bnp++;

	return (bnp->name);
}
#endif	/* !MAC_LIKE */
#endif	/* PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\condincl.inc ===
#
# CONDITIONAL_INCLUDES lists include files build.exe shouldn't complain
# about if it can't find them.  To make it easier on myself the same block
# is used for all of SoftPC Base via !include in sources.
#

CONDITIONAL_INCLUDES=bios_support.seg       \
                     softpc_cmos.seg        \
                     sas4gen.h              \
                     at_stuff.seg           \
                     softpc_lim.seg         \
                     softpc_init.seg        \
                     softpc_support.seg     \
                     softpc_bios.seg        \
                     softpc_comms.seg       \
                     softpc_printer.seg     \
                     softpc_error.seg       \
                     dasm1.seg              \
                     softpc_floppy.seg      \
                     softpc_hda.seg         \
                     softpc_test_floppy.seg \
                     softpc_ppi.seg         \
                     softpc_mouse.seg       \
                     softpc_ios.seg         \
                     sys/param.h            \
                     smeg_head.h            \
                     softpc_ega.seg         \
                     evidgen.h              \
                     video_bios.seg         \
                     softpc_vga.seg         \
                     video_bios_vga.seg     \
                     softpc_cga.seg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\mem_size.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * VPC-XT Revision 1.0
 *
 * Title	: memory_size
 *
 * Description	: Returns the memory size of the virtual PC memory
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)mem_size.c	1.7 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "bios.h"
#include "sas.h"

void memory_size()
{
    word memory_size;
    
    /*
     * Return the memory size in AX.  This is read in from the BIOS, as
     * certain applications can write to this area.
     */
    sas_loadw(MEMORY_VAR, &memory_size);
    
    setAX(memory_size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\ill_bop.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * VPC-XT Revision 1.0
 *
 * Title	: illegal_bop.c
 *
 * Description	: A bop instuction has been executed for which
 *		  no VPC function exists.
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)ill_bop.c	1.11 12/07/94 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include TypesH
#include StringH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include CpuH
#include "debug.h"

#ifndef	PROD

#define	MAX_IGNORE_BOPS	8
LOCAL IU8 ignoreBops[MAX_IGNORE_BOPS];
LOCAL IU8 maxIgnore = 0;
LOCAL IBOOL ignoreAll = FALSE;
LOCAL IBOOL doForceYoda = FALSE;

#endif	/* PROD */

#if defined(NTVDM) && defined(MONITOR)
#define GetInstructionPointer()     getEIP()
#endif

void illegal_bop()
{
#ifndef PROD
	static IBOOL first = TRUE;
	IU8 bop_number;
	double_word ea;
	IU8 i;
	char *ignEnv;
	char *pIgn;

	if (first)
	{
#ifdef	YODA
		/* Check whether YODA is defined or not. */
		
		if (ignEnv = (char *)host_getenv("YODA"))
			doForceYoda = TRUE;
#endif	/* YODA */
			
		/* Sort out which illegal bops to ignore. These are set
		** in the environment variable IGNORE_ILLEGAL_BOPS
		** which is set to either "all" to ignore all illegal
		** bops, or to a colon-separated list of hex numbers
		** to ignore specific bops.
		*/

		if (ignEnv = (char*)host_getenv("IGNORE_ILLEGAL_BOPS"))
		{
			if (strcasecmp(ignEnv, "all") == 0)
			{
				ignoreAll = TRUE;
			}
			else
			{
				for (pIgn = ignEnv; *pIgn &&
					(maxIgnore < (MAX_IGNORE_BOPS - 1)); )
				{
					int ignValue;
					
					/* Find the first hex digit. */

					for ( ; *pIgn && !isxdigit(*pIgn);
						pIgn++)
						;

					/* Read in the bop number. */
					
					if (isxdigit(*pIgn) &&
						(sscanf(pIgn, "%x",
						&ignValue) == 1))
					{
						ignoreBops[maxIgnore++] =
							(IU8)ignValue;
					}
					
					/* Skip the bop number. */
					
					for ( ; isxdigit(*pIgn); pIgn++)
						;
				}
			}
		}
		
		first = FALSE;	/* no need to repeat this palaver */
	}

	ea = effective_addr(getCS(), GetInstructionPointer() - 1);
	bop_number = sas_hw_at(ea);
	
	/* Why is the bop there at all if it's illegal? Alway trace
	 * such BOPs rather than silently ignoring them.
	 */

	always_trace3(
	"Illegal BOP %02x precedes CS:EIP %04x:%04x",
		bop_number, getCS(), GetInstructionPointer());
			
	if (ignoreAll)
		return;
		
	for (i = 0; i < maxIgnore; i++)
	{
		if (ignoreBops[i] == bop_number)
			return;
	}

	/* This BOP isn't ignored - drop into Yoda if possible */
#ifdef	YODA
	if (doForceYoda)
		force_yoda();
#endif	/* YODA */
#endif /* PROD */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\reset.c ===
#include "insignia.h"
#include "host_def.h"
/*[
        Name:           reset.c
        Derived From:   base 2.0
        Author:         Henry Nash
        Created On:     Unknown
        Sccs ID:        @(#)reset.c     1.81 06/20/95
        Purpose:
                This function is called once the system memory has been
                initialised.  It builds the interrupt vector table,
                initiailises any physical devices and BIOS handlers.
                The CPU will execute a call to the BIOS bootstrap
                function after this routine has returned.


        (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdlib.h>
#include <stdio.h>
#include TypesH
#include StringH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "bios.h"
#include "sas.h"
#include CpuH
#include "cmos.h"
#include "error.h"
#include "config.h"
#include "dma.h"
#include "fla.h"
#include "gfi.h"
#include "floppy.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "gvi.h"
#include "ica.h"
#include "keyboard.h"
#include "mouse.h"
#include "mouse_io.h"
#include "ppi.h"
#include "printer.h"
#include "ios.h"
#include "equip.h"
#include "rs232.h"
#include "timer.h"
#include "gendrvr.h"
#include "virtual.h"
#ifdef PRINTER
#include "host_lpt.h"
#endif
#include "fdisk.h"
#include "trace.h"
#include "debug.h"
#include "video.h"
#ifdef NOVELL
#include "novell.h"
#endif
#include "emm.h"
#include "quick_ev.h"
#include "keyba.h"
#include "rom.h"
#ifdef GISP_SVGA
#include "gisp_sas.h"
#endif          /* GISP_SVGA */
#include "hunter.h"
#ifdef LICENSING
#include "host_lic.h"
#endif /* LICENSING */

/* Exports */

/*
 * These are the working function pointer structures for the GWI.
 */

VIDEOFUNCS      *working_video_funcs;
KEYBDFUNCS      *working_keybd_funcs;
#ifndef NTVDM
ERRORFUNCS      *working_error_funcs;
#endif
HOSTMOUSEFUNCS  *working_mouse_funcs;

/* Imports */
#ifdef NPX
IMPORT void initialise_npx IPT0();
#endif  /* NPX */

#ifdef DPMI
IMPORT void DPMI_reset IPT0();
#endif /* DPMI */

#ifdef GISP_SVGA
#include HostHwVgaH
#include "hwvga.h"
#endif /* GISP_SVGA */

#if     defined(DELTA) && defined(A2CPU)
extern  void    reset_delta_data_structures();
#endif /* DELTA && A2CPU */

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/*
 * Macro to produce an interrupt table location from an interrupt number
 */

#define int_addr(int_no)                (int_no * 4)

/*
 * global variable for keyboard requested interrupts. After the
 * initial boot  treat any subsequent reset as 'soft'. This allows
 * for user installed reboots which will not be able to set this flag.
 */

int soft_reset = 0;

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

extern void npx_reset IPT0();
extern void cmos_clear_shutdown_byte IPT0();

extern word msw;

#if defined(NEC_98)
extern GLOBAL BOOL HIRESO_MODE;
extern GLOBAL BOOL video_emu_mode;
extern GLOBAL UCHAR Configuration_Data[1192];
extern void sys_port_init();
extern void sys_port_post();
extern void text_gdc_init();
extern void text_gdc_post();
extern void crtc_init();
extern void crtc_post();
extern void cg_init();
extern void cg_post();
extern void NEC98_graph_init();
extern void NEC98_graph_post();
extern void video_freeze_change(BOOL);
void init_system_common_area();
#endif // NEC_98

IMPORT  CHAR    *host_get_version IPT0();
IMPORT  CHAR    *host_get_unpublished_version IPT0();
IMPORT  CHAR    *host_get_years IPT0();
IMPORT  CHAR    *host_get_copyright IPT0();

#ifdef PIG
extern long pig_gfx_adapter;
#endif

#define STATUS_PORT   0x64   /* keyboard status port */
#define SYS_FLAG      0x4    /* shutdown bit of keyboard status port */
#define PORT_A        0x60   /* keyboard port a */
#define IO_ROM_SEG    0x69   /* User Stack Pointer(SS) */
#define IO_ROM_INIT   0x67   /* User Stack Pointer(SP) */

static void setup_ivt()
{
#if defined(NEC_98)
    if(HIRESO_MODE) {
            sas_storew(int_addr(0x0), H_INT00_OFFSET);
            sas_storew(int_addr(0x0) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x1), H_INT01_OFFSET);
            sas_storew(int_addr(0x1) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x2), H_INT02_OFFSET);
            sas_storew(int_addr(0x2) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x3), H_INT03_OFFSET);
            sas_storew(int_addr(0x3) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x4), H_INT04_OFFSET);
            sas_storew(int_addr(0x4) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x5), H_INT05_OFFSET);
            sas_storew(int_addr(0x5) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x6), H_INT06_OFFSET);
            sas_storew(int_addr(0x6) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x7), H_INT07_OFFSET);
            sas_storew(int_addr(0x7) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x8), H_INT08_OFFSET);
            sas_storew(int_addr(0x8) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x9), H_INT09_OFFSET);
            sas_storew(int_addr(0x9) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0xA), H_INT0A_OFFSET);
            sas_storew(int_addr(0xA) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0xB), H_INT0B_OFFSET);
            sas_storew(int_addr(0xB) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0xC), H_INT0C_OFFSET);
            sas_storew(int_addr(0xC) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0xD), H_INT0D_OFFSET);
            sas_storew(int_addr(0xD) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0xE), H_INT0E_OFFSET);
            sas_storew(int_addr(0xE) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0xF), H_INT0F_OFFSET);
            sas_storew(int_addr(0xF) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x10), H_INT10_OFFSET);
            sas_storew(int_addr(0x10) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x11), H_INT11_OFFSET);
            sas_storew(int_addr(0x11) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x12), H_INT12_OFFSET);
            sas_storew(int_addr(0x12) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x13), H_INT13_OFFSET);
            sas_storew(int_addr(0x13) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x14), H_INT14_OFFSET);
            sas_storew(int_addr(0x14) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x15), H_INT15_OFFSET);
            sas_storew(int_addr(0x15) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x16), H_INT16_OFFSET);
            sas_storew(int_addr(0x16) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x17), H_INT17_OFFSET);
            sas_storew(int_addr(0x17) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x18), H_INT18_OFFSET);
            sas_storew(int_addr(0x18) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x19), H_INT19_OFFSET);
            sas_storew(int_addr(0x19) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x1A), H_INT1A_OFFSET);
            sas_storew(int_addr(0x1A) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x1B), H_INT1B_OFFSET);
            sas_storew(int_addr(0x1B) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x1C), H_INT1C_OFFSET);
            sas_storew(int_addr(0x1C) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x1D), H_INT1D_OFFSET);
            sas_storew(int_addr(0x1D) + 2, H_GBIO_SEGMENT);
            sas_storew(int_addr(0x1E), H_INT1E_OFFSET);
            sas_storew(int_addr(0x1E) + 2, H_BIOS_SEGMENT);
            sas_storew(int_addr(0x1F), H_INT1F_OFFSET);
            sas_storew(int_addr(0x1F) + 2, H_BIOS_SEGMENT);

        /*  from int 20h to int FFh are 0x0000:0x0000 */
            sas_fills(int_addr(0x20),0x00,0x400-0x20*4);

    } else {
            sas_storew(int_addr(0x0), N_INT00_OFFSET);
            sas_storew(int_addr(0x0) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x1), N_INT01_OFFSET);
            sas_storew(int_addr(0x1) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x2), N_INT02_OFFSET);
            sas_storew(int_addr(0x2) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x3), N_INT03_OFFSET);
            sas_storew(int_addr(0x3) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x4), N_INT04_OFFSET);
            sas_storew(int_addr(0x4) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x5), N_INT05_OFFSET);
            sas_storew(int_addr(0x5) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x6), N_INT06_OFFSET);
            sas_storew(int_addr(0x6) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x7), N_INT07_OFFSET);
            sas_storew(int_addr(0x7) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x8), N_INT08_OFFSET);
            sas_storew(int_addr(0x8) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x9), N_INT09_OFFSET);
            sas_storew(int_addr(0x9) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0xA), N_INT0A_OFFSET);
            sas_storew(int_addr(0xA) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0xB), N_INT0B_OFFSET);
            sas_storew(int_addr(0xB) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0xC), N_INT0C_OFFSET);
            sas_storew(int_addr(0xC) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0xD), N_INT0D_OFFSET);
            sas_storew(int_addr(0xD) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0xE), N_INT0E_OFFSET);
            sas_storew(int_addr(0xE) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0xF), N_INT0F_OFFSET);
            sas_storew(int_addr(0xF) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x10), N_INT10_OFFSET);
            sas_storew(int_addr(0x10) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x11), N_INT11_OFFSET);
            sas_storew(int_addr(0x11) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x12), N_INT12_OFFSET);
            sas_storew(int_addr(0x12) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x13), N_INT13_OFFSET);
            sas_storew(int_addr(0x13) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x14), N_INT14_OFFSET);
            sas_storew(int_addr(0x14) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x15), N_INT15_OFFSET);
            sas_storew(int_addr(0x15) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x16), N_INT16_OFFSET);
            sas_storew(int_addr(0x16) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x17), N_INT17_OFFSET);
            sas_storew(int_addr(0x17) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x18), N_INT18_OFFSET);
            sas_storew(int_addr(0x18) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x19), N_INT19_OFFSET);
            sas_storew(int_addr(0x19) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x1A), N_INT1A_OFFSET);
            sas_storew(int_addr(0x1A) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x1B), N_INT1B_OFFSET);
            sas_storew(int_addr(0x1B) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x1C), N_INT1C_OFFSET);
            sas_storew(int_addr(0x1C) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x1D), N_INT1D_OFFSET);
            sas_storew(int_addr(0x1D) + 2, N_BIOS_SEGMENT);
            sas_storew(int_addr(0x1E), N_INT1E_OFFSET);
            sas_storew(int_addr(0x1E) + 2, BASIC_SEGMENT);
            sas_storew(int_addr(0x1F), N_INT1F_OFFSET);
            sas_storew(int_addr(0x1F) + 2, N_BIOS_SEGMENT);

        /*  from int 20h to int FFh are 0x0000:0x0000 */
            sas_fills(int_addr(0x20),0x00,0x400-0x20*4);
    }
#else  // !NEC_98
        IUH count;

        /* make all vectors between 0 and 78 (apart from
        ** 60-67 inclusive) point to the unexpected
        ** interrupt routine
        */
        for (count=0; count<=0x78; count++)
        {
                sas_storew(int_addr(count), UNEXP_INT_OFFSET);
                sas_storew(int_addr(count) + 2, UNEXP_INT_SEGMENT);
        }
        for (count=0x60; count<=0x67; count++)
        {
                sas_storew(int_addr(count), 0);
                sas_storew(int_addr(count) + 2, 0);
        }

        /* now put in any vectors that should be set up
        */

        sas_storew(int_addr(0x5), PRINT_SCREEN_OFFSET);
        sas_storew(int_addr(0x5) + 2, PRINT_SCREEN_SEGMENT);
        sas_storew(int_addr(0x6), ILL_OP_INT_OFFSET);
        sas_storew(int_addr(0x6) + 2, ILL_OP_INT_SEGMENT);
        sas_storew(int_addr(0x8), TIMER_INT_OFFSET);
        sas_storew(int_addr(0x8) + 2, TIMER_INT_SEGMENT);
        sas_storew(int_addr(0x9), KB_INT_OFFSET);
        sas_storew(int_addr(0x9) + 2, KB_INT_SEGMENT);
        /* disk h/w interrupt arrives on slave ica, at line 6
        * (gets setup by fixed disk POST (disk_post())
        */
        sas_storew(int_addr(0xE), DISKETTE_INT_OFFSET);
        sas_storew(int_addr(0xE) + 2, DISKETTE_INT_SEGMENT);
#ifdef  GISP_SVGA
        if((ULONG) config_inquire(C_GFX_ADAPTER, NULL) == CGA )
        {
                sas_storew(int_addr(0x10), CGA_VIDEO_IO_OFFSET);
                sas_storew( int_addr(0x10) + 2 , VIDEO_IO_SEGMENT );
        }
        else
        {
                sas_storew(int_addr(0x10), GISP_INT_10_ADDR_OFFSET );
                sas_storew( int_addr(0x10) + 2 , EgaROMSegment );
        }
#else           /* GISP_SVGA */
        sas_storew(int_addr(0x10), VIDEO_IO_OFFSET);
        sas_storew(int_addr(0x10) + 2, VIDEO_IO_SEGMENT);
#endif          /* GISP_SVGA */
        sas_storew(int_addr(0x11), EQUIPMENT_OFFSET);
        sas_storew(int_addr(0x11) + 2, EQUIPMENT_SEGMENT);
        sas_storew(int_addr(0x12), MEMORY_SIZE_OFFSET);
        sas_storew(int_addr(0x12) + 2, MEMORY_SIZE_SEGMENT);
        /* disk_post() will revector this to INT 40h
        */
        sas_storew(int_addr(0x13), DISKETTE_IO_OFFSET);
        sas_storew(int_addr(0x13) + 2, DISKETTE_IO_SEGMENT);
        sas_storew(int_addr(0x14), RS232_IO_OFFSET);
        sas_storew(int_addr(0x14) + 2, RS232_IO_SEGMENT);
        sas_storew(int_addr(0x15), CASSETTE_IO_OFFSET);
        sas_storew(int_addr(0x15) + 2, CASSETTE_IO_SEGMENT);
        sas_storew(int_addr(0x16), KEYBOARD_IO_OFFSET);
        sas_storew(int_addr(0x16) + 2, KEYBOARD_IO_SEGMENT);
        sas_storew(int_addr(0x17), PRINTER_IO_OFFSET);
        sas_storew(int_addr(0x17) + 2, PRINTER_IO_SEGMENT);
        sas_storew(int_addr(0x18), BASIC_OFFSET);
        sas_storew(int_addr(0x18) + 2, BASIC_SEGMENT);
        sas_storew(int_addr(0x19), BOOT_STRAP_OFFSET);
        sas_storew(int_addr(0x19) + 2, BOOT_STRAP_SEGMENT);
        sas_storew(int_addr(0x1A), TIME_OF_DAY_OFFSET);
        sas_storew(int_addr(0x1A) + 2, TIME_OF_DAY_SEGMENT);
        sas_storew(int_addr(0x1B), DUMMY_INT_OFFSET);
        sas_storew(int_addr(0x1B) + 2, DUMMY_INT_SEGMENT);
        sas_storew(int_addr(0x1C), DUMMY_INT_OFFSET);
        sas_storew(int_addr(0x1C) + 2, DUMMY_INT_SEGMENT);
        sas_storew(int_addr(0x1D), VIDEO_PARM_OFFSET);
        sas_storew(int_addr(0x1D) + 2, VIDEO_PARM_SEGMENT);
        sas_storew(int_addr(0x1E), DISKETTE_TB_OFFSET);
        sas_storew(int_addr(0x1E) + 2, DISKETTE_TB_SEGMENT);
        sas_storew(int_addr(0x1F), EXTEND_CHAR_OFFSET);
        sas_storew(int_addr(0x1F) + 2, EXTEND_CHAR_SEGMENT);
        /* disk_post() will set this up
        */
        sas_storew(int_addr(0x40), DUMMY_INT_OFFSET);
        sas_storew(int_addr(0x40) + 2, DUMMY_INT_SEGMENT);
        sas_storew(int_addr(0x41), DISK_TB_OFFSET);
        sas_storew(int_addr(0x41) + 2, DISK_TB_SEGMENT);

        sas_storew(int_addr(0x6F), DUMMY_INT_OFFSET); /* Needed for Windows 3.1 */
        sas_storew(int_addr(0x6F) + 2, DUMMY_INT_SEGMENT);

        sas_storew(int_addr(0x70), RTC_INT_OFFSET);
        sas_storew(int_addr(0x70) + 2, RTC_INT_SEGMENT);

        sas_storew(int_addr(0x71), REDIRECT_INT_OFFSET);
        sas_storew(int_addr(0x71) + 2, REDIRECT_INT_SEGMENT);
        sas_storew(int_addr(0x72), D11_INT_OFFSET);
        sas_storew(int_addr(0x72) + 2, D11_INT_SEGMENT);
        sas_storew(int_addr(0x73), D11_INT_OFFSET);
        sas_storew(int_addr(0x73) + 2, D11_INT_SEGMENT);
        sas_storew(int_addr(0x74), D11_INT_OFFSET);
        sas_storew(int_addr(0x74) + 2, D11_INT_SEGMENT);
        sas_storew(int_addr(0x75), X287_INT_OFFSET);
        sas_storew(int_addr(0x75) + 2, X287_INT_SEGMENT);
        sas_storew(int_addr(0x76), D11_INT_OFFSET);
        sas_storew(int_addr(0x76) + 2, D11_INT_SEGMENT);
        sas_storew(int_addr(0x77), D11_INT_OFFSET);
        sas_storew(int_addr(0x77) + 2, D11_INT_SEGMENT);
#endif // !NEC_98
}

/* Low Switch Settings */
#define RAM_64KB 0x0
#define RAM_128KB 0x4
#define RAM_192KB 0x8
#define RAM_256KB 0xC
#define PPI_CO_PROCESSOR_PRESENT 0x2
#define PPI_CO_PROCESSOR_NOT_PRESENT 0x0
#define NO_LOOP_ON_POST 0x1
#define DO_LOOP_ON_POST 0x0

/* High Switch Settings */
#define PPI_ONE_DRIVE 0x0
#define PPI_TWO_DRIVES 0x4
#define PPI_THREE_DRIVES 0x8
#define PPI_FOUR_DRIVES 0xC
#define PPI_CGA_40_COLUMN 0x1
#define PPI_CGA_80_COLUMN 0x2
#define MDA_OR_MULTI 0x3
#define EGA_INSTALLED 0x0

static void ppi_get_switches(low,high)
half_word *low, *high;
{
        half_word low_switches = 0, high_switches = 0;

#ifdef  NPX
        /*
        ** Switchable NPX
        */

        if (host_runtime_inquire(C_NPX_ENABLED))
        {
#ifdef SWITCHNPX
                Npx_enabled = 1;
#endif
                low_switches |= (RAM_256KB | PPI_CO_PROCESSOR_PRESENT | NO_LOOP_ON_POST);
        }
        else
        {
#ifdef SWITCHNPX
                Npx_enabled = 0;
#endif
                low_switches |= (RAM_256KB | PPI_CO_PROCESSOR_NOT_PRESENT | NO_LOOP_ON_POST);
        }
#else
        low_switches |= (RAM_256KB | PPI_CO_PROCESSOR_NOT_PRESENT | NO_LOOP_ON_POST);
#endif

#ifdef FLOPPY_B
        /* only indicate two floppies if a second is configured */
        if (strlen(config_inquire(C_FLOPPY_B_DEVICE, NULL)))
                high_switches |= (PPI_TWO_DRIVES);
        else
                high_switches |= (PPI_ONE_DRIVE);
#else
        high_switches |= (PPI_ONE_DRIVE);
#endif


    /* set the value of the high switches from the config settings */

    switch((ULONG)config_inquire(C_GFX_ADAPTER, NULL))
    {
    case CGA:
#ifdef CGAMONO
    case CGA_MONO:
#endif
        high_switches |= (PPI_CGA_80_COLUMN);
        break;
    case MDA:
        high_switches |= (MDA_OR_MULTI);
        break;
#ifdef EGG
    case EGA:
#ifdef VGG
    case VGA:
#endif
        high_switches |= EGA_INSTALLED;
        break;
#endif
    case HERCULES:
#ifdef HERC
        break;
#endif
    default:
        break;
    }

        *low = low_switches;
        *high = high_switches;
}

#define PRE_RELEASE_PRECAUTION "\012\015This version is subject to confidentiality provisions and should not\012\015be distributed."

GLOBAL CHAR *get_copyright IFN0()
{
        LOCAL   CHAR    buffer[300];
        CHAR    *unpublished_version;

        unpublished_version = host_get_unpublished_version();
        if (*unpublished_version)
                sprintf(buffer, "%s %s%s\012\015Copyright %s, an unpublished work by Insignia Solutions Inc.%s\012\015", SPC_Product_Name, host_get_version(), unpublished_version, host_get_years(), PRE_RELEASE_PRECAUTION );
        else
                sprintf(buffer, "%s %s\012\015Copyright %s by Insignia Solutions Inc. All rights reserved.\012\015", SPC_Product_Name, host_get_version(), host_get_years());
        assert1(sizeof(buffer) > strlen(buffer), "get_copyright buffer overflow (strlen = %d)", strlen(buffer));
        return(buffer);
}



#ifndef PROD
LOCAL void announce_variant IFN0()
{
        CHAR    buff[4*80], *p;

        strcpy (buff, "Non-PROD build variant:");

#if defined(CPU_30_STYLE) && !defined(CPU_40_STYLE)
        strcat (buff, " CPU_30_STYLE");
#endif /* CPU_30_STYLE && ! CPU_40_STYLE*/

#ifdef CPU_40_STYLE
        strcat (buff, " CPU_40_STYLE");
#endif /* CPU_40_STYLE */

#ifdef CCPU
        strcat (buff, " CCPU");
#endif /* CCPU */

#ifdef A2CPU
        strcat (buff, " A2CPU");
#endif /* A2CPU */

#ifdef A3CPU
        strcat (buff, " A3CPU");
#endif /* A3CPU */

#ifdef GISP_CPU
        strcat( buff , " GISP_CPU" );
#endif /* GISP_CPU */

#if (defined(SPC386) && !defined(SPC486))
        strcat( buff , " SPC386" );
#endif /* SPC386 && !SPC486 */

#ifdef SPC486
        strcat( buff , " SPC486" );
#endif /* SPC486 */

#ifdef PIG
        strcat (buff, " PIG");
#endif /* PIG */

#ifdef A_VID
        strcat (buff, " A_VID");
#endif /* A_VID */

#ifdef C_VID
        strcat (buff, " C_VID");
#endif /* C_VID */

#ifdef MSWDVR
        strcat( buff , " MSWDVR" );
#endif /* MSWDVR */

#ifdef BACK_M
        strcat (buff, " BACK_M");
#endif /* BACK_M */

#ifdef GISP_SVGA
        strcat( buff , " GISP_SVGA" );
#endif /* GISP_SVGA */

#ifdef DPMI
        strcat( buff , " DPMI" );
#endif /* DPMI */

#ifdef IRET_HOOKS
        strcat( buff , " IRET_HOOKS" );
#endif /* IRET_HOOKS */

#ifdef SECURE
        strcat( buff , " SECURE" );
#endif

#ifdef SYNCH_TIMERS
        strcat( buff , " SYNCH_TIMERS" );
#endif

        p = buff;
        while (strlen(p) >= 80)
        {
                while( *(--p) != ' ' )
                        ;
                *p++ = (char)0xFF;      /* Mark last space on line */
        }
        p = buff;
        while(*p != '\0')
        {
                if( (IU8)*p == 0xFF )           /* Marker from above */
                {
                        setAH( 14 );
                        setAL( VD_CR );
                        bop(BIOS_VIDEO_IO);
                        setAH( 14 );
                        setAL( VD_LF );
                        bop(BIOS_VIDEO_IO);
                }
                else
                {
                        setAH(14);
                        setAL(*p);
                        bop(BIOS_VIDEO_IO);
                }

                p++;
        }

        /*
         * Set the cursor to the next line
         */

        setAH(14);
        setAL(0xd);
        bop(BIOS_VIDEO_IO);
        setAH(14);
        setAL(0xa);
        bop(BIOS_VIDEO_IO);
        setAH(14);
        setAL(0xa);
        bop(BIOS_VIDEO_IO);
}
#endif /* PROD */

void reset()
{
#ifndef NTVDM
        char *cp;
        char temp_str[256];
#ifdef LIM
        SHORT limSize, backFill;
#endif /* LIM */
#endif /* NTVDM */
        EQUIPMENT_WORD equip_flag;
        half_word low_switches, high_switches;
        LONG gfxAdapt;
        int adapter;
#ifndef NEC_98
#ifdef PM
        half_word status_byte;
        half_word cmos_shutdown;
        sys_addr user_stack;
        word temp_word;
#ifdef NTVDM
        half_word cmos_diskette;
#endif

        /* iff not first time thru find out reset cause */
        if ( soft_reset )
        {
                /* read keyboard status port */
                inb(STATUS_PORT, &status_byte);

                /* iff shutdown bit is set */
                if ( status_byte & SYS_FLAG )
                {
                        /* read cmos shutdown byte */
                        outb(CMOS_PORT, CMOS_SHUT_DOWN);
                        inb(CMOS_DATA, &cmos_shutdown);

                        switch (cmos_shutdown)
                        {

                        case 0:
                                break;  /* nothing special */

                        case BLOCK_MOVE:
                                /* clear shut down byte */
                                outb(CMOS_PORT, CMOS_SHUT_DOWN);
                                outb(CMOS_DATA, (half_word)0);

                                /* force A20 low */
                                outb(STATUS_PORT, 0xd1);  /* 8042 cmd */
                                outb(PORT_A, 0xdd);

                                /*
                                 * After a block move IO_ROM_SEG:IO_ROM_INIT
                                 * points to User Stack, which holds:-
                                 *
                                 *      -----> DS  POP'ed by real bios
                                 *      ES  POP'ed by real bios
                                 *      DI  POPA'ed by real bios
                                 *      SI  ..
                                 *      BP  ..
                                 *      --  ..
                                 *      BX  ..
                                 *      DX  ..
                                 *      CX  ..
                                 *      AX  ..
                                 *      IP  RETF 2'ed by real bios
                                 *      CS  ..
                                 *      --  ..
                                 *
                                 * We just haul off all the registers and
                                 * then set SP.
                                 */
                                sas_loadw(effective_addr(BIOS_VAR_SEGMENT,
                                        IO_ROM_INIT), &temp_word);
                                setSP(temp_word);
                                sas_loadw(effective_addr(BIOS_VAR_SEGMENT,
                                        IO_ROM_SEG), &temp_word);
                                setSS(temp_word);

                                user_stack = effective_addr(getSS(), getSP());

                                sas_loadw(user_stack, &temp_word);
                                setDS(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setES(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setDI(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setSI(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setBP(temp_word);
                                user_stack += 2;
                                /* forget SP value */
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setBX(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setDX(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setCX(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setAX(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
#ifndef CPU_30_STYLE
                                temp_word = temp_word + HOST_BOP_IP_FUDGE;
#endif /* CPU_30_STYLE */
                                setIP(temp_word);
                                user_stack += 2;
                                sas_loadw(user_stack, &temp_word);
                                setCS(temp_word);

                                /* now adjust SP */
                                temp_word = getSP();
                                temp_word += 26;
                                setSP(temp_word);

                                /* finally set ok */
                                setAH(0);
                                setCF(0);
                                setZF(1);
                                setIF(1);
                                return;

                        case JMP_DWORD_ICA:
                                {
                                half_word       dummy;

                                /* Reset ICA and 287 before jumping to
                                ** stored double word.
                                */
#ifdef  NPX
                                npx_reset();
#endif  /* NPX */
                                outb(ICA0_PORT_0, (half_word)0x11);
                                outb(ICA0_PORT_1, (half_word)0x08);
                                outb(ICA0_PORT_1, (half_word)0x04);
                                outb(ICA0_PORT_1, (half_word)0x01);
                                /* mask all interrupts off */
                                outb(ICA0_PORT_1, (half_word)0xff);

                                outb(ICA1_PORT_0, (half_word)0x11);
                                outb(ICA1_PORT_1, (half_word)0x70);
                                outb(ICA1_PORT_1, (half_word)0x02);
                                outb(ICA1_PORT_1, (half_word)0x01);
                                /* mask all interrupts off */
                                outb(ICA1_PORT_1, (half_word)0xff);

                                /* flush keyboard buffer */
                                inb(PORT_A, &dummy);

                                /* flush timer req and allow timer ints */
                                outb(ICA0_PORT_0,END_INTERRUPT);
                                host_clear_hw_int();
                                }
                                /* deliberate fall-through */

                        case JMP_DWORD_NOICA:
                            /* clear shut down byte */
                            outb(CMOS_PORT, CMOS_SHUT_DOWN);
                            outb(CMOS_DATA, (half_word)0);

                            /* set up stack just like post */
                            setSS(0);
                            setSP(0x400);

                            /* fake up jump to indicated point */
                            sas_loadw(effective_addr(BIOS_VAR_SEGMENT, IO_ROM_INIT), &temp_word);
#ifndef CPU_30_STYLE
                            temp_word = temp_word + HOST_BOP_IP_FUDGE;
#endif /* CPU_30_STYLE */
                            setIP(temp_word);
                            sas_loadw(effective_addr(BIOS_VAR_SEGMENT, IO_ROM_SEG), &temp_word);
                            setCS(temp_word);

                            return;

                        default:
                                always_trace1("Unsupported shutdown (%x)",
                                        cmos_shutdown);

                                /* clear shut down byte */
                                outb(CMOS_PORT, CMOS_SHUT_DOWN);
                                outb(CMOS_DATA, (half_word)0);
                                break;
                        }
                }
        }
#ifdef DPMI
        /* ensure DPMI host is not still active */
        DPMI_reset();
#endif /* DPMI */
#endif /* PM */

        /*
         * Ensure any paint routines are nulled out.
         */

    reset_paint_routines();

        cmos_write_byte(CMOS_DISKETTE,
                (IU8)((half_word) gfi_drive_type(0) << 4 | gfi_drive_type(1)));
#endif // !NEC_98

        /*
         * NTVDM: if soft reset We will never get here...
         */
#ifndef NTVDM
        /*
         * If this isn't the first (re)set, then allow hosts to close down
         * timer and keyboard systems. Most ports will need to disable ALRM and
         * IO signals during this call, so that the respective signal handlers
         * will not be executed at undefined points during the adapter
         * initialisation
         */
        if (soft_reset)
        {
                /* Allow Windows 3.x compliant DOS Drivers to correctly handle
                   any data instances. To do this we:-
                   1) Close down (terminate) the driver, thus freeing any data
                      instances.
                   2) Restart (initialise) the driver, ensuring one data instance
                      is available [for config or whoever else thinks they know
                      that DOS Driver data must always exist]. */

                /* FIRST Inform NIDDB that reboot is happening.. */
                NIDDB_System_Reboot();

#ifdef HFX
                hfx_driver_termination();       /* ..then each driver */
                hfx_driver_initialisation();
#endif
                mouse_driver_termination();     /* ..then each driver */
                mouse_driver_initialisation();

                q_event_init();
                tic_event_init();

                host_timer_shutdown();
                host_kb_shutdown();
                host_disable_timer2_sound();
#ifdef NTVDM
/*
 * MS NT VDM cannot reboot in SoftPC conventional terms so exits in preparation
 * for new VDM startup.
 */
                cmdRebootVDM();
                host_terminate();
#endif /* NTVDM */
        }
#endif /* NTVDM */

        /*
         * Shutdown ODI network driver in case it was running
         */
#ifdef NOVELL
        net_term();
#endif

        /* Shutdown SmartCopy */

#ifndef HostProcessClipData
#ifdef MSWDVR
        msw_smcpy_term();
#endif
#endif

#if defined(NEC_98)
        sas_fills (0, '\0', 32L * 1024L);
        setup_ivt();
        init_system_common_area();
#else  // !NEC_98
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX)) || defined(ARCX86)
#ifdef ARCX86
    if (UseEmulationROM)
#endif
    {
        /* Clear out the bottom 32K of memory. */
        sas_fills (0, '\0', 640L * 1024L);

        /* Now set up the interrupt vector table. */
        setup_ivt();
    }
#endif /* !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX)) || defined(ARCX86) */
#endif // !NEC_98

#ifndef NTVDM

        /* Initialise the physical devices */
        SWPIC_init_funcptrs ();

        /* IO initialisation moved earlier to allow support for 3rd party
         * VDDs. (see host\src\nt_msscs.c).
         */
        io_init();
#endif /* NTVDM */

#if defined(NEC_98)
        cpu_port_init();
        cpu_port_post();
#endif // NEC_98
        ica0_init();
        ica0_post();
        ica1_init();
        ica1_post();

        /*
         * Initialise the ppi and set up the BIOS data area equipment flag
         * using the system board dip switches and configuration details
         * Note that bit 1 of both the equipment flag and the low_switches
         * indicates the existance ( or otherwise ) of a co-processor, such as
         * an 8087 floating point chip.
         */
#ifdef IPC
        init_subprocs();
#endif /* IPC */

#if defined(NEC_98)
        sys_port_init();
        sys_port_post();
        calender_init();
        calender_post();
        gvi_init();
        text_gdc_init();
        text_gdc_post();
        crtc_init();
        crtc_post();
        cg_init();
        cg_post();
        video_freeze_change(video_emu_mode);
        NEC98_graph_init();
        NEC98_graph_post();
#else  // !NEC_98
        cmos_init();
        cmos_post();

        ppi_init();
        ppi_get_switches(&low_switches,&high_switches);

        equip_flag.all = (low_switches & 0xE) | (high_switches<<4);
#ifdef PRINTER
        equip_flag.bits.printer_count = NUM_PARALLEL_PORTS;
#else /* PRINTER */
        equip_flag.bits.printer_count = 0;
#endif /* PRINTER */
        equip_flag.bits.game_io_present = FALSE;
        equip_flag.bits.rs232_count = NUM_SERIAL_PORTS;
        equip_flag.bits.ram_size = 0;

#ifdef NTVDM
        equip_flag.bits.diskette_present = FALSE;
        equip_flag.bits.max_diskette = 0;
        if (cmos_read_byte(CMOS_DISKETTE, &cmos_diskette) == SUCCESS &&
            cmos_diskette != 0)
        {
            equip_flag.bits.diskette_present = TRUE;
            if ((cmos_diskette & 0xF)  && (cmos_diskette >> 4))
                equip_flag.bits.max_diskette++;
        }
#else

        /* 20/10/93 PaulC - set the diskette_present bit regardless of */
        /* whether or not any floppies are configured. Not having the  */
        /* bit set confuses DOS and Windows. See BCN 2262.             */

        equip_flag.bits.diskette_present = TRUE;

#endif /* NTVDM */

        sas_storew(EQUIP_FLAG, equip_flag.all);

        /* Load up the amount of memory into the BIOS. */
        sas_storew(MEMORY_VAR, host_get_memory_size());

        gfxAdapt = (LONG)config_inquire(C_GFX_ADAPTER, NULL);

#ifdef GISP_SVGA

        /* The gisp build needs to do all its setup and then
        ** build the SoftPC ivt.
        */
        initHWVGA( );
        setup_ivt( );

#endif          /* GISP_SVGA */

        gvi_init((half_word) gfxAdapt);
#endif // !NEC_98

#ifdef PIG
        /* tell the pig what video adapter we are using */
        pig_gfx_adapter = gfxAdapt;
#endif

        SWTMR_init_funcptrs ();
#ifndef NEC_98
        time_of_day_init();
#endif // !NEC_98
        timer_init();
        timer_post();
        keyboard_init();
#if defined(NEC_98)
        AT_kbd_init();
#endif // NEC_98
        keyboard_post();
#ifndef NEC_98
        AT_kbd_init();
#endif // !NEC_98
        AT_kbd_post();

        video_init();

#ifdef SWIN_SNDBLST_NULL
        sb_init();
#endif /* SWIN_SNDBLST_NULL */

#ifndef NEC_98
#ifndef NTVDM   /* No signon for NTVDM - transparent integration */
        if (soft_reset == 0)
        {
                sprintf(temp_str,"%d KB OK", sas_w_at(MEMORY_VAR)
                        + ((sas_memory_size()/1024) - 1024));

                cp = temp_str;
                while(*cp != '\0')
                {
                        setAH(14);
                        setAL(*cp++);
                        bop(BIOS_VIDEO_IO);
                }

                /* Set the cursor to the next line */
                setAH(14);
                setAL(0xd);
                bop(BIOS_VIDEO_IO);
                setAH(14);
                setAL(0xa);
                bop(BIOS_VIDEO_IO);
                setAH(14);
                setAL(0xa);
                bop(BIOS_VIDEO_IO);
        }

        /*
         * Print Insignia Copyright and Version No.
         *
         * was in bios as:
         *      p = &M[COPYRIGHT_ADDR];
         * but this is a pain to change so call host routine that can be easily
         * changed. host_get_(Mr)_Copyright()
         */
        cp = get_copyright();
        while(*cp != '\0')
        {
                setAH(14);
                setAL(*cp++);
                bop(BIOS_VIDEO_IO);
        }

        cp = host_get_copyright();
        if (*cp)
        {
                while(*cp != '\0')
                {
                        setAH(14);
                        setAL(*cp++);
                        bop(BIOS_VIDEO_IO);
                }
                setAH(14);
                setAL(0xd);     /* carriage return feed */
                bop(BIOS_VIDEO_IO);
                setAH(14);
                setAL(0xa);     /* line feed */
                bop(BIOS_VIDEO_IO);
        }

#ifdef LICENSING
        if (host_lic_tick)
        host_lic_tick();

        cp = host_lic_string();
        if (*cp)
        {
                while(*cp != '\0')
                {
                        setAH(14);
                        setAL(*cp++);
                        bop(BIOS_VIDEO_IO);
                }
                setAH(14);
                setAL(0xd);     /* carriage return feed */
                bop(BIOS_VIDEO_IO);
                setAH(14);
                setAL(0xa);     /* line feed */
                bop(BIOS_VIDEO_IO);
        }
#endif /* LICENSING */

        /* skip another 1 line */
        setAH(14);
        setAL(0xa);     /* line feed */
        bop(BIOS_VIDEO_IO);

        /*
         * Print a line in a non-PROD build to give the developer a clue what
         * sort of a SoftPC they are running.
         */
#ifndef PROD
        announce_variant();
#endif /* PROD */

#endif  /* NTVDM */

        /* Now search for extra ROM modules */
        search_for_roms();
#endif // !NEC_98

        /* Now initialise the other BIOS handlers */
#if defined (GEN_DRVR) || defined (CDROM)
        init_gen_drivers();
#endif /* GEN_DRVR || CDROM */

#if defined(NEC_98)
        for (adapter = 0; adapter < 3; adapter++)
#else  // !NEC_98
        for (adapter = 0; adapter < NUM_SERIAL_PORTS; adapter++)
#endif // !NEC_98
        {
                com_init(adapter);
#ifndef NEC_98
                com_post(adapter);
#endif // !NEC_98
        }

#ifdef NPX
        initialise_npx();
#endif
        dma_init();
        dma_post();
#ifndef NEC_98
        fla_init();
        mouse_init();
        hda_init();
#else  // NEC_98
        mouse_init();
#endif // NEC_98


#ifdef PRINTER
        for (adapter = 0; adapter < NUM_PARALLEL_PORTS;adapter++)
        {
                printer_init(adapter);
                printer_post(adapter);
        }
#endif /* PRINTER */

#if     defined(DELTA) && defined(A2CPU)
        reset_delta_data_structures();
#endif /* DELTA && A2CPU */

#ifdef SOFTWIN_API
        ApiReset() ;
        ApiDisable() ;
#endif

#ifdef HUNTER
        /* Initialise the Hunter program -- the bug finder */
        hunter_init();
#endif

#ifdef LIM
#if !defined(SUN_VA) && !defined(NTVDM)
/*
        Temporary removal of LIM for SUN_VA until this issue is sorted out
*/
        /*
         * Initialise the LIM
         *
         * 'free expanded memory' only does anything if expanded memory
         * has previously been initialised
         *
         * GISP_SVGAs may need to disable LIM if there isn't room in the
         * UMA for the page frame, so don't insist on LIM for these.
         */

#ifdef GISP_SVGA
        if(!LimBufferInUse()) {
#endif /*GISP_SVGA */
        if (soft_reset)                 /* if LIM already initialised */
                free_expanded_memory();

        backFill = (SHORT) (config_inquire(C_MEM_LIMIT, NULL)? 256: 640);
        if (limSize = (ULONG)config_inquire(C_LIM_SIZE, NULL))
                while (init_expanded_memory(limSize, backFill) != SUCCESS)
                {
                        free_expanded_memory();
                        host_error(EG_EXPANDED_MEM_FAILURE, ERR_QU_CO, NULL);
                }
#ifdef GISP_SVGA
        }       /* end of additional check for no LIM buffer */
#endif /*GISP_SVGA */
#endif /* !SUN_VA & !NTVDM */

#endif /* LIM */

#ifdef NTVDM
/* lim stuff has been moved to config.c */
#endif

#ifndef NTVDM
        host_reset();
#endif

        /* Do diskette BIOS POST */
        diskette_post();

        disk_post();

#ifdef  NTVDM
        /* On NT do this after everything else is done */
        host_reset();
        q_event_init();
#endif

        /*
         * allow routines to distinguish between the initial boot and the 'soft'
         * or ctl-alt-del variety
         */
        soft_reset = 1;


        /* Now perform any other initialisation of DOS Drivers */
#ifdef HFX
        hfx_init();
#endif
}

/*(
================================ reset_bios_flags =============================
PURPOSE: To ensure that we reset "cleanly"
                -- clear out the keyboard flags and the CMOS shutdown byte.
        This fixes things like Lotus 123r31 giving an "Involuntary
        return to real mode" error when rebooting via the user interface.
INPUT:
OUTPUT:
===============================================================================
)*/

GLOBAL void reset_bios_flags IFN0()
{
        sas_PW16(RESET_FLAG, SOFT_FLAG);
        sas_PW8 (kb_flag, 0);
        sas_PW8 (kb_flag_1, 0);
        sas_PW8 (alt_input, 0);

        /* clear shut down byte */
        cmos_clear_shutdown_byte();
}
#if defined(NEC_98)
void init_system_common_area()
{

    half_word save481h,save484h,bas_clock;
    int i;
    DWORD expmemsz,expmemsz1,expmemsz2;

    for(i=0;i<512;i++) {
        sas_store(0x400+i, Configuration_Data[40+i]);
    }

    save481h = sas_hw_at(BIOS_NEC98_BIOS_FLAG3);
    save484h = sas_hw_at(BIOS_NEC98_BIOS_FLAG4);
    bas_clock = sas_hw_at(BIOS_NEC98_BIOS_FLAG+1)&0x80;

   if(HIRESO_MODE) {
        sas_store(BIOS_NEC98_SYS_SEL, 0x00);
        sas_store(BIOS_NEC98_WIN_386, 0x00);
        sas_storew(BIOS_NEC98_USER_SP, 0x0000);
        sas_storew(BIOS_NEC98_USER_SS, 0x0000);
        sas_store(BIOS_NEC98_KB_SHIFT_COD, 0x70);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+1, 0x71);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+2, 0x72);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+3, 0x73);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+4, 0x74);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+5, 0xFF);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+6, 0xFF);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+7, 0xFF);
        sas_storew(BIOS_NEC98_KB_BUFFER_ADR, 0x0502);
        sas_storew(BIOS_NEC98_KB_BUFFER_ADR+2, 0x0000);
        sas_storew(BIOS_NEC98_KB_ENTRY_TBL_ADR, 0x03B4);
        sas_storew(BIOS_NEC98_KB_ENTRY_TBL_ADR+2, 0xF800);
        sas_storew(BIOS_NEC98_KB_INT_ADR, 0x03B1);
        sas_storew(BIOS_NEC98_KB_INT_ADR+2, 0xF800);
        sas_storew(BIOS_NEC98_PR_TIME, 0x0001);
        sas_store(BIOS_NEC98_VD_PRT, 0x00);
        sas_store(BIOS_NEC98_VD_PRT+1, 0x00);
        sas_store(BIOS_NEC98_VD_PRT+2, 0x00);
        sas_store(BIOS_NEC98_VD_PRT+3, 0x00);
        sas_store(BIOS_NEC98_VD_PRT+4, 0x00);
        sas_store(BIOS_NEC98_VD_NUL, 0x00);
        sas_storew(BIOS_NEC98_VD_REMAIN_SEC, 0x0000);
        sas_storew(BIOS_NEC98_VD_REMAIN_LEN, 0x0000);
        sas_storew(BIOS_NEC98_VD_DATA_OFF, 0x0000);
        sas_store(BIOS_NEC98_VDISK_EQUIP, 0x00);
        sas_store(BIOS_NEC98_BRANCH_INT, 0x00);
        sas_storew(BIOS_NEC98_BRANCH_WORK, 0x0000);
        sas_storew(BIOS_NEC98_BRANCH_WORK+2, 0x0000);
        for(i=0;i<16;i++) {
             sas_store(BIOS_NEC98_VD_BOOT_WORK+i, 0x00);
        }
        sas_storew(BIOS_NEC98_VD_ADD, 0x0000);
        sas_storew(BIOS_NEC98_VD_ADD+2, 0x0000);
        sas_storew(BIOS_NEC98_CAL_ROOT_LST, 0x0000);
        sas_storew(BIOS_NEC98_CAL_ROOT_LST+2, 0x0000);
        sas_storew(BIOS_NEC98_CAL_BEEP_TIME, 0x0000);
        sas_storew(BIOS_NEC98_CAL_TONE, 0x0000);
        sas_storew(BIOS_NEC98_CAL_USER_OFF, 0x0000);
        sas_storew(BIOS_NEC98_CAL_USER_SEG, 0x0000);
        sas_storew(BIOS_NEC98_CRT_FONT, 0x0000);
        sas_store(BIOS_NEC98_CRT_P1, 0x00);
        sas_store(BIOS_NEC98_CRT_P2, 0x00);
        sas_store(BIOS_NEC98_CRT_P3, 0x00);
        sas_store(BIOS_NEC98_MODE_CONTROL, 0x00);
        sas_store(BIOS_NEC98_IN_BIOS, 0x00);
        sas_store(BIOS_NEC98_AT_SWITCH, 0x00);
        sas_store(BIOS_NEC98_CR_EXT_STS, 0x00);
        sas_store(BIOS_NEC98_SCSI_WORK, 0x00);
        sas_store(BIOS_NEC98_F2HD_TIME, 0x17);
        sas_store(BIOS_NEC98_CPU_STEP, 0x05);
        sas_store(BIOS_NEC98_CPU_STEP+1, 0x03);
        sas_store(BIOS_NEC98_RDISK_EQUIP, 0x00);
        sas_store(BIOS_NEC98_RDISK_EXIT, 0x00);
        sas_storew(BIOS_NEC98_RDISK_EXIT+1, 0x0000);
        sas_storew(BIOS_NEC98_RDISK_EXIT+3, 0x0000);
        sas_store(BIOS_NEC98_RDISK_STATUS, 0x00);
        sas_store(BIOS_NEC98_OMNI_FLAG, 0x00);
        sas_storew(BIOS_NEC98_BEEP_TONE, 0x0000);
        sas_store(BIOS_NEC98_DISK_RESET, 0xFF);
//      sas_store(BIOS_NEC98_F2HD_MODE, 0xFF);
        sas_store(BIOS_NEC98_GRAPH_CHG, 0x00);
        sas_storew(BIOS_NEC98_GRAPH_TAI, 0x0000);
        sas_storew(BIOS_NEC98_GRAPH_TAI+2, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_INTB1, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_B1OF, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_B2SE, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_INT1B, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_1BOF, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_1BSE, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_INT1A, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_1AOF, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_1ASE, 0x0000);
        sas_storew(BIOS_NEC98_XROM_PTR, 0x0000);
        sas_storew(BIOS_NEC98_XROM_PTR+2, 0x0000);
        for(i=0;i<16;i++) {
            sas_store(BIOS_NEC98_DISK_XROM+i, 0x00);
        }
        for(i=0;i<56;i++) {
            sas_store(BIOS_NEC98_XROM_ID+i, 0x00);
        }
        sas_storew(BIOS_NEC98_ROM_XCHG, 0x0000);
        sas_storew(BIOS_NEC98_ROM_OFS, 0x0000);
        sas_storew(BIOS_NEC98_ROM_SEG, 0x0000);
        sas_storew(BIOS_NEC98_SCLK_USER, 0x0000);
        for(i=0;i<32;i++) {
            sas_store(BIOS_NEC98_KB_BUF+i, 0x00);
        }
        sas_storew(BIOS_NEC98_KB_SHFT_TBL, 0x0000);
        sas_storew(BIOS_NEC98_KB_BUF_HEAD, 0x0000);
        sas_storew(BIOS_NEC98_KB_BUF_TAIL, 0x0000);
        sas_store(BIOS_NEC98_KB_COUNT, 0x00);
        sas_store(BIOS_NEC98_KB_RETRY, 0x00);
        for(i=0;i<16;i++) {
            sas_store(BIOS_NEC98_KB_KY_STS+i, 0x00);
        }
        sas_store(BIOS_NEC98_KB_SHFT_STS, 0x00);
//      for(i=0;i<17;i++) {
//          sas_store(BIOS_NEC98_CR_RASTER+i, 0x00);
//      }
        sas_store(BIOS_NEC98_PRXCRT, sas_hw_at(BIOS_NEC98_PRXCRT) & 0x7F);
        sas_store(BIOS_NEC98_PRXDUPD, sas_hw_at(BIOS_NEC98_PRXDUPD) & 0x7F);
        sas_storew(BIOS_NEC98_PRXGCPTN, 0x0000);
        sas_storew(BIOS_NEC98_PRXGCPTN+2, 0x0000);
        sas_storew(BIOS_NEC98_PRXGCPTN+4, 0x0000);
        sas_storew(BIOS_NEC98_PRXGCPTN+6, 0x0000);
        sas_storew(BIOS_NEC98_RS_OFST_ADR, 0x0000);
        sas_storew(BIOS_NEC98_RS_SEG_ADR, 0x0000);
        sas_store(BIOS_NEC98_RS_SIFT, 0x00);
        sas_store(BIOS_NEC98_RS_S_FLAG, 0x00);
        for(i=0;i<44;i++) {
            sas_store(BIOS_NEC98_DISK_INT+i, 0x00);
        }
        sas_storew(BIOS_NEC98_CA_TIM_CNT, 0x0000);
        sas_storew(BIOS_NEC98_DISK_WORK, 0x0000);
        sas_storew(BIOS_NEC98_DISK_SEG, 0x0000);
        sas_store(BIOS_NEC98_HDSK_MOD2, 0x00);
        sas_store(BIOS_NEC98_DMA_ALLOC_TBL, 0x00);
        sas_store(BIOS_NEC98_NMI_STATUS1, 0x00);
        sas_store(BIOS_NEC98_NMI_STATUS2, 0x00);
        sas_storew(BIOS_NEC98_EXPMMSZ2, 0x0000);
        sas_storew(BIOS_NEC98_SLOW_GEAR, 0x0000);
        sas_store(BIOS_NEC98_PRXCRT2, 0x00);
        sas_storew(BIOS_NEC98_AT_TIME, 0x0000);
        sas_storew(BIOS_NEC98_AT_MOFF, 0x0000);
        sas_storew(BIOS_NEC98_RDISK_BANK, 0x0000);
        sas_store(BIOS_NEC98_CTRL_FLAG, 0x00);
        sas_store(BIOS_NEC98_SCLK_COUNT, 0x00);
        sas_store(BIOS_NEC98_SAVE_MODE, 0x00);
        sas_storew(BIOS_NEC98_SAVE_COUNT, 0x0000);
        sas_store(BIOS_NEC98_FD_READY_STS, 0x00);
        sas_store(BIOS_NEC98_CARD_STATUS, 0x00);
        sas_store(BIOS_NEC98_CARD_STATUS2, 0x00);
        sas_store(BIOS_NEC98_CARD_EQUIP, 0x00);
        sas_store(BIOS_NEC98_RS_D_FLAG, 0x00);
        sas_storew(BIOS_NEC98_GPIBWORK, 0x0000);
        sas_storew(BIOS_NEC98_GPIBWORK+2, 0x0000);
        sas_storew(BIOS_NEC98_KB_CODE, 0x0000);
        sas_storew(BIOS_NEC98_KB_CODE+2, 0x0000);
        sas_store(BIOS_NEC98_F2DD_MODE, 0xFF);
        sas_store(BIOS_NEC98_F2DD_COUNT, 0x96);
        sas_storew(BIOS_NEC98_F2DD_POINTER, 0x0000);
        sas_storew(BIOS_NEC98_F2DD_POINTER+2, 0x0000);
        for(i=0;i<16;i++) {
            sas_store(BIOS_NEC98_F2DD_RESULT+i, 0x00);
        }
        sas_storew(BIOS_NEC98_MUSIC_WORK, 0x0000);
        sas_storew(BIOS_NEC98_MUSIC_WORK+2, 0x0000);
        sas_store(BIOS_NEC98_V_VOL_TYPE, 0x00);
        sas_store(BIOS_NEC98_OMNI_SERVER, 0x00);
        sas_store(BIOS_NEC98_OMNI_STATION, 0x00);
        sas_storew(BIOS_NEC98_DISK_PRM0, 0x0000);
        sas_storew(BIOS_NEC98_DISK_PRM0+2, 0x0000);
        sas_storew(BIOS_NEC98_DISK_PRM1, 0x0000);
        sas_storew(BIOS_NEC98_DISK_PRM1+2, 0x0000);
        sas_storew(BIOS_NEC98_RS_CH1_OFST, 0x0000);
        sas_storew(BIOS_NEC98_RS_CH1_SEG, 0x0000);
        sas_storew(BIOS_NEC98_RS_CH2_OFST, 0x0000);
        sas_storew(BIOS_NEC98_RS_CH2_SEG, 0x0000);
        sas_storew(BIOS_NEC98_F2HD_POINTER, 0x0000);
        sas_storew(BIOS_NEC98_F2HD_POINTER+2, 0x0000);
        sas_storew(BIOS_NEC98_MOUSEW, 0x0000);
        sas_storew(BIOS_NEC98_BASIC_LDSR, 0x0000);

        sas_store(BIOS_NEC98_BIOS_FLAG, 0x00);
        sas_store(BIOS_NEC98_BIOS_FLAG1, 0x03);
        sas_store(BIOS_NEC98_BIOS_FLAG3, (save481h&0x03)|0x44);
        sas_store(BIOS_NEC98_BIOS_FLAG5, 0x00);
        sas_store(BIOS_NEC98_BIOS_FLAG6, 0x00);
        sas_store(BIOS_NEC98_BIOS_FLAG7, 0x00);
        sas_store(BIOS_NEC98_BIOS_FLAG8, 0x00);

        if(bas_clock == 0){
            sas_store(BIOS_NEC98_BIOS_FLAG+1, 0x2D);
            sas_store(BIOS_NEC98_BIOS_FLAG2, 0x10);
            sas_store(BIOS_NEC98_BIOS_FLAG4, save484h&0xf0);
        } else {
            sas_store(BIOS_NEC98_BIOS_FLAG+1, 0xAD);
            sas_store(BIOS_NEC98_BIOS_FLAG2, 0x12);
            sas_store(BIOS_NEC98_BIOS_FLAG4, save484h&0xf0|0x02);
        }

        expmemsz = config_inquire(C_EXTENDED_MEM_SIZE, NULL);
        expmemsz1 = expmemsz % 16;
        expmemsz2 = expmemsz - expmemsz1;
        expmemsz1 = expmemsz1 * 8;
        sas_store(BIOS_NEC98_EXPMMSZ,(half_word)expmemsz1);
        sas_store(BIOS_NEC98_EXPMMSZ2,(half_word)expmemsz2);

   } else {
        sas_store(BIOS_NEC98_SYS_SEL, 0x00);
        sas_store(BIOS_NEC98_WIN_386, 0x00);
        sas_storew(BIOS_NEC98_USER_SP, 0x0000);
        sas_storew(BIOS_NEC98_USER_SS, 0x0000);
        sas_store(BIOS_NEC98_KB_SHIFT_COD, 0x00);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+1, 0x00);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+2, 0x00);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+3, 0x00);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+4, 0x00);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+5, 0x00);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+6, 0x00);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+7, 0x00);
        sas_storew(BIOS_NEC98_KB_BUFFER_ADR, 0x0000);
        sas_storew(BIOS_NEC98_KB_BUFFER_ADR+2, 0x0000);
        sas_storew(BIOS_NEC98_KB_ENTRY_TBL_ADR, 0x0000);
        sas_storew(BIOS_NEC98_KB_ENTRY_TBL_ADR+2, 0x0000);
        sas_storew(BIOS_NEC98_KB_INT_ADR, 0x0000);
        sas_storew(BIOS_NEC98_KB_INT_ADR+2, 0x0000);
        sas_storew(BIOS_NEC98_PR_TIME, 0x0001);
        sas_store(BIOS_NEC98_VD_PRT, 0x00);
        sas_store(BIOS_NEC98_VD_PRT+1, 0x00);
        sas_store(BIOS_NEC98_VD_PRT+2, 0x00);
        sas_store(BIOS_NEC98_VD_PRT+3, 0x00);
        sas_store(BIOS_NEC98_VD_PRT+4, 0x00);
        sas_store(BIOS_NEC98_VD_NUL, 0x00);
        sas_storew(BIOS_NEC98_VD_REMAIN_SEC, 0x0000);
        sas_storew(BIOS_NEC98_VD_REMAIN_LEN, 0x0000);
        sas_storew(BIOS_NEC98_VD_DATA_OFF, 0x0000);
        sas_store(BIOS_NEC98_VDISK_EQUIP, 0x00);
        sas_store(BIOS_NEC98_BRANCH_INT, 0x00);
        sas_storew(BIOS_NEC98_BRANCH_WORK, 0x0000);
        sas_storew(BIOS_NEC98_BRANCH_WORK+2, 0x0000);
        for(i=0;i<16;i++) {
             sas_store(BIOS_NEC98_VD_BOOT_WORK+i, 0x00);
        }
        sas_storew(BIOS_NEC98_VD_ADD, 0x0000);
        sas_storew(BIOS_NEC98_VD_ADD+2, 0x0000);
        sas_storew(BIOS_NEC98_CAL_ROOT_LST, 0x0000);
        sas_storew(BIOS_NEC98_CAL_ROOT_LST+2, 0x0000);
        sas_storew(BIOS_NEC98_CAL_BEEP_TIME, 0x0000);
        sas_storew(BIOS_NEC98_CAL_TONE, 0x0000);
        sas_storew(BIOS_NEC98_CAL_USER_OFF, 0x0000);
        sas_storew(BIOS_NEC98_CAL_USER_SEG, 0x0000);
        sas_storew(BIOS_NEC98_CRT_FONT, 0x0000);
        sas_store(BIOS_NEC98_CRT_P1, 0x00);
        sas_store(BIOS_NEC98_CRT_P2, 0x00);
        sas_store(BIOS_NEC98_CRT_P3, 0x00);
        sas_store(BIOS_NEC98_MODE_CONTROL, 0x00);
        sas_store(BIOS_NEC98_IN_BIOS, 0x00);
        sas_store(BIOS_NEC98_AT_SWITCH, 0x00);
        sas_store(BIOS_NEC98_CR_EXT_STS, 0x00);
        sas_store(BIOS_NEC98_SCSI_WORK, 0x00);
        sas_store(BIOS_NEC98_F2HD_TIME, 0x17);
        sas_store(BIOS_NEC98_CPU_STEP, 0x05);
        sas_store(BIOS_NEC98_CPU_STEP+1, 0x03);
        sas_store(BIOS_NEC98_RDISK_EQUIP, 0x00);
        sas_store(BIOS_NEC98_RDISK_EXIT, 0x00);
        sas_storew(BIOS_NEC98_RDISK_EXIT+1, 0x0000);
        sas_storew(BIOS_NEC98_RDISK_EXIT+3, 0x0000);
        sas_store(BIOS_NEC98_RDISK_STATUS, 0x00);
        sas_store(BIOS_NEC98_OMNI_FLAG, 0x00);
        sas_storew(BIOS_NEC98_BEEP_TONE, 0x0000);
        sas_store(BIOS_NEC98_DISK_RESET, 0xFF);
//        sas_store(BIOS_NEC98_F2HD_MODE, 0xFF);
        sas_store(BIOS_NEC98_GRAPH_CHG, 0x00);
        sas_storew(BIOS_NEC98_GRAPH_TAI, 0x0000);
        sas_storew(BIOS_NEC98_GRAPH_TAI+2, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_INTB1, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_B1OF, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_B2SE, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_INT1B, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_1BOF, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_1BSE, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_INT1A, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_1AOF, 0x0000);
        sas_storew(BIOS_NEC98_OMNI_1ASE, 0x0000);
        sas_storew(BIOS_NEC98_XROM_PTR, 0x0000);
        sas_storew(BIOS_NEC98_XROM_PTR+2, 0x0000);
        for(i=0;i<16;i++) {
            sas_store(BIOS_NEC98_DISK_XROM+i, 0x00);
        }
        for(i=0;i<56;i++) {
            sas_store(BIOS_NEC98_XROM_ID+i, 0x00);
        }
        sas_storew(BIOS_NEC98_ROM_XCHG, 0x0000);
        sas_storew(BIOS_NEC98_ROM_OFS, 0x0000);
        sas_storew(BIOS_NEC98_ROM_SEG, 0x0000);
        sas_storew(BIOS_NEC98_SCLK_USER, 0x0000);
        for(i=0;i<32;i++) {
            sas_store(BIOS_NEC98_KB_BUF+i, 0x00);
        }
        sas_storew(BIOS_NEC98_KB_SHFT_TBL, 0x0BE8);
        sas_storew(BIOS_NEC98_KB_BUF_HEAD, 0x0000);
        sas_storew(BIOS_NEC98_KB_BUF_TAIL, 0x0000);
        sas_store(BIOS_NEC98_KB_COUNT, 0x00);
        sas_store(BIOS_NEC98_KB_RETRY, 0x00);
        for(i=0;i<16;i++) {
            sas_store(BIOS_NEC98_KB_KY_STS+i, 0x00);
        }
        sas_store(BIOS_NEC98_KB_SHFT_STS, 0x00);
//      for(i=0;i<17;i++) {
//          sas_store(BIOS_NEC98_CR_RASTER+i, 0x00);
//      }
        sas_store(BIOS_NEC98_PRXCRT, sas_hw_at(BIOS_NEC98_PRXCRT) & 0x7F);
        sas_store(BIOS_NEC98_PRXDUPD, sas_hw_at(BIOS_NEC98_PRXDUPD) & 0x7F);
        if(video_emu_mode) {
            sas_store(BIOS_NEC98_PRXCRT, sas_hw_at(BIOS_NEC98_PRXCRT) & ~0x02);
            sas_store(BIOS_NEC98_PRXDUPD, sas_hw_at(BIOS_NEC98_PRXDUPD) & ~0x40);
        }
        sas_storew(BIOS_NEC98_PRXGCPTN, 0x0000);
        sas_storew(BIOS_NEC98_PRXGCPTN+2, 0x0000);
        sas_storew(BIOS_NEC98_PRXGCPTN+4, 0x0000);
        sas_storew(BIOS_NEC98_PRXGCPTN+6, 0x0000);
        sas_storew(BIOS_NEC98_RS_OFST_ADR, 0x0000);
        sas_storew(BIOS_NEC98_RS_SEG_ADR, 0x0000);
        sas_store(BIOS_NEC98_RS_SIFT, 0x00);
        sas_store(BIOS_NEC98_RS_S_FLAG, 0x00);
        for(i=0;i<44;i++) {
            sas_store(BIOS_NEC98_DISK_INT+i, 0x00);
        }
        sas_storew(BIOS_NEC98_CA_TIM_CNT, 0x0000);
        sas_storew(BIOS_NEC98_DISK_WORK, 0x0000);
        sas_storew(BIOS_NEC98_DISK_SEG, 0x0000);
        sas_store(BIOS_NEC98_HDSK_MOD2, 0x00);
        sas_store(BIOS_NEC98_DMA_ALLOC_TBL, 0x00);
        sas_store(BIOS_NEC98_NMI_STATUS1, 0x00);
        sas_store(BIOS_NEC98_NMI_STATUS2, 0x00);
        sas_storew(BIOS_NEC98_EXPMMSZ2, 0x0000);
        sas_storew(BIOS_NEC98_SLOW_GEAR, 0x0000);
        sas_store(BIOS_NEC98_PRXCRT2, 0x00);
        sas_storew(BIOS_NEC98_AT_TIME, 0x0000);
        sas_storew(BIOS_NEC98_AT_MOFF, 0x0000);
        sas_storew(BIOS_NEC98_RDISK_BANK, 0x0000);
        sas_store(BIOS_NEC98_CTRL_FLAG, 0x00);
        sas_store(BIOS_NEC98_SCLK_COUNT, 0x00);
        sas_store(BIOS_NEC98_SAVE_MODE, 0x00);
        sas_storew(BIOS_NEC98_SAVE_COUNT, 0x0000);
        sas_store(BIOS_NEC98_FD_READY_STS, 0x00);
        sas_store(BIOS_NEC98_CARD_STATUS, 0x00);
        sas_store(BIOS_NEC98_CARD_STATUS2, 0x00);
        sas_store(BIOS_NEC98_CARD_EQUIP, 0x00);
        sas_store(BIOS_NEC98_RS_D_FLAG, 0x00);
        sas_storew(BIOS_NEC98_GPIBWORK, 0x0000);
        sas_storew(BIOS_NEC98_GPIBWORK+2, 0x0000);
        sas_storew(BIOS_NEC98_KB_CODE, 0x0000);
        sas_storew(BIOS_NEC98_KB_CODE+2, 0x0000);
        sas_store(BIOS_NEC98_F2DD_MODE, 0xFF);
        sas_store(BIOS_NEC98_F2DD_COUNT, 0x96);
        sas_storew(BIOS_NEC98_F2DD_POINTER, 0x0000);
        sas_storew(BIOS_NEC98_F2DD_POINTER+2, 0x0000);
        for(i=0;i<16;i++) {
            sas_store(BIOS_NEC98_F2DD_RESULT+i, 0x00);
        }
        sas_storew(BIOS_NEC98_MUSIC_WORK, 0x0000);
        sas_storew(BIOS_NEC98_MUSIC_WORK+2, 0x0000);
        sas_store(BIOS_NEC98_V_VOL_TYPE, 0x00);
        sas_store(BIOS_NEC98_OMNI_SERVER, 0x00);
        sas_store(BIOS_NEC98_OMNI_STATION, 0x00);
        sas_storew(BIOS_NEC98_DISK_PRM0, 0x0000);
        sas_storew(BIOS_NEC98_DISK_PRM0+2, 0x0000);
        sas_storew(BIOS_NEC98_DISK_PRM1, 0x0000);
        sas_storew(BIOS_NEC98_DISK_PRM1+2, 0x0000);
        sas_storew(BIOS_NEC98_RS_CH1_OFST, 0x0000);
        sas_storew(BIOS_NEC98_RS_CH1_SEG, 0x0000);
        sas_storew(BIOS_NEC98_RS_CH2_OFST, 0x0000);
        sas_storew(BIOS_NEC98_RS_CH2_SEG, 0x0000);
        sas_storew(BIOS_NEC98_F2HD_POINTER, 0x0000);
        sas_storew(BIOS_NEC98_F2HD_POINTER+2, 0x0000);
        sas_storew(BIOS_NEC98_MOUSEW, 0x0000);
        sas_storew(BIOS_NEC98_BASIC_LDSR, 0x0000);

        sas_store(BIOS_NEC98_BIOS_FLAG, 0x03);
        sas_store(BIOS_NEC98_BIOS_FLAG1, 0xc3);
        sas_store(BIOS_NEC98_BIOS_FLAG3, (save481h&0x03)|0x60);
        sas_store(BIOS_NEC98_BIOS_FLAG5, 0x00);
        sas_store(BIOS_NEC98_BIOS_FLAG6, 0x00);
        sas_store(BIOS_NEC98_BIOS_FLAG7, 0x00);
        sas_store(BIOS_NEC98_BIOS_FLAG8, 0x00);

        if(bas_clock == 0){
            sas_store(BIOS_NEC98_BIOS_FLAG+1, 0x24);
            sas_store(BIOS_NEC98_BIOS_FLAG2, 0x10);
            sas_store(BIOS_NEC98_BIOS_FLAG4, save484h&0xf0);
        } else {
            sas_store(BIOS_NEC98_BIOS_FLAG+1, 0xA4);
            sas_store(BIOS_NEC98_BIOS_FLAG2, 0x12);
            sas_store(BIOS_NEC98_BIOS_FLAG4, save484h&0xf0|0x02);
        }

        expmemsz = config_inquire(C_EXTENDED_MEM_SIZE, NULL);
//        expmemsz1 = expmemsz % 16;
//        expmemsz2 = expmemsz - expmemsz1;
//        expmemsz1 = expmemsz1 * 8;
// FIX: WOW memory size calculate - START
        if(expmemsz < 2)
        {
            expmemsz1 = 1;
            expmemsz2 = 0;
        }
        else if(expmemsz <= 16)
        {
            expmemsz1 = (expmemsz - 1) * 8;
            expmemsz2 = 0;
        }
        else
        {
            expmemsz1 = 15 * 8;
            expmemsz2 = expmemsz - 16;
        }
// FIX: WOW memory size calculate - END
        sas_store(BIOS_NEC98_EXPMMSZ,(half_word)expmemsz1);
        sas_store(BIOS_NEC98_EXPMMSZ2,(half_word)expmemsz2);
   }
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\rom_basc.c ===
#include "insignia.h"
#include "host_def.h"
/*[
	Name:		rom_basic.c
	Derived From:	Base 1.0
	Author:		David Rees.
	Created On:	Unknown
	Sccs ID:	08/03/93 @(#)rom_basic.c	1.7
	Purpose:	A function which reports an error when an attempt
			is made to run ROM BASIC.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_SUPPORT.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "host.h"
#include "error.h"
#include "sas.h"


void rom_basic()
{
	host_error(EG_NO_ROM_BASIC, ERR_CONT, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\cntlbop.c ===
#include "insignia.h"
#include "host_def.h"
/*
==========================================================================
			INSIGNIA MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DESIGNER		: J. Koprowski

REVISION HISTORY	:
First version		: 18th January 1989

MODULE NAME		: cntlbop

SOURCE FILE NAME	: cntlbop.c

SCCS ID                 : @(#)cntlbop.c	1.12 05/15/95

PURPOSE			: Supply a BOP FF function for implementation
			  of various control functions, which may be
			  base or host specific.

==========================================================================
*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "AT_STUFF.seg"
#endif

#include TypesH
#include "xt.h"
#include CpuH
#include "host.h"
#include "cntlbop.h"
#include "host_bop.h"

#ifdef SCCSID
static char SccsID[] = "@(#)cntlbop.c	1.12 05/15/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SECURE
void end_secure_boot IPT0();
#endif

#if defined(RUNUX)
IMPORT void runux IPT0();
#endif

static control_bop_array base_bop_table[] =
{
#ifdef SECURE
     9, end_secure_boot,
#endif
#if defined(RUNUX)
     8, runux,			/* BCN 2328 run a host (unix) script file */
#endif
#if defined(DUMB_TERMINAL) && !defined(NO_SERIAL_UIF)
     7, flatog,
#ifdef FLOPPY_B
     6, flbtog,
#endif /* FLOPPY_B */
#ifdef SLAVEPC
     5, slvtog,
#endif /* SLAVEPC */
     4, comtog,
     3, D_kyhot,             /* Flush the COM/LPT ports */
     2, D_kyhot2,            /* Rock the screen         */
#endif /* DUMB_TERMINAL && !NO_SERIAL_UIF */
#ifndef NTVDM
     1,	exitswin,
#endif
     0,	NULL
};



/*
==========================================================================
FUNCTION	:	do_bop
PURPOSE		:	Look up bop function and execute it.
EXTERNAL OBJECTS:	None
RETURN VALUE	:	(in AX)
                        ERR_NO_FUNCTION
                        Various codes according to the subsequent function
                        called.

INPUT  PARAMS	:	struct control_bop_array *bop_table[]
                        function code (in AL)
RETURN PARAMS   :	None
==========================================================================
*/

static void do_bop IFN1(control_bop_array *, bop_table)
{
    unsigned int i;
/*
 * Search for the function in the table.
 * If found, call it, else return error.
 */
    for (i = 0; (bop_table[i].code != getAL()) && (bop_table[i].code != 0); i++)
        ;
    if (bop_table[i].code == 0)
    	setAX(ERR_NO_FUNCTION);
    else
        (*bop_table[i].function)();
}


/*
=========================================================================
PROCEDURE	  : 	control_bop()

PURPOSE		  : 	Execute a BOP FF control function.
		
PARAMETERS	  : 	AH - Host type.
			AL - Function code
			(others are function specific)
			
GLOBALS		  :	None

RETURNED VALUE	  : 	(in AX) 0 - Success
				1 - Function not implemented (returned by
				    do_bop)
				2 - Wrong host type
				Other error codes can be returned by the
				individual functions called.

DESCRIPTION	  : 	Invokes a base or host specific BOP function.

ERROR INDICATIONS :	Error code returned in AX

ERROR RECOVERY	  :	No call made
=========================================================================
*/

void control_bop IPT0()
{
    unsigned long host_type;

/*
 * If the host type is generic then look up the function in the
 * base bop table, otherwise see if the function is specific to the
 * host that we are running on.  If it is then look up the function
 * in the host bop table, otherwise return an error.
 */
    if ((host_type = getAH()) == GENERIC)
        do_bop(base_bop_table);
    else
        if (host_type == HOST_TYPE)
            do_bop(host_bop_table);
        else
       	    setAX(ERR_WRONG_HOST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\equipmnt.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: equipment.c
 *
 * Description	: BIOS equipment function.  Returns a word containing
 *		  a bit pattern representing the equipment supported
 *		  by the virtual bios.
 *
 * Author	: Henry Nash / David Rees
 *
 * Notes	: Now reads the word from the appropriate place within
 *                the BIOS data area (40:10H).
 */

/*
 * static char SccsID[]="@(#)equipment.c	1.6 08/03/93 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "bios.h"
#include "sas.h"
#include "equip.h"

void equipment()
{
    EQUIPMENT_WORD equip_flag;

    sas_loadw(EQUIP_FLAG, &equip_flag.all);
    setAX(equip_flag.all);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\cmos_bis.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA MODULE SPECIFICATION
			-----------------------------

MODULE NAME	: Bios code for accessing the cmos

	THIS PROGRAM SOURCE FILE IS SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF ITS OPERATION MAY
	ONLY BE DISCLOSED TO PERSONS EMPLOYED BY THE CUSTOMER WHO
	REQUIRE A KNOWLEDGE OF THE  SOFTWARE  CODING TO CARRY OUT
	THEIR JOB. DISCLOSURE TO ANY OTHER PERSON MUST HAVE PRIOR
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: September '88

PURPOSE		: To provide routines to initialise and access the
		CMOS

The Following Routines are defined:
		1. set_tod
		2. cmos_read
		3. cmos_write

=========================================================================

AMENDMENTS	:

=========================================================================
*/

/*
 * static char SccsID[]="@(#)cmos_bios.c	1.7 08/25/93 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_CMOS.seg"
#endif

#include "xt.h"
#include "bios.h"
#include "sas.h"
#include "cmos.h"
#include "cmosbios.h"
#include "ios.h"
#include "rtc_bios.h"

#ifndef NTVDM
/*
=========================================================================

FUNCTION	: set_tod

PURPOSE		: Reads the time from the CMOS and sets the timer
		data area in the BIOS

RETURNED STATUS	: None

DESCRIPTION	:


=======================================================================
*/
#define BCD_TO_BIN( n )		((n & 0x0f) + (((n >> 4) & 0x0f) * 10))

void set_tod()
{
	half_word	value;		/* time value read from CMOS	*/
	DOUBLE_TIME	timer_tics;	/* time converted to ticks	*/
	double_word	tics_temp;	/* prevent floating point code  */
	
	/* set data area to 0 in case of error return	*/
	sas_storew(TIMER_LOW, 0);
	sas_storew(TIMER_HIGH, 0);
	sas_store(TIMER_OVFL, 0);
	
	/* read seconds	*/
	value = cmos_read( CMOS_SECONDS + NMI_DISABLE );
	if( value > 0x59)
	{
		value = cmos_read( CMOS_DIAG + NMI_DISABLE );
		cmos_write( CMOS_DIAG + NMI_DISABLE, (value | CMOS_CLK_FAIL) );
		return;
	}
	tics_temp = BCD_TO_BIN( value ) * 73;	/* was 18.25 */
	tics_temp /= 4;
	timer_tics.total = tics_temp;
	
	/* read minutes	*/
	value = cmos_read( CMOS_MINUTES + NMI_DISABLE );
	if( value > 0x59)
	{
		value = cmos_read( CMOS_DIAG + NMI_DISABLE );
		cmos_write( CMOS_DIAG + NMI_DISABLE, (value | CMOS_CLK_FAIL) );
		return;
	}
	tics_temp = BCD_TO_BIN( value ) * 2185;	/* was 1092.5 */
	tics_temp /= 2;
	timer_tics.total += tics_temp;

	/* read hours	*/
	value = cmos_read( CMOS_HOURS + NMI_DISABLE );
	if( value > 0x23)
	{
		value = cmos_read( CMOS_DIAG + NMI_DISABLE );
		cmos_write( CMOS_DIAG + NMI_DISABLE, (value | CMOS_CLK_FAIL) );
		return;
	}
	timer_tics.total += BCD_TO_BIN( value ) * 65543L;

	/* write total to bios data area	*/
	
	sas_storew(TIMER_LOW, timer_tics.half.low);
	sas_storew(TIMER_HIGH, timer_tics.half.high);
	
	return;
}
#endif


/*
=========================================================================

FUNCTION	: cmos_read

PURPOSE		: Reads a byte from the cmos system clock configuration table
		from the CMOS address specified

RETURNED STATUS	: The value read from the CMOS

DESCRIPTION	:


=======================================================================
*/
half_word cmos_read(table_address)

/*   IN  */
half_word table_address;		/* cmos table address to be read	*/

{
	half_word	value;		/* value read from cmos			*/
	
	outb( CMOS_PORT, (IU8)(table_address | NMI_DISABLE) );
	
	inb( CMOS_DATA, &value );
	
	/*
	 * Set bit 7 if it was previously set  in table_address
	 */
	outb( CMOS_PORT, (IU8)((CMOS_SHUT_DOWN | (table_address & NMI_DISABLE))) );
	
	return ( value );
}

/*
=========================================================================

FUNCTION	: cmos_read

PURPOSE		: Writes a byte to the cmos system clock configuration table
		at the CMOS address specified

RETURNED STATUS	: none

DESCRIPTION	:


=======================================================================
*/
void cmos_write(table_address, value)
/*  IN  */
half_word table_address,		/* cmos table address to be written	*/
	  value;			/* value to be written			*/

{
	outb( CMOS_PORT, (IU8)((table_address | NMI_DISABLE)) );

	outb( CMOS_DATA, value );
	
	/*
	 * Set bit 7 if it was previously set  in table_address
	 */
	outb( CMOS_PORT, (IU8)((CMOS_SHUT_DOWN | (table_address & NMI_DISABLE))) );
	
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\emm_fncs.c ===
#include "insignia.h"
#include "host_def.h"

#ifdef	SUN_VA
#define		MAXPATHLEN	1024
#define		NL			0x0a
#define		CR			0x0d
#include	<ctype.h>
#endif

/*			INSIGNIA MODULE SPECIFICATION
			-----------------------------

MODULE NAME	: 'Top layer' of Expanded Memory Manager

	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: May '88

PURPOSE		: Contains all the top level calls to the Expanded
		Memory Manager. Data is received and returned to the
		calling application via Intel registers		

The Following Routines are defined:
		0. emm_io()
		1. Get_Status()
		2. Get_Page_Frame_Address()
		3. Get_Unallocated_Page()
		4. Allocate_Pages()
		5. Map_Unmap_Handle_Page()
		6. Deallocate_Pages()
		7. Get_Version()
		8. Save_Page_Map()
		9. Restore_Page_Map()
		10. Reserved()
		12. Get_Handle_Count()
		13. Get_Handle_pages()
		14. Get_All_Handle_Pages()
		15. Get_Set_Page_Map()
		16. Get_Set_Partial_Page_Map()
		17. Map_Unmap_Multiple_Handle_Pages()
		18. Reallocate_Pages()
		19. Get_Set_Handle_Attribute()
		20. Get_Set_Handle_Name()
		21. Get_Handle_Directory()
		22. Alter_Page_Map_And_Jump()
		23. Alter_Page_Map_And_Call()
		24. Move_Exchange_Memory_Region()
		25. Get_Mappable_Physical_Address_Array()
		26. Get_Hardware_Configuration_Array()
		27. Allocate_Raw_Pages()
		28. Alternate_Map_Register_Support()
		29. Prepare_Expanded_Memory_HW_For_Warm_Boot()
		30. Enable_Disable_OSE_Function_Set_Functions()
		31. reset_emm_funcs()		

=========================================================================

AMMENDMENTS	:

=========================================================================
*/
#ifdef LIM


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_LIM.seg"
#endif


#include <stdio.h>
#include TypesH
#include <string.h>
#include TimeH

#include "xt.h"
#include "sas.h"
#include CpuH
#include "emm.h"
#if defined(SUN_VA) || defined(NTVDM)
#include "error.h"
#include "config.h"
#endif	/* SUN or NTVDM */
#include "timeval.h"
#include "debug.h"
#ifndef PROD
#include "trace.h"
#endif
#include "timer.h"
#include <error.h>
#include "gisp_sas.h"

/*	Global Variables		*/
#ifdef SCCSID
static char SccsID[]="@(#)emm_funcs.c	1.27 2/22/94 Copyright Insignia Solutions Ltd.";
#endif

/*	Forward Declarations		*/

/*	External Declarations		*/
IMPORT void dma_lim_setup IPT0();
IMPORT void host_get_access_key IPT1(unsigned short *, access_key);

#if defined(A2CPU) && defined(DELTA)
IMPORT void reset_delta_data_structures IPT0();
#endif /* A2CPU && DELTA */

/*	Local Variables			*/
static short	map_on_return[MAX_NO_PAGES];	/* list of pages to be	*/
					/* mapped on return from func 23*/

static unsigned short	segment68,	/* segment address of BOP 0x68	*/
			offset68;	/* offset address of BOP 0x68	*/

static boolean disabled = FALSE;	/* flag used to disable funcs.	*/
					/* 26, 28 and 30		*/

static unsigned short alt_map_segment,	/* segment address of map array	*/
		      alt_map_offset;	/* offset of map array		*/
		      			/* in function 28		*/

#ifndef NTVDM
static boolean set_called;		/* flag to indicate if the 'set'*/
					/* sub-function has been called */
					/* in function 28		*/

#endif

#ifndef PROD
static FILE *fp;
static boolean trace_flag = FALSE;
#endif

/* 	Internal Function Declarations	*/

LOCAL void Get_Status();
LOCAL void Get_Page_Frame_Address();
LOCAL void Get_Unallocated_Page_Count();
LOCAL void Allocate_Pages();
LOCAL void Map_Unmap_Handle_Pages();
LOCAL void Deallocate_Pages();
LOCAL void Get_Version();
LOCAL void Save_Page_Map();
LOCAL void Restore_Page_Map();
LOCAL void Reserved();
LOCAL void Get_Handle_Count();
LOCAL void Get_Handle_Pages();
LOCAL void Get_All_Handle_Pages();
LOCAL void Get_Set_Page_Map();
LOCAL void Get_Set_Partial_Page_Map();
LOCAL void Map_Unmap_Multiple_Handle_Pages();
LOCAL void Reallocate_Pages();
LOCAL void Get_Set_Handle_Attribute();
LOCAL void Get_Set_Handle_Name();
LOCAL void Get_Handle_Directory();
LOCAL void Alter_Page_Map_And_Jump();
LOCAL void Alter_Page_Map_And_Call();
LOCAL void Move_Exchange_Memory_Region();
LOCAL void Get_Mappable_Physical_Address_Array();
LOCAL void Get_Hardware_Configuration_Array();
LOCAL void Allocate_Raw_Pages();
LOCAL void Alternate_Map_Register_Support();
LOCAL void Prepare_Expanded_Memory_HW_For_Warm_Boot();
LOCAL void Enable_Disable_OSE_Function_Set_Functions();
LOCAL void Increment_Address IPT4(unsigned short *,seg_or_page,
			      unsigned short *,offset,
			      unsigned long, increment_by,
			      unsigned char, memory_type);
#ifndef PROD
LOCAL void Start_Trace();
LOCAL void End_Trace();
#endif

#if defined(NEC_98)
LOCAL void Page_Frame_Bank_Status();
#endif // NEC_98

void (*emm_func[]) () = {
	Get_Status,
	Get_Page_Frame_Address,
	Get_Unallocated_Page_Count,
	Allocate_Pages,
	Map_Unmap_Handle_Pages,
	Deallocate_Pages,
	Get_Version,
	Save_Page_Map,
	Restore_Page_Map,
	Reserved,
	Reserved,
	Get_Handle_Count,
	Get_Handle_Pages,
	Get_All_Handle_Pages,
	Get_Set_Page_Map,
	Get_Set_Partial_Page_Map,
	Map_Unmap_Multiple_Handle_Pages,
	Reallocate_Pages,
	Get_Set_Handle_Attribute,
	Get_Set_Handle_Name,
	Get_Handle_Directory,
	Alter_Page_Map_And_Jump,
	Alter_Page_Map_And_Call,
	Move_Exchange_Memory_Region,
	Get_Mappable_Physical_Address_Array,
	Get_Hardware_Configuration_Array,
	Allocate_Raw_Pages,
	Alternate_Map_Register_Support,
	Prepare_Expanded_Memory_HW_For_Warm_Boot,
	Enable_Disable_OSE_Function_Set_Functions
#ifndef PROD
	,Start_Trace,
	End_Trace
#endif
	};

#ifndef PROD
char *func_names[] = {
	"Get_Status",
	"Get_Page_Frame_Address",
	"Get_Unallocated_Page_Count",
	"Allocate_Pages",
	"Map_Unmap_Handle_Pages",
	"Deallocate_Pages",
	"Get_Version",
	"Save_Page_Map",
	"Restore_Page_Map",
	"Reserved",
	"Reserved",
	"Get_Handle_Count",
	"Get_Handle_Pages",
	"Get_All_Handle_Pages",
	"Get_Set_Page_Map",
	"Get_Set_Partial_Page_Map",
	"Map_Unmap_Multiple_Handle_Pages",
	"Reallocate_Pages",
	"Get_Set_Handle_Attribute",
	"Get_Set_Handle_Name",
	"Get_Handle_Directory",
	"Alter_Page_Map_And_Jump",
	"Alter_Page_Map_And_Call",
	"Move_Exchange_Memory_Region",
	"Get_Mappable_Physical_Address_Array",
	"Get_Hardware_Configuration_Array",
	"Allocate_Raw_Pages",
	"Alternate_Map_Register_Support",
	"Prepare_Expanded_Memory_HW_For_Warm_Boot",
	"Enable_Disable_OSE_Function_Set_Functions"
#ifndef PROD
	,"Start_Trace",
	"End_Trace"
#endif
	};
#endif

/* Defintion of this is non-standard */

#ifndef min
#define min(a,b)	(((a)<(b)) ? (a) : (b))
#endif

/*
===========================================================================

FUNCTION	: emm_io

PURPOSE		: This is THE top level call to the EMM

RETURNED STATUS	: none

DESCRIPTION	: uses a function jump table to call the appropriate
		routine for each EMM function. The type of function is
		encoded into the AH register


=========================================================================
*/
GLOBAL void emm_io IFN0()

{	
	int func_num;

#if defined(NEC_98)
        if((getAH() >= MIN_FUNC_NO && getAH() <= MAX_FUNC_NO) || getAH() == 0x70) {
#else  // !NEC_98
	if(getAH() >= MIN_FUNC_NO && getAH() <= MAX_FUNC_NO) {
#endif // !NEC_98

		func_num = getAH() - MIN_FUNC_NO;

		sure_note_trace5(LIM_VERBOSE, "func %s - AX %#x BX %#x CX %#x DX %#x ",
		func_names[func_num],getAX(),getBX(),getCX(),getDX());

#ifdef EMM_DEBUG
		printf("emm_io entry: func=%s, AX=%x, BX=%x, CX=%x, DX=%x\n",
		       func_names[func_num],getAX(),getBX(),getCX(),getDX()
		      );
#endif
#if defined(NEC_98)
                if(getAH() == 0x70)
                        Page_Frame_Bank_Status();
                else
                        (*emm_func[func_num])();
#else  // !NEC_98
		(*emm_func[func_num])();	
#endif // !NEC_98

#ifdef EMM_DEBUG
		printf("emm_io exit: AX=%x, BX=%x, CX=%x, DX=%x\n",
		       getAX(),getBX(),getCX(),getDX()
		      );
#endif

		if (getAH() != SUCCESS) {
			sure_note_trace5(LIM_VERBOSE, "func %s failed - AX %#x BX %#x CX %#x DX %#x\n",
			func_names[func_num],getAX(),getBX(),getCX(),getDX());
		} else {
			sure_note_trace5(LIM_VERBOSE, "func %s succeeded - AX %#x BX %#x CX %#x DX %#x\n",
			func_names[func_num],getAX(),getBX(),getCX(),getDX());
		}

	} else {
		sure_note_trace1(LIM_VERBOSE,"Bad LIM call %#x\n", getAH());
		setAH(BAD_FUNC_CODE);
	}

}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

/*
===========================================================================

FUNCTION	: emm_init

PURPOSE		: This routine is called from the driver to pass back
		the address of the bop 68 (return_from_call) call and
		to find out how many pages have been installed

RETURNED STATUS	: none

DESCRIPTION	: DS:DX contains the segment:offset of the bop68 call
		the number of pages is returned in BX		

=========================================================================
*/


GLOBAL void emm_init IFN0()

{
	short	total_pages;

#ifdef GISP_SVGA
	/*
	 * Check whether LIM is possible.  If it isn't (because the page
	 * frame's already been used for the ROMs)
	 * warn the user, and bail out.
	 */
	
	if (LimBufferInUse()) {
		host_error(EG_NO_ROOM_FOR_LIM, ERR_CONT | ERR_QUIT, "");
		setBX((word)0);		/* return error to driver */
		return;
	}
#endif /* GISP_SVGA */

#ifdef	SUN_VA
	half_word	emm_all[256];
	half_word	*cptr;
	half_word	temp;
	int		i;
	int		found_mb = FALSE;
#endif
	
#if	defined(SUN_VA) || defined(NTVDM)
	SHORT limSize, backFill;
#endif

	segment68 = getDS();
	offset68 = getDX();

#ifdef	SUN_VA

	/*
	 * config.sys command line pointer is passed in the DI:DX registers
	  from the driver.
	 */

	ea  = effective_addr(getDI(), getCX());

	i = 0;
	do{
		sas_load(ea + i, &temp);
		emm_all[i] = temp;
		if (temp == '/'){
			found_mb = TRUE;
			cptr = &emm_all[i+1];		/* point to digit after flag	*/
		}
		i++;
	} while ( (temp != NULL)  && (temp != NL) && (temp != CR));
	emm_all[i-1] = NULL;				/* In cased it is not NULL	*/


	/*
	 * Search for #MB of EMM requested
	 */

	if ((found_mb == TRUE) && isdigit(*cptr) ) {
		temp = atoi(cptr);
	} else {								/* EMM size not specified	*/
		temp = 2;							/* default to 2MB			*/
	}

	/*
	 * Initialise the LIM
	 *
	 */
	if (limSize = (SHORT)config_inquire(C_LIM_SIZE, NULL)){
		backFill = 640;					/* We will always have at least 640k	*/
		limSize--;						/* Subtract 1M of regular DOS memory	*/	
		/*
		 * Check that we have enough raw memory for the EMM request.
		 * If not, set to the available memory size.
		 */
		if ( temp <= limSize)
			limSize = temp;

		while (init_expanded_memory(limSize, backFill) != SUCCESS )
		{
			free_expanded_memory();
			host_error(EG_EXPANDED_MEM_FAILURE, ERR_QU_CO, NULL);
		}
	}

#endif	/* SUN_VA	*/
#ifdef NTVDM	/* Similar to SUN_VA but without command line sizing */
	if ((limSize = (SHORT)config_inquire(C_LIM_SIZE, NULL)) && get_no_phys_pages())
	{
	    backFill = 640;
	    if (init_expanded_memory(limSize, backFill) == FAILURE)
	    {
		if (get_total_pages() == (short)0xffff)	/* config error */
		{
		    setBX((word)0xffff);	/* return error to driver */
		    return;
		}
		else
		{				/* out of memory */
		    setBX((word)0);		/* return error to driver */
		    return;
		}
	    }
	}

#endif	/* NTVDM */

	total_pages = get_total_pages();
	setBX(total_pages);

	/* Let the rest of SoftPC know that Expanded Memory is present
	 * and active
	 */
	if( total_pages )
	{
		dma_lim_setup();
#if defined(A2CPU) && defined(DELTA)
		reset_delta_data_structures();
#endif /* A2CPU && DELTA */
	}	
	return;
}	
	

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_LIM.seg"
#endif

/*
===========================================================================

FUNCTION	: Get_Status

PURPOSE		: Returns the status indicating whether the memory manager
		has been initialised successfuly

RETURNED STATUS	: in AH register
		SUCCESS - everything OK
		EMM_HW_ERROR - memory manager not initialised successfuly

DESCRIPTION	: checks the number of pages available

=========================================================================
*/
LOCAL void Get_Status IFN0()
{
	if(get_total_pages() == 0)
		setAH(EMM_HW_ERROR);
	else
		setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Get_Page_Frame_Address

PURPOSE		: Returns the segment address where the page frame is
		located

RETURNED STATUS	: in AH register
		SUCCESS - Allocation successful

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Page_Frame_Address IFN0()
{
	setBX(get_base_address());
	setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Get_Unallocated_Page_Count

PURPOSE		: Returns the number of unallocated (available) expanded
		memory pages and the total number of pages

RETURNED STATUS	: in AH register
		SUCCESS - Allocation successful

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Unallocated_Page_Count IFN0()
{
	setBX(get_unallocated_pages());
	setDX(get_total_pages());
	setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Allocate_Pages

PURPOSE		: Allocates a number of Expanded Memory Pages to the next
		available handle number

RETURNED STATUS	: in AH register
		SUCCESS - Allocation successful
		NOT_ENOUGH_PAGES - not enough pages in the system
		NO_MORE_PAGES - not enough free pages available
		NO_MORE_HANDLES - no more free handles available
		EMM_HW_ERROR - memory allocation error

DESCRIPTION	:

=========================================================================
*/
LOCAL void Allocate_Pages IFN0()
{
	short	handle_no,
		no_of_pages,		/* no of pages to be allocated	*/
		i,			/* loop counter			*/
		EM_page_no;		/* Expanded Memory page number	*/

	no_of_pages = getBX();
	if(get_total_open_handles() >= get_total_handles())
	{
		setAH(NO_MORE_HANDLES);
		return;
	}
	if(no_of_pages > get_total_pages())
	{
		setAH(NOT_ENOUGH_PAGES);
		return;
	}
	if(no_of_pages > get_unallocated_pages())
        {
		setAH(NO_MORE_PAGES);
		return;
	}
	if((handle_no = get_new_handle(no_of_pages)) == FAILURE)
	{
		setAH(EMM_HW_ERROR);
		return;
	}
	set_no_pages(handle_no, no_of_pages);

	for(i=0; i<no_of_pages; i++)
	{
		if ((EM_page_no = alloc_page()) == FAILURE)
		{
			setAH(EMM_HW_ERROR);
			return;
		}
		set_EMpage_no(handle_no, i, EM_page_no);
	}

	setDX(handle_no);
	setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Map_Unmap_Handle_Pages

PURPOSE		: maps and umaps the requested Expanded Memory pages into
		and out of Intel physical address space

RETURNED STATUS	: in AH register
		SUCCESS - Mapping/Unmapping successful
		BAD_HANDLE - couldn't find specified handle
		BAD_LOG_PAGE - invalid logical page number
		BAD_PHYS_PAGE - invalid physical page number
		EMM_HW_ERROR - unable to map/unmap for some unspecified
				reason

DESCRIPTION	:

=========================================================================
*/
LOCAL void Map_Unmap_Handle_Pages IFN0()
{
	short	handle_no,
		logical_page_no,	/* page no. within handle	*/
		EM_page_no,		/* Expanded memory page		*/
		no_of_pages;		/* No. of pages in handle	*/
	unsigned char
		physical_page_no;	/* page no. in Intel physical	*/
		 			/* address space		*/

	handle_no = getDX();
	physical_page_no = getAL();
	logical_page_no = getBX();

	if(!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}
	if(physical_page_no >= get_no_phys_pages())
	{
		setAH(BAD_PHYS_PAGE);
		return;
	}
	no_of_pages = get_no_pages(handle_no);
	if((logical_page_no < -1) || (logical_page_no >= no_of_pages))
	{
		setAH(BAD_LOG_PAGE);
		return;
	}
	/*
	 * If you get to here, all parameters must be ok - so start mapping
	 */
	if(logical_page_no == -1)
	{
		/*
		 * Unmapping required
		 */
		if(unmap_page(physical_page_no) != SUCCESS)
		{
			setAH(EMM_HW_ERROR);
			return;
		}
	}
	else
	{
		/*
		 * Mapping required
		 */
		EM_page_no = get_EMpage_no(handle_no, logical_page_no);
		if(map_page(EM_page_no, physical_page_no) != SUCCESS)
		{
			setAH(EMM_HW_ERROR);
			return;
		}
	}
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Deallocate_Pages

PURPOSE		: Deallocates all pages assigned to the specified handle
		number, freeing them for further use, also frees the handle
		number itself.

RETURNED STATUS	: in AH register
		SUCCESS - Deallocation successful
		BAD_HANDLE - couldn't find specified handle
		MAP_SAVED - there is a map context saved in this handle
		EMM_HW_ERROR - unable to free page or memory

DESCRIPTION	:

=========================================================================
*/
LOCAL void Deallocate_Pages IFN0()

{
	short	handle_no,
		no_of_pages,		/* no of pages in handle	*/
		i,			/* loop counter			*/
		EM_page_no;		/* Expanded Memory page number	*/


	handle_no = getDX();

	if (!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}
	if(map_saved(handle_no))
	{
		setAH(MAP_SAVED);
		return;
	}
	/*
	 *	Free pages
	 */
	no_of_pages = get_no_pages(handle_no);
	for(i = 0; i < no_of_pages; i++)
	{
		EM_page_no = get_EMpage_no(handle_no, i);
		if (free_page(EM_page_no) != SUCCESS)
		{
			setAH(EMM_HW_ERROR);
			return;
		}
	}
	/*
	 *	free handle
	 */
	if (handle_no != 0)	/* reserved handle no	*/
		if (free_handle(handle_no) != SUCCESS)
		{
			setAH(EMM_HW_ERROR);
			return;
		}

	setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Get Version

PURPOSE		: Returns the version number of the memory manager software

RETURNED STATUS	: in AH register
		SUCCESS - returned successfuly

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Version IFN0()
{
	setAL(VERSION);
	setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Save_Page_Map

PURPOSE		: Saves the contents of the page mapping registers


RETURNED STATUS	: in AH register
		SUCCESS - Mapping context saved successfuly
		BAD_HANDLE - couldn't find specified handle
		MAP_IN_USE - mapping already saved for this handle

DESCRIPTION	:

=========================================================================
*/
LOCAL void Save_Page_Map IFN0()
{
	short	handle_no;

	handle_no = getDX();


	if(!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}
	if(map_saved(handle_no))
	{
		setAH(MAP_IN_USE);
		return;
	}

	save_map(handle_no, 0, 0, 0, 0);

	setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Restore_Page_Map

PURPOSE		: restores the mapping context associated with a particular
		handle
		This function only restores the map for the 4 physical pages that existed in LIM 3.

RETURNED STATUS	: in AH register
		SUCCESS - mapping restored successfuly
		BAD_HANDLE - couldn't find specified handle
		NO_MAP - No map has been saved for this handle
		EMM_HW_ERROR - error occurred in mapping or unmapping

DESCRIPTION	:

=========================================================================
*/
LOCAL void Restore_Page_Map IFN0()
{
	short	handle_no,	
		pages_out[MAX_NO_PAGES],	/* pages to map out	*/
		pages_in[MAX_NO_PAGES];		/* pages to map in	*/
    unsigned char i;				/* loop counter		*/

	handle_no = getDX();


	if(!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}
	if(!map_saved(handle_no))
	{
		setAH(NO_MAP);
		return;
	}

	restore_map(handle_no, 0, 0, pages_out, pages_in);

	for(i = 0; i < 4; i++)	/* Only do the 4 pages supported by EMS 3 !! */
	{
		if(pages_out[i] != EMPTY)
			if(unmap_page(i) != SUCCESS)
			{
				setAH(EMM_HW_ERROR);
				return;
			}
		if(pages_in[i] != EMPTY)
			if(map_page(pages_in[i], i) != SUCCESS)
			{
				setAH(EMM_HW_ERROR);
				return;
			}
	}

	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	:

PURPOSE		:


RETURNED STATUS	: in AH register
		SUCCESS -

DESCRIPTION	:

=========================================================================
*/
LOCAL void Reserved IFN0()
{
	setAH(BAD_FUNC_CODE);
	return;
}

/*
===========================================================================

FUNCTION	: Get_Handle_Count

PURPOSE		: Returns the number of open EMM handles


RETURNED STATUS	: in AH register
		SUCCESS - number returned successfuly

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Handle_Count IFN0()
{
	setBX(get_total_open_handles());

	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Get_Handle_Pages

PURPOSE		: returns the number of pages assigned to a particular
		handle

RETURNED STATUS	: in AH register
		SUCCESS - Page count returned successfuly
		BAD_HANDLE - couldn't find specified handle

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Handle_Pages IFN0()
{
	short		handle_no;

	handle_no = getDX();
	if (!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}

	setBX(get_no_pages(handle_no));
	setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Get_All_Handle_Pages

PURPOSE		: Returns a list of all open handles and the number of
		pages assigned to each handle


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_All_Handle_Pages IFN0()
{
	unsigned short	segment,	/* segment address of position	*/
					/* to return data to		*/
			offset;		/* offset within segment	*/
	short		no_of_handles,	/* no. of open handles		*/
			no_of_pages,	/* no of pages in each handle	*/
			i,		/* Loop counter			*/
			handle_no;

	segment = getES();
	offset = getDI();

	no_of_handles = get_total_open_handles();
	handle_no = 0;

	for (i = 0; i < no_of_handles; i++)
	{
		while(!handle_ok(handle_no))
			handle_no++;
		no_of_pages = get_no_pages(handle_no);

		write_intel_word(segment, offset, handle_no);
		offset += 2;
		write_intel_word(segment, offset, no_of_pages);
		offset += 2;
		handle_no++;
	}
	setBX(no_of_handles);
	setAH(SUCCESS);

	return;
}


/*
===========================================================================

FUNCTION	: Get_Set_Page_Map

PURPOSE		: saves mapping context in a user supplied array and restores
		a previously saved context from a given array


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_SUB_FUNC - Invalid sub-function
		BAD_MAP - The contents of the map are a load of cak

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Set_Page_Map IFN0()
{
	unsigned short 	src_segment,	/* segment address of src array	*/
			src_offset,	/* offset of source array	*/
			dst_segment,	/* segment address of dst array	*/
			dst_offset;	/* offset of destination array	*/
	unsigned char	sub_func;	/* sub-function code		*/
	short	pages_out[MAX_NO_PAGES],/* pages to map out		*/
		pages_in[MAX_NO_PAGES];	/* pages to map in		*/
    unsigned short no_phys_pages,		/* no. of phys. pages available	*/
		i;			/* loop counter			*/

	sub_func = getAL();
	switch(sub_func)
	{
		case 0:
		case 2:
			dst_segment = getES();
			dst_offset = getDI();
			save_map(-1, dst_segment, dst_offset, 0, 0);
			if(sub_func == 0 )
				break;
		case 1:	
			src_segment = getDS();
			src_offset = getSI();
			if(restore_map(-1 , src_segment, src_offset, pages_out, pages_in) != SUCCESS)
			{
				setAH(BAD_MAP);
				return;
			}

			no_phys_pages = get_no_phys_pages();
			for(i = 0; i < no_phys_pages; i++)
			{
				if(pages_out[i] != EMPTY)
					if(unmap_page((UCHAR)i) != SUCCESS)
					{
						setAH(EMM_HW_ERROR);
						return;
					}
				if(pages_in[i] != EMPTY)
					if(map_page(pages_in[i], (UCHAR)i) != SUCCESS)
					{
						setAH(EMM_HW_ERROR);
						return;
					}
			}
			break;

		case 3: setAL((unsigned char)get_map_size());
			break;


		default: setAH(BAD_SUB_FUNC);
			return;
	}

	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Get_Set_Partial_Page_map

PURPOSE		: Only saves or restores part of a complete page map
		as specified by a user supplied array


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_SEGMENT - one of the specified segments is incorrect
		BAD_SUB_FUNC - Invalid sub-function
		BAD_MAP - The contents of the map are a load of cak

DESCRIPTION	: Note in this implementation the size of array used for
		storing the partial mapping context is the same as for
		storing a full context as the pages that are'nt specified
		are marked in the array as being empty

=========================================================================
*/
LOCAL void Get_Set_Partial_Page_Map IFN0()
{
	unsigned short 	src_segment,	/* segment address of src array	*/
			src_offset,	/* offset of source array	*/
			dst_segment,	/* segment address of dst array	*/
			dst_offset;	/* offset of destination array	*/
	unsigned char	sub_func;	/* sub-function code		*/
	short	pages_out[MAX_NO_PAGES],/* pages to map out		*/
		pages_in[MAX_NO_PAGES];	/* pages to map in		*/
    unsigned short no_phys_pages,		/* no. of phys. pages available */
		i;			/* loop counter			*/

	sub_func = getAL();
	switch(sub_func)
	{
		case 0:	dst_segment = getES();
			dst_offset = getDI();
			src_segment = getDS();
			src_offset = getSI();
			if(save_map(-2, dst_segment, dst_offset, src_segment, src_offset) != SUCCESS)
			{
				setAH(BAD_PHYS_PAGE);
				return;
			}
			break;

		case 1: src_segment = getDS();
			src_offset = getSI();
			if(restore_map(-1 , src_segment, src_offset, pages_out, pages_in) != SUCCESS)
			{
				setAH(BAD_MAP);
				return;
			}

			no_phys_pages = get_no_phys_pages();
			for(i = 0; i < no_phys_pages; i++)
			{
				if(pages_out[i] != EMPTY)
					if(unmap_page((UCHAR)i) != SUCCESS)
					{
						setAH(EMM_HW_ERROR);
						return;
					}
				if(pages_in[i] != EMPTY)
					if(map_page(pages_in[i], (UCHAR)i) != SUCCESS)
					{
						setAH(EMM_HW_ERROR);
						return;
					}
			}
			break;

		case 2: setAL((unsigned char)get_map_size());
			break;


		default: setAH(BAD_SUB_FUNC);
			return;
	}
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Map_Unmap_Multiple_Handle_Pages

PURPOSE		: maps and umaps the requested Expanded Memory pages into
		and out of Intel physical address space

RETURNED STATUS	: in AH register
		SUCCESS - Mapping/Unmapping successful
		BAD_HANDLE - couldn't find specified handle
		BAD_LOG_PAGE - invalid logical page number
		BAD_PHYS_PAGE - invalid physical page number
		BAD_SUB_FUNC - invalid sub-function code
		EMM_HW_ERROR - unable to map/unmap for some unspecified
				reason

DESCRIPTION	:

=========================================================================
*/
LOCAL void Map_Unmap_Multiple_Handle_Pages IFN0()
{
	unsigned short	segment,	/* segment address of map array	*/
			offset,		/* offset address of map array	*/
			value;		/* segment address or page no.  */

	short	handle_no,
		logical_page_no,	/* page no. within handle	*/
		EM_page_no,		/* Expanded memory page		*/
		no_of_pages,		/* No. of pages in handle	*/
		no_phys_pages,		/* no. of phys. pages available	*/
		pages_to_map,		/* total no of pages to map	*/
		i;			/* loop counter			*/

	unsigned char
		sub_func,		/* sub-function	code		*/
		physical_page_no;	

	sub_func = getAL();
	if(sub_func > 1)
	{
		setAH(BAD_SUB_FUNC);
		return;
	}
	handle_no = getDX();
	if(!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}
	no_of_pages = get_no_pages(handle_no);
	pages_to_map = getCX();
	segment = getDS();
	offset = getSI();

	for(i = 0; i < pages_to_map; i++)
	{
		read_intel_word(segment, offset, (word *)&logical_page_no);
		offset += 2;
		read_intel_word(segment, offset, &value);
		offset += 2;	
		no_phys_pages = get_no_phys_pages();
		if(sub_func == 1)
		{
			physical_page_no = 0;
			do
				if(value == get_page_seg(physical_page_no))
					break;
			while(++physical_page_no < no_phys_pages);
		}
		else
			physical_page_no = (unsigned char)value;

		if(physical_page_no >= no_phys_pages)
		{
			setAH(BAD_PHYS_PAGE);
			return;
		}
		if((logical_page_no < -1) || (logical_page_no >= no_of_pages))
		{
			setAH(BAD_LOG_PAGE);
			return;
		}
	/*
	 * If you get to here, all parameters must be ok - so start mapping
	 */
		if(logical_page_no == -1)
		{
			/*
			 * Unmapping required
			 */
			if(unmap_page(physical_page_no) != SUCCESS)
			{
				setAH(EMM_HW_ERROR);
				return;
			}
		}
		else
		{
			/*
			 * Mapping required
			 */
			EM_page_no = get_EMpage_no(handle_no, logical_page_no);
			if(map_page(EM_page_no, physical_page_no) != SUCCESS)
			{
				setAH(EMM_HW_ERROR);
				return;
			}	
		}
	}
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Reallocate_Pages

PURPOSE		: Changes the number of pages assigned to a handle


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_HANDLE - invalid handle number
		NOT_ENOUGH_PAGES - Not enough pages in the system
		NO_MORE_PAGES - not enough free pages available
		EMM_HW_ERROR - memory allocation error

DESCRIPTION	:

=========================================================================
*/
LOCAL void Reallocate_Pages IFN0()
{
	short		handle_no,
			EM_page_no,	/* Expanded Memory page number	*/
			old_page_count,	/* no. of pages in handle	*/
			new_page_count,	/* required pages in handle	*/
			i;		/* loop counter			*/

	handle_no = getDX();
	if(!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}
	new_page_count = getBX();
	if(new_page_count > get_total_pages())
	{
		setAH(NOT_ENOUGH_PAGES);
		return;
	}
	old_page_count = get_no_pages(handle_no);
	if((new_page_count - old_page_count) > get_unallocated_pages())
	{
		setAH(NO_MORE_PAGES);
		return;
	}	
	if(new_page_count > old_page_count)
	{
		if(reallocate_handle(handle_no, old_page_count, new_page_count) != SUCCESS)
		{
			setAH(EMM_HW_ERROR);
			return;
		}
		set_no_pages(handle_no, new_page_count);
		for(i = old_page_count; i < new_page_count; i++)
		{
			if((EM_page_no = alloc_page()) < SUCCESS)
			{
				setAH(EMM_HW_ERROR);
				return;
			}
			set_EMpage_no(handle_no, i, EM_page_no);
		}	
	}
	else if(new_page_count < old_page_count)
	{
		set_no_pages(handle_no, new_page_count);
		for(i = new_page_count; i < old_page_count; i++)
		{
			EM_page_no = get_EMpage_no(handle_no, i);
			if(free_page(EM_page_no) != SUCCESS)
			{
				setAH(EMM_HW_ERROR);
				return;
			}
		}		
	}	

	setBX(new_page_count);
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Get_Set_Handle_Attribute

PURPOSE		:


RETURNED STATUS	: in AH register
		SUCCESS 	- everything ok (Al set to 0 also)
		NOT_SUPPORTED   - this function not supported
		BAD_SUB_FUNC	- invalid sub_function

DESCRIPTION	: Non - volatile handles are currently not supported

=========================================================================
*/
LOCAL void Get_Set_Handle_Attribute IFN0()
{
	unsigned char	sub_func;	/* sub_function code		*/

	sub_func = getAL();
	if(sub_func > 2)
	{
		setAH(BAD_SUB_FUNC);
		return;
	}
	if(sub_func < 2)
	{
		setAH(NOT_SUPPORTED);
		return;
	}
	/*
	 * Setting AL to 0 here indicates support of volatile handles only
	 */

	setAL(0);
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Get_Set_Handle_Name

PURPOSE		: Assigns or retrieves a name to or from a given handle


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_HANDLE - Invalid handle
		BAD_SUB_FUNC -Invalid sub-function code
		NAME_EXISTS - Name already exists in another handle

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Set_Handle_Name IFN0()
{
	unsigned char	sub_func;	/* sub-function code		*/	

	short		handle_no,
			no_of_handles,	/* no of open(allocated) handles*/
			tmp_hndl_no,	/* temp. variable for handle no	*/
			i;		/* loop counter			*/

	unsigned short	segment,	/* segment address of name	*/
			offset;		/* offset address of name	*/

	char	name[NAME_LENGTH],	/* array for holding name	*/
			*name_ptr;	/* pointer to existing names	*/

	sub_func = getAL();
	if(sub_func > 1)
	{
		setAH(BAD_SUB_FUNC);
		return;
	}
	handle_no = getDX();
	if(!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}
	if(sub_func == 0)
	{
		segment = getES();
		offset = getDI();
		name_ptr = get_name(handle_no);
		write_intel_byte_string(segment, offset, (host_addr)name_ptr, NAME_LENGTH);	
	}
	else if(sub_func == 1)
	{
		segment = getDS();
		offset = getSI();
		read_intel_byte_string(segment, offset, (host_addr)name, NAME_LENGTH);
		/*
		 * check all existing names
		 */
		no_of_handles = get_total_open_handles();
		tmp_hndl_no = 0;
		for(i = 0; i < no_of_handles; i++)
		{
			while(!handle_ok(tmp_hndl_no))
				tmp_hndl_no++;
			name_ptr = get_name(tmp_hndl_no);

			if(strncmp(name, name_ptr, NAME_LENGTH) == 0)
			{
				setAH(NAME_EXISTS);
				return;
			}
			tmp_hndl_no++;
		}
		/*
		 * If you get here - name must be ok	
		 */
		set_name(handle_no, name);
	}

	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Get_Handle_Directory

PURPOSE		: Returns a list of handles and their names


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_SUB_FUNC - Invalid sub-function
		HANDLE_NOT_FOUND - could not find handle with specified name

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Handle_Directory IFN0()
{
	unsigned char	sub_func;	/* sub-function code		*/
	unsigned short 	segment,	/* segment address of name array*/
			offset;		/* offset of name array		*/
	short		handle_no,
			no_of_handles,	/* no. of open handles		*/
			i;		/* loop counter			*/
	char		*name_ptr,	/* pointer to name		*/
			name[NAME_LENGTH];	/* name to search for	*/

	sub_func = getAL();
	switch(sub_func)
	{
		case 0:	segment = getES();
			offset = getDI();
			no_of_handles = get_total_open_handles();
			handle_no = 0;
			for(i = 0; i < no_of_handles; i++)
			{
				while(!handle_ok(handle_no))
					handle_no++;
				name_ptr = get_name(handle_no);
				write_intel_word(segment, offset, handle_no);
				offset += 2;
				write_intel_byte_string(segment, offset, (host_addr)name_ptr, NAME_LENGTH);
				offset += NAME_LENGTH;
				handle_no++;
			}
			setAL((unsigned char)no_of_handles);
			break;

		case 1:	segment = getDS();
			offset = getSI();
			read_intel_byte_string(segment, offset, (host_addr)name, NAME_LENGTH);
			no_of_handles = get_total_open_handles();
			handle_no = 0;
			for(i = 0; i < no_of_handles; i++)
			{
				while(!handle_ok(handle_no))
					handle_no++;
				name_ptr = get_name(handle_no);

				if(strncmp(name, name_ptr, NAME_LENGTH) == 0)
					break;
				handle_no++;
			}
			if(i >= no_of_handles)
			{	
				setAH(HANDLE_NOT_FOUND);
				return;
			}
			setDX(handle_no);
			break;

		case 2: setBX(get_total_handles());
			break;

		default: setAH(BAD_SUB_FUNC);
			return;
	}
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Alter_Page_Map_And_Jump

PURPOSE		: Map a selection of pages and jump to a new address


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_HANDLE - Couldn't find specified handle
		BAD_SUB_FUNC - Invalid sub-function code
		BAD_LOG_PAGE - Invalid logical page number
		BAD_PHYS_PAGE - Invalid physical page number
		EMM_HW_ERROR - Unable to map or unmap for some undefined
				reason

DESCRIPTION	:

=========================================================================
*/

LOCAL void Alter_Page_Map_And_Jump IFN0()
{
	short		handle_no,
			no_of_pages,	/* pages assigned to handle	*/
			no_phys_pages,	/* no. of phys. pages available	*/
			EM_page_no,	/* Expanded memory page no.	*/
			i;		/* Loop counter			*/

	unsigned short	segment,	/* segment of data structure	*/
			offset,		/* offset of data structure	*/
			jmp_segment,	/* segment of address to jump to*/
			jmp_offset,	/* offset of address to jump to	*/
			map_segment,	/* segment of mapping data	*/
			map_offset,	/* offset of mapping data	*/
			logical_page_no,/* number of logical page	*/
			value;		/* segment/page no. (AL=0 or 1) */

	unsigned char	sub_func,	/* sub-function code		*/
			pages_to_map,	/* no of pages to be mapped in	*/
			physical_page_no; /* number of physical page	*/

	handle_no = getDX();
	if(!handle_ok(handle_no))
	{
		setAH(BAD_HANDLE);
		return;
	}
	sub_func = getAL();
	if(sub_func > 1)
	{
		setAH(BAD_SUB_FUNC);
		return;
	}
	segment = getDS();
	offset = getSI();

	read_intel_word(segment, offset, &jmp_offset);
	offset += 2;
	read_intel_word(segment, offset, &jmp_segment);
	offset += 2;
	read_intel_byte(segment, offset, &pages_to_map);
	offset++;
	read_intel_word(segment, offset, &map_offset);
	offset += 2;
	read_intel_word(segment, offset, &map_segment);
	offset += 2;

	no_of_pages = get_no_pages(handle_no);
	for(i = 0; i < pages_to_map; i++)
	{
		read_intel_word(map_segment, map_offset, &logical_page_no);
		map_offset += 2;
		if(logical_page_no >= no_of_pages)
		{
			setAH(BAD_LOG_PAGE);
			return;
		}
		read_intel_word(map_segment, map_offset, &value);
		map_offset += 2;

		no_phys_pages = get_no_phys_pages();
		if(sub_func == 1)
		{
			physical_page_no = 0;
			do
				if(value == get_page_seg(physical_page_no))
					break;
			while(++physical_page_no < no_phys_pages);
		}
		else
			physical_page_no = (unsigned char)value;

		if(physical_page_no >= no_phys_pages)
		{
			setAH(BAD_PHYS_PAGE);
			return;
		}

		EM_page_no = get_EMpage_no(handle_no, logical_page_no);
		if(map_page(EM_page_no, physical_page_no) != SUCCESS)
		{
			setAH(EMM_HW_ERROR);
			return;
		}
	}
	/*
	 * Push flags and segment:offset of target address onto stack
	 * to enable iret in driver to transfer control
	 */
	push_word((word)(getSTATUS()));
	push_word(jmp_segment);
	push_word(jmp_offset);

	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Alter_Page_Map_And_Call
		  return_from_call

PURPOSE		: Map a selection of pages and transfer control to a new
		address. Upon return map in a different set of pages


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_HANDLE - Couldn't find specified handle
		BAD_SUB_FUNC - Invalid sub-function code
		BAD_LOG_PAGE - Invalid logical page number
		BAD_PHYS_PAGE - Invalid physical page number
		EMM_HW_ERROR - Unable to map or unmap for some undefined
				reason

DESCRIPTION	: The return is handled by loading the segment and offset
		of the BOP 0x68 call onto the stack. This BOP will initiate
		a call to 'return_from_call()' which will handle the
		remapping.

=========================================================================
*/
LOCAL void Alter_Page_Map_And_Call IFN0()
{
	short		handle_no,
			no_of_pages,	/* pages assigned to handle	*/
			no_phys_pages,	/* no. of phys. pages available	*/
			EM_page_no,	/* Expanded memory page no.	*/
			i;		/* Loop counter			*/

	unsigned short	segment,	/* segment of data structure	*/
			offset,		/* offset of data structure	*/
			call_segment,	/* segment of address to jump to*/
			call_offset,	/* offset of address to jump to	*/
			map_segment,	/* segment of mapping data	*/
			map_offset,	/* offset of mapping data	*/
			logical_page_no,/* number of logical page	*/
			value;		/* segment/page no. (AL=0 or 1) */

	unsigned char	sub_func,	/* sub-function code		*/
			pages_to_map,	/* no of pages to be mapped in	*/
			physical_page_no; /* number of physical page	*/

	sub_func = getAL();
	if(sub_func > 2)
	{
		setAH(BAD_SUB_FUNC);
		return;
	}
	if(sub_func != 2)
	{
		handle_no = getDX();
		if(!handle_ok(handle_no))
		{
			setAH(BAD_HANDLE);
			return;
		}
		segment = getDS();
		offset = getSI();

		read_intel_word(segment, offset, &call_offset);
		offset += 2;
		read_intel_word(segment, offset, &call_segment);
		offset += 2;
		read_intel_byte(segment, offset, &pages_to_map);
		offset++;
		read_intel_word(segment, offset, &map_offset);
		offset += 2;
		read_intel_word(segment, offset, &map_segment);
		offset += 2;

		no_of_pages = get_no_pages(handle_no);
		for(i = 0; i < pages_to_map; i++)
		{
			read_intel_word(map_segment, map_offset, &logical_page_no);
			map_offset += 2;
			if(logical_page_no >= no_of_pages)
			{
				setAH(BAD_LOG_PAGE);
				return;
			}
			read_intel_word(map_segment, map_offset, &value);
			map_offset += 2;

			no_phys_pages = get_no_phys_pages();
			if(sub_func == 1)
			{
				physical_page_no = 0;
				do
					if(value == get_page_seg(physical_page_no))
						break;
				while(++physical_page_no < no_phys_pages);
			}
			else
				physical_page_no = (unsigned char)value;

			if(physical_page_no >= no_phys_pages)
			{
				setAH(BAD_PHYS_PAGE);
				return;
			}

			EM_page_no = get_EMpage_no(handle_no, logical_page_no);
			if(map_page(EM_page_no, physical_page_no) != SUCCESS)
			{
				setAH(EMM_HW_ERROR);
				return;
			}
		}
		/*
		 * Now set up mapping data for return
		 * read new segment, offset and pages to map data
		 */

		read_intel_byte(segment, offset, &pages_to_map);
		offset++;
		read_intel_word(segment, offset, &map_offset);
		offset += 2;
		read_intel_word(segment, offset, &map_segment);
		offset += 2;

		for(i = 0; i < no_phys_pages; map_on_return[i++] = EMPTY);

		for(i = 0; i < pages_to_map; i++)
		{
			read_intel_word(map_segment, map_offset, &logical_page_no);
			map_offset += 2;
			if(logical_page_no >= no_of_pages)
			{
				setAH(BAD_LOG_PAGE);
				return;
			}
			read_intel_word(map_segment, map_offset, &value);
			map_offset += 2;

			if(sub_func == 1)
			{
				physical_page_no = 0;
				do
					if(value == get_page_seg(physical_page_no))
						break;
				while(++physical_page_no < no_phys_pages);
			}
			else
				physical_page_no = (unsigned char)value;

			if(physical_page_no >= no_phys_pages)
			{
				setAH(BAD_PHYS_PAGE);
				return;
			}

			EM_page_no = get_EMpage_no(handle_no, logical_page_no);
			map_on_return[physical_page_no] = EM_page_no;
		}
		/*
		 * Push segment:offset of bop68 onto stack to trap far return
		 */	
		push_word(segment68);
		push_word(offset68);
		/*
		 * Push flags and segment:offset of target address onto stack
		 * to enable iret in driver to transfer control
		 */
		push_word((word)getSTATUS());
		push_word(call_segment);
		push_word(call_offset);
	}
	else /* if sub_func == 2 */
		setBX(10);

	setAH(SUCCESS);
	return;
}


GLOBAL void return_from_call IFN0()

{
	unsigned char	page_no;	/* physical page number		*/
	short		no_phys_pages;	/* no. of phys. pages available	*/

	no_phys_pages = get_no_phys_pages();
	for(page_no = 0; page_no < no_phys_pages; page_no++)
	{
		if(map_on_return[page_no] != EMPTY)
			if(map_page(map_on_return[page_no], page_no) != SUCCESS)
			{
				setAH(EMM_HW_ERROR);
				return;
			}
	}
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Move_Exchange_Memory_Region

PURPOSE		: copies a region of memory from either, conventional or
		expanded memory to either, conventional or expanded memory.


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_SUB_FUNC - Invalid sub-function code
		BAD_HANDLE - couldn't find specified handle
		BAD_LOG_PAGE - invalid logical page number
		MOVE_MEM_OVERLAP - Source and destination regions overlap during move
		XCHG_MEM_OVERLAP - Source and destination regions overlap during exchange
		TOO_FEW_PAGES - Insufficient pages in handle for operation
		OFFSET_TOO_BIG - Offsey exceeds size of page
		LENGTH_GT_1M - Memory length to be moved exceeds 1 M byte
		BAD_TYPE - Unsupported memory type
		WRAP_OVER_1M - Attempt made to wrap around the 1 Mbyte address
		EMM_HW_ERROR - Undefined error occurred during copying

DESCRIPTION	: type - uses a bit pattern, bit 0 represents destination,
		bit 1 represents source, a set bit means expanded, a clear
		bit means conventional memory
		bit 2 represents exchange if set or move if it is clear

		e.g. 	0 (0000) = move conventional to conventional
		 	1 (0001) = move conventional to expanded
		 	6 (0110) = exchange expanded to conventional
		 	7 (0111) = exchange expanded to expanded

=========================================================================
*/
LOCAL void Move_Exchange_Memory_Region IFN0()
{
	unsigned char	sub_func,	/* sub-function code		*/
			type,		/* see description above	*/
			mem_type;	/* type of src or dest memory	*/

	unsigned short 	segment,	/* segment address of structure	*/
			offset,		/* offset address of structure	*/
			half_length,	/* tmp store for reading length	*/
			src_offset,	/* offset of source memory	*/
			src_seg_page,	/* segment or page of src memory*/
			dst_offset,	/* offset of destination memory	*/
			dst_seg_page;	/* segment or page of dst memory*/

	unsigned long
			length,		/* length of memory region	*/
			src_start,	/* start of src within handle	*/
			src_end,	/* end of src within handle	*/
			dst_start,	/* start of dest within handle	*/
			dst_end,	/* end of dest within handle	*/
			data_block_size,/* transfer data block size     */
			bytes_available;/* no. bytes to end of handle	*/

	short		src_handle_no,	/* source handle number		*/
			dst_handle_no,	/* dest handle number		*/
			no_of_pages;	/* no. of pages within handle	*/

	boolean		overlap;	/* indicates a memory overlap	*/


	sub_func = getAL();
	if(sub_func > 1)
	{
		setAH(BAD_SUB_FUNC);
		return;
	}
	type = sub_func << 2;
	segment = getDS();
	offset = getSI();	

	read_intel_word(segment, offset, &half_length);
	offset += 2;
	length = half_length;
	read_intel_word(segment, offset, &half_length);
	offset += 2;
	length += (((long)half_length) << 16);
	if(length > 0x100000)
	{
		setAH(LENGTH_GT_1M);
		return;
	}
	/*
	 * READ SOURCE DATA
	 */
	read_intel_byte(segment, offset, &mem_type);
	offset++;
	if(mem_type > 1)
	{
		setAH(BAD_TYPE);
		return;
	}
	type |= (mem_type << 1);
	read_intel_word(segment, offset, (word *)&src_handle_no);
	offset += 2;
	if(mem_type == 1) {
		if(!handle_ok(src_handle_no))
		{
			setAH(BAD_HANDLE);
			return;
		}
	}

	read_intel_word(segment, offset, &src_offset);
	offset += 2;
	read_intel_word(segment, offset, &src_seg_page);
	offset += 2;
	if(mem_type == 1)
	{
		no_of_pages = get_no_pages(src_handle_no);
		if(src_seg_page >= no_of_pages)
		{
			setAH(BAD_LOG_PAGE);
			return;
		}
		if(src_offset >= EMM_PAGE_SIZE)
		{
			setAH(OFFSET_TOO_BIG);
			return;
		}
		bytes_available = ((no_of_pages - src_seg_page + 1) * EMM_PAGE_SIZE) - src_offset;
		if(length > bytes_available)
		{
			setAH(TOO_FEW_PAGES);
			return;
		}
	}
	else {
		if((effective_addr(src_seg_page, src_offset) + length) >= 0x100000)
		{
			setAH(WRAP_OVER_1M);
			return;
		}
	}
	/*
	 * READ DESTINATION DATA
	 */
	read_intel_byte(segment, offset, &mem_type);
	offset++;
	if(mem_type > 1)
	{
		setAH(BAD_TYPE);
		return;
	}
	type |= mem_type;
	read_intel_word(segment, offset, (word *)&dst_handle_no);
	offset += 2;
	if(mem_type == 1) {
		if(!handle_ok(dst_handle_no))
		{
			setAH(BAD_HANDLE);
			return;
		}
	}

	read_intel_word(segment, offset, &dst_offset);
	offset += 2;
	read_intel_word(segment, offset, &dst_seg_page);
	offset += 2;
	if(mem_type == 1)
	{
		no_of_pages = get_no_pages(dst_handle_no);
		if(dst_seg_page >= no_of_pages)
		{
			setAH(BAD_LOG_PAGE);
			return;
		}
		if(dst_offset >= EMM_PAGE_SIZE)
		{
			setAH(OFFSET_TOO_BIG);
			return;
		}
		bytes_available = ((no_of_pages - dst_seg_page + 1) * EMM_PAGE_SIZE) - dst_offset;
		if(length > bytes_available)
		{
			setAH(TOO_FEW_PAGES);
			return;
		}
	}
	else
		if(((((unsigned long)dst_seg_page) << 4) + dst_offset + length) >= 0x100000)
		{
			setAH(WRAP_OVER_1M);
			return;
		}
	/*
	 * Check for overlap - ( only on expanded to expanded cases )
	 */	
	overlap = FALSE;
	if((type & 3) == 3)
		if(src_handle_no == dst_handle_no)
		{
			/*
			 * calc start and end positions of src and dst
			 * within handle
			 */
			src_start = (src_seg_page * EMM_PAGE_SIZE) + src_offset;
			src_end = src_start + length - 1;
			dst_start = (dst_seg_page * EMM_PAGE_SIZE) + dst_offset;
			dst_end = dst_start + length - 1;
			if((dst_start <= src_end && dst_start >= src_start) ||
			   (src_start <= dst_end && src_start >= dst_start))
		    	{
		    		if(sub_func == 1)
		    		{
		    			setAH(XCHG_MEM_OVERLAP);
		    			return;
		    		}
		    		else
		    			overlap = TRUE;
		    	}
		}
	/*
	 * If we get here everything is ok. Copy memory a page at a time, catering
	 * for the fact that expanded memory pages might not be contiguous and may be
	 * mapped into the intel address space.  Remember that Intel memory may be
	 * treated as contiguous memory.  So an Intel address need only be incremented
	 * if a copy spans more than one page of LIM memory.
	 */

	while (length>0) {
		int min_src, min_dst;

		min_src = (type & 2) ? min((unsigned long)(EMM_PAGE_SIZE - src_offset), length) : length;
		min_dst = (type & 1) ? min((unsigned long)(EMM_PAGE_SIZE - dst_offset), length) : length;
			
		data_block_size = min(min_src, min_dst);

		if(copy_exchange_data(type, src_handle_no, src_seg_page, src_offset,
		   dst_handle_no, dst_seg_page, dst_offset, data_block_size) != SUCCESS) {
			setAH(EMM_HW_ERROR);
			return;
		}

		Increment_Address(&src_seg_page, &src_offset, data_block_size, (unsigned char)(type & 2));
		Increment_Address(&dst_seg_page, &dst_offset, data_block_size, (unsigned char)(type & 1));
		length -= data_block_size;

	}

	if(overlap)
		setAH(MOVE_MEM_OVERLAP);
	else
		setAH(SUCCESS);

	return;
}			

/*
===========================================================================

FUNCTION	: Increment address

PURPOSE		: Increments an address, correctly catering for whether the address
		  is an Intel (conventional memory) address or a LIM (expanded memory)
		  address.

RETURNED STATUS	: None

DESCRIPTION	:

=========================================================================
*/

#define SEG_SIZE 0x10000

LOCAL void Increment_Address IFN4(unsigned short *,seg_or_page,
			      unsigned short *,offset,
			      unsigned long, increment_by,
			      unsigned char, memory_type)
{
	if (memory_type) {
		/* A LIM address, code makes assumption that increment across
		 * page boundary will always be to page boundary. */
		if (*offset + increment_by >= EMM_PAGE_SIZE) {
			(*seg_or_page)++;
			*offset = 0;
		} else {
			*offset += (unsigned short)increment_by;
		}
	} else {
		/* Conventional memory */
		if (*offset + increment_by >= SEG_SIZE) {
			unsigned long address;

			/* Make new segment value as high as possible, to
			 * minimise chances of further segment wrap */
			address = (*seg_or_page << 4) + *offset + increment_by;	
			*seg_or_page = (unsigned short)(address >> 4);
			*offset = (unsigned short)(address & 0xf);
		} else {
			*offset += (unsigned short)increment_by;
		}
	}
}

/*
===========================================================================

FUNCTION	: Get_Mappable_Physical_address_Array

PURPOSE		: returns an array of the sector address for each mappable
		page in physical address space

RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_SUB_FUNC - The sub function is invalid

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Mappable_Physical_Address_Array IFN0()
{
	unsigned short	segment,	/* segment address of position	*/
					/* to return data to		*/
			offset,		/* offset within segment	*/
			page_seg,	/* segment address of page	*/
			low_seg;	/* lowest segment address	*/
	short		no_phys_pages;	/* no. of phys. pages available */
	unsigned char	sub_func,	/* sub-function			*/
			page_no,	/* physical page number		*/
			lowest;		/* page no. having lowest seg.	*/

	sub_func = getAL();
	no_phys_pages = get_no_phys_pages();

	switch(sub_func)
	{
		case 0:
			segment = getES();
			offset = getDI();
			/*
			 * must be written in address order - lowest first
			 * if we are back filling page 0 is not the lowest
			 */
			lowest = 0;
			low_seg = get_page_seg(0);
			for(page_no = 1; page_no < no_phys_pages; page_no++)
				if((page_seg = get_page_seg(page_no)) < low_seg)
				{
					lowest = page_no;
					low_seg = page_seg;
				}
			for(page_no = lowest; page_no < no_phys_pages; page_no++)
			{
				page_seg = get_page_seg(page_no);
				write_intel_word(segment, offset, page_seg);
				offset += 2;
				write_intel_word(segment, offset, (short)page_no);
				offset += 2;
			}
			for(page_no = 0; page_no < lowest; page_no++)
			{
				page_seg = get_page_seg(page_no);
				write_intel_word(segment, offset, page_seg);
				offset += 2;
				write_intel_word(segment, offset, (short)page_no);
				offset += 2;
			}
		case 1:
			break;

		default:
			setAH(BAD_SUB_FUNC);
			return;
	}

	setCX(no_phys_pages);
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Get_Expanded_Memory_Hardware_Information

PURPOSE		: Returns an array containing hardware configuration
		information


RETURNED STATUS	: in AH register
		SUCCESS - Everything ok
		BAD_SUB_FUNC - invalid sub-function
		ACCESS_DENIED - the OS has denied access to this function

DESCRIPTION	:

=========================================================================
*/
LOCAL void Get_Hardware_Configuration_Array IFN0()
{
	unsigned short	segment,	/* segment address of position	*/
					/* to return data to		*/
			offset;		/* offset within segment	*/
	short		sub_func,	/* sub-function 		*/
			unallocated_raw_pages,
			total_raw_pages,				
			context_save_area_size;
	sub_func = getAL();
	switch(sub_func)
	{
		case 0:	if(disabled)
			{
				setAH(ACCESS_DENIED);
				return;
			}
			segment = getES();
			offset = getDI();
			context_save_area_size = get_map_size();

			write_intel_word(segment, offset, RAW_PAGE_SIZE);
			offset += 2;
#ifdef NTVDM

			write_intel_word(segment, offset, get_no_altreg_sets());
#else
			write_intel_word(segment, offset, ALT_REGISTER_SETS);
#endif

			offset += 2;
			write_intel_word(segment, offset, context_save_area_size);
			offset += 2;
			write_intel_word(segment, offset, DMA_CHANNELS);
			offset += 2;
			write_intel_word(segment, offset, DMA_CHANNEL_OPERATION);
			break;

			/*
			 * Our raw pages are the same size as the std pages
			 */			
		case 1: unallocated_raw_pages = get_unallocated_pages();
			total_raw_pages = get_total_pages();
			setBX(unallocated_raw_pages);
			setDX(total_raw_pages);
			break;

		default: setAH(BAD_SUB_FUNC);
			return;
	}

	setAH(SUCCESS);
	return;
}


/*
===========================================================================

FUNCTION	: Allocate_Raw_Pages

PURPOSE		: Allocates the requested number of raw pages, in this case
		our Raw pages are exactly the same as conventional pages.

RETURNED STATUS	: in AH register
		SUCCESS - Allocation successful
		NOT_ENOUGH_PAGES - not enough pages in the system
		NO_MORE_PAGES - not enough free pages available
		NO_MORE_HANDLES - no more free handles available
		EMM_HW_ERROR - memory allocation error

		BAD_FUNC_CODE - invalid function code

DESCRIPTION	:

=========================================================================
*/
LOCAL void Allocate_Raw_Pages IFN0()
{
	short	handle_no,
		no_of_pages,		/* no of pages to be allocated	*/
		i,			/* loop counter			*/
		EM_page_no;		/* Expanded Memory page number	*/

	no_of_pages = getBX();

	if(no_of_pages > get_total_pages())
	{
		setAH(NOT_ENOUGH_PAGES);
		return;
	}
	if(no_of_pages > get_unallocated_pages())
        {
		setAH(NO_MORE_PAGES);
		return;
	}
	if((handle_no = get_new_handle(no_of_pages)) < SUCCESS)
	{
		setAH(EMM_HW_ERROR);
		return;
	}
	set_no_pages(handle_no, no_of_pages);

	for(i=0; i<no_of_pages; i++)
	{
		if ((EM_page_no = alloc_page()) < SUCCESS)
		{
			setAH(EMM_HW_ERROR);
			return;
		}
		set_EMpage_no(handle_no, i, EM_page_no);
	}

	setDX(handle_no);
	setAH(SUCCESS);

	return;
}

/*
===========================================================================

FUNCTION	: Alternate_Map_Register_Support();

PURPOSE		: provides an alternate method of saving and restoring
		mapping contexts

RETURNED STATUS	: in AH register
		SUCCESS - Everything OK
		NO_ALT_REGS - Alternate Map register sets not supported
		BAD_MAP - Contents of the map are invalid
		BAD_SUB_FUNC - invalid sub-function code
		ACCESS_DENIED - the OS has denied access to this function

DESCRIPTION	:

=========================================================================
*/
LOCAL void Alternate_Map_Register_Support IFN0()
{

#ifdef NTVDM

    unsigned char sub_func;	/* sub-function code		*/

    short
	pages_in[MAX_NO_PAGES],	/* pages to map in		*/
	no_phys_pages,		/* no. of phys. pages available	*/
	i;			/* loop counter			*/
    unsigned short offset, map_register;
    boolean  pages_in_override;

    if(disabled)
    {
	setAH(ACCESS_DENIED);
	return;
    }

    sub_func = getAL();
    switch(sub_func) {

	case 0:
		map_register = get_active_altreg_set();
		if (map_register == 0) {
		    setES(alt_map_segment);
		    setDI(alt_map_offset);
		    if (alt_map_segment && alt_map_offset)
			save_map(-1, alt_map_segment, alt_map_offset, 0, 0);
		}
		setBL((unsigned char)map_register);
		setAH(EMM_SUCCESS);
		break;

	case 1:
		map_register = getBL();
		if (map_register >= get_no_altreg_sets()){
		    setAH(UNSUPPORTED_ALT_REGS);
		    break;
		}
		else if (!altreg_set_ok(map_register)) {
		    setAH(INVALID_ALT_REG);
		    break;
		}

		pages_in_override = FALSE;

		if (map_register == 0) {
		    alt_map_segment = getES();
		    alt_map_offset = getDI();

		    if (alt_map_segment && alt_map_offset) {
			no_phys_pages = get_no_phys_pages();
			offset = alt_map_offset;
			for (i = 0; i < no_phys_pages; i++) {
			    sas_loadw(effective_addr(alt_map_segment, offset), &pages_in[i]);
			    offset += sizeof(word);
			}
			pages_in_override = TRUE;
		    }
		}
		if (activate_altreg_set(map_register,
					(pages_in_override) ? pages_in : NULL
					))
		    setAH(EMM_SUCCESS);
		else
		    setAH(EMM_HW_ERROR);
		break;


	case 2: setDX(get_map_size());
		break;


	case 3:
		if (allocate_altreg_set(&map_register)) {
		    setBL((unsigned char)map_register);
		    setAH(EMM_SUCCESS);
		}
		else {
		    setBL(0);
		    setAH(NO_FREE_ALT_REGS);
		}
		break;

	case 4:
		map_register = getBL();
		/* immediately retrun okay if trying to deallocate alt reg 0 */
		if (map_register == 0)
		    setAH(EMM_SUCCESS);
		else if (map_register == get_active_altreg_set())
		    if (get_no_altreg_sets() == 1)
			setAH(NO_ALT_REGS);
		    else
			setAH(INVALID_ALT_REG);

		else if(deallocate_altreg_set(map_register))
			setAH(EMM_SUCCESS);
		     else
			setAH(EMM_HW_ERROR);
		break;

	case 5:
	case 6:
	case 7:
	case 8:
		map_register = getBL();
		if(map_register != 0)
		{
			setAH(NO_ALT_REGS);
			return;
		}
		break;

	default: setAH(BAD_SUB_FUNC);
		return;
    }

    setAH(SUCCESS);
    return;

#else
	unsigned char	sub_func,	/* sub-function code		*/
			map_register;	/* No. of alternate register	*/

	short	pages_out[MAX_NO_PAGES],/* pages to map out		*/
		pages_in[MAX_NO_PAGES],	/* pages to map in		*/
		no_phys_pages,		/* no. of phys. pages available	*/
		i;			/* loop counter			*/

	if(disabled)
	{
		setAH(ACCESS_DENIED);
		return;
	}
	sub_func = getAL();
	switch(sub_func)
	{
		case 0:
			if(set_called)
				save_map(-1, alt_map_segment, alt_map_offset, 0, 0);
			setES(alt_map_segment);
			setDI(alt_map_offset);
			break;
		case 1:	
			set_called = TRUE;
			map_register = getBL();
			if(map_register != 0)
			{
				setAH(NO_ALT_REGS);
				return;
			}
			alt_map_segment = getES();
			alt_map_offset = getDI();

			/*
			 * Undocumented feature (???) to restore the
			 * alternative mappings back to their original
			 * state a NULL ptr is passed into here (ES:DI == 0)
			 * We must therefore set things as if set_alt had
			 * never been called
			 */
			if ((alt_map_segment == 0) && (alt_map_offset == 0))
			{
				set_called = FALSE;
				break;
			}
			if(restore_map(-1 , alt_map_segment, alt_map_offset, pages_out, pages_in) != SUCCESS)
			{
				setAH(BAD_MAP);
				return;
			}

			no_phys_pages = get_no_phys_pages();
			for(i = 0; i < no_phys_pages; i++)
			{
				if(pages_out[i] != EMPTY)
					if(unmap_page(i) != SUCCESS)
					{
						setAH(EMM_HW_ERROR);
						return;
					}
				if(pages_in[i] != EMPTY)
					if(map_page(pages_in[i], i) != SUCCESS)
					{
						setAH(EMM_HW_ERROR);
						return;
					}
			}

			break;


		case 2: setDX(get_map_size());
			break;

		case 3:
		case 5:
			setBL(0);
			break;

		case 4:
		case 6:
		case 7:
		case 8:
			map_register = getBL();
			if(map_register != 0)
			{
				setAH(NO_ALT_REGS);
				return;
			}
			break;

		default: setAH(BAD_SUB_FUNC);
			return;
	}

	setAH(SUCCESS);
	return;
#endif

}

/*
===========================================================================

FUNCTION	: Prepare_Expanded_Memory_HW_For_Warm_Boot

PURPOSE		:

RETURNED STATUS	: in AH register
		SUCCESS -

DESCRIPTION	: We don't actually do anything here, we just pretend
		 that we do

=========================================================================
*/
LOCAL void Prepare_Expanded_Memory_HW_For_Warm_Boot IFN0()
{
	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: Enable_Disable_OSE_Function_Set_Functions

PURPOSE		: Enables or disables the functions:-
			Get Expanded Memory Hardware Information,
			Alternate Map Register Sets
			Enable Disable OS/E Function Set Functions

RETURNED STATUS	: in AH register
		SUCCESS - Everything OK
		BAD_SUB_FUNC - invalid sub-function code
		ACCESS_DENIED - the OS has denied access to this function

DESCRIPTION	:

=========================================================================
*/
LOCAL void Enable_Disable_OSE_Function_Set_Functions IFN0()
{
	static unsigned short
			access_key[2];	/* random access key in BX & CX	*/
	static boolean
		     first_time = TRUE;	/* first time through flag	*/

	unsigned char	sub_func;	/* sub-function code		*/

	if(!first_time)
	{
		/*
		 * We must check the 'access key'
		 */
		if((access_key[0] != getBX()) || (access_key[1] != getCX()))
		{
			setAH(ACCESS_DENIED);
			return;
		}
	}
	sub_func = getAL();
	switch(sub_func)
	{
		case 0:	if(first_time)
			{
				host_get_access_key(access_key);
				setBX(access_key[0]);
				setCX(access_key[1]);
				first_time = FALSE;
			}
			disabled = FALSE;
			break;

		case 1:	if(first_time)
			{
				host_get_access_key(access_key);
				setBX(access_key[0]);
				setCX(access_key[1]);
				first_time = FALSE;
			}
			disabled = TRUE;
			break;

		case 2:	disabled = FALSE;
			first_time = TRUE;
			break;

		default: setAH(BAD_SUB_FUNC);
			return;
	}

	setAH(SUCCESS);
	return;
}

/*
===========================================================================

FUNCTION	: reset_emm_funcs

PURPOSE		: sets up variables to their initial value, used mainly
		for SoftPC reboot

RETURNED STATUS	: none

DESCRIPTION	:

=========================================================================
*/
GLOBAL void reset_emm_funcs IFN0()
{
	/*
	 * These variables are used in function 28
	 * (Alternate Map Register Support)
	 */
	alt_map_segment = 0;
	alt_map_offset  = 0;
#ifndef NTVDM
	set_called      = FALSE;
#endif

	return;
}

#ifndef PROD
/*
===========================================================================

FUNCTION	: Routines to start and end a trace of all EMM calls

PURPOSE		:

RETURNED STATUS	: in AH register
		SUCCESS

DESCRIPTION	:

=========================================================================
*/
LOCAL void Start_Trace IFN0()
{
	if ((fp = fopen("emm_trace","w")) == NULL)
	{
		setAH(EMM_HW_ERROR);
		return;
	}

	setbuf(fp, NULL);	
	trace_flag = TRUE;

	setAH(SUCCESS);
	return;
}


LOCAL void End_Trace IFN0()
{
	fflush(fp);
	fclose(fp);
	trace_flag = FALSE;

	setAH(SUCCESS);
	return;
}
#endif /* PROD */
#if defined(NEC_98)
LOCAL void Page_Frame_Bank_Status IFN0()
{
        switch(getAL()) {
                case 0:
                        setAX(0);
                        break;
                case 1:
                        setAX(0);
                        break;
                default:
                        setAH(BAD_SUB_FUNC);
                        break;
        }
        return;
}
#endif // NEC_98
#endif /* LIM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\aaa.h ===
/* 
   aaa.h

   Define all AAA CPU functions.
 */

/*
   static char SccsID[]="@(#)aaa.h	1.4 09/01/94";
 */

IMPORT VOID AAA IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\slave_bs.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA MODULE SPECIFICATION
			-----------------------------

MODULE NAME	: Slave Interrupt Bios

	THIS PROGRAM SOURCE FILE IS SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF ITS OPERATION MAY 
	ONLY BE DISCLOSED TO PERSONS EMPLOYED BY THE CUSTOMER WHO
	REQUIRE A KNOWLEDGE OF THE  SOFTWARE  CODING TO CARRY OUT 
	THEIR JOB. DISCLOSURE TO ANY OTHER PERSON MUST HAVE PRIOR
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: October '88

PURPOSE		: To provide BIOS code used by the interrupts from
		the slave ICA

The Following Routines are defined:
		1. 	D11_int
		2.	re_direct
		3. 	int_287

=========================================================================

AMMENDMENTS	:

=========================================================================
*/

#ifdef SCCSID
static char SccsID[]=" @(#)slave_bios.c	1.6 08/10/92 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "AT_STUFF.seg"
#endif

#include "xt.h"
#include "ios.h"
#include "sas.h"


/*
=========================================================================

FUNCTION	: D11_int

PURPOSE		: Services unused interrupt vectors

RETURNED STATUS	: None

DESCRIPTION	:


=======================================================================
*/
#define	intr_flag	0x46b

void D11_int()
{
	half_word	level,		/* int. level being serviced	*/	
			level2,		/* ica2 level being serviced	*/
			mask;		/* interrupt mask		*/

	/* read in-service register	*/
	outb( ICA0_PORT_0, 0x0B );
	inb( ICA0_PORT_0, &level );

	if( level == 0 )
	{
		/* Not a H/w interrupt	*/
		level = 0xff;
	}
	else
	{
		/* read in-service register from int controller 2	*/
		outb( ICA1_PORT_0, 0x0B );
		inb( ICA1_PORT_0, &level2 );

		if( level2 == 0 )
		{
			/* get current mask value	*/
			inb( ICA0_PORT_1, &mask );

			/* don't disable 2nd controller	*/
			level &= 0xfb;

			/* set new interrupt mask	*/
			mask |= level;
			outb( ICA0_PORT_1, mask );
		}
		else
		{
			/* get 2nd interrupt mask	*/
			inb( ICA1_PORT_1, &mask );

			/* mask off level being serviced	*/
			mask |= level2;
			outb( ICA1_PORT_1, mask );

			/* send EOI to 2nd chip		*/
			outb( ICA1_PORT_1, 0x20 );
		}
		/* send EOI to 1st chip	*/
		outb( ICA0_PORT_0, 0x20 );
	}
	/* set flag	*/
	sas_store (intr_flag , level);

	return;
}

/*
=========================================================================

FUNCTION	: re_direct

PURPOSE		: re direct slave interrupt 9 to level 2

RETURNED STATUS	: None

DESCRIPTION	:

=======================================================================
*/
void re_direct()

{
	/* EOI to slave interrupt controller	*/

	outb( ICA1_PORT_0, 0x20 );

	return;
}

/*
=========================================================================

FUNCTION	: int_287

PURPOSE		: service X287 interrupts

RETURNED STATUS	: none

DESCRIPTION	:

=======================================================================
*/
void int_287()

{
	/* remove the interrupt request	*/
	outb(0xf0, 0);

	/* enable the interrupt		*/
	outb( ICA1_PORT_0, 0x20 );	/* Slave	*/
	outb( ICA0_PORT_0, 0x20 );	/* Master	*/

	/* int 02 is now called from bios1.rom	*/

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\tape_io.c ===
#if defined(JAPAN) && defined(i386)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif // JAPAN && i386
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: cassette_io
 *
 * Description	: Cassette i/o functions - interrupt 15H.
 *
 * Notes	: None
 *
 */

/*
 * static char SccsID[]="@(#)tape_io.c	1.26 06/28/95 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif

/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#if defined(JAPAN) && defined(i386)
#include "stdlib.h"
#endif // JAPAN && i386
/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "tape_io.h"
#include "ica.h"
#include "cmos.h"
#include "rtc_bios.h"
#include "cmosbios.h"
#include "trace.h"
#include "debug.h"
#include "quick_ev.h"

extern void xmsEnableA20Wrapping(void);
extern void xmsDisableA20Wrapping(void);

#define ONE_MEGABYTE    (1024 * 1024)
#define SIXTY_FOUR_K    (64 * 1024)
#define	WRAP_AREA(addr) (addr) >= ONE_MEGABYTE && (addr) < ONE_MEGABYTE + SIXTY_FOUR_K

#if defined(JAPAN) && defined(i386)
#define	PAGE_SIZE	4096
LOCAL HANDLE	     mvdm_process_handle= NULL;
LOCAL unsigned char *int15_ems_commit;
LOCAL unsigned char *int15_ems_buf = NULL;
LOCAL unsigned long  int15_ems_start = 0;
LOCAL unsigned long  int15_ems_end = 0;
LOCAL int	     int15_ems_init;

LOCAL int init_int15_ext_mem();
LOCAL int map_int15_ext_mem(unsigned char *start_add, unsigned long size);
#endif // JAPAN && i386
LOCAL q_ev_handle wait_event_handle = (q_ev_handle)0;

/* Call back routine that needs to set a user's flag byte */
LOCAL void wait_event IFN1(long, parm)
{
	LIN_ADDR addr = (LIN_ADDR)parm;

	note_trace1(CMOS_VERBOSE, "INT15_EVENT_WAIT: delay complete: flag at %05x\n", addr);

	sas_store( addr, sas_hw_at( addr ) | 0x80 );
	wait_event_handle = (q_ev_handle)0;
}

void cassette_io()
{
#ifdef PM
#ifndef	CPU_30_STYLE
IMPORT void retrieve_descr_fields IPT4(half_word *, AR, sys_addr *, base,
	word *, limit, sys_addr, descr_addr);
#endif	/* not CPU_30_STYLE */
half_word cmos_u_m_s_hi;
half_word cmos_u_m_s_lo;
sys_addr gdt;
sys_addr  source;
sys_addr  source_base;
sys_addr  target;
#if (!defined(PROD) || !defined(CPU_30_STYLE))
sys_addr      source_limit;
sys_addr      target_limit;
#endif
sys_addr  target_base;
sys_addr byte_count;   /* Max size is 0x8000 * 2 = 10000 */
#ifdef CPU_30_STYLE
DESCR src_entry;
DESCR dst_entry;
#else
half_word source_AR;
half_word target_AR;
#endif /* CPU_30_STYLE */
#endif /* PM */

	half_word	mask,		/* interrupt mask			*/
			alarm;		/* value read from alarm register	*/	

#if defined(NTVDM) && defined(MONITOR)
        IMPORT word conf_15_seg, conf_15_off;
#endif /* NTVDM & MONITOR */
        /*
         *	Determine function
         */
	switch ( getAH() )
	{
	case INT15_DEVICE_OPEN:
        case INT15_DEVICE_CLOSE:
        case INT15_PROGRAM_TERMINATION:
        case INT15_REQUEST_KEY:
        case INT15_DEVICE_BUSY:
		setAH( 0 );
                setCF( 0 );
                break;

	case INT15_EMS_DETERMINE:
#if 0 /* I'm sure we've all had enough of this one */
                always_trace0("INT15 Extended Memory Access");
#endif
#ifdef PM
                outb(CMOS_PORT, CMOS_U_M_S_LO);
                inb(CMOS_DATA, &cmos_u_m_s_lo);
                outb(CMOS_PORT, CMOS_U_M_S_HI);
                inb(CMOS_DATA, &cmos_u_m_s_hi);
                setAH(cmos_u_m_s_hi);
                setAL(cmos_u_m_s_lo);
#if defined(JAPAN) && defined(i386)
		/* Save max memory for Int 15 memory function */
		int15_ems_start=1024*1024;
		int15_ems_end  =(unsigned long)(((cmos_u_m_s_hi*256)
				+cmos_u_m_s_lo+1024)*1024);
#endif // JAPAN && i386
#else
                setAX ( 0 );
#endif /* PM */
		break;
        case INT15_MOVE_BLOCK:
#ifdef PM
#if defined(JAPAN) && defined(i386)
	/* Int 15 memory service for $disp.sys and other */
	{
		unsigned char	*index;
		unsigned char	*src;
		unsigned char	*dst;
		unsigned long	tfr_size;
		int		use_this=0;
		int		rc;

		/* Check initialized */
		if(int15_ems_init == 0){
			rc=init_int15_ext_mem();
			int15_ems_init = (rc==SUCCESS) ? 1 : -1;
		}

		/* Check reserved Vertiual mamory */
		if(int15_ems_init < 0){
			DbgPrint("MVDM: Move block out of memory\n");
			setCF (1);
			setAH (0);
			break;
		}

		/* Get Address and size */
		tfr_size=getCX()*2;

		index=(unsigned char *)((getES()<<4) + getSI());
		src=(unsigned char *)(	 ((unsigned long)index[0x12])
					+((unsigned long)index[0x13]<<8)
					+((unsigned long)index[0x14]<<16));
		dst=(unsigned char *)(	 ((unsigned long)index[0x1a])
					+((unsigned long)index[0x1b]<<8)
					+((unsigned long)index[0x1c]<<16));
//		DbgPrint("MVDM: Move block %08x to %08x\n",src,dst);

		/* If over 1MB, convert internal memory (src)*/
		if((unsigned long)src > int15_ems_start){
			use_this=1;
			if (((unsigned long)src + tfr_size) > int15_ems_end){
				DbgPrint("MVDM: Move block out of range (src)\n");
				setCF(1);
				setAH(0);
				break;
			}
			src = int15_ems_buf + ((unsigned long)src - int15_ems_start);
			rc = map_int15_ext_mem(src, tfr_size);
			if (rc!=SUCCESS){
				setCF(1);
				setAH(0);
				break;
			}
		}

		/* If over 1MB, convert internal memory dst)*/
		if((unsigned long)dst > int15_ems_start){
			use_this=1;
			if (((unsigned long)dst + tfr_size) > int15_ems_end){
				DbgPrint("MVDM: Move block out of range (dst)\n");
				setCF(1);
				setAH(0);
				break;
			}
			dst = int15_ems_buf + ((unsigned long)dst - int15_ems_start);
			rc = map_int15_ext_mem(dst, tfr_size);
			if (rc!=SUCCESS){
				setCF(1);
				setAH(0);
				break;
			}
		}

		/* Transfer! (Not so good routine) */
		if(use_this){
			while(tfr_size){
				*dst = *src;
				dst++;
				src++;
				tfr_size--;
			}
			setAH(0);
			setCF(0);
			break;
		}
	}
#endif // JAPAN && i386
               /* Unlike the real PC we don't have to go into protected
                  mode in order to address memory above 1MB, thanks to
                  the wonders of C this function becomes much simpler
                  than the contortions of the bios */

               gdt = effective_addr(getES(), getSI());
               source = gdt + 0x10;   /* see layout in bios listing */
               target = gdt + 0x18;

#ifdef CPU_30_STYLE
	       read_descriptor(source, &src_entry);
	       read_descriptor(target, &dst_entry);
	       source_base = src_entry.base;
	       target_base = dst_entry.base;
#ifndef PROD
	       source_limit = src_entry.limit;
	       target_limit = dst_entry.limit;
#endif

		assert1( (src_entry.AR & 0x9e) == 0x92, "Bad source access rights %x", src_entry.AR );
		assert1( (dst_entry.AR & 0x9e) == 0x92, "Bad dest access rights %x", dst_entry.AR );

#else /* CPU_30_STYLE */
		/* retrieve descriptor information for source */
		retrieve_descr_fields(&source_AR, &source_base, &source_limit, source);

		/* retrieve descriptor information for target */
		retrieve_descr_fields(&target_AR, &target_base, &target_limit, target);
#endif /* CPU_30_STYLE */

		/* make word count into a byte count */
		byte_count = getCX() << 1;

		assert1( byte_count <= 0x10000, "Invalid byte_count %x", byte_count );

		/* Check count not outside limits of target
			 and source blocks. */

		assert0( byte_count <= source_limit + 1, "Count outside source limit" );
		assert0( byte_count <= target_limit + 1, "Count outside target limit" );

		/* TO DO: Check base addresses of target and source
			 fall within the area of extended memory
			 that we support */

		/* Go to it */
		if (sas_twenty_bit_wrapping_enabled())
		{
#ifdef NTVDM
			/* call xms functions to deal with A20 line */
			xmsDisableA20Wrapping();
			sas_move_words_forward ( source_base, target_base, byte_count >> 1);
			xmsEnableA20Wrapping();
#else
			sas_disable_20_bit_wrapping();
			sas_move_words_forward ( source_base, target_base, byte_count >> 1);
			sas_enable_20_bit_wrapping();
#endif /* NTVDM */
		}
		else
			sas_move_words_forward ( source_base, target_base, byte_count >> 1);

		/* set for good completion, just like bios after reset */
		setAH(0);
		setCF(0);
		setZF(1);
		setIF(1);
#else
		setCF(1);
		setAH(INT15_INVALID);
#endif
		break;

        case INT15_VIRTUAL_MODE:
                always_trace0("INT15 Virtual Mode (Go into PM)");
#ifdef	PM
		/*
		 * This function returns to the user in protected mode.
		 *
		 * See BIOS listing 5-174 AT Tech Ref for full details
		 *
		 * Upon entry the following is expected to be set up:-
		 *
		 *		ES	- GDT segment
		 *		SI	- GDT offset
		 *		BH	- hardware int level 1 offset
		 *		BL	- hardware int level 2 offset
		 *
		 * Also
		 *
		 *	(ES:SI)	->	0 +-------------+
		 *			  |	 DUMMY	|
		 *			8 +-------------+
		 *			  |	 GDT	|
		 *			16+-------------+
		 *			  |	 IDT	|
		 *			24+-------------+
		 *			  |	 DS	|
		 *			32+-------------+
		 *			  |	 ES	|
		 *			40+-------------+
		 *			  |	 SS	|
		 *			48+-------------+
		 *			  |	 CS	|
		 *			52+-------------+
		 *			  |  (BIOS CS)	|
		 *			  +-------------+
		 */
		
		/* Clear interrupt flag - no ints allowed in this mode. */
		setIF(0);
		 		
		/* Enable a20. */
		sas_disable_20_bit_wrapping();

		/* Reinitialise ICA0 to the offset given in BH. */
		outb(ICA0_PORT_0, (half_word)0x11);
		outb(ICA0_PORT_1, (half_word)getBH());
		outb(ICA0_PORT_1, (half_word)0x04);
		outb(ICA0_PORT_1, (half_word)0x01);
		outb(ICA0_PORT_1, (half_word)0xff);

		/* Reinitialise ICA1 to the offset given in BL. */
		outb(ICA1_PORT_0, (half_word)0x11);
		outb(ICA1_PORT_1, (half_word)getBL());
		outb(ICA1_PORT_1, (half_word)0x02);
		outb(ICA1_PORT_1, (half_word)0x01);
		outb(ICA1_PORT_1, (half_word)0xff);
		
		/* Set DS to the ES value for the bios rom to do the rest. */
		setDS(getES());

#else
		setCF(1);
		setAH(INT15_INVALID);
#endif	/* PM */
                break;

	case INT15_INTERRUPT_COMPLETE:
		break;
	case INT15_CONFIGURATION:
#if defined(NTVDM) && defined(MONITOR)
		setES( conf_15_seg );
		setBX( conf_15_off );
#else
		setES( getCS() );
		setBX( CONF_TABLE_OFFSET );
#endif
		setAH( 0 );
		setCF( 0 );
		break;

#ifdef	SPC486
	case 0xc9:
		setCF( 0 );
		setAH( 0 );
		setCX( 0xE401 );
		note_trace0(GENERAL_VERBOSE, "INT15: C9 chip revision");
		break;
#endif	/* SPC486 */

	/* Keyboard intercept 0x4f, wait_event 83, wait 86 are all no longer
	 * passed through from ROM.
	 */

#ifdef JAPAN
        case INT15_GET_BIOS_TYPE:
            if(getAL() == 0) {
                setCF(0);
                setBL(0);
                setAH(0);
            }
            else {
                setCF(1);
                setAH(INT15_INVALID);
            }
            break;
        case INT15_KEYBOARD_INTERCEPT:
        case INT15_GETSET_FONT_IMAGE:
#endif // JAPAN
	default:
		/*
		 *	All other functions invalid.
		 */			
#ifndef	PROD
	{
		LIN_ADDR stack=effective_addr(getSS(),getSP());

		IU16 ip = sas_w_at(stack);
		IU16 cs = sas_w_at(stack+2);

                note_trace3(GENERAL_VERBOSE, "INT15: AH=%02x @ %04x:%04x", getAH(), cs, ip);
	}
#endif	/* PROD */

		/* Fall through */

	case INT15_JOYSTICK:
	case 0x24: /* A20 wrapping control */
	case 0xd8: /* EISA device access */
	case 0x41: /* Laptop wait event */
 		setCF(1);
		setAH(INT15_INVALID);
		break;
	}
}

#if defined(JAPAN) && defined(i386)
/* Initialize int 15 memory */

LOCAL int init_int15_ext_mem()
{
	NTSTATUS status;
	unsigned char cmos_u_m_s_hi;
	unsigned char cmos_u_m_s_lo;
	unsigned long i;
	unsigned long max_commit_flag;
	unsigned long reserve_size;

	/* Check already get max int15 memory */
	if(int15_ems_start==0){
	        outb(CMOS_PORT, CMOS_U_M_S_LO);
	        inb(CMOS_DATA, &cmos_u_m_s_lo);
	        outb(CMOS_PORT, CMOS_U_M_S_HI);
	        inb(CMOS_DATA, &cmos_u_m_s_hi);
		int15_ems_start=1024*1024;
		int15_ems_end  =(unsigned long)(((cmos_u_m_s_hi*256)
				+cmos_u_m_s_lo+1024)*1024);
	}

//	DbgPrint("MVDM!init_int15_ems_mem:ems start=%08x\n",int15_ems_start);
//	DbgPrint("MVDM!init_int15_ems_mem:ems end  =%08x\n",int15_ems_end);

	/* Ger process handle for get Vertiual memory */
	if(!(mvdm_process_handle = NtCurrentProcess())){
		DbgPrint("MVDM!init_int15_ext_mem:Can't get process handle\n");
		return(FAILURE);
	}

	/* Reserve Viertual memory */
	reserve_size=int15_ems_end-int15_ems_start;
	status = NtAllocateVirtualMemory(mvdm_process_handle,
					&int15_ems_buf,
					0,
					&reserve_size,
					MEM_RESERVE,
					PAGE_READWRITE);
	if(!NT_SUCCESS(status)){
		DbgPrint("MVDM!init_int15_ext_mem:Can't reserve Viretual memory (%x)\n",status);
		return(FAILURE);
	}
//	DbgPrint("MVDM!init_int15_ems_mem:ems reserveed at %08x (%08xByte)\n",int15_ems_buf,reserve_size);

	/* Initialize commited area table */
	max_commit_flag=reserve_size/PAGE_SIZE;
	int15_ems_commit=(unsigned char *)malloc(max_commit_flag);
	if(int15_ems_commit==NULL){
		DbgPrint("MVDM!init_int15_ext_mem:Can't get control memory\n");
		return(FAILURE);
	}

	for(i=0;i<max_commit_flag;i++) int15_ems_commit[i]=0;
	return(SUCCESS);
}

/* Commit vertual memory for int 15 memory function */
LOCAL int map_int15_ext_mem(unsigned char *start_add, unsigned long size)
{
	NTSTATUS status;
	unsigned long i;
	unsigned long start;
	unsigned long end;
	unsigned char *commit_add;
	unsigned long commit_size;

	/* Get start/end page address */
	start= (unsigned long)start_add;
	end  = start+size;
	start= start/PAGE_SIZE;
	if (end % PAGE_SIZE)	end = (end/PAGE_SIZE)+1;
	else			end =  end/PAGE_SIZE;

	/* Commit vertual memory start to end address */
	for(i=start;i<end;i++){
		if(!int15_ems_commit[i]){
			commit_add=(unsigned char *)(i*PAGE_SIZE);
			commit_size=PAGE_SIZE;
			status = NtAllocateVirtualMemory(mvdm_process_handle,
							&commit_add,
							0,
							&commit_size,
							MEM_COMMIT,
							PAGE_READWRITE);
			if(!NT_SUCCESS(status)){
				DbgPrint("MVDM!map_int15_ext_mem:Can't commit Viretual memory %08x (%x)\n",commit_add,status);
				return(FAILURE);
			}
//			DbgPrint("MVDM!map_int15_ext_mem:Commit Viretual memory %08x-%08x\n",commit_add,commit_add+PAGE_SIZE);
			int15_ems_commit[i]=1;
		}
	}

	return(SUCCESS);
}
#endif // JAPAN && i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\rtc_bios.c ===
/*
 * @(#)rtc_bios.c	1.12 06/28/95
 *
 * This file has been deleted, its functionality has been replaced by
 * a pure Intel   implementation in bios4.rom
 */




/*
 *  But not for ntvdm!
 */


#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include CpuH
#include "host.h"
#include "bios.h"
#include "cmos.h"
#include "sas.h"
#include "ios.h"
#include "rtc_bios.h"

#ifdef NTVDM

/*
=========================================================================

FUNCTION	: rtc_int

PURPOSE		: interrupt called from real time clock

RETURNED STATUS	: None

DESCRIPTION	:


=======================================================================
*/
#ifdef MONITOR

  /*
  ** Tim, June 92, for Microsoft pseudo-ROM.
  ** Call the NTIO.SYS int 4a routine, not
  ** the one in real ROM.
  */
extern word rcpu_int4A_seg; /* in keybd_io.c */
extern word rcpu_int4A_off; /* in keybd_io.c */

#ifdef RCPU_INT4A_SEGMENT
#undef RCPU_INT4A_SEGMENT
#endif
#ifdef RCPU_INT4A_OFFSET
#undef RCPU_INT4A_OFFSET
#endif

#define RCPU_INT4A_SEGMENT rcpu_int4A_seg
#define RCPU_INT4A_OFFSET  rcpu_int4A_off

#endif




void rtc_int(void)

{
     half_word       regC_value,             /* value read from cmos register C      */
                     regB_value,             /* value read from cmos register B      */
                     regB_value2;            /* 2nd value read from register B       */
     DOUBLE_TIME     time_count;             /* timer count in microseconds          */
     double_word     orig_time_count;        /* timer count before decrement         */
     word            flag_seg,               /* segment address of users flag        */
                     flag_off,               /* offset address of users flag         */
                     CS_saved,               /* CS before calling re-entrant CPU     */
                     IP_saved;               /* IP before calling re-entrant CPU     */

     outb( CMOS_PORT, (CMOS_REG_C + NMI_DISABLE) );
     inb( CMOS_DATA, &regC_value );          /* read register C      */

     outb( CMOS_PORT, (CMOS_REG_B + NMI_DISABLE) );
     inb( CMOS_DATA, &regB_value );          /* read register B      */

     outb( CMOS_PORT, CMOS_SHUT_DOWN );

     regB_value &= regC_value;

     if  (regB_value & PIE)
     {
         /* decrement wait count */
         sas_loadw( RTC_LOW, &time_count.half.low );
         sas_loadw( RTC_HIGH, &time_count.half.high );
         orig_time_count = time_count.total;
         time_count.total -= TIME_DEC;
         sas_storew( RTC_LOW, time_count.half.low );
         sas_storew( RTC_HIGH, time_count.half.high );

         /* Has countdown finished       */
         if ( time_count.total > orig_time_count )       /* time_count < 0 ?     */
         {
              /* countdown finished   */
              /* turn off PIE         */
              outb( CMOS_PORT, (CMOS_REG_B + NMI_DISABLE) );
              inb( CMOS_DATA, &regB_value2 );
              outb( CMOS_PORT, (CMOS_REG_B + NMI_DISABLE) );
              outb( CMOS_DATA, (IU8)((regB_value2 & 0xbf)) );

              /* set users flag       */
              sas_loadw( USER_FLAG_SEG, &flag_seg );
              sas_loadw( USER_FLAG, &flag_off );
              sas_store( effective_addr(flag_seg, flag_off), 0x80 );

              /* check for wait active        */
              if( sas_hw_at(rtc_wait_flag) & 2 )
                  sas_store (rtc_wait_flag, 0x83);
              else
                  sas_store (rtc_wait_flag, 0);

         }
     }


     /*
      *  If alarm interrupt, call interrupt 4ah
      */
     if (regB_value & AIE)  {
         CS_saved = getCS();
         IP_saved = getIP();
         setCS( RCPU_INT4A_SEGMENT );
         setIP( RCPU_INT4A_OFFSET );
         host_simulate();
         setCS( CS_saved );
         setIP( IP_saved );
         }



     /*
      *  Eoi rtc interrupt
      */
     outb( ICA1_PORT_0, 0x20 );
     outb( ICA0_PORT_0, 0x20 );

     return;
}




#endif   /* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\virtual.c ===
#include "insignia.h"
#include "host_def.h"
/*
 *
 * Title	: virtual.c
 *
 * Description	: Virtual Machine support for Windows 3.x.
 *                aka Non-Intel Driver Data Block (NIDDB) Manager.
 *
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)virtual.c	1.9 07/05/95 Copyright Insignia Solutions Ltd.";
#endif

/*
 *    O/S include files.
 */
#include <stdio.h>
#include <malloc.h>

extern void ClearInstanceDataMarking(void);

#include TypesH
#include StringH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "virtual.h"
#include "error.h"
#include "debug.h"

/*
   This file implements the Non-Intel Driver Data Block (NIDDB) Manager. This
   service allows Insignia DOS Device Drivers or TSRs with C code and data to
   operate correctly under the Virtual Machines of Windows 3.x Enhanced Mode.
   Essentially the Device Driver informs this manager of the C (or Non-Intel)
   data area associated with the Driver and this manager does the rest, providing
   specific instances (copies) of the data area for each Virtual Machine. It
   performs it's work in cooperation with INSIGNIA.386 a Virtual Device Driver
   (VxD) written for the Windows 3.x enviroment.

   First a quick summary of the Device Drivers viewpoint. All driver data is
   assembled into one data structure:-

      typedef struct
	 {
	 IU32 my_var_1;
	 IU8  my_var_2;
	 } MY_INSTANCE_DATA, **MY_INSTANCE_DATA_HANDLE;

   and a variable is reserved to hold a handle (a handle is merely a pointer to
   a pointer) to the data structure:-

      MY_INSTANCE_DATA_HANDLE my_handle;

   Optionally a create callback procedure can be defined:-

      void create_callback IFN1
	 (
	 MY_INSTANCE_DATA_HANDLE, orig_handle
	 )
	 {
	 ....
	 }

   Optionally a terminate callback procedure can be defined:-

      void terminate_callback IFN0()
	 {
	 ....
	 }

   When the driver is initialised (as DOS boots) the initial data area is
   requested from the NIDDB Manager:-

      my_handle = (MY_INSTANCE_DATA_HANDLE)NIDDB_Allocate_Instance_Data(
		     sizeof(MY_INSTANCE_DATA),
		     create_callback,       (0 if no callback required)
		     terminate_callback);   (0 if no callback required)

   A return value of 0 indicates an error has occured and the data area can't be
   supported, otherwise the NIDDB Manager has taken control of the data area.
   After this all accesses to the data area should be via the handle, further
   dereferenced variables within the data area should not be saved over BOP
   invocations. Correct access is as follows:-

      (*my_handle)->my_var_1 = 1;
      (*my_handle)->my_var_2 = 2;

   The NIDDB Manager will call the create_callback function during the initial
   NIDDB_Allocate_Instance_Data call (initial_instance is TRUE) or during the
   creation of each Virtual Machine (initial_instance is FALSE). Typically the
   create callback is used to initialise any data variables for the new instance.
   It is particularly important that, for example, pointers to dynamically
   allocated host memory are initialised, otherwise duplicate host pointers may
   result. Note for the creation of Virtual Machines all variables will have
   been copied from the initial instance before the create callback routine is
   called. However the create_callback function must copy any dynamically
   allocated data structures referenced from the instanced variables, the
   parameter 'orig_handle' points to the source instance.

   The NIDDB Manager will call the terminate_callback function just before a
   Virtual Machine (and hence its associated data) is terminated. The data
   variables active will be those of the terminating Virtual Machine. During
   the terminate callback the device driver can perform housekeeping as required.
   For example, if a variable is a pointer to dynamically allocated host memory,
   then the host memory may be freed.

   When the device driver terminates (just ahead of reboot) it should inform the
   NIDDB Manager that the data area is no longer required:-

      NIDDB_Deallocate_Instance_Data(my_handle);


   Now an internal viewpoint. We are driven by two masters, firstly the
   NIDDB_Allocate_Instance_Data and NIDDB_Deallocate_Instance_Data calls which
   require memory allocation and freeing, and secondly the VxD messages (from
   INSIGNIA.386) which require creation, swapping and deletion of any defined
   data areas. It is possible that these two masters make contradictory requests.

   The NIDDB Manager makes a couple of simplyfing assumptions to ease the
   implementation and clarify it's responses to conflicting requests.

   1) Only a very small number of data areas are expected to be allocated, there
   being only a few Insignia device drivers. Hence a very small fixed table is
   used to hold each allocated handle. This avoids the slightly more complex
   use of linked lists.

   2) Once we have started instancing the data areas (Sys_VM_Init) no new data
   areas may be allocated or deallocated until after all instancing has been
   terminated (System_Exit, Device_Reboot_Notify).

   3) A specific entry point (NIDDB_System_Reboot) is used to catch reboots
   (usually from User Interface) which bypass the normal Windows exit sequence.


   Now an overview of of the data structures employed:-

      master_ptrs     Fixed length table of master pointers.
		      Pointed to by handles returned to Device Driver, hence can
		      not be moved or have entries re-assigned. A zero entry
		      indicates that the handle is free for allocation. It in
		      effect holds the current pointers for the exported handles.

      snapshot_ptrs   Fixed length table of snapshot pointers.
                      While initial allocation is in progress, this table mirrors
		      the master_ptrs table. Once instancing starts the table
		      holds the pointers to the initial data. This data is used
		      to initialise each new instance, it is also restored as
		      the current data when instancing terminates.

      instance_size   Fixed length table of byte sizes.
		      Holds data area size for each allocated data area.

      create_callback      Fixed length table of function pointers.
			   Holds create callback function pointer for each
			   allocated data area. A zero value indicates no
			   callback exists.

      terminate_callback   Fixed length table of function pointers.
			   Holds terminate callback function pointer for each
			   allocated data area. A zero value indicates no
			   callback exists.

      vrecs           Fixed length table of 'virtual records'.
		      Each virtual record hold two entries, the instance handle
		      of the Windows Virtual Machine and a pointer to the
		      associated instance_ptrs. It is indexed via the BIOS
		      virtualising byte value. It hooks together the Virtual
		      Machine messages and our native data area allocations.

      instance_ptrs   Fixed length table which is dynamically allocated for
		      each new instance, its layout and meaning follows that of
		      the master_ptrs, except the pointers are to the instance
		      copy of the data areas. When an instance is swapped to, the
		      pointers held here are copied to master_ptrs.

      allocation_allowed   Boolean which controls Device Driver allocation and
			   deallocation requests.

   And an overview of the functions employed (minus error handling):-

      NIDDB_Allocate_Instance_Data

	 Allocate (host_malloc) data area of requested size.
	 Find entry in master_ptrs(and snapshot_ptrs) and set to pointer to
	 allocated data area.
	 Save size of data area in instance_size.
	 Save create and terminate callbacks.
	 Return pointer to master_ptrs entry, ie the handle.

      NIDDB_Deallocate_Instance_Data

	 Deallocate (host_free) data area given by input handle.
	 Set master_ptrs(and snapshot_ptrs) entry to 0.

      allocate_NIDDB

	 Allocate new instance_ptrs table.
	 Allocate space for all data areas requested for instancing, storing
	 pointers in new instance_ptrs table.
	 Set up new entry in vrecs and return index to it.

      copy_instance_data

	 Copy data in one instanced data block (typically the snapshot, ie
	 using the pointers in snapshot_ptrs) to another instanced data block
	 (typically a new instance, ie using the pointers in instance_ptrs).

      restore_snapshot

	 Copy snapshot_ptrs to master_ptrs.

      NIDDB_is_active

	 Return true if the driver is active (ie allocation is disallowed)

      NIDDB_present

	 Return true if any vrec is active (ie holds non zero pointer).

      delete_NIDDB

	 Given index to vrecs, access instance_ptrs table.
	 Call terminate callbacks.
	 Deallocate (host_free) all data areas in instance_ptrs table.
	 Deallocate (host_free) instance_ptrs table.
	 Zero vrec entry.

      deallocate_specific_NIDDB

	 Search vrec table for given instance handle to Windows Virtual Machine,
	 then call delete_NIDDB to remove the instance.

      deallocate_all_NIDDB

	 Search vrec table for all active instance handles to Windows Virtual
	 Machines, calling delete_NIDDB to remove each instance.

      swap_NIDDB

	 Given current virtualising byte, look up appropriate vrec entry for
	 pointer to instance_ptrs table.
	 Copy instance_ptrs to master_ptrs.
 */

/* Control Messages received by Virtual Device Drivers (Windows 3.1) */
#define VxD_Sys_Critical_Init		0x00
#define VxD_Device_Init			0x01
#define VxD_Init_Complete		0x02
#define VxD_Sys_VM_Init			0x03
#define VxD_Sys_VM_Terminate		0x04
#define VxD_System_Exit			0x05
#define VxD_Sys_Critical_Exit		0x06
#define VxD_Create_VM			0x07
#define VxD_VM_Critical_Init		0x08
#define VxD_VM_Init 			0x09
#define VxD_VM_Terminate		0x0A
#define VxD_VM_Not_Executeable		0x0B
#define VxD_Destroy_VM			0x0C
#define VxD_VM_Suspend			0x0D
#define VxD_VM_Resume			0x0E
#define VxD_Set_Device_Focus		0x0F
#define VxD_Begin_Message_Mode		0x10
#define VxD_End_Message_Mode		0x11
#define VxD_Reboot_Processor		0x12
#define VxD_Query_Destroy		0x13
#define VxD_Debug_Query			0x14
#define VxD_Begin_PM_App		0x15
#define VxD_End_PM_App			0x16
#define VxD_Device_Reboot_Notify	0x17
#define VxD_Crit_Reboot_Notify		0x18
#define VxD_Close_VM_Notify 		0x19
#define VxD_Power_Event			0x1A

/*
   Define number of data instances we are prepared to manage.
   Note by design this is kept to a very small number.
 */
#define MAX_INSTANCES 4

/*
   Define number of Virtual Machines we are prepared to support.
   The virtualising byte would allow a maximuum of 256.
 */
#define MAX_VMS 80

typedef struct
   {
   IU32 vr_inst_handle;	/* Windows instance handle for Virtual Machine */
   IHP *vr_pinst_tbl;	/* Pointer to host instance_ptr table */
   } VIRTUAL_RECORD;

/*
   The static data structures.
 */
LOCAL IHP master_ptrs[MAX_INSTANCES];
LOCAL IHP snapshot_ptrs[MAX_INSTANCES];
LOCAL IU32 instance_size[MAX_INSTANCES];   /* in bytes */

LOCAL NIDDB_CR_CALLBACK create_callback[MAX_INSTANCES];
LOCAL NIDDB_TM_CALLBACK terminate_callback[MAX_INSTANCES];

LOCAL VIRTUAL_RECORD vrecs[MAX_VMS];

LOCAL IBOOL allocation_allowed = TRUE;
LOCAL IU32 insignia_386_version;	/* Version number of out intel VxD code */
LOCAL last_virtual_byte = 0;   /* ID of last Virtual Machine seen */

/*
   Prototype local routines.
 */
LOCAL IBOOL allocate_NIDDB IPT2
   (
   IU32,  inst_handle,
   int *, record_id
   );

LOCAL void copy_instance_data IPT2
   (
   IHP *, to,
   IHP *, from
   );

LOCAL void deallocate_all_NIDDB IPT0();

LOCAL void deallocate_specific_NIDDB IPT1
   (
   IU32, inst_handle
   );

LOCAL void delete_NIDDB IPT1
   (
   int, record_id
   );

LOCAL IBOOL NIDDB_present IPT0();

LOCAL void restore_snapshot IPT0();

LOCAL void swap_NIDDB IPT1
   (
   IU8, vb
   );

/* =========================================================================== */
/* LOCAL ROUTINES                                                              */
/* =========================================================================== */

/* Allocate data structures required for new data instance. */
LOCAL IBOOL allocate_NIDDB IFN2
   (
   IU32,  inst_handle,	/* (I ) Windows handle for Virtual Machine */
   int *, record_id	/* ( 0) Record ID (ie virtualising byte value) */
   )
   {
   int v;
   int i;
   IHP *p;
   IHP *instance_ptr;

   /* Search for empty virtual record */
   for (v = 0; v < MAX_VMS; v++)
      {
      if ( vrecs[v].vr_pinst_tbl == (IHP *)0 )
	 break;   /* found empty slot */
      }

   /* Ensure we found empty slot */
   if ( v == MAX_VMS )
      {
      /* No free slot! */
      always_trace0("NIDDB: Too many Virtual Machines being requested.");
      return FALSE;
      }

   /* Allocate new instance table - ensure it is zero */
   if ( (instance_ptr = (IHP *)host_calloc(1, sizeof(master_ptrs))) == (IHP *)0 )
      {
      /* No room at the inn */
      return FALSE;
      }

   /* Allocate new data areas */
   for (i = 0, p = instance_ptr; i < MAX_INSTANCES; i++, p++)
      {
      /* Use master pointer as the 'creation template' */
      if ( master_ptrs[i] != (IHP *)0 )
	 {
	 if ( (*p = (IHP)host_malloc(instance_size[i])) == (IHP)0 )
	    {
	    /* No room at the inn */

	    /* Clean up any blocks which may have been allocated */
	    for (i = 0, p = instance_ptr; i < MAX_INSTANCES; i++, p++)
	       {
	       if ( *p != (IHP)0 )
		  host_free(*p);
	       }

	    return FALSE;
	    }
	 }
      }

   /* Finally fill in virtual record */
   vrecs[v].vr_inst_handle = inst_handle;
   vrecs[v].vr_pinst_tbl = instance_ptr;
   *record_id = v;
   return TRUE;
   }

/* Copy data items from one instance to another */
LOCAL void copy_instance_data IFN2
   (
   IHP *, to,	/* (I ) Pntr to table of destination area pointers */
   IHP *, from 	/* (I ) Pntr to table of source area pointers */
   )
   {
   int i;

   /*
      Note the 'from' instance is assumed to be currently active, ie activated
      by the caller.
    */

   /* Process each possible data area */
   for (i = 0; i < MAX_INSTANCES; i++, to++, from++)
      {
      if ( *to != (IHP)0 )
	 {
	 /* Copy data for this instance */
	 memcpy(*to, *from, instance_size[i]);

	 /* Action any create callback */
	 if ( create_callback[i] != (NIDDB_CR_CALLBACK)0 )
	    {
	    (create_callback[i])(from);
	    }
	 }
      }
   }

/* Find all data instances and delete them. */
LOCAL void deallocate_all_NIDDB IFN0()
   {
   int v;

   /* Search (linear) table for all extant data instances */
   for (v = 0; v < MAX_VMS; v++ )
      {
      if ( vrecs[v].vr_pinst_tbl != (IHP *)0 )
	 {
	 /* Found extant instance - eliminate */
	 delete_NIDDB(v);
	 }
      }
   }

/* Find given data instance and delte it.*/
LOCAL void deallocate_specific_NIDDB IFN1
   (
   IU32, inst_handle	/* Windows handle for Virtual Machine */
   )
   {
   int v;

   /* Search (linear) table for given VM handle */
   for (v = 0; v < MAX_VMS; v++ )
      {
      if ( vrecs[v].vr_inst_handle == inst_handle )
	 {
	 /* Found deletion candidate - eliminate */
	 delete_NIDDB(v);
	 return;   /* all done, handles are unique */
	 }
      }

   /* Search fails - moan */
   always_trace0("NIDDB: Attempt to remove non existant VM data instance.");
   }

/* Deallocate all data and structues for given data instance. */
LOCAL void delete_NIDDB IFN1
   (
   int, record_id	/* (I ) Record ID (ie virtualising byte value) */
   )
   {
   int i;
   IHP *instance_ptr;

   /* Ensure instance is active (for terminate callback). */
   swap_NIDDB((IU8)record_id);

   instance_ptr = vrecs[record_id].vr_pinst_tbl;

   /* Deallocate all data areas in instance_ptr table. */
   for (i = 0; i < MAX_INSTANCES; i++, instance_ptr++)
      {
      if ( *instance_ptr != (IHP)0 )
	 {
	 /* Action any terminate callback */
	 if ( terminate_callback[i] != (NIDDB_TM_CALLBACK)0 )
	    {
	    (terminate_callback[i])();
	    }

	 /* free up memory */
	 host_free(*instance_ptr);
	 }
      }

   /* Deallocate the instance_ptr table itself */
   host_free((IHP)vrecs[record_id].vr_pinst_tbl);

   /* Initialise virtual record entry */
   vrecs[record_id].vr_pinst_tbl = (IHP *)0;
   vrecs[record_id].vr_inst_handle = (IU32)0;
   }

/* Return true if any data instance is extant */
LOCAL IBOOL NIDDB_present IFN0()
   {
   int v;

   /* Search (linear) table for any extant data instances */
   for (v = 0; v < MAX_VMS; v++ )
      {
      if ( vrecs[v].vr_pinst_tbl != (IHP *)0 )
	 return TRUE;   /* Found extant instance */
      }

   return FALSE;   /* Nothing found */
   }

/* Restore master pointers to point to snapshot (initial) data */
LOCAL void restore_snapshot IFN0()
   {
   int i;

   for (i= 0; i < MAX_INSTANCES; i++ )
      {
      master_ptrs[i] = snapshot_ptrs[i];
      }

   last_virtual_byte = 0;

   allocation_allowed = TRUE;   /* Remove lock on Insignia Device Driver calls */
   }

/* Set up pointers to new instance data in master pointers */
LOCAL void swap_NIDDB IFN1
   (
   IU8, vb
   )
   {
   int i;
   IHP *instance_ptrs;

   instance_ptrs = vrecs[vb].vr_pinst_tbl;

   for (i = 0; i < MAX_INSTANCES; i++, instance_ptrs++)
      {
      master_ptrs[i] = *instance_ptrs;
      }

   last_virtual_byte = vb;
   }

/* =========================================================================== */
/* GLOBAL ROUTINES                                                             */
/* =========================================================================== */

/* Allocate per Virtual Machine data area for Device Driver. */
GLOBAL IHP *NIDDB_Allocate_Instance_Data IFN3
   (
   int, size,				/* Size of data area required */
   NIDDB_CR_CALLBACK, create_cb,	/* create callback */
   NIDDB_TM_CALLBACK, terminate_cb	/* terminate callback */
   )
   {
   int i;

   if ( !allocation_allowed )
      {
      /* We are still managing instances for Windows, we can't add more data
	 Instances on the fly! */
      return (IHP *)0;
      }

   /* Find available instance slot */
   for (i = 0; i < MAX_INSTANCES; i++)
      {
      if ( master_ptrs[i] == (IHP)0 )
	 break;   /* found empty slot */
      }

   if ( i == MAX_INSTANCES )
      {
      /* No free slot */
      always_trace0("NIDDB: Too many Data Instances being requested.");
      return (IHP)0;
      }

   /* Allocate data area */
   if ( (master_ptrs[i] = (IHP)host_malloc(size)) == (IHP)0 )
      {
      return (IHP)0;   /* No room at inn */
      }

   /* Save details of this instance */
   snapshot_ptrs[i] = master_ptrs[i];
   instance_size[i] = size;

   /* Save callbacks */
   create_callback[i] = create_cb;
   terminate_callback[i] = terminate_cb;

   return &master_ptrs[i];   /* return handle */
   }

/* Deallocate per Virtual Machine data area for Device Driver. */
GLOBAL void NIDDB_Deallocate_Instance_Data IFN1
   (
   IHP *, handle	/* Handle to data area */
   )
   {
   int i;

   if ( !allocation_allowed )
      {
      /*
	 We are still managing instances for Windows, or at least we think we
	 are. Has the user escaped from Windows without our VxD being informed,
	 or is the Insignia Device Driver giving us a bum steer?
       */
      always_trace0("NIDDB: Unexpected call to NIDDB_Deallocate_Instance_Data.");

      /* We might give the Insignia Device Driver the benefit of the doubt and
	 act like a System_Exit message. - Then again we might just ignore em. */
      return;
      }

   /* Find index to master_ptrs, etc. */
   i = handle - &master_ptrs[0];
   if ( i < 0 || i >= MAX_INSTANCES )
      {
      always_trace0("NIDDB: Bad handle passed to NIDDB_Deallocate_Instance_Data.");
      return;
      }

   /* Free data area */
   host_free(master_ptrs[i]);

   /* Initialise entry */
   master_ptrs[i] = snapshot_ptrs[i] = (IHP)0;
   instance_size[i] = (IU32)0;
   create_callback[i] = (NIDDB_CR_CALLBACK)0;
   terminate_callback[i] = (NIDDB_TM_CALLBACK)0;

   return;
   }

/* Catch System Reboot (if all else fails) and destroy data instances. */
GLOBAL void NIDDB_System_Reboot IFN0()
   {
   /* Act like a Windows Device_Reboot_Notify */
   deallocate_all_NIDDB();
   restore_snapshot();
   }

#ifdef CPU_40_STYLE
/* Indicate if NIDDB is active, based on whether Device Driver allocation is allowed */
GLOBAL IBOOL NIDDB_is_active IFN0()
{
	return(!allocation_allowed);
}

/*
   Entry point from Windows 386 Virtual Device Driver (INSIGNIA.386) - Provide
   virtualising services as required.
 */
GLOBAL void
virtual_device_trap IFN0()
   {
   int new_vb;

   switch ( getEAX() )
      {
   case VxD_Device_Init:
      /* We can check that the Intel version is valid */

      insignia_386_version = getDX();

      always_trace2("386 VxD: Device_Init version %d.%02d",
		    insignia_386_version / 100,
		    insignia_386_version % 100);

      /* pm selectors for virtualisation are in ebx and ecx */

      if ((getBX() !=0) && (getCX() !=0))
	sas_init_pm_selectors (getBX(), getCX());
      else
	always_trace0("386 VxD: Device_Init. Failed to get pm selectors!!");

      /* Compatibility test:
       * Return in top half of EDX the the "current" Intel version of the driver.
       * This allows an incompatible future driver to reject an old SoftWindows.
       */
#define INTEL_VERSION	102
      setEDX(INTEL_VERSION << 16);
      break;

   case VxD_Sys_VM_Init:
      always_trace0("386 VxD: Sys_VM_Init.");

      /* As safety measure undo anything which may be currently active */
      deallocate_all_NIDDB();
      restore_snapshot();

      /* Lock out Insignia Device Driver requests */
      allocation_allowed = FALSE;

      /* Form new instance */
      if ( allocate_NIDDB(getEBX(), &new_vb) )
	 {
	 /* Make new instance active (for create callback) */
	 swap_NIDDB((IU8)new_vb);

	 /* Copy instance data and action create callback */
	 copy_instance_data(vrecs[new_vb].vr_pinst_tbl, snapshot_ptrs);

	 /* Return virtualising byte to INSIGNIA.386 */
	 setEAX(new_vb);
	 }
      else
	 {
	 /* We can't do it */
	 setCF(1);   /* Inform Windows that Virtual Machine can't be created */
	 host_error(EG_MALLOC_FAILURE, ERR_CONT , "");
	 }
      break;

   case VxD_VM_Init:
      always_trace0("386 VxD: VM_Init.");
      /* Form new instance */
      if ( allocate_NIDDB(getEBX(), &new_vb) )
	 {
	 /* Make new instance active (for create callback) */
	 swap_NIDDB((IU8)new_vb);

	 /* Copy instance data and action create callback */
	 copy_instance_data(vrecs[new_vb].vr_pinst_tbl, snapshot_ptrs);

	 /* Return virtualising byte to INSIGNIA.386 */
	 setEAX(new_vb);
	 }
      else
	 {
	 /* We can't do it */
	 setCF(1);   /* Inform Windows that Virtual Machine can't be created */
	 host_error(EG_MALLOC_FAILURE, ERR_CONT , "");
	 }
      break;

   case VxD_VM_Not_Executeable:
      always_trace0("386 VxD: VM_Not_Executeable.");
      deallocate_specific_NIDDB(getEBX());
      break;

   case VxD_Device_Reboot_Notify:
      always_trace0("386 VxD: Device_Reboot_Notify.");
      deallocate_all_NIDDB();
      restore_snapshot();

      /* Clear our version number in case we are changing disks */
      insignia_386_version = 0;
      break;

   case VxD_System_Exit:
      always_trace0("386 VxD: System_Exit.");
      deallocate_all_NIDDB();
      restore_snapshot();
      ClearInstanceDataMarking();

#ifndef NTVDM
      host_mswin_disable();
#endif /* ! NTVDM */

      /* Clear our version number in case we are changing disks */
      insignia_386_version = 0;
      break;

   default:
      always_trace1("386 VxD: Unrecognised Control Message. 0x%02x", getEAX());
      }
   }

/* Ensure correct instance in place for Device Drivers. */
/* Called by BOP handler(bios.c) for any Device Driver BOP. */
GLOBAL void
virtual_swap_instance IFN0()
   {
   IU8 current_virtual_byte;

   /* If instances can be created then Windows isn't active yet */
   if ( allocation_allowed )
      return;

   /* read virtualising byte and compare with current ID */
   sas_load(BIOS_VIRTUALISING_BYTE, &current_virtual_byte);

   if ( current_virtual_byte == last_virtual_byte )
      return;   /* Nothing to do */

   /* Swap data areas */
   always_trace0("Swapping data instances.");
   swap_NIDDB(current_virtual_byte);
   return;
   }
#endif	/* CPU_40_STYLE */


#ifdef CPU_40_STYLE
/* To support a mis-matched disk spcmswd.drv and insignia.386 we
 * do the setting of virtualisation selectors here, if the
 * insignia.386 driver is less than version 1. Later drivers
 * use VxD_Device_Init to set the selectors.
 */
GLOBAL void set_virtual_selectors_from_mswdvr IFN0()
{
	if (insignia_386_version < 1)
	{
		sas_init_pm_selectors (getCX(), getDX());
	}
}
#endif	/* CPU_40_STYLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\bios\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


MAJORCOMP=spcbase
MINORCOMP=bios


TARGETNAME=bios
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=\
    $(SOFTPC_TREE)\host\inc;\
    $(SOFTPC_TREE)\base\inc

SOURCES=..\bios.c        \
        ..\cmos_bis.c    \
        ..\cntlbop.c     \
        ..\emm_fncs.c    \
        ..\reset.c       \
        ..\rom_basc.c    \
        ..\rtc_bios.c    \
        ..\slave_bs.c    \
        ..\tape_io.c     \
        ..\equipmnt.c    \
        ..\ill_bop.c     \
        ..\build_id.c    \
        ..\virtual.c     \
        ..\mem_size.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC

UMTYPE=console
SOURCES_USED=..\sources.inc

!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\aaa.c ===
/*[

aaa.c

LOCAL CHAR SccsID[]="@(#)aaa.c	1.5 02/09/94";

AAA CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>

#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <aaa.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
AAA()
   {
   if ( (GET_AL() & 0xf) > 9 || GET_AF() )
      {
      SET_AX(GET_AX() + 6);
      SET_AH(GET_AH() + 1);
      SET_CF(1); SET_AF(1);
      }
   else
      {
      SET_CF(0); SET_AF(0);
      }
   SET_AL(GET_AL() & 0xf);

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_OF(UNDEFINED_FLAG);
   SET_SF(UNDEFINED_FLAG);
   SET_ZF(UNDEFINED_FLAG);
   SET_PF(UNDEFINED_FLAG);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\aad.c ===
/*[

aad.c

LOCAL CHAR SccsID[]="@(#)aad.c	1.5 02/09/94";

AAD CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <aad.h>

/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
AAD
                 
IFN1(
	IU32, op1
    )


   {
   IU8 temp_al;

   temp_al = GET_AH() * op1 + GET_AL();
   SET_AL(temp_al);
   SET_AH(0);

   /* set ZF,SF,PF according to result */
   SET_ZF(temp_al == 0);
   SET_SF((temp_al & BIT7_MASK) != 0);
   SET_PF(pf_table[temp_al]);

   /* Set undefined flag(s) to zero */
#ifdef SET_UNDEFINED_FLAG
   SET_AF(UNDEFINED_FLAG);
   SET_OF(UNDEFINED_FLAG);
   SET_CF(UNDEFINED_FLAG);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\aam.h ===
/* 
   aam.h

   Define all AAM CPU functions.
 */

/*
   static char SccsID[]="@(#)aam.h	1.4 02/09/94";
 */

IMPORT VOID AAM
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\aam.c ===
/*[

aam.c

LOCAL CHAR SccsID[]="@(#)aam.c	1.5 02/09/94";

AAM CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <aam.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
AAM
                 
IFN1(
	IU32, op1
    )


   {
   IU8 temp_al;

   if ( op1 == 0 )
      Int0();
   
   SET_AH(GET_AL() / op1);
   SET_AL(GET_AL() % op1);

   /* set ZF,SF,PF according to result */
   temp_al = GET_AL();
   SET_ZF(temp_al == 0);
   SET_SF((temp_al & BIT7_MASK) != 0);
   SET_PF(pf_table[temp_al]);

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_AF(UNDEFINED_FLAG);
   SET_OF(UNDEFINED_FLAG);
   SET_CF(UNDEFINED_FLAG);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\aas.h ===
/* 
   aas.h

   Define all AAS CPU functions.
 */

/*
   static char SccsID[]="@(#)aas.h	1.5 09/01/94";
 */

IMPORT VOID AAS IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\aas.c ===
/*[

aas.c

LOCAL CHAR SccsID[]="@(#)aas.c	1.5 02/09/94";

AAS CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <aas.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
AAS()
   {
   if ( (GET_AL() & 0xf) > 9 || GET_AF() )
      {
      SET_AX(GET_AX() - 6);
      SET_AH(GET_AH() - 1);
      SET_CF(1); SET_AF(1);
      }
   else
      {
      SET_CF(0); SET_AF(0);
      }
   SET_AL(GET_AL() & 0xf);

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_OF(UNDEFINED_FLAG);
   SET_SF(UNDEFINED_FLAG);
   SET_ZF(UNDEFINED_FLAG);
   SET_PF(UNDEFINED_FLAG);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\aad.h ===
/* 
   aad.h

   Define all AAD CPU functions.
 */

/*
   static char SccsID[]="@(#)aad.h	1.4 02/09/94";
 */

IMPORT VOID AAD
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\adc.h ===
/* 
   adc.h

   Define all ADC CPU functions.
 */

/*
   static char SccsID[]="@(#)adc.h	1.4 02/09/94";
 */

IMPORT VOID ADC
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\adc.c ===
/*[

adc.c

LOCAL CHAR SccsID[]="@(#)adc.c	1.5 02/09/94";

ADC CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <adc.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'adc'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
ADC
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 carry;
   IU32 msb;
   IU32 op1_msb;
   IU32 op2_msb;
   IU32 res_msb;

   msb = SZ2MSB(op_sz);
   					/* Do operation */
   result = *pop1 + op2 + GET_CF() & SZ2MASK(op_sz);
   op1_msb = (*pop1  & msb) != 0;	/* Isolate all msb's */
   op2_msb = (op2    & msb) != 0;
   res_msb = (result & msb) != 0;
   carry = *pop1 ^ op2 ^ result;	/* Isolate carries */
					/* Determine flags */
   /*
      OF = (op1 == op2) & (op2 ^ res)
      ie if operand signs same and res sign different set OF.
    */
   SET_OF((op1_msb == op2_msb) & (op2_msb ^ res_msb));
   /*
      Formally:-     CF = op1 & op2 | !res & op1 | !res & op2
      Equivalently:- CF = OF ^ op1 ^ op2 ^ res
    */
   SET_CF(((carry & msb) != 0) ^ GET_OF());
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */
   SET_AF((carry & BIT4_MASK) != 0);	/* AF = Bit 4 carry */
   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\add.c ===
/*[

add.c

LOCAL CHAR SccsID[]="@(#)add.c	1.5 02/09/94";

ADD CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <add.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'add'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
ADD
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 carry;
   IU32 msb;
   IU32 op1_msb;
   IU32 op2_msb;
   IU32 res_msb;

   msb = SZ2MSB(op_sz);
   					/* Do operation */
   result = *pop1 + op2 & SZ2MASK(op_sz);
   op1_msb = (*pop1  & msb) != 0;	/* Isolate all msb's */
   op2_msb = (op2    & msb) != 0;
   res_msb = (result & msb) != 0;
   carry = *pop1 ^ op2 ^ result;	/* Isolate carries */
					/* Determine flags */
   /*
      OF = (op1 == op2) & (op2 ^ res)
      ie if operand signs same and res sign different set OF.
    */
   SET_OF((op1_msb == op2_msb) & (op2_msb ^ res_msb));
   /*
      Formally:-     CF = op1 & op2 | !res & op1 | !res & op2
      Equivalently:- CF = OF ^ op1 ^ op2 ^ res
    */
   SET_CF(((carry & msb) != 0) ^ GET_OF());
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */
   SET_AF((carry & BIT4_MASK) != 0);	/* AF = Bit 4 carry */
   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\arpl.c ===
/*[

arpl.c

LOCAL CHAR SccsID[]="@(#)arpl.c	1.5 02/09/94";

ARPL CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <arpl.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */

GLOBAL VOID
ARPL
                          
IFN2(
	IU32 *, pop1,
	IU32, op2
    )


   {
   IU32 rpl;

   /* Reduce op1 RPL to lowest privilege (highest value) */
   if ( GET_SELECTOR_RPL(*pop1) < (rpl = GET_SELECTOR_RPL(op2)) )
      {
      SET_SELECTOR_RPL(*pop1, rpl);
      SET_ZF(1);
      }
   else
      {
      SET_ZF(0);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\arpl.h ===
/* 
   arpl.h

   Define all ARPL CPU functions.
 */

/*
   static char SccsID[]="@(#)arpl.h	1.4 02/09/94";
 */

IMPORT VOID ARPL
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\add.h ===
/* 
   add.h

   Define all ADD CPU functions.
 */

/*
   static char SccsID[]="@(#)add.h	1.4 02/09/94";
 */

IMPORT VOID ADD
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bound.h ===
/* 
   bound.h

   Define all BOUND CPU functions.
 */

/*
   static char SccsID[]="@(#)bound.h	1.4 02/09/94";
 */

IMPORT VOID BOUND
               
IPT3(
	IU32, op1,
	IU32, op2[2],
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bound.c ===
/*[

bound.c

LOCAL CHAR SccsID[]="@(#)bound.c	1.6 03/28/94";

BOUND CPU functions.
--------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <bound.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
BOUND
#ifdef ANSI
   (
   IU32 op1,		/* lsrc(test value) operand */
   IU32 op2[2],	/* rsrc(lower:upper pair) operand */
   IUM8 op_sz		/* 16 or 32-bit */
   )
#else
   (op1, op2, op_sz)
   IU32 op1;
   IU32 op2[2];
   IUM8 op_sz;
#endif
   {
   IS32 value;
   IS32 lower;
   IS32 upper;

   /* transfer to local signed variables */
   value = op1;
   lower = op2[0];
   upper = op2[1];

   if ( op_sz == 16 )
      {
      /* sign extend operands */
      if ( value & BIT15_MASK )
	 value |= ~WORD_MASK;

      if ( lower & BIT15_MASK )
	 lower |= ~WORD_MASK;

      if ( upper & BIT15_MASK )
	 upper |= ~WORD_MASK;
      }

   op_sz = op_sz / 8;   /* determine number of bytes in operand */

   if ( value < lower || value > upper )
      Int5();
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\and.c ===
/*[

and.c

LOCAL CHAR SccsID[]="@(#)and.c	1.5 02/09/94";

AND CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <and.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'and'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
AND
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;

   result = *pop1 & op2;	/* Do operation */
   SET_CF(0);			/* Determine flags */
   SET_OF(0);
   SET_AF(0);
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & SZ2MSB(op_sz)) != 0);	/* SF = MSB */
   *pop1 = result;		/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\and.h ===
/* 
   and.h

   Define all AND CPU functions.
 */

/*
   static char SccsID[]="@(#)and.h	1.4 02/09/94";
 */

IMPORT VOID AND
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bsr.h ===
/* 
   bsr.h

   BSR CPU functions.
 */

/*
   static char SccsID[]="@(#)bsr.h	1.4 02/09/94";
 */

IMPORT VOID BSR
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bsr.c ===
/*[

bsr.c

LOCAL CHAR SccsID[]="@(#)bsr.c	1.5 02/09/94";

BSR CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <bsr.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'bsr'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
BSR
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2,	/* rsrc (ie scanned) operand */
	IUM8, op_sz	/* 16 or 32-bit */
    )


   {
   IU32 temp;
   IU32 msb;

   if ( op2 == 0 )
      {
      SET_ZF(1);
      /* leave dst unaltered */
      }
   else
      {
      SET_ZF(0);
      temp = op_sz - 1;
      msb = SZ2MSB(op_sz);

      while ( (op2 & msb) == 0 )
	 {
	 temp -= 1;
	 op2 <<= 1;
	 }

      *pop1 = temp;
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bswap.h ===
/* 
   bswap.h

   BSWAP CPU functions.
 */

/*
   static char SccsID[]="@(#)bswap.h	1.4 02/09/94";
 */

IMPORT VOID BSWAP
       
IPT1(
	IU32 *, pop1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bswap.c ===
/*[

bswap.c

LOCAL CHAR SccsID[]="@(#)bswap.c	1.6 11/30/94";

BSWAP CPU functions.
--------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <bswap.h>
#include <stdio.h>

/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


#ifdef SPC486

GLOBAL VOID
BSWAP
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst/src operand */
    )


   {
   IU32 src;	/* temp for source */
   IU32 dst;	/* temp for destination */

   src = *pop1;		/* get source operand */

   /*
                        =================      =================
      Munge bytes from  | A | B | C | D |  to  | D | C | B | A |
                        =================      =================
    */
   dst = ((src & 0xff000000) >> 24) |	/* A->D */
         ((src & 0x00ff0000) >>  8) |	/* B->C */
         ((src & 0x0000ff00) <<  8) |	/* C->B */
         ((src & 0x000000ff) << 24);	/* D->A */

   *pop1 = dst;		/* return destination operand */
   }

#endif /* SPC486 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bsf.h ===
/* 
   bsf.h

   BSF CPU functions.
 */

/*
   static char SccsID[]="@(#)bsf.h	1.4 02/09/94";
 */

IMPORT VOID BSF
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bt.h ===
/* 
   bt.h

   BT CPU functions.
 */

/*
   static char SccsID[]="@(#)bt.h	1.4 02/09/94";
 */

IMPORT VOID BT
               
IPT3(
	IU32, op1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bsf.c ===
/*[

bsf.c

LOCAL CHAR SccsID[]="@(#)bsf.c	1.5 02/09/94";

BSF CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <bsf.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'bsf'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
BSF
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2	/* rsrc (ie scanned) operand */
    )


   {
   IU32 temp = 0;

   if ( op2 == 0 )
      {
      SET_ZF(1);
      /* leave dst unaltered */
      }
   else
      {
      SET_ZF(0);
      while ( (op2 & BIT0_MASK) == 0 )
	 {
	 temp += 1;
	 op2 >>= 1;
	 }
      *pop1 = temp;
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bt.c ===
/*[

bt.c

LOCAL CHAR SccsID[]="@(#)bt.c	1.5 02/09/94";

BT CPU functions.
-----------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <bt.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'bt'.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
BT
       	    	    	                    
IFN3(
	IU32, op1,	/* lsrc operand */
	IU32, op2,	/* rsrc (ie bit nr.) operand */
	IUM8, op_sz	/* 16 or 32-bit */
    )


   {
   IU32 bit_mask;

   op2 = op2 % op_sz;		/* take bit nr. modulo operand size */
   bit_mask = 1 << op2;			/* form mask for bit */
   SET_CF((op1 & bit_mask) != 0);	/* set CF to given bit */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\btc.h ===
/* 
   btc.h

   BTC CPU functions.
 */

/*
   static char SccsID[]="@(#)btc.h	1.4 02/09/94";
 */

IMPORT VOID BTC
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\btc.c ===
/*[

btc.c

LOCAL CHAR SccsID[]="@(#)btc.c	1.5 02/09/94";

BTC CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <btc.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'btc'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
BTC
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to lsrc/dst operand */
	IU32, op2,	/* rsrc (ie bit nr.) operand */
	IUM8, op_sz	/* 16 or 32-bit */
    )


   {
   IU32 bit_mask;

   op2 = op2 % op_sz;		/* take bit nr. modulo operand size */
   bit_mask = 1 << op2;			/* form mask for bit */
   SET_CF((*pop1 & bit_mask) != 0);	/* set CF to given bit */
   *pop1 = *pop1 ^ bit_mask;		/* Set Bit = !Bit */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\btr.c ===
/*[

btr.c

LOCAL CHAR SccsID[]="@(#)btr.c	1.5 02/09/94";

BTR CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <btr.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'btr'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
BTR
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to lsrc/dst operand */
	IU32, op2,	/* rsrc (ie bit nr.) operand */
	IUM8, op_sz	/* 16 or 32-bit */
    )


   {
   IU32 bit_mask;

   op2 = op2 % op_sz;		/* take bit nr. modulo operand size */
   bit_mask = 1 << op2;			/* form mask for bit */
   SET_CF((*pop1 & bit_mask) != 0);	/* set CF to given bit */
   *pop1 = *pop1 & ~bit_mask;		/* Set Bit = 0 */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bts.h ===
/* 
   bts.h

   BTS CPU functions.
 */

/*
   static char SccsID[]="@(#)bts.h	1.4 02/09/94";
 */

IMPORT VOID BTS
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\btr.h ===
/* 
   btr.h

   BTR CPU functions.
 */

/*
   static char SccsID[]="@(#)btr.h	1.4 02/09/94";
 */

IMPORT VOID BTR
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\call.h ===
/* 
   call.h

   Define all CALL CPU functions.
 */

/*
   static char SccsID[]="@(#)call.h	1.4 02/09/94";
 */

IMPORT VOID CALLF
       
IPT1(
	IU32, op1[2]

   );

IMPORT VOID CALLN
       
IPT1(
	IU32, offset

   );

IMPORT VOID CALLR
       
IPT1(
	IU32, rel_offset

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\bts.c ===
/*[

bts.c

LOCAL CHAR SccsID[]="@(#)bts.c	1.5 02/09/94";

BTS CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <bts.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'bts'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
BTS
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to lsrc/dst operand */
	IU32, op2,	/* rsrc (ie bit nr.) operand */
	IUM8, op_sz	/* 16 or 32-bit */
    )


   {
   IU32 bit_mask;

   op2 = op2 % op_sz;		/* take bit nr. modulo operand size */
   bit_mask = 1 << op2;			/* form mask for bit */
   SET_CF((*pop1 & bit_mask) != 0);	/* set CF to given bit */
   *pop1 = *pop1 | bit_mask;		/* Set Bit = 1 */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cbw.c ===
/*[

cbw.c

LOCAL CHAR SccsID[]="@(#)cbw.c	1.5 02/09/94";

CBW CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cbw.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CBW()
   {
   if ( GET_AL() & BIT7_MASK )   /* sign bit set? */
      SET_AH(0xff);
   else
      SET_AH(0);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\call.c ===
/*[

call.c

LOCAL CHAR SccsID[]="@(#)call.c	1.15 02/27/95";

CALL CPU Functions.
-------------------

]*/


#include <insignia.h>
#include <host_def.h>
#include <xt.h>

#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <call.h>
#include <c_xfer.h>
#include <c_tsksw.h>
#include <fault.h>

/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Process far calls.                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
CALLF
#ifdef ANSI
   (
   IU32 op1[2]       /* offset:segment pointer */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   IU16  new_cs;	/* The destination */
   IU32 new_ip;

   IU32 cs_descr_addr;		/* code segment descriptor address */
   CPU_DESCR cs_entry;		/* code segment descriptor entry */

   ISM32 dest_type;	/* category for destination */

   IU8 count;	/* call gate count (if used) */
   IU32 dpl;		/* new privilege level (if used) */

   IU16  new_ss;	/* The new stack */
   IU32 new_sp;
   ISM32 new_stk_sz;	/* Size in bytes of new stack */

   IU32 ss_descr_addr;		/* stack segment descriptor address */
   CPU_DESCR ss_entry;		/* stack segment descriptor entry */

   /* Variables used on stack transfers */
   IU32 old_cs;
   IU32 old_ip;
   IU32 old_ss;
   IU32 old_sp;
   IU32 params[31];
   ISM32 i;

   /* get destination (correctly typed) */
   new_cs = op1[1];
   new_ip = op1[0];

   if ( GET_PE() == 0 || GET_VM() == 1 )
      {
      /* Real Mode or V86 Mode */

      /* must be able to push CS:(E)IP */
      validate_stack_space(USE_SP, (ISM32)NR_ITEMS_2);

#ifdef	TAKE_REAL_MODE_LIMIT_FAULT

      /* do ip limit checking */
      if ( new_ip > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_CALLF_RM_CS_LIMIT);

#else	/* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */
   

      /* ALL SYSTEMS GO */

      /* push return address */
      spush16((IU32)GET_CS_SELECTOR());
      spush((IU32)GET_EIP());
      
      load_CS_cache(new_cs, (IU32)0, (CPU_DESCR *)0);
      SET_EIP(new_ip);
      }
   else
      {
      /* protected mode */

      /* decode and check final destination */
      validate_far_dest(&new_cs, &new_ip, &cs_descr_addr, &count,
		        &dest_type, CALL_ID);

      /* action possible types of target */
      switch ( dest_type )
	 {
      case NEW_TASK:
	 switch_tasks(NOT_RETURNING, NESTING, new_cs, cs_descr_addr, GET_EIP());

	 /* limit check new IP (now in new task) */
	 if ( GET_EIP() > GET_CS_LIMIT() )
	    GP((IU16)0, FAULT_CALLF_TASK_CS_LIMIT);
	 break;

      case SAME_LEVEL:
	 read_descriptor_linear(cs_descr_addr, &cs_entry);

	 /* stamp new selector with CPL */
	 SET_SELECTOR_RPL(new_cs, GET_CPL());

	 /* check room for return address CS:(E)IP */
	 validate_stack_space(USE_SP, (ISM32)NR_ITEMS_2);

	 /* do ip limit check */
	 if ( new_ip > cs_entry.limit )
	    GP((IU16)0, FAULT_CALLF_PM_CS_LIMIT_1);
	 
	 /* ALL SYSTEMS GO */

	 /* push return address */
	 spush16((IU32)GET_CS_SELECTOR());
	 spush((IU32)GET_EIP());

	 load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
	 SET_EIP(new_ip);
	 break;

      default:   /* MORE_PRIVILEGE(0|1|2) */
	 read_descriptor_linear(cs_descr_addr, &cs_entry);

	 dpl = dest_type;
	 
	 /* stamp new selector with new CPL */
	 SET_SELECTOR_RPL(new_cs, dpl);

	 /* find out about new stack */
	 get_stack_selector_from_TSS(dpl, &new_ss, &new_sp);

	 /* check new stack selector */
	 validate_SS_on_stack_change(dpl, new_ss,
				     &ss_descr_addr, &ss_entry);

	 /* check room for SS:(E)SP
			   parameters
			   CS:(E)IP */
	 new_stk_sz = count + NR_ITEMS_4;
	 validate_new_stack_space(new_stk_sz, new_sp, &ss_entry, new_ss);

	 /* do ip limit check */
	 if ( new_ip > cs_entry.limit )
	    GP((IU16)0, FAULT_CALLF_PM_CS_LIMIT_2);

	 /* ALL SYSTEMS GO */

	 SET_CPL(dpl);

	 /* update code segment */
	 old_cs = (IU32)GET_CS_SELECTOR();
	 old_ip = GET_EIP();
	 load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
	 SET_EIP(new_ip);

	 /* 'pop' params from old stack */
	 old_ss = (IU32)GET_SS_SELECTOR();
	 old_sp = GET_ESP();

	 for ( i = 0; i < count; i++ )
	    params[i] = spop();

	 /* update stack segment */
	 load_SS_cache(new_ss, ss_descr_addr, &ss_entry);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    SET_SP(new_sp);
	 else
	    SET_ESP(new_sp);

	 /*
	    FORM NEW STACK, VIZ
	    
			  ==========                ==========
	    old SS:SP  -> | parm 1 |  new SS:SP  -> | old IP |
			  | parm 2 |                | old CS |
			  | parm 3 |                | parm 1 |
			  ==========                | parm 2 |
						    | parm 3 |
						    | old SP |
						    | old SS |
						    ==========
	  */

	 /* push old stack values */
	 spush16(old_ss);
	 spush(old_sp);

	 /* push back params onto new stack */
	 for ( i = count-1; i >= 0; i-- )
	    spush(params[i]);

	 /* push return address */
	 spush16(old_cs);
	 spush(old_ip);
	 break;
	 }
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* call near indirect                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
CALLN
                 
IFN1(
	IU32, offset
    )


   {
   /* check push to stack ok */
   validate_stack_space(USE_SP, (ISM32)NR_ITEMS_1);

   /*
      Although the 386 book says a 16-bit operand should be AND'ed
      with 0x0000ffff, a 16-bit operand is never fetched with the
      top bits dirty anyway, so we don't AND here.
    */

   /* do ip limit check */
#ifdef	TAKE_REAL_MODE_LIMIT_FAULT

   if ( offset > GET_CS_LIMIT() )
      GP((IU16)0, FAULT_CALLN_RM_CS_LIMIT);

#else /* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#ifdef TAKE_PROT_MODE_LIMIT_FAULT

   if ( GET_PE() == 1 && GET_VM() == 0 )
      {
      if ( offset > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_CALLN_PM_CS_LIMIT);
      }

#endif /* TAKE_PROT_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Protected Mode limit failues
       * for the instructions with relative offsets, Jxx, LOOPxx, JCXZ,
       * JMP rel and CALL rel, or instructions with near offsets,
       * JMP near and CALL near.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */

   /* all systems go */
   spush((IU32)GET_EIP());
   SET_EIP(offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* call near relative                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
CALLR
                 
IFN1(
	IU32, rel_offset
    )


   {
   IU32 new_dest;

   /* check push to stack ok */
   validate_stack_space(USE_SP, (ISM32)NR_ITEMS_1);

   /* calculate and check new destination */
   new_dest = GET_EIP() + rel_offset;

   if ( GET_OPERAND_SIZE() == USE16 )
      new_dest &= WORD_MASK;

   /* do ip limit check */
#ifdef	TAKE_REAL_MODE_LIMIT_FAULT

   if ( new_dest > GET_CS_LIMIT() )
      GP((IU16)0, FAULT_CALLR_RM_CS_LIMIT);

#else /* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#ifdef TAKE_PROT_MODE_LIMIT_FAULT

   if ( GET_PE() == 1 && GET_VM() == 0 )
      {
      if ( new_dest > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_CALLR_PM_CS_LIMIT);
      }

#endif /* TAKE_PROT_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Protected Mode limit failues
       * for the instructions with relative offsets, Jxx, LOOPxx, JCXZ,
       * JMP rel and CALL rel, or instructions with near offsets,
       * JMP near and CALL near.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */

   /* all systems go */
   spush((IU32)GET_EIP());
   SET_EIP(new_dest);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ccpudefs.inc ===
C_DEFINES= -DCPU_30_STYLE -DCPU_40_STYLE -DNEW_CPU -DCCPU -DSPC386 -DANSI -DNTVDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cbw.h ===
/* 
   cbw.h

   Define all CBW CPU functions.
 */

/*
   static char SccsID[]="@(#)cbw.h	1.5 09/01/94";
 */

IMPORT VOID CBW IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ccpusas4.c ===
/*[
 * File Name		: ccpu_sas4.c
 *
 * Derived From		: ccpu_sas.c
 *
 * Author		: Mike Moreton
 *
 * Creation Date	: Oct 93
 *
 * SCCS Version		: @(#)ccpusas4.c	1.45 08/31/94
 *
 * Purpose
 *	This module contains the SAS functions for a C CPU using the
 *	CPU_40_STYLE interface.
 *
 *! (c)Copyright Insignia Solutions Ltd., 1990-3. All rights reserved.
]*/


#include "insignia.h"
#include "host_def.h"

#ifdef	CCPU

#ifdef SEGMENTATION

/*
 * The following #include specifies the code segment into which this module
 * will by placed by the MPW C compiler on the Mac II running MultiFinder.
 */
#include <SOFTPC_SUPPORT.seg>
#endif


#include <stdio.h>
#include <stdlib.h>
#include MemoryH
#include StringH
#include <xt.h>
#include <trace.h>
#include <sas.h>
#include <sasp.h>
#include <ccpusas4.h>
#include <gmi.h>
#include CpuH
#include <cpu_vid.h>
#include <debug.h>
#include <ckmalloc.h>
#include <rom.h>
#include <trace.h>
#include <ckmalloc.h>
#include <c_tlb.h>
#include <c_page.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <timer.h>
#include <yoda.h>

/********************************************************/
#define SIXTY_FOUR_K 1024*64

/* global functions & variables */

IU8	  *memory_type = NULL;

LOCAL	BOOL	selectors_set = FALSE;
LOCAL	IU16	code_sel, data_sel;

#define INTEL_SRC	0
#define HOST_SRC	1

/*
 * We're going to declare all the functions that we'll need for SAS function
 * pointers so that we can put them all into the function pointers structure.
 * This structure will then be passed to SasSetPointers from the sas_init
 * function in this module.
 */

GLOBAL TYPE_sas_memory_size c_sas_memory_size;
GLOBAL TYPE_sas_connect_memory c_sas_connect_memory;
GLOBAL TYPE_sas_enable_20_bit_wrapping c_sas_enable_20_bit_wrapping;
GLOBAL TYPE_sas_disable_20_bit_wrapping c_sas_disable_20_bit_wrapping;
GLOBAL TYPE_sas_twenty_bit_wrapping_enabled c_sas_twenty_bit_wrapping_enabled;
GLOBAL TYPE_sas_memory_type c_sas_memory_type;
GLOBAL TYPE_sas_hw_at c_sas_hw_at;
GLOBAL TYPE_sas_w_at c_sas_w_at;
GLOBAL TYPE_sas_dw_at c_sas_dw_at;
GLOBAL TYPE_sas_store c_sas_store;
GLOBAL TYPE_sas_storew c_sas_storew;
GLOBAL TYPE_sas_storedw c_sas_storedw;
GLOBAL TYPE_sas_loads c_sas_loads;
GLOBAL TYPE_sas_stores c_sas_stores;
GLOBAL TYPE_sas_loads_no_check c_sas_loads_no_check;
GLOBAL TYPE_sas_stores_no_check c_sas_stores_no_check;
GLOBAL TYPE_sas_move_bytes_forward c_sas_move_bytes_forward;
GLOBAL TYPE_sas_move_words_forward c_sas_move_words_forward;
GLOBAL TYPE_sas_move_doubles_forward c_sas_move_doubles_forward;
GLOBAL TYPE_sas_fills c_sas_fills;
GLOBAL TYPE_sas_fillsw c_sas_fillsw;
GLOBAL TYPE_sas_fillsdw c_sas_fillsdw;
GLOBAL TYPE_sas_scratch_address c_sas_scratch_address;
GLOBAL TYPE_sas_transbuf_address c_sas_transbuf_address;
GLOBAL TYPE_sas_overwrite_memory c_sas_overwrite_memory;
GLOBAL TYPE_sas_PWS c_sas_PWS;
GLOBAL TYPE_sas_PRS c_sas_PRS;
GLOBAL TYPE_sas_PWS_no_check c_sas_PWS_no_check;
GLOBAL TYPE_sas_PRS_no_check c_sas_PRS_no_check;
GLOBAL TYPE_getPtrToLinAddrByte c_GetLinAdd;
GLOBAL TYPE_getPtrToPhysAddrByte c_GetPhyAdd;
GLOBAL TYPE_sas_init_pm_selectors c_SasRegisterVirtualSelectors;
GLOBAL TYPE_sas_PigCmpPage c_sas_PigCmpPage;

LOCAL void	c_sas_not_used	IPT0();

extern struct SasVector cSasPtrs;
GLOBAL struct SasVector Sas;

/* local functions */
LOCAL void write_word IPT2(sys_addr, addr, IU16, wrd);
LOCAL word read_word IPT1(sys_addr, addr);
LOCAL IU8  bios_read_byte   IPT1(LIN_ADDR, linAddr);
LOCAL IU16 bios_read_word   IPT1(LIN_ADDR, linAddr);
LOCAL IU32 bios_read_double IPT1(LIN_ADDR, linAddr);
LOCAL void bios_write_byte   IPT2(LIN_ADDR, linAddr, IU8, value);
LOCAL void bios_write_word   IPT2(LIN_ADDR, linAddr, IU16, value);
LOCAL void bios_write_double IPT2(LIN_ADDR, linAddr, IU32, value);

GLOBAL IU8 *Start_of_M_area = NULL;
GLOBAL PHY_ADDR  Length_of_M_area = 0;
#ifdef BACK_M
GLOBAL IU8 *end_of_M = NULL;
#endif

void	    (*temp_func) ();

#ifndef EGATEST
#define READ_SELF_MOD(addr)	   (SAS_MEM_TYPE)( memory_type[(addr)>>12] )
#define write_self_mod(addr, type)  	(memory_type[(addr)>>12] = (IU8)(type))

/*********** 'GMI' CCPU ONLY  ***********/

/*
 * types are : SAS_RAM SAS_VIDEO SAS_ROM SAS_WRAP SAS_INACCESSIBLE
 */
#define TYPE_RANGE ((int)SAS_INACCESSIBLE)

#define ROM_byte ((IU8)SAS_ROM)
#define RAM_byte ((IU8)SAS_RAM)

#define write_b_write_ptrs( offset, func )	( b_write_ptrs[(offset)] = (func) )
#define write_w_write_ptrs( offset, func )	( w_write_ptrs[(offset)] = (func) )
#define write_b_page_ptrs( offset, func )	( b_move_ptrs[(offset)] = b_fill_ptrs[(offset)] = (func) )
#define write_w_page_ptrs( offset, func )	( w_move_ptrs[(offset)] = w_fill_ptrs[(offset)] = (func) )
#define init_b_write_ptrs( offset, func )	( b_write_ptrs[(offset)] = (func) )
#define init_w_write_ptrs( offset, func )	( w_write_ptrs[(offset)] = (func) )
#define init_b_page_ptrs( offset, func )	( b_move_ptrs[(offset)] = b_fill_ptrs[(offset)] = (func) )
#define init_w_page_ptrs( offset, func )	( w_move_ptrs[(offset)] = w_fill_ptrs[(offset)] = (func) )
#define read_b_write_ptrs( offset )		( b_write_ptrs[(offset)] )
#define read_w_write_ptrs( offset )		( w_write_ptrs[(offset)] )
#define read_b_page_ptrs( offset )		( b_move_ptrs[(offset)] )
#define read_w_page_ptrs( offset )		( w_move_ptrs[(offset)] )
#define read_b_move_ptrs( offset )		( b_move_ptrs[(offset)] )
#define read_w_move_ptrs( offset )		( w_move_ptrs[(offset)] )
#define read_b_fill_ptrs( offset )		( b_fill_ptrs[(offset)] )
#define read_w_fill_ptrs( offset )		( w_fill_ptrs[(offset)] )

/*
 * The main gmi data structures are defined here
 */
void	    (*(b_write_ptrs[TYPE_RANGE])) ();	/* byte write function */
void	    (*(w_write_ptrs[TYPE_RANGE])) ();	/* word write function */
void	    (*(b_fill_ptrs[TYPE_RANGE])) ();	/* byte str fill func */
void	    (*(w_fill_ptrs[TYPE_RANGE])) ();	/* word str fill func */
void	    (*(b_move_ptrs[TYPE_RANGE])) ();	/* byte str write func */
void	    (*(w_move_ptrs[TYPE_RANGE])) ();	/* word str write func */

#endif				/* EGATEST */


/*(
 *======================= c_SasRegisterVirtualSelectors =========================
 *
 * Purpose
 *	The Sas virtualisation handler requires a code+data selector which
 *	are available in protected mode (when called from say the Insignia
 *	host windows driver.
 *	Our current experimental implementation does not worry about how
 *	long these live.
 *
 *	It is expected that this functionality should be moved from the
 *	windows driver itself, to the Insignia VxD so that correct
 *	initialisation/termination can be handled.
)*/

GLOBAL IBOOL c_SasRegisterVirtualSelectors IFN2(IU16, sel1, IU16, sel2)
{
	IU32	addr;

	always_trace0 ("c_SasRegisterVirtualSelectors called\n");

	addr = c_getLDT_BASE() + ((data_sel = sel1) & ~7);

	/* Construct a flat writable data segment */

	sas_storedw (addr, 0x0000FFFF);
	sas_storedw (addr+4, 0x008ff300);

	addr = c_getLDT_BASE() + ((code_sel = sel2) & ~7);

	/* Construct a code segment with base 0xf0000 and large limits */

	sas_storedw (addr, 0x0000FFFF);
	sas_storedw (addr+4, 0x008f9f0f);

	selectors_set = TRUE;

	always_trace2 ("Set code_sel = %x, data_sel = %x\n",
		code_sel, data_sel);
}

/*(
 *========================== checkAccess ===================================
 * checkAccess
 *
 * Purpose
 *	This function is used in debugging to spot writes to an area
 *	of memory.  Note that it is controlled by global variables that
 *	must be set elsewhere, or by a debugger.
 *
 * Input
 *	addr		The physical intel address to write to
 *
 * Outputs
 *	None.
 *
 * Description
 *	Actually a macro that is nothing if CHECK_ACCESS isn't defined.
)*/

#ifndef CHECK_ACCESS
#define checkAccess(addr)
#else
GLOBAL PHY_ADDR lowCheckAccess = 0;
GLOBAL PHY_ADDR highCheckAccess = 0;
#define checkAccess(addr) \
	if ((addr < highCheckAccess) && (addr >= lowCheckAccess)) { \
		always_trace1("Write access break point - addres 0x%.8x", \
				 addr); \
	}
#endif /* !CHECK_ACCESS else */

#ifndef PROD
/*
 * This function is useful for calling from a debugger!
 */

GLOBAL void
DumpMemType()
{
	SAS_MEM_TYPE currentType;
	PHY_ADDR numEntries;	/* number of entries in the table */
	PHY_ADDR currEntry;

	currentType = SAS_DANGEROUS;  /* memory_type should never have this */
	numEntries = c_sas_memory_size() >> 12;

	for (currEntry = 0; currEntry < numEntries; currEntry++) {
		if (memory_type[currEntry] != currentType) {
			fprintf(stderr,"0x%.8x	%s\n", currEntry << 12,
				SAS_TYPE_TO_STRING(memory_type[currEntry]));
			currentType = memory_type[currEntry];
		}
	}
	fprintf(stderr,"0x%.8x End of Memory\n", c_sas_memory_size());

}
#endif /* ndef PROD */


/*********** INIT & ADMIN FUNCS  ***********/
/*(
 *========================== readSelfMod ===================================
 * readSelfMod
 *
 * Purpose
 *	This function reads the self modify table, and returns the
 *	memory type.  It will also indicate whether there is a type
 *	boundary within the length specified.
 *
 * Input
 *	addr		The physical intel address to read from
 *	typeSize	The size in bytes of the item to be read
 *
 * Outputs
 *	Memory type.
 *
 * Description
 *	We check that the memory type for both ends of the type is the same.
)*/

LOCAL SAS_MEM_TYPE
readSelfMod IFN2(PHY_ADDR, addr, IUM8, typeSize)
{
	SAS_MEM_TYPE startType;

	startType = READ_SELF_MOD(addr);

	if (startType == READ_SELF_MOD(addr + typeSize - 1))
		return(startType);
	else
		return(SAS_DANGEROUS);
}

/*(
 *========================== SasSetPointers ===================================
 * SasSetPointers
 *
 * Purpose
 *	This function is used to install a set of function pointers.
 *
 * Input
 *	An array of pointers to use.
 *
 * Outputs
 *	None.
 *
 * Description
 *	Just do a memory copy of the pointers.
)*/

GLOBAL void 
SasSetPointers IFN1(struct SasVector *, newPointers)
{
	memcpy(&Sas, newPointers, sizeof(struct SasVector));
}


/* Init the sas system - malloc the memory & load the roms */


/* need to put some of this in the ROMs! */

GLOBAL void
sas_init IFN1(PHY_ADDR, size)
{
	IU32	required_mem;
	IUM16	ipatch;
	IU8	*ptr;
	char	*env;

	/*
	 * Set the SAS pointers to point to the functions in this
	 * module, and initialise the scratch buffer to 64K
	 */

	SasSetPointers(&cSasPtrs);
	(void)c_sas_scratch_address(SIXTY_FOUR_K);

	/* do the host sas */

	required_mem = size + NOWRAP_PROTECTION;
	Start_of_M_area = (IU8 *) host_sas_init(size);
	if (Start_of_M_area == NULL) {
		check_malloc(Start_of_M_area, required_mem, IU8);
	}
	env = getenv("CPU_INITIALISE_MEMORY");
	if (env != NULL)
	{
		int zap = strtol(env, (char **)0, 16);
		memset(Start_of_M_area, zap, size);	/* Fill with user supplied byte */
	}
	if (!memory_type)
		check_malloc(memory_type, ((size + NOWRAP_PROTECTION) >> 12), IU8);

	{
		IMPORT IU8 *CCPU_M;

#ifdef BACK_M
		CCPU_M = Start_of_M_area + size - 1;
#else
		CCPU_M = Start_of_M_area;
#endif				/* BACK_M */
	}

	/*
	 * Make the entire memory space RAM.  The ROM load routines
	 * will change some of this to being ROM.
	 */

	c_sas_connect_memory(0, size - 1, SAS_RAM);

	Length_of_M_area = size;
#ifdef BACK_M
	end_of_M = Start_of_M_area + Length_of_M_area -1;
#endif

	/* init the ROM (load the bios roms etc) */

#ifndef EGATEST
	rom_init();
#endif				/* EGATEST */

	copyROM();
}

/* finish the sas system -basically free up the M space prior to reallocing it */
GLOBAL void 
sas_term IFN0()
{
	if (host_sas_term() != NULL) {
		if (Start_of_M_area)
			free(Start_of_M_area);
		if (memory_type)
			free(memory_type);
		memory_type = NULL;
	}

	Start_of_M_area = NULL;
}

/* return the size of the sas */
GLOBAL PHY_ADDR 
c_sas_memory_size IFN0()
{
	return (Length_of_M_area);
}

/*********** GMI TYPE FUNCS ***********/
/*
 * Sets all intel addresses in give range to the specified memory type
 * for the ccpu this writes to memory_type.
 * Callers of this can be a bit confused about the meaning of the
 * high parameter.  e.g. for a range of 1000 - 2fff inclusive, they're
 * not sure if high should be 2fff or 3000.  It should be 2fff, but we
 * watch out for people who've got it wrong, and put them right, poor
 * little dears.
 */
GLOBAL void 
c_sas_connect_memory IFN3(PHY_ADDR, low, PHY_ADDR, high, SAS_MEM_TYPE, type)
{
	if ((high & 0xfff) == 0) {
		if (high)
			high--;
	}
	sub_note_trace3(SAS_VERBOSE, "Connect %s from 0x%lx to 0x%lx", 
		SAS_TYPE_TO_STRING(type), low, high);
	memset(&memory_type[low >> 12], type, (high >> 12) - (low >> 12) + 1);
}

/* returns memory type for specified addr */
GLOBAL SAS_MEM_TYPE
c_sas_memory_type IFN1(PHY_ADDR, addr)
{
	return(memory_type[ addr >> 12 ]);
}

/* clears any compiled code from the given range */
/* for the ccpu this doesn't do anything */
GLOBAL void 
c_sas_overwrite_memory IFN2(PHY_ADDR, addr, PHY_ADDR, length)
{
	UNUSED(addr);
	UNUSED(length);
}

/*********** WRAPPING ***********/
/* enable 20 bit wrapping */
GLOBAL void 
c_sas_enable_20_bit_wrapping IFN0()
{
	SasWrapMask = 0xfffff;
}

/* disable 20 bit wrapping */
GLOBAL void 
c_sas_disable_20_bit_wrapping IFN0()
{
	SasWrapMask = 0xffffffff;
}

GLOBAL IBOOL 
c_sas_twenty_bit_wrapping_enabled IFN0()
{
	return (SasWrapMask == 0xfffff);
}

/*(
 *========================== phyR ===================================
 * phyR
 *
 * Purpose
 *	This is the generic physical read function and takes parameters
 *	of any size (well up to an IU32 that is).
 *
 * Input
 *	addr		The physical intel address to read from
 *	typeSize	The size in bytes of the item to be read
 *	vidFP		A video read function pointer of the appropriate size.
 *	name		"byte" for byte, etc.
 *
 * Outputs
 *	An IU32 that should be masked to get the right bits.
 *
 * Description
 *	We check for out of memory refernces, VIDEO and inaccessible references
 *	and also split reads that span a memory type boundary.
)*/
typedef IU32 (*VID_READ_FP) IPT1(PHY_ADDR, offset);

LOCAL IU32
phyR IFN4(PHY_ADDR, addr, IUM8, typeSize, VID_READ_FP, vidFP, char *, name)
{
	IUM8	byte;
	IUM32	retVal;

	addr &= SasWrapMask;

	if ((addr + typeSize + 1) >= Length_of_M_area) {
		SAVED IBOOL first = TRUE;
		SAVED IU32 junk_value = 0xfefefefe;
		if (first)
		{
			char *env = getenv("BEYOND_MEMORY_VALUE");
			if (env != NULL)
			{
				junk_value = strtol(env, (char **)0, 16);
				always_trace1("phyR: using %08x as value to read from outside physical M", junk_value)
			}
			first = FALSE;
		}
		always_trace2("phyR - %s read from outside physical M - address 0x%0x", name, addr)
		return(junk_value);
	}

	switch (readSelfMod(addr, typeSize)) {
	case SAS_DANGEROUS:
		retVal = 0;
		for (byte = 0; byte < typeSize; byte++) {
			retVal = retVal
				+((IUM32)phyR(addr, 1, read_pointers.b_read,
					"byte") << (byte * 8));
			addr++;
		}
		return(retVal);
#ifdef	EGG
	case SAS_VIDEO:
		return ((*vidFP)(addr));
		break;
#endif				/* EGG */

	case SAS_INACCESSIBLE:
		return (0xffffffff);

	case SAS_ROM:
	case SAS_RAM:
	default:
		/*
		 * Pick-up the bytes.  This could be optimised, but
		 * we have to take account of BACK_M, endianness,
		 * and misaligned accesses on RISC hosts.  Just
		 * keep it simple for the moment!
		 */

		addr = addr + typeSize - 1; /* move to last byte */
		retVal = 0;

		while (typeSize > 0) {
			retVal = retVal << 8;
			retVal += *(c_GetPhyAdd(addr));
			addr -= 1;
			typeSize -= 1;
		}
		return(retVal);
	}
}
/*(
 *========================== phy_rX ===================================
 * phy_rX
 *
 * Purpose
 *	These are the physical read functions.
 *
 * Input
 *	addr		The physical intel address to read from
 *
 * Outputs
 *	The value read
 *
 * Description
 *	Simply call the generic function with the right bits.
)*/

GLOBAL IU8 
phy_r8 IFN1(PHY_ADDR, addr)
{
	IU8 retVal;

	retVal = (IU8)phyR(addr, sizeof(IU8), read_pointers.b_read, "byte");
	sub_note_trace2(SAS_VERBOSE, "phy_r8 addr=%x, val=%x\n", addr, retVal);
	return(retVal);
}


GLOBAL IU16 
phy_r16 IFN1(PHY_ADDR, addr)
{
	IU16 retVal;

	retVal = (IU16)phyR(addr, sizeof(IU16), read_pointers.w_read, "word");
	sub_note_trace2(SAS_VERBOSE, "phy_r16 addr=%x, val=%x\n", addr, retVal);
	return(retVal);
}


GLOBAL IU32 
phy_r32 IFN1(PHY_ADDR, addr)
{
	/*
	 * MIKE!  This needs changing when we have a dword interface to the
	 * video.
	 */

	IU16 low, high;
	low = (IU16)phyR(addr, sizeof(IU16), read_pointers.w_read, "word");
	high = (IU16)phyR(addr + 2, sizeof(IU16), read_pointers.w_read, "word");

	return(((IU32)high << 16) + low);
}

/*(
 *======================= c_sas_PWS ================================
 * c_sas_PWS
 *
 * Purpose
 *	This function writes a block of memory from into Intel memory
 *	from host memory.  It is the physical address equivalent of
 *	sas_stores.
 *
 * Input
 *	dest	Intel physical address
 *	src	host address
 *	length	number of IU8s to transfer
 *
 * Outputs
 *	None.
 *
 * Description
 *	Just call phy_w8 lots of times.
)*/

GLOBAL void
c_sas_PWS IFN3(PHY_ADDR, dest, IU8 *, src, PHY_ADDR, length)
{
	while (length--) {
		phy_w8(dest, *src);
		dest++;
		src++;
	}
}

/*(
 *======================= c_sas_PWS_no_check =========================
 * c_sas_PWS_no_check
 *
 * Purpose
 *	This function writes a block of memory from into Intel memory
 *	from host memory.  It is the physical address equivalent of
 *	sas_stores_no_check.
 *
 * Input
 *	dest	Intel physical address
 *	src	host address
 *	length	number of IU8s to transfer
 *
 * Outputs
 *	None.
 *
 * Description
 *	Just call c_sas_PWS()
)*/
GLOBAL void
c_sas_PWS_no_check IFN3(PHY_ADDR, dest, IU8 *, src, PHY_ADDR, length)
{
	c_sas_PWS(dest, src, length);
}


/*(
 *======================= c_sas_PRS ================================
 * c_sas_PRS
 *
 * Purpose
 *	This function reads a block of memory from  Intel memory
 *	into host memory.  It is the physical address equivalent of
 *	sas_loads.
 *
 * Input
 *	src	Intel physical address
 *	dest	host address
 *	length	number of IU8s to transfer
 *
 * Outputs
 *	None.
 *
 * Description
 *	Just call phy_r8 lots of times.
)*/

GLOBAL void
c_sas_PRS IFN3(PHY_ADDR, src, IU8 *, dest, PHY_ADDR, length)
{
	while (length--) {
		*dest = phy_r8(src);
		dest++;
		src++;
	}
}


/*(
 *======================= c_sas_PRS_no_check ==========================
 * c_sas_PRS_no_check
 *
 * Purpose
 *	This function reads a block of memory from  Intel memory
 *	into host memory.  It is the physical address equivalent of
 *	sas_loads_no_check.
 *
 * Input
 *	src	Intel physical address
 *	dest	host address
 *	length	number of IU8s to transfer
 *
 * Outputs
 *	None.
 *
 * Description
 *	Just call c_sas_PRS.
)*/

GLOBAL void
c_sas_PRS_no_check IFN3(PHY_ADDR, src, IU8 *, dest, PHY_ADDR, length)
{
	c_sas_PRS(src, dest, length);
}


GLOBAL IU8
c_sas_hw_at IFN1(LIN_ADDR, addr)
{
	return (bios_read_byte(addr));
}


/* return the word (short) at the specified address */
GLOBAL IU16 
c_sas_w_at IFN1(LIN_ADDR, addr)
{
	if ((addr & 0xFFF) <= 0xFFE)
		return (bios_read_word(addr));
	else
	{
		return (bios_read_byte(addr) | ((IU16)bios_read_byte(addr+1) << 8));
	}
}

/* return the double word (long) at the address passed */
GLOBAL IU32 
c_sas_dw_at IFN1(LIN_ADDR, addr)
{
	if ((addr & 0xFFF) <= 0xFFC)
		return (bios_read_double(addr));
	else
	{
		return (bios_read_word(addr) | ((IU32)bios_read_word(addr+2) << 16));
	}
}

/* store a byte at the given address */

GLOBAL void phy_w8 
IFN2(PHY_ADDR, addr, IU8, val)
{
	sys_addr	temp_val;

	sub_note_trace2(SAS_VERBOSE, "c_sas_store addr=%x, val=%x\n", addr, val);

	addr &= SasWrapMask;
	checkAccess(addr);

	if (addr < Length_of_M_area) {
		temp_val = readSelfMod(addr, sizeof(IU8));

		switch (temp_val) {
		case SAS_RAM:
			(*(IU8 *) c_GetPhyAdd(addr)) = val;
			break;

#ifdef	LIM
		case SAS_MM_LIM:
			(*(IU8 *) c_GetPhyAdd(addr)) = val;
			LIM_b_write(addr);
			break;
#endif

		case SAS_INACCESSIBLE:
		case SAS_ROM:
			/* No ROM_fix_sets !!! Yeh !!! */
			break;

		default:
			printf("Unknown SAS type\n");
			force_yoda();

		case SAS_VIDEO:
			temp_func = read_b_write_ptrs(temp_val);
			(*temp_func) (addr, val);
			break;
		}

	} else
		printf("Byte written outside M %x\n", addr);
}

GLOBAL void phy_w8_no_check
IFN2(PHY_ADDR, addr, IU8, val)
{
	phy_w8( addr, val );
}

GLOBAL void c_sas_store 
IFN2(LIN_ADDR, addr, IU8, val)
{
	sub_note_trace2(SAS_VERBOSE, "c_sas_store addr=%x, val=%x\n", addr, val);
	bios_write_byte(addr, val);
}

/* store a word at the given address */
GLOBAL void 
phy_w16 IFN2(PHY_ADDR, addr, IU16, val)
{
	sys_addr	temp_val;

	sub_note_trace2(SAS_VERBOSE, "c_sas_storew addr=%x, val=%x\n", addr, val);

	addr &= SasWrapMask;
	checkAccess(addr);

	if ((addr + 1) < Length_of_M_area) {
		temp_val = readSelfMod(addr, sizeof(IU16));

		switch (temp_val) {
		case SAS_RAM:
			write_word(addr, val);
			break;

#ifdef	LIM
		case SAS_MM_LIM:
			write_word(addr, val);
			LIM_w_write(addr);
			break;
#endif

		case SAS_INACCESSIBLE:
		case SAS_ROM:
			/* No ROM_fix_sets !!! Yeh !!! */
			break;

		default:
			printf("Unknown Sas type\n");
			force_yoda();

		case SAS_VIDEO:
			temp_func = read_w_write_ptrs(temp_val);
			(*temp_func) (addr, val);
			break;
		}

	} else
		printf("Word written outside M %x\n", addr);
}

GLOBAL void phy_w16_no_check
IFN2(PHY_ADDR, addr, IU16, val)
{
	phy_w16( addr, val );
}

GLOBAL void 
phy_w32 IFN2(PHY_ADDR, addr, IU32, val)
{
	phy_w16(addr, (IU16)val);
	phy_w16(addr + 2, (IU16)(val >> 16));
}


GLOBAL void phy_w32_no_check
IFN2(PHY_ADDR, addr, IU32, val)
{
	phy_w32( addr, val );
}


/* store a word at the given address */
GLOBAL void
c_sas_storew IFN2(LIN_ADDR, addr, IU16, val)
{
	sub_note_trace2(SAS_VERBOSE, "c_sas_storew addr=%x, val=%x\n", addr, val);
	if ((addr & 0xFFF) <= 0xFFE)
		bios_write_word(addr, val);
	else
	{
		bios_write_byte(addr+1, val >> 8);
		bios_write_byte(addr, val & 0xFF);
	}
}

/* store a double word at the given address */
GLOBAL void c_sas_storedw 
IFN2(LIN_ADDR, addr, IU32, val)
{
	sub_note_trace2(SAS_VERBOSE, "c_sas_storedw addr=%x, val=%x\n", addr, val);

	if ((addr & 0xFFF) <= 0xFFC)
		bios_write_double(addr, val);
	else
	{
		bios_write_word(addr+2, val >> 16);
		bios_write_word(addr, val & 0xFFFF);
	}
}

/*********** STRING OPS ***********/
/* load a string from M */
GLOBAL void c_sas_loads 
IFN3(LIN_ADDR, src, IU8 *, dest, LIN_ADDR, len)
{
	/*
	 * This is a linear address op, so we have to call the byte operation
	 * lots of times.
	 */

	IU8 *destP;

	for (destP = dest; destP < (dest + len); destP++) {
		*destP = c_sas_hw_at(src);
		src++;
	}
}

GLOBAL void c_sas_loads_no_check
IFN3(LIN_ADDR, src, IU8 *, dest, LIN_ADDR, len)
{
	c_sas_loads(src, dest, len);
}

/* write a string into M */
GLOBAL void c_sas_stores 
IFN3(LIN_ADDR, dest, IU8 *, src, LIN_ADDR, len)
{
	/*
	 * This is a linear address op, so we have to call the byte operation
	 * lots of times.
	 */

	IU8 *srcP;
	LIN_ADDR savedDest;

	sub_note_trace3(SAS_VERBOSE, "c_sas_stores dest=%x, src=%x, len=%d\n", dest, src, len);

	savedDest = dest;
	for (srcP = src; srcP < (src + len); srcP++) {
		c_sas_store(dest, *srcP);
		dest++;
	}
}

GLOBAL void c_sas_stores_no_check
IFN3(LIN_ADDR, dest, IU8 *, src, LIN_ADDR, len)
{
	c_sas_stores(dest, src, len);
}

/*********** MOVE OPS ***********/
/* move bytes from src to dest where src & dest are the low intel addresses */
/* of the affected areas */

/*
 * we can use straight memcpys here because we know that M is either all
 * forwards or
 */
/* backwards */
GLOBAL void c_sas_move_bytes_forward 
IFN3(sys_addr, src, sys_addr, dest,
     sys_addr, len)
{
	LIN_ADDR offset;

	for (offset = 0; offset < len; offset++) {
		c_sas_store(dest + offset, c_sas_hw_at(src + offset));
	}
}

/* move words from src to dest as above */
GLOBAL void c_sas_move_words_forward 
IFN3(LIN_ADDR, src, LIN_ADDR, dest,
     LIN_ADDR, len)
{
	LIN_ADDR offset;

	len = len * 2;	/* convert to bytes */
	for (offset = 0; offset < len; offset += 2) {
		c_sas_storew(dest + offset, c_sas_w_at(src + offset));
	}
}

/* move doubles from src to dest as above */
GLOBAL void c_sas_move_doubles_forward 
IFN3(LIN_ADDR, src, LIN_ADDR, dest,
     LIN_ADDR, len)
{
	LIN_ADDR offset;

	len = len * 4;	/* convert to bytes */
	for (offset = 0; offset < len; offset += 4) {
		c_sas_storedw(dest + offset, c_sas_dw_at(src + offset));
	}
}

/* backwards versions not used */
GLOBAL void c_sas_move_bytes_backward IFN3(sys_addr, src, sys_addr, dest, sys_addr, len)
{
	UNUSED(src);
	UNUSED(dest);
	UNUSED(len);
	c_sas_not_used();
}

GLOBAL void c_sas_move_words_backward IFN3(LIN_ADDR, src, LIN_ADDR, dest, LIN_ADDR, len)
{
	UNUSED(src);
	UNUSED(dest);
	UNUSED(len);
	c_sas_not_used();
}

GLOBAL void c_sas_move_doubles_backward IFN3(LIN_ADDR, src, LIN_ADDR, dest, LIN_ADDR, len)
{
	UNUSED(src);
	UNUSED(dest);
	UNUSED(len);
	c_sas_not_used();
}


/*********** FILL OPS ***********/
/* 
 * Fill an area with bytes (IU8s) of the passed value.
 */
GLOBAL void c_sas_fills 
IFN3(LIN_ADDR, dest, IU8 , val, LIN_ADDR, len)
   {
   /*
    * This is a linear address op, so just call the byte operation
    * lots of times.
    */

   LIN_ADDR i;

   sub_note_trace3(SAS_VERBOSE, "c_sas_fills dest=%x, val=%x, len=%d\n", dest, val, len);

   for (i = 0; i < len; i++)
      {
      c_sas_store(dest, val);
      dest++;
      }
   }

/* fill an area with words (IU16s) of the passed value */

GLOBAL void c_sas_fillsw 
IFN3(LIN_ADDR, dest, IU16, val, LIN_ADDR, len)
   {
   /*
    * This is a linear address op, so just call the word operation
    * lots of times.
    */

   LIN_ADDR i;

   sub_note_trace3(SAS_VERBOSE, "c_sas_fillsw dest=%x, val=%x, len=%d\n", dest, val, len);

   for (i = 0; i < len; i++)
      {
      c_sas_storew(dest, val);
      dest += 2;
      }
   }

/* Fill Intel memory with 32 bit values */

GLOBAL void c_sas_fillsdw 
IFN3(LIN_ADDR, dest, IU32, val, LIN_ADDR, len)
   {
   /*
    * This is a linear address op, so just call the double word operation
    * lots of times.
    */

   LIN_ADDR i;

   sub_note_trace3(SAS_VERBOSE, "c_sas_fillsdw dest=%x, val=%x, len=%d\n", dest, val, len);

   for (i = 0; i < len; i++)
      {
      c_sas_storedw(dest, val);
      dest += 4;
      }
   }

/*(
 *======================= c_sas_scratch_address ================================
 * c_sas_scratch_address
 *
 * Purpose
 *	This function returns a pointer to a scratch area for use by
 *	other functions.  There is only one such buffer!
 *
 * Input
 *	length		(no restrictions)
 *
 * Outputs
 *	A pointer to the buffer.
 *
 * Description
 *	The buffer is grown each time a new request for a larger buffer is
 *	made.  Note that there is an initial call from sas_init for
 *	64K, so this will be the minimum size we ever have.
)*/

LOCAL IU8 *scratch = (IU8 *) NULL;	/* keep a copy of the pointer */
LOCAL LIN_ADDR currentLength = 0;	/* how much we've allocated */

GLOBAL IU8 *
c_sas_scratch_address IFN1(sys_addr, length)
{
	if (length > currentLength) {
		if (scratch) {
			host_free(scratch);
			printf("Freeing old scratch buffer - VGA will be broken!\n");
			force_yoda();
		}

		check_malloc(scratch, length, IU8);
		currentLength = length;
	}
	return (scratch);
}


/*(
 *======================= sas_transbuf_address ================================
 * sas_transbuf_address
 *
 * Purpose
 *	This function returns a pointer to a host buffer that the base/host
 *	can read data into, and then load into/from Intel space using the two
 *	special functions that follow.  This allows optimisations
 *	on forwards M builds that we haven't implemented on the C CPU.  Hence
 *	note that sas_loads_to_transbuff is mapped directly onto sas_loads
 *	by sas_init, and similarly for sas_stores_to_transbuff.
 *
 * Input
 *	destination address	The intel address that this buffer will be
 *				loaded from, stored to. 
 *	length			(no restrictions)
 *
 * Outputs
 *	A pointer to the buffer.
 *
 * Description
 *	Just pass them the scratch buffer!.
)*/

GLOBAL IU8 * 
c_sas_transbuf_address IFN2(LIN_ADDR, dest_intel_addr, PHY_ADDR, length)
{
	UNUSED (dest_intel_addr);
	return (c_sas_scratch_address(length));
}


/********************************************************/
/* local functions */

/*********** WORD OPS  ***********/
/* store a word in M */
LOCAL void write_word 
IFN2(sys_addr, addr, IU16, wrd)
{
	IU8       hi, lo;

	/* split the word */
	hi = (IU8) ((wrd >> 8) & 0xff);
	lo = (IU8) (wrd & 0xff);



	*(c_GetPhyAdd(addr + 1)) = hi;
	*(c_GetPhyAdd(addr)) = lo;
}

/* read a word from M */
LOCAL word read_word 
IFN1(sys_addr, addr)
{
	IU8       hi, lo;


	hi = *(c_GetPhyAdd(addr + 1));
	lo = *(c_GetPhyAdd(addr));


	/* build the word */
	return (((IU16)hi << 8) + (IU16) lo);
}

#ifndef EGATEST
void gmi_define_mem 
IFN2(mem_type, type, MEM_HANDLERS *, handlers)
{
	int	     int_type = (int) (type);

	init_b_write_ptrs(int_type, (void (*) ()) (handlers->b_write));
	init_w_write_ptrs(int_type, (void (*) ()) (handlers->w_write));
	b_move_ptrs[int_type] = (void (*) ()) (handlers->b_move);
	w_move_ptrs[int_type] = (void (*) ()) (handlers->w_move);
	b_fill_ptrs[int_type] = (void (*) ()) (handlers->b_fill);
	w_fill_ptrs[int_type] = (void (*) ()) (handlers->w_fill);
}


#endif				/* EGATEST */

/*(
 *========================== c_GetLinAdd ===================================
 * c_GetLinAdd
 *
 * Purpose
 *	Returns a host pointer to the byte specified by an Intel linear
 *	address.
 *
 * Input
 *	addr	The Intel linear address
 *
 * Outputs
 *	The host pointer
 *
 * Description
 *	Translate it.  If it's not a physical address, scream.
)*/

GLOBAL IU8 *
c_GetLinAdd IFN1(PHY_ADDR, linAddr)
{
	PHY_ADDR phyAddr;

	if (!c_getPG())
		return(c_GetPhyAdd((PHY_ADDR)linAddr));
	else if (xtrn2phy(linAddr, (IUM8)0, &phyAddr))
		return(c_GetPhyAdd(phyAddr));
	else {
#ifndef	PROD
		if (!AlreadyInYoda) {
			always_trace1("get_byte_addr for linear address 0x%x which is unmapped", linAddr);
			force_yoda();
		}
#endif
		return(c_GetPhyAdd(0));	/* as good as anything! */
	}
}

/*(
 *========================== c_GetPhyAdd ===================================
 * c_GetPhyAdd
 *
 * Purpose
 *	Returns a host pointer to the byte specified by an Intel physical
 *	address.
 *
 * Input
 *	addr	The Intel physical address
 *
 * Outputs
 *	The host pointer
 *
 * Description
 *	This is the #ifdef BACK_M bit!  Just a simple calculation.
)*/

LOCAL IBOOL firstDubious = TRUE;	
GLOBAL IU8 *
c_GetPhyAdd IFN1(PHY_ADDR, addr)
{
	IU8 *retVal;

#ifdef BACK_M
	retVal = (IU8 *)((IHPE)end_of_M - (IHPE)addr);
	return(retVal);
#else 
	return((IU8 *)((IHPE)Start_of_M_area + (IHPE)addr));
#endif
}

/*
 *  Support for V86 Mode.
 *
 * The basic idea here is that some of our BIOS C code will be trying to do
 * things, like changing the interrupt flag, and doing IO which the OS
 * (e.g. Windows) might prevent us doing on a real PC by running the
 * BIOS code in V86 mode.  Hence what we do is check whether executing
 * the relevant instruction would have caused an exception if the processor
 * at it's current protection level had executed it.  If not, it's OK
 * for us to just go ahead and do it.  However, if it would have caused
 * an exception, we need to actually execute an appropriate instruction
 * with the CPU.
 *
 * This has two advantages - one it makes the code layout simpler(!), and
 * secondly it means that Windows can have a look at what sort of instruction
 * caused the exception.
 *
 * Note that this only works for V86 mode because we need to patch-up the
 * CS to point at the ROM.  Basically any OS that trys to execute our
 * BIOS in VM mode and expects to be able to catch exceptions is in for a nasty
 * shock.  Hence the macro that follows:
 *
 * When not in V86 mode, at least one of the Insgina drivers must have
 * allocated and registered two segments for us to use. We use these to
 * construct a flat-writeable data segment and a small code segment that
 * points at the rom -- we use the same code as the V86.
 */


#define BIOS_VIRTUALISE_SEGMENT  0xf000
/*(
 *========================== biosDoInst ===================================
 * biosDoInst
 *
 * Purpose
 *	This function executes the instruction at the requested offset,
 *	saving CS and IP across it.
 *
 * Input
 *	vCS, vEIP, vEAX, vDS, vEDX	The values to used for the
 *					virtualised instruction.
 *
 * Outputs
 *	The value returned in EAX after virtualisation.
 *
 * Description
 *	Use host_simulate to execute an instruction in the bios1.rom
)*/

LOCAL IU32
biosDoInst IFN5(IU16, vCS, LIN_ADDR, vEIP, IU32, vEAX, IU16, vDS, IU32, vEDX)
{
	SAVED IBOOL first = TRUE;
	SAVED IBOOL trace_bios_inst = FALSE;
	SAVED int bodgeAdjustment = 0;

	IMPORT IS32 simulate_level;

	IU16 savedCS;
	IU32 savedEIP;
	IU32 savedEAX;
	IU16 savedDS;
	IU32 savedEDX;
	IU32 savedEBP;
	IU32 result;

	if (first)
	{
		if (Sas.Sas_w_at(0xF3030) == 0x9066)
		{
			/* These are still Keith's roms with garbage as
			 * first two bytes of each entry point
			 */
			bodgeAdjustment = 2;
			fprintf(stderr, "**** Warning: The bios1.rom is out of date. This Ccpu486 will not run Win/E\n");
		}
		if (getenv("biosDoInst") != NULL)
			trace_bios_inst = TRUE;
		first = FALSE;
	}

	savedCS  = getCS();
	savedEIP = getEIP(); //GetInstructionPointer();
	savedEAX = getEAX();
	savedDS  = getDS();
	savedEDX = getEDX();
	savedEBP = getEBP();

	setCS (vCS );
	setEIP(vEIP + bodgeAdjustment);
	setEAX(vEAX);
	setDS (vDS );
	setEDX(vEDX);
	setEBP(simulate_level);

	/*
	 * Call the CPU.
	 */

	if (trace_bios_inst)
	{
		always_trace3("biosDoInst: @ %04x, EAX %08x, EDX %08X", vEIP, vEAX, vEDX);
	}

	host_simulate();

	if (getEBP() != simulate_level)
	{
#ifdef	PROD
		host_error(EG_OWNUP, ERR_QUIT, "biosDoInst: Virtualisation sequencing failure");
#else
		always_trace0("biosDoInst: Virtualisation sequencing failure");
		force_yoda();
#endif
	}

	result = getEAX();

	/* Restore the registers to the original values */

	setCS (savedCS );
	setEIP(savedEIP);
	setEAX(savedEAX);
	setDS (savedDS );
	setEDX(savedEDX);
	setEBP(savedEBP);

	return (result);
}

/*(
 *============================ BiosSti & BiosCli ===============================
 * BiosSti & BiosCli
 *
 * Purpose
 *	These functions are used to check if executing a CLI or STI
 *	would cause an exception.  If so, we execute it from the ROMs
 *	so that Windows has a chance to virtualise it.
 *
 * Input
 *	None.
 *
 * Outputs
 *	None.
 *
 * Description
 *	If protection is OK, just do it, otherwise do the instruction in ROM.
)*/

/* Do STI if legal, else go back to CPU to do STI. */
GLOBAL void
BiosSti IFN0()
{

	if ( c_getCPL() > getIOPL() ) {
		(void)biosDoInst(BIOS_VIRTUALISE_SEGMENT, BIOS_STI_OFFSET, 0, 0, 0);
	} else {
		SET_IF(1);
	}
}

/* Do CLI if legal, else go back to CPU to do CLI. */
GLOBAL void
BiosCli IFN0()
{

	if ( c_getCPL() > getIOPL() ) {
		(void)biosDoInst(BIOS_VIRTUALISE_SEGMENT, BIOS_CLI_OFFSET, 0, 0, 0);
	} else {
		SET_IF(0);
	}
}

/*(
 *============================ c_IOVirtualised =================================
 * c_IOVirtualised
 *
 * Purpose
 *	This function checks whether executing an IO instruction
 *	of the indicated width would cause an exception to go off.
 *
 *	If so, it executes the indicated identical instruction in ROM.
 *	This will allow the exception to go off correctly, and allow the
 *	Intel OS (e.g. Windows) to catch and virtualise it if it wishes.
 *
 *	Otherwise it will be up to the caller to execute the actual IO.
 *
 * Input
 *	port	The port to use
 *	value	Where output values are taken from, and input values
 *		written to. NOTE: THIS MUST BE AN IU32*, WHATEVER THE WIDTH.
 *	offset	The offset in the ROM of the equivalent instruction.
 *	width	byte, word, dword
 *
 * Outputs
 *	True if the operation went to ROM, false if the caller needs to do it.
 *
 * Description
 *	If this is an illegal IO operation, we need to save CS, IP, EAX, EDX
 *	and call host_simulate to execute the equivalent instruction in ROM.
)*/

GLOBAL IBOOL
c_IOVirtualised IFN4(io_addr, port, IU32 *, value, LIN_ADDR, offset, IU8, width)
{
	if (getVM())
	{
		*value = biosDoInst(BIOS_VIRTUALISE_SEGMENT, offset, *value, 0, port);
		return(TRUE);
	} else if ( c_getCPL() > getIOPL()) {
		
		switch (port)
		{
		case 0x23c:	/* mouse */
		case 0x23d:	/* mouse */
		case 0xa0:	/* ica */
		case 0x20:	/* ica */
			break;
		default:
			always_trace1("Virtualising PM I/O code called, port =0x%x\n",
				port);
		}

		if (!selectors_set) {
			sub_note_trace0(SAS_VERBOSE, 
				"Exiting as selectors not set !\n");
			return FALSE;
		}
		*value = biosDoInst(code_sel, offset, *value, 0, port);
		return(TRUE);
	}
	return FALSE;
}

/* Read byte from memory, if V86 Mode let CPU do it. */
LOCAL IU8 
bios_read_byte IFN1(LIN_ADDR, linAddr)
{
	PHY_ADDR phyAddr;
	IUM8 access_request = 0; /* BIT 0 = R/W */
				 /* BIT 1 = U/S */
				 /* BIT 2 = Ensure A and D are valid */

	/* If no paging on, then no problem */

	if (!c_getPG())
	{
		return(phy_r8((PHY_ADDR)linAddr));
	}

	/* Note default access_request (0) is Supervisor Read */

	/* We don't specifically disallow Protected Mode calls, they
	   are not designed to happen, but the Video at least has a habit
	   of reading BIOS variables on host timer ticks. We treat such
	   requests more leniently than V86 Mode requests, by not insisting
	   that the access and dirty bits are kosher.
	 */

	if ( getCPL() != 3 )
	{
		access_request = access_request | PG_U;
	}

	/* Beware V86 Mode, be strict about access and dirty bits */

	if ( getVM() )
	{
		access_request = access_request | 0x4;
	}

	/* Go translate the address. */

	if (xtrn2phy(linAddr, access_request, &phyAddr))
	{
		return(phy_r8(phyAddr));
	}

	/* Handle Address Mapping Failure... */

	if(getPE() && !getVM())
	{
		always_trace1("Virtualising PM byte read, lin address 0x%x", linAddr);

		if (!selectors_set)
			return;

		return ((IU8)biosDoInst(code_sel, BIOS_RDB_OFFSET, 0, data_sel, linAddr));
	}
	else
	{
		sub_note_trace1(SAS_VERBOSE, "Page read VM virtualisation at 0x%x", linAddr);

		return ((IU8)biosDoInst(BIOS_VIRTUALISE_SEGMENT, BIOS_RDB_OFFSET, 0, data_sel, linAddr));
	}
}



/* Read word from memory, if V86 Mode let CPU do it. */
LOCAL IU16
bios_read_word IFN1(LIN_ADDR, linAddr)
{
	PHY_ADDR phyAddr;
	IUM8 access_request = 0; /* BIT 0 = R/W */
				 /* BIT 1 = U/S */
				 /* BIT 2 = Ensure A and D are valid */

	/* If no paging on, then no problem */

	if (!c_getPG())
	{
		return(phy_r16((PHY_ADDR)linAddr));
	}

	/* Note default access_request (0) is Supervisor Read */

	/* We don't specifically disallow Protected Mode calls, they
	   are not designed to happen, but the Video at least has a habit
	   of reading BIOS variables on host timer ticks. We treat such
	   requests more leniently than V86 Mode requests, by not insisting
	   that the access and dirty bits are kosher.
	 */

	if ( getCPL() != 3 )
	{
		access_request = access_request | PG_U;
	}

	/* Beware V86 Mode, be strict about access and dirty bits */

	if ( getVM() )
	{
		access_request = access_request | 0x4;
	}

	/* Go translate the address. Never called crossing a page boundary */

	if (xtrn2phy(linAddr, access_request, &phyAddr))
	{
		return(phy_r16(phyAddr));
	}

	/* Handle Address Mapping Failure... */

	if(getPE() && !getVM())
	{
		always_trace1("Virtualising PM word read, lin address 0x%x", linAddr);

		if (!selectors_set)
			return;

		return ((IU8)biosDoInst(code_sel, BIOS_RDW_OFFSET, 0, data_sel, linAddr));
	}
	else
	{
		sub_note_trace1(SAS_VERBOSE, "Page read word VM virtualisation at 0x%x", linAddr);

		return ((IU8)biosDoInst(BIOS_VIRTUALISE_SEGMENT, BIOS_RDW_OFFSET, 0, data_sel, linAddr));
	}
}


/* Read double from memory, if V86 Mode let CPU do it. */
LOCAL IU32
bios_read_double IFN1(LIN_ADDR, linAddr)
{
	PHY_ADDR phyAddr;
	IUM8 access_request = 0; /* BIT 0 = R/W */
				 /* BIT 1 = U/S */
				 /* BIT 2 = Ensure A and D are valid */

	/* If no paging on, then no problem */

	if (!c_getPG())
	{
		return(phy_r32((PHY_ADDR)linAddr));
	}

	/* Note default access_request (0) is Supervisor Read */

	/* We don't specifically disallow Protected Mode calls, they
	   are not designed to happen, but the Video at least has a habit
	   of reading BIOS variables on host timer ticks. We treat such
	   requests more leniently than V86 Mode requests, by not insisting
	   that the access and dirty bits are kosher.
	 */

	if ( getCPL() != 3 )
	{
		access_request = access_request | PG_U;
	}

	/* Beware V86 Mode, be strict about access and dirty bits */

	if ( getVM() )
	{
		access_request = access_request | 0x4;
	}

	/* Go translate the address. Never called crossing a page boundary */

	if (xtrn2phy(linAddr, access_request, &phyAddr))
	{
		return(phy_r32(phyAddr));
	}

	/* Handle Address Mapping Failure... */

	if(getPE() && !getVM())
	{
		always_trace1("Virtualising PM double read, lin address 0x%x", linAddr);

		if (!selectors_set)
			return;

		return ((IU8)biosDoInst(code_sel, BIOS_RDD_OFFSET, 0, data_sel, linAddr));
	}
	else
	{
		sub_note_trace1(SAS_VERBOSE, "Page read double VM virtualisation at 0x%x", linAddr);

		return ((IU8)biosDoInst(BIOS_VIRTUALISE_SEGMENT, BIOS_RDD_OFFSET, 0, data_sel, linAddr));
	}
}


/* Write byte to memory, if V86 Mode let CPU do it. */
LOCAL void 
bios_write_byte IFN2(LIN_ADDR, linAddr, IU8, value)
{
	PHY_ADDR addr;
	IUM8 access_request = 0;	/* BIT 0 = R/W */
   					/* BIT 1 = U/S */
   					/* BIT 2 = Ensure A and D are valid */

	/* If no paging on, then no problem */

	if (!c_getPG())
	{
		phy_w8((PHY_ADDR)linAddr, value);
		return;
	}
	
	/* Note default access_request (0) is Supervisor Read */
	access_request = access_request | PG_W;   /* So make it Right :-) */
	
	/* We don't specifically disallow Protected Mode calls, they
	   are not designed to happen, but who knows. We treat such
	   requests more leniently than V86 Mode requests, by not insisting
	   that the access and dirty bits are kosher.
	 */

	if ( getCPL() != 3 )
	{
		access_request = access_request | PG_U;
	}
	
	/* Beware V86 Mode, be strict about access and dirty bits */
	if ( getVM() )
	{
		access_request = access_request | 0x4;
	}
	
	/* Go translate the address. */
	if (xtrn2phy(linAddr, access_request, &addr))
	{
		phy_w8(addr, value);
		return;
	}
	
	/* Handle Address Mapping Failure... */

	if(getPE() && !getVM())
	{
		always_trace1("Virtualising PM byte write, lin address 0x%x", linAddr);
		
		if (!selectors_set)
			return;

		(void)biosDoInst(code_sel, BIOS_WRTB_OFFSET, (IU32)value, data_sel, linAddr);
	}
	else
	{
		sub_note_trace1(SAS_VERBOSE, "Page write VM virtualisation at 0x%x", linAddr);

		(void)biosDoInst(BIOS_VIRTUALISE_SEGMENT, BIOS_WRTB_OFFSET, (IU32)value, data_sel, linAddr);
	}
}


/* Write word to memory, if V86 Mode let CPU do it. */
LOCAL void 
bios_write_word IFN2(LIN_ADDR, linAddr, IU16, value)
{
	PHY_ADDR addr;
	IUM8 access_request = 0;	/* BIT 0 = R/W */
   					/* BIT 1 = U/S */
   					/* BIT 2 = Ensure A and D are valid */

	/* If no paging on, then no problem */

	if (!c_getPG())
	{
		phy_w16((PHY_ADDR)linAddr, value);
		return;
	}
	
	/* Note default access_request (0) is Supervisor Read */
	access_request = access_request | PG_W;   /* So make it Right :-) */
	
	/* We don't specifically disallow Protected Mode calls, they
	   are not designed to happen, but who knows. We treat such
	   requests more leniently than V86 Mode requests, by not insisting
	   that the access and dirty bits are kosher.
	 */

	if ( getCPL() != 3 )
	{
		access_request = access_request | PG_U;
	}
	
	/* Beware V86 Mode, be strict about access and dirty bits */
	if ( getVM() )
	{
		access_request = access_request | 0x4;
	}
	
	/* Go translate the address. Never called crossing a page boundary */
	if (xtrn2phy(linAddr, access_request, &addr))
	{
		phy_w16(addr, value);
		return;
	}
	
	/* Handle Address Mapping Failure... */

	if(getPE() && !getVM())
	{
		always_trace1("Virtualising PM word write, lin address 0x%x", linAddr);
		
		if (!selectors_set)
			return;

		(void)biosDoInst(code_sel, BIOS_WRTW_OFFSET, (IU32)value, data_sel, linAddr);
	}
	else
	{
		sub_note_trace1(SAS_VERBOSE, "Page word write VM virtualisation at 0x%x", linAddr);

		(void)biosDoInst(BIOS_VIRTUALISE_SEGMENT, BIOS_WRTW_OFFSET, (IU32)value, data_sel, linAddr);
	}
}


/* Write double to memory, if V86 Mode let CPU do it. */
LOCAL void 
bios_write_double IFN2(LIN_ADDR, linAddr, IU32, value)
{
	PHY_ADDR addr;
	IUM8 access_request = 0;	/* BIT 0 = R/W */
   					/* BIT 1 = U/S */
   					/* BIT 2 = Ensure A and D are valid */

	/* If no paging on, then no problem */

	if (!c_getPG())
	{
		phy_w32((PHY_ADDR)linAddr, value);
		return;
	}
	
	/* Note default access_request (0) is Supervisor Read */
	access_request = access_request | PG_W;   /* So make it Right :-) */
	
	/* We don't specifically disallow Protected Mode calls, they
	   are not designed to happen, but who knows. We treat such
	   requests more leniently than V86 Mode requests, by not insisting
	   that the access and dirty bits are kosher.
	 */

	if ( getCPL() != 3 )
	{
		access_request = access_request | PG_U;
	}
	
	/* Beware V86 Mode, be strict about access and dirty bits */
	if ( getVM() )
	{
		access_request = access_request | 0x4;
	}
	
	/* Go translate the address. Never called crossing a page boundary */
	if (xtrn2phy(linAddr, access_request, &addr))
	{
		phy_w32(addr, value);
		return;
	}
	
	/* Handle Address Mapping Failure... */

	if(getPE() && !getVM())
	{
		always_trace1("Virtualising PM double write, lin address 0x%x", linAddr);
		
		if (!selectors_set)
			return;

		(void)biosDoInst(code_sel, BIOS_WRTD_OFFSET, (IU32)value, data_sel, linAddr);
	}
	else
	{
		sub_note_trace1(SAS_VERBOSE, "Page double write VM virtualisation at 0x%x", linAddr);

		(void)biosDoInst(BIOS_VIRTUALISE_SEGMENT, BIOS_WRTD_OFFSET, (IU32)value, data_sel, linAddr);
	}
}


LOCAL	void	c_sas_not_used	IFN0()
{
	always_trace0("c_sas_not_used called");
#ifndef	PROD
	force_yoda();
#endif
}


/* Compatibility with SoftPC2.0 access name (used in video) */
GLOBAL IU8* c_get_byte_addr IFN1(PHY_ADDR, addr)
{
	return (c_GetPhyAdd(addr));
}

/* stub needed for standalone Ccpu */
GLOBAL IBOOL c_sas_PigCmpPage IFN3(IU32, src, IU8 *, dest, IU32, len)
{
	return(FALSE);
}
#endif 				/* CCPU */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ccpusas4.h ===
/*[
 * File Name		: ccpu_sas4.h
 *
 * Derived From		: Template
 *
 * Author		: Mike
 *
 * Creation Date	: October 1993
 *
 * SCCS Version		: @(#)ccpusas4.h	1.5 11/15/94
 *!
 * Purpose
 *	This include file contains the interface provided by ccpu_sas4.h
 *	to the rest of the ccpu.
 *
 *! (c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
]*/

extern IU8 phy_r8 IPT1(PHY_ADDR, addr);
extern IU16 phy_r16 IPT1(PHY_ADDR, addr);
extern IU32 phy_r32 IPT1(PHY_ADDR, addr);
extern void phy_w8 IPT2(PHY_ADDR, addr, IU8, value);
extern void phy_w16 IPT2(PHY_ADDR, addr, IU16, value);
extern void phy_w32 IPT2(PHY_ADDR, addr, IU32, value);

extern PHY_ADDR SasWrapMask;

#if !defined(PIG)
#ifdef BACK_M
#define IncCpuPtrLS8(ptr) (ptr)--
#else	/* BACK_M */
#define IncCpuPtrLS8(ptr) (ptr)++
#endif	/* BACK_M */
#endif	/* PIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ccpupig.c ===
/*[

ccpupig.c

LOCAL CHAR SccsID[]="@(#)ccpupig.c	1.22 04/11/95"

C CPU <-> Pigger Interface
--------------------------

]*/

#include <insignia.h>
#include <host_def.h>

#ifdef	PIG

#include <xt.h>
#define	CPU_PRIVATE
#include CpuH
#include <ccpupig.h>
#include  <sas.h>	/* need memory(M)     */
#include  <ccpusas4.h>	/* the cpu internal sas bits */
#include <Cpu_c.h>	/* Intel memory access macros */

#include <c_reg.h>
#include <c_xcptn.h>
#include <c_page.h>

#define DASM_PRIVATE
#include <dasm.h>
#include <decode.h>

#include <assert.h>
/*
 * Interface between this cpu and other one being pigged
 */
GLOBAL	enum pig_actions pig_cpu_action;
GLOBAL	IBOOL	ccpu_pig_enabled = FALSE;

/*
 * Last Instruction memorizing...
 */

GLOBAL	IU32	ccpu_synch_count = 1;

LOCAL struct ccpu_last_inst *inst_buffer;
LOCAL struct ccpu_last_inst *inst_ptr;
LOCAL struct ccpu_last_inst *inst_ptr_wrap;
LOCAL struct ccpu_last_inst *next_inst_ptr;
LOCAL struct ccpu_last_inst *inst_bytes_ptr;
LOCAL char prefetch_inst_buffer[200];

/*(
 * Keep these last inst vars up to date...
)*/

GLOBAL	VOID	save_last_inst_details	IFN1(char *, text)
{
	inst_ptr->cs = GET_CS_SELECTOR();
	inst_ptr->big_cs = GET_CS_AR_X() != 0;
	inst_ptr->text = text;
	/*
	 * getEIP() should be getInstructionPointer() but they
	 * are equivalent for the current CCPU.
	 */
	inst_ptr->eip = GET_EIP();
	inst_bytes_ptr = inst_ptr;
	inst_bytes_ptr->inst_len = 0;

	inst_ptr->synch_count = ccpu_synch_count;

	if (++inst_ptr >= inst_ptr_wrap)
		inst_ptr = inst_buffer;

	/* Invalidate the previous prefetch disassembly buffer */
	prefetch_inst_buffer[0] = '\0';
}

/* This is called by the CCPU as it processes each instruction byte.
 * The CCPU has already checked that the Intel instruction is not just
 * an infinite sequence of prefixes, so we know it will fit.
 */
GLOBAL IU8 save_instruction_byte IFN1(IU8, byte)
{
	int len = inst_bytes_ptr->inst_len++;

	inst_bytes_ptr->bytes[len] = byte;
	return (byte);
}

/* When an exception occurs, the CCPU will save the details in the last instruction
 * history buffer. This requires a sprintf, and we use the code-bytes data area
 * to keep this information.
 * Up to 3 parameters can be in the format.
 */
GLOBAL	VOID	save_last_xcptn_details	IFN6(char *, fmt, IUH, a1, IUH, a2, IUH, a3, IUH, a4, IUH, a5 )
{
	char buffer[128];

	inst_ptr->cs = getCS_SELECTOR();
	inst_ptr->eip = getEIP();
	inst_ptr->big_cs = 0;
	inst_ptr->synch_count = ccpu_synch_count;

	/* The default message is too long sometimes.
	 * We replace any leading "Exception:-" with "XCPT"
	 */

	if (strncmp(fmt, "Exception:-", 11) == 0)
	{
		strcpy(buffer, "XCPT");
		sprintf(buffer + 4, fmt + 11, a1, a2, a3, a4, a5);
	}
	else
	{
		sprintf(buffer, fmt, a1, a2, a3, a4, a5);
	}

	if (strlen(buffer) >= sizeof(inst_ptr->bytes))
		printf("warning: CCPU XCPTN text message below longer than buffer; truncating:\n -- %s\n", buffer);

	strncpy(&inst_ptr->bytes[0], buffer, sizeof(inst_ptr->bytes) - 2);

	inst_ptr->bytes[sizeof(inst_ptr->bytes) - 2] = '\n';
	inst_ptr->bytes[sizeof(inst_ptr->bytes) - 1] = '\0';

	inst_ptr->text = (char *)&inst_ptr->bytes[0];

	if (++inst_ptr >= inst_ptr_wrap)
		inst_ptr = inst_buffer;

	/* Invalidate the previous prefetch disassembly buffer */
	prefetch_inst_buffer[0] = '\0';
}

GLOBAL	struct ccpu_last_inst *get_synch_inst_details IFN1(IU32, synch_point)
{
	/* scan backwards through the buffer until the start of the relevant
	 * synch point block is found.
	 */
	IS32 n_entries = inst_ptr_wrap - inst_buffer;

	next_inst_ptr = inst_ptr - 1;

	if (next_inst_ptr < inst_buffer)
		next_inst_ptr = inst_ptr_wrap - 1;

	while (synch_point <= next_inst_ptr->synch_count)
	{
		if (--n_entries <= 0)
			return (next_inst_ptr);

		if (--next_inst_ptr < inst_buffer)
			next_inst_ptr = inst_ptr_wrap - 1;
	}

	if (++next_inst_ptr >= inst_ptr_wrap)
		next_inst_ptr = inst_buffer;

	return (next_inst_ptr);
}


/* After a previous call to get_synch_inst_details(), get the next
 * inst details. This call should be repeated until NULL is returned.
 */
GLOBAL	struct ccpu_last_inst *get_next_inst_details IFN1(IU32, finish_synch_point)
{
	if (next_inst_ptr)
	{
		if (++next_inst_ptr >= inst_ptr_wrap)
			next_inst_ptr = inst_buffer;

		if ((next_inst_ptr->synch_count == 0)
		    || (next_inst_ptr == inst_ptr)
		    || (next_inst_ptr->synch_count > finish_synch_point)
		    )
		{
			next_inst_ptr = (struct ccpu_last_inst *)0;
		}
	}
	return next_inst_ptr;
}


GLOBAL	VOID	init_last_inst_details IFN0()
{
	SAVED IBOOL first = TRUE;

	if (first)
	{
		struct ccpu_last_inst *ptr;
		ISM32 size = ISM32getenv("CCPU_HISTORY_SIZE", 256);

		if (size < 100)
		{
			sprintf(prefetch_inst_buffer,
				"CCPU_HISTORY_SIZE of %d is too small",
				size);
			FatalError(prefetch_inst_buffer);
		}
		ptr = (struct ccpu_last_inst *)host_malloc(size * sizeof(*ptr));
		if (ptr == (struct ccpu_last_inst *)0)
		{
			sprintf(prefetch_inst_buffer,
				"Unable to malloc memory for CCPU_HISTORY_SIZE of %d",
				size);
			FatalError(prefetch_inst_buffer);
		}
		inst_buffer = ptr;
		inst_ptr_wrap = &inst_buffer[size];
		first = FALSE;
	}

	memset(inst_buffer, 0, ((IHPE)inst_ptr_wrap - (IHPE)inst_buffer));
	next_inst_ptr = (struct ccpu_last_inst *)0;
	inst_ptr = inst_buffer;
}


/* When about to pig an interrupt we may need to mark the last
 * basic block as "invalid" even though it has been executed by
 * the CCPU.
 */
GLOBAL VOID save_last_interrupt_details IFN2(IU8, number, IBOOL, invalidateLastBlock)
{
	if (invalidateLastBlock)
	{
		struct ccpu_last_inst *ptr;
		IU32 synch_count = ccpu_synch_count - 1;

		ptr = get_synch_inst_details(synch_count);
		
		while (ptr != (struct ccpu_last_inst *)0)
		{
			ptr->text = "Intr: invalidated";
			ptr = get_next_inst_details(synch_count);
		}
	}
	save_last_xcptn_details("Intr: vector %02x", number, 0, 0, 0, 0);
}


LOCAL IBOOL reset_prefetch;

LOCAL IS32 prefetch_byte IFN1(LIN_ADDR, eip)
{
	SAVED IU8 *ip_ptr;
	SAVED IU8 *ip_ceiling;
	SAVED LIN_ADDR last_eip;
	IU8 b;

	if (reset_prefetch
	    || (eip != ++last_eip)
	    || !BelowOrEqualCpuPtrsLS8(ip_ptr, ip_ceiling))
	{
		IU32 ip_phys_addr;

		/* Ensure this we fault first on the first
		 * byte within a new page -- dasm386 sometimes
		 * looks ahead a couple of bytes.
		 */
		if (GET_EIP() != eip)
		{
			(void)usr_chk_byte((GET_CS_BASE() + eip) & 0xFFFFF000, PG_R);
		}
		ip_phys_addr = usr_chk_byte(GET_CS_BASE() + eip, PG_R);
		ip_ptr = Sas.SasPtrToPhysAddrByte(ip_phys_addr);
		ip_ceiling = CeilingIntelPageLS8(ip_ptr);
		reset_prefetch = FALSE;
	}
	b = *IncCpuPtrLS8(ip_ptr);
	last_eip = eip;
	return ((IS32) b);
}

/* Use the decoder from dasm386 to read the bytes in a single instruction */
GLOBAL void prefetch_1_instruction IFN0()
{
	IBOOL bigCode = GET_CS_AR_X() != 0;
	IU32 eip = GET_EIP();
	char *fmt, *newline;

	reset_prefetch = TRUE;

	/* If we take a fault, the EIP pushed will be the
	 * value at the start of the "instruction"
	 * We must update this incase we fault.
	 */
	CCPU_save_EIP = eip;

	if ( bigCode )
	{
		fmt = "  %04x:%08x ";
		newline = "\n                ";
	}
	else
	{
		fmt = "  %04x:%04x ";
		newline = "\n            ";
	}
	(void)dasm_internal(prefetch_inst_buffer,
			    GET_CS_SELECTOR(),
			    eip,
			    bigCode ? THIRTY_TWO_BIT: SIXTEEN_BIT,
			    eip,
			    prefetch_byte,
			    fmt,
			    newline);
	assert(strlen(prefetch_inst_buffer) < sizeof(prefetch_inst_buffer));
}

/* Return to the show_code() routine in the pigger the instruction
 * we prefetched.
 */
GLOBAL char *get_prefetched_instruction IFN0()
{
	return (prefetch_inst_buffer);
}
#endif	/* PIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ccpupig.h ===
/*[

ccpupig.h

LOCAL CHAR SccsID[]="@(#)ccpupig.h	1.26 04/11/95"

C CPU <-> Pigger definitions and interfaces.
-------------------------------------------

]*/

#ifdef	PIG

enum pig_actions
{
	CHECK_NONE,		/* Check nothing (not yet executed) and carry on */
	CHECK_ALL,		/* Check all and carry on */
	CHECK_NO_EXEC,		/* Check all, but dont carry on */
	CHECK_SOME_MEM,		/* Check memory (other than marked not written) */
	CHECK_NO_AL,		/* Don't check AL */
	CHECK_NO_AX,		/* Don't check AX */
	CHECK_NO_EAX,		/* Don't check EAX */
	CHECK_NO_A20		/* Don't check A20 wrap (just done OUT 60) */
};

typedef struct CpuStateREC cpustate_t;

/*
 * Interface between this cpu and other one being pigged
 */
IMPORT	enum pig_actions pig_cpu_action;
IMPORT	enum pig_actions last_pig_action;
IMPORT	IBOOL	ccpu_pig_enabled;

/*
 * Mask for arithmetic flags bits not known if PigIgnoreFlags is TRUE
 * == ( CF | PF | AF | SF | ZF | OV ) == BIT0 | BIT2 | BIT4 | BIT6 | BIT7 | BIT11 )
 */
#define ARITH_FLAGS_BITS	( 0x1 | 0x4 | 0x10 | 0x40 | 0x80 | 0x800 )

/*
 * Mask for interrupts for which the EDL *may* not have correct flags
 * information.
 */
#define NO_FLAGS_EXCEPTION_MASK	( ( 1 <<  1 ) |	\
				  ( 1 <<  3 ) |	\
				  ( 1 <<  8 ) |	\
				  ( 1 << 10 ) |	\
				  ( 1 << 11 ) |	\
				  ( 1 << 12 ) |	\
				  ( 1 << 13 ) |	\
				  ( 1 << 14 ) |	\
				  ( 1 << 15 ) )

/*
 * Last Instruction memorizing...
 */

#define	MAX_INTEL_PREFIX	(15-1)
#define	MAX_INTEL_BODY		15
#define MAX_INTEL_BYTES		(MAX_INTEL_PREFIX+MAX_INTEL_BODY)	/* max size of single intel instruction */
#define MAX_EXCEPTION_BYTES	40					/* size of buffer used for exception logging */

#define CCPUINST_BUFFER_SIZE	((MAX_INTEL_BYTES > MAX_EXCEPTION_BYTES) ? MAX_INTEL_BYTES : MAX_EXCEPTION_BYTES)

struct ccpu_last_inst {
	IU16		cs;
	IU8		inst_len;
	IBOOL		big_cs;
	IU32		eip;
	IU32		synch_count;
	char		*text;
	IU8		bytes[CCPUINST_BUFFER_SIZE];
};

IMPORT	IU32	ccpu_synch_count;

IMPORT	VOID	save_last_inst_details	IPT1(char *, text);
IMPORT	IU8	save_instruction_byte	IPT1(IU8, byte);
IMPORT	VOID	save_last_xcptn_details	IPT6(char *, fmt, IUH, a1, IUH, a2, IUH, a3, IUH, a4, IUH, a5);
IMPORT	VOID	init_last_inst_details	IPT0();
IMPORT	VOID	save_last_interrupt_details IPT2(IU8, number, IBOOL, invalidateLastBlock);

/* Routines to get last instruction information from the CCPU ring buffer */

IMPORT	struct ccpu_last_inst *get_synch_inst_details IPT1(IU32, synch_point);
IMPORT	struct ccpu_last_inst *get_next_inst_details IPT1(IU32, synch_point);

/* Routine to return a disassembled form of the last instruction prefetched by the CCPU */

IMPORT char *get_prefetched_instruction IPT0();

/*
 * Get/Set state of C CCPU (getsetc.c)
 */
IMPORT void c_getCpuState IPT1(cpustate_t *, p_state);
IMPORT void c_setCpuState IPT1(cpustate_t *, p_new_state);

/*
 * Get NPX regs from A Cpu and set C Cpu (only if necessary)
 */
IMPORT void c_checkCpuNpxRegisters IPT0();
/*
 * Set NPX regs from given state.
 */
IMPORT void c_setCpuNpxRegisters IPT1(cpustate_t *, p_new_state);
/*
 *
 */
IMPORT void prefetch_1_instruction IPT0();

#if defined(SFELLOW)
/*
 * memory-mapped I/O information. Counts number of memory-mapped inputs and
 * outputs since the last pig synch.
 */
#define COLLECT_MMIO_STATS	1
 
#define	LAST_FEW	32		/* must be power of 2 */
#define	LAST_FEW_MASK	(LAST_FEW - 1)	/* see above */

struct pig_mmio_info \
{
#if COLLECT_MMIO_STATS
	IU32	mm_input_count;		/* since last Pig error */
	IU32	mm_output_count;	/* since last Pig error */
	IU32	mm_input_section_count;	/* no. of synch sections unchecked due
					   to M-M input since last Pig error */
	IU32	mm_output_section_count;/* no. of synch sections containing
					   M-M output since last Pig error */
	IU32	start_synch_count;	/* at last pig error/enabling */
	struct last_few_inputs
	{	
		IU32	addr;		/* address of memory-mapped input	*/
		IU32	synch_count;	/* ccpu_synch_count at that input	*/
	} last_few_inputs[LAST_FEW];
	struct last_few_outputs
	{	
		IU32	addr;		/* address of memory-mapped output	*/
		IU32	synch_count;	/* ccpu_synch_count at that output	*/
	} last_few_outputs[LAST_FEW];
#endif	/* COLLECT_MMIO_STATS */
	IUM16	flags;
};

/*
 * flags element definitions
 */
#define	MM_INPUT_OCCURRED		0x1	/* in current synch section */
#define	MM_OUTPUT_OCCURRED		0x2	/* in current synch section */
#define	MM_INPUT_COUNT_WRAPPED		0x4
#define	MM_OUTPUT_COUNT_WRAPPED		0x8
#define	MM_INPUT_SECTION_COUNT_WRAPPED	0x10
#define	MM_OUTPUT_SECTION_COUNT_WRAPPED	0x20

extern	struct pig_mmio_info	pig_mmio_info;

#if COLLECT_MMIO_STATS
extern void clear_mmio_stats IPT0();
extern void show_mmio_stats IPT0();
#endif	/* COLLECT_MMIO_STATS */

#endif	/* SFELLOW */

extern IBOOL IgnoringThisSynchPoint IPT2(IU16, cs, IU32, eip);
extern IBOOL ignore_page_accessed IPT0();
#endif	/* PIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cdq.h ===
/* 
   cdq.h

   CDQ CPU functions.
 */

/*
   static char SccsID[]="@(#)cdq.h	1.5 09/01/94";
 */

IMPORT VOID CDQ IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cdq.c ===
/*[

cdq.c

LOCAL CHAR SccsID[]="@(#)cdq.c	1.5 02/09/94";

CDQ CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cdq.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CDQ()
   {
   if ( GET_EAX() & BIT31_MASK )   /* sign bit set? */
      SET_EDX(0xffffffff);
   else
      SET_EDX(0);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\clc.c ===
/*[

clc.c

LOCAL CHAR SccsID[]="@(#)clc.c	1.5 02/09/94";

CLC CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <clc.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CLC()
   {
   SET_CF(0);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cld.c ===
/*[

cld.c

LOCAL CHAR SccsID[]="@(#)cld.c	1.5 02/09/94";

CLD CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cld.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CLD()
   {
   SET_DF(0);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cld.h ===
/* 
   cld.h

   Define all CLD CPU functions.
 */

/*
   static char SccsID[]="@(#)cld.h	1.5 09/01/94";
 */

IMPORT VOID CLD IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\clc.h ===
/* 
   clc.h

   Define all CLC CPU functions.
 */

/*
   static char SccsID[]="@(#)clc.h	1.5 09/01/94";
 */

IMPORT VOID CLC IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cli.c ===
/*[

cli.c

LOCAL CHAR SccsID[]="@(#)cli.c	1.5 02/09/94";

CLI CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cli.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CLI()
   {
   SET_IF(0);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\clts.c ===
/*[

clts.c

LOCAL CHAR SccsID[]="@(#)clts.c	1.5 02/09/94";

CLTS CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <clts.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CLTS()
   {
   SET_CR(CR_STAT, GET_CR(CR_STAT) & ~BIT3_MASK);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cli.h ===
/* 
   cli.h

   Define all CLI CPU functions.
 */

/*
   static char SccsID[]="@(#)cli.h	1.5 09/01/94";
 */

IMPORT VOID CLI IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cmc.c ===
/*[

cmc.c

LOCAL CHAR SccsID[]="@(#)cmc.c	1.5 02/09/94";

CMC CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cmc.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CMC()
   {
   SET_CF(1 - GET_CF());
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\clts.h ===
/* 
   clts.h

   Define all CLTS CPU functions.
 */

/*
   static char SccsID[]="@(#)clts.h	1.5 09/01/94";
 */

IMPORT VOID CLTS IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cmc.h ===
/* 
   cmc.h

   Define all CMC CPU functions.
 */

/*
   static char SccsID[]="@(#)cmc.h	1.5 09/01/94";
 */

IMPORT VOID CMC IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cmp.h ===
/* 
   cmp.h

   Define all CMP CPU functions.
 */

/*
   static char SccsID[]="@(#)cmp.h	1.4 02/09/94";
 */

IMPORT VOID CMP
               
IPT3(
	IU32, op1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cmpxchg.c ===
/*[

cmpxchg.c

LOCAL CHAR SccsID[]="@(#)cmpxchg.c	1.5 02/09/94";

CMPXCHG CPU functions.
----------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cmpxchg.h>
#include <cmp.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


#ifdef SPC486

GLOBAL VOID
CMPXCHG8
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   /*
      First do comparision and generate flags.
    */
   CMP((IU32)GET_AL(), *pop1, 8);

   /*
      Then swap data as required.
    */
   if ( GET_ZF() )   /* ie iff AL == op1 */
      {
      *pop1 = op2;
      }
   else
      {
      SET_AL(*pop1);
      }
   }

GLOBAL VOID
CMPXCHG16
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   /*
      First do comparision and generate flags.
    */
   CMP((IU32)GET_AX(), *pop1, 16);

   /*
      Then swap data as required.
    */
   if ( GET_ZF() )   /* ie iff AX == op1 */
      {
      *pop1 = op2;
      }
   else
      {
      SET_AX(*pop1);
      }
   }

GLOBAL VOID
CMPXCHG32
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   /*
      First do comparision and generate flags.
    */
   CMP((IU32)GET_EAX(), *pop1, 32);

   /*
      Then swap data as required.
    */
   if ( GET_ZF() )   /* ie iff EAX == op1 */
      {
      *pop1 = op2;
      }
   else
      {
      SET_EAX(*pop1);
      }
   }

#endif /* SPC486 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cmpxchg.h ===
/* 
   cmpxchg.h

   CMPXCHG CPU functions.
 */

/*
   static char SccsID[]="@(#)cmpxchg.h	1.4 02/09/94";
 */

IMPORT VOID CMPXCHG8
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID CMPXCHG16
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID CMPXCHG32
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cwd.c ===
/*[

cwd.c

LOCAL CHAR SccsID[]="@(#)cwd.c	1.5 02/09/94";

CWD CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cwd.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CWD()
   {
   if ( GET_AX() & BIT15_MASK )   /* sign bit set? */
      SET_DX(0xffff);
   else
      SET_DX(0);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cmp.c ===
/*[

cmp.c

LOCAL CHAR SccsID[]="@(#)cmp.c	1.5 02/09/94";

CMP CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cmp.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'cmp'.                                 */
/* Generic - one size fits all 'cmps'.                                */
/* Generic - one size fits all 'scas'.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
CMP
       	    	    	                    
IFN3(
	IU32, op1,	/* lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 carry;
   IU32 msb;
   IU32 op1_msb;
   IU32 op2_msb;
   IU32 res_msb;

   msb = SZ2MSB(op_sz);

   result = op1 - op2 & SZ2MASK(op_sz);		/* Do operation */
   op1_msb = (op1    & msb) != 0;	/* Isolate all msb's */
   op2_msb = (op2    & msb) != 0;
   res_msb = (result & msb) != 0;
   carry = op1 ^ op2 ^ result;		/* Isolate carries */
					/* Determine flags */
   /*
      OF = (op1 == !op2) & (op1 ^ res)
      ie if operand signs differ and res sign different to original
      destination set OF.
    */
   SET_OF((op1_msb != op2_msb) & (op1_msb ^ res_msb));
   /*
      Formally:-     CF = !op1 & op2 | res & !op1 | res & op2
      Equivalently:- CF = OF ^ op1 ^ op2 ^ res
    */
   SET_CF(((carry & msb) != 0) ^ GET_OF());
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */
   SET_AF((carry & BIT4_MASK) != 0);	/* AF = Bit 4 carry */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cpuint_c.h ===
#ifndef _CpuInt_c_h
#define _CpuInt_c_h
#define ChipType (228)
#define WaferRevision (1)
#define nQuickTickerThreads (4)
struct InterruptREC
{
	IBOOL Activity;
	IBOOL Reset;
	IBOOL PoolsGettingTooBig;
	IBOOL Hardware;
	IBOOL Interval;
	IBOOL AsynchIO;
	IBOOL QuickTickerScan;
	IBOOL SRCI;
	IBOOL Disabled;
};
struct QuickTickerThreadREC
{
	IBOOL Activity;
	IUH triggerPoint;
	IUH elapsed;
};
struct QuickTickerREC
{
	IUH triggerPoint;
	IUH elapsed;
	IUH perTickDelta;
	IUH averageRate;
	IUH averageError;
	struct QuickTickerThreadREC *threads;
};
enum CPU_INT_TYPE
{
	CPU_HW_RESET = 0,
	CPU_TIMER_TICK = 1,
	CPU_HW_INT = 2,
	CPU_SAD_INT = 3,
	CPU_SIGIO_EVENT = 4,
	CPU_NPX_INT = 5
};
#endif /* ! _CpuInt_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cpu4gen.h ===
/*[
 * Generated File: cpu4gen.h
 *
]*/

#ifndef _CPU4GEN_H_
#define _CPU4GEN_H_

#include <gdpvar.h>	/* For direct access getAX() etc. */

struct	CpuVector	{
#ifdef	CPU_PRIVATE
	struct	CpuPrivateVector	*Private;
#else	/* !CPU_PRIVATE */
	IHP	Private;
#endif	/* CPU_PRIVATE */
#ifdef	CPU_PRIVATE
	struct	SasVector	*Sas;
#else	/* !CPU_PRIVATE */
	IHP	Sas;
#endif	/* CPU_PRIVATE */
#ifdef	CPU_PRIVATE
	struct	VideoVector	*Video;
#else	/* !CPU_PRIVATE */
	IHP	Video;
#endif	/* CPU_PRIVATE */
	void	(*Simulate)	IPT0();
	void	(*Interrupt)	IPT2(CPU_INT_TYPE,	intType, IU16,	intNum);
	void	(*ClearHwInt)	IPT0();
	void	(*EndOfApplication)	IPT0();
	void	(*Terminate)	IPT0();
	void	(*Initialise)	IPT0();
	IU32	(*EffectiveAddr)	IPT2(IU16,	seg, IU32,	offset);
	void	(*SetQuickEventCount)	IPT1(IU32,	val);
	IU32	(*GetQuickEventCount)	IPT0();
	void	(*InitIOS)	IPT4(IHP,	InTables, IHP,	OutTables, IUH,	maxAdaptor, IU16,	portMask);
	void	(*DefineInb)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineInw)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineInd)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineOutb)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineOutw)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineOutd)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*SetAL)	IPT1(IU8,	val);
	void	(*SetAH)	IPT1(IU8,	val);
	void	(*SetAX)	IPT1(IU16,	val);
	void	(*SetEAX)	IPT1(IU32,	val);
	void	(*SetBL)	IPT1(IU8,	val);
	void	(*SetBH)	IPT1(IU8,	val);
	void	(*SetBX)	IPT1(IU16,	val);
	void	(*SetEBX)	IPT1(IU32,	val);
	void	(*SetCL)	IPT1(IU8,	val);
	void	(*SetCH)	IPT1(IU8,	val);
	void	(*SetCX)	IPT1(IU16,	val);
	void	(*SetECX)	IPT1(IU32,	val);
	void	(*SetDL)	IPT1(IU8,	val);
	void	(*SetDH)	IPT1(IU8,	val);
	void	(*SetDX)	IPT1(IU16,	val);
	void	(*SetEDX)	IPT1(IU32,	val);
	void	(*SetSI)	IPT1(IU16,	val);
	void	(*SetESI)	IPT1(IU32,	val);
	void	(*SetDI)	IPT1(IU16,	val);
	void	(*SetEDI)	IPT1(IU32,	val);
	void	(*SetSP)	IPT1(IU16,	val);
	void	(*SetESP)	IPT1(IU32,	val);
	void	(*SetBP)	IPT1(IU16,	val);
	void	(*SetEBP)	IPT1(IU32,	val);
	void	(*SetIP)	IPT1(IU16,	val);
	void	(*SetEIP)	IPT1(IU32,	val);
	IUH	(*SetCS)	IPT1(IU16,	val);
	IUH	(*SetSS)	IPT1(IU16,	val);
	IUH	(*SetDS)	IPT1(IU16,	val);
	IUH	(*SetES)	IPT1(IU16,	val);
	IUH	(*SetFS)	IPT1(IU16,	val);
	IUH	(*SetGS)	IPT1(IU16,	val);
	void	(*SetEFLAGS)	IPT1(IU32,	val);
	void	(*SetSTATUS)	IPT1(IU16,	val);
	void	(*SetIOPL)	IPT1(IU8,	val);
	void	(*SetMSW)	IPT1(IU16,	val);
	void	(*SetCR0)	IPT1(IU32,	val);
	void	(*SetCR2)	IPT1(IU32,	val);
	void	(*SetCR3)	IPT1(IU32,	val);
	void	(*SetCF)	IPT1(IBOOL,	val);
	void	(*SetPF)	IPT1(IBOOL,	val);
	void	(*SetAF)	IPT1(IBOOL,	val);
	void	(*SetZF)	IPT1(IBOOL,	val);
	void	(*SetSF)	IPT1(IBOOL,	val);
	void	(*SetTF)	IPT1(IBOOL,	val);
	void	(*SetIF)	IPT1(IBOOL,	val);
	void	(*SetDF)	IPT1(IBOOL,	val);
	void	(*SetOF)	IPT1(IBOOL,	val);
	void	(*SetNT)	IPT1(IBOOL,	val);
	void	(*SetRF)	IPT1(IBOOL,	val);
	void	(*SetVM)	IPT1(IBOOL,	val);
	void	(*SetAC)	IPT1(IBOOL,	val);
	void	(*SetPE)	IPT1(IBOOL,	val);
	void	(*SetMP)	IPT1(IBOOL,	val);
	void	(*SetEM)	IPT1(IBOOL,	val);
	void	(*SetTS)	IPT1(IBOOL,	val);
	void	(*SetPG)	IPT1(IBOOL,	val);
	void	(*SetLDT_SELECTOR)	IPT1(IU16,	val);
	void	(*SetTR_SELECTOR)	IPT1(IU16,	val);
	IU8	(*GetAL)	IPT0();
	IU8	(*GetAH)	IPT0();
	IU16	(*GetAX)	IPT0();
	IU32	(*GetEAX)	IPT0();
	IU8	(*GetBL)	IPT0();
	IU8	(*GetBH)	IPT0();
	IU16	(*GetBX)	IPT0();
	IU32	(*GetEBX)	IPT0();
	IU8	(*GetCL)	IPT0();
	IU8	(*GetCH)	IPT0();
	IU16	(*GetCX)	IPT0();
	IU32	(*GetECX)	IPT0();
	IU8	(*GetDL)	IPT0();
	IU8	(*GetDH)	IPT0();
	IU16	(*GetDX)	IPT0();
	IU32	(*GetEDX)	IPT0();
	IU16	(*GetSI)	IPT0();
	IU32	(*GetESI)	IPT0();
	IU16	(*GetDI)	IPT0();
	IU32	(*GetEDI)	IPT0();
	IU16	(*GetSP)	IPT0();
	IU32	(*GetESP)	IPT0();
	IU16	(*GetBP)	IPT0();
	IU32	(*GetEBP)	IPT0();
	IU16	(*GetIP)	IPT0();
	IU32	(*GetEIP)	IPT0();
	IU16	(*GetCS)	IPT0();
	IU16	(*GetSS)	IPT0();
	IU16	(*GetDS)	IPT0();
	IU16	(*GetES)	IPT0();
	IU16	(*GetFS)	IPT0();
	IU16	(*GetGS)	IPT0();
	IU32	(*GetEFLAGS)	IPT0();
	IU16	(*GetSTATUS)	IPT0();
	IU8	(*GetIOPL)	IPT0();
	IU16	(*GetMSW)	IPT0();
	IU32	(*GetCR0)	IPT0();
	IU32	(*GetCR2)	IPT0();
	IU32	(*GetCR3)	IPT0();
	IBOOL	(*GetCF)	IPT0();
	IBOOL	(*GetPF)	IPT0();
	IBOOL	(*GetAF)	IPT0();
	IBOOL	(*GetZF)	IPT0();
	IBOOL	(*GetSF)	IPT0();
	IBOOL	(*GetTF)	IPT0();
	IBOOL	(*GetIF)	IPT0();
	IBOOL	(*GetDF)	IPT0();
	IBOOL	(*GetOF)	IPT0();
	IBOOL	(*GetNT)	IPT0();
	IBOOL	(*GetRF)	IPT0();
	IBOOL	(*GetVM)	IPT0();
	IBOOL	(*GetAC)	IPT0();
	IBOOL	(*GetPE)	IPT0();
	IBOOL	(*GetMP)	IPT0();
	IBOOL	(*GetEM)	IPT0();
	IBOOL	(*GetTS)	IPT0();
	IBOOL	(*GetET)	IPT0();
	IBOOL	(*GetNE)	IPT0();
	IBOOL	(*GetWP)	IPT0();
	IBOOL	(*GetPG)	IPT0();
	IU32	(*GetGDT_BASE)	IPT0();
	IU16	(*GetGDT_LIMIT)	IPT0();
	IU32	(*GetIDT_BASE)	IPT0();
	IU16	(*GetIDT_LIMIT)	IPT0();
	IU16	(*GetLDT_SELECTOR)	IPT0();
	IU32	(*GetLDT_BASE)	IPT0();
	IU32	(*GetLDT_LIMIT)	IPT0();
	IU16	(*GetTR_SELECTOR)	IPT0();
	IU32	(*GetTR_BASE)	IPT0();
	IU32	(*GetTR_LIMIT)	IPT0();
	IU16	(*GetTR_AR)	IPT0();
	IUH	(*GetJumpCalibrateVal)	IPT0();
	IUH	(*GetJumpInitialVal)	IPT0();
	void	(*SetJumpInitialVal)	IPT1(IUH,	initialVal);
	void	(*SetEOIEnable)	IPT1(IU8 *,	initialVal);
	void	(*SetAddProfileData)	IPT1(IHP,	initialVal);
	void	(*SetMaxProfileData)	IPT1(IHP,	initialVal);
	IHP	(*GetAddProfileDataAddr)	IPT0();
	void	(*PurgeLostIretHookLine)	IPT2(IU16,	lineNum, IU32,	depth);
	void	(*ActivityCheckAfterTimeSlice)	IPT0();
	IBOOL	(*CheckCsSelectorAndEipForCallFarPatching)	IPT3(IU16,	csSel, IU32,	eip, IU32 *,	pCsBase);
};

extern	struct	CpuVector	Cpu;

#ifdef	CCPU
IMPORT	void	c_cpu_simulate	IPT0();
#define	cpu_simulate	c_cpu_simulate
#else	/* CCPU */

#ifdef PROD
#define	cpu_simulate	(*(Cpu.Simulate))
#else /* PROD */
IMPORT	void	cpu_simulate	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_interrupt	IPT2(CPU_INT_TYPE, intType, IU16, intNum);
#define	cpu_interrupt	c_cpu_interrupt
#else	/* CCPU */

#ifdef PROD
#define	cpu_interrupt	(*(Cpu.Interrupt))
#else /* PROD */
IMPORT	void	cpu_interrupt	IPT2(CPU_INT_TYPE, intType, IU16, intNum);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_clearHwInt	IPT0();
#define	cpu_clearHwInt	c_cpu_clearHwInt
#else	/* CCPU */

#ifdef PROD
#define	cpu_clearHwInt	(*(Cpu.ClearHwInt))
#else /* PROD */
IMPORT	void	cpu_clearHwInt	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_EOA_hook	IPT0();
#define	cpu_EOA_hook	c_cpu_EOA_hook
#else	/* CCPU */

#ifdef PROD
#define	cpu_EOA_hook	(*(Cpu.EndOfApplication))
#else /* PROD */
IMPORT	void	cpu_EOA_hook	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_terminate	IPT0();
#define	cpu_terminate()	c_cpu_terminate()
#else	/* CCPU */

#ifdef PROD
#define	cpu_terminate()	{	if (Cpu.Terminate)	(*(Cpu.Terminate))(); }
#else /* PROD */
IMPORT	void	cpu_terminate	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_init	IPT0();
#define	cpu_init	c_cpu_init
#else	/* CCPU */

#ifdef PROD
#define	cpu_init	(*(Cpu.Initialise))
#else /* PROD */
IMPORT	void	cpu_init	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_effective_addr	IPT2(IU16, seg, IU32, offset);
#define	effective_addr(seg, offset)	c_effective_addr(seg, offset)
#else	/* CCPU */

#ifdef PROD
#define	effective_addr(seg, offset)	(*(Cpu.EffectiveAddr))(seg, offset)
#else /* PROD */
IMPORT	IU32	effective_addr	IPT2(IU16, seg, IU32, offset);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_q_ev_set_count	IPT1(IU32, val);
#define	host_q_ev_set_count	c_cpu_q_ev_set_count
#else	/* CCPU */

#ifdef PROD
#define	host_q_ev_set_count	(*(Cpu.SetQuickEventCount))
#else /* PROD */
IMPORT	void	host_q_ev_set_count	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_cpu_q_ev_get_count	IPT0();
#define	host_q_ev_get_count	c_cpu_q_ev_get_count
#else	/* CCPU */

#ifdef PROD
#define	host_q_ev_get_count	(*(Cpu.GetQuickEventCount))
#else /* PROD */
IMPORT	IU32	host_q_ev_get_count	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_init_ios_in	IPT4(IHP, InTables, IHP, OutTables, IUH, maxAdaptor, IU16, portMask);
#define	cpu_init_ios_in	c_cpu_init_ios_in
#else	/* CCPU */

#ifdef PROD
#define	cpu_init_ios_in	(*(Cpu.InitIOS))
#else /* PROD */
IMPORT	void	cpu_init_ios_in	IPT4(IHP, InTables, IHP, OutTables, IUH, maxAdaptor, IU16, portMask);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_inb	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_inb	c_cpu_define_inb
#else	/* CCPU */

#ifdef PROD
#define	ios_define_inb	(*(Cpu.DefineInb))
#else /* PROD */
IMPORT	void	ios_define_inb	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_inw	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_inw	c_cpu_define_inw
#else	/* CCPU */

#ifdef PROD
#define	ios_define_inw	(*(Cpu.DefineInw))
#else /* PROD */
IMPORT	void	ios_define_inw	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_ind	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_ind	c_cpu_define_ind
#else	/* CCPU */

#ifdef PROD
#define	ios_define_ind	(*(Cpu.DefineInd))
#else /* PROD */
IMPORT	void	ios_define_ind	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_outb	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_outb	c_cpu_define_outb
#else	/* CCPU */

#ifdef PROD
#define	ios_define_outb	(*(Cpu.DefineOutb))
#else /* PROD */
IMPORT	void	ios_define_outb	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_outw	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_outw	c_cpu_define_outw
#else	/* CCPU */

#ifdef PROD
#define	ios_define_outw	(*(Cpu.DefineOutw))
#else /* PROD */
IMPORT	void	ios_define_outw	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_outd	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_outd	c_cpu_define_outd
#else	/* CCPU */

#ifdef PROD
#define	ios_define_outd	(*(Cpu.DefineOutd))
#else /* PROD */
IMPORT	void	ios_define_outd	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAL	IPT1(IU8, val);
#define	setAL(val)	c_setAL(val)
#else	/* CCPU */

#ifdef PROD
#define	setAL(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEax((GLOBAL_nanoEax & 0xFFFFFF00) | ((val) & 0x000000FF)): \
		SET_GLOBAL_R_EAX((GLOBAL_R_EAX & 0xFFFFFF00) | ((val) & 0x000000FF)))

#else /* PROD */
IMPORT	void	setAL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAH	IPT1(IU8, val);
#define	setAH(val)	c_setAH(val)
#else	/* CCPU */

#ifdef PROD
#define	setAH(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEax((GLOBAL_nanoEax & 0xFFFF00FF) | (((val) & 0x000000FF) << 8)): \
		SET_GLOBAL_R_EAX((GLOBAL_R_EAX & 0xFFFF00FF) | (((val) & 0x000000FF) << 8)))

#else /* PROD */
IMPORT	void	setAH	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAX	IPT1(IU16, val);
#define	setAX(val)	c_setAX(val)
#else	/* CCPU */

#ifdef PROD
#define	setAX(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEax((GLOBAL_nanoEax & 0xFFFF0000) | ((val) & 0x0000FFFF)): \
		SET_GLOBAL_R_EAX((GLOBAL_R_EAX & 0xFFFF0000) | ((val) & 0x0000FFFF)))

#else /* PROD */
IMPORT	void	setAX	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEAX	IPT1(IU32, val);
#define	setEAX(val)	c_setEAX(val)
#else	/* CCPU */

#ifdef PROD
#define	setEAX(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEax(val): \
		SET_GLOBAL_R_EAX(val))

#else /* PROD */
IMPORT	void	setEAX	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setBL	IPT1(IU8, val);
#define	setBL(val)	c_setBL(val)
#else	/* CCPU */

#ifdef PROD
#define	setBL(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEbx((GLOBAL_nanoEbx & 0xFFFFFF00) | ((val) & 0x000000FF)): \
		SET_GLOBAL_R_EBX((GLOBAL_R_EBX & 0xFFFFFF00) | ((val) & 0x000000FF)))

#else /* PROD */
IMPORT	void	setBL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setBH	IPT1(IU8, val);
#define	setBH(val)	c_setBH(val)
#else	/* CCPU */

#ifdef PROD
#define	setBH(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEbx((GLOBAL_nanoEbx & 0xFFFF00FF) | (((val) & 0x000000FF) << 8)): \
		SET_GLOBAL_R_EBX((GLOBAL_R_EBX & 0xFFFF00FF) | (((val) & 0x000000FF) << 8)))

#else /* PROD */
IMPORT	void	setBH	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setBX	IPT1(IU16, val);
#define	setBX(val)	c_setBX(val)
#else	/* CCPU */

#ifdef PROD
#define	setBX(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEbx((GLOBAL_nanoEbx & 0xFFFF0000) | ((val) & 0x0000FFFF)): \
		SET_GLOBAL_R_EBX((GLOBAL_R_EBX & 0xFFFF0000) | ((val) & 0x0000FFFF)))

#else /* PROD */
IMPORT	void	setBX	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEBX	IPT1(IU32, val);
#define	setEBX(val)	c_setEBX(val)
#else	/* CCPU */

#ifdef PROD
#define	setEBX(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEbx(val): \
		SET_GLOBAL_R_EBX(val))

#else /* PROD */
IMPORT	void	setEBX	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCL	IPT1(IU8, val);
#define	setCL(val)	c_setCL(val)
#else	/* CCPU */

#ifdef PROD
#define	setCL(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEcx((GLOBAL_nanoEcx & 0xFFFFFF00) | ((val) & 0x000000FF)): \
		SET_GLOBAL_R_ECX((GLOBAL_R_ECX & 0xFFFFFF00) | ((val) & 0x000000FF)))

#else /* PROD */
IMPORT	void	setCL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCH	IPT1(IU8, val);
#define	setCH(val)	c_setCH(val)
#else	/* CCPU */

#ifdef PROD
#define	setCH(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEcx((GLOBAL_nanoEcx & 0xFFFF00FF) | (((val) & 0x000000FF) << 8)): \
		SET_GLOBAL_R_ECX((GLOBAL_R_ECX & 0xFFFF00FF) | (((val) & 0x000000FF) << 8)))

#else /* PROD */
IMPORT	void	setCH	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCX	IPT1(IU16, val);
#define	setCX(val)	c_setCX(val)
#else	/* CCPU */

#ifdef PROD
#define	setCX(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEcx((GLOBAL_nanoEcx & 0xFFFF0000) | ((val) & 0x0000FFFF)): \
		SET_GLOBAL_R_ECX((GLOBAL_R_ECX & 0xFFFF0000) | ((val) & 0x0000FFFF)))

#else /* PROD */
IMPORT	void	setCX	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setECX	IPT1(IU32, val);
#define	setECX(val)	c_setECX(val)
#else	/* CCPU */

#ifdef PROD
#define	setECX(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEcx(val): \
		SET_GLOBAL_R_ECX(val))

#else /* PROD */
IMPORT	void	setECX	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDL	IPT1(IU8, val);
#define	setDL(val)	c_setDL(val)
#else	/* CCPU */

#ifdef PROD
#define	setDL(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEdx((GLOBAL_nanoEdx & 0xFFFFFF00) | ((val) & 0x000000FF)): \
		SET_GLOBAL_R_EDX((GLOBAL_R_EDX & 0xFFFFFF00) | ((val) & 0x000000FF)))

#else /* PROD */
IMPORT	void	setDL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDH	IPT1(IU8, val);
#define	setDH(val)	c_setDH(val)
#else	/* CCPU */

#ifdef PROD
#define	setDH(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEdx((GLOBAL_nanoEdx & 0xFFFF00FF) | (((val) & 0x000000FF) << 8)): \
		SET_GLOBAL_R_EDX((GLOBAL_R_EDX & 0xFFFF00FF) | (((val) & 0x000000FF) << 8)))

#else /* PROD */
IMPORT	void	setDH	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDX	IPT1(IU16, val);
#define	setDX(val)	c_setDX(val)
#else	/* CCPU */

#ifdef PROD
#define	setDX(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEdx((GLOBAL_nanoEdx & 0xFFFF0000) | ((val) & 0x0000FFFF)): \
		SET_GLOBAL_R_EDX((GLOBAL_R_EDX & 0xFFFF0000) | ((val) & 0x0000FFFF)))

#else /* PROD */
IMPORT	void	setDX	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEDX	IPT1(IU32, val);
#define	setEDX(val)	c_setEDX(val)
#else	/* CCPU */

#ifdef PROD
#define	setEDX(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEdx(val): \
		SET_GLOBAL_R_EDX(val))

#else /* PROD */
IMPORT	void	setEDX	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSI	IPT1(IU16, val);
#define	setSI(val)	c_setSI(val)
#else	/* CCPU */

#ifdef PROD
#define	setSI(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEsi((GLOBAL_nanoEsi & 0xFFFF0000) | ((val) & 0x0000FFFF)): \
		SET_GLOBAL_R_ESI((GLOBAL_R_ESI & 0xFFFF0000) | ((val) & 0x0000FFFF)))

#else /* PROD */
IMPORT	void	setSI	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setESI	IPT1(IU32, val);
#define	setESI(val)	c_setESI(val)
#else	/* CCPU */

#ifdef PROD
#define	setESI(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEsi(val): \
		SET_GLOBAL_R_ESI(val))

#else /* PROD */
IMPORT	void	setESI	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDI	IPT1(IU16, val);
#define	setDI(val)	c_setDI(val)
#else	/* CCPU */

#ifdef PROD
#define	setDI(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEdi((GLOBAL_nanoEdi & 0xFFFF0000) | ((val) & 0x0000FFFF)): \
		SET_GLOBAL_R_EDI((GLOBAL_R_EDI & 0xFFFF0000) | ((val) & 0x0000FFFF)))

#else /* PROD */
IMPORT	void	setDI	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEDI	IPT1(IU32, val);
#define	setEDI(val)	c_setEDI(val)
#else	/* CCPU */

#ifdef PROD
#define	setEDI(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEdi(val): \
		SET_GLOBAL_R_EDI(val))

#else /* PROD */
IMPORT	void	setEDI	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSP	IPT1(IU16, val);
#define	setSP(val)	c_setSP(val)
#else	/* CCPU */

#ifdef PROD
#define	setSP(val)	(*(Cpu.SetSP))(val)
#else /* PROD */
IMPORT	void	setSP	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setESP	IPT1(IU32, val);
#define	setESP(val)	c_setESP(val)
#else	/* CCPU */

#ifdef PROD
#define	setESP(val)	(*(Cpu.SetESP))(val)
#else /* PROD */
IMPORT	void	setESP	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setBP	IPT1(IU16, val);
#define	setBP(val)	c_setBP(val)
#else	/* CCPU */

#ifdef PROD
#define	setBP(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEbp((GLOBAL_nanoEbp & 0xFFFF0000) | ((val) & 0x0000FFFF)): \
		SET_GLOBAL_R_EBP((GLOBAL_R_EBP & 0xFFFF0000) | ((val) & 0x0000FFFF)))

#else /* PROD */
IMPORT	void	setBP	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEBP	IPT1(IU32, val);
#define	setEBP(val)	c_setEBP(val)
#else	/* CCPU */

#ifdef PROD
#define	setEBP(val)	(GLOBAL_InNanoCpu ? SET_GLOBAL_nanoEbp(val): \
		SET_GLOBAL_R_EBP(val))

#else /* PROD */
IMPORT	void	setEBP	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setIP	IPT1(IU16, val);
#define	setIP(val)	c_setIP(val)
#else	/* CCPU */

#ifdef PROD
#define	setIP(val)	(*(Cpu.SetIP))(val)
#else /* PROD */
IMPORT	void	setIP	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEIP	IPT1(IU32, val);
#define	setEIP(val)	c_setEIP(val)
#else	/* CCPU */

#ifdef PROD
#define	setEIP(val)	(*(Cpu.SetEIP))(val)
#else /* PROD */
IMPORT	void	setEIP	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setCS	IPT1(IU16, val);
#define	setCS(val)	c_setCS(val)
#else	/* CCPU */

#ifdef PROD
#define	setCS(val)	(*(Cpu.SetCS))(val)
#else /* PROD */
IMPORT	IUH	setCS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setSS	IPT1(IU16, val);
#define	setSS(val)	c_setSS(val)
#else	/* CCPU */

#ifdef PROD
#define	setSS(val)	(*(Cpu.SetSS))(val)
#else /* PROD */
IMPORT	IUH	setSS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setDS	IPT1(IU16, val);
#define	setDS(val)	c_setDS(val)
#else	/* CCPU */

#ifdef PROD
#define	setDS(val)	(*(Cpu.SetDS))(val)
#else /* PROD */
IMPORT	IUH	setDS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setES	IPT1(IU16, val);
#define	setES(val)	c_setES(val)
#else	/* CCPU */

#ifdef PROD
#define	setES(val)	(*(Cpu.SetES))(val)
#else /* PROD */
IMPORT	IUH	setES	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setFS	IPT1(IU16, val);
#define	setFS(val)	c_setFS(val)
#else	/* CCPU */

#ifdef PROD
#define	setFS(val)	(*(Cpu.SetFS))(val)
#else /* PROD */
IMPORT	IUH	setFS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setGS	IPT1(IU16, val);
#define	setGS(val)	c_setGS(val)
#else	/* CCPU */

#ifdef PROD
#define	setGS(val)	(*(Cpu.SetGS))(val)
#else /* PROD */
IMPORT	IUH	setGS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEFLAGS	IPT1(IU32, val);
#define	setEFLAGS(val)	c_setEFLAGS(val)
#else	/* CCPU */

#ifdef PROD
#define	setEFLAGS(val)	(*(Cpu.SetEFLAGS))(val)
#else /* PROD */
IMPORT	void	setEFLAGS	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSTATUS	IPT1(IU16, val);
#define	setSTATUS(val)	c_setSTATUS(val)
#else	/* CCPU */

#ifdef PROD
#define	setSTATUS(val)	(*(Cpu.SetSTATUS))(val)
#else /* PROD */
IMPORT	void	setSTATUS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setIOPL	IPT1(IU8, val);
#define	setIOPL(val)	c_setIOPL(val)
#else	/* CCPU */

#ifdef PROD
#define	setIOPL(val)	(*(Cpu.SetIOPL))(val)
#else /* PROD */
IMPORT	void	setIOPL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setMSW	IPT1(IU16, val);
#define	setMSW(val)	c_setMSW(val)
#else	/* CCPU */

#ifdef PROD
#define	setMSW(val)	(*(Cpu.SetMSW))(val)
#else /* PROD */
IMPORT	void	setMSW	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCR0	IPT1(IU32, val);
#define	setCR0(val)	c_setCR0(val)
#else	/* CCPU */

#ifdef PROD
#define	setCR0(val)	(*(Cpu.SetCR0))(val)
#else /* PROD */
IMPORT	void	setCR0	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCR2	IPT1(IU32, val);
#define	setCR2(val)	c_setCR2(val)
#else	/* CCPU */

#ifdef PROD
#define	setCR2(val)	(*(Cpu.SetCR2))(val)
#else /* PROD */
IMPORT	void	setCR2	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCR3	IPT1(IU32, val);
#define	setCR3(val)	c_setCR3(val)
#else	/* CCPU */

#ifdef PROD
#define	setCR3(val)	(*(Cpu.SetCR3))(val)
#else /* PROD */
IMPORT	void	setCR3	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCF	IPT1(IBOOL, val);
#define	setCF(val)	c_setCF(val)
#else	/* CCPU */

#ifdef PROD
#define	setCF(val)	(*(Cpu.SetCF))(val)
#else /* PROD */
IMPORT	void	setCF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setPF	IPT1(IBOOL, val);
#define	setPF(val)	c_setPF(val)
#else	/* CCPU */

#ifdef PROD
#define	setPF(val)	(*(Cpu.SetPF))(val)
#else /* PROD */
IMPORT	void	setPF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAF	IPT1(IBOOL, val);
#define	setAF(val)	c_setAF(val)
#else	/* CCPU */

#ifdef PROD
#define	setAF(val)	(*(Cpu.SetAF))(val)
#else /* PROD */
IMPORT	void	setAF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setZF	IPT1(IBOOL, val);
#define	setZF(val)	c_setZF(val)
#else	/* CCPU */

#ifdef PROD
#define	setZF(val)	(*(Cpu.SetZF))(val)
#else /* PROD */
IMPORT	void	setZF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSF	IPT1(IBOOL, val);
#define	setSF(val)	c_setSF(val)
#else	/* CCPU */

#ifdef PROD
#define	setSF(val)	(*(Cpu.SetSF))(val)
#else /* PROD */
IMPORT	void	setSF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setTF	IPT1(IBOOL, val);
#define	setTF(val)	c_setTF(val)
#else	/* CCPU */

#ifdef PROD
#define	setTF(val)	(*(Cpu.SetTF))(val)
#else /* PROD */
IMPORT	void	setTF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setIF	IPT1(IBOOL, val);
#define	setIF(val)	c_setIF(val)
#else	/* CCPU */

#ifdef PROD
#define	setIF(val)	(*(Cpu.SetIF))(val)
#else /* PROD */
IMPORT	void	setIF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDF	IPT1(IBOOL, val);
#define	setDF(val)	c_setDF(val)
#else	/* CCPU */

#ifdef PROD
#define	setDF(val)	(*(Cpu.SetDF))(val)
#else /* PROD */
IMPORT	void	setDF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setOF	IPT1(IBOOL, val);
#define	setOF(val)	c_setOF(val)
#else	/* CCPU */

#ifdef PROD
#define	setOF(val)	(*(Cpu.SetOF))(val)
#else /* PROD */
IMPORT	void	setOF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setNT	IPT1(IBOOL, val);
#define	setNT(val)	c_setNT(val)
#else	/* CCPU */

#ifdef PROD
#define	setNT(val)	(*(Cpu.SetNT))(val)
#else /* PROD */
IMPORT	void	setNT	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setRF	IPT1(IBOOL, val);
#define	setRF(val)	c_setRF(val)
#else	/* CCPU */

#ifdef PROD
#define	setRF(val)	(*(Cpu.SetRF))(val)
#else /* PROD */
IMPORT	void	setRF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setVM	IPT1(IBOOL, val);
#define	setVM(val)	c_setVM(val)
#else	/* CCPU */

#ifdef PROD
#define	setVM(val)	(*(Cpu.SetVM))(val)
#else /* PROD */
IMPORT	void	setVM	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAC	IPT1(IBOOL, val);
#define	setAC(val)	c_setAC(val)
#else	/* CCPU */

#ifdef PROD
#define	setAC(val)	(*(Cpu.SetAC))(val)
#else /* PROD */
IMPORT	void	setAC	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setPE	IPT1(IBOOL, val);
#define	setPE(val)	c_setPE(val)
#else	/* CCPU */

#ifdef PROD
#define	setPE(val)	(*(Cpu.SetPE))(val)
#else /* PROD */
IMPORT	void	setPE	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setMP	IPT1(IBOOL, val);
#define	setMP(val)	c_setMP(val)
#else	/* CCPU */

#ifdef PROD
#define	setMP(val)	(*(Cpu.SetMP))(val)
#else /* PROD */
IMPORT	void	setMP	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEM	IPT1(IBOOL, val);
#define	setEM(val)	c_setEM(val)
#else	/* CCPU */

#ifdef PROD
#define	setEM(val)	(*(Cpu.SetEM))(val)
#else /* PROD */
IMPORT	void	setEM	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setTS	IPT1(IBOOL, val);
#define	setTS(val)	c_setTS(val)
#else	/* CCPU */

#ifdef PROD
#define	setTS(val)	(*(Cpu.SetTS))(val)
#else /* PROD */
IMPORT	void	setTS	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setPG	IPT1(IBOOL, val);
#define	setPG(val)	c_setPG(val)
#else	/* CCPU */

#ifdef PROD
#define	setPG(val)	(*(Cpu.SetPG))(val)
#else /* PROD */
IMPORT	void	setPG	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setLDT_SELECTOR	IPT1(IU16, val);
#define	setLDT_SELECTOR(val)	c_setLDT_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setLDT_SELECTOR(val)	(*(Cpu.SetLDT_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setLDT_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setTR_SELECTOR	IPT1(IU16, val);
#define	setTR_SELECTOR(val)	c_setTR_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setTR_SELECTOR(val)	(*(Cpu.SetTR_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setTR_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getAL	IPT0();
#define	getAL()	c_getAL()
#else	/* CCPU */

#ifdef PROD
#define	getAL()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEax: GLOBAL_R_EAX)) & 0x000000FF)
#else /* PROD */
IMPORT	IU8	getAL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getAH	IPT0();
#define	getAH()	c_getAH()
#else	/* CCPU */

#ifdef PROD
#define	getAH()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEax: GLOBAL_R_EAX) >> 8) & 0x000000FF)
#else /* PROD */
IMPORT	IU8	getAH	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getAX	IPT0();
#define	getAX()	c_getAX()
#else	/* CCPU */

#ifdef PROD
#define	getAX()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEax: GLOBAL_R_EAX)) & 0x0000FFFF)
#else /* PROD */
IMPORT	IU16	getAX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEAX	IPT0();
#define	getEAX()	c_getEAX()
#else	/* CCPU */

#ifdef PROD
#define	getEAX()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEax: GLOBAL_R_EAX)) & 0xFFFFFFFF)
#else /* PROD */
IMPORT	IU32	getEAX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getBL	IPT0();
#define	getBL()	c_getBL()
#else	/* CCPU */

#ifdef PROD
#define	getBL()	(*(Cpu.GetBL))()
#else /* PROD */
IMPORT	IU8	getBL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getBH	IPT0();
#define	getBH()	c_getBH()
#else	/* CCPU */

#ifdef PROD
#define	getBH()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEbx: GLOBAL_R_EBX) >> 8) & 0x000000FF)
#else /* PROD */
IMPORT	IU8	getBH	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getBX	IPT0();
#define	getBX()	c_getBX()
#else	/* CCPU */

#ifdef PROD
#define	getBX()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEbx: GLOBAL_R_EBX)) & 0x0000FFFF)
#else /* PROD */
IMPORT	IU16	getBX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEBX	IPT0();
#define	getEBX()	c_getEBX()
#else	/* CCPU */

#ifdef PROD
#define	getEBX()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEbx: GLOBAL_R_EBX)) & 0xFFFFFFFF)
#else /* PROD */
IMPORT	IU32	getEBX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getCL	IPT0();
#define	getCL()	c_getCL()
#else	/* CCPU */

#ifdef PROD
#define	getCL()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEcx: GLOBAL_R_ECX)) & 0x000000FF)
#else /* PROD */
IMPORT	IU8	getCL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getCH	IPT0();
#define	getCH()	c_getCH()
#else	/* CCPU */

#ifdef PROD
#define	getCH()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEcx: GLOBAL_R_ECX) >> 8) & 0x000000FF)
#else /* PROD */
IMPORT	IU8	getCH	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getCX	IPT0();
#define	getCX()	c_getCX()
#else	/* CCPU */

#ifdef PROD
#define	getCX()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEcx: GLOBAL_R_ECX)) & 0x0000FFFF)
#else /* PROD */
IMPORT	IU16	getCX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getECX	IPT0();
#define	getECX()	c_getECX()
#else	/* CCPU */

#ifdef PROD
#define	getECX()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEcx: GLOBAL_R_ECX)) & 0xFFFFFFFF)
#else /* PROD */
IMPORT	IU32	getECX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getDL	IPT0();
#define	getDL()	c_getDL()
#else	/* CCPU */

#ifdef PROD
#define	getDL()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEdx: GLOBAL_R_EDX)) & 0x000000FF)
#else /* PROD */
IMPORT	IU8	getDL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getDH	IPT0();
#define	getDH()	c_getDH()
#else	/* CCPU */

#ifdef PROD
#define	getDH()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEdx: GLOBAL_R_EDX) >> 8) & 0x000000FF)
#else /* PROD */
IMPORT	IU8	getDH	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDX	IPT0();
#define	getDX()	c_getDX()
#else	/* CCPU */

#ifdef PROD
#define	getDX()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEdx: GLOBAL_R_EDX)) & 0x0000FFFF)
#else /* PROD */
IMPORT	IU16	getDX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEDX	IPT0();
#define	getEDX()	c_getEDX()
#else	/* CCPU */

#ifdef PROD
#define	getEDX()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEdx: GLOBAL_R_EDX)) & 0xFFFFFFFF)
#else /* PROD */
IMPORT	IU32	getEDX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSI	IPT0();
#define	getSI()	c_getSI()
#else	/* CCPU */

#ifdef PROD
#define	getSI()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEsi: GLOBAL_R_ESI)) & 0x0000FFFF)
#else /* PROD */
IMPORT	IU16	getSI	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getESI	IPT0();
#define	getESI()	c_getESI()
#else	/* CCPU */

#ifdef PROD
#define	getESI()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEsi: GLOBAL_R_ESI)) & 0xFFFFFFFF)
#else /* PROD */
IMPORT	IU32	getESI	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDI	IPT0();
#define	getDI()	c_getDI()
#else	/* CCPU */

#ifdef PROD
#define	getDI()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEdi: GLOBAL_R_EDI)) & 0x0000FFFF)
#else /* PROD */
IMPORT	IU16	getDI	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEDI	IPT0();
#define	getEDI()	c_getEDI()
#else	/* CCPU */

#ifdef PROD
#define	getEDI()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEdi: GLOBAL_R_EDI)) & 0xFFFFFFFF)
#else /* PROD */
IMPORT	IU32	getEDI	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSP	IPT0();
#define	getSP()	c_getSP()
#else	/* CCPU */

#ifdef PROD
#define	getSP()	(*(Cpu.GetSP))()
#else /* PROD */
IMPORT	IU16	getSP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getESP	IPT0();
#define	getESP()	c_getESP()
#else	/* CCPU */

#ifdef PROD
#define	getESP()	(*(Cpu.GetESP))()
#else /* PROD */
IMPORT	IU32	getESP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getBP	IPT0();
#define	getBP()	c_getBP()
#else	/* CCPU */

#ifdef PROD
#define	getBP()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEbp: GLOBAL_R_EBP)) & 0x0000FFFF)
#else /* PROD */
IMPORT	IU16	getBP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEBP	IPT0();
#define	getEBP()	c_getEBP()
#else	/* CCPU */

#ifdef PROD
#define	getEBP()	(((GLOBAL_InNanoCpu ? GLOBAL_nanoEbp: GLOBAL_R_EBP)) & 0xFFFFFFFF)
#else /* PROD */
IMPORT	IU32	getEBP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getIP	IPT0();
#define	getIP()	c_getIP()
#else	/* CCPU */

#ifdef PROD
#define	getIP()	(*(Cpu.GetIP))()
#else /* PROD */
IMPORT	IU16	getIP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEIP	IPT0();
#define	getEIP()	c_getEIP()
#else	/* CCPU */

#ifdef PROD
#define	getEIP()	(*(Cpu.GetEIP))()
#else /* PROD */
IMPORT	IU32	getEIP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getCS	IPT0();
#define	getCS()	c_getCS()
#else	/* CCPU */

#ifdef PROD
#define	getCS()	(*(Cpu.GetCS))()
#else /* PROD */
IMPORT	IU16	getCS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSS	IPT0();
#define	getSS()	c_getSS()
#else	/* CCPU */

#ifdef PROD
#define	getSS()	(*(Cpu.GetSS))()
#else /* PROD */
IMPORT	IU16	getSS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDS	IPT0();
#define	getDS()	c_getDS()
#else	/* CCPU */

#ifdef PROD
#define	getDS()	(*(Cpu.GetDS))()
#else /* PROD */
IMPORT	IU16	getDS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getES	IPT0();
#define	getES()	c_getES()
#else	/* CCPU */

#ifdef PROD
#define	getES()	(*(Cpu.GetES))()
#else /* PROD */
IMPORT	IU16	getES	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getFS	IPT0();
#define	getFS()	c_getFS()
#else	/* CCPU */

#ifdef PROD
#define	getFS()	(*(Cpu.GetFS))()
#else /* PROD */
IMPORT	IU16	getFS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getGS	IPT0();
#define	getGS()	c_getGS()
#else	/* CCPU */

#ifdef PROD
#define	getGS()	(*(Cpu.GetGS))()
#else /* PROD */
IMPORT	IU16	getGS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEFLAGS	IPT0();
#define	getEFLAGS()	c_getEFLAGS()
#else	/* CCPU */

#ifdef PROD
#define	getEFLAGS()	(*(Cpu.GetEFLAGS))()
#else /* PROD */
IMPORT	IU32	getEFLAGS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSTATUS	IPT0();
#define	getSTATUS()	c_getSTATUS()
#else	/* CCPU */

#ifdef PROD
#define	getSTATUS()	(*(Cpu.GetSTATUS))()
#else /* PROD */
IMPORT	IU16	getSTATUS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getIOPL	IPT0();
#define	getIOPL()	c_getIOPL()
#else	/* CCPU */

#ifdef PROD
#define	getIOPL()	(*(Cpu.GetIOPL))()
#else /* PROD */
IMPORT	IU8	getIOPL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getMSW	IPT0();
#define	getMSW()	c_getMSW()
#else	/* CCPU */

#ifdef PROD
#define	getMSW()	(*(Cpu.GetMSW))()
#else /* PROD */
IMPORT	IU16	getMSW	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCR0	IPT0();
#define	getCR0()	c_getCR0()
#else	/* CCPU */

#ifdef PROD
#define	getCR0()	(*(Cpu.GetCR0))()
#else /* PROD */
IMPORT	IU32	getCR0	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCR2	IPT0();
#define	getCR2()	c_getCR2()
#else	/* CCPU */

#ifdef PROD
#define	getCR2()	(*(Cpu.GetCR2))()
#else /* PROD */
IMPORT	IU32	getCR2	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCR3	IPT0();
#define	getCR3()	c_getCR3()
#else	/* CCPU */

#ifdef PROD
#define	getCR3()	(*(Cpu.GetCR3))()
#else /* PROD */
IMPORT	IU32	getCR3	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getCF	IPT0();
#define	getCF()	c_getCF()
#else	/* CCPU */

#ifdef PROD
#define	getCF()	(*(Cpu.GetCF))()
#else /* PROD */
IMPORT	IBOOL	getCF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getPF	IPT0();
#define	getPF()	c_getPF()
#else	/* CCPU */

#ifdef PROD
#define	getPF()	(*(Cpu.GetPF))()
#else /* PROD */
IMPORT	IBOOL	getPF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getAF	IPT0();
#define	getAF()	c_getAF()
#else	/* CCPU */

#ifdef PROD
#define	getAF()	(*(Cpu.GetAF))()
#else /* PROD */
IMPORT	IBOOL	getAF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getZF	IPT0();
#define	getZF()	c_getZF()
#else	/* CCPU */

#ifdef PROD
#define	getZF()	(*(Cpu.GetZF))()
#else /* PROD */
IMPORT	IBOOL	getZF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getSF	IPT0();
#define	getSF()	c_getSF()
#else	/* CCPU */

#ifdef PROD
#define	getSF()	(*(Cpu.GetSF))()
#else /* PROD */
IMPORT	IBOOL	getSF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getTF	IPT0();
#define	getTF()	c_getTF()
#else	/* CCPU */

#ifdef PROD
#define	getTF()	(*(Cpu.GetTF))()
#else /* PROD */
IMPORT	IBOOL	getTF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getIF	IPT0();
#define	getIF()	c_getIF()
#else	/* CCPU */

#ifdef PROD
#define	getIF()	(*(Cpu.GetIF))()
#else /* PROD */
IMPORT	IBOOL	getIF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getDF	IPT0();
#define	getDF()	c_getDF()
#else	/* CCPU */

#ifdef PROD
#define	getDF()	(*(Cpu.GetDF))()
#else /* PROD */
IMPORT	IBOOL	getDF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getOF	IPT0();
#define	getOF()	c_getOF()
#else	/* CCPU */

#ifdef PROD
#define	getOF()	(*(Cpu.GetOF))()
#else /* PROD */
IMPORT	IBOOL	getOF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getNT	IPT0();
#define	getNT()	c_getNT()
#else	/* CCPU */

#ifdef PROD
#define	getNT()	(*(Cpu.GetNT))()
#else /* PROD */
IMPORT	IBOOL	getNT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getRF	IPT0();
#define	getRF()	c_getRF()
#else	/* CCPU */

#ifdef PROD
#define	getRF()	(*(Cpu.GetRF))()
#else /* PROD */
IMPORT	IBOOL	getRF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getVM	IPT0();
#define	getVM()	c_getVM()
#else	/* CCPU */

#ifdef PROD
#define	getVM()	(*(Cpu.GetVM))()
#else /* PROD */
IMPORT	IBOOL	getVM	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getAC	IPT0();
#define	getAC()	c_getAC()
#else	/* CCPU */

#ifdef PROD
#define	getAC()	(*(Cpu.GetAC))()
#else /* PROD */
IMPORT	IBOOL	getAC	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getPE	IPT0();
#define	getPE()	c_getPE()
#else	/* CCPU */

#ifdef PROD
#define	getPE()	(*(Cpu.GetPE))()
#else /* PROD */
IMPORT	IBOOL	getPE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getMP	IPT0();
#define	getMP()	c_getMP()
#else	/* CCPU */

#ifdef PROD
#define	getMP()	(*(Cpu.GetMP))()
#else /* PROD */
IMPORT	IBOOL	getMP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getEM	IPT0();
#define	getEM()	c_getEM()
#else	/* CCPU */

#ifdef PROD
#define	getEM()	(*(Cpu.GetEM))()
#else /* PROD */
IMPORT	IBOOL	getEM	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getTS	IPT0();
#define	getTS()	c_getTS()
#else	/* CCPU */

#ifdef PROD
#define	getTS()	(*(Cpu.GetTS))()
#else /* PROD */
IMPORT	IBOOL	getTS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getET	IPT0();
#define	getET()	c_getET()
#else	/* CCPU */

#ifdef PROD
#define	getET()	(*(Cpu.GetET))()
#else /* PROD */
IMPORT	IBOOL	getET	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getNE	IPT0();
#define	getNE()	c_getNE()
#else	/* CCPU */

#ifdef PROD
#define	getNE()	(*(Cpu.GetNE))()
#else /* PROD */
IMPORT	IBOOL	getNE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getWP	IPT0();
#define	getWP()	c_getWP()
#else	/* CCPU */

#ifdef PROD
#define	getWP()	(*(Cpu.GetWP))()
#else /* PROD */
IMPORT	IBOOL	getWP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getPG	IPT0();
#define	getPG()	c_getPG()
#else	/* CCPU */

#ifdef PROD
#define	getPG()	(*(Cpu.GetPG))()
#else /* PROD */
IMPORT	IBOOL	getPG	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getGDT_BASE	IPT0();
#define	getGDT_BASE()	c_getGDT_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getGDT_BASE()	(*(Cpu.GetGDT_BASE))()
#else /* PROD */
IMPORT	IU32	getGDT_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getGDT_LIMIT	IPT0();
#define	getGDT_LIMIT()	c_getGDT_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getGDT_LIMIT()	(*(Cpu.GetGDT_LIMIT))()
#else /* PROD */
IMPORT	IU16	getGDT_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getIDT_BASE	IPT0();
#define	getIDT_BASE()	c_getIDT_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getIDT_BASE()	(*(Cpu.GetIDT_BASE))()
#else /* PROD */
IMPORT	IU32	getIDT_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getIDT_LIMIT	IPT0();
#define	getIDT_LIMIT()	c_getIDT_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getIDT_LIMIT()	(*(Cpu.GetIDT_LIMIT))()
#else /* PROD */
IMPORT	IU16	getIDT_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getLDT_SELECTOR	IPT0();
#define	getLDT_SELECTOR()	c_getLDT_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getLDT_SELECTOR()	(*(Cpu.GetLDT_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getLDT_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getLDT_BASE	IPT0();
#define	getLDT_BASE()	c_getLDT_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getLDT_BASE()	(*(Cpu.GetLDT_BASE))()
#else /* PROD */
IMPORT	IU32	getLDT_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getLDT_LIMIT	IPT0();
#define	getLDT_LIMIT()	c_getLDT_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getLDT_LIMIT()	(*(Cpu.GetLDT_LIMIT))()
#else /* PROD */
IMPORT	IU32	getLDT_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getTR_SELECTOR	IPT0();
#define	getTR_SELECTOR()	c_getTR_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getTR_SELECTOR()	(*(Cpu.GetTR_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getTR_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getTR_BASE	IPT0();
#define	getTR_BASE()	c_getTR_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getTR_BASE()	(*(Cpu.GetTR_BASE))()
#else /* PROD */
IMPORT	IU32	getTR_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getTR_LIMIT	IPT0();
#define	getTR_LIMIT()	c_getTR_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getTR_LIMIT()	(*(Cpu.GetTR_LIMIT))()
#else /* PROD */
IMPORT	IU32	getTR_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getTR_AR	IPT0();
#define	getTR_AR()	c_getTR_AR()
#else	/* CCPU */

#ifdef PROD
#define	getTR_AR()	(*(Cpu.GetTR_AR))()
#else /* PROD */
IMPORT	IU16	getTR_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	host_get_q_calib_val	IPT0();
#define	host_get_q_calib_val	host_get_q_calib_val
#else	/* CCPU */

#ifdef PROD
#define	host_get_q_calib_val	(*(Cpu.GetJumpCalibrateVal))
#else /* PROD */
IMPORT	IUH	host_get_q_calib_val	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	host_get_jump_restart	IPT0();
#define	host_get_jump_restart	host_get_jump_restart
#else	/* CCPU */

#ifdef PROD
#define	host_get_jump_restart	(*(Cpu.GetJumpInitialVal))
#else /* PROD */
IMPORT	IUH	host_get_jump_restart	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	host_set_jump_restart	IPT1(IUH, initialVal);
#define	host_set_jump_restart(initialVal)	host_set_jump_restart(initialVal)
#else	/* CCPU */

#ifdef PROD
#define	host_set_jump_restart(initialVal)	(*(Cpu.SetJumpInitialVal))(initialVal)
#else /* PROD */
IMPORT	void	host_set_jump_restart	IPT1(IUH, initialVal);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	setEOIEnableAddr	IPT1(IU8 *, initialVal);
#define	setEOIEnableAddr(initialVal)	setEOIEnableAddr(initialVal)
#else	/* CCPU */

#ifdef PROD
#define	setEOIEnableAddr(initialVal)	(*(Cpu.SetEOIEnable))(initialVal)
#else /* PROD */
IMPORT	void	setEOIEnableAddr	IPT1(IU8 *, initialVal);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	setAddProfileDataPtr	IPT1(IHP, initialVal);
#define	setAddProfileDataPtr(initialVal)	setAddProfileDataPtr(initialVal)
#else	/* CCPU */

#ifdef PROD
#define	setAddProfileDataPtr(initialVal)	(*(Cpu.SetAddProfileData))(initialVal)
#else /* PROD */
IMPORT	void	setAddProfileDataPtr	IPT1(IHP, initialVal);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	setMaxProfileDataAddr	IPT1(IHP, initialVal);
#define	setMaxProfileDataAddr(initialVal)	setMaxProfileDataAddr(initialVal)
#else	/* CCPU */

#ifdef PROD
#define	setMaxProfileDataAddr(initialVal)	(*(Cpu.SetMaxProfileData))(initialVal)
#else /* PROD */
IMPORT	void	setMaxProfileDataAddr	IPT1(IHP, initialVal);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IHP	getAddProfileDataAddr	IPT0();
#define	getAddProfileDataAddr()	getAddProfileDataAddr()
#else	/* CCPU */

#ifdef PROD
#define	getAddProfileDataAddr()	(*(Cpu.GetAddProfileDataAddr))()
#else /* PROD */
IMPORT	IHP	getAddProfileDataAddr	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	PurgeLostIretHookLine	IPT2(IU16, lineNum, IU32, depth);
#define	PurgeLostIretHookLine(lineNum, depth)	PurgeLostIretHookLine(lineNum, depth)
#else	/* CCPU */

#ifdef PROD
#define	PurgeLostIretHookLine(lineNum, depth)	(*(Cpu.PurgeLostIretHookLine))(lineNum, depth)
#else /* PROD */
IMPORT	void	PurgeLostIretHookLine	IPT2(IU16, lineNum, IU32, depth);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	ActivityCheckAfterTimeSlice	IPT0();
#define	ActivityCheckAfterTimeSlice()	ActivityCheckAfterTimeSlice()
#else	/* CCPU */

#ifdef PROD
#define	ActivityCheckAfterTimeSlice()	(*(Cpu.ActivityCheckAfterTimeSlice))()
#else /* PROD */
IMPORT	void	ActivityCheckAfterTimeSlice	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	CheckCsSelectorAndEipForCallFarPatching	IPT3(IU16, csSel, IU32, eip, IU32 *, pCsBase);
#define	CheckCsSelectorAndEipForCallFarPatching(csSel, eip, pCsBase)	CheckCsSelectorAndEipForCallFarPatching(csSel, eip, pCsBase)
#else	/* CCPU */

#ifdef PROD
#define	CheckCsSelectorAndEipForCallFarPatching(csSel, eip, pCsBase)	(*(Cpu.CheckCsSelectorAndEipForCallFarPatching))(csSel, eip, pCsBase)
#else /* PROD */
IMPORT	IBOOL	CheckCsSelectorAndEipForCallFarPatching	IPT3(IU16, csSel, IU32, eip, IU32 *, pCsBase);
#endif /*PROD*/

#endif	/* CCPU */

typedef struct CpuStateREC * TypeCpuStateRECptr;
typedef struct ConstraintBitMapREC * TypeConstraintBitMapRECptr;
typedef struct EntryPointCacheREC * TypeEntryPointCacheRECptr;

struct	CpuPrivateVector	{
	IHP	(*GetSadInfoTable)	IPT0();
	IBOOL	(*SetGDT_BASE_LIMIT)	IPT2(IU32,	base, IU16,	limit);
	IBOOL	(*SetIDT_BASE_LIMIT)	IPT2(IU32,	base, IU16,	limit);
	IBOOL	(*SetLDT_BASE_LIMIT)	IPT2(IU32,	base, IU32,	limit);
	IBOOL	(*SetTR_BASE_LIMIT)	IPT2(IU32,	base, IU32,	limit);
	IBOOL	(*SetTR_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetCS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetSS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetDS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetES_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetFS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetGS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	void	(*SetCS_SELECTOR)	IPT1(IU16,	val);
	void	(*SetSS_SELECTOR)	IPT1(IU16,	val);
	void	(*SetDS_SELECTOR)	IPT1(IU16,	val);
	void	(*SetES_SELECTOR)	IPT1(IU16,	val);
	void	(*SetFS_SELECTOR)	IPT1(IU16,	val);
	void	(*SetGS_SELECTOR)	IPT1(IU16,	val);
	IU16	(*GetCS_SELECTOR)	IPT0();
	IU16	(*GetSS_SELECTOR)	IPT0();
	IU16	(*GetDS_SELECTOR)	IPT0();
	IU16	(*GetES_SELECTOR)	IPT0();
	IU16	(*GetFS_SELECTOR)	IPT0();
	IU16	(*GetGS_SELECTOR)	IPT0();
	IU32	(*GetCS_BASE)	IPT0();
	IU32	(*GetSS_BASE)	IPT0();
	IU32	(*GetDS_BASE)	IPT0();
	IU32	(*GetES_BASE)	IPT0();
	IU32	(*GetFS_BASE)	IPT0();
	IU32	(*GetGS_BASE)	IPT0();
	IU32	(*GetCS_LIMIT)	IPT0();
	IU32	(*GetSS_LIMIT)	IPT0();
	IU32	(*GetDS_LIMIT)	IPT0();
	IU32	(*GetES_LIMIT)	IPT0();
	IU32	(*GetFS_LIMIT)	IPT0();
	IU32	(*GetGS_LIMIT)	IPT0();
	IU16	(*GetCS_AR)	IPT0();
	IU16	(*GetSS_AR)	IPT0();
	IU16	(*GetDS_AR)	IPT0();
	IU16	(*GetES_AR)	IPT0();
	IU16	(*GetFS_AR)	IPT0();
	IU16	(*GetGS_AR)	IPT0();
	IUH	(*GetCPL)	IPT0();
	void	(*SetCPL)	IPT1(IUH,	prot);
	void	(*GetCpuState)	IPT1(TypeCpuStateRECptr,	state);
	void	(*SetCpuState)	IPT1(TypeCpuStateRECptr,	state);
	void	(*InitNanoCpu)	IPT1(IU32,	variety);
	void	(*PrepareBlocksToCompile)	IPT1(IU32,	variety);
	void	(*InitRdWrCacheAndCookies)	IPT1(IU32,	variety);
	void	(*ResetRdWrCacheAndCookies)	IPT1(IU32,	variety);
	void	(*SetRegConstraint)	IPT2(IU32,	regId, IU8,	constraintType);
	void	(*BpiCompileBPI)	IPT1(char *,	instructions);
	void	(*TrashIntelRegisters)	IPT0();
	void	(*FmDeleteAllStructures)	IPT1(IU32,	newCR0);
	void	(*SfForceVideoOff)	IPT0();
	void	(*SfRestoreVideoState)	IPT0();
	void	(*SfMarkPageAsParsed)	IPT1(IU32,	intelPpn);
	void	(*SfMarkPageAsNotParsed)	IPT1(IU32,	intelPpn);
	void	(*SfRemovePciMappings)	IPT0();
};

#ifdef	CCPU
IMPORT	IHP	c_getSadInfoTable	IPT0();
#define	getSadInfoTable()	c_getSadInfoTable()
#else	/* CCPU */

#ifdef PROD
#define	getSadInfoTable()	(*((*(Cpu.Private)).GetSadInfoTable))()
#else /* PROD */
IMPORT	IHP	getSadInfoTable	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setGDT_BASE_LIMIT	IPT2(IU32, base, IU16, limit);
#define	setGDT_BASE_LIMIT(base, limit)	c_setGDT_BASE_LIMIT(base, limit)
#else	/* CCPU */

#ifdef PROD
#define	setGDT_BASE_LIMIT(base, limit)	(*((*(Cpu.Private)).SetGDT_BASE_LIMIT))(base, limit)
#else /* PROD */
IMPORT	IBOOL	setGDT_BASE_LIMIT	IPT2(IU32, base, IU16, limit);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setIDT_BASE_LIMIT	IPT2(IU32, base, IU16, limit);
#define	setIDT_BASE_LIMIT(base, limit)	c_setIDT_BASE_LIMIT(base, limit)
#else	/* CCPU */

#ifdef PROD
#define	setIDT_BASE_LIMIT(base, limit)	(*((*(Cpu.Private)).SetIDT_BASE_LIMIT))(base, limit)
#else /* PROD */
IMPORT	IBOOL	setIDT_BASE_LIMIT	IPT2(IU32, base, IU16, limit);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setLDT_BASE_LIMIT	IPT2(IU32, base, IU32, limit);
#define	setLDT_BASE_LIMIT(base, limit)	c_setLDT_BASE_LIMIT(base, limit)
#else	/* CCPU */

#ifdef PROD
#define	setLDT_BASE_LIMIT(base, limit)	(*((*(Cpu.Private)).SetLDT_BASE_LIMIT))(base, limit)
#else /* PROD */
IMPORT	IBOOL	setLDT_BASE_LIMIT	IPT2(IU32, base, IU32, limit);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setTR_BASE_LIMIT	IPT2(IU32, base, IU32, limit);
#define	setTR_BASE_LIMIT(base, limit)	c_setTR_BASE_LIMIT(base, limit)
#else	/* CCPU */

#ifdef PROD
#define	setTR_BASE_LIMIT(base, limit)	(*((*(Cpu.Private)).SetTR_BASE_LIMIT))(base, limit)
#else /* PROD */
IMPORT	IBOOL	setTR_BASE_LIMIT	IPT2(IU32, base, IU32, limit);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setTR_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setTR_BASE_LIMIT_AR(base, limit, ar)	c_setTR_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setTR_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetTR_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setTR_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setCS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setCS_BASE_LIMIT_AR(base, limit, ar)	c_setCS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setCS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetCS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setCS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setSS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setSS_BASE_LIMIT_AR(base, limit, ar)	c_setSS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setSS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetSS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setSS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setDS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setDS_BASE_LIMIT_AR(base, limit, ar)	c_setDS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setDS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetDS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setDS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setES_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setES_BASE_LIMIT_AR(base, limit, ar)	c_setES_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setES_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetES_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setES_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setFS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setFS_BASE_LIMIT_AR(base, limit, ar)	c_setFS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setFS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetFS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setFS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setGS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setGS_BASE_LIMIT_AR(base, limit, ar)	c_setGS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setGS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetGS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setGS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCS_SELECTOR	IPT1(IU16, val);
#define	setCS_SELECTOR(val)	c_setCS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setCS_SELECTOR(val)	(*((*(Cpu.Private)).SetCS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setCS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSS_SELECTOR	IPT1(IU16, val);
#define	setSS_SELECTOR(val)	c_setSS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setSS_SELECTOR(val)	(*((*(Cpu.Private)).SetSS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setSS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDS_SELECTOR	IPT1(IU16, val);
#define	setDS_SELECTOR(val)	c_setDS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setDS_SELECTOR(val)	(*((*(Cpu.Private)).SetDS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setDS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setES_SELECTOR	IPT1(IU16, val);
#define	setES_SELECTOR(val)	c_setES_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setES_SELECTOR(val)	(*((*(Cpu.Private)).SetES_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setES_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setFS_SELECTOR	IPT1(IU16, val);
#define	setFS_SELECTOR(val)	c_setFS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setFS_SELECTOR(val)	(*((*(Cpu.Private)).SetFS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setFS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setGS_SELECTOR	IPT1(IU16, val);
#define	setGS_SELECTOR(val)	c_setGS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setGS_SELECTOR(val)	(*((*(Cpu.Private)).SetGS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setGS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getCS_SELECTOR	IPT0();
#define	getCS_SELECTOR()	c_getCS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getCS_SELECTOR()	(*((*(Cpu.Private)).GetCS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getCS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSS_SELECTOR	IPT0();
#define	getSS_SELECTOR()	c_getSS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getSS_SELECTOR()	(*((*(Cpu.Private)).GetSS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getSS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDS_SELECTOR	IPT0();
#define	getDS_SELECTOR()	c_getDS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getDS_SELECTOR()	(*((*(Cpu.Private)).GetDS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getDS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getES_SELECTOR	IPT0();
#define	getES_SELECTOR()	c_getES_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getES_SELECTOR()	(*((*(Cpu.Private)).GetES_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getES_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getFS_SELECTOR	IPT0();
#define	getFS_SELECTOR()	c_getFS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getFS_SELECTOR()	(*((*(Cpu.Private)).GetFS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getFS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getGS_SELECTOR	IPT0();
#define	getGS_SELECTOR()	c_getGS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getGS_SELECTOR()	(*((*(Cpu.Private)).GetGS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getGS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCS_BASE	IPT0();
#define	getCS_BASE()	c_getCS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getCS_BASE()	(*((*(Cpu.Private)).GetCS_BASE))()
#else /* PROD */
IMPORT	IU32	getCS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getSS_BASE	IPT0();
#define	getSS_BASE()	c_getSS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getSS_BASE()	(*((*(Cpu.Private)).GetSS_BASE))()
#else /* PROD */
IMPORT	IU32	getSS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getDS_BASE	IPT0();
#define	getDS_BASE()	c_getDS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getDS_BASE()	(*((*(Cpu.Private)).GetDS_BASE))()
#else /* PROD */
IMPORT	IU32	getDS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getES_BASE	IPT0();
#define	getES_BASE()	c_getES_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getES_BASE()	(*((*(Cpu.Private)).GetES_BASE))()
#else /* PROD */
IMPORT	IU32	getES_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getFS_BASE	IPT0();
#define	getFS_BASE()	c_getFS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getFS_BASE()	(*((*(Cpu.Private)).GetFS_BASE))()
#else /* PROD */
IMPORT	IU32	getFS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getGS_BASE	IPT0();
#define	getGS_BASE()	c_getGS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getGS_BASE()	(*((*(Cpu.Private)).GetGS_BASE))()
#else /* PROD */
IMPORT	IU32	getGS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCS_LIMIT	IPT0();
#define	getCS_LIMIT()	c_getCS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getCS_LIMIT()	(*((*(Cpu.Private)).GetCS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getCS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getSS_LIMIT	IPT0();
#define	getSS_LIMIT()	c_getSS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getSS_LIMIT()	(*((*(Cpu.Private)).GetSS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getSS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getDS_LIMIT	IPT0();
#define	getDS_LIMIT()	c_getDS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getDS_LIMIT()	(*((*(Cpu.Private)).GetDS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getDS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getES_LIMIT	IPT0();
#define	getES_LIMIT()	c_getES_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getES_LIMIT()	(*((*(Cpu.Private)).GetES_LIMIT))()
#else /* PROD */
IMPORT	IU32	getES_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getFS_LIMIT	IPT0();
#define	getFS_LIMIT()	c_getFS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getFS_LIMIT()	(*((*(Cpu.Private)).GetFS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getFS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getGS_LIMIT	IPT0();
#define	getGS_LIMIT()	c_getGS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getGS_LIMIT()	(*((*(Cpu.Private)).GetGS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getGS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getCS_AR	IPT0();
#define	getCS_AR()	c_getCS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getCS_AR()	(*((*(Cpu.Private)).GetCS_AR))()
#else /* PROD */
IMPORT	IU16	getCS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSS_AR	IPT0();
#define	getSS_AR()	c_getSS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getSS_AR()	(*((*(Cpu.Private)).GetSS_AR))()
#else /* PROD */
IMPORT	IU16	getSS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDS_AR	IPT0();
#define	getDS_AR()	c_getDS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getDS_AR()	(*((*(Cpu.Private)).GetDS_AR))()
#else /* PROD */
IMPORT	IU16	getDS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getES_AR	IPT0();
#define	getES_AR()	c_getES_AR()
#else	/* CCPU */

#ifdef PROD
#define	getES_AR()	(*((*(Cpu.Private)).GetES_AR))()
#else /* PROD */
IMPORT	IU16	getES_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getFS_AR	IPT0();
#define	getFS_AR()	c_getFS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getFS_AR()	(*((*(Cpu.Private)).GetFS_AR))()
#else /* PROD */
IMPORT	IU16	getFS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getGS_AR	IPT0();
#define	getGS_AR()	c_getGS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getGS_AR()	(*((*(Cpu.Private)).GetGS_AR))()
#else /* PROD */
IMPORT	IU16	getGS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_getCPL	IPT0();
#define	getCPL()	c_getCPL()
#else	/* CCPU */

#ifdef PROD
#define	getCPL()	(*((*(Cpu.Private)).GetCPL))()
#else /* PROD */
IMPORT	IUH	getCPL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCPL	IPT1(IUH, prot);
#define	setCPL(prot)	c_setCPL(prot)
#else	/* CCPU */

#ifdef PROD
#define	setCPL(prot)	(*((*(Cpu.Private)).SetCPL))(prot)
#else /* PROD */
IMPORT	void	setCPL	IPT1(IUH, prot);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_getCpuState	IPT1(TypeCpuStateRECptr, state);
#define	getCpuState(state)	c_getCpuState(state)
#else	/* CCPU */

#ifdef PROD
#define	getCpuState(state)	(*((*(Cpu.Private)).GetCpuState))(state)
#else /* PROD */
IMPORT	void	getCpuState	IPT1(TypeCpuStateRECptr, state);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCpuState	IPT1(TypeCpuStateRECptr, state);
#define	setCpuState(state)	c_setCpuState(state)
#else	/* CCPU */

#ifdef PROD
#define	setCpuState(state)	(*((*(Cpu.Private)).SetCpuState))(state)
#else /* PROD */
IMPORT	void	setCpuState	IPT1(TypeCpuStateRECptr, state);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_InitNanoCpu	IPT1(IU32, variety);
#define	initNanoCpu(variety)	c_InitNanoCpu(variety)
#else	/* CCPU */

#ifdef PROD
#define	initNanoCpu(variety)	(*((*(Cpu.Private)).InitNanoCpu))(variety)
#else /* PROD */
IMPORT	void	initNanoCpu	IPT1(IU32, variety);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_PrepareBlocksToCompile	IPT1(IU32, variety);
#define	prepareBlocksToCompile(variety)	c_PrepareBlocksToCompile(variety)
#else	/* CCPU */

#ifdef PROD
#define	prepareBlocksToCompile(variety)	(*((*(Cpu.Private)).PrepareBlocksToCompile))(variety)
#else /* PROD */
IMPORT	void	prepareBlocksToCompile	IPT1(IU32, variety);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_InitRdWrCacheAndCookies	IPT1(IU32, variety);
#define	initRdWrCacheAndCookies(variety)	c_InitRdWrCacheAndCookies(variety)
#else	/* CCPU */

#ifdef PROD
#define	initRdWrCacheAndCookies(variety)	(*((*(Cpu.Private)).InitRdWrCacheAndCookies))(variety)
#else /* PROD */
IMPORT	void	initRdWrCacheAndCookies	IPT1(IU32, variety);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_ResetRdWrCacheAndCookies	IPT1(IU32, variety);
#define	resetRdWrCacheAndCookies(variety)	c_ResetRdWrCacheAndCookies(variety)
#else	/* CCPU */

#ifdef PROD
#define	resetRdWrCacheAndCookies(variety)	(*((*(Cpu.Private)).ResetRdWrCacheAndCookies))(variety)
#else /* PROD */
IMPORT	void	resetRdWrCacheAndCookies	IPT1(IU32, variety);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setRegConstraint	IPT2(IU32, regId, IU8, constraintType);
#define	setRegConstraint(regId, constraintType)	c_setRegConstraint(regId, constraintType)
#else	/* CCPU */

#ifdef PROD
#define	setRegConstraint(regId, constraintType)	(*((*(Cpu.Private)).SetRegConstraint))(regId, constraintType)
#else /* PROD */
IMPORT	void	setRegConstraint	IPT2(IU32, regId, IU8, constraintType);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	BpiCompileBPI(instructions)	(*((*(Cpu.Private)).BpiCompileBPI))(instructions)
#else /* PROD */
IMPORT	void	BpiCompileBPI	IPT1(char *, instructions);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_trashIntelRegisters	IPT0();
#define	trashIntelregisters	c_trashIntelRegisters
#else	/* CCPU */

#ifdef PROD
#define	trashIntelregisters	(*((*(Cpu.Private)).TrashIntelRegisters))
#else /* PROD */
IMPORT	void	trashIntelregisters	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	FmDeleteAllStructures(newCR0)	(*((*(Cpu.Private)).FmDeleteAllStructures))(newCR0)
#else /* PROD */
IMPORT	void	FmDeleteAllStructures	IPT1(IU32, newCR0);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	sfForceVideoOff	(*((*(Cpu.Private)).SfForceVideoOff))
#else /* PROD */
IMPORT	void	sfForceVideoOff	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	sfRestoreVideoState	(*((*(Cpu.Private)).SfRestoreVideoState))
#else /* PROD */
IMPORT	void	sfRestoreVideoState	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	sfMarkPageAsParsed	(*((*(Cpu.Private)).SfMarkPageAsParsed))
#else /* PROD */
IMPORT	void	sfMarkPageAsParsed	IPT1(IU32, intelPpn);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	sfMarkPageAsNotParsed	(*((*(Cpu.Private)).SfMarkPageAsNotParsed))
#else /* PROD */
IMPORT	void	sfMarkPageAsNotParsed	IPT1(IU32, intelPpn);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	sfRemovePciMappings	(*((*(Cpu.Private)).SfRemovePciMappings))
#else /* PROD */
IMPORT	void	sfRemovePciMappings	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#endif	/* _CPU4GEN_H_ */
/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cwd.h ===
/* 
   cwd.h

   Define all CWD CPU functions.
 */

/*
   static char SccsID[]="@(#)cwd.h	1.5 09/01/94";
 */

IMPORT VOID CWD IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cwde.c ===
/*[

cwde.c

LOCAL CHAR SccsID[]="@(#)cwde.c	1.5 02/09/94";

CWDE CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <cwde.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
CWDE()
   {
   IU32 temp;

   if ( (temp = GET_AX()) & BIT15_MASK )   /* sign bit set? */
      temp |= 0xffff0000;
   SET_EAX(temp);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\cwde.h ===
/* 
   cwde.h

   CWDE CPU functions.
 */

/*
   static char SccsID[]="@(#)cwde.h	1.5 09/01/94";
 */

IMPORT VOID CWDE IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_addr.c ===
/*[

c_addr.c

LOCAL CHAR SccsID[]="@(#)c_addr.c	1.10 7/19/94";

Memory Addressing Support.
--------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>

#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_mem.h>
#include <ccpupig.h>
#include <fault.h>

/*
   Allowable memory addressing types.
 */

/* <addr size><mode><r/m> */
#define A_1600	  (IU8) 0 /* [BX + SI]       */
#define A_1601	  (IU8) 1 /* [BX + DI]       */
#define A_1602	  (IU8) 2 /* [BP + SI]       */
#define A_1603	  (IU8) 3 /* [BP + DI]       */
#define A_1604	  (IU8) 4 /* [SI]            */
#define A_1605	  (IU8) 5 /* [DI]            */
#define A_1606	  (IU8) 6 /* [d16]           */
#define A_1607	  (IU8) 7 /* [BX]            */

#define A_1610	  (IU8) 8 /* [BX + SI + d8]  */
#define A_1611	  (IU8) 9 /* [BX + DI + d8]  */
#define A_1612	  (IU8)10 /* [BP + SI + d8]  */
#define A_1613	  (IU8)11 /* [BP + DI + d8]  */
#define A_1614	  (IU8)12 /* [SI + d8]       */
#define A_1615	  (IU8)13 /* [DI + d8]       */
#define A_1616	  (IU8)14 /* [BP + d8]       */
#define A_1617	  (IU8)15 /* [BX + d8]       */

#define A_1620	  (IU8)16 /* [BX + SI + d16] */
#define A_1621	  (IU8)17 /* [BX + DI + d16] */
#define A_1622	  (IU8)18 /* [BP + SI + d16] */
#define A_1623	  (IU8)19 /* [BP + DI + d16] */
#define A_1624	  (IU8)20 /* [SI + d16]      */
#define A_1625	  (IU8)21 /* [DI + d16]      */
#define A_1626	  (IU8)22 /* [BP + d16]      */
#define A_1627	  (IU8)23 /* [BX + d16]      */

/* <addr size><mode><r/m> */
#define A_3200	  (IU8)24 /* [EAX]       */
#define A_3201	  (IU8)25 /* [ECX]       */
#define A_3202	  (IU8)26 /* [EDX]       */
#define A_3203	  (IU8)27 /* [EBX]       */
#define A_3205	  (IU8)28 /* [d32]       */
#define A_3206	  (IU8)29 /* [ESI]       */
#define A_3207	  (IU8)30 /* [EDI]       */

#define A_3210	  (IU8)31 /* [EAX + d8]  */
#define A_3211	  (IU8)32 /* [ECX + d8]  */
#define A_3212	  (IU8)33 /* [EDX + d8]  */
#define A_3213	  (IU8)34 /* [EBX + d8]  */
#define A_3215	  (IU8)35 /* [EBP + d8]  */
#define A_3216	  (IU8)36 /* [ESI + d8]  */
#define A_3217	  (IU8)37 /* [EDI + d8]  */

#define A_3220	  (IU8)38 /* [EAX + d32] */
#define A_3221	  (IU8)39 /* [ECX + d32] */
#define A_3222	  (IU8)40 /* [EDX + d32] */
#define A_3223	  (IU8)41 /* [EBX + d32] */
#define A_3225	  (IU8)42 /* [EBP + d32] */
#define A_3226	  (IU8)43 /* [ESI + d32] */
#define A_3227	  (IU8)44 /* [EDI + d32] */

/* <addr size><S=SIB form><mode><base> */
#define A_32S00	  (IU8)45 /* [EAX + si]       */
#define A_32S01	  (IU8)46 /* [ECX + si]       */
#define A_32S02	  (IU8)47 /* [EDX + si]       */
#define A_32S03	  (IU8)48 /* [EBX + si]       */
#define A_32S04	  (IU8)49 /* [ESP + si]       */
#define A_32S05	  (IU8)50 /* [d32 + si]       */
#define A_32S06	  (IU8)51 /* [ESI + si]       */
#define A_32S07	  (IU8)52 /* [EDI + si]       */

#define A_32S10	  (IU8)53 /* [EAX + si + d8]  */
#define A_32S11	  (IU8)54 /* [ECX + si + d8]  */
#define A_32S12	  (IU8)55 /* [EDX + si + d8]  */
#define A_32S13	  (IU8)56 /* [EBX + si + d8]  */
#define A_32S14	  (IU8)57 /* [ESP + si + d8]  */
#define A_32S15	  (IU8)58 /* [EBP + si + d8]  */
#define A_32S16	  (IU8)59 /* [ESI + si + d8]  */
#define A_32S17	  (IU8)60 /* [EDI + si + d8]  */

#define A_32S20	  (IU8)61 /* [EAX + si + d32] */
#define A_32S21	  (IU8)62 /* [ECX + si + d32] */
#define A_32S22	  (IU8)63 /* [EDX + si + d32] */
#define A_32S23	  (IU8)64 /* [EBX + si + d32] */
#define A_32S24	  (IU8)65 /* [ESP + si + d32] */
#define A_32S25	  (IU8)66 /* [EBP + si + d32] */
#define A_32S26	  (IU8)67 /* [ESI + si + d32] */
#define A_32S27	  (IU8)68 /* [EDI + si + d32] */

/* Table fillers - never actually referenced */
#define A_3204	(IU8)0
#define A_3214	(IU8)0
#define A_3224	(IU8)0

/*                 [addr_sz][mode][r/m] */
/* addr_sz 0 = 16-bit                   */
/* addr_sz 1 = 32-bit                   */
/* addr_sz 2 = 32-bit (+SIB)            */
LOCAL IU8 addr_maintype[3]   [3]  [8] =
   {
   { {A_1600, A_1601, A_1602, A_1603, A_1604, A_1605, A_1606, A_1607},
     {A_1610, A_1611, A_1612, A_1613, A_1614, A_1615, A_1616, A_1617},
     {A_1620, A_1621, A_1622, A_1623, A_1624, A_1625, A_1626, A_1627} },

   { {A_3200, A_3201, A_3202, A_3203, A_3204, A_3205, A_3206, A_3207},
     {A_3210, A_3211, A_3212, A_3213, A_3214, A_3215, A_3216, A_3217},
     {A_3220, A_3221, A_3222, A_3223, A_3224, A_3225, A_3226, A_3227} },
   
   { {A_32S00, A_32S01, A_32S02, A_32S03, A_32S04, A_32S05, A_32S06, A_32S07},
     {A_32S10, A_32S11, A_32S12, A_32S13, A_32S14, A_32S15, A_32S16, A_32S17},
     {A_32S20, A_32S21, A_32S22, A_32S23, A_32S24, A_32S25, A_32S26, A_32S27} }
   };

/*
   Allowable memory addressing sub types.
 */

/* <ss><index> */
#define A_SINO (IU8) 0 /* No SIB byte */
#define A_SI00 (IU8) 1 /* EAX       */
#define A_SI01 (IU8) 2 /* ECX       */
#define A_SI02 (IU8) 3 /* EDX       */
#define A_SI03 (IU8) 4 /* EBX       */
#define A_SI04 (IU8) 5 /* none      */
#define A_SI05 (IU8) 6 /* EBP       */
#define A_SI06 (IU8) 7 /* ESI       */
#define A_SI07 (IU8) 8 /* EDI       */

#define A_SI10 (IU8) 9 /* EAX x 2   */
#define A_SI11 (IU8)10 /* ECX x 2   */
#define A_SI12 (IU8)11 /* EDX x 2   */
#define A_SI13 (IU8)12 /* EBX x 2   */
#define A_SI14 (IU8)13 /* undefined */
#define A_SI15 (IU8)14 /* EBP x 2   */
#define A_SI16 (IU8)15 /* ESI x 2   */
#define A_SI17 (IU8)16 /* EDI x 2   */

#define A_SI20 (IU8)17 /* EAX x 4   */
#define A_SI21 (IU8)18 /* ECX x 4   */
#define A_SI22 (IU8)19 /* EDX x 4   */
#define A_SI23 (IU8)20 /* EBX x 4   */
#define A_SI24 (IU8)21 /* undefined */
#define A_SI25 (IU8)22 /* EBP x 4   */
#define A_SI26 (IU8)23 /* ESI x 4   */
#define A_SI27 (IU8)24 /* EDI x 4   */

#define A_SI30 (IU8)25 /* EAX x 8   */
#define A_SI31 (IU8)26 /* ECX x 8   */
#define A_SI32 (IU8)27 /* EDX x 8   */
#define A_SI33 (IU8)28 /* EBX x 8   */
#define A_SI34 (IU8)29 /* undefined */
#define A_SI35 (IU8)30 /* EBP x 8   */
#define A_SI36 (IU8)31 /* ESI x 8   */
#define A_SI37 (IU8)32 /* EDI x 8   */

/*                     [ss][index] */
LOCAL IU8 addr_subtype[4]    [8] =
   {
   {A_SI00, A_SI01, A_SI02, A_SI03, A_SI04, A_SI05, A_SI06, A_SI07}, 
   {A_SI10, A_SI11, A_SI12, A_SI13, A_SI14, A_SI15, A_SI16, A_SI17}, 
   {A_SI20, A_SI21, A_SI22, A_SI23, A_SI24, A_SI25, A_SI26, A_SI27}, 
   {A_SI30, A_SI31, A_SI32, A_SI33, A_SI34, A_SI35, A_SI36, A_SI37}
   };

/*
   Displacement information.
 */
#define D_NO	(IU8)0
#define D_S8	(IU8)1
#define D_S16	(IU8)2
#define D_Z16	(IU8)3
#define D_32    (IU8)4

/*             [addr_sz][mode][r/m] */
LOCAL IU8 addr_disp[2]   [3]  [8] =
   {
   { {D_NO , D_NO , D_NO , D_NO , D_NO , D_NO , D_Z16, D_NO },
     {D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 },
     {D_S16, D_S16, D_S16, D_S16, D_S16, D_S16, D_S16, D_S16} },

   { {D_NO , D_NO , D_NO , D_NO , D_NO , D_32 , D_NO , D_NO },
     {D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 },
     {D_32 , D_32 , D_32 , D_32 , D_32 , D_32 , D_32 , D_32 } }
   };

/*
   Default Segment information.
 */
/*                    [addr_sz][mode][r/m] */
LOCAL IU8 addr_default_seg[2]   [3]  [8] =
   {
   { {DS_REG, DS_REG, SS_REG, SS_REG, DS_REG, DS_REG, DS_REG, DS_REG},
     {DS_REG, DS_REG, SS_REG, SS_REG, DS_REG, DS_REG, SS_REG, DS_REG},
     {DS_REG, DS_REG, SS_REG, SS_REG, DS_REG, DS_REG, SS_REG, DS_REG} },

   { {DS_REG, DS_REG, DS_REG, DS_REG, SS_REG, DS_REG, DS_REG, DS_REG},
     {DS_REG, DS_REG, DS_REG, DS_REG, SS_REG, SS_REG, DS_REG, DS_REG},
     {DS_REG, DS_REG, DS_REG, DS_REG, SS_REG, SS_REG, DS_REG, DS_REG} }
   };

/*

   SIB
   ---

    7 6 5 4 3 2 1 0
   =================
   |ss |index|base |
   =================

 */

#define GET_SS(x)    ((x) >> 6 & 0x3)
#define GET_INDEX(x) ((x) >> 3 & 0x7)
#define GET_BASE(x)  ((x) & 0x7)


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Perform arithmetic for addressing functions.                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
address_add
                          
IFN2(
	IU32, offset,
	IS32, delta
    )


   {
   IU32 retval;

   if ( GET_ADDRESS_SIZE() == USE32 )
      retval = offset + delta;
   else
      retval = offset + delta & WORD_MASK;

   return retval;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Decode memory address.                                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
d_mem
       			    			    	    			    			                              
IFN5(
	IU8, modRM,	/* (I ) current mode R/M byte */
	IU8 **, p,	/* (IO) Intel opcode stream */
	IU8, segment_override,	/* (I ) current segment_override */
	ISM32 *, seg,	/* ( O) Segment register index */
	IU32 *, off	/* ( O) Memory offset */
    )

 /* ANSI */
   {
   IU8 mode;		/* Working copy of 'mode' field */
   IU8 r_m;		/* Working copy of 'R/M' field */
   IU32 disp;		/* Working copy of displacement */
   IU32 mem_off;	/* Working copy of memory offset */
   IU8 identifier;	/* Memory addressing type */
   IU8 sub_id;        /* Memory addressing sub type */

   mode = GET_MODE(modRM);
   r_m  = GET_R_M(modRM);

   /*
      DECODE IT.
    */

   /* check for presence of SIB byte */
   if ( r_m == 4 && GET_ADDRESS_SIZE() == USE32 )
      {
      /* process SIB byte */
      modRM = GET_INST_BYTE(*p);   /* get SIB byte */

      /* subvert the original r_m value with the base value,
	 then addressing mode, displacements and default
	 segments all fall out in the wash */
      r_m = GET_BASE(modRM);

      /* determine decoded type and sub type */
      identifier = addr_maintype[2][mode][r_m];   /* 2 = 32-bit addr + SIB */
      sub_id = addr_subtype[GET_SS(modRM)][GET_INDEX(modRM)];
      }
   else
      {
      /* no SIB byte */
      identifier = addr_maintype[GET_ADDRESS_SIZE()][mode][r_m];
      sub_id = A_SINO;
      }

   /* encode displacement */
   switch ( addr_disp[GET_ADDRESS_SIZE()][mode][r_m] )
      {
   case D_NO:    /* No displacement */
      disp = 0;
      break;

   case D_S8:    /* Sign extend Intel byte */
      disp = GET_INST_BYTE(*p);
      if ( disp & BIT7_MASK )
	 disp |= ~BYTE_MASK;
      break;

   case D_S16:   /* Sign extend Intel word */
      disp = GET_INST_BYTE(*p);
      disp |= (IU32)GET_INST_BYTE(*p) << 8;
      if ( disp & BIT15_MASK )
	 disp |= ~WORD_MASK;
      break;

   case D_Z16:   /* Zero extend Intel word */
      disp = GET_INST_BYTE(*p);
      disp |= (IU32)GET_INST_BYTE(*p) << 8;
      break;
   
   case D_32:   /* Intel double word */
      disp = GET_INST_BYTE(*p);
      disp |= (IU32)GET_INST_BYTE(*p) << 8;
      disp |= (IU32)GET_INST_BYTE(*p) << 16;
      disp |= (IU32)GET_INST_BYTE(*p) << 24;
      break;
      }

   /*
      DO IT.
    */

   /* encode segment register */
   if ( segment_override == SEG_CLR )
      segment_override = addr_default_seg[GET_ADDRESS_SIZE()][mode][r_m];
   *seg = segment_override;

   /* caclculate offset */
   switch ( identifier )
      {
   case A_1600: case A_1610: case A_1620:
      mem_off = GET_BX() + GET_SI() + disp & WORD_MASK;
      break;

   case A_1601: case A_1611: case A_1621:
      mem_off = GET_BX() + GET_DI() + disp & WORD_MASK;
      break;

   case A_1602: case A_1612: case A_1622:
      mem_off = GET_BP() + GET_SI() + disp & WORD_MASK;
      break;

   case A_1603: case A_1613: case A_1623:
      mem_off = GET_BP() + GET_DI() + disp & WORD_MASK;
      break;

   case A_1604: case A_1614: case A_1624:
      mem_off = GET_SI() + disp & WORD_MASK;
      break;

   case A_1605: case A_1615: case A_1625:
      mem_off = GET_DI() + disp & WORD_MASK;
      break;

   case A_1606:
      mem_off = disp & WORD_MASK;
      break;

    case A_1616: case A_1626:
      mem_off = GET_BP() + disp & WORD_MASK;
      break;

   case A_1607: case A_1617: case A_1627:
      mem_off = GET_BX() + disp & WORD_MASK;
      break;
   
   case A_3200:  case A_3210:  case A_3220:
   case A_32S00: case A_32S10: case A_32S20:
      mem_off = GET_EAX() + disp;
      break;

   case A_3201:  case A_3211:  case A_3221:
   case A_32S01: case A_32S11: case A_32S21:
      mem_off = GET_ECX() + disp;
      break;

   case A_3202:  case A_3212:  case A_3222:
   case A_32S02: case A_32S12: case A_32S22:
      mem_off = GET_EDX() + disp;
      break;

   case A_3203:  case A_3213:  case A_3223:
   case A_32S03: case A_32S13: case A_32S23:
      mem_off = GET_EBX() + disp;
      break;

   case A_32S04: case A_32S14: case A_32S24:
      mem_off = GET_ESP() + GET_POP_DISP() + disp;
      break;

   case A_3205:
   case A_32S05:
      mem_off = disp;
      break;

   case A_3215:  case A_3225:
   case A_32S15: case A_32S25:
      mem_off = GET_EBP() + disp;
      break;

   case A_3206:  case A_3216:  case A_3226:
   case A_32S06: case A_32S16: case A_32S26:
      mem_off = GET_ESI() + disp;
      break;

   case A_3207:  case A_3217:  case A_3227:
   case A_32S07: case A_32S17: case A_32S27:
      mem_off = GET_EDI() + disp;
      break;
      } /* end switch */

   /* add 'si', scale and index into offset */
   switch ( sub_id )
      {
   case A_SINO: /* No SIB byte */         break;

   case A_SI00: mem_off += GET_EAX();      break;
   case A_SI01: mem_off += GET_ECX();      break;
   case A_SI02: mem_off += GET_EDX();      break;
   case A_SI03: mem_off += GET_EBX();      break;
   case A_SI04:                           break;
   case A_SI05: mem_off += GET_EBP();      break;
   case A_SI06: mem_off += GET_ESI();      break;
   case A_SI07: mem_off += GET_EDI();      break;

   case A_SI10: mem_off += GET_EAX() << 1; break;
   case A_SI11: mem_off += GET_ECX() << 1; break;
   case A_SI12: mem_off += GET_EDX() << 1; break;
   case A_SI13: mem_off += GET_EBX() << 1; break;
   case A_SI14:                           break;
   case A_SI15: mem_off += GET_EBP() << 1; break;
   case A_SI16: mem_off += GET_ESI() << 1; break;
   case A_SI17: mem_off += GET_EDI() << 1; break;

   case A_SI20: mem_off += GET_EAX() << 2; break;
   case A_SI21: mem_off += GET_ECX() << 2; break;
   case A_SI22: mem_off += GET_EDX() << 2; break;
   case A_SI23: mem_off += GET_EBX() << 2; break;
   case A_SI24:                           break;
   case A_SI25: mem_off += GET_EBP() << 2; break;
   case A_SI26: mem_off += GET_ESI() << 2; break;
   case A_SI27: mem_off += GET_EDI() << 2; break;

   case A_SI30: mem_off += GET_EAX() << 3; break;
   case A_SI31: mem_off += GET_ECX() << 3; break;
   case A_SI32: mem_off += GET_EDX() << 3; break;
   case A_SI33: mem_off += GET_EBX() << 3; break;
   case A_SI34:                           break;
   case A_SI35: mem_off += GET_EBP() << 3; break;
   case A_SI36: mem_off += GET_ESI() << 3; break;
   case A_SI37: mem_off += GET_EDI() << 3; break;
      } /* end switch */

   *off = mem_off;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Perform limit checking.                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
limit_check
       		    	    	    		                         
IFN4(
	ISM32, index,	/* (I) segment register identifier */
	IU32, offset,	/* (I) offset for first (lowest memory)
			   data item */
	ISM32, nr_items,	/* (I) number of items to be accessed */
	IUM8, op_sz	/* (I) number of bytes in each item */
    )


   {
   /*
      As documented by Intel the basic limit check failures are:

	 IU8:-  address > limit
	 IU16:-  address > (limit-1)
	 IU32:- address > (limit-3)
      
      We (for efficiency) extend the algorithm to handle multiple
      operands with one check:- address > (limit-(total_nr_bytes-1)).

      Further we must account for the different interpretation of
      limit in expand down segments. This leads to two algorithms.

      EXPAND UP:-

	 Check address > (limit-(total_nr_bytes-1)) with two caveats.
	 One, beware that the subtraction from limit may underflow
	 (eg a IU32 accessed in a 3 byte segment). Two, beware that
	 wraparound can occur if each individual operand is stored
	 contiguously and we have a 'full sized' segment.

      EXPAND DOWN:-

	 Check address <= limit ||
	       address > (segment_top-(total_nr_bytes-1)).
	 Because total_nr_bytes is always a relatively small number
	 the subtraction never underflows. And as you can never have
	 a full size expand down segment you can never have wraparound.

      Additionally although 32-bit addressing mode may be used in Real
      Mode, all offsets must fit in the range 0 - 0xffff.
    */

   /*
      Note a quick summary of inclusive valid bounds is:-

      =================================================
      | E | G | X |    lower bound    | upper bound   |
      =================================================
      | 0 | 0 | 0 |         0         |     limit     |
      | 0 | 0 | 1 |         0         |     limit     |
      | 0 | 1 | 0 |         0         | limit<<12|fff |
      | 0 | 1 | 1 |         0         | limit<<12|fff |
      | 1 | 0 | 0 |      limit+1      |      ffff     |
      | 1 | 0 | 1 |      limit+1      |    ffffffff   |
      | 1 | 1 | 0 | (limit<<12|fff)+1 |      ffff     |
      | 1 | 1 | 1 | (limit<<12|fff)+1 |    ffffffff   |
      =================================================
    */

   /*
      We "pre-process" the G-bit when the segment is first loaded
      and store the limit to reflect the G-bit as required. Hence we
      don't need to refer to the G-bit here.
    */

   ISM32 range;
   BOOL bad_limit = FALSE;
   IU32 segment_top;

   range = nr_items * op_sz - 1;

   if ( GET_SR_AR_E(index) )
      {
      /* expand down */
      if ( GET_SR_AR_X(index) == USE32 )
	 segment_top =  0xffffffff;
      else
	 segment_top =  0xffff;

      if ( offset <= GET_SR_LIMIT(index) ||	/* out of range */
	   offset > segment_top - range )	/* segment too small */
	 {
	 bad_limit = TRUE;
	 }
      }
   else
      {
      /* expand up */
      segment_top = GET_SR_LIMIT(index);

      if ( offset > segment_top ||	/* out of range */
	   segment_top < range )	/* segment too small */
	 {
	 bad_limit = TRUE;
	 }
      else
	 {
	 if ( offset > segment_top - range )
	    {
	    /* data extends past end of segment */
	    if ( offset % op_sz != 0 )
	       {
	       /* Data mis-aligned, so basic operand won't be
		  contiguously stored */
	       bad_limit = TRUE;
	       }
	    else
	       {
	       /* If 'full sized' segment wraparound can occur */
	       if ( GET_SR_AR_X(index) == USE16 )
		  {
		  if ( GET_SR_LIMIT(index) != 0xffff )
		     bad_limit = TRUE;
		  }
	       else   /* USE32 */
		  {
		  if ( GET_SR_LIMIT(index) != 0xffffffff )
		     bad_limit = TRUE;
		  }
	       }
	    }
	 }
      }



#ifndef	TAKE_REAL_MODE_LIMIT_FAULT

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

   if ( GET_PE() == 0 || GET_VM() == 1 )
      return;
#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */

   if ( bad_limit )
      {
      if ( index == SS_REG )
	 {
	 SF((IU16)0, FAULT_LIMITCHK_SEG_LIMIT);
	 }
      else
	 {
	 GP((IU16)0, FAULT_LIMITCHK_SEG_LIMIT);
	 }
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_addr.h ===
/*[

c_addr.h

LOCAL CHAR SccsID[]="@(#)c_addr.h	1.4 02/09/94";

Memory Addressing Support.
--------------------------

]*/

IMPORT IU32 address_add
           
IPT2(
	IU32, offset,
	IS32, delta

   );

IMPORT VOID d_mem
                       
IPT5(
	IU8, modRM,
	IU8 **, p,
	IU8, segment_override,
	ISM32 *, seg,
	IU32 *, off

   );

IMPORT VOID limit_check
                   
IPT4(
	ISM32, indx,
	IU32, offset,
	ISM32, nr_items,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_debug.h ===
/*[

c_debug.h

Debugging Register and Breakpoint Support
-----------------------------------------

LOCAL CHAR SccsID[]="@(#)c_debug.h	1.5 09/01/94";

]*/


/*
   Debug breakpoint status variables.
 */
IMPORT IU32 nr_inst_break;
IMPORT IU32 nr_data_break;

/*
   Debug attributes.
 */
#define D_R 0   /* memory read */
#define D_W 1   /* memory write */

#define D_BYTE  0
#define D_WORD  1
#define D_DWORD 3

IMPORT VOID setup_breakpoints IPT0();

IMPORT VOID check_for_data_exception
               
IPT3(
	IU32, la,
	ISM32, attr,
	ISM32, size

   );

IMPORT VOID check_for_inst_exception
       
IPT1(
	IU32, la

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_div64.c ===
/*[

c_div64.c

LOCAL CHAR SccsID[]="@(#)c_div64.c	1.5 02/09/94";

64-bit Divide Functions.
------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <c_div64.h>
#include <c_neg64.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Do 64bit = 64bit / 32bit Divide (Signed).                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
div64
       		    		        		                         
IFN4(
	IS32 *, hr,	/* High 32 bits of dividend/quotient */
	IS32 *, lr,	/* Low 32 bits of dividend/quotient */
	IS32, divisor,
	IS32 *, rem	/* Remainder */
    )


   {
   if ( *hr & BIT31_MASK )
      {
      if ( divisor & BIT31_MASK )
	 {
	 /* Negative Dividend :: Negative Divisor */
	 neg64(hr, lr);
	 divisor = -divisor;
	 divu64((IU32 *)hr, (IU32 *)lr, (IU32)divisor, (IU32 *)rem);
	 *rem = -*rem;
	 }
      else
	 {
	 /* Negative Dividend :: Positive Divisor */
	 neg64(hr, lr);
	 divu64((IU32 *)hr, (IU32 *)lr, (IU32)divisor, (IU32 *)rem);
	 neg64(hr, lr);
	 *rem = -*rem;
	 }
      }
   else
      {
      if ( divisor & BIT31_MASK )
	 {
	 /* Positive Dividend :: Negative Divisor */
	 divisor = -divisor;
	 divu64((IU32 *)hr, (IU32 *)lr, (IU32)divisor, (IU32 *)rem);
	 neg64(hr, lr);
	 }
      else
	 {
	 /* Positive Dividend :: Positive Divisor */
	 divu64((IU32 *)hr, (IU32 *)lr, (IU32)divisor, (IU32 *)rem);
	 }
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Do 64bit = 64bit / 32bit Divide (Unsigned).                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
divu64
       		    		        		                         
IFN4(
	IU32 *, hr,	/* High 32 bits of dividend/quotient */
	IU32 *, lr,	/* Low 32 bits of dividend/quotient */
	IU32, divisor,
	IU32 *, rem	/* Remainder */
    )


   {
   ISM32 count;
   IU32 hd;   /* High 32 bits of dividend/quotient */
   IU32 ld;   /* Low 32 bits of dividend/quotient */
   IU32 par_div;   /* partial dividend */
   IU32 carry1;
   IU32 carry2;
   IU32 carry3;

   hd = *hr;	/* Get local copies */
   ld = *lr;
   count = 64;	/* Initialise */
   par_div = 0;

   while ( count != 0 )
      {
      /* shift <par_div:dividend> left.
	    We have to watch out for carries from
	       ld<bit31> to hd<bit0>      (carry1) and
	       hd<bit31> to par_div<bit0> (carry2) and
	       par_div<bit31> to 'carry'  (carry3).
       */
      carry1 = carry2 = carry3 = 0;
      if ( ld & BIT31_MASK )
	 carry1 = 1;
      if ( hd & BIT31_MASK )
	 carry2 = 1;
      if ( par_div & BIT31_MASK )
	 carry3 = 1;
      ld = ld << 1;
      hd = hd << 1 | carry1;
      par_div = par_div << 1 | carry2;

      /* check if divisor 'goes into' partial dividend */
      if ( carry3 || divisor <= par_div )
	 {
	 /* Yes it does */
	 par_div = par_div - divisor;
	 ld = ld | 1;   /* output a 1 bit */
	 }
      count--;
      }

   *rem = par_div;	/* Return results */
   *hr = hd;
   *lr = ld;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_div64.h ===
/* 
   c_div64.h

   Define all 64-bit Divide Functions.
 */

/*
   static char SccsID[]="@(#)c_div64.h	1.4 02/09/94";
 */

IMPORT VOID divu64
                   
IPT4(
	IU32 *, hr,
	IU32 *, lr,
	IU32, divisor,
	IU32 *, rem

   );

IMPORT VOID div64
                   
IPT4(
	IS32 *, hr,
	IS32 *, lr,
	IS32, divisor,
	IS32 *, rem

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_bsic.c ===
/*[

c_bsic.c

LOCAL CHAR SccsID[]="@(#)c_bsic.c	1.7 09/20/94";

Basic Protected Mode Support and Flag Support.
----------------------------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>

#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <c_page.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Determine 'super' type from access rights.                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL ISM32
descriptor_super_type
       	          
IFN1(
	IU16, AR	/* (I) access rights */
    )


   {
   ISM32 super;

   switch ( super = GET_AR_SUPER(AR) )
      {
   case 0x0: case 0x8: case 0xa: case 0xd:
      /* We have just one bad case */
      return INVALID;

   
   case 0x1: case 0x2: case 0x3:
   case 0x4: case 0x5: case 0x6: case 0x7:
   case 0x9: case 0xb: case 0xc: case 0xe: case 0xf:
      /* system/control segments have one to one mapping */
      return super;
   
   case 0x10: case 0x11: case 0x12: case 0x13:
   case 0x14: case 0x15: case 0x16: case 0x17:
   case 0x18: case 0x19: case 0x1a: case 0x1b:
   case 0x1c: case 0x1d: case 0x1e: case 0x1f:
      /* data/code segments map as if accessed */
      return super | ACCESSED;
      }

   /* We 'know' we never get here, but the C compiler doesn't */
   return 0;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set OF flag after multiple shift or rotate instruction.            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
do_multiple_shiftrot_of
       	          
IFN1(
	ISM32, new_of	/* (I) overflow that would be written by last bit
		       shift or rotate */
    )


   {
	SAVED	IBOOL	cold = TRUE;
	SAVED	IBOOL	shiftrot_of_undef = FALSE;

	if( cold )
	{
		/*
		 * Determine whether to have the multiple shift/rotates
		 * OF undefined or calculated by the count == 1 algorithm.
		 * The default is the count == 1 option.
		 */

		shiftrot_of_undef = ( host_getenv( "SHIFTROT_OF_UNDEF" ) != NULL );
		cold = FALSE;
	}
   /*
      There are three possible actions:-

      1) Set OF based on the last bit shift or rotate.

      2) Leave OF unchanged

      3) Set OF to a specific undefined value.
    */

	if( shiftrot_of_undef )
	{
		/* Set undefined flag(s) */
		SET_OF(UNDEFINED_FLAG);
	}
	else
	{
		/* Just like count of one case */
		SET_OF(new_of);
	}
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Retrieve Intel EFLAGS register value                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
c_getEFLAGS IFN0()
   {
   IU32 flags;

   flags = getFLAGS();   /* get lower word */

   flags = flags | GET_VM() << 17 | GET_RF() << 16;

#ifdef SPC486
   flags = flags | GET_AC() << 18;
#endif /* SPC486 */

   return flags;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Retrieve Intel FLAGS register value                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
getFLAGS()
   {
   IU32 flags;

   flags = GET_NT() << 14 | GET_IOPL() << 12 | GET_OF() << 11 |
	   GET_DF() << 10 | GET_IF()   <<  9 | GET_TF() <<  8 |
	   GET_SF() <<  7 | GET_ZF()   <<  6 | GET_AF() <<  4 |
	   GET_PF() <<  2 | GET_CF()         | 0x2;

   return flags;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Read a descriptor table at given linear address.                   */
/* Take #PF if descriptor not in linear address space.                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
read_descriptor_linear
       	    	               
IFN2(
	IU32, addr,	/* (I) Linear address of descriptor */
	CPU_DESCR *, descr	/* (O) Pntr to our internal descriptor structure */
    )


   {
   IU32 first_dword;
   IU32 second_dword;
   IU32 limit;

   /*
      The format of a 286 descriptor is:-

	 ===========================
      +1 |        LIMIT 15-0       | +0
	 ===========================
      +3 |        BASE 15-0        | +2
	 ===========================
      +5 |     AR     | BASE 23-16 | +4
	 ===========================
      +7 |         RESERVED        | +6
	 ===========================
   */

   /*
      The format of a 386 descriptor is:-

	 =============================        AR  = Access Rights.
      +1 |         LIMIT 15-0        | +0     AVL = Available.
	 =============================        D   = Default Operand
      +3 |         BASE 15-0         | +2           Size, = 0 16-bit
	 =============================                    = 1 32-bit.
      +5 |      AR     | BASE 23-16  | +4     G   = Granularity,
	 =============================                 = 0 byte limit
	 |             | | | |A|LIMIT|                 = 1 page limit.
      +7 | BASE 31-24  |G|D|0|V|19-16| +6
	 |             | | | |L|     |
	 =============================

   */

   /* read in descriptor with minimum interaction with memory */
   first_dword  = spr_read_dword(addr);
   second_dword = spr_read_dword(addr+4);

   /* load attributes and access rights */
   descr->AR = second_dword >> 8 & WORD_MASK;

   /* unpack the base */
   descr->base = (first_dword >> 16) | 
		 (second_dword << 16 & 0xff0000 ) |
		 (second_dword & 0xff000000);

   /* unpack the limit */
   limit = (first_dword & WORD_MASK) | (second_dword & 0xf0000);

   if ( second_dword & BIT23_MASK )
      {
      /* Granularity Bit Set. Limit is expressed in pages
	 (4k bytes), convert to byte limit */
      limit = limit << 12 | 0xfff;
      }
   descr->limit = limit;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check for null selector                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL BOOL
selector_is_null
       	          
IFN1(
	IU16, selector	/* selector to be checked */
    )


   {
   if ( GET_SELECTOR_INDEX(selector) == 0 && GET_SELECTOR_TI(selector) == 0 )
      return TRUE;
   return FALSE;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check if selector outside bounds of GDT                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL BOOL
selector_outside_GDT
       	    	               
IFN2(
	IU16, selector,	/* (I) selector to be checked */
	IU32 *, descr_addr	/* (O) address of related descriptor */
    )


   {
   IU16 offset;

   offset = GET_SELECTOR_INDEX_TIMES8(selector);

   /* make sure GDT then trap NULL selector or outside table */
   if ( GET_SELECTOR_TI(selector) == 1 ||
	offset == 0 || offset + 7 > GET_GDT_LIMIT() )
      return TRUE;
   
   *descr_addr = GET_GDT_BASE() + offset;
   return FALSE;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check if selector outside bounds of GDT or LDT                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL BOOL
selector_outside_GDT_LDT
       	    	               
IFN2(
	IU16, selector,	/* (I) selector to be checked */
	IU32 *, descr_addr	/* (O) address of related descriptor */
    )


   {
   IU16 offset;

   offset = GET_SELECTOR_INDEX_TIMES8(selector);

   /* choose a table */
   if ( GET_SELECTOR_TI(selector) == 0 )
      {
      /* GDT - trap NULL selector or outside table */
      if ( offset == 0 || offset + 7 > GET_GDT_LIMIT() )
	 return TRUE;
      *descr_addr = GET_GDT_BASE() + offset;
      }
   else
      {
      /* LDT - trap invalid LDT or outside table */
#ifndef DONT_CLEAR_LDTR_ON_INVALID
      if ( GET_LDT_SELECTOR() <= 3 || offset + 7 > GET_LDT_LIMIT() )
#else
      if ( GET_LDT_SELECTOR() == 0 || offset + 7 > GET_LDT_LIMIT() )
#endif /* DONT_CLEAR_LDTR_ON_INVALID */
	 return TRUE;
      *descr_addr = GET_LDT_BASE() + offset;
      }
   
   return FALSE;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Store new value in Intel EFLAGS register.                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
c_setEFLAGS
                 
IFN1(
	IU32, flags
    )


   {
   setFLAGS(flags);   /* set lower word */

   SET_RF((flags & BIT16_MASK) != 0);

   if ( GET_CPL() == 0 )
      SET_VM((flags & BIT17_MASK) != 0);

#ifdef SPC486
   SET_AC((flags & BIT18_MASK) != 0);
#endif /* SPC486 */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Store new value in Intel FLAGS register                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
setFLAGS
                 
IFN1(
	IU32, flags
    )


   {
   SET_CF((flags & BIT0_MASK) != 0);
   SET_PF((flags & BIT2_MASK) != 0);
   SET_AF((flags & BIT4_MASK) != 0);
   SET_ZF((flags & BIT6_MASK) != 0);
   SET_SF((flags & BIT7_MASK) != 0);
   SET_TF((flags & BIT8_MASK) != 0);
   SET_DF((flags & BIT10_MASK) != 0);
   SET_OF((flags & BIT11_MASK) != 0);

   /* IF only updated if CPL <= IOPL */
   if ( GET_CPL() <= GET_IOPL() )
      SET_IF((flags & BIT9_MASK) != 0);

   SET_NT((flags & BIT14_MASK) != 0);

   /* IOPL only updated at highest privilege */
   if ( GET_CPL() == 0 )
      SET_IOPL((flags >> 12) & 3);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_bsic.h ===
/*[

c_bsic.h

Basic Protected Mode Support and Flag Support.
----------------------------------------------

LOCAL CHAR SccsID[]="@(#)c_bsic.h	1.5 09/01/94";

]*/


/*
   Define descriptor 'super' types.
 */
#define INVALID				0x00
#define AVAILABLE_TSS			0x01
#define LDT_SEGMENT			0x02
#define BUSY_TSS			0x03
#define CALL_GATE			0x04
#define TASK_GATE			0x05
#define INTERRUPT_GATE			0x06
#define TRAP_GATE			0x07
#define XTND_AVAILABLE_TSS              0x09
#define XTND_BUSY_TSS                   0x0b
#define XTND_CALL_GATE                  0x0c
#define XTND_INTERRUPT_GATE             0x0e
#define XTND_TRAP_GATE                  0x0f
#define EXPANDUP_READONLY_DATA		0x11
#define EXPANDUP_WRITEABLE_DATA		0x13
#define EXPANDDOWN_READONLY_DATA	0x15
#define EXPANDDOWN_WRITEABLE_DATA	0x17
#define NONCONFORM_NOREAD_CODE		0x19
#define NONCONFORM_READABLE_CODE	0x1b
#define CONFORM_NOREAD_CODE		0x1d
#define CONFORM_READABLE_CODE		0x1f


/*
   Macros for access to SELECTOR bit fields.

	      15	               3 2 1 0
	      =================================
   SELECTOR   |          INDEX          |T|RPL|
	      |                         |I|   |
	      =================================
 */
#define GET_SELECTOR_INDEX_TIMES8(x)  ((x) & 0xfff8)
#define GET_SELECTOR_INDEX(x)         (((x) & 0xfff8) >> 3)
#define GET_SELECTOR_TI(x)            (((x) & 0x0004) >> 2)
#define GET_SELECTOR_RPL(x)           ((x) & 0x3)
#define SET_SELECTOR_RPL(x,y)         (x = ((x) & ~0x3) | y)

/*
   Macros for access to ACCESS RIGHTS bit fields.

		  1 1 1 1 1 1
		  5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
		 =================================
   ACCESS RIGHTS |-|X|-|-|-|-|-|-|P|DPL|  SUPER  |
		 =================================

  Code Segment:            Data Segment:
   7 6 5 4 3 2 1 0          7 6 5 4 3 2 1 0 
  =================        =================
  |P|DPL|1|1|C|R|A|        |P|DPL|1|0|E|W|A|
  =================        =================

 */
#define GET_AR_P(x) (((x) & BIT7_MASK) != 0)  /* present */
#define GET_AR_E(x) (((x) & BIT2_MASK) != 0)  /* expand down */
#define GET_AR_C(x) (((x) & BIT2_MASK) != 0)  /* conforming */
#define GET_AR_W(x) (((x) & BIT1_MASK) != 0)  /* writeable */
#define GET_AR_R(x) (((x) & BIT1_MASK) != 0)  /* readable */
#define GET_AR_X(x) (((x) & BIT14_MASK) != 0)  /* big/default */

#define GET_AR_DPL(x)     (((x) & 0x60) >> 5)
#define GET_AR_SUPER(x)   ((x) & 0x1f)

#define NOT_PRESENT 0
#define PRESENT     1
#define ACCESSED    1


IMPORT ISM32 descriptor_super_type
       
IPT1(
	IU16, AR

   );

IMPORT VOID do_multiple_shiftrot_of
       
IPT1(
	ISM32, new_of

   );


IMPORT IU32 getFLAGS IPT0();

IMPORT VOID read_descriptor_linear
           
IPT2(
	IU32, addr,
	CPU_DESCR *, descr

   );

IMPORT BOOL selector_is_null
       
IPT1(
	IU16, selector

   );

IMPORT BOOL selector_outside_GDT
           
IPT2(
	IU16, selector,
	IU32 *, descr_addr

   );

IMPORT BOOL selector_outside_GDT_LDT
           
IPT2(
	IU16, selector,
	IU32 *, descr_addr

   );

IMPORT VOID setFLAGS
       
IPT1(
	IU32, flags

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_debug.c ===
/*[

c_debug.c

LOCAL CHAR SccsID[]="@(#)c_debug.c	1.5 02/09/94";

Debugging Register and Breakpoint Support
-----------------------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <c_debug.h>


/*
   IMPLEMENTATION NOTE. We ignore the GE and LE bits, effectively like
   the 486 we will always generate exact exceptions. As we have no
   pipeline architecture and have always finished the last instruction
   before starting the next one, we can easily provide exact exceptions.

   For the same reason we never need to set the BD bit, with no 
   pipelining the debug registers may be freely written to at any time.
 */


/* 
   We hold instruction breakpoints as a linear address, plus
   an index which identifies the debug register.
 */
typedef struct
   {
   IU32 addr;	/* Linear address of breakpoint */
   IU32 id;	/* debug register identifier */
   } INST_BREAK;

/*
   We hold data breakpoints as start and end linear addresses, type
   and an index which identifies the debug register.
 */
typedef struct
   {
   IU32 start_addr;	/* Linear start address of breakpoint (incl) */
   IU32 end_addr;	/* Linear end address of breakpoint (incl) */
   ISM32 type;		/* D_WO (write) or D_RW (read/write) */
   IU32 id;		/* debug register identifier */
   } DATA_BREAK;

/*
   Data breakpoint types.
 */
#define D_WO 0   /* write only */
#define D_RW 1   /* read or write */

#define NR_BRKS 4	/* Intel has 4 breakpoint address regs */

/*
   Our breakpoint structure.
 */
GLOBAL IU32 nr_inst_break = 0;	/* number of inst breakpoints active */
GLOBAL IU32 nr_data_break = 0;	/* number of data breakpoints active */

LOCAL INST_BREAK i_brk[NR_BRKS];
LOCAL DATA_BREAK d_brk[NR_BRKS];

/*
   Define masks and shifts for components of Debug Control Register.

   DCR = Debug Control Register:-

       33 22 22 22 22 22 11 11 1    1
       10 98 76 54 32 10 98 76 5    0 9 8 7 6 5 4 3 2 1 0
      ====================================================
      |L |R |L |R |L |R |L |R |   0  |G|L|G|L|G|L|G|L|G|L|
      |E |/ |E |/ |E |/ |E |/ |      |E|E|3|3|2|2|1|1|0|0|
      |N |W |N |W |N |W |N |W |      | | | | | | | | | | |
      |3 |3 |2 |2 |1 |1 |0 |0 |      | | | | | | | | | | |
      ====================================================
   
 */

LOCAL IU32 g_l_shift[NR_BRKS] =
   {
   0,   /* access G0 L0 */
   2,   /* access G1 L1 */
   4,   /* access G2 L2 */
   6    /* access G3 L3 */
   };

LOCAL IU32 r_w_shift[NR_BRKS] =
   {
   16,   /* access R/W0 */
   20,   /* access R/W1 */
   24,   /* access R/W2 */
   28    /* access R/W3 */
   };

LOCAL IU32 len_shift[NR_BRKS] =
   {
   18,   /* access LEN0 */
   22,   /* access LEN1 */
   26,   /* access LEN2 */
   30    /* access LEN3 */
   };

#define COMP_MASK    0x3   /* all fields are 2-bit */


/*
   =====================================================================
   INTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Map Intel length indicator to start and end address form.          */
/* RETURNS true if valid len processed                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL BOOL
len_to_addr
       		    	    		                    
IFN3(
	ISM32, index,	/* (I) debug register holding breakpoint */
	IU32 *, start,	/* (O) pntr to start address (inclusive) for
			       debug area */
	IU32 *, end	/* (O) pntr to end address (inclusive) for
			       debug area */
    )


   {
   BOOL retval;

   /* map length into start and end addresses */
   switch ( GET_DR(DR_DCR) >> len_shift[index] & COMP_MASK )
      {
   case 0:   /* one byte */
      *start = *end = GET_DR(index);
      retval = TRUE;
      break;

   case 1:   /* two byte */
      *start = GET_DR(index) & ~BIT0_MASK;
      *end = *start + 1;
      retval = TRUE;
      break;
   
   case 3:   /* four byte */
      *start = GET_DR(index) & ~(BIT1_MASK | BIT0_MASK);
      *end = *start + 3;
      retval = TRUE;
      break;
   
   case 2:   /* undefined */
   default:
      retval = FALSE;
      break;
      }

   return retval;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Put Intel inst breakpoint into our internal form.                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
setup_inst_break
       	          
IFN1(
	ISM32, index	/* debug register holding breakpoint */
    )


   {
   INST_BREAK *p;

   p = &i_brk[nr_inst_break];

   p->addr = GET_DR(index);
   p->id = index;

   nr_inst_break++;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Put Intel data breakpoint into our internal form.                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
setup_data_break
       	    	               
IFN2(
	ISM32, type,	/* (I) D_WO(write) or D_RW(read/write) breakpoint */
	ISM32, index	/* (I) debug register holding breakpoint */
    )


   {
   DATA_BREAK *p;

   p = &d_brk[nr_data_break];

   if ( len_to_addr(index, &p->start_addr, &p->end_addr) )
      {
      p->id = index;
      p->type = type;
      nr_data_break++;
      }
   }


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check Memory Access for Data Breakpoint Exception.                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
check_for_data_exception
       	    	    	                    
IFN3(
	IU32, la,	/* linear address */
	ISM32, attr,	/* read or write access to memory */
	ISM32, size	/* encoded IU8, IU16 or IU32 size indicator */
    )


   {
   ISM32 i;		/* index thru active data breakpoints */
   ISM32 ii;		/* index thru all Intel breakpoints */
   ISM32 trig;	 	/* id of breakpoint which first triggers */
   IU32 end_la;	/* end (inclusive) address of memory access */
   IU32 start;		/* start (inclusive) address of brkpnt. */
   IU32 end;		/* end (inclusive) address of brkpnt. */
   BOOL data_brk;	/* current breakpoint needs range check */
   DATA_BREAK *p;

   end_la = la + size;   /* calc. end address (inclusive) */

   /* look for debugging hit among active breakpoints */
   for ( i = 0; i < nr_data_break; i++ )
      {
      p = &d_brk[i];

      if ( la > p->end_addr || end_la < p->start_addr ||
	   attr == D_R && p->type == D_WO )
	 {
	 ;   /* no hit */
	 }
      else
	 {
	 /* Data breakpoint triggered */
	 trig = p->id;   /* get Intel identifier */
	 SET_DR(DR_DSR, GET_DR(DR_DSR) | 1 << trig);   /* set B bit */

	 /*
	    Now all breakpoints are checked regardless of the
	    enable bits and the appropriate B bit set if the
	    breakpoint would trigger if enabled.
	  */
	 for ( ii = 0; ii < NR_BRKS; ii++ )
	    {
	    if ( ii == trig )
	       continue;   /* we have already processed the tigger */

	    data_brk = FALSE;

	    /* action according to R/W field */
	    switch ( GET_DR(DR_DCR) >> r_w_shift[ii] & COMP_MASK )
	       {
	    case 1:   /* data write only */
	       if ( attr == D_W )
		  {
		  data_brk = len_to_addr(ii, &start, &end);
		  }
	       break;
	    
	    case 3:   /* data read or write */
	       data_brk = len_to_addr(ii, &start, &end);
	       break;
	       }
	    
	    if ( data_brk )
	       {
	       if ( la > end || end_la < start )
		  {
		  ;   /* no hit */
		  }
	       else
		  {
		  /* set appropriate B bit */
		  SET_DR(DR_DSR, GET_DR(DR_DSR) | 1 << ii);
		  }
	       }
	    }

	 break;   /* all done after one trigger */
	 }
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check Memory Access for Instruction Breakpoint Exception.          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
check_for_inst_exception
       	          
IFN1(
	IU32, la	/* linear address */
    )


   {
   ISM32 i;		/* index thru active inst breakpoints */
   ISM32 trig;
   INST_BREAK *p;

   /* look for debugging hit among active breakpoints */
   for ( i = 0; i < nr_inst_break; i++ )
      {
      p = &i_brk[i];

      if ( p->addr == la )
	 {
	 /* Inst breakpoint triggered */
	 trig = p->id;   /* get Intel identifier */
	 SET_DR(DR_DSR, GET_DR(DR_DSR) | 1 << trig);   /* set B bit */
	 }
      }
   }


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Put Intel debugging registers into internal breakpoint form.       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
setup_breakpoints()
   {
   ISM32 i;

   nr_inst_break = nr_data_break = 0;   /* set no breakpoints */

   /* look for breakpoints set in DCR */
   for ( i = DR_DAR0; i <= DR_DAR3; i++ )
      {
      /* look for globally or locally active */
      if ( GET_DR(DR_DCR) >> g_l_shift[i] & COMP_MASK )
	 {
	 /* action according to R/W field */
	 switch ( GET_DR(DR_DCR) >> r_w_shift[i] & COMP_MASK )
	    {
	 case 0:   /* instruction breakpoint */
	    setup_inst_break(i);
	    break;

	 case 1:   /* data write only */
	    setup_data_break(D_WO, i);
	    break;
	 
	 case 2:   /* undefined */
	    /* do nothing */
	    break;
	 
	 case 3:   /* data read or write */
	    setup_data_break(D_RW, i);
	    break;
	    }
	 }
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_intr.h ===
/*[

c_intr.h

LOCAL CHAR SccsID[]="@(#)c_intr.h	1.4 02/09/94";

Interrupt Support.
------------------

]*/

IMPORT VOID do_intrupt
                   
IPT4(
	IU16, vector,
	BOOL, priv_check,
	BOOL, has_error_code,
	IU16, error_code

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_intr.c ===
/*[

c_intr.c

LOCAL CHAR SccsID[]="@(#)c_intr.c	1.21 03/07/95";

Interrupt Support.
------------------

]*/


#include <insignia.h>

#include <host_def.h>

#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_intr.h>
#include <c_xfer.h>
#include <c_tsksw.h>
#include <c_page.h>
#include <c_mem.h>
#include <ccpusas4.h>
#include <ccpupig.h>
#include <fault.h>

#ifdef PIG
#include <gdpvar.h>
#endif

/*
   Prototype our internal functions.
 */
LOCAL ISM32 validate_int_dest
                           
IPT6(
	IU16, vector,
	BOOL, do_priv,
	IU16 *, cs,
	IU32 *, ip,
	IU32 *, descr_addr,
	ISM32 *, dest_type

   );


/*
   =====================================================================
   INTERNAL FUNCTIONS STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Validate int destination. Essentially decode int instruction.      */
/* Take #GP_INT(vector) if invalid.                                   */
/* Take #NP_INT(vector) if not present.                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL ISM32
validate_int_dest
       		    	    		    		    	    	                                   
IFN6(
	IU16, vector,	/* (I) vector to be checked  */
	BOOL, do_priv,	/* (I) if true do privilege check */
	IU16 *, cs,	/* (O) segment of target address */
	IU32 *, ip,	/* (O) offset  of target address */
	IU32 *, descr_addr,	/* (O) related descriptor memory address */
	ISM32 *, dest_type	/* (O) destination type */
    )


   {
   IU16 offset;
   IU8 AR;
   ISM32 super;

   /* calc address within IDT */
   offset = vector * 8;

   /* check within IDT */
   if ( offset + 7 > GET_IDT_LIMIT() )
      GP_INT(vector, FAULT_INT_DEST_NOT_IN_IDT);
   
   *descr_addr = GET_IDT_BASE() + offset;

   AR = spr_read_byte((*descr_addr)+5);

   /* check type */
   switch ( super = descriptor_super_type((IU16)AR) )
      {
   case INTERRUPT_GATE:
   case TRAP_GATE:
      SET_OPERAND_SIZE(USE16);
      break;
   
   case XTND_INTERRUPT_GATE:
   case XTND_TRAP_GATE:
      SET_OPERAND_SIZE(USE32);
      break;
   
   case TASK_GATE:
      break;   /* ok */
   
   default:
      GP_INT(vector, FAULT_INT_DEST_BAD_SEG_TYPE);
      }

   /* access check requires CPL <= DPL */
   if ( do_priv && (GET_CPL() > GET_AR_DPL(AR)) )
      GP_INT(vector, FAULT_INT_DEST_ACCESS);

   /* gate must be present */
   if ( GET_AR_P(AR) == NOT_PRESENT )
      NP_INT(vector, FAULT_INT_DEST_NOTPRESENT);

   /* ok, get real destination from gate */
   *cs = spr_read_word((*descr_addr)+2);

   /* action gate type */
   if ( super == TASK_GATE )
      {
      /* Need to set operand size here so that any
       * error code is push with correct size.
       */
      switch (validate_task_dest(*cs, descr_addr))
        {
	case BUSY_TSS:
	case AVAILABLE_TSS:
		SET_OPERAND_SIZE(USE16);
		break;
	case XTND_BUSY_TSS:
	case XTND_AVAILABLE_TSS:
		SET_OPERAND_SIZE(USE32);
		break;
        }
      *dest_type = NEW_TASK;
      }
   else
      {
      /* INTERRUPT or TRAP GATE */

      *ip = (IU32)spr_read_word(*descr_addr);
      if ( super == XTND_INTERRUPT_GATE || super == XTND_TRAP_GATE )
	 *ip = (IU32)spr_read_word((*descr_addr)+6) << 16 | *ip;

      validate_gate_dest(INT_ID, *cs, descr_addr, dest_type);
      }

   return super;
   }


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Process interrupt.                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
do_intrupt
       			    		    	    		                         
IFN4(
	IU16, vector,	/* (I) interrupt vector to call */
	BOOL, priv_check,	/* (I) if true access check is needed */
	BOOL, has_error_code,	/* (I) if true needs error code pushing
				       on stack */
	IU16, error_code	/* (I) error code to be pushed */
    )


   {
   /* GLOBALS USED */
   /* doing_contributory   cleared on success of interrupt */
   /* doing_page_fault     cleared on success of interrupt */
   /* doing_double_fault   cleared on success of interrupt */
   /* doing_fault          indicates RF should be set in pushed
			   flags, cleared on success */

   IU32 flags;		/* temp store for FLAGS register */
   IU32 ivt_addr;	/* address of ivt entry */

   IU16  new_cs;	/* The destination */
   IU32 new_ip;

   IU32 cs_descr_addr;	/* code segment descriptor address */
   CPU_DESCR cs_entry;	/* code segment descriptor entry */

   ISM32 dest_type;	/* category for destination */
   ISM32 super;		/* super type of destination */
   IU32 dpl;		/* new privilege level (if used) */

   ISM32 stk_sz;		/* space (in bytes) reqd on stack */
   IU16  new_ss;	/* The new stack */
   IU32 new_sp;

   IU32 ss_descr_addr;		/* stack segment descriptor address */
   CPU_DESCR ss_entry;		/* stack segment descriptor entry */

   IU32 old_ss;        /* Variables used while making stack */
   IU32 old_sp;

   if ( GET_PE() == 0 )
      {
      /* Real Mode */

      /* must be able to push FLAGS:CS:IP */
      validate_stack_space(USE_SP, (ISM32)NR_ITEMS_3);

      /* get new destination */
      ivt_addr = (IU32)vector * 4;
      new_ip = (IU32)phy_read_word(ivt_addr);
      new_cs = phy_read_word(ivt_addr+2);

#ifdef	TAKE_REAL_MODE_LIMIT_FAULT
	/*
	 * In real mode, there is still an IP limit check.  The new IP is
	 * compared against the last CS limit from when the program was last
	 * in protected mode (or 64K if it never was).  For us, this is stored
	 * in the CS limit field. (cf i486PRM page 22-4)
	 */

      if ( new_ip > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_INTR_RM_CS_LIMIT);

#else	/* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */
   
      /* ALL SYSTEMS GO */

      flags = c_getEFLAGS();

      if ( doing_fault )
      {
#ifdef PIG
         if (GLOBAL_RF_OnXcptnWanted)
	    flags |= BIT16_MASK;   /* SET RF bit */
#else
	 flags |= BIT16_MASK;   /* SET RF bit */
#endif
      }

#ifdef PIG
      if (vector < 31 && (((1 << vector) & NO_FLAGS_EXCEPTION_MASK) != 0))
         spush_flags(flags);
      else
#endif /* PIG */
         spush(flags);

      spush16((IU32)GET_CS_SELECTOR());
      spush((IU32)GET_EIP());

      load_CS_cache(new_cs, (IU32)0, (CPU_DESCR *)0);
      SET_EIP(new_ip);
      SET_IF(0);
      SET_TF(0);
      }
   else
      {
      /* Protected Mode */

      super = validate_int_dest(vector, priv_check, &new_cs, &new_ip,
				&cs_descr_addr, &dest_type);

      /* check type of indirect target */
      switch ( dest_type )
	 {
      case NEW_TASK:
	 switch_tasks(NOT_RETURNING, NESTING, new_cs, cs_descr_addr, GET_EIP());

	 /* save error code on new stack */
	 if ( has_error_code )
	    {
	    validate_stack_space(USE_SP, (ISM32)NR_ITEMS_1);
	    spush((IU32)error_code);
	    }

	 /* limit check new IP (now in new task) */
	 if ( GET_EIP() > GET_CS_LIMIT() )
	    GP((IU16)0, FAULT_INTR_TASK_CS_LIMIT);

	 break;

      case SAME_LEVEL:
	 read_descriptor_linear(cs_descr_addr, &cs_entry);

	 /* stamp new selector with CPL */
	 SET_SELECTOR_RPL(new_cs, GET_CPL());

	 /* check room for return address CS:(E)IP:(E)FLAGS:(Error) */
	 if ( has_error_code )
	    stk_sz = NR_ITEMS_4;
	 else
	    stk_sz = NR_ITEMS_3;
	 validate_stack_space(USE_SP, stk_sz);

	 if ( new_ip > cs_entry.limit )
	    GP((IU16)0, FAULT_INTR_PM_CS_LIMIT_1);

	 /* ALL SYSTEMS GO */

	 /* push flags */
	 flags = c_getEFLAGS();

	 if ( doing_fault )
         {
#ifdef PIG
            if (GLOBAL_RF_OnXcptnWanted)
	       flags |= BIT16_MASK;   /* SET RF bit */
#else
	    flags |= BIT16_MASK;   /* SET RF bit */
#endif
         }

#ifdef PIG
	 if (vector < 31 && (((1 << vector) & NO_FLAGS_EXCEPTION_MASK) != 0))
	    spush_flags(flags);
	 else
#endif /* PIG */
	    spush(flags);


	 /* push return address */
	 spush16((IU32)GET_CS_SELECTOR());
	 spush((IU32)GET_EIP());

	 /* finally push error code if required */
	 if ( has_error_code )
	    {
	    spush((IU32)error_code);
	    }

	 load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
	 SET_EIP(new_ip);
	 
	 /* finally action IF, TF and NT flags */
	 if ((super == INTERRUPT_GATE) || (super == XTND_INTERRUPT_GATE))
	    SET_IF(0);
	 SET_TF(0);
	 SET_NT(0);
	 break;

      default:   /* MORE PRIVILEGE(0|1|2) */
	 read_descriptor_linear(cs_descr_addr, &cs_entry);

	 dpl = dest_type;

	 /* stamp new selector with new CPL */
	 SET_SELECTOR_RPL(new_cs, dpl);

	 /* find out about new stack */
	 get_stack_selector_from_TSS(dpl, &new_ss, &new_sp);

	 /* check new stack selector */
	 validate_SS_on_stack_change(dpl, new_ss,
				     &ss_descr_addr, &ss_entry);

	 /* check room for (GS:FS:DS:ES)
			   SS:(E)SP
			   (E)FLAGS
			   CS:(E)IP
			   (ERROR) */
	 if ( GET_VM() == 1 )
	    stk_sz = NR_ITEMS_9;
	 else
	    stk_sz = NR_ITEMS_5;

	 if ( has_error_code )
	    stk_sz = stk_sz + NR_ITEMS_1;

	 validate_new_stack_space(stk_sz, new_sp, &ss_entry, new_ss);

	 if ( new_ip > cs_entry.limit )
	    GP((IU16)0, FAULT_INTR_PM_CS_LIMIT_2);
	 
	 /* ALL SYSTEMS GO */

	 flags = c_getEFLAGS();

	 if ( doing_fault )
         {
#ifdef PIG
            if (GLOBAL_RF_OnXcptnWanted)
	       flags |= BIT16_MASK;   /* SET RF bit */
#else
	    flags |= BIT16_MASK;   /* SET RF bit */
#endif
         }

	 SET_CPL(dpl);
	 SET_VM(0);

	 /* update stack segment */
	 old_ss = (IU32)GET_SS_SELECTOR();
	 old_sp = GET_ESP();

	 load_SS_cache(new_ss, ss_descr_addr, &ss_entry);
	 set_current_SP(new_sp);

	 /*
	    FORM NEW STACK, VIZ

			  ==============
	    new SS:IP  -> | error code |
			  | old IP     |
			  | old CS     |
			  | FLAGS      |
			  | old SP     |
			  | old SS     |
			  ==============
			  | old ES     |
			  | old DS     |
			  | old FS     |
			  | old GS     |
			  ==============
	  */

	 if ( stk_sz >= NR_ITEMS_9 )
	    {
	    /* interrupt from V86 mode */
	    spush16((IU32)GET_GS_SELECTOR());
	    spush16((IU32)GET_FS_SELECTOR());
	    spush16((IU32)GET_DS_SELECTOR());
	    spush16((IU32)GET_ES_SELECTOR());

	    /* invalidate data segments */
	    load_data_seg(GS_REG, (IU16)0);
	    load_data_seg(FS_REG, (IU16)0);
	    load_data_seg(DS_REG, (IU16)0);
	    load_data_seg(ES_REG, (IU16)0);
	    }

	 /* push old stack values */
	 spush16(old_ss);
	 spush(old_sp);

	 /* push old flags */
#ifdef PIG
	 if (vector < 31 && (((1 << vector) & NO_FLAGS_EXCEPTION_MASK) != 0))
	    spush_flags(flags);
	 else
#endif /* PIG */
	    spush(flags);

	 /* push return address */
	 spush16((IU32)GET_CS_SELECTOR());
	 spush((IU32)GET_EIP());

	 /* finally push error code if required */
	 if ( has_error_code )
	    {
	    spush((IU32)error_code);
	    }

	 /* update code segment */
	 load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
	 SET_EIP(new_ip);
	 
	 /* finally action IF, TF and NT flags */
	 if ((super == INTERRUPT_GATE) || (super == XTND_INTERRUPT_GATE))
	    SET_IF(0);
	 SET_TF(0);
	 SET_NT(0);
	 break;
	 }
	 
      }
   EXT = INTERNAL;
#ifdef	PIG
   save_last_inst_details("do_intr");
   pig_cpu_action = CHECK_ALL;
   /* If the destination is going to page fault, or need
    * accessing, then the EDL CPU will do so before issuing
    * the pig synch. We use the dasm386 decode to prefetch
    * a single instruction which mimics the EDL Cpu's behaviour
    * when close to a page boundary.
    */
   prefetch_1_instruction();	/* Will PF if destination not present */
   ccpu_synch_count++;
#else /* !PIG */
#ifdef SYNCH_TIMERS
   if (doing_fault)
      {
      extern void SynchTick IPT0();
      SynchTick();
      }
#endif /* SYNCH_TIMERS */
#endif /* PIG */
   /* mark successful end to interrupt */
   doing_fault = FALSE;
   doing_contributory = FALSE;
   doing_page_fault = FALSE;
   doing_double_fault = FALSE;
#ifdef PIG
   c_cpu_unsimulate();
#endif /* PIG */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_main.c ===
/*[

c_main.c

LOCAL CHAR SccsID[]="@(#)c_main.c	1.96 04/11/95";

Main routine for CPU emulator.
------------------------------

All instruction decoding and addressing is controlled here.
Actual worker routines are spun off elsewhere.

]*/

#include <insignia.h>
#include <host_def.h>

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

#include  <xt.h>		/* needed by bios.h */
#include  <sas.h>	/* need memory(M)     */
#include  <ccpusas4.h>	/* the cpu internal sas bits */
#ifdef	PIG
#include  <Cpu_c.h>	/* Intel pointer manipulation macros */
#endif	/* PIG */
#include CpuH
/* #include "event.h" */	/* Event Manager         */
#include  <bios.h>	/* need access to bop */
#include  <debug.h>
#include  <config.h>
#ifdef NTVDM
#include <ntthread.h>
#endif

#include <c_main.h>	/* C CPU definitions-interfaces */
#include <c_page.h>	/* Paging Interface */
#include <c_mem.h>	/* CPU - Memory Interface */
#include <c_intr.h>	/* Interrupt Interface */
#include <c_debug.h>	/* Debug Regs and Breakpoint Interface */
#include <c_oprnd.h>	/* Operand decoding functions(macros) */
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_page.h>
#include <c_intr.h>
#include <c_debug.h>
#include <c_oprnd.h>
#include <c_bsic.h>
#include <ccpupig.h>
#include <fault.h>

#include  <aaa.h>	/* The workers */
#include  <aad.h>	/*     ...     */
#include  <aam.h>	/*     ...     */
#include  <aas.h>	/*     ...     */
#include  <adc.h>	/*     ...     */
#include  <add.h>	/*     ...     */
#include  <and.h>	/*     ...     */
#include  <arpl.h>	/*     ...     */
#include  <bound.h>	/*     ...     */
#include  <bsf.h>	/*     ...     */
#include  <bsr.h>	/*     ...     */
#include  <bt.h>		/*     ...     */
#include  <btc.h>	/*     ...     */
#include  <btr.h>	/*     ...     */
#include  <bts.h>	/*     ...     */
#include  <call.h>	/*     ...     */
#include  <cbw.h>	/*     ...     */
#include  <cdq.h>	/*     ...     */
#include  <clc.h>	/*     ...     */
#include  <cld.h>	/*     ...     */
#include  <cli.h>	/*     ...     */
#include  <clts.h>	/*     ...     */
#include  <cmc.h>	/*     ...     */
#include  <cmp.h>	/* CMP, CMPS, SCAS */
#include  <cwd.h>	/*     ...     */
#include  <cwde.h>	/*     ...     */
#include  <daa.h>	/*     ...     */
#include  <das.h>	/*     ...     */
#include  <dec.h>	/*     ...     */
#include  <div.h>	/*     ...     */
#include  <enter.h>	/*     ...     */
#include  <idiv.h>	/*     ...     */
#include  <imul.h>	/*     ...     */
#include  <in.h>		/*     ...     */
#include  <inc.h>	/*     ...     */
#include  <into.h>	/*     ...     */
#include  <intx.h>	/* INT, INT 3  */
#include  <iret.h>	/*     ...     */
#include  <jcxz.h>	/* JCXZ, JECXZ */
#include  <jmp.h>	/*     ...     */
#include  <jxx.h>	/* JB, JBE, JL, JLE, JNB, JNBE, JNL, JNLE, */
			/* JNO, JNP, JNS, JNZ, JO, JP, JS, JZ      */
#include  <lahf.h>	/*     ...     */
#include  <lar.h>	/*     ...     */
#include  <lea.h>	/*     ...     */
#include  <leave.h>	/*     ...     */
#include  <lgdt.h>	/*     ...     */
#include  <lidt.h>	/*     ...     */
#include  <lldt.h>	/*     ...     */
#include  <lmsw.h>	/*     ...     */
#include  <loopxx.h>	/* LOOP, LOOPE, LOOPNE */
#include  <lsl.h>	/*     ...     */
#include  <ltr.h>	/*     ...     */
#include  <lxs.h>	/* LDS, LES, LFS, LGS, LSS */
#include  <mov.h>	/* LODS, MOV, MOVZX, MOVS, STOS */
#include  <movsx.h>	/*     ...     */
#include  <mul.h>	/*     ...     */
#include  <neg.h>	/*     ...     */
#include  <nop.h>	/*     ...     */
#include  <not.h>	/*     ...     */
#include  <out.h>	/*     ...     */
#include  <or.h>		/*     ...     */
#include  <pop.h>	/*     ...     */
#include  <popa.h>	/*     ...     */
#include  <popf.h>	/*     ...     */
#include  <push.h>	/*     ...     */
#include  <pusha.h>	/*     ...     */
#include  <pushf.h>	/*     ...     */
#include  <rcl.h>	/*     ...     */
#include  <rcr.h>	/*     ...     */
#include  <ret.h>	/*     ...     */
#include  <rol.h>	/*     ...     */
#include  <ror.h>	/*     ...     */
#include  <rsrvd.h>	/*     ...     */
#include  <sahf.h>	/*     ...     */
#include  <sar.h>	/*     ...     */
#include  <sbb.h>	/*     ...     */
#include  <setxx.h>	/* SETB, SETBE, SETL, SETLE, SETNB, SETNBE,   */
			/* SETNL, SETNLE, SETNO, SETNP, SETNS, SETNZ, */
			/* SETO, SETP, SETS, SETZ                     */
#include  <sgdt.h>	/*     ...     */
#include  <shl.h>	/*     ...     */
#include  <shld.h>	/*     ...     */
#include  <shr.h>	/*     ...     */
#include  <shrd.h>	/*     ...     */
#include  <sidt.h>	/*     ...     */
#include  <sldt.h>	/*     ...     */
#include  <smsw.h>	/*     ...     */
#include  <stc.h>	/*     ...     */
#include  <std.h>	/*     ...     */
#include  <sti.h>	/*     ...     */
#include  <str.h>	/*     ...     */
#include  <sub.h>	/*     ...     */
#include  <test.h>	/*     ...     */
#include  <verr.h>	/*     ...     */
#include  <verw.h>	/*     ...     */
#include  <wait.h>	/*     ...     */
#include  <xchg.h>	/*     ...     */
#include  <xlat.h>	/*     ...     */
#include  <xor.h>	/*     ...     */
#include  <zfrsrvd.h>	/*     ...     */

#ifdef CPU_486
#include  <bswap.h>	/*     ...     */
#include  <cmpxchg.h>	/*     ...     */
#include  <invd.h>	/*     ...     */
#include  <invlpg.h>	/*     ...     */
#include  <wbinvd.h>	/*     ...     */
#include  <xadd.h>	/*     ...     */
#endif /* CPU_486 */

#define FIX_BT_BUG	/* Of course we want the bug fixed! */

#define SYNCH_BOTH_WAYS	/* Do a PIG_SYNCH() on not-taken conditionals as well */

/*
   Types and constants local to this module.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

typedef union
   {
   IU32 sng;		/* Single Part Operand */
   IU32 mlt[2];	/* Multiple (two) Part Operand */
   DOUBLE flt;		/* Floating Point Operand */
   IU8 npxbuff[108];
   } OPERAND;

/*
   The allowable types of repeat prefix.
 */
#define REP_CLR (IU8)0
#define REP_NE  (IU8)1
#define REP_E   (IU8)2

/*
   Offsets to Low byte, High byte and Word parts of Double Word Regs.
 */
#ifdef LITTLEND

#define L_OFF 0
#define H_OFF 1
#define X_OFF 0

#else /* BIGEND */

#define L_OFF 3
#define H_OFF 2
#define X_OFF 2

#endif /* LITTLEND */

/* CPU hardware interrupt definitions */
#define CPU_HW_INT_MASK         (1 << 0)

#ifdef SFELLOW
	/* for raising NPX interrupt */
#define IRQ5_SLAVE_PIC	5
#endif	/* SFELLOW */

/* CPU hardware interrupt definitions */
#define CPU_HW_INT_MASK         (1 << 0)

/* Masks for external CPU events. */
#define CPU_SIGIO_EXCEPTION_MASK        (1 << 12)
#define CPU_SAD_EXCEPTION_MASK          (1 << 13)
#define CPU_RESET_EXCEPTION_MASK        (1 << 14)
#define CPU_SIGALRM_EXCEPTION_MASK      (1 << 15)
#ifdef SFELLOW
#define CPU_HW_NPX_INT_MASK         	(1 << 16)
#endif	/* SFELLOW */

LOCAL IU16 cpu_hw_interrupt_number;
#if defined(SFELLOW)
extern IU32	cpu_interrupt_map ;
#else
LOCAL IUM32	cpu_interrupt_map = 0;
#endif	/* SFELLOW */


GLOBAL IBOOL took_relative_jump;
extern IBOOL NpxIntrNeeded;
GLOBAL IBOOL took_absolute_toc;
LOCAL IBOOL single_instruction_delay ;
LOCAL IBOOL single_instruction_delay_enable ;

/*
   Define Maximun valid segment register in a 3-bit 'reg' field.
 */
#define MAX_VALID_SEG 5

/*
   Define lowest modRM for register (rather than memory) addressing.
 */
#define LOWEST_REG_MODRM 0xc0

GLOBAL VOID clear_any_thingies IFN0()
{
	cpu_interrupt_map &= ~CPU_SIGALRM_EXCEPTION_MASK;
}


/*
   Prototype our internal functions.
 */
LOCAL VOID ccpu
       
IPT1(
	ISM32, single_step

   );

LOCAL VOID check_io_permission_map IPT2(IU32, port_addr, IUM8, port_width);

/*
   FRIG for delayed interrupts to *not* occur when IO registers
   are accessed from our non CPU C code.
 */
ISM32 in_C;

LOCAL BOOL quick_mode = FALSE;	/* true if no special processing (trap
				   flag, interrupts, yoda...) is needed
				   between instructions. All flow of
				   control insts. and I/O insts. force
				   an exit from quick mode. IE. linear
				   sequences of CPU functions should
				   normally run in quick mode. */


#ifdef	PIG

/* We must delay the actual synch (i.e. the c_cpu_unsimulate)
 * until after processing any trap/breakpoint stuff.
 */
#define	PIG_SYNCH(action)			\
	SYNCH_TICK();				\
	if (ccpu_pig_enabled)			\
	{					\
		pig_cpu_action = (action);	\
		quick_mode = FALSE;		\
		pig_synch_required = TRUE;	\
		CANCEL_HOST_IP();		\
	}
	

LOCAL IBOOL pig_synch_required = FALSE; /* This indicates that the current
					 * instruction needs a pig synch,
					 * and after trap/breakpoint
					 * processing we must return to
					 * the pigger.
					 */
#else

#define	PIG_SYNCH(action)			\
	SYNCH_TICK();				\
	/* No pig operations */

#endif	/* PIG */
/*
   Recursive CPU variables. Exception Handling.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

#define FRAMES 9

/* keep track of each CPU recursion */
GLOBAL IS32 simulate_level = 0;
LOCAL  jmp_buf longjmp_env_stack[FRAMES];

/* each level has somewhere for exception processing to bail out to */
LOCAL jmp_buf next_inst[FRAMES];


/* When Pigging we save each opcode byte in the last_inst record.
 * We must check the prefix length so that we dont overflow
 * our buffer.
 */
#ifdef	PIG
LOCAL int prefix_length = 0;
#define	CHECK_PREFIX_LENGTH()				\
	if (++prefix_length >= MAX_INTEL_PREFIX)	\
		Int6();
#else	/* !PIG */
#define	CHECK_PREFIX_LENGTH()
#endif	/* PIG */

/*
   The emulation register set.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

GLOBAL SEGMENT_REGISTER  CCPU_SR[6];	/* Segment Registers */

GLOBAL IU32 CCPU_TR[8];       	/* Test Registers */

GLOBAL IU32 CCPU_DR[8];       	/* Debug Registers */

GLOBAL IU32 CCPU_CR[4];       	/* Control Registers */

GLOBAL IU32 CCPU_GR[8];        /* Double Word General Registers */

/*
 * WARNING: in the initialisation below, (IU8 *) casts are used
 * to satify dominatrix compilers that will not allow the use of
 * IHPE casts for pointer types _in initialisation_.
 */
GLOBAL IU16 *CCPU_WR[8] =	/* Pointers to the Word Registers */
   {
   (IU16 *)((IU8 *)&CCPU_GR[0] + X_OFF),
   (IU16 *)((IU8 *)&CCPU_GR[1] + X_OFF),
   (IU16 *)((IU8 *)&CCPU_GR[2] + X_OFF),
   (IU16 *)((IU8 *)&CCPU_GR[3] + X_OFF),
   (IU16 *)((IU8 *)&CCPU_GR[4] + X_OFF),
   (IU16 *)((IU8 *)&CCPU_GR[5] + X_OFF),
   (IU16 *)((IU8 *)&CCPU_GR[6] + X_OFF),
   (IU16 *)((IU8 *)&CCPU_GR[7] + X_OFF)
   };

GLOBAL IU8 *CCPU_BR[8] =	/* Pointers to the Byte Registers */
   {
   (IU8 *)((IU8 *)&CCPU_GR[0] + L_OFF),
   (IU8 *)((IU8 *)&CCPU_GR[1] + L_OFF),
   (IU8 *)((IU8 *)&CCPU_GR[2] + L_OFF),
   (IU8 *)((IU8 *)&CCPU_GR[3] + L_OFF),
   (IU8 *)((IU8 *)&CCPU_GR[0] + H_OFF),
   (IU8 *)((IU8 *)&CCPU_GR[1] + H_OFF),
   (IU8 *)((IU8 *)&CCPU_GR[2] + H_OFF),
   (IU8 *)((IU8 *)&CCPU_GR[3] + H_OFF)
   };

GLOBAL IU32 CCPU_IP;		/* The Instruction Pointer */
GLOBAL SYSTEM_TABLE_ADDRESS_REGISTER CCPU_STAR[2];	/* GDTR and IDTR */

GLOBAL SYSTEM_ADDRESS_REGISTER CCPU_SAR[2];		/* LDTR and TR */

GLOBAL IU32 CCPU_CPL;	/* Current Privilege Level */

GLOBAL IU32 CCPU_FLAGS[32];	/* The flags. (EFLAGS) */

      /* We allocate one integer per bit posn, multiple
	 bit fields are aligned to the least significant
	 posn. hence:-
	    CF   =  0   PF   =  2   AF   =  4   ZF   =  6
	    SF   =  7   TF   =  8   IF   =  9   DF   = 10
	    OF   = 11   IOPL = 12   NT   = 14   RF   = 16
	    VM   = 17   AC   = 18  */


GLOBAL IU32 CCPU_MODE[3];	/* Current Operating Mode */

      /* We allocate one integer per modal condition, as follows:-
	    [0] = current operand size (0=16-bit, 1=32-bit)
	    [1] = current address size (0=16-bit, 1=32-bit)
	    [2] = 'POP' displacement. (0=None,
				       2=Pop word,
				       4=Pop double word)
		  Set by POP used by [ESP] addressing modes. */

/*
   Trap Flag Support.

   Basically if the trap flag is set before an instruction, then when
   the instruction has been executed a trap is taken. This is why
   instructions which set the trap flag have a one instruction delay
   (or apparent one instruction delay) before a trap is first taken.
   However INT's will clear the trap flag and clear any pending trap
   at the end of the INT.
 */
LOCAL IU32 start_trap;

/*
   Host Pointer to Instruction Start.
   (Used in Host IP optimisation)
 */
LOCAL  IU8 *p_start;

/*
   Host pointer to point to where host may safely read instruction
   stream bytes.
   (Used in Host IP optimisation)
 */
GLOBAL  IU8 *pg_end;

/*
   Flag support.
 */
GLOBAL IU8 pf_table[] =
   {
   1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
   0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
   0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
   1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
   0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
   1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
   1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
   0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
   0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
   1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
   1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
   0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
   1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
   0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
   0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
   1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1
   };

/*
   CPU Heart Beat. A counter is decremented if not zero, and if it becomes
   zero, this means that an external routine requires an event to occur.
   The event handling is done through the quick event manager, all we need
   to do is count down and then call the manager when we get to zero. This
   mechanism is used to simulate an accurate micro-second
   timer.
 */
LOCAL IU32 cpu_heartbeat;
GLOBAL IUH PigSynchCount = 0;

IMPORT VOID dispatch_q_event();

#ifndef SFELLOW
#ifdef SYNCH_TIMERS

#define SYNCH_TICK()					\
	{						\
		PigSynchCount += 1;			\
		if (cpu_heartbeat != 0)			\
		{					\
			if ((--cpu_heartbeat) == 0)	\
			{				\
				dispatch_q_event();	\
				quick_mode = FALSE;	\
			}				\
		}					\
	}

#define QUICK_EVENT_TICK()	/* Nothing */

GLOBAL void SynchTick IFN0()
{
	quick_mode = FALSE;
	SYNCH_TICK();
}

#else	/* !SYNCH_TIMERS */

#define SYNCH_TICK()	/* Nothing */

#define QUICK_EVENT_TICK() 				\
	{						\
		if (cpu_heartbeat != 0)			\
		{					\
			if ((--cpu_heartbeat) == 0) {	\
				dispatch_q_event();	\
				quick_mode = FALSE;	\
			}				\
		}					\
	}

#endif /* SYNCH_TIMERS */
#else	/* SFELLOW */

extern IBOOL qEventsToDo;
extern IBOOL checkForQEvent IPT0();

#define SYNCH_TICK()

#define QUICK_EVENT_TICK() 				\
	{						\
		if (qEventsToDo)			\
		{					\
			if (checkForQEvent())		\
			{				\
				dispatch_q_event();	\
				quick_mode = FALSE;	\
			}				\
		}					\
	}

#ifdef host_timer_event
#undef host_timer_event
#endif

#define host_timer_event()
#endif	/* SFELLOW */

#ifdef SFELLOW
extern int ica_intack IPT0();
extern int VectorBase8259Slave IPT0();
#if !defined(PROD)
IMPORT IBOOL sf_debug_char_waiting();
#endif	/* !PROD */
#endif	/* SFELLOW */


/* debugging stuff */
IMPORT int do_condition_checks;
IMPORT void check_I();

/*
   Define macros which allow Intel and host IP formats to be maintained
   seperately. This is an 'unclean' implementation but does give a
   significant performance boost. Specifically it means during the
   decode of one Intel instruction we can use a host pointer into
   memory and avoid incrementing the Intel IP on a byte by byte basis.
 */

/*
 * SasWrapMask
 */

GLOBAL	PHY_ADDR	SasWrapMask = 0xfffff;

/* update Intel format EIP from host format IP
 * Note we only mask to 16 bits if the original EIP was 16bits so that
 * pigger scripts that result in very large EIP values pig correctly.
 */
#define UPDATE_INTEL_IP(x)						\
   {  int len = DIFF_INST_BYTE(x, p_start);				\
      IU32 mask = 0xFFFFFFFF;						\
      IU32 oldEIP = GET_EIP();						\
      if ((oldEIP < 0x10000) && (GET_CS_AR_X() == USE16))		\
          mask = 0xFFFF;						\
      SET_EIP((oldEIP + len) & mask);					\
   }

/* update Intel format EIP from host format IP (mask if 16 operand) */
#define UPDATE_INTEL_IP_USE_OP_SIZE(x)					\
   if ( GET_OPERAND_SIZE() == USE16 )					\
      SET_EIP(GET_EIP() + DIFF_INST_BYTE(x, p_start) & WORD_MASK);\
   else								\
      SET_EIP(GET_EIP() + DIFF_INST_BYTE(x, p_start));

/* mark host format IP as inoperative */
#define CANCEL_HOST_IP()					\
   quick_mode = FALSE;	\
   p_start = p = (IU8 *)0;

/* setup host format IP from Intel format IP */
/*    and set up end of page marker          */
#ifdef PIG
#define SETUP_HOST_IP(x)							\
   ip_phy_addr = usr_chk_byte(GET_CS_BASE() + GET_EIP(), PG_R) & SasWrapMask;	\
   x = Sas.SasPtrToPhysAddrByte(ip_phy_addr);					\
   pg_end = AddCpuPtrLS8(CeilingIntelPageLS8(x), 1);
#else /* !PIG */
GLOBAL UTINY *CCPU_M;
#ifdef BACK_M
#define SETUP_HOST_IP(x)							\
   ip_phy_addr = usr_chk_byte(GET_CS_BASE() + GET_EIP(), PG_R) &		\
		    SasWrapMask;						\
   x = &CCPU_M[-ip_phy_addr];							\
   ip_phy_addr = (ip_phy_addr & ~0xfff) + 0x1000;				\
   pg_end = &CCPU_M[-ip_phy_addr];
#else
#define SETUP_HOST_IP(x)							\
   ip_phy_addr = usr_chk_byte(GET_CS_BASE() + GET_EIP(), PG_R) &		\
		    SasWrapMask;						\
   x = &CCPU_M[ip_phy_addr];							\
   ip_phy_addr = (ip_phy_addr & ~0xfff) + 0x1000;				\
   pg_end = &CCPU_M[ip_phy_addr];
#endif /* BACK_M */
#endif /* PIG */

GLOBAL INT   m_seg[3];		/* Memory Operand segment reg. index. */
GLOBAL ULONG m_off[3];		/* Memory Operand offset. */
GLOBAL ULONG m_la[3];		/* Memory Operand Linear Addr. */
GLOBAL ULONG m_pa[3];		/* Memory Operand Physical Addr. */
GLOBAL UTINY modRM;		/* The modRM byte. */
GLOBAL UTINY segment_override;	/* Segment Prefix for current inst. */
GLOBAL UTINY *p;		/* Pntr. to Intel Opcode Stream. */
GLOBAL BOOL m_isreg[3];		/* Memory Operand Register(true)/
				   Memory(false) indicator */
GLOBAL OPERAND ops[3];		/* Inst. Operands. */
GLOBAL ULONG save_id[3];		/* Saved state for Inst. Operands. */
GLOBAL ULONG m_la2[3];		/* Memory Operand(2) Linear Addr. */
GLOBAL ULONG m_pa2[3];		/* Memory Operand(2) Physical Addr. */

#if defined(PIG) && defined(SFELLOW)
/*
 * memory-mapped I/O information. Counts number of memory-mapped inputs and
 * outputs since the last pig synch.
 */
GLOBAL	struct pig_mmio_info	pig_mmio_info;

#endif /* PIG && SFELLOW */

extern void InitNpx IPT1(IBOOL, disable);

/*
   =====================================================================
   INTERNAL FUNCTIONS START HERE.
   =====================================================================
 */

/*
 * invalidFunction
 *
 * This function will get called if we try to call through the wrong instruction
 * pointer.
 */

LOCAL VOID
invalidFunction IFN0()
{
	always_trace0("Invalid Instruction Function Pointer");
	force_yoda();
}

/*
 * note_486_instruction
 *
 * This function will get called if we execute a 486-only instruction
 */

GLOBAL VOID
note_486_instruction IFN1(char *, text)
{
	SAVED IBOOL first = TRUE;
	SAVED IBOOL want_yoda;
	SAVED IBOOL want_trace;

	if (first)
	{
		char *env = getenv("NOTE_486_INSTRUCTION");

		if (env)
		{
			want_yoda = FALSE;
			want_trace = TRUE;
			if (strcmp(env, "YODA") == 0)
			{
				want_yoda = TRUE;
				want_trace = TRUE;
			}
			if (strcmp(env, "FALSE") == 0)
				want_trace = FALSE;
			if (strcmp(env, "TRUE") == 0)
				want_trace = TRUE;
		}
		first = FALSE;
	}
	if (want_trace)
		always_trace0(text);
	if (want_yoda)
		force_yoda();
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Internal entry point to CPU.                                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
ccpu
                 
IFN1(
	ISM32, single_step
    )


   {
      /* Decoding variables */
   IU8 opcode;		/* Last Opcode Byte Read. */

   /*
    * A set of function pointers used for pointing to the instruction
    * emmulation function for the current instruction.  We have different
    * ones because they need to be of different types.
    * 
    * The name encoding uses 32, 16, or 8 for the size of the parameters,
    * preceded by a p if it is a pointer.  If the parameter string is preceded
    * by a 2, then this is the second function required by some instructions.
    *
    * For safety, these are all set to point at invalidFunction() at the start
    * of each instruction.
    */

   VOID (*inst32) IPT1(IU32, op1);
   VOID (*instp32) IPT1(IU32 *, pop1);
   VOID (*instp328) IPT2(IU32 *, pop1, IUM8, op_sz);
   VOID (*instp3232) IPT2(IU32 *, pop1, IU32, op2);
   VOID (*instp32p32) IPT2(IU32 *, pop1, IU32 *, pop2);
   VOID (*inst32328) IPT3(IU32, op1, IU32, op2, IUM8, op_sz);
   VOID (*instp32328) IPT3(IU32 *, pop1, IU32, op2, IUM8, op_sz);
   VOID (*instp3232328) IPT4(IU32 *, pop1, IU32, op2, IU32, op3, IUM8, op_sz);

   VOID (*inst232) IPT1(IU32, op1);
   VOID (*inst2p32) IPT1(IU32 *, pop1);
   VOID (*inst2p3232) IPT2(IU32 *, pop1, IU32, op2);

      /* Operand State variables */

      /* Prefix handling variables */
   IU8 repeat;		/* Repeat Prefix for current inst. */
   IU32 rep_count;		/* Repeat Count for string insts. */

      /* General CPU variables */
   IU32 ip_phy_addr;		/* Used when setting up IP */

      /* Working variables */
   IU32 immed;			/* For immediate generation. */

   ISM32 i;
   /*
      Initialise.   ----------------------------------------------------
    */

   single_instruction_delay = FALSE;
   took_relative_jump = FALSE;
   took_absolute_toc = FALSE;
#ifdef PIG
   pig_synch_required = FALSE;
#if defined(SFELLOW)
   pig_mmio_info.flags &= ~(MM_INPUT_OCCURRED | MM_OUTPUT_OCCURRED);
#endif	/* SFELLOW */
#endif	/* PIG */

   /* somewhere for exceptions to return to */
#ifdef NTVDM
   setjmp(ccpu386ThrdExptnPtr());
#else
   setjmp(next_inst[simulate_level-1]);
#endif

#ifdef SYNCH_TIMERS
   /* If we have taken a fault the EDL Cpu will have checked on
    * the resulting transfer of control.
    */
   if (took_absolute_toc || took_relative_jump)
	   goto CHECK_INTERRUPT;
   quick_mode = TRUE;
#else /* SYNCH_TIMERS */
   /* go slow until we are sure we can go fast */
   quick_mode = FALSE;
#endif /* SYNCH_TIMERS */

   goto NEXT_INST;

DO_INST:


   /* INSIGNIA debugging */
#ifdef	PIG
   /* We do not want to do check_I() in both CPUs */
#else	/* PIG */
   if ( do_condition_checks )
      {
      check_I();
      CCPU_save_EIP = GET_EIP();   /* in case yoda changed IP */
      }
#endif	/* !PIG */

#ifdef	PIG
   save_last_inst_details(NULL);
   prefix_length = 0;
#endif

   QUICK_EVENT_TICK();

   /* save beginning of the current instruction */

   p_start = p;

   /*
      Decode instruction.   --------------------------------------------
    */

   /* 'zero' all prefix byte indicators */
   segment_override = SEG_CLR;
   repeat = REP_CLR;

   /*
      Decode and Action instruction.
    */
DECODE:

   opcode = GET_INST_BYTE(p);	/* get next byte */
   /*
      NB. Each opcode is categorised by a type, instruction name
      and operand names. The type and operand names are explained
      further in c_oprnd.h.
    */
   switch ( opcode )
      {
   case 0x00:   /* T5 ADD Eb Gb */
      instp32328 = ADD;
TYPE00:

      modRM = GET_INST_BYTE(p);
      D_Eb(0, RW0, PG_W);
      D_Gb(1);
      F_Eb(0);
      F_Gb(1);
      (*instp32328)(&ops[0].sng, ops[1].sng, 8);
      P_Eb(0);
      break;

   case 0x01:   /* T5 ADD Ev Gv */
      instp32328 = ADD;
TYPE01:

      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ew(0, RW0, PG_W);
	 D_Gw(1);
	 F_Ew(0);
	 F_Gw(1);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 16);
	 P_Ew(0);
	 }
      else   /* USE32 */
	 {
	 D_Ed(0, RW0, PG_W);
	 D_Gd(1);
	 F_Ed(0);
	 F_Gd(1);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 32);
	 P_Ed(0);
	 }
      break;

   case 0x02:   /* T5 ADD Gb Eb */
      instp32328 = ADD;
TYPE02:

      modRM = GET_INST_BYTE(p);
      D_Gb(0);
      D_Eb(1, RO1, PG_R);
      F_Gb(0);
      F_Eb(1);
      (*instp32328)(&ops[0].sng, ops[1].sng, 8);
      P_Gb(0);
      break;

   case 0x03:   /* T5 ADD Gv Ev */
      instp32328 = ADD;
TYPE03:

      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Gw(0);
	 D_Ew(1, RO1, PG_R);
	 F_Gw(0);
	 F_Ew(1);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 16);
	 P_Gw(0);
	 }
      else   /* USE32 */
	 {
	 D_Gd(0);
	 D_Ed(1, RO1, PG_R);
	 F_Gd(0);
	 F_Ed(1);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 32);
	 P_Gd(0);
	 }
      break;

   case 0x04:   /* T5 ADD Fal Ib */
      instp32328 = ADD;
TYPE04:

      D_Ib(1);
      F_Fal(0);
      (*instp32328)(&ops[0].sng, ops[1].sng, 8);
      P_Fal(0);
      break;

   case 0x05:   /* T5 ADD F(e)ax Iv */
      instp32328 = ADD;
TYPE05:

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Iw(1);
	 F_Fax(0);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 16);
	 P_Fax(0);
	 }
      else   /* USE32 */
	 {
	 D_Id(1);
	 F_Feax(0);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 32);
	 P_Feax(0);
	 }
      break;

   case 0x06:   /* T2 PUSH Pw */
   case 0x0e:
   case 0x16:
   case 0x1e:
      D_Pw(0);
      F_Pw(0);
      PUSH_SR(ops[0].sng);
      break;

   case 0x07:   /* T3 POP Pw */
   case 0x17:
   case 0x1f:
      D_Pw(0);
      POP_SR(ops[0].sng);
      if ( ops[0].sng == SS_REG )
         {
         /* locally update IP - interrupts are supressed after POP SS */
         UPDATE_INTEL_IP(p);

         goto NEXT_INST;
         }
      break;

   case 0x08:   /* T5 OR Eb Gb */       instp32328 = OR;   goto TYPE00;
   case 0x09:   /* T5 OR Ev Gv */       instp32328 = OR;   goto TYPE01;
   case 0x0a:   /* T5 OR Gb Eb */       instp32328 = OR;   goto TYPE02;
   case 0x0b:   /* T5 OR Gv Ev */       instp32328 = OR;   goto TYPE03;
   case 0x0c:   /* T5 OR Fal Ib */      instp32328 = OR;   goto TYPE04;
   case 0x0d:   /* T5 OR F(e)ax Iv */   instp32328 = OR;   goto TYPE05;

   case 0x0f:
      opcode = GET_INST_BYTE(p);   /* get next opcode byte */

      /* Remove Empty Top of Table here. */
      if ( opcode >= 0xd0 )
	 Int6();

      switch ( opcode )
	 {
      case  0x00:
	 if ( GET_PE() == 0 || GET_VM() == 1 )
	    Int6();
	 modRM = GET_INST_BYTE(p);
	 switch ( GET_XXX(modRM) )
	    {
	 case 0:   /* T3 SLDT Ew */
	    instp32 = SLDT;
TYPE0F00_0:

	    D_Ew(0, WO0, PG_W);
	    (*instp32)(&ops[0].sng);
	    P_Ew(0);
	    break;

	 case 1:   /* T3 STR  Ew */   instp32 = STR;    goto TYPE0F00_0;

	 case 2:   /* T2 LLDT Ew */
	    if ( GET_CPL() != 0 )
	       GP((IU16)0, FAULT_CCPU_LLDT_ACCESS);
	    inst32 = LLDT;
TYPE0F00_2:

	    D_Ew(0, RO0, PG_R);
	    F_Ew(0);
	    (*inst32)(ops[0].sng);
	    break;

	 case 3:   /* T2 LTR Ew */
	    if ( GET_CPL() != 0 )
	       GP((IU16)0, FAULT_CCPU_LTR_ACCESS);
	    inst32 = LTR;
	    goto TYPE0F00_2;

	 case 4:   /* T2 VERR Ew */   inst32 = VERR;   goto TYPE0F00_2;
	 case 5:   /* T2 VERW Ew */   inst32 = VERW;   goto TYPE0F00_2;

	 case 6: case 7:

	    Int6();
	    break;
	    } /* end switch ( GET_XXX(modRM) ) */
	 break;

      case  0x01:
	 modRM = GET_INST_BYTE(p);
	 switch ( GET_XXX(modRM) )
	    {
	 case 0:   /* T3 SGDT Ms */
	    instp32  = SGDT16;
	    inst2p32 = SGDT32;
TYPE0F01_0:

	    if ( GET_MODE(modRM) == 3 )
	       Int6();   /* Register operand not allowed */

	    D_Ms(0, WO0, PG_W);
	    if ( GET_OPERAND_SIZE() == USE16 )
	       {
	       (*instp32)(ops[0].mlt);
	       }
	    else   /* USE32 */
	       {
	       (*inst2p32)(ops[0].mlt);
	       }
	    P_Ms(0);
	    break;

	 case 1:   /* T3 SIDT Ms */
	    instp32  = SIDT16;
	    inst2p32 = SIDT32;
	    goto TYPE0F01_0;

	 case 2:   /* T2 LGDT Ms */
	    instp32  = LGDT16;
	    inst2p32 = LGDT32;
TYPE0F01_2:

	    if ( GET_MODE(modRM) == 3 )
	       Int6();   /* Register operand not allowed */

	    if ( GET_CPL() != 0 )
	       GP((IU16)0, FAULT_CCPU_LGDT_ACCESS);

	    D_Ms(0, RO0, PG_R);
	    F_Ms(0);
	    if ( GET_OPERAND_SIZE() == USE16 )
	       {
	       (*instp32)(ops[0].mlt);
	       }
	    else   /* USE32 */
	       {
	       (*inst2p32)(ops[0].mlt);
	       }
	    break;

	 case 3:   /* T2 LIDT Ms */
	    instp32  = LIDT16;
	    inst2p32 = LIDT32;
	    goto TYPE0F01_2;

	 case 4:   /* T3 SMSW Ew */
	    instp32 = SMSW;
	    goto TYPE0F00_0;

	 case 5:
	    Int6();
	    break;

	 case 6:   /* T2 LMSW Ew */
	    if ( GET_CPL() != 0 )
	       GP((IU16)0, FAULT_CCPU_LMSW_ACCESS);
	    inst32 = LMSW;
	    goto TYPE0F00_2;

	 case 7:   /* T2 INVLPG Mm */

#ifdef SPC486
	    note_486_instruction("INVLPG");

	    if ( GET_CPL() != 0 )
	       GP((IU16)0, FAULT_CCPU_INVLPG_ACCESS);
	    D_Mm(0);
	    F_Mm(0);
	    INVLPG(ops[0].sng);
#else
	    Int6();
#endif /* SPC486 */

	    break;
	    } /* end switch ( GET_XXX(modRM) ) */
	 break;

      case  0x02:   /* T5 LAR Gv Ew */
	 instp3232 = LAR;
TYPE0F02:

	 if ( GET_PE() == 0 || GET_VM() == 1 )
	    Int6();
	 modRM = GET_INST_BYTE(p);

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Gw(0);
	    D_Ew(1, RO1, PG_R);
	    F_Gw(0);
	    F_Ew(1);
	    (*instp3232)(&ops[0].sng, ops[1].sng);
	    P_Gw(0);
	    }
	 else   /* USE32 */
	    {
	    D_Gd(0);
	    D_Ew(1, RO1, PG_R);
	    F_Gd(0);
	    F_Ew(1);
	    (*instp3232)(&ops[0].sng, ops[1].sng);
	    P_Gd(0);
	    }
	 break;

      case  0x03:   /* T5 LSL Gv Ew */
	 instp3232 = LSL;
	 goto TYPE0F02;

      case  0x04: case  0x05: case  0x0a: case  0x0b:
      case  0x0c: case  0x0d: case  0x0e:

      case  0x14: case  0x15: case  0x16: case  0x17:
      case  0x18: case  0x19: case  0x1a: case  0x1b:
      case  0x1c: case  0x1d: case  0x1e: case  0x1f:

      case  0x25: case  0x27:
      case  0x28: case  0x29: case  0x2a: case  0x2b:
      case  0x2c: case  0x2d: case  0x2e: case  0x2f:

      case  0x30: case  0x31: case  0x32: case  0x33:
      case  0x34: case  0x35: case  0x36: case  0x37:
      case  0x38: case  0x39: case  0x3a: case  0x3b:
      case  0x3c: case  0x3d: case  0x3e: case  0x3f:

      case  0x40: case  0x41: case  0x42: case  0x43:
      case  0x44: case  0x45: case  0x46: case  0x47:
      case  0x48: case  0x49: case  0x4a: case  0x4b:
      case  0x4c: case  0x4d: case  0x4e: case  0x4f:

      case  0x50: case  0x51: case  0x52: case  0x53:
      case  0x54: case  0x55: case  0x56: case  0x57:
      case  0x58: case  0x59: case  0x5a: case  0x5b:
      case  0x5c: case  0x5d: case  0x5e: case  0x5f:

      case  0x60: case  0x61: case  0x62: case  0x63:
      case  0x64: case  0x65: case  0x66: case  0x67:
      case  0x68: case  0x69: case  0x6a: case  0x6b:
      case  0x6c: case  0x6d: case  0x6e: case  0x6f:

      case  0x70: case  0x71: case  0x72: case  0x73:
      case  0x74: case  0x75: case  0x76: case  0x77:
      case  0x78: case  0x79: case  0x7a: case  0x7b:
      case  0x7c: case  0x7d: case  0x7e: case  0x7f:

      case  0xae: case  0xb8: case  0xb9:

      case  0xc2: case  0xc3: case  0xc4: case  0xc5:
      case  0xc6: case  0xc7:
	 Int6();
	 break;

      case  0xa2:
	 /* Pentium CPUID instruction */
	 note_486_instruction("CPUID");
	 Int6();
	 break;

      case  0xa6: case  0xa7:
	 /* 386, A-Step archaic instruction */
	 note_486_instruction("A-step CMPXCHG");
	 Int6();
	 break;

      case 0xaa:
	 /* Pentium RSM instruction, used by Windows95 */
	 note_486_instruction("RSM");
	 RSRVD();
	 break;

      case  0x06:   /* T0 CLTS */
	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_CLTS_ACCESS);
	 CLTS();
	 break;

      case  0x07:   /* T0 "RESERVED" */
      case  0x10:
      case  0x11:
      case  0x12:
      case  0x13:
	 RSRVD();
	 break;

      case  0x08:   /* T0 INVD */

#ifdef SPC486
	 note_486_instruction("INVD");

	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_INVD_ACCESS);
	 INVD();
#else
	 Int6();
#endif /* SPC486 */

	 break;

      case  0x09:   /* T0 WBINVD */

#ifdef SPC486
	 note_486_instruction("WBINVD");

	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_WBIND_ACCESS);
	 WBINVD();
#else
	 Int6();
#endif /* SPC486 */

	 break;

      case  0x0f:
#ifdef PIG
	 SET_EIP(CCPU_save_EIP);
	 CANCEL_HOST_IP();
	 PIG_SYNCH(CHECK_NO_EXEC);
#else
	 Int6();
#endif /* PIG */
	 break;

      case  0x20:   /* T4 MOV Rd Cd */
	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_MOV_R_C_ACCESS);
	 modRM = GET_INST_BYTE(p);
	 D_Rd(0);
	 D_Cd(1);
	 F_Cd(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Rd(0);
	 break;

      case  0x21:   /* T4 MOV Rd Dd */
	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_MOV_R_D_ACCESS);
	 modRM = GET_INST_BYTE(p);
	 D_Rd(0);
	 D_Dd(1);
	 F_Dd(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Rd(0);
	 break;

      case  0x22:   /* T4 MOV Cd Rd */
	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_MOV_C_R_ACCESS);
	 modRM = GET_INST_BYTE(p);
	 D_Cd(0);
	 D_Rd(1);
	 F_Rd(1);
	 MOV_CR(ops[0].sng, ops[1].sng);
	 break;

      case  0x23:   /* T4 MOV Dd Rd */
	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_MOV_D_R_ACCESS);
	 modRM = GET_INST_BYTE(p);
	 D_Dd(0);
	 D_Rd(1);
	 F_Rd(1);
	 MOV_DR(ops[0].sng, ops[1].sng);
	 quick_mode = FALSE;
	 break;

      case  0x24:   /* T4 MOV Rd Td */
	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_MOV_R_T_ACCESS);
	 modRM = GET_INST_BYTE(p);
	 D_Rd(0);
	 D_Td(1);
	 F_Td(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Rd(0);
	 break;

      case  0x26:   /* T4 MOV Td Rd */
	 if ( GET_CPL() != 0 )
	    GP((IU16)0, FAULT_CCPU_MOV_T_R_ACCESS);
	 modRM = GET_INST_BYTE(p);
	 D_Td(0);
	 D_Rd(1);
	 F_Rd(1);
	 MOV_TR(ops[0].sng, ops[1].sng);
	 break;

      case  0x80:   /* T2 JO   Jv */
	 inst32 = JO;
TYPE0F80:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Jw(0);
	    }
	 else
	    {
	    D_Jd(0);
	    }
	 UPDATE_INTEL_IP_USE_OP_SIZE(p);
	 (*inst32)(ops[0].sng);
	 CANCEL_HOST_IP();
#ifdef SYNCH_BOTH_WAYS
	 took_relative_jump = TRUE;
#endif	/* SYNCH_BOTH_WAYS */
	 if (took_relative_jump)
	 {
		 PIG_SYNCH(CHECK_ALL);
	 }
	 break;

      case  0x81:   /* T2 JNO  Jv */   inst32 = JNO;    goto TYPE0F80;
      case  0x82:   /* T2 JB   Jv */   inst32 = JB;     goto TYPE0F80;
      case  0x83:   /* T2 JNB  Jv */   inst32 = JNB;    goto TYPE0F80;
      case  0x84:   /* T2 JZ   Jv */   inst32 = JZ;     goto TYPE0F80;
      case  0x85:   /* T2 JNZ  Jv */   inst32 = JNZ;    goto TYPE0F80;
      case  0x86:   /* T2 JBE  Jv */   inst32 = JBE;    goto TYPE0F80;
      case  0x87:   /* T2 JNBE Jv */   inst32 = JNBE;   goto TYPE0F80;
      case  0x88:   /* T2 JS   Jv */   inst32 = JS;     goto TYPE0F80;
      case  0x89:   /* T2 JNS  Jv */   inst32 = JNS;    goto TYPE0F80;
      case  0x8a:   /* T2 JP   Jv */   inst32 = JP;     goto TYPE0F80;
      case  0x8b:   /* T2 JNP  Jv */   inst32 = JNP;    goto TYPE0F80;
      case  0x8c:   /* T2 JL   Jv */   inst32 = JL;     goto TYPE0F80;
      case  0x8d:   /* T2 JNL  Jv */   inst32 = JNL;    goto TYPE0F80;
      case  0x8e:   /* T2 JLE  Jv */   inst32 = JLE;    goto TYPE0F80;
      case  0x8f:   /* T2 JNLE Jv */   inst32 = JNLE;   goto TYPE0F80;

      case  0x90:   /* T3 SETO   Eb */
	 instp32 = SETO;
TYPE0F90:

	 modRM = GET_INST_BYTE(p);
	 D_Eb(0, WO0, PG_W);
	 (*instp32)(&ops[0].sng);
	 P_Eb(0);
	 break;

      case  0x91:   /* T3 SETNO  Eb */   instp32 = SETNO;    goto TYPE0F90;
      case  0x92:   /* T3 SETB   Eb */   instp32 = SETB;     goto TYPE0F90;
      case  0x93:   /* T3 SETNB  Eb */   instp32 = SETNB;    goto TYPE0F90;
      case  0x94:   /* T3 SETZ   Eb */   instp32 = SETZ;     goto TYPE0F90;
      case  0x95:   /* T3 SETNZ  Eb */   instp32 = SETNZ;    goto TYPE0F90;
      case  0x96:   /* T3 SETBE  Eb */   instp32 = SETBE;    goto TYPE0F90;
      case  0x97:   /* T3 SETNBE Eb */   instp32 = SETNBE;   goto TYPE0F90;
      case  0x98:   /* T3 SETS   Eb */   instp32 = SETS;     goto TYPE0F90;
      case  0x99:   /* T3 SETNS  Eb */   instp32 = SETNS;    goto TYPE0F90;
      case  0x9a:   /* T3 SETP   Eb */   instp32 = SETP;     goto TYPE0F90;
      case  0x9b:   /* T3 SETNP  Eb */   instp32 = SETNP;    goto TYPE0F90;
      case  0x9c:   /* T3 SETL   Eb */   instp32 = SETL;     goto TYPE0F90;
      case  0x9d:   /* T3 SETNL  Eb */   instp32 = SETNL;    goto TYPE0F90;
      case  0x9e:   /* T3 SETLE  Eb */   instp32 = SETLE;    goto TYPE0F90;
      case  0x9f:   /* T3 SETNLE Eb */   instp32 = SETNLE;   goto TYPE0F90;

      case  0xa0:   /* T2 PUSH Qw */
      case  0xa8:
	 D_Qw(0);
	 F_Qw(0);
	 PUSH_SR(ops[0].sng);
	 break;

      case  0xa1:   /* T3 POP Qw */
      case  0xa9:
	 D_Qw(0);
	 POP_SR(ops[0].sng);
	 break;

      case  0xa3:   /* T6 BT Ev Gv */
	 inst32328 = BT;
#ifndef FIX_BT_BUG
	goto TYPE39;
#endif
	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
            BT_OPSw(RO0, PG_R);
	    (*inst32328)(ops[0].sng, ops[1].sng, 16);
	    }
	 else   /* USE32 */
	    {
            BT_OPSd(RO0, PG_R);
	    (*inst32328)(ops[0].sng, ops[1].sng, 32);
	    }
	 break;

      case  0xa4:   /* T9 SHLD Ev Gv Ib */
	 instp3232328 = SHLD;
TYPE0FA4:

	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RW0, PG_W);
	    D_Gw(1);
	    D_Ib(2);
	    F_Ew(0);
	    F_Gw(1);
	    (*instp3232328)(&ops[0].sng, ops[1].sng, ops[2].sng, 16);
	    P_Ew(0);
	    }
	 else
	    {
	    D_Ed(0, RW0, PG_W);
	    D_Gd(1);
	    D_Ib(2);
	    F_Ed(0);
	    F_Gd(1);
	    (*instp3232328)(&ops[0].sng, ops[1].sng, ops[2].sng, 32);
	    P_Ed(0);
	    }
	 break;

      case  0xa5:   /* T9 SHLD Ev Gv Fcl */
	 instp3232328 = SHLD;
TYPE0FA5:

	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RW0, PG_W);
	    D_Gw(1);
	    F_Ew(0);
	    F_Gw(1);
	    F_Fcl(2);
	    (*instp3232328)(&ops[0].sng, ops[1].sng, ops[2].sng, 16);
	    P_Ew(0);
	    }
	 else
	    {
	    D_Ed(0, RW0, PG_W);
	    D_Gd(1);
	    F_Ed(0);
	    F_Gd(1);
	    F_Fcl(2);
	    (*instp3232328)(&ops[0].sng, ops[1].sng, ops[2].sng, 32);
	    P_Ed(0);
	    }
	 break;

      case  0xab:   /* T5 BTS Ev Gv */
	 instp32328 = BTS;
#ifndef FIX_BT_BUG
	goto TYPE01;
#endif
TYPE0FAB:
	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
            BT_OPSw(RW0, PG_W);
	    (*instp32328)(&ops[0].sng, ops[1].sng, 16);
            P_Ew(0);
	    }
	 else   /* USE32 */
	    {
            BT_OPSd(RW0, PG_W);
	    (*instp32328)(&ops[0].sng, ops[1].sng, 32);
            P_Ed(0);
	    }
	 break;

      case  0xac:   /* T9 SHRD Ev Gv Ib */
	 instp3232328 = SHRD;
	 goto TYPE0FA4;

      case  0xad:   /* T9 SHRD Ev Gv Fcl */
	 instp3232328 = SHRD;
	 goto TYPE0FA5;

      case  0xaf:   /* T5 IMUL Gv Ev */
	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Gw(0);
	    D_Ew(1, RO1, PG_R);
	    F_Gw(0);
	    F_Ew(1);
	    IMUL16T(&ops[0].sng, ops[0].sng, ops[1].sng);
	    P_Gw(0);
	    }
	 else
	    {
	    D_Gd(0);
	    D_Ed(1, RO1, PG_R);
	    F_Gd(0);
	    F_Ed(1);
	    IMUL32T(&ops[0].sng, ops[0].sng, ops[1].sng);
	    P_Gd(0);
	    }
	 break;

      case  0xb0:   /* T5 CMPXCHG Eb Gb */

#ifdef SPC486
	 note_486_instruction("CMPXCHG Eb Gb");

	 modRM = GET_INST_BYTE(p);
	 D_Eb(0, RW0, PG_W);
	 D_Gb(1);
	 F_Eb(0);
	 F_Gb(1);
	 CMPXCHG8(&ops[0].sng, ops[1].sng);
	 P_Eb(0);
#else
	 Int6();
#endif /* SPC486 */

	 break;

      case  0xb1:   /* T5 CMPXCHG Ev Gv */

#ifdef SPC486
	 note_486_instruction("CMPXCHG Ev Gv");

	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RW0, PG_W);
	    D_Gw(1);
	    F_Ew(0);
	    F_Gw(1);
	    CMPXCHG16(&ops[0].sng, ops[1].sng);
	    P_Ew(0);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RW0, PG_W);
	    D_Gd(1);
	    F_Ed(0);
	    F_Gd(1);
	    CMPXCHG32(&ops[0].sng, ops[1].sng);
	    P_Ed(0);
	    }
#else
	 Int6();
#endif /* SPC486 */

	 break;

      case  0xb2:   /* T4 LSS Gv Mp */   instp32p32 = LSS;   goto TYPEC4;
#ifndef FIX_BT_BUG
      case  0xb3:   /* T5 BTR Ev Gv */   instp32328 = BTR;   goto TYPE01;
#else
      case  0xb3:   /* T5 BTR Ev Gv */   instp32328 = BTR;   goto TYPE0FAB;
#endif
      case  0xb4:   /* T4 LFS Gv Mp */   instp32p32 = LFS;   goto TYPEC4;
      case  0xb5:   /* T4 LGS Gv Mp */   instp32p32 = LGS;   goto TYPEC4;

      case  0xb6:   /* T4 MOVZX Gv Eb */
	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Gw(0);
	    D_Eb(1, RO1, PG_R);
	    F_Eb(1);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    P_Gw(0);
	    }
	 else
	    {
	    D_Gd(0);
	    D_Eb(1, RO1, PG_R);
	    F_Eb(1);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    P_Gd(0);
	    }
	 break;

      case  0xb7:   /* T4 MOVZX Gd Ew */
	 modRM = GET_INST_BYTE(p);
	 D_Gd(0);
	 D_Ew(1, RO1, PG_R);
	 F_Ew(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Gd(0);
	 break;

      case  0xba:
	 modRM = GET_INST_BYTE(p);
	 switch ( GET_XXX(modRM) )
	    {
	 case 0: case 1: case 2: case 3:
	    Int6();
	    break;

	 case 4:   /* T6 BT Ev Ib */
	    if ( GET_OPERAND_SIZE() == USE16 )
	       {
	       D_Ew(0, RO0, PG_R);
	       D_Ib(1);
	       F_Ew(0);
	       BT(ops[0].sng, ops[1].sng, 16);
	       }
	    else
	       {
	       D_Ed(0, RO0, PG_R);
	       D_Ib(1);
	       F_Ed(0);
	       BT(ops[0].sng, ops[1].sng, 32);
	       }
	    break;

	 case 5:   /* T5 BTS Ev Ib */   instp32328 = BTS;   goto TYPEC1;
	 case 6:   /* T5 BTR Ev Ib */   instp32328 = BTR;   goto TYPEC1;
	 case 7:   /* T5 BTC Ev Ib */   instp32328 = BTC;   goto TYPEC1;
	    } /* end switch ( GET_XXX(modRM) ) */
	 break;

      case  0xbb:   /* T5 BTC Ev Gv */
	 instp32328 = BTC;
#ifndef FIX_BT_BUG
	 goto TYPE01;
#else
	 goto TYPE0FAB;
#endif
      case  0xbc:   /* T5 BSF Gv Ev */
	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Gw(0);
	    D_Ew(1, RO1, PG_R);
	    F_Gw(0);
	    F_Ew(1);
	    BSF(&ops[0].sng, ops[1].sng);
	    P_Gw(0);
	    }
	 else
	    {
	    D_Gd(0);
	    D_Ed(1, RO1, PG_R);
	    F_Gd(0);
	    F_Ed(1);
	    BSF(&ops[0].sng, ops[1].sng);
	    P_Gd(0);
	    }
	 break;

      case  0xbd:   /* T5 BSR Gv Ev */
	 instp32328 = BSR;
	 goto TYPE03;

      case  0xbe:   /* T4 MOVSX Gv Eb */
	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Gw(0);
	    D_Eb(1, RO1, PG_R);
	    F_Eb(1);
	    MOVSX(&ops[0].sng, ops[1].sng, 8);
	    P_Gw(0);
	    }
	 else
	    {
	    D_Gd(0);
	    D_Eb(1, RO1, PG_R);
	    F_Eb(1);
	    MOVSX(&ops[0].sng, ops[1].sng, 8);
	    P_Gd(0);
	    }
	 break;

      case  0xbf:   /* T4 MOVSX Gd Ew */
	 modRM = GET_INST_BYTE(p);
	 D_Gd(0);
	 D_Ew(1, RO1, PG_R);
	 F_Ew(1);
	 MOVSX(&ops[0].sng, ops[1].sng, 16);
	 P_Gd(0);
	 break;

      case  0xc0:   /* T8 XADD Eb Gb */

#ifdef SPC486
	 note_486_instruction("XADD Eb Gb");

	 modRM = GET_INST_BYTE(p);
	 D_Eb(0, RW0, PG_W);
	 D_Gb(1);
	 F_Eb(0);
	 F_Gb(1);
	 XADD(&ops[0].sng, &ops[1].sng, 8);
	 P_Eb(0);
	 P_Gb(1);
#else
	 Int6();
#endif /* SPC486 */

	 break;

      case  0xc1:   /* T8 XADD Ev Gv */

#ifdef SPC486
	 note_486_instruction("XADD Ev Gv");

	 modRM = GET_INST_BYTE(p);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RW0, PG_W);
	    D_Gw(1);
	    F_Ew(0);
	    F_Gw(1);
	    XADD(&ops[0].sng, &ops[1].sng, 16);
	    P_Ew(0);
	    P_Gw(1);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RW0, PG_W);
	    D_Gd(1);
	    F_Ed(0);
	    F_Gd(1);
	    XADD(&ops[0].sng, &ops[1].sng, 32);
	    P_Ed(0);
	    P_Gd(1);
	    }
#else
	 Int6();
#endif /* SPC486 */

	 break;

      case  0xc8:   /* T1 BSWAP Hv */
      case  0xc9:
      case  0xca:
      case  0xcb:
      case  0xcc:
      case  0xcd:
      case  0xce:
      case  0xcf:

#ifdef SPC486
	 note_486_instruction("BSWAP Hv");

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Hd(0);		/* BSWAP 16 bit reads 32 bit & writes 16 */
	    F_Hd(0);		/* so getting EAX -> EAX' -> AX */
	    BSWAP(&ops[0].sng);
	    P_Hw(0);
	    }
	 else   /* USE32 */
	    {
	    D_Hd(0);
	    F_Hd(0);
	    BSWAP(&ops[0].sng);
	    P_Hd(0);
	    }
#else
	 Int6();
#endif /* SPC486 */

	 break;
	 } /* end switch ( opcode ) 0F */
      break;

   case 0x10:   /* T5 ADC Eb Gb */       instp32328 = ADC;   goto TYPE00;
   case 0x11:   /* T5 ADC Ev Gv */       instp32328 = ADC;   goto TYPE01;
   case 0x12:   /* T5 ADC Gb Eb */       instp32328 = ADC;   goto TYPE02;
   case 0x13:   /* T5 ADC Gv Ev */       instp32328 = ADC;   goto TYPE03;
   case 0x14:   /* T5 ADC Fal Ib */      instp32328 = ADC;   goto TYPE04;
   case 0x15:   /* T5 ADC F(e)ax Iv */   instp32328 = ADC;   goto TYPE05;

   case 0x18:   /* T5 SBB Eb Gb */       instp32328 = SBB;   goto TYPE00;
   case 0x19:   /* T5 SBB Ev Gv */       instp32328 = SBB;   goto TYPE01;
   case 0x1a:   /* T5 SBB Gb Eb */       instp32328 = SBB;   goto TYPE02;
   case 0x1b:   /* T5 SBB Gv Ev */       instp32328 = SBB;   goto TYPE03;
   case 0x1c:   /* T5 SBB Fal Ib */      instp32328 = SBB;   goto TYPE04;
   case 0x1d:   /* T5 SBB F(e)ax Iv */   instp32328 = SBB;   goto TYPE05;

   case 0x20:   /* T5 AND Eb Gb */       instp32328 = AND;   goto TYPE00;
   case 0x21:   /* T5 AND Ev Gv */       instp32328 = AND;   goto TYPE01;
   case 0x22:   /* T5 AND Gb Eb */       instp32328 = AND;   goto TYPE02;
   case 0x23:   /* T5 AND Gb Eb */       instp32328 = AND;   goto TYPE03;
   case 0x24:   /* T5 AND Fal Ib */      instp32328 = AND;   goto TYPE04;
   case 0x25:   /* T5 AND F(e)ax Iv */   instp32328 = AND;   goto TYPE05;

   case 0x26:
      segment_override = ES_REG;
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0x27:   /* T0 DAA */
      DAA();
      break;

   case 0x28:   /* T5 SUB Eb Gb */       instp32328 = SUB;   goto TYPE00;
   case 0x29:   /* T5 SUB Ev Gv */       instp32328 = SUB;   goto TYPE01;
   case 0x2a:   /* T5 SUB Gb Eb */       instp32328 = SUB;   goto TYPE02;
   case 0x2b:   /* T5 SUB Gv Ev */       instp32328 = SUB;   goto TYPE03;
   case 0x2c:   /* T5 SUB Fal Ib */      instp32328 = SUB;   goto TYPE04;
   case 0x2d:   /* T5 SUB F(e)ax Iv */   instp32328 = SUB;   goto TYPE05;

   case 0x2e:
      segment_override = CS_REG;
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0x2f:   /* T0 DAS */
      DAS();
      break;

   case 0x30:   /* T5 XOR Eb Gb */       instp32328 = XOR;   goto TYPE00;
   case 0x31:   /* T5 XOR Ev Gv */       instp32328 = XOR;   goto TYPE01;
   case 0x32:   /* T5 XOR Gb Eb */       instp32328 = XOR;   goto TYPE02;
   case 0x33:   /* T5 XOR Gv Ev */       instp32328 = XOR;   goto TYPE03;
   case 0x34:   /* T5 XOR Fal Ib */      instp32328 = XOR;   goto TYPE04;
   case 0x35:   /* T5 XOR F(e)ax Iv */   instp32328 = XOR;   goto TYPE05;

   case 0x36:
      segment_override = SS_REG;
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0x37:   /* T0 AAA */
      AAA();
      break;

   case 0x38:   /* T6 CMP Eb Gb */
      inst32328 = CMP;
TYPE38:

      modRM = GET_INST_BYTE(p);
      D_Eb(0, RO0, PG_R);
      D_Gb(1);
      F_Eb(0);
      F_Gb(1);
      (*inst32328)(ops[0].sng, ops[1].sng, 8);
      break;

   case 0x39:   /* T6 CMP Ev Gv */
      inst32328 = CMP;
TYPE39:

      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ew(0, RO0, PG_R);
	 D_Gw(1);
	 F_Ew(0);
	 F_Gw(1);
	 (*inst32328)(ops[0].sng, ops[1].sng, 16);
	 }
      else   /* USE32 */
	 {
	 D_Ed(0, RO0, PG_R);
	 D_Gd(1);
	 F_Ed(0);
	 F_Gd(1);
	 (*inst32328)(ops[0].sng, ops[1].sng, 32);
	 }
      break;

   case 0x3a:   /* T6 CMP Gb Eb */
      modRM = GET_INST_BYTE(p);
      D_Gb(0);
      D_Eb(1, RO1, PG_R);
      F_Gb(0);
      F_Eb(1);
      CMP(ops[0].sng, ops[1].sng, 8);
      break;

   case 0x3b:   /* T6 CMP Gv Ev */
      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Gw(0);
	 D_Ew(1, RO1, PG_R);
	 F_Gw(0);
	 F_Ew(1);
	 CMP(ops[0].sng, ops[1].sng, 16);
	 }
      else   /* USE32 */
	 {
	 D_Gd(0);
	 D_Ed(1, RO1, PG_R);
	 F_Gd(0);
	 F_Ed(1);
	 CMP(ops[0].sng, ops[1].sng, 32);
	 }
      break;

   case 0x3c:   /* T6 CMP Fal Ib */
      inst32328 = CMP;
TYPE3C:

      D_Ib(1);
      F_Fal(0);
      (*inst32328)(ops[0].sng, ops[1].sng, 8);
      break;

   case 0x3d:   /* T6 CMP F(e)ax Iv */
      inst32328 = CMP;
TYPE3D:

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Iw(1);
	 F_Fax(0);
	 (*inst32328)(ops[0].sng, ops[1].sng, 16);
	 }
      else   /* USE32 */
	 {
	 D_Id(1);
	 F_Feax(0);
	 (*inst32328)(ops[0].sng, ops[1].sng, 32);
	 }
      break;

   case 0x3e:
      segment_override = DS_REG;
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0x3f:   /* T0 AAS */
      AAS();
      break;

   case 0x40:   /* T1 INC Hv */
   case 0x41:
   case 0x42:
   case 0x43:
   case 0x44:
   case 0x45:
   case 0x46:
   case 0x47:
      instp328 = INC;
TYPE40:

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Hw(0);
	 F_Hw(0);
	 (*instp328)(&ops[0].sng, 16);
	 P_Hw(0);
	 }
      else   /* USE32 */
	 {
	 D_Hd(0);
	 F_Hd(0);
	 (*instp328)(&ops[0].sng, 32);
	 P_Hd(0);
	 }
      break;

   case 0x48:   /* T1 DEC Hv */
   case 0x49:
   case 0x4a:
   case 0x4b:
   case 0x4c:
   case 0x4d:
   case 0x4e:
   case 0x4f:
      instp328 = DEC;
      goto TYPE40;

   case 0x50:   /* T2 PUSH Hv */
   case 0x51:
   case 0x52:
   case 0x53:
   case 0x54:
   case 0x55:
   case 0x56:
   case 0x57:
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Hw(0);
	 F_Hw(0);
	 }
      else   /* USE32 */
	 {
	 D_Hd(0);
	 F_Hd(0);
	 }
      PUSH(ops[0].sng);
      break;

   case 0x58:   /* T3 POP Hv */
   case 0x59:
   case 0x5a:
   case 0x5b:
   case 0x5c:
   case 0x5d:
   case 0x5e:
   case 0x5f:
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Hw(0);
	 POP(&ops[0].sng);
	 P_Hw(0);
	 }
      else   /* USE32 */
	 {
	 D_Hd(0);
	 POP(&ops[0].sng);
	 P_Hd(0);
	 }
      break;

   case 0x60:   /* T0 PUSHA */
      PUSHA();
      break;

   case 0x61:   /* T0 POPA */
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 POPA();
	 }
      else   /* USE32 */
	 {
	 POPAD();
	 }
      break;

   case 0x62:   /* T6 BOUND Gv Ma */
      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Gw(0);
	 D_Ma16(1, RO1, PG_R);
	 F_Gw(0);
	 F_Ma16(1);
	 BOUND(ops[0].sng, ops[1].mlt, 16);
	 }
      else   /* USE32 */
	 {
	 D_Gd(0);
	 D_Ma32(1, RO1, PG_R);
	 F_Gd(0);
	 F_Ma32(1);
	 BOUND(ops[0].sng, ops[1].mlt, 32);
	 }
      break;

   case 0x63:   /* T5 ARPL Ew Gw */
      if ( GET_PE() == 0 || GET_VM() == 1 )
	 Int6();
      modRM = GET_INST_BYTE(p);
      D_Ew(0, RW0, PG_W);
      D_Gw(1);
      F_Ew(0);
      F_Gw(1);
      ARPL(&ops[0].sng, ops[1].sng);
      P_Ew(0);
      break;

   case 0x64:
      segment_override = FS_REG;
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0x65:
      segment_override = GS_REG;
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0x66:
      SET_OPERAND_SIZE(GET_CS_AR_X());
      if ( GET_OPERAND_SIZE() == USE16 )
	SET_OPERAND_SIZE(USE32);
      else   /* USE32 */
	SET_OPERAND_SIZE(USE16);
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0x67:
      SET_ADDRESS_SIZE(GET_CS_AR_X());
      if ( GET_ADDRESS_SIZE() == USE16 )
	SET_ADDRESS_SIZE(USE32);
      else   /* USE32 */
	SET_ADDRESS_SIZE(USE16);
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0x68:   /* T2 PUSH Iv */
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Iw(0);
	 }
      else   /* USE32 */
	 {
	 D_Id(0);
	 }
      PUSH(ops[0].sng);
      break;

   case 0x69:   /* T7 IMUL Gv Ev Iv */
      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Gw(0);
	 D_Ew(1, RO1, PG_R);
	 D_Iw(2);
	 F_Gw(0);
	 F_Ew(1);
	 IMUL16T(&ops[0].sng, ops[1].sng, ops[2].sng);
	 P_Gw(0);
	 }
      else   /* USE32 */
	 {
	 D_Gd(0);
	 D_Ed(1, RO1, PG_R);
	 D_Id(2);
	 F_Gd(0);
	 F_Ed(1);
	 IMUL32T(&ops[0].sng, ops[1].sng, ops[2].sng);
	 P_Gd(0);
	 }
      break;

   case 0x6a:   /* T2 PUSH Ib */
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ix(0);
	 }
      else   /* USE32 */
	 {
	 D_Iy(0);
	 }
      PUSH(ops[0].sng);
      break;

   case 0x6b:   /* T7 IMUL Gv Ev Ib */
      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Gw(0);
	 D_Ew(1, RO1, PG_R);
	 D_Ix(2);
	 F_Gw(0);
	 F_Ew(1);
	 IMUL16T(&ops[0].sng, ops[1].sng, ops[2].sng);
	 P_Gw(0);
	 }
      else   /* USE32 */
	 {
	 D_Gd(0);
	 D_Ed(1, RO1, PG_R);
	 D_Iy(2);
	 F_Gd(0);
	 F_Ed(1);
	 IMUL32T(&ops[0].sng, ops[1].sng, ops[2].sng);
	 P_Gd(0);
	 }
      break;

   case 0x6c:   /* T4 INSB Yb Fdx */
      STRING_COUNT;
      F_Fdx(1);

      if ( GET_CPL() > GET_IOPL() || GET_VM() )
	 check_io_permission_map(ops[1].sng, BYTE_WIDTH);

      while ( rep_count )
	 {
	 D_Yb(0, WO0, PG_W);
	 IN8(&ops[0].sng, ops[1].sng);
	 rep_count--;
	 C_Yb(0);
	 PIG_P_Yb(0);
	 /*
	    KNOWN BUG #1.
	    We should check for pending interrupts here, at least:-
	       Single step trap
	       Debug trap
	  */
	 }
#ifdef	PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_SOME_MEM);
      quick_mode = FALSE;
      break;

   case 0x6d:   /* T4 INSW Yv Fdx */
      STRING_COUNT;
      F_Fdx(1);

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[1].sng, WORD_WIDTH);

	 while ( rep_count )
	    {
	    D_Yw(0, WO0, PG_W);
	    IN16(&ops[0].sng, ops[1].sng);
	    rep_count--;
	    C_Yw(0);
	    PIG_P_Yw(0);
	    /* KNOWN BUG #1. */
	    }
	 }
      else   /* USE32 */
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[1].sng, DWORD_WIDTH);

	 while ( rep_count )
	    {
	    D_Yd(0, WO0, PG_W);
	    IN32(&ops[0].sng, ops[1].sng);
	    rep_count--;
	    C_Yd(0);
	    PIG_P_Yd(0);
	    /* KNOWN BUG #1. */
	    }
	 }
#ifdef	PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_SOME_MEM);
      quick_mode = FALSE;
      break;

   case 0x6e:   /* T6 OUTSB Fdx Xb */
      STRING_COUNT;
      F_Fdx(0);

      if ( GET_CPL() > GET_IOPL() || GET_VM() )
	 check_io_permission_map(ops[0].sng, BYTE_WIDTH);

      while ( rep_count )
	 {
	 D_Xb(1, RO1, PG_R);
	 F_Xb(1);
	 OUT8(ops[0].sng, ops[1].sng);
	 rep_count--;
	 C_Xb(1);
	 /* KNOWN BUG #1. */
	 }
#ifdef	PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_ALL);
      quick_mode = FALSE;
      break;

   case 0x6f:   /* T6 OUTSW Fdx Xv */
      STRING_COUNT;
      F_Fdx(0);

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[0].sng, WORD_WIDTH);

	 while ( rep_count )
	    {
	    D_Xw(1, RO1, PG_R);
	    F_Xw(1);
	    OUT16(ops[0].sng, ops[1].sng);
	    rep_count--;
	    C_Xw(1);
	    /* KNOWN BUG #1. */
	    }
	 }
      else   /* USE32 */
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[0].sng, DWORD_WIDTH);

	 while ( rep_count )
	    {
	    D_Xd(1, RO1, PG_R);
	    F_Xd(1);
	    OUT32(ops[0].sng, ops[1].sng);
	    rep_count--;
	    C_Xd(1);
	    /* KNOWN BUG #1. */
	    }
	 }
#ifdef	PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_ALL);
      quick_mode = FALSE;
      break;

   case 0x70:   /* T2 JO   Jb */
      inst32 = JO;
TYPE70:

      D_Jb(0);
      UPDATE_INTEL_IP_USE_OP_SIZE(p);
#ifdef PIG
      if ((opcode != 0xeb) && (ops[0].sng == 3))
      {
	/* Convert the EDL cpu super-instructions
	 *
	 *	Jcc	.+03
	 *	JMPN	dst
	 *
	 * into
	 *
	 *	Jcc'	dest
	 */
	 int offset_in_page = DiffCpuPtrsLS8(FloorIntelPageLS8(p), p);

	 if ((GET_CS_AR_X() == 0)
	     && (offset_in_page != 0)
	     && (offset_in_page <= 0xFFD)
	     && (*p == 0xe9)) 
	 {
		 p_start = p;
		 (void)GET_INST_BYTE(p);
		 switch (opcode)
		 {
		 case 0x70:   /* T2 JO   Jb */   inst32 = JNO;    goto TYPE0F80;
		 case 0x71:   /* T2 JNO  Jb */   inst32 = JO;     goto TYPE0F80;
		 case 0x72:   /* T2 JB   Jb */   inst32 = JNB;    goto TYPE0F80;
		 case 0x73:   /* T2 JNB  Jb */   inst32 = JB;     goto TYPE0F80;
		 case 0x74:   /* T2 JZ   Jb */   inst32 = JNZ;    goto TYPE0F80;
		 case 0x75:   /* T2 JNZ  Jb */   inst32 = JZ;     goto TYPE0F80;
		 case 0x76:   /* T2 JBE  Jb */   inst32 = JNBE;   goto TYPE0F80;
		 case 0x77:   /* T2 JNBE Jb */   inst32 = JBE;    goto TYPE0F80;
		 case 0x78:   /* T2 JS   Jb */   inst32 = JNS;    goto TYPE0F80;
		 case 0x79:   /* T2 JNS  Jb */   inst32 = JS;     goto TYPE0F80;
		 case 0x7a:   /* T2 JP   Jb */   inst32 = JNP;    goto TYPE0F80;
		 case 0x7b:   /* T2 JNP  Jb */   inst32 = JP;     goto TYPE0F80;
		 case 0x7c:   /* T2 JL   Jb */   inst32 = JNL;    goto TYPE0F80;
		 case 0x7d:   /* T2 JNL  Jb */   inst32 = JL;     goto TYPE0F80;
		 case 0x7e:   /* T2 JLE  Jb */   inst32 = JNLE;   goto TYPE0F80;
		 case 0x7f:   /* T2 JNLE Jb */   inst32 = JLE;    goto TYPE0F80;
		 default:
			 break;
		 }
	 }
      }
#endif	/* PIG */
      (*inst32)(ops[0].sng);
      CANCEL_HOST_IP();

#ifdef PIG
      if (single_instruction_delay && !took_relative_jump)
      {
	 if (single_instruction_delay_enable)
	 {
	    save_last_xcptn_details("STI/POPF blindspot\n", 0, 0, 0, 0, 0);
	    PIG_SYNCH(CHECK_NO_EXEC);
         }
	 else
	 {
	    save_last_xcptn_details("STI/POPF problem\n", 0, 0, 0, 0, 0);
	 }
	 break;
      }
#ifdef SYNCH_BOTH_WAYS
      took_relative_jump = TRUE;
#endif	/* SYNCH_BOTH_WAYS */
      if (took_relative_jump)
      {
	 PIG_SYNCH(CHECK_ALL);
      }
#endif	/* PIG */
      break;

   case 0x71:   /* T2 JNO  Jb */   inst32 = JNO;    goto TYPE70;
   case 0x72:   /* T2 JB   Jb */   inst32 = JB;     goto TYPE70;
   case 0x73:   /* T2 JNB  Jb */   inst32 = JNB;    goto TYPE70;
   case 0x74:   /* T2 JZ   Jb */   inst32 = JZ;     goto TYPE70;
   case 0x75:   /* T2 JNZ  Jb */   inst32 = JNZ;    goto TYPE70;
   case 0x76:   /* T2 JBE  Jb */   inst32 = JBE;    goto TYPE70;
   case 0x77:   /* T2 JNBE Jb */   inst32 = JNBE;   goto TYPE70;
   case 0x78:   /* T2 JS   Jb */   inst32 = JS;     goto TYPE70;
   case 0x79:   /* T2 JNS  Jb */   inst32 = JNS;    goto TYPE70;
   case 0x7a:   /* T2 JP   Jb */   inst32 = JP;     goto TYPE70;
   case 0x7b:   /* T2 JNP  Jb */   inst32 = JNP;    goto TYPE70;
   case 0x7c:   /* T2 JL   Jb */   inst32 = JL;     goto TYPE70;
   case 0x7d:   /* T2 JNL  Jb */   inst32 = JNL;    goto TYPE70;
   case 0x7e:   /* T2 JLE  Jb */   inst32 = JLE;    goto TYPE70;
   case 0x7f:   /* T2 JNLE Jb */   inst32 = JNLE;   goto TYPE70;

   case 0x80:
   case 0x82:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ADD Eb Ib */
	 instp32328 = ADD;
TYPE80_0:

	 D_Eb(0, RW0, PG_W);
	 D_Ib(1);
	 F_Eb(0);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 8);
	 P_Eb(0);
	 break;

      case 1:   /* T5 OR  Eb Ib */   instp32328 = OR;    goto TYPE80_0;
      case 2:   /* T5 ADC Eb Ib */   instp32328 = ADC;   goto TYPE80_0;
      case 3:   /* T5 SBB Eb Ib */   instp32328 = SBB;   goto TYPE80_0;
      case 4:   /* T5 AND Eb Ib */   instp32328 = AND;   goto TYPE80_0;
      case 5:   /* T5 SUB Eb Ib */   instp32328 = SUB;   goto TYPE80_0;
      case 6:   /* T5 XOR Eb Ib */   instp32328 = XOR;   goto TYPE80_0;

      case 7:   /* T6 CMP Eb Ib */
	 inst32328 = CMP;
TYPE80_7:

	 D_Eb(0, RO0, PG_R);
	 D_Ib(1);
	 F_Eb(0);
	 (*inst32328)(ops[0].sng, ops[1].sng, 8);
	 break;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;

   case 0x81:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ADD Ev Iv */
	 instp32328 = ADD;
TYPE81_0:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RW0, PG_W);
	    D_Iw(1);
	    F_Ew(0);
	    (*instp32328)(&ops[0].sng, ops[1].sng, 16);
	    P_Ew(0);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RW0, PG_W);
	    D_Id(1);
	    F_Ed(0);
	    (*instp32328)(&ops[0].sng, ops[1].sng, 32);
	    P_Ed(0);
	    }
	 break;

      case 1:   /* T5 OR  Ev Iv */   instp32328 = OR;    goto TYPE81_0;
      case 2:   /* T5 ADC Ev Iv */   instp32328 = ADC;   goto TYPE81_0;
      case 3:   /* T5 SBB Ev Iv */   instp32328 = SBB;   goto TYPE81_0;
      case 4:   /* T5 AND Ev Iv */   instp32328 = AND;   goto TYPE81_0;
      case 5:   /* T5 SUB Ev Iv */   instp32328 = SUB;   goto TYPE81_0;
      case 6:   /* T5 XOR Ev Iv */   instp32328 = XOR;   goto TYPE81_0;

      case 7:   /* T6 CMP Ev Iv */
	 inst32328 = CMP;
TYPE81_7:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RO0, PG_R);
	    D_Iw(1);
	    F_Ew(0);
	    (*inst32328)(ops[0].sng, ops[1].sng, 16);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RO0, PG_R);
	    D_Id(1);
	    F_Ed(0);
	    (*inst32328)(ops[0].sng, ops[1].sng, 32);
	    }
	 break;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;

   case 0x83:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ADD Ev Ib */
	 instp32328 = ADD;
TYPE83_0:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RW0, PG_W);
	    D_Ix(1);
	    F_Ew(0);
	    (*instp32328)(&ops[0].sng, ops[1].sng, 16);
	    P_Ew(0);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RW0, PG_W);
	    D_Iy(1);
	    F_Ed(0);
	    (*instp32328)(&ops[0].sng, ops[1].sng, 32);
	    P_Ed(0);
	    }
	 break;

      case 1:   /* T5 OR  Ev Ib */   instp32328 = OR;    goto TYPE83_0;
      case 2:   /* T5 ADC Ev Ib */   instp32328 = ADC;   goto TYPE83_0;
      case 3:   /* T5 SBB Ev Ib */   instp32328 = SBB;   goto TYPE83_0;
      case 4:   /* T5 AND Ev Ib */   instp32328 = AND;   goto TYPE83_0;
      case 5:   /* T5 SUB Ev Ib */   instp32328 = SUB;   goto TYPE83_0;
      case 6:   /* T5 XOR Ev Ib */   instp32328 = XOR;   goto TYPE83_0;

      case 7:   /* T6 CMP Ev Ib */
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RO0, PG_R);
	    D_Ix(1);
	    F_Ew(0);
	    CMP(ops[0].sng, ops[1].sng, 16);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RO0, PG_R);
	    D_Iy(1);
	    F_Ed(0);
	    CMP(ops[0].sng, ops[1].sng, 32);
	    }
	 break;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;

   case 0x84:   /* T6 TEST Eb Gb */    inst32328 = TEST;   goto TYPE38;
   case 0x85:   /* T6 TEST Ev Gv */    inst32328 = TEST;   goto TYPE39;

   case 0x86:   /* T8 XCHG Eb Gb */
      modRM = GET_INST_BYTE(p);
      D_Eb(0, RW0, PG_W);
      D_Gb(1);
      F_Eb(0);
      F_Gb(1);
      XCHG(&ops[0].sng, &ops[1].sng);
      P_Eb(0);
      P_Gb(1);
      break;

   case 0x87:   /* T8 XCHG Ev Gv */
      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ew(0, RW0, PG_W);
	 D_Gw(1);
	 F_Ew(0);
	 F_Gw(1);
	 XCHG(&ops[0].sng, &ops[1].sng);
	 P_Ew(0);
	 P_Gw(1);
	 }
      else   /* USE32 */
	 {
	 D_Ed(0, RW0, PG_W);
	 D_Gd(1);
	 F_Ed(0);
	 F_Gd(1);
	 XCHG(&ops[0].sng, &ops[1].sng);
	 P_Ed(0);
	 P_Gd(1);
	 }
      break;

   case 0x88:   /* T4 MOV Eb Gb */
      modRM = GET_INST_BYTE(p);
      D_Eb(0, WO0, PG_W);
      D_Gb(1);
      F_Gb(1);
      ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
      P_Eb(0);
      break;

   case 0x89:   /* T4 MOV Ev Gv */
      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ew(0, WO0, PG_W);
	 D_Gw(1);
	 F_Gw(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Ew(0);
	 }
      else   /* USE32 */
	 {
	 D_Ed(0, WO0, PG_W);
	 D_Gd(1);
	 F_Gd(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Ed(0);
	 }
      break;

   case 0x8a:   /* T4 MOV Gb Eb */
      modRM = GET_INST_BYTE(p);
      D_Gb(0);
      D_Eb(1, RO1, PG_R);
      F_Eb(1);
      ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
      P_Gb(0);
      break;

   case 0x8b:   /* T4 MOV Gv Ev */
      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Gw(0);
	 D_Ew(1, RO1, PG_R);
	 F_Ew(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Gw(0);
	 }
      else   /* USE32 */
	 {
	 D_Gd(0);
	 D_Ed(1, RO1, PG_R);
	 F_Ed(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Gd(0);
	 }
      break;

   case 0x8c:   /* T4 MOV Ew Nw */
      modRM = GET_INST_BYTE(p);
      if ( GET_SEG(modRM) > MAX_VALID_SEG )
	 Int6();

      if ( GET_OPERAND_SIZE() == USE16 || modRM < LOWEST_REG_MODRM )
	 {
	 D_Ew(0, WO0, PG_W);
	 D_Nw(1);
	 F_Nw(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Ew(0);
	 }
      else   /* USE32 and REGISTER */
	 {
	 D_Rd(0);
	 D_Nw(1);
	 F_Nw(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Rd(0);
	 }
      break;

   case 0x8d:   /* T4 LEA Gv M */
      modRM = GET_INST_BYTE(p);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Gw(0);
	 D_M(1);
	 F_M(1);
	 LEA(&ops[0].sng, ops[1].sng);
	 P_Gw(0);
	 }
      else   /* USE32 */
	 {
	 D_Gd(0);
	 D_M(1);
	 F_M(1);
	 LEA(&ops[0].sng, ops[1].sng);
	 P_Gd(0);
	 }
      break;

   case 0x8e:   /* T4 MOV Nw Ew */
      modRM = GET_INST_BYTE(p);
      if ( GET_SEG(modRM) > MAX_VALID_SEG || GET_SEG(modRM) == CS_REG )
	 Int6();
      D_Nw(0);
      D_Ew(1, RO1, PG_R);
      F_Ew(1);
      MOV_SR(ops[0].sng, ops[1].sng);
      if ( GET_SEG(modRM) == SS_REG )
         {
         /* locally update IP - interrupts are supressed after MOV SS,xx */
         UPDATE_INTEL_IP(p);

         goto NEXT_INST;
         }
      break;

   case 0x8f:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T3 POP Ev */
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    SET_POP_DISP(2);   /* in case they use [ESP] */
	    D_Ew(0, WO0, PG_W);
	    POP(&ops[0].sng);
	    P_Ew(0);
	    }
	 else   /* USE32 */
	    {
	    SET_POP_DISP(4);   /* in case they use [ESP] */
	    D_Ed(0, WO0, PG_W);
	    POP(&ops[0].sng);
	    P_Ed(0);
	    }
	 SET_POP_DISP(0);
	 break;

      case 1: case 2: case 3: case 4: case 5: case 6: case 7:
	 Int6();
	 break;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;

   case 0x90:   /* T0 NOP */
      break;

   case 0x91:   /* T8 XCHG F(e)ax Hv */
   case 0x92:
   case 0x93:
   case 0x94:
   case 0x95:
   case 0x96:
   case 0x97:
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 F_Fax(0);
	 D_Hw(1);
	 F_Hw(1);
	 XCHG(&ops[0].sng, &ops[1].sng);
	 P_Fax(0);
	 P_Hw(1);
	 }
      else   /* USE32 */
	 {
	 F_Feax(0);
	 D_Hd(1);
	 F_Hd(1);
	 XCHG(&ops[0].sng, &ops[1].sng);
	 P_Feax(0);
	 P_Hd(1);
	 }
      break;

   case 0x98:   /* T0 CBW */
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 CBW();
	 }
      else   /* USE32 */
	 {
	 CWDE();
	 }
      break;

   case 0x99:   /* T0 CWD */
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 CWD();
	 }
      else   /* USE32 */
	 {
	 CDQ();
	 }
      break;

   case 0x9a:   /* T2 CALL Ap */
      instp32 = CALLF;
      took_absolute_toc = TRUE;
TYPE9A:

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Aw(0);
	 }
      else   /* USE32 */
	 {
	 D_Ad(0);
	 }
      UPDATE_INTEL_IP_USE_OP_SIZE(p);
      (*instp32)(ops[0].mlt);
      CANCEL_HOST_IP();
      PIG_SYNCH(CHECK_ALL);
      break;

   case 0x9b:   /* T0 WAIT */
      if ( GET_MP() && GET_TS() )
	 Int7();
      WAIT();
      break;

   case 0x9c:   /* T0 PUSHF */
      if ( GET_VM() == 1 && GET_CPL() > GET_IOPL() )
	 GP((IU16)0, FAULT_CCPU_PUSHF_ACCESS);
      PUSHF();
      break;

   case 0x9d:   /* T0 POPF */
   {
      int oldIF;

      if ( GET_VM() == 1 && GET_CPL() > GET_IOPL() )
	 GP((IU16)0, FAULT_CCPU_POPF_ACCESS);

      oldIF = getIF();

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 POPF();
	 }
      else   /* USE32 */
	 {
	 POPFD();
	 }
#ifdef PIG
      if (getIF()==1 && oldIF==0)
      {
          /* locally update IP - interrupts are supressed after POPF */
          UPDATE_INTEL_IP(p);

	  /* We need to pig sync one instr *after* an POPF that enabled
	   * interrupts, because the A4CPU might need to take a H/W interrupt
	   */

	  single_instruction_delay = TRUE;
	  PIG_SYNCH(CHECK_ALL);

          goto NEXT_INST;
      }
#endif /* PIG */

      quick_mode = FALSE;
      break;
   }

   case 0x9e:   /* T0 SAHF */
      SAHF();
      break;

   case 0x9f:   /* T0 LAHF */
      LAHF();
      break;

   case 0xa0:   /* T4 MOV Fal Ob */
      D_Ob(1, RO1, PG_R);
      F_Ob(1);
      ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
      P_Fal(0);
      break;

   case 0xa1:   /* T4 MOV F(e)ax Ov */
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ow(1, RO1, PG_R);
	 F_Ow(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Fax(0);
	 }
      else   /* USE32 */
	 {
	 D_Od(1, RO1, PG_R);
	 F_Od(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Feax(0);
	 }
      break;

   case 0xa2:   /* T4 MOV Ob Fal */
      D_Ob(0, WO0, PG_W);
      F_Fal(1);
      ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
      P_Ob(0);
      break;

   case 0xa3:   /* T4 MOV Ov F(e)ax */
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ow(0, WO0, PG_W);
	 F_Fax(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Ow(0);
	 }
      else   /* USE32 */
	 {
	 D_Od(0, WO0, PG_W);
	 F_Feax(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Od(0);
	 }
      break;

   case 0xa4:   /* T4 MOVSB Yb Xb */
      STRING_COUNT;

      while ( rep_count )
	 {
	 D_Xb(1, RO1, PG_R);
	 D_Yb(0, WO0, PG_W);
	 F_Xb(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 rep_count--;
	 C_Yb(0);
	 C_Xb(1);
	 P_Yb(0);
	 /* KNOWN BUG #1. */
	 }
      break;

   case 0xa5:   /* T4 MOVSW Yv Xv */
      STRING_COUNT;

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 while ( rep_count )
	    {
	    D_Xw(1, RO1, PG_R);
	    D_Yw(0, WO0, PG_W);
	    F_Xw(1);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    rep_count--;
	    C_Yw(0);
	    C_Xw(1);
	    P_Yw(0);
	    /* KNOWN BUG #1. */
	    }
	 }
      else   /* USE32 */
	 {
	 while ( rep_count )
	    {
	    D_Xd(1, RO1, PG_R);
	    D_Yd(0, WO0, PG_W);
	    F_Xd(1);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    rep_count--;
	    C_Yd(0);
	    C_Xd(1);
	    P_Yd(0);
	    /* KNOWN BUG #1. */
	    }
	 }
      break;

   case 0xa6:   /* T6 CMPSB Xb Yb */
      STRING_COUNT;

      while ( rep_count )
	 {
	 D_Xb(0, RO0, PG_R);
	 D_Yb(1, RO1, PG_R);
	 F_Xb(0);
	 F_Yb(1);
	 CMP(ops[0].sng, ops[1].sng, 8);
	 rep_count--;
	 C_Xb(0);
	 C_Yb(1);
	 if ( rep_count &&
	      ( repeat == REP_E  && GET_ZF() == 0 ||
		repeat == REP_NE && GET_ZF() == 1 )
	    )
	    break;
	 /* KNOWN BUG #1. */
	 }
      break;

   case 0xa7:   /* T6 CMPSW Xv Yv */
      STRING_COUNT;

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 while ( rep_count )
	    {
	    D_Xw(0, RO0, PG_R);
	    D_Yw(1, RO1, PG_R);
	    F_Xw(0);
	    F_Yw(1);
	    CMP(ops[0].sng, ops[1].sng, 16);
	    rep_count--;
	    C_Xw(0);
	    C_Yw(1);
	    if ( rep_count &&
		 ( repeat == REP_E  && GET_ZF() == 0 ||
		   repeat == REP_NE && GET_ZF() == 1 )
	       )
	       break;
	    /* KNOWN BUG #1. */
	    }
	 }
      else   /* USE32 */
	 {
	 while ( rep_count )
	    {
	    D_Xd(0, RO0, PG_R);
	    D_Yd(1, RO1, PG_R);
	    F_Xd(0);
	    F_Yd(1);
	    CMP(ops[0].sng, ops[1].sng, 32);
	    rep_count--;
	    C_Xd(0);
	    C_Yd(1);
	    if ( rep_count &&
		 ( repeat == REP_E  && GET_ZF() == 0 ||
		   repeat == REP_NE && GET_ZF() == 1 )
	       )
	       break;
	    /* KNOWN BUG #1. */
	    }
	 }
      break;

   case 0xa8:   /* T6 TEST Fal Ib */      inst32328 = TEST;   goto TYPE3C;
   case 0xa9:   /* T6 TEST F(e)ax Iv */   inst32328 = TEST;   goto TYPE3D;

   case 0xaa:   /* T4 STOSB Yb Fal */
      STRING_COUNT;

      F_Fal(1);
      while ( rep_count )
	 {
	 D_Yb(0, WO0, PG_W);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 rep_count--;
	 C_Yb(0);
	 P_Yb(0);
	 /* KNOWN BUG #1. */
	 }
      break;

   case 0xab:   /* T4 STOSW Yv F(e)ax */
      STRING_COUNT;

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 F_Fax(1);
	 while ( rep_count )
	    {
	    D_Yw(0, WO0, PG_W);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    rep_count--;
	    C_Yw(0);
	    P_Yw(0);
	    /* KNOWN BUG #1. */
	    }
	 }
      else   /* USE32 */
	 {
	 F_Feax(1);
	 while ( rep_count )
	    {
	    D_Yd(0, WO0, PG_W);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    rep_count--;
	    C_Yd(0);
	    P_Yd(0);
	    /* KNOWN BUG #1. */
	    }
	 }
      break;

   case 0xac:   /* T4 LODSB Fal Xb */
      STRING_COUNT;

      while ( rep_count )
	 {
	 D_Xb(1, RO1, PG_R);
	 F_Xb(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 rep_count--;
	 P_Fal(0);
	 C_Xb(1);
	 /* KNOWN BUG #1. */
	 }
      break;

   case 0xad:   /* T4 LODSW F(e)ax Xv */
      STRING_COUNT;

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 while ( rep_count )
	    {
	    D_Xw(1, RO1, PG_R);
	    F_Xw(1);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    rep_count--;
	    P_Fax(0);
	    C_Xw(1);
	    /* KNOWN BUG #1. */
	    }
	 }
      else   /* USE32 */
	 {
	 while ( rep_count )
	    {
	    D_Xd(1, RO1, PG_R);
	    F_Xd(1);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    rep_count--;
	    P_Feax(0);
	    C_Xd(1);
	    /* KNOWN BUG #1. */
	    }
	 }
      break;

   case 0xae:   /* T6 SCASB Fal Yb */
      STRING_COUNT;

      F_Fal(0);
      while ( rep_count )
	 {
	 D_Yb(1, RO1, PG_R);
	 F_Yb(1);
	 CMP(ops[0].sng, ops[1].sng, 8);
	 rep_count--;
	 C_Yb(1);
	 if ( rep_count &&
	      ( repeat == REP_E  && GET_ZF() == 0 ||
		repeat == REP_NE && GET_ZF() == 1 )
	    )
	    break;
	 /* KNOWN BUG #1. */
	 }
      break;

   case 0xaf:   /* T6 SCASW F(e)ax Yv */
      STRING_COUNT;

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 F_Fax(0);
	 while ( rep_count )
	    {
	    D_Yw(1, RO1, PG_R);
	    F_Yw(1);
	    CMP(ops[0].sng, ops[1].sng, 16);
	    rep_count--;
	    C_Yw(1);
	    if ( rep_count &&
		 ( repeat == REP_E  && GET_ZF() == 0 ||
		   repeat == REP_NE && GET_ZF() == 1 )
	       )
	       break;
	    /* KNOWN BUG #1. */
	    }
	 }
      else   /* USE32 */
	 {
	 F_Feax(0);
	 while ( rep_count )
	    {
	    D_Yd(1, RO1, PG_R);
	    F_Yd(1);
	    CMP(ops[0].sng, ops[1].sng, 32);
	    rep_count--;
	    C_Yd(1);
	    if ( rep_count &&
		 ( repeat == REP_E  && GET_ZF() == 0 ||
		   repeat == REP_NE && GET_ZF() == 1 )
	       )
	       break;
	    /* KNOWN BUG #1. */
	    }
	 }
      break;

   case 0xb0:   /* T4 MOV Hb Ib */
   case 0xb1:
   case 0xb2:
   case 0xb3:
   case 0xb4:
   case 0xb5:
   case 0xb6:
   case 0xb7:
      D_Hb(0);
      D_Ib(1);
      ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
      P_Hb(0);
      break;

   case 0xb8:   /* T4 MOV Hv Iv */
   case 0xb9:
   case 0xba:
   case 0xbb:
   case 0xbc:
   case 0xbd:
   case 0xbe:
   case 0xbf:
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Hw(0);
	 D_Iw(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Hw(0);
	 }
      else   /* USE32 */
	 {
	 D_Hd(0);
	 D_Id(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Hd(0);
	 }
      break;

   case 0xc0:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ROL Eb Ib */   instp32328 = ROL;   goto TYPE80_0;
      case 1:   /* T5 ROR Eb Ib */   instp32328 = ROR;   goto TYPE80_0;
      case 2:   /* T5 RCL Eb Ib */   instp32328 = RCL;   goto TYPE80_0;
      case 3:   /* T5 RCR Eb Ib */   instp32328 = RCR;   goto TYPE80_0;
      case 4:   /* T5 SHL Eb Ib */   instp32328 = SHL;   goto TYPE80_0;
      case 5:   /* T5 SHR Eb Ib */   instp32328 = SHR;   goto TYPE80_0;
      case 6:   /* T5 SHL Eb Ib */   instp32328 = SHL;   goto TYPE80_0;
      case 7:   /* T5 SAR Eb Ib */   instp32328 = SAR;   goto TYPE80_0;
	 }

   case 0xc1:
      modRM = GET_INST_BYTE(p);

      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ROL Ev Ib */   instp32328 = ROL;   break;
      case 1:   /* T5 ROR Ev Ib */   instp32328 = ROR;   break;
      case 2:   /* T5 RCL Ev Ib */   instp32328 = RCL;   break;
      case 3:   /* T5 RCR Ev Ib */   instp32328 = RCR;   break;
      case 4:   /* T5 SHL Ev Ib */   instp32328 = SHL;   break;
      case 5:   /* T5 SHR Ev Ib */   instp32328 = SHR;   break;
      case 6:   /* T5 SHL Ev Ib */   instp32328 = SHL;   break;
      case 7:   /* T5 SAR Ev Ib */   instp32328 = SAR;   break;
	 }

TYPEC1:

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ew(0, RW0, PG_W);
	 D_Ib(1);
	 F_Ew(0);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 16);
	 P_Ew(0);
	 }
      else   /* USE32 */
	 {
	 D_Ed(0, RW0, PG_W);
	 D_Ib(1);
	 F_Ed(0);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 32);
	 P_Ed(0);
	 }
      break;

   case 0xc2:   /* T2 RET Iw */
      inst32 = RETN;
      took_absolute_toc = TRUE;
TYPEC2:

      D_Iw(0);
      UPDATE_INTEL_IP_USE_OP_SIZE(p);
      (*inst32)(ops[0].sng);
      CANCEL_HOST_IP();
      PIG_SYNCH(CHECK_ALL);
      break;

   case 0xc3:   /* T2 RET I0 */
      inst32 = RETN;
      took_absolute_toc = TRUE;
TYPEC3:

      F_I0(0);
      UPDATE_INTEL_IP_USE_OP_SIZE(p);
      (*inst32)(ops[0].sng);
      CANCEL_HOST_IP();
      PIG_SYNCH(CHECK_ALL);
      break;

   case 0xc4:   /* T4 LES Gv Mp */
      instp32p32 = LES;
TYPEC4:

      modRM = GET_INST_BYTE(p);
      if (((modRM & 0xfc) == 0xc4) && (instp32p32 == LES)) {
         /*
          * It's a c4c? BOP.
	  * The bop routine itself will read the argument, but
	  * we read it here so that we get the next EIP correct.
          */
	  int nField, i;

          D_Ib(0);
	  nField = modRM & 3;
	  immed = 0;
	  for (i = 0; i < nField; i++)
	  {
		  immed |= (ULONG)GET_INST_BYTE(p);
		  immed <<= 8;
	  }
          immed |= ops[0].sng;
#ifdef	PIG
          if (immed == 0xfe)
	     SET_EIP(CCPU_save_EIP);
	  else
	     UPDATE_INTEL_IP(p);
	  CANCEL_HOST_IP();
	  PIG_SYNCH(CHECK_NO_EXEC);	/* Everything checkable up to this point */
#else	/* PIG */
	  UPDATE_INTEL_IP(p);
          if ((immed & 0xff) == 0xfe)
          {
		  switch(immed)
		  {
#if defined(SFELLOW)
		  case 0x03fe:
			    SfdelayUSecs();
			    break;
		  case 0x05fe:
			    SfsasTouchBop();
			    break;
		  case 0x06fe:
			    SfscatterGatherSasTouch();
			    break;
#endif /* SFELLOW */
		  case 0xfe:
			  c_cpu_unsimulate();
			  /* Never returns (?) */
		  default:
			  EDL_fast_bop(immed);
			  break;
		  }
	  }
	  else
	  {
	      in_C = 1;
	      bop(ops[0].sng);
	      in_C = 0;
	  }
          CANCEL_HOST_IP();
	  SYNCH_TICK();
#endif	/* PIG */
          break;
      }
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Gw(0);
	 D_Mp16(1, RO1, PG_R);
	 F_Mp16(1);
	 (*instp32p32)(&ops[0].sng, ops[1].mlt);
	 P_Gw(0);
	 }
      else   /* USE32 */
	 {
	 D_Gd(0);
	 D_Mp32(1, RO1, PG_R);
	 F_Mp32(1);
	 (*instp32p32)(&ops[0].sng, ops[1].mlt);
	 P_Gd(0);
	 }
      break;

   case 0xc5:   /* T4 LDS Gv Mp */
      instp32p32 = LDS;
      goto TYPEC4;

   case 0xc6:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T4 MOV Eb Ib */
	 D_Eb(0, WO0, PG_W);
	 D_Ib(1);
	 ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	 P_Eb(0);
	 break;

      case 1: case 2: case 3: case 4: case 5: case 6: case 7:
	 Int6();
	 break;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;

   case 0xc7:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T4 MOV Ev Iv */
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, WO0, PG_W);
	    D_Iw(1);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    P_Ew(0);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, WO0, PG_W);
	    D_Id(1);
	    ops[0].sng = ops[1].sng;   /*MOV(&ops[0].sng, ops[1].sng);*/
	    P_Ed(0);
	    }
	 break;

      case 1: case 2: case 3: case 4: case 5: case 6: case 7:
	 Int6();
	 break;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;

   case 0xc8:   /* T6 ENTER Iw Ib */
      D_Iw(0);
      D_Ib(1);
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 ENTER16(ops[0].sng, ops[1].sng);
	 }
      else   /* USE32 */
	 {
	 ENTER32(ops[0].sng, ops[1].sng);
	 }
      break;

   case 0xc9:   /* T0 LEAVE */
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 LEAVE16();
	 }
      else   /* USE32 */
	 {
	 LEAVE32();
	 }
      break;

   case 0xca:   /* T2 RET Iw */
      inst32 = RETF; 
      took_absolute_toc = TRUE;
      goto TYPEC2;
   case 0xcb:   /* T2 RET I0 */
      inst32 = RETF; 
      took_absolute_toc = TRUE;
      goto TYPEC3;

   case 0xcc:   /* T2 INT I3 */
      took_absolute_toc = TRUE;
      F_I3(0);
      UPDATE_INTEL_IP(p);
      start_trap = 0;   /* clear any pending TF exception */
      INTx(ops[0].sng);
      CANCEL_HOST_IP();
      PIG_SYNCH(CHECK_ALL);
      break;

   case 0xcd:   /* T2 INT Ib */
      if ( GET_VM() == 1 && GET_CPL() > GET_IOPL() )
	 GP((IU16)0, FAULT_CCPU_INT_ACCESS);
      took_absolute_toc = TRUE;
      D_Ib(0);
      UPDATE_INTEL_IP(p);
      start_trap = 0;   /* clear any pending TF exception */
      INTx(ops[0].sng);
      CANCEL_HOST_IP();
      PIG_SYNCH(CHECK_ALL);
      break;

   case 0xce:   /* T0 INTO */
      if ( GET_OF() )
	 {
	 took_absolute_toc = TRUE;
	 UPDATE_INTEL_IP(p);
	 start_trap = 0;   /* clear any pending TF exception */
	 INTO();
	 CANCEL_HOST_IP();
	 PIG_SYNCH(CHECK_ALL);
	 }
      break;

   case 0xcf:   /* T0 IRET */
      if ( GET_VM() == 1 && GET_CPL() > GET_IOPL() )
	 GP((IU16)0, FAULT_CCPU_IRET_ACCESS);
      took_absolute_toc = TRUE;
      UPDATE_INTEL_IP(p);
      IRET();
      CANCEL_HOST_IP();
      PIG_SYNCH(CHECK_ALL);
      /* Dont do interrupt checks etc after an IRET */
#ifdef PIG
      /* If the destination is going to page fault, or need
       * accessing, then the EDL CPU will do so before issuing
       * the pig synch. We use the dasm386 decode to prefetch
       * a single instruction which mimics the EDL Cpu's behaviour
       * when close to a page boundary.
       */
      prefetch_1_instruction();	/* Will PF if destination not present */
      ccpu_synch_count++;
      c_cpu_unsimulate();
#endif /* PIG */

      goto NEXT_INST;
      break;

   case 0xd0:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ROL Eb I1 */   instp32328 = ROL;   break;
      case 1:   /* T5 ROR Eb I1 */   instp32328 = ROR;   break;
      case 2:   /* T5 RCL Eb I1 */   instp32328 = RCL;   break;
      case 3:   /* T5 RCR Eb I1 */   instp32328 = RCR;   break;
      case 4:   /* T5 SHL Eb I1 */   instp32328 = SHL;   break;
      case 5:   /* T5 SHR Eb I1 */   instp32328 = SHR;   break;
      case 6:   /* T5 SHL Eb I1 */   instp32328 = SHL;   break;
      case 7:   /* T5 SAR Eb I1 */   instp32328 = SAR;   break;
	 }
      D_Eb(0, RW0, PG_W);
      F_Eb(0);
      F_I1(1);
      (*instp32328)(&ops[0].sng, ops[1].sng, 8);
      P_Eb(0);
      break;

   case 0xd1:
      modRM = GET_INST_BYTE(p);

      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ROL Ev I1 */   instp32328 = ROL;   break;
      case 1:   /* T5 ROR Ev I1 */   instp32328 = ROR;   break;
      case 2:   /* T5 RCL Ev I1 */   instp32328 = RCL;   break;
      case 3:   /* T5 RCR Ev I1 */   instp32328 = RCR;   break;
      case 4:   /* T5 SHL Ev I1 */   instp32328 = SHL;   break;
      case 5:   /* T5 SHR Ev I1 */   instp32328 = SHR;   break;
      case 6:   /* T5 SHL Ev I1 */   instp32328 = SHL;   break;
      case 7:   /* T5 SAR Ev I1 */   instp32328 = SAR;   break;
	 }

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ew(0, RW0, PG_W);
	 F_Ew(0);
	 F_I1(1);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 16);
	 P_Ew(0);
	 }
      else   /* USE32 */
	 {
	 D_Ed(0, RW0, PG_W);
	 F_Ed(0);
	 F_I1(1);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 32);
	 P_Ed(0);
	 }
      break;

   case 0xd2:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ROL Eb Fcl */   instp32328 = ROL;   break;
      case 1:   /* T5 ROR Eb Fcl */   instp32328 = ROR;   break;
      case 2:   /* T5 RCL Eb Fcl */   instp32328 = RCL;   break;
      case 3:   /* T5 RCR Eb Fcl */   instp32328 = RCR;   break;
      case 4:   /* T5 SHL Eb Fcl */   instp32328 = SHL;   break;
      case 5:   /* T5 SHR Eb Fcl */   instp32328 = SHR;   break;
      case 6:   /* T5 SHL Eb Fcl */   instp32328 = SHL;   break;
      case 7:   /* T5 SAR Eb Fcl */   instp32328 = SAR;   break;
	 }
      D_Eb(0, RW0, PG_W);
      F_Eb(0);
      F_Fcl(1);
      (*instp32328)(&ops[0].sng, ops[1].sng, 8);
      P_Eb(0);
      break;

   case 0xd3:
      modRM = GET_INST_BYTE(p);

      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T5 ROL Ev Fcl */   instp32328 = ROL;   break;
      case 1:   /* T5 ROR Ev Fcl */   instp32328 = ROR;   break;
      case 2:   /* T5 RCL Ev Fcl */   instp32328 = RCL;   break;
      case 3:   /* T5 RCR Ev Fcl */   instp32328 = RCR;   break;
      case 4:   /* T5 SHL Ev Fcl */   instp32328 = SHL;   break;
      case 5:   /* T5 SHR Ev Fcl */   instp32328 = SHR;   break;
      case 6:   /* T5 SHL Ev Fcl */   instp32328 = SHL;   break;
      case 7:   /* T5 SAR Ev Fcl */   instp32328 = SAR;   break;
	 }

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Ew(0, RW0, PG_W);
	 F_Ew(0);
	 F_Fcl(1);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 16);
	 P_Ew(0);
	 }
      else   /* USE32 */
	 {
	 D_Ed(0, RW0, PG_W);
	 F_Ed(0);
	 F_Fcl(1);
	 (*instp32328)(&ops[0].sng, ops[1].sng, 32);
	 P_Ed(0);
	 }
      break;

   case 0xd4:   /* T2 AAM Ib */
      inst32 = AAM;
TYPED4:

      D_Ib(0);
      (*inst32)(ops[0].sng);
      break;

   case 0xd5:   /* T2 AAD Ib */   inst32 = AAD;   goto TYPED4;

   case 0xd6:   /* T2 BOP Ib */
      D_Ib(0);
      UPDATE_INTEL_IP(p);

      PIG_SYNCH(CHECK_NO_EXEC);

#ifndef	PIG
      if (ops[0].sng == 0xfe)
      {
	      c_cpu_unsimulate();
      }
      in_C = 1;
      bop(ops[0].sng);
      in_C = 0;
      CANCEL_HOST_IP();
#endif	/* PIG */
      SYNCH_TICK();
      break;

   case 0xd7:   /* T2 XLAT Z */
      D_Z(0, RO0, PG_R);
      F_Z(0);
      XLAT(ops[0].sng);
      break;

   case 0xd8:   /* T2 NPX ??? */
   case 0xd9:
   case 0xda:
   case 0xdb:
   case 0xdc:
   case 0xdd:
   case 0xde:
   case 0xdf:
	if ( GET_EM() || GET_TS() )
		Int7();

	if (NpxIntrNeeded)
	{
		TakeNpxExceptionInt();	/* should set up ISR */
		goto DO_INST;		/* run ISR */
	}

#ifdef	PIG
	/* Must get npx registers from test CPU
	 * This is lazily done for efficiency.
	 */
	c_checkCpuNpxRegisters();
#endif	/* PIG */

	modRM = GET_INST_BYTE(p);
	ZFRSRVD(((opcode-0xd8)*0x100) + modRM);
      break;

   case 0xe0:   /* T2 LOOPNE Jb */
      inst32 = LOOPNE16;
      inst232 = LOOPNE32;
TYPEE0:

      D_Jb(0);
      UPDATE_INTEL_IP_USE_OP_SIZE(p);
      if ( GET_ADDRESS_SIZE() == USE16 )
	 {
	 (*inst32)(ops[0].sng);
	 }
      else   /* USE32 */
	 {
	 (*inst232)(ops[0].sng);
	 }
      CANCEL_HOST_IP();

#ifdef PIG
      if (single_instruction_delay && !took_relative_jump)
      {
	 if (single_instruction_delay_enable)
	 {
	    save_last_xcptn_details("STI/POPF blindspot\n", 0, 0, 0, 0, 0);
	    PIG_SYNCH(CHECK_NO_EXEC);
         }
	 else
	 {
	    save_last_xcptn_details("STI/POPF problem\n", 0, 0, 0, 0, 0);
	 }
	 break;
      }
#ifdef SYNCH_BOTH_WAYS
      took_relative_jump = TRUE;
#endif	/* SYNCH_BOTH_WAYS */
      if (took_relative_jump)
      {
	 PIG_SYNCH(CHECK_ALL);
      }
#endif	/* PIG */
      break;

   case 0xe1:   /* T2 LOOPE  Jb */
      inst32 = LOOPE16;
      inst232 = LOOPE32;
      goto TYPEE0;

   case 0xe2:   /* T2 LOOP   Jb */
      inst32 = LOOP16;
      inst232 = LOOP32;
      goto TYPEE0;

   case 0xe3:   /* T2 JCXZ   Jb */
      inst32 = JCXZ;
      inst232 = JECXZ;
      goto TYPEE0;

   case 0xe4:   /* T4 INB Fal Ib */
      D_Ib(1);

      if ( GET_CPL() > GET_IOPL() || GET_VM() )
	 check_io_permission_map(ops[1].sng, BYTE_WIDTH);

      IN8(&ops[0].sng, ops[1].sng);
      P_Fal(0);
#ifdef PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_NO_AL);
      quick_mode = FALSE;
      break;

   case 0xe5:   /* T4 INW F(e)ax Ib */
      D_Ib(1);

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[1].sng, WORD_WIDTH);

	 IN16(&ops[0].sng, ops[1].sng);
	 P_Fax(0);
#ifdef PIG
	 UPDATE_INTEL_IP(p);
#endif
         PIG_SYNCH(CHECK_NO_AX);
	 }
      else   /* USE32 */
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[1].sng, DWORD_WIDTH);

	 IN32(&ops[0].sng, ops[1].sng);
	 P_Feax(0);
#ifdef PIG
	 UPDATE_INTEL_IP(p);
#endif
	 PIG_SYNCH(CHECK_NO_EAX);
	 }
      quick_mode = FALSE;
      break;

   case 0xe6:   /* T6 OUTB Ib Fal */
      D_Ib(0);

      if ( GET_CPL() > GET_IOPL() || GET_VM() )
	 check_io_permission_map(ops[0].sng, BYTE_WIDTH);

      F_Fal(1);
      OUT8(ops[0].sng, ops[1].sng);
#ifdef PIG
      UPDATE_INTEL_IP(p);
      if (ops[0].sng == 0x60)
         {
	      /* This may be a change of A20 wrap status */
	      PIG_SYNCH(CHECK_NO_A20);
         }
      else
         {
         PIG_SYNCH(CHECK_ALL);
         }
#else
      SYNCH_TICK();
#endif
      break;

   case 0xe7:   /* T6 OUTW Ib F(e)ax */
      D_Ib(0);

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[0].sng, WORD_WIDTH);

	 F_Fax(1);
	 OUT16(ops[0].sng, ops[1].sng);
	 }
      else   /* USE32 */
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[0].sng, DWORD_WIDTH);

	 F_Feax(1);
	 OUT32(ops[0].sng, ops[1].sng);
	 }
#ifdef PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_ALL);
      quick_mode = FALSE;
      break;

   case 0xe8:   /* T2 CALL Jv */
      inst32 = CALLR;
      took_absolute_toc = TRUE;
TYPEE8:

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 D_Jw(0);
	 }
      else   /* USE32 */
	 {
	 D_Jd(0);
	 }

      UPDATE_INTEL_IP_USE_OP_SIZE(p);
      (*inst32)(ops[0].sng);
      CANCEL_HOST_IP();
      PIG_SYNCH(CHECK_ALL);
      break;

   case 0xe9:   /* T2 JMP Jv */
      inst32 = JMPR;
      took_absolute_toc = TRUE;
      goto TYPEE8;
   case 0xea:   /* T2 JMP Ap */
      instp32 = JMPF;
      took_absolute_toc = TRUE;
      goto TYPE9A;
   case 0xeb:   /* T2 JMP Jb */
      inst32 = JMPR;
      took_absolute_toc = TRUE;
      goto TYPE70;

   case 0xec:   /* T4 INB Fal Fdx */
      F_Fdx(1);

      if ( GET_CPL() > GET_IOPL() || GET_VM() )
	 check_io_permission_map(ops[1].sng, BYTE_WIDTH);

      IN8(&ops[0].sng, ops[1].sng);
      P_Fal(0);
#ifdef	PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_NO_AL);
      quick_mode = FALSE;
      break;

   case 0xed:   /* T4 INW F(e)ax Fdx */
      F_Fdx(1);

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[1].sng, WORD_WIDTH);

	 IN16(&ops[0].sng, ops[1].sng);
	 P_Fax(0);
#ifdef PIG
	 UPDATE_INTEL_IP(p);
#endif
         PIG_SYNCH(CHECK_NO_AX);
	 }
      else   /* USE32 */
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[1].sng, DWORD_WIDTH);

	 IN32(&ops[0].sng, ops[1].sng);
	 P_Feax(0);
#ifdef PIG
	 UPDATE_INTEL_IP(p);
#endif
         PIG_SYNCH(CHECK_NO_EAX);
	 }
      quick_mode = FALSE;
      break;

   case 0xee:   /* T6 OUTB Fdx Fal */
      F_Fdx(0);

      if ( GET_CPL() > GET_IOPL() || GET_VM() )
	 check_io_permission_map(ops[0].sng, BYTE_WIDTH);

      F_Fal(1);
      OUT8(ops[0].sng, ops[1].sng);
#ifdef	PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_ALL);
      quick_mode = FALSE;
      break;

   case 0xef:   /* T6 OUTW Fdx F(e)ax */
      F_Fdx(0);

      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[0].sng, WORD_WIDTH);

	 F_Fax(1);
	 OUT16(ops[0].sng, ops[1].sng);
	 }
      else   /* USE32 */
	 {
	 if ( GET_CPL() > GET_IOPL() || GET_VM() )
	    check_io_permission_map(ops[0].sng, DWORD_WIDTH);

	 F_Feax(1);
	 OUT32(ops[0].sng, ops[1].sng);
	 }
#ifdef	PIG
      UPDATE_INTEL_IP(p);
#endif
      PIG_SYNCH(CHECK_ALL);
      quick_mode = FALSE;
      break;

   case 0xf0:   /* T0 LOCK */
      CHECK_PREFIX_LENGTH();
      goto DECODE;   /* NB. Incorrect Emulation! */

   case 0xf1:
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0xf2:
      repeat = REP_NE;
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0xf3:
      repeat = REP_E;
      CHECK_PREFIX_LENGTH();
      goto DECODE;

   case 0xf4:   /* T0 HLT */
      if ( GET_CPL() != 0 )
	 GP((IU16)0, FAULT_CCPU_HLT_ACCESS);

      /* Wait for an interrupt */

      UPDATE_INTEL_IP(p);
      PIG_SYNCH(CHECK_ALL);

#ifndef PIG

       while ( TRUE )
	 {
	 /* RESET ends the halt state. */
	 if ( cpu_interrupt_map & CPU_RESET_EXCEPTION_MASK )
	    break;

	 /* An enabled INTR ends the halt state. */
	 if ( GET_IF() && cpu_interrupt_map & CPU_HW_INT_MASK )
	    break;

	 /* As time goes by. */
	 if (cpu_interrupt_map & CPU_SIGALRM_EXCEPTION_MASK)
	    {
	    cpu_interrupt_map &= ~CPU_SIGALRM_EXCEPTION_MASK;
	    host_timer_event();
	    }

#ifndef	PROD
	 if (cpu_interrupt_map & CPU_SAD_EXCEPTION_MASK)
	    {
	    cpu_interrupt_map &= ~CPU_SAD_EXCEPTION_MASK;
	    force_yoda();
	    }
#endif	/* PROD */

         SYNCH_TICK();
         QUICK_EVENT_TICK();
	 }
	quick_mode = FALSE;

#endif	/* PIG */

      break;

   case 0xf5:   /* T0 CMC */
      CMC();
      break;

   case 0xf6:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T6 TEST Eb Ib */
      case 1:
	 inst32328 = TEST;
	 goto TYPE80_7;

      case 2:   /* T1 NOT Eb */
	 D_Eb(0, RW0, PG_W);
	 F_Eb(0);
	 NOT(&ops[0].sng);
	 P_Eb(0);
	 break;

      case 3:   /* T1 NEG Eb */
	 instp328 = NEG;
TYPEF6_3:

	 D_Eb(0, RW0, PG_W);
	 F_Eb(0);
	 (*instp328)(&ops[0].sng, 8);
	 P_Eb(0);
	 break;

      case 4:   /* T5 MUL Fal Eb */
	 instp3232 = MUL8;
TYPEF6_4:

	 D_Eb(1, RO1, PG_R);
	 F_Fal(0);
	 F_Eb(1);
	 (*instp3232)(&ops[0].sng, ops[1].sng);;
	 P_Fal(0);
	 break;

      case 5:   /* T5 IMUL Fal Eb */   instp3232 = IMUL8;   goto TYPEF6_4;

      case 6:   /* T2 DIV Eb */
	 inst32 = DIV8;
TYPEF6_6:

	 D_Eb(0, RO0, PG_R);
	 F_Eb(0);
	 (*inst32)(ops[0].sng);
	 break;

      case 7:   /* T2 IDIV Eb */   inst32 = IDIV8;   goto TYPEF6_6;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;

   case 0xf7:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T6 TEST Ev Iv */
      case 1:
	 inst32328 = TEST;
	 goto TYPE81_7;

      case 2:   /* T1 NOT Ew */
	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RW0, PG_W);
	    F_Ew(0);
	    NOT(&ops[0].sng);
	    P_Ew(0);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RW0, PG_W);
	    F_Ed(0);
	    NOT(&ops[0].sng);
	    P_Ed(0);
	    }
	 break;

      case 3:   /* T1 NEG Ew */
	 instp328 = NEG;
TYPEF7_3:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RW0, PG_W);
	    F_Ew(0);
	    (*instp328)(&ops[0].sng, 16);
	    P_Ew(0);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RW0, PG_W);
	    F_Ed(0);
	    (*instp328)(&ops[0].sng, 32);
	    P_Ed(0);
	    }
	 break;

      case 4:   /* T5 MUL F(e)ax Ev */
	 instp3232 = MUL16;
	 inst2p3232 = MUL32;
TYPEF7_4:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(1, RO1, PG_R);
	    F_Fax(0);
	    F_Ew(1);
	    (*instp3232)(&ops[0].sng, ops[1].sng);;
	    P_Fax(0);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(1, RO1, PG_R);
	    F_Feax(0);
	    F_Ed(1);
	    (*inst2p3232)(&ops[0].sng, ops[1].sng);
	    P_Feax(0);
	    }
	 break;

      case 5:   /* T5 IMUL F(e)ax Ev */
	 instp3232 = IMUL16;
	 inst2p3232 = IMUL32;
	 goto TYPEF7_4;

      case 6:   /* T2 DIV Ev */
	 inst32 = DIV16;
	 inst232 = DIV32;
TYPEF7_6:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RO0, PG_R);
	    F_Ew(0);
	    (*inst32)(ops[0].sng);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RO0, PG_R);
	    F_Ed(0);
	    (*inst232)(ops[0].sng);
	    }
	 break;

      case 7:   /* T5 IDIV Ev */
	 inst32 = IDIV16;
	 inst232 = IDIV32;
	 goto TYPEF7_6;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;

   case 0xf8:   /* T0 CLC */
      CLC();
      break;

   case 0xf9:   /* T0 STC */
      STC();
      break;

   case 0xfa:   /* T0 CLI */
      if ( GET_CPL() > GET_IOPL() )
	 GP((IU16)0, FAULT_CCPU_CLI_ACCESS);
      CLI();
      break;

   case 0xfb:   /* T0 STI */
      if ( GET_CPL() > GET_IOPL() )
	 GP((IU16)0, FAULT_CCPU_STI_ACCESS);
      STI();

      /* locally update IP - interrupts are supressed after STI */
      UPDATE_INTEL_IP(p);

#ifdef PIG
      /* We need to pig sync one instr *after* an STI that enabled
       * interrupts, because the A4CPU might need to take a H/W interrupt
       */
      single_instruction_delay = TRUE;
      PIG_SYNCH(CHECK_ALL);
#endif /* PIG */
      goto NEXT_INST;

   case 0xfc:   /* T0 CLD */
      CLD();
      break;

   case 0xfd:   /* T0 STD */
      STD();
      break;

   case 0xfe:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T1 INC Eb */   instp328 = INC;   goto TYPEF6_3;
      case 1:   /* T1 DEC Eb */   instp328 = DEC;   goto TYPEF6_3;

      case 2: case 3: case 4: case 5: case 6: case 7:
	 Int6();
	 break;
	 }
      break;

   case 0xff:
      modRM = GET_INST_BYTE(p);
      switch ( GET_XXX(modRM) )
	 {
      case 0:   /* T1 INC Ev */   instp328 = INC;   goto TYPEF7_3;
      case 1:   /* T1 DEC Ev */   instp328 = DEC;   goto TYPEF7_3;

      case 2:   /* T2 CALL Ev */
	 inst32 = CALLN;
	 took_absolute_toc = TRUE;
TYPEFF_2:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Ew(0, RO0, PG_R);
	    F_Ew(0);
	    }
	 else   /* USE32 */
	    {
	    D_Ed(0, RO0, PG_R);
	    F_Ed(0);
	    }

	 UPDATE_INTEL_IP_USE_OP_SIZE(p);
	 (*inst32)(ops[0].sng);
	 CANCEL_HOST_IP();
	 PIG_SYNCH(CHECK_ALL);
	 break;

      case 3:   /* T2 CALL Mp */
	 instp32 = CALLF;
	 took_absolute_toc = TRUE;
TYPEFF_3:

	 if ( GET_OPERAND_SIZE() == USE16 )
	    {
	    D_Mp16(0, RO0, PG_R);
	    F_Mp16(0);
	    }
	 else   /* USE32 */
	    {
	    D_Mp32(0, RO0, PG_R);
	    F_Mp32(0);
	    }

	 UPDATE_INTEL_IP_USE_OP_SIZE(p);
	 (*instp32)(ops[0].mlt);
	 CANCEL_HOST_IP();
	 PIG_SYNCH(CHECK_ALL);
	 break;

      case 4:   /* T2 JMP  Ev */
	      inst32 = JMPN;
	      took_absolute_toc = TRUE;
	      goto TYPEFF_2;
      case 5:   /* T2 JMP  Mp */
	      instp32 = JMPF;
	      took_absolute_toc = TRUE;
	      goto TYPEFF_3;
      case 6:   /* T2 PUSH Ev */
	 inst32 = PUSH;
	 inst232 = PUSH;
	 goto TYPEF7_6;

      case 7:
	 Int6();
	 break;
	 } /* end switch ( GET_XXX(modRM) ) */
      break;
      } /* end switch ( opcode ) */

   /* >>>>> Instruction Completed. <<<<< */

   /* Reset default mode */
   SET_OPERAND_SIZE(GET_CS_AR_X());
   SET_ADDRESS_SIZE(GET_CS_AR_X());

   /*
      Increment instruction pointer.
      NB. For most instructions we increment the IP after processing
      the instruction, however all users of the IP (eg flow of control)
      instructions are coded on the basis that IP has already been
      updated, so where necessary we update IP before the instruction.
      In those cases p_start is also updated so that this code can
      tell that IP has already been updated.
    */
   if ( p != p_start )
      UPDATE_INTEL_IP(p);

   /*
      Move start of inst to the next inst. We have successfully
      completed instruction and are now going on to inter-instruction
      checks.
    */
   CCPU_save_EIP = GET_EIP();

   /*
      Now check for interrupts/external events/breakpoints...
    */

   if ( quick_mode && GET_DR(DR_DSR) == 0 )
      goto DO_INST;

#ifdef SYNCH_TIMERS
 CHECK_INTERRUPT:
#endif /* SYNCH_TIMERS */
   quick_mode = FALSE;

   /* Action RESET first. <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
#ifdef SYNCH_TIMERS
   if (took_absolute_toc || took_relative_jump)
#endif /* SYNCH_TIMERS */
   if (cpu_interrupt_map & CPU_RESET_EXCEPTION_MASK)
      {
      cpu_interrupt_map &= ~CPU_RESET_EXCEPTION_MASK;
      c_cpu_reset();
      doing_contributory = FALSE;
      doing_page_fault = FALSE;
      doing_double_fault = FALSE;
      doing_fault = FALSE;
      EXT = INTERNAL;
      SET_POP_DISP(0);
      goto NEXT_INST;
      }

   /* Action Insignia (ie non Intel) Processing. <<<<<<<<<<<<<<< */

#ifdef SYNCH_TIMERS
   if (took_absolute_toc || took_relative_jump)
#endif /* SYNCH_TIMERS */
   if (cpu_interrupt_map & CPU_SIGALRM_EXCEPTION_MASK)
      {
      cpu_interrupt_map &= ~CPU_SIGALRM_EXCEPTION_MASK;
      host_timer_event();
      }

   if (cpu_interrupt_map & CPU_SAD_EXCEPTION_MASK)
      {
      cpu_interrupt_map &= ~CPU_SAD_EXCEPTION_MASK;
      force_yoda();
      }

   /* INTEL inter instruction processing. <<<<<<<<<<<<<<<<<<<<<<<*/

   /* Reset default mode */
   SET_OPERAND_SIZE(GET_CS_AR_X());
   SET_ADDRESS_SIZE(GET_CS_AR_X());

   /* Check for single step trap */
   if ( start_trap )
      {
      SET_DR(DR_DSR, GET_DR(DR_DSR) | DSR_BS_MASK);   /* set BS */
      Int1_t();   /* take TF trap */
      }

   /* check for debug traps */
   if ( GET_DR(DR_DSR) &
	(DSR_BT_MASK | DSR_B3_MASK | DSR_B2_MASK | DSR_B1_MASK |
	 DSR_B0_MASK) )
      {
      Int1_t();   /* at least one breakpoint set from:-
		     T-bit or DATA Breakpoints */
      }

   if ( nr_inst_break && GET_RF() == 0 )
      {
      check_for_inst_exception(GET_CS_BASE() + GET_EIP());
      if ( GET_DR(DR_DSR) )
	 {
	 Int1_f();   /* a CODE Breakpoint triggered */
	 }
      }

#ifdef SYNCH_TIMERS
   if (took_absolute_toc || took_relative_jump)
#endif /* SYNCH_TIMERS */
#ifndef SFELLOW
   if (GET_IF() && (cpu_interrupt_map & CPU_HW_INT_MASK))
      {

/*
 * IRET hooks aren't yet used by the C CPU, but we might want to do in
 * future.
 */

	 IU32 hook_address;	

	 cpu_hw_interrupt_number = ica_intack(&hook_address);
	 cpu_interrupt_map &= ~CPU_HW_INT_MASK;
	 EXT = EXTERNAL;
	 SYNCH_TICK();
	 do_intrupt(cpu_hw_interrupt_number, FALSE, FALSE, (IU16)0);
	 CCPU_save_EIP = GET_EIP();   /* to reflect IP change */
      }
#else	/* SFELLOW */
   if (GET_IF() && (cpu_interrupt_map & (CPU_HW_INT_MASK | CPU_HW_NPX_INT_MASK)))
      {
	/* service any pending real H/W interrupt first */
      	if (cpu_interrupt_map & CPU_HW_INT_MASK)
      	{
		 cpu_hw_interrupt_number = ica_intack();
		 cpu_interrupt_map &= ~CPU_HW_INT_MASK;
		 EXT = EXTERNAL;
		 do_intrupt(cpu_hw_interrupt_number, FALSE, FALSE, (IU16)0);
		 CCPU_save_EIP = GET_EIP();   /* to reflect IP change */
	}
	else
      	if (cpu_interrupt_map & CPU_HW_NPX_INT_MASK)
      	{
		 cpu_hw_interrupt_number = IRQ5_SLAVE_PIC + VectorBase8259Slave();
		 cpu_interrupt_map &= ~CPU_HW_NPX_INT_MASK;
		 EXT = EXTERNAL;
		 do_intrupt(cpu_hw_interrupt_number, FALSE, FALSE, (IU16)0);
		 CCPU_save_EIP = GET_EIP();   /* to reflect IP change */
	}
      }
#endif	/* SFELLOW */

#ifdef PIG
   if ( pig_synch_required )
      {
      if (IgnoringThisSynchPoint(GET_CS_SELECTOR(), GET_EIP()))
      {
      	pig_synch_required = FALSE;
      }
      else
      {
      /* If the destination is going to page fault, or need
       * accessing, then the EDL CPU will do so before issuing
       * the pig synch. We use the dasm386 decode to prefetch
       * a single instruction which mimics the EDL Cpu's behaviour
       * when close to a page boundary.
       */
      prefetch_1_instruction();	/* Will PF if destination not present */
#if defined(SFELLOW)
      /*
       * Check for occurrence of memory-mapped input.
       * This initial crude implementation just leaves the entire synch
       * section unchecked.
       */
      if ( pig_mmio_info.flags & MM_INPUT_OCCURRED )
      {
         pig_cpu_action = CHECK_NONE;	/* cos' its effects are unknown */
#if COLLECT_MMIO_STATS
         if ( ++pig_mmio_info.mm_input_section_count == 0 )
            pig_mmio_info.flags |= MM_INPUT_SECTION_COUNT_WRAPPED;
#endif	/* COLLECT_MMIO_STATS */
      }
      if ( pig_mmio_info.flags & MM_OUTPUT_OCCURRED )
      {
#if COLLECT_MMIO_STATS
         if ( ++pig_mmio_info.mm_output_section_count == 0 )
            pig_mmio_info.flags |= MM_OUTPUT_SECTION_COUNT_WRAPPED;
#endif	/* COLLECT_MMIO_STATS */
      }
#endif	/* SFELLOW */
      ccpu_synch_count++;
      c_cpu_unsimulate();
      }
      }
#endif /* PIG */

NEXT_INST:

   CCPU_save_EIP = GET_EIP();   /* to reflect IP change */

#if defined(SFELLOW) && !defined(PROD)
	if (sf_debug_char_waiting())
	{
	   force_yoda();
	}
#endif	/* SFELLOW && !PROD */

   /* Reset default mode */
   SET_OPERAND_SIZE(GET_CS_AR_X());
   SET_ADDRESS_SIZE(GET_CS_AR_X());
   took_relative_jump = FALSE;
   took_absolute_toc = FALSE;

   SETUP_HOST_IP(p);

   /*
      THIS IS A CHEAT.
      The Intel documentation says RF is cleared AFTER all instructions
      except (POPF, IRET or TASK SWITCH). To save clearing RF for each
      and every instruction with a special test for the named exceptions
      we clear RF before the instruction, we are assuming the
      instruction will now be successful. As all the fault handlers set
      RF in the pushed flags it will appear that RF was left set when
      instructions don't run to completion from this point.
      So although we cheat we intend to have the same effect as the
      real thing.
    */
   SET_RF(0);

   start_trap = GET_TF();

   /* Determine if we can go into quick mode */
   if ( cpu_interrupt_map == 0 &&
	start_trap == 0 &&
	nr_inst_break == 0
#ifdef PIG
	&& !pig_synch_required
#endif
	)
      {
	quick_mode = TRUE;
      }

   goto DO_INST;
   }

#define MAP_BASE_ADDR 0x66

LOCAL IUM32 width_mask[4] = { 0x1, 0x3, 0, 0xf };

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check IO access against Permission Map in TSS.                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
   check_io_permission_map IFN2
      (
      IU32, port,	/* address of 1st port being accessed */
      IUM8, width	/* bytes (1|2|4) accessed */
      )
      {
      IU16 map_start_offset;
      IU16 map_word_offset;
      IU16 map_word;

      /* if invalid or 286 TSS, just take exception */
      if ( GET_TR_SELECTOR() == 0 || GET_TR_AR_SUPER() == BUSY_TSS )
	 GP((IU16)0, FAULT_CHKIOMAP_BAD_TSS);

      if ( MAP_BASE_ADDR >= GET_TR_LIMIT() )
	 GP((IU16)0, FAULT_CHKIOMAP_BAD_MAP);   /* No I/O Map Base Address. */

      /* Read bit map start address */
      map_start_offset = spr_read_word(GET_TR_BASE() + MAP_BASE_ADDR);

      /* Now try to read reqd word from bit map */
      map_word_offset = map_start_offset + port/8;
      if ( map_word_offset >= GET_TR_LIMIT() )
	 GP((IU16)0, FAULT_CHKIOMAP_BAD_TR);   /* Map truncated before current port */
      
      /* Actually read word and check appropriate bits */
      map_word = spr_read_word(GET_TR_BASE() + map_word_offset);
      map_word = map_word >> port%8;   /* bits to lsb's */
      if ( map_word & width_mask[width-1] )
	 GP((IU16)0, FAULT_CHKIOMAP_ACCESS);   /* Access dis-allowed */
      
      /* ACCESS OK */
      }

   /*
      =====================================================================
      EXTERNAL FUNCTIONS START HERE.
      =====================================================================
    */

#ifndef SFELLOW

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Set the CPU heartbeat timer (for quick events).                    */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID c_cpu_q_ev_set_count IFN1( IU32, countval )
      {
/*	printf("setting q counter to %d\n", countval); */
      cpu_heartbeat = countval;
      }

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Calculate (ie guess) the number of CPU heartbeat timer ticks to    */
   /* will have gone by for a given number of microseconds.	      */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL IU32 c_cpu_calc_q_ev_inst_for_time IFN1( IU32, time )
      {
      return ( time );
      }

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Get the CPU heartbeat timer (for quick events).                    */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL IU32 c_cpu_q_ev_get_count()
      {
/*	printf("returning q counter as %d\n", cpu_heartbeat); */
      return cpu_heartbeat;
      }

#endif	/* SFELLOW */

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Set up new page for fast Instruction Decoding.                     */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL IU8
   ccpu_new_code_page
		     
   IFN1(
	   IU8 **, q	/* pntr. to host format IP pointer */
       )

    /* ANSI */
      {
      IU32 ip_phy_addr;	/* Used when setting up IP (cf SETUP_HOST_IP) */

      /* update Intel IP up to end of the old page */
      SET_EIP(GET_EIP() + DIFF_INST_BYTE(*q, p_start));

      /* move onto new page in host format */
      SETUP_HOST_IP(*q)
      p_start = *q;

#ifdef	PIG
      return *IncCpuPtrLS8(*q);
#else /* PIG */
#ifdef BACK_M
      return *(*q)--;
#else
      return *(*q)++;
#endif /* BACK_M */
#endif /* PIG */
      }

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Initialise the CPU.                                                */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID
   c_cpu_init IFN0()
      {
      SAVED IBOOL first = TRUE;

#ifdef	PIG
      SAVED char default_flags[] = "faults accessed";

      if (first)
      {
	char *s = getenv("FLAGS_IGNORE_DEFAULT");
	if (s)
	  set_flags_ignore(s);
	else
	  set_flags_ignore(default_flags);
	single_instruction_delay_enable = FALSE;
	s = getenv("SINGLE_INSTRUCTION_BLIND_SPOT");
	if (s)
	{
	    if (strcmp(s, "TRUE") == 0)
	       single_instruction_delay_enable = TRUE;
	    else if (strcmp(s, "FALSE") == 0)
	       single_instruction_delay_enable = FALSE;
	    else
	       printf("*** Ignoring getenv(\"SINGLE_INSTRUCTION_BLIND_SPOT\") value\n");
	    printf("STI/POPF %s cause a blind spot after next conditional\n",
		   single_instruction_delay_enable ? "will": "will not");
        }
	first = FALSE;
      }
#endif	/* PIG */

#ifdef NTVDM
      ccpu386InitThreadStuff();
#endif

      c_cpu_reset();
      SET_POP_DISP(0);
      doing_contributory = FALSE;
      doing_page_fault = FALSE;
      doing_double_fault = FALSE;
      doing_fault = FALSE;
      EXT = INTERNAL;
      }

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * Make CPU aware that external event is pending.                     
    * Be careful about modifying this function, as much of the base and host
    * in A2CPU will modify cpu_interrupt_map directly, rather than going through
    * this function. 
    *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    */
   GLOBAL VOID
   c_cpu_interrupt IFN2(CPU_INT_TYPE, type, IU16, number)
      {
      switch ( type )
	 {
      case CPU_HW_RESET:
	 cpu_interrupt_map |= CPU_RESET_EXCEPTION_MASK;
	 break;
      case CPU_TIMER_TICK:
	 cpu_interrupt_map |= CPU_SIGALRM_EXCEPTION_MASK;
	 break;
      case CPU_SIGIO_EVENT:
	 cpu_interrupt_map |= CPU_SIGIO_EXCEPTION_MASK;
	 break;
      case CPU_HW_INT:
	 cpu_interrupt_map |= CPU_HW_INT_MASK;
	 break;
      case CPU_SAD_INT:
	 cpu_interrupt_map |= CPU_SAD_EXCEPTION_MASK;
	 break;
	 }
      quick_mode = FALSE;
      }

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Act like CPU 'reset' line activated. (Well nearly)                 */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID
   c_cpu_reset IFN0()
      {
      IBOOL disableNpx = FALSE;

      /* All FLAGS are cleared */
      /* NB. VM MUST BE CLEARED BEFORE SEGMENT REGISTERS ARE LOADED. */
#ifdef SPC486
      SET_AC(0);
#endif /* SPC486 */
      SET_RF(0); SET_VM(0); SET_NT(0); SET_IOPL(0);
      SET_PF(0); SET_CF(0); SET_AF(0); SET_ZF(0); SET_SF(0); SET_OF(0);
      SET_TF(0); SET_IF(0); SET_DF(0);

      SET_EIP(0xFFF0);
      SET_CPL(0);

      SET_CS_SELECTOR(0xF000);
      SET_CS_BASE(0xf0000);	/* Really 0xffff0000 */
      load_pseudo_descr(CS_REG);

      SET_SS_SELECTOR(0);
      SET_SS_BASE(0);
      load_pseudo_descr(SS_REG);

      SET_DS_SELECTOR(0);
      SET_DS_BASE(0);
      load_pseudo_descr(DS_REG);

      SET_ES_SELECTOR(0);
      SET_ES_BASE(0);
      load_pseudo_descr(ES_REG);

      SET_FS_SELECTOR(0);
      SET_FS_BASE(0);
      load_pseudo_descr(FS_REG);

      SET_GS_SELECTOR(0);
      SET_GS_BASE(0);
      load_pseudo_descr(GS_REG);

      SET_CR(CR_STAT, 0);
#ifdef SPC486
      SET_CD(1);
      SET_NW(1);
#endif /* SPC486 */

      SET_DR(DR_DAR0, 0);   /* Really Undefined */
      SET_DR(DR_DAR1, 0);   /* Really Undefined */
      SET_DR(DR_DAR2, 0);   /* Really Undefined */
      SET_DR(DR_DAR3, 0);   /* Really Undefined */
      SET_DR(DR_DSR, 0);    /* Really Undefined */
      MOV_DR((IU32) DR_DCR, (IU32) 0);   /* Disable Breakpoints */

      SET_TR(TR_TCR, 0);   /* Really Undefined */
      SET_TR(TR_TDR, 0);   /* Really Undefined */

      SET_IDT_BASE(0); SET_IDT_LIMIT(0x3ff);

      /* Really Undefined */
      SET_GDT_BASE(0); SET_GDT_LIMIT(0);

      SET_LDT_SELECTOR(0); SET_LDT_BASE(0); SET_LDT_LIMIT(0);

      SET_TR_SELECTOR(0);  SET_TR_BASE(0);  SET_TR_LIMIT(0);
      SET_TR_AR_SUPER(3);

      SET_EAX(0);
      SET_ECX(0);   /* Really Undefined */
#ifdef SPC486
      SET_EDX(0x0000E401);	/* Give component ID : revision ID */
#else
      SET_EDX(0x00000303);	/* Give component ID : revision ID */
#endif
      SET_EBX(0);   /* Really Undefined */
      SET_ESP(0);	/* Really Undefined */
      SET_EBP(0);   /* Really Undefined */
      SET_ESI(0);   /* Really Undefined */
      SET_EDI(0);   /* Really Undefined */


#if defined(SWITCHNPX)
      if (!config_inquire(C_SWITCHNPX, NULL))
	      disableNpx = TRUE;
#endif	/* SWITCHNPX */

      if ( disableNpx )
	 SET_ET(0);
      else
	 SET_ET(1);

      InitNpx(disableNpx);
      }



   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Entry point to CPU.                                                */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID
   c_cpu_simulate IFN0()
      {
      SYNCH_TICK();
      if (simulate_level >= FRAMES)
	 fprintf(stderr, "Stack overflow in host_simulate()!\n");

      /* Save current context and invoke a new CPU level */
#ifdef NTVDM
      if ( setjmp(ccpu386SimulatePtr()) == 0)
#else
      if ( setjmp(longjmp_env_stack[simulate_level++]) == 0 )
#endif
	 {
	 in_C = 0;
	 ccpu(FALSE);
	 }
      }

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Restart (Continue) point for CPU.                                  */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID
   c_cpu_continue IFN0()
      {
#ifdef NTVDM
      ccpu386GotoThrdExptnPt();
#else
      longjmp(next_inst[simulate_level-1], 1);
#endif
      }

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* Exit point from CPU.                                               */
   /* Called from CPU via 'BOP FE' to exit the current CPU invocation    */
   /* Or from CPU via '0F 0F' for the PIG_TESTER.                        */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID
   c_cpu_unsimulate IFN0()
      {
#ifdef NTVDM
      ccpu386Unsimulate();
#else
      if (simulate_level == 0)
         {
	 fprintf(stderr, "host_unsimulate() - already at base of stack!\n");
#ifndef	PROD
	 force_yoda();
#endif	/* PROD */	 
	 }
      else
	 {
	 /* Return to previous context */
	 in_C = 1;
	 longjmp(longjmp_env_stack[--simulate_level], 1);
	 }
#endif
      }

#ifdef	PIG
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* To push an interrupt frame in response to an external interrupt.   */
   /* Called from CPU under test, just before it processes the interrupt */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID
   c_pig_interrupt
   IFN1(
	   IU8, vector
       )

      {
      if (simulate_level >= FRAMES)
	 fprintf(stderr, "Stack overflow in c_do_interrupt()!\n");

      /* Save current context and invoke a new CPU level */
#ifdef NTVDM
      if ( setjmp(ccpu386SimulatePtr()) == 0)
#else
      if ( setjmp(longjmp_env_stack[simulate_level++]) == 0 )
#endif
	 {
	 in_C = 0;
	 EXT = EXTERNAL;

         /* Reset default mode */
         SET_OPERAND_SIZE(GET_CS_AR_X());
         SET_ADDRESS_SIZE(GET_CS_AR_X());

	 do_intrupt((IU16)vector, FALSE, FALSE, (IU16)0);
	 }
      }
#endif	/* PIG */


   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* End of application hook.                                           */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID
   c_cpu_EOA_hook IFN0()
      {
	   /* Do nothing */
      }

   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   /* SoftPC termination hook.                                           */
   /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
   GLOBAL VOID
   c_cpu_terminate IFN0()
      {
	   /* Do nothing */
      }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_main.h ===
/*[

c_main.h

LOCAL CHAR SccsID[]="@(#)c_main.h	1.11 09/02/94";

C CPU definitions and interfaces.
---------------------------------

]*/


/*
   Define major CPU varients here.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */
/* Indicator that multiple shifts or rotates (ie count n != 1) should
   treat the Overflow Flag as undefined. */
#define SHIFTROT_N_OF_UNDEFINED

/* Indicator to set MUL undefined flags to a specific value (else they
   are left unchanged). */
#define SET_UNDEFINED_MUL_FLAG

/* Indicator to set DIV undefined flags to a specific value (else they
   are left unchanged). */
#define SET_UNDEFINED_DIV_FLAG

/* Indicator to set SHRD/SHLD undefined flags (i.e. OF with shift > 1)
   to a specific value (else they are left unchanged). */
#define SET_UNDEFINED_SHxD_FLAG

/* Indicator to set all other undefined flags to a specific value (else they
   are left unchanged). */
#define SET_UNDEFINED_FLAG

/* Value to set undefined flags to (if they are not left unchanged). */
#define UNDEFINED_FLAG 0


/*
   Rational definition of TRUE/FALSE.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Leads to more efficient tests than other definitions.
typedef int BOOL;
#define FALSE ((BOOL)0)
#define TRUE  ((BOOL)1)
 */


/*
   Allowable types of segment prefixs.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Actually we define here only a type for no segment prefix,
   otherwise the segment register names (CS_REG,DS_REG,...) are used.
 */
#define SEG_CLR 6


/*
   Frequently used constants.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

/* Masks for bits 0 - 32. */
#define BIT0_MASK         0x1
#define BIT1_MASK         0x2
#define BIT2_MASK         0x4
#define BIT3_MASK         0x8
#define BIT4_MASK        0x10
#define BIT5_MASK        0x20
#define BIT6_MASK        0x40
#define BIT7_MASK        0x80
#define BIT8_MASK       0x100
#define BIT9_MASK       0x200
#define BIT10_MASK      0x400
#define BIT11_MASK      0x800
#define BIT12_MASK     0x1000
#define BIT13_MASK     0x2000
#define BIT14_MASK     0x4000
#define BIT15_MASK     0x8000
#define BIT16_MASK    0x10000
#define BIT17_MASK    0x20000
#define BIT18_MASK    0x40000
#define BIT19_MASK    0x80000
#define BIT20_MASK   0x100000
#define BIT21_MASK   0x200000
#define BIT22_MASK   0x400000
#define BIT23_MASK   0x800000
#define BIT24_MASK  0x1000000
#define BIT25_MASK  0x2000000
#define BIT26_MASK  0x4000000
#define BIT27_MASK  0x8000000
#define BIT28_MASK 0x10000000
#define BIT29_MASK 0x20000000
#define BIT30_MASK 0x40000000
#define BIT31_MASK 0x80000000

/* Various Intel component masks */
#define BYTE_MASK   0xff
#define WORD_MASK 0xffff

/* Widths for IO permission map checks */
#define BYTE_WIDTH ((IUM8)1)
#define WORD_WIDTH ((IUM8)2)
#define DWORD_WIDTH ((IUM8)4)

/*
   Data structures.
   ~~~~~~~~~~~~~~~~
 */

/* Our model for the data extracted from a decriptor entry.  */
typedef struct
   {
   IU32 base;		/* 32-bit base address */
   IU32 limit;		/* 32-bit offset limit */
   IU16  AR;		/* 16-bit attributes/access rights */
   } CPU_DESCR;


/*
   Table for converting byte quantity to Parity Flag.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */
IMPORT IU8 pf_table[];

#ifdef	PIG
IMPORT IBOOL took_relative_jump;
#endif	/* PIG */


/*
   External interface provided to outside world.
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

typedef IU16	IO_ADDR;

#ifndef DOUBLE_CPU
/*
   Note we can't include "cpu.h" as this would overwrite our macro
   names, hence we must redefine the external subroutines here.
 */
IMPORT IU32 effective_addr IPT2(
   IU16, selector,
   IU32, offset
   );

IMPORT VOID c_cpu_enable_a20 IPT0();

IMPORT VOID c_cpu_force_a20_low IPT0();

IMPORT VOID c_cpu_init IPT0();

IMPORT VOID c_cpu_reset IPT0();

IMPORT VOID c_cpu_continue IPT0();

IMPORT VOID c_cpu_simulate IPT0();

IMPORT VOID c_pig_interrupt IPT1(IU8, vector);

IMPORT VOID c_cpu_unsimulate IPT0();


#if 0				/* ROG */
IMPORT VOID read_descriptor IPT2(
   IU32, addr,
   CPU_DESCR *, descr
   );

IMPORT ISM32 selector_outside_table IPT2(
   IU16, selector,
   IU32 *, descr_addr
   );

#endif				/* 0 ROG */

#endif /* !DOUBLE_CPU */

/*
   Useful mini functions (macros).
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

/*
   Macros for access to MODRM bit fields.

	   7 6 5 4 3 2 1 0
	  =================
   MODRM  |   |     |     |
	  =================
	  MODE  REG   R_M
		XXX   LOW3
		SEG
		EEE
		SEG3
		SEG2

 */
#define GET_MODE(x)  ((x) >> 6 & 0x3)
#define GET_R_M(x)   ((x) & 0x7)
#define GET_REG(x)   ((x) >> 3 & 0x7)
#define GET_XXX(x)   ((x) >> 3 & 0x7)
#define GET_SEG(x)   ((x) >> 3 & 0x7)
#define GET_EEE(x)   ((x) >> 3 & 0x7)
#define GET_SEG3(x)  ((x) >> 3 & 0x7)
#define GET_SEG2(x)  ((x) >> 3 & 0x7)
#define GET_LOW3(x)  ((x) & 0x7)

/* Turn operand size into mask for Most Significant Bit. */
#define SZ2MSB(x)  ((IU32)0x80000000 >> 32 - x )

/* Turn operand size into mask for Operand. */
#define SZ2MASK(x) ((IU32)0xffffffff >> 32 - x )

#ifdef DOUBLE_CPU

#define HARD_CPU        0
#define SOFT_CPU        1

IMPORT VOID double_switch_to IPT1(IU8, cpu_type);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_getset.c ===
#include "insignia.h"
#include "host_def.h"

/*[
 * ============================================================================
 *
 *	Name:		c_getset.c
 *
 *	Derived From:	pig/getsetc.c
 *
 *	Author:		Andrew Ogle
 *
 *	Created On:	9th Febuary 1993
 *
 *	Sccs ID:	@(#)c_getset.c	1.25 12/06/94
 *
 *	Purpose:
 *
 *		Defines procedures for getting and setting the complete
 *		C CPU status required for instruction and application testing
 *		against the assembler CPU.
 *		These routines are used by both the instruction and application
 *		piggers.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 *
 * ============================================================================
]*/

#if defined(PIG)


/*
 * Get access to C CPU's global defintions.
 */
#include <xt.h>
#define CPU_PRIVATE
#include CpuH
#include <evidgen.h>

/*
 * Local structure definitions.
 */
#include "c_reg.h"
#include <Fpu_c.h>
#include <PigReg_c.h>
#include <ccpupig.h>
#include <ccpusas4.h>

LOCAL	cpustate_t	*p_current_state; /* used to check if NPX regs valid */

/*(
============================ c_setCpuNpxRegisters =============================
PURPOSE:
	The NPX registers are only transfered on demand from the CPU
	under test (EDL) to the CCPU. This is because the information
	involved is large and costly to process since it must be stored
	textually in the state structure.
===============================================================================
)*/
GLOBAL	void	c_setCpuNpxRegisters IFN1(cpustate_t *, p_state)
{
	setNpxControlReg(p_state->NPX_regs.NPX_control);
	setNpxStatusReg(p_state->NPX_regs.NPX_status);
	setNpxStackRegs(p_state->NPX_regs.NPX_ST);
	setNpxTagwordReg(p_state->NPX_regs.NPX_tagword);
}

/*(
============================ c_checkCpuNpxRegisters ===========================
PURPOSE:
	retrieves the NPX state from the assembler CPU and updates the Ccpu.
===============================================================================
)*/
GLOBAL	void	c_checkCpuNpxRegisters IFN0()
{
	if (p_current_state->NPX_valid)
	{
		/* The CCPU already has the NPX registers */
		return;
	}
	GetAcpuNpxRegisters(p_current_state);
	p_current_state->NPX_valid = TRUE;
	c_setCpuNpxRegisters(p_current_state);
}


/*(
============================ c_getCpuState =====================================
PURPOSE:
	Saves the complete current state of the C CPU in the passed
	state structure.
===============================================================================
)*/

GLOBAL void
c_getCpuState IFN1(
	cpustate_t *, p_state
)
{
	/*
	 * Recover machine status word, privilege level and instruction
	 */
	p_state->cpu_regs.CR0  = GET_CR(0);
	p_state->cpu_regs.PFLA = GET_CR(2);
	p_state->cpu_regs.PDBR = GET_CR(3);

	p_state->cpu_regs.CPL  = GET_CPL();
	p_state->cpu_regs.EIP  = GET_EIP();

	/*
	 * Recover general registers
	 */
	p_state->cpu_regs.EAX  = GET_EAX();
	p_state->cpu_regs.EBX  = GET_EBX();
	p_state->cpu_regs.ECX  = GET_ECX();
	p_state->cpu_regs.EDX  = GET_EDX();
	p_state->cpu_regs.ESP  = GET_ESP();
	p_state->cpu_regs.EBP  = GET_EBP();
	p_state->cpu_regs.ESI  = GET_ESI();
	p_state->cpu_regs.EDI  = GET_EDI();

	/*
	 * Recover processor status flags.
	 */
	p_state->cpu_regs.EFLAGS = c_getEFLAGS();

	/*
	 * Recover descriptor table registers.
	 */
	p_state->cpu_regs.GDT_base  = GET_GDT_BASE();
	p_state->cpu_regs.GDT_limit = GET_GDT_LIMIT();

	p_state->cpu_regs.IDT_base  = GET_IDT_BASE();
	p_state->cpu_regs.IDT_limit = GET_IDT_LIMIT();

	p_state->cpu_regs.LDT_selector = GET_LDT_SELECTOR();
	p_state->cpu_regs.LDT_base  = GET_LDT_BASE();
	p_state->cpu_regs.LDT_limit = GET_LDT_LIMIT();

	p_state->cpu_regs.TR_selector = GET_TR_SELECTOR();
	p_state->cpu_regs.TR_base  = GET_TR_BASE();
	p_state->cpu_regs.TR_limit = GET_TR_LIMIT();
	p_state->cpu_regs.TR_ar    = c_getTR_AR();

	/*
	 * Recover segment register details
	 */
	p_state->cpu_regs.DS_selector = GET_DS_SELECTOR();
	p_state->cpu_regs.DS_base  = GET_DS_BASE();
	p_state->cpu_regs.DS_limit = GET_DS_LIMIT();
	p_state->cpu_regs.DS_ar = c_getDS_AR();

	p_state->cpu_regs.ES_selector = GET_ES_SELECTOR();
	p_state->cpu_regs.ES_base  = GET_ES_BASE();
	p_state->cpu_regs.ES_limit = GET_ES_LIMIT();
	p_state->cpu_regs.ES_ar    = c_getES_AR();

	p_state->cpu_regs.SS_selector = GET_SS_SELECTOR();
	p_state->cpu_regs.SS_base  = GET_SS_BASE();
	p_state->cpu_regs.SS_limit = GET_SS_LIMIT();
	p_state->cpu_regs.SS_ar    = c_getSS_AR();

	p_state->cpu_regs.CS_selector = GET_CS_SELECTOR();
	p_state->cpu_regs.CS_base = GET_CS_BASE();
	p_state->cpu_regs.CS_limit = GET_CS_LIMIT();
	p_state->cpu_regs.CS_ar = c_getCS_AR();

	p_state->cpu_regs.FS_selector = GET_FS_SELECTOR();
	p_state->cpu_regs.FS_base  = GET_FS_BASE();
	p_state->cpu_regs.FS_limit = GET_FS_LIMIT();
	p_state->cpu_regs.FS_ar    = c_getFS_AR();

	p_state->cpu_regs.GS_selector = GET_GS_SELECTOR();
	p_state->cpu_regs.GS_base  = GET_GS_BASE();
	p_state->cpu_regs.GS_limit = GET_GS_LIMIT();
	p_state->cpu_regs.GS_ar    = c_getGS_AR();

	p_state->video_latches = Cpu.Video->GetVideolatches();

	p_state->NPX_valid = FALSE;

	if ((p_current_state != (cpustate_t *)0) && p_current_state->NPX_valid)
	{
		p_state->NPX_regs.NPX_control = getNpxControlReg();
		p_state->NPX_regs.NPX_status  = getNpxStatusReg();
		p_state->NPX_regs.NPX_tagword = getNpxTagwordReg();
		getNpxStackRegs(&p_state->NPX_regs.NPX_ST);
		p_state->NPX_valid = TRUE;
	}
	p_state->twenty_bit_wrap = (SasWrapMask == 0xFFFFF);
	p_state->synch_index = ccpu_synch_count;
}

/*(
============================ c_setCpuState =====================================
PURPOSE:
	Takes the saved CPU state from the passed state structure and
	uses it to set the current state of the C CPU.
===============================================================================
)*/

GLOBAL void
c_setCpuState IFN1(
	cpustate_t *, p_new_state
)
{
	c_setCPL(0);	/* Allow manipulation of IO flags */

	/*
	 * Setup machine status word, privilege level and instruction
	 * pointer.
	 */
	MOV_CR(0,(IU32)p_new_state->cpu_regs.CR0);
	MOV_CR(2,(IU32)p_new_state->cpu_regs.PFLA);
	MOV_CR(3,(IU32)p_new_state->cpu_regs.PDBR);

	SET_EIP(p_new_state->cpu_regs.EIP);

	/*
	 * Setup general registers
	 */
	SET_EAX(p_new_state->cpu_regs.EAX);
	SET_EBX(p_new_state->cpu_regs.EBX);
	SET_ECX(p_new_state->cpu_regs.ECX);
	SET_EDX(p_new_state->cpu_regs.EDX);
	SET_ESP(p_new_state->cpu_regs.ESP);
	SET_EBP(p_new_state->cpu_regs.EBP);
	SET_ESI(p_new_state->cpu_regs.ESI);
	SET_EDI(p_new_state->cpu_regs.EDI);

	/*
	 * Setup processor status flags.
	 */
	c_setEFLAGS(p_new_state->cpu_regs.EFLAGS);

	SET_CPL(p_new_state->cpu_regs.CPL);

	/*
	 * Setup descriptor table registers.
	 */
	c_setGDT_BASE_LIMIT(p_new_state->cpu_regs.GDT_base, p_new_state->cpu_regs.GDT_limit);

	c_setIDT_BASE_LIMIT(p_new_state->cpu_regs.IDT_base, p_new_state->cpu_regs.IDT_limit);

	SET_LDT_SELECTOR(p_new_state->cpu_regs.LDT_selector);
	c_setLDT_BASE_LIMIT(p_new_state->cpu_regs.LDT_base, p_new_state->cpu_regs.LDT_limit);

	SET_TR_SELECTOR(p_new_state->cpu_regs.TR_selector);
	c_setTR_BASE_LIMIT_AR(p_new_state->cpu_regs.TR_base, p_new_state->cpu_regs.TR_limit, p_new_state->cpu_regs.TR_ar);

	/*
	 * Setup segment register details
	 */
	SET_DS_SELECTOR(p_new_state->cpu_regs.DS_selector);
	c_setDS_BASE_LIMIT_AR(p_new_state->cpu_regs.DS_base, p_new_state->cpu_regs.DS_limit, p_new_state->cpu_regs.DS_ar);

	SET_ES_SELECTOR(p_new_state->cpu_regs.ES_selector);
	c_setES_BASE_LIMIT_AR(p_new_state->cpu_regs.ES_base, p_new_state->cpu_regs.ES_limit, p_new_state->cpu_regs.ES_ar);

	SET_SS_SELECTOR(p_new_state->cpu_regs.SS_selector);
	c_setSS_BASE_LIMIT_AR(p_new_state->cpu_regs.SS_base, p_new_state->cpu_regs.SS_limit, p_new_state->cpu_regs.SS_ar);

	SET_CS_SELECTOR(p_new_state->cpu_regs.CS_selector);
	c_setCS_BASE_LIMIT_AR(p_new_state->cpu_regs.CS_base, p_new_state->cpu_regs.CS_limit, p_new_state->cpu_regs.CS_ar);

	SET_FS_SELECTOR(p_new_state->cpu_regs.FS_selector);
	c_setFS_BASE_LIMIT_AR(p_new_state->cpu_regs.FS_base, p_new_state->cpu_regs.FS_limit, p_new_state->cpu_regs.FS_ar);

	SET_GS_SELECTOR(p_new_state->cpu_regs.GS_selector);
	c_setGS_BASE_LIMIT_AR(p_new_state->cpu_regs.GS_base, p_new_state->cpu_regs.GS_limit, p_new_state->cpu_regs.GS_ar);

	Cpu.Video->SetVideolatches(p_new_state->video_latches);

	/* The NPX registers are not loaded here, since the extraction
	 * from the EDL Cpu is expensive. Instead we note that we have
	 * not loaded them yet, and will obtain them (if needed) when
	 * the first NPX instruction if encountered.
	 * N.B. we need a pointer to this state structure so that we can
	 * update the NPX registers when the CCPU does require them.
	 */
	p_new_state->NPX_valid = FALSE;
	p_current_state = p_new_state;
	if (p_new_state->twenty_bit_wrap)
		SasWrapMask = 0xFFFFF;
	else
		SasWrapMask = -1;
}

#endif /* PIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_mul64.h ===
/* 
   c_mul64.h

   Define all 64-bit Multiplication Functions.
 */

/*
   static char SccsID[]="@(#)c_mul64.h	1.4 02/09/94";
 */

IMPORT VOID mul64
                   
IPT4(
	IS32 *, hr,
	IS32 *, lr,
	IS32, mcand,
	IS32, mpy

   );

IMPORT VOID mulu64
                   
IPT4(
	IU32 *, hr,
	IU32 *, lr,
	IU32, mcand,
	IU32, mpy

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_mem.h ===
/*[

c_mem.h

LOCAL CHAR SccsID[]="@(#)c_mem.h	1.8 02/28/95";

CPU to Memory interface.
------------------------

]*/

/* >>>>>>>>>>>>>>>> NON KOSHER FORM <<<<<<<<<<<<<<<< */

/* Use only for decoding the Intel Opcode Stream. */
/* DIRECT ACCESS to memory! */

IMPORT UTINY ccpu_new_code_page IPT1(UTINY **, q );

IMPORT UTINY *pg_end;	/* point up to which host may safely read
			   instruction stream bytes */

/* To return difference between two points in the inst. stream.
   n = new posn, o = old posn. */

#ifdef	PIG
#include <Cpu_c.h>
#define DIFF_INST_BYTE(n, o) DiffCpuPtrsLS8((o), (n))
#else	/* !PIG */
#ifdef BACK_M
#define DIFF_INST_BYTE(n, o) ((o) - (n))
#else
#define DIFF_INST_BYTE(n, o) ((n) - (o))
#endif /* BACK_M */
#endif	/* PIG */

/* To get next inst. byte and move pointer to next inst. byte. */
#ifdef	PIG
#define GET_INST_BYTE(x) \
   save_instruction_byte( DiffCpuPtrsLS8((x), pg_end) <= 0 ? ccpu_new_code_page(&(x)) : *IncCpuPtrLS8(x) )
#else	/* !PIG */
#ifdef BACK_M
#define GET_INST_BYTE(x) \
   ( (x) <= pg_end ? ccpu_new_code_page(&(x)) : *(x)-- )
#else
#define GET_INST_BYTE(x) \
   ( (x) >= pg_end ? ccpu_new_code_page(&(x)) : *(x)++ )
#endif /* BACK_M */
#endif	/* PIG */


/* >>>>>>>>>>>>>>>> KOSHER FORM <<<<<<<<<<<<<<<< */

#ifdef PIG

IMPORT IU8	phy_read_byte	IPT1(LIN_ADDR, address );
IMPORT IU16	phy_read_word	IPT1(LIN_ADDR, address );
IMPORT IU32	phy_read_dword	IPT1(LIN_ADDR, address );
IMPORT VOID	phy_write_byte	IPT2(LIN_ADDR, address, IU8, data);
IMPORT VOID	phy_write_word	IPT2(LIN_ADDR, address, IU16, data);
IMPORT VOID	phy_write_dword	IPT2(LIN_ADDR, address, IU32, data);

IMPORT VOID cannot_phy_write_byte	IPT2(LIN_ADDR, address, IU8, valid_mask);
IMPORT VOID cannot_phy_write_word	IPT2(LIN_ADDR, address, IU16, valid_mask);
IMPORT VOID cannot_phy_write_dword	IPT2(LIN_ADDR, address, IU32, valid_mask);
#else

#define phy_read_byte(x)	((IU8)(phy_r8((PHY_ADDR)x)))
#define phy_read_word(x)	((IU16)(phy_r16((PHY_ADDR)x)))
#define phy_read_dword(x)	((IU32)(phy_r32((PHY_ADDR)x)))

#define phy_write_byte(x, y)	phy_w8((PHY_ADDR)x, (IU8)y)
#define phy_write_word(x, y)	phy_w16((PHY_ADDR)x, (IU16)y)
#define phy_write_dword(x, y)	phy_w32((PHY_ADDR)x, (IU32)y)

#endif /* PIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_mul64.c ===
/*[

c_mul64.c

LOCAL CHAR SccsID[]="@(#)c_mul64.c	1.5 02/09/94";

64-bit Multiplication Functions.
--------------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <c_mul64.h>
#include <c_neg64.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Do 64bit = 32bit X 32bit Signed Multiply.                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
mul64
       	    	    	    	                         
IFN4(
	IS32 *, hr,	/* Pntr to high 32 bits of result */
	IS32 *, lr,	/* Pntr to low 32 bits of result */
	IS32, mcand,	/* multiplicand */
	IS32, mpy	/* multiplier */
    )


   {
   if ( mcand & BIT31_MASK )
      {
      if ( mpy & BIT31_MASK )
	 {
	 /* Negative Multiplicand :: Negative Multiplier */
	 mcand = -mcand;
	 mpy = -mpy;
	 mulu64((IU32 *)hr, (IU32 *)lr, (IU32)mcand, (IU32)mpy);
	 }
      else
	 {
	 /* Negative Multiplicand :: Positive Multiplier */
	 mcand = -mcand;
	 mulu64((IU32 *)hr, (IU32 *)lr, (IU32)mcand, (IU32)mpy);
	 neg64(hr, lr);
	 }
      }
   else
      {
      if ( mpy & BIT31_MASK )
	 {
	 /* Positive Multiplicand :: Negative Multiplier */
	 mpy = -mpy;
	 mulu64((IU32 *)hr, (IU32 *)lr, (IU32)mcand, (IU32)mpy);
	 neg64(hr, lr);
	 }
      else
	 {
	 /* Positive Multiplicand :: Positive Multiplier */
	 mulu64((IU32 *)hr, (IU32 *)lr, (IU32)mcand, (IU32)mpy);
	 }
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Do 64bit = 32bit X 32bit Unsigned Multiply.                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
mulu64
       	    	    	    	                         
IFN4(
	IU32 *, hr,	/* Pntr to high 32 bits of result */
	IU32 *, lr,	/* Pntr to low 32 bits of result */
	IU32, mcand,	/* multiplicand */
	IU32, mpy	/* multiplier */
    )


   {
   IU32 ha, la, hb, lb;
   IU32 res1, res2, res3, res4;
   IU32 temp;

   /* Our algorithm:-

      a) Split the operands up into two 16 bit parts,
	 
		      3      1 1      
		      1      6 5      0
		     ===================
	    mcand =  |   ha   |   la   |
		     ===================
	    
		     ===================
	    mpy   =  |   hb   |   lb   |
		     ===================
      
      b) Form four partial results,

	    res1 = la * lb
	    res2 = ha * lb
	    res3 = la * hb
	    res4 = ha * hb
      
      c) Shift results to correct posn and sum. The tricky bit is
	 allowing for the carry between bits 31 and 32.
	 
	     6               3 3 
	     3               2 1               0
	    =====================================
	    |        hr       |        lr       |
	    =====================================
			      <------res1------->
		     <------res2------->
		     <------res3------->
	    <------res4------->
    */

   /* a) */

   la = mcand & WORD_MASK;
   ha = mcand >> 16 & WORD_MASK;
   lb = mpy & WORD_MASK;
   hb = mpy >> 16 & WORD_MASK;

   /* b) */

   res1 = la * lb;
   res2 = ha * lb;
   res3 = la * hb;
   res4 = ha * hb;

   /* c) */

   /* Form:-
			<------res1------->
	       <------res2------->
    */
   *hr = res2 >> 16;
   *lr = res1 + (res2 << 16);
   /* determine carry for res1 + res2 */
   if ( (res1 & BIT31_MASK) && (res2 & BIT15_MASK) ||
	( !(*lr & BIT31_MASK) &&
	  ((res1 & BIT31_MASK) | (res2 & BIT15_MASK)) )
      )
      *hr = *hr + 1;

   /* Add in:-
	       <------res3------->
    */
   *hr = *hr + (res3 >> 16);
   temp = *lr + (res3 << 16);
   /* determine carry for ... + res3 */
   if ( (*lr & BIT31_MASK) && (res3 & BIT15_MASK) ||
	( !(temp & BIT31_MASK) &&
	  ((*lr & BIT31_MASK) | (res3 & BIT15_MASK)) )
      )
      *hr = *hr + 1;
   *lr = temp;

   /*  Add in:-
      <------res4------->
    */
   *hr = *hr + res4;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_neg64.h ===
/* 
   c_neg64.h

   Define all 64-bit Negate Functions.
 */

/*
   static char SccsID[]="@(#)c_neg64.h	1.4 02/09/94";
 */

IMPORT VOID neg64
           
IPT2(
	IS32 *, hr,
	IS32 *, lr

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_neg64.c ===
/*[

c_neg64.c

LOCAL CHAR SccsID[]="@(#)c_neg64.c	1.5 02/09/94";

64-bit Negate Functions.
------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <c_neg64.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Do 64bit Negate.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
neg64
       	    	               
IFN2(
	IS32 *, hr,	/* Pntr to high 32 bits of operand */
	IS32 *, lr	/* Pntr to low 32 bits of operand */
    )


   {
   *hr = ~(*hr);	/* 1's complement */
   *lr = ~(*lr);

			/*    +1 ==> 2's complement */
   /*
      The only tricky case is when the addition causes a carry from
      the low to high 32-bits, but this only happens when all low
      bits are set.
    */
   if ( *lr == 0xffffffff )
      {
      *lr = 0;
      *hr = *hr + 1;
      }
   else
      {
      *lr = *lr + 1;
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_page.c ===
/*[

c_page.c

LOCAL CHAR SccsID[]="@(#)c_page.c	1.10 02/28/95";

Paging Support.
---------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>		/* SoftPC types */
#include <c_main.h>	/* C CPU definitions-interfaces */
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <c_page.h>	/* our interface */
#include <c_mem.h>	/* CPU - Physical Memory interface */
#include <c_tlb.h>	/* Translation Lookaside Buffer interface */
#include <ccpusas4.h>	/* CPU <-> sas interface */
#include <c_debug.h>	/* Debugging Regs and Breakpoint interface */


/*[

   Various levels of interface are provided to the paging system (to
   allow fairly optimal emulation) these levels are:-

      spr_chk_	Checks Supervisor Access to given data item, caller
		aware that #PF may occur. 'A/D' bits will be set. No
		other action is taken.

      usr_chk_	Checks User Access to given data item, caller aware
		that #PF may occur. 'A/D' bits will be set. No other
		action is taken.

      spr_	Perform Supervisor Access, caller aware that #PF may
		occur. Action (Read/Write) is performed immediately.
		Will update A/D bits.
      
      vir_	Perform Virtual Memory Operation (Read/Write). No checks
		are made and no fault will be generated, only call after
		a spr_chk or usr_chk function.

	        NB. At present no super optimal vir_ implementation
		    exists. If a spr_chk or usr_chk function is not
		    called before a vir_ function, then the vir_
		    function may cause #PF, this condition will become
		    a fatal error in an optimised implementation.
		    For the moment we assume that after a 'chk' call it
		    is virtually 100% certain that the 'vir' call will
		    get a cache hit.

]*/

#define LAST_DWORD_ON_PAGE 0xffc
#define LAST_WORD_ON_PAGE  0xffe

#define OFFSET_MASK 0xfff

#ifdef	PIG
LOCAL VOID cannot_spr_write_byte IPT2( LIN_ADDR, lin_addr, IU8, valid_mask);
LOCAL VOID cannot_spr_write_word IPT2( LIN_ADDR, lin_addr, IU16, valid_mask);
LOCAL VOID cannot_spr_write_dword IPT2( LIN_ADDR, lin_addr, IU32, valid_mask);
#endif	/* PIG */

/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check Supervisor Byte access.                                      */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL PHY_ADDR
spr_chk_byte
       	    		               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	ISM32, access	/* Read(PG_R) or Write(PG_W) */
    )


   {
   if ( GET_PG() == 1 )
      {
      access |= PG_S;
      lin_addr = lin2phy(lin_addr, access);
      }

   return lin_addr;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check Supervisor Double Word access.                               */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spr_chk_dword
       	    		               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	ISM32, access	/* Read(PG_R) or Write(PG_W) */
    )


   {
   if ( GET_PG() == 1 )
      {
      access |= PG_S;
      (VOID)lin2phy(lin_addr, access);
      if ( (lin_addr & OFFSET_MASK) > LAST_DWORD_ON_PAGE )
	 (VOID)lin2phy(lin_addr + 3, access);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check Supervisor Word access.                                      */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spr_chk_word
       	    		               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	ISM32, access	/* Read(PG_R) or Write(PG_W) */
    )


   {
   if ( GET_PG() == 1 )
      {
      access |= PG_S;
      (VOID)lin2phy(lin_addr, access);
      if ( (lin_addr & OFFSET_MASK) > LAST_WORD_ON_PAGE )
	 (VOID)lin2phy(lin_addr + 1, access);
      }
   }


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check User Byte access.                                            */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
usr_chk_byte
       	    		               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	ISM32, access	/* Read(PG_R) or Write(PG_W) */
    )


   {
   PHY_ADDR phy_addr;

   phy_addr = lin_addr;

   if ( GET_PG() == 1 )
      {
      if ( GET_CPL() == 3 )
	 access |= PG_U;
      else
	 access |= PG_S;

      phy_addr = lin2phy(lin_addr, access);
      }

   return phy_addr;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check User Double Word access.                                     */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
usr_chk_dword
       	    		               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	ISM32, access	/* Read(PG_R) or Write(PG_W) */
    )


   {
   PHY_ADDR phy_addr;

   phy_addr = lin_addr;

   if ( GET_PG() == 1 )
      {
      if ( GET_CPL() == 3 )
	 access |= PG_U;
      else
	 access |= PG_S;

      phy_addr = lin2phy(lin_addr, access);

      if ( (lin_addr & OFFSET_MASK) > LAST_DWORD_ON_PAGE )
	 {
	 (VOID)lin2phy(lin_addr + 3, access);
	 phy_addr = NO_PHYSICAL_MAPPING;
	 }
      }

   return phy_addr;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check User Word access.                                            */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
usr_chk_word
       	    		               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	ISM32, access	/* Read(PG_R) or Write(PG_W) */
    )


   {
   PHY_ADDR phy_addr;

   phy_addr = lin_addr;

   if ( GET_PG() == 1 )
      {
      if ( GET_CPL() == 3 )
	 access |= PG_U;
      else
	 access |= PG_S;

      phy_addr = lin2phy(lin_addr, access);
      if ( (lin_addr & OFFSET_MASK) > LAST_WORD_ON_PAGE )
	 {
	 (VOID)lin2phy(lin_addr + 1, access);
	 phy_addr = NO_PHYSICAL_MAPPING;
	 }
      }

   return phy_addr;
   }


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Read a Byte from memory.                                */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU8
spr_read_byte
       	          
IFN1(
	LIN_ADDR, lin_addr	/* Linear Address */
    )


   {
   if ( GET_PG() == 1 )
      {
      lin_addr = lin2phy(lin_addr, PG_R | PG_S);
      }

   return phy_read_byte(lin_addr);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Read a Double Word from memory.                         */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
spr_read_dword
       	          
IFN1(
	LIN_ADDR, lin_addr	/* Linear Address */
    )


   {
   IU16 low_word;
   IU16 high_word;

   if ( GET_PG() == 1 )
      {
      if ( (lin_addr & OFFSET_MASK) > LAST_DWORD_ON_PAGE )
	 {
	 /* Spans two pages */
	 low_word  = spr_read_word(lin_addr);
	 high_word = spr_read_word(lin_addr + 2);
	 return (IU32)high_word << 16 | low_word;
	 }
      else
	 {
	 lin_addr = lin2phy(lin_addr, PG_R | PG_S);
	 }
      }

   return phy_read_dword(lin_addr);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Read a Word from memory.                                */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU16
spr_read_word
       	          
IFN1(
	LIN_ADDR, lin_addr	/* Linear Address */
    )


   {
   IU8 low_byte;
   IU8 high_byte;

   if ( GET_PG() == 1 )
      {
      if ( (lin_addr & OFFSET_MASK) > LAST_WORD_ON_PAGE )
	 {
	 /* Spans two pages */
	 low_byte  = spr_read_byte(lin_addr);
	 high_byte = spr_read_byte(lin_addr + 1);
	 return (IU16)high_byte << 8 | low_byte;
	 }
      else
	 {
	 lin_addr = lin2phy(lin_addr, PG_R | PG_S);
	 }
      }

   return phy_read_word(lin_addr);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Write a Byte to memory.                                 */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spr_write_byte
       	                   
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	IU8, data
    )


   {
   if ( GET_PG() == 1 )
      {
      lin_addr = lin2phy(lin_addr, PG_W | PG_S);
      }

   phy_write_byte(lin_addr, data);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Write a Double Word to memory.                          */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spr_write_dword
       	                   
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	IU32, data
    )


   {
   if ( GET_PG() == 1 )
      {
      if ( (lin_addr & OFFSET_MASK) > LAST_DWORD_ON_PAGE )
	 {
	 /* Spans two pages */
	 spr_write_word(lin_addr, (IU16)data);
	 spr_write_word(lin_addr + 2, (IU16)(data >> 16));
         return;
	 }
      else
	 {
	 lin_addr = lin2phy(lin_addr, PG_W | PG_S);
	 }
      }

   phy_write_dword(lin_addr, data);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Write a Word to memory.                                 */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spr_write_word
       	                   
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	IU16, data
    )


   {
   if ( GET_PG() == 1 )
      {
      if ( (lin_addr & OFFSET_MASK) > LAST_WORD_ON_PAGE )
	 {
	 /* Spans two pages */
	 spr_write_byte(lin_addr, (IU8)data);
	 spr_write_byte(lin_addr + 1, (IU8)(data >> 8));
	 return;
	 }
      else
	 {
	 lin_addr = lin2phy(lin_addr, PG_W | PG_S);
	 }
      }

   phy_write_word(lin_addr, data);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Read Bytes from memory.                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL void
vir_read_bytes
       	    	               
IFN4(
	IU8 *, destbuff,	/* Where the data goes */
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr,	/* Physical Address, if non zero */
	IU32, num_bytes
    )
   {
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_R, D_BYTE);
      }
   if ( phy_addr ) {
       phy_addr += (num_bytes-1);
       while (num_bytes--) {
		*destbuff++ = phy_read_byte(phy_addr);
		phy_addr--;
       }
   } else {
	lin_addr += (num_bytes-1);
	while (num_bytes--) {
      		*destbuff++ = spr_read_byte(lin_addr);
		lin_addr--;
   	}
   }
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Read a Byte from memory.                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU8
vir_read_byte
       	    	               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr	/* Physical Address, if non zero */
    )


   {
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_R, D_BYTE);
      }

   if ( phy_addr )
      {
      return phy_read_byte(phy_addr);
      }
   else
      {
      return spr_read_byte(lin_addr);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Read a Double Word from memory.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
vir_read_dword
       	    	               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr	/* Physical Address, if non zero */
    )


   {
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_R, D_DWORD);
      }

   if ( phy_addr )
      {
      return phy_read_dword(phy_addr);
      }
   else
      {
      return spr_read_dword(lin_addr);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Read a Word from memory.                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU16
vir_read_word
       	    	               
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr	/* Physical Address, if non zero */
    )


   {
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_R, D_WORD);
      }

   if ( phy_addr )
      {
      return phy_read_word(phy_addr);
      }
   else
      {
      return spr_read_word(lin_addr);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Write Bytes to memory.                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
vir_write_bytes
       	    	                        
IFN4(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr,	/* Physical Address, if non zero */
	IU8 *, data,		/* Pointer to data to be written */
	IU32, num_bytes		/* Number of bytes to act on */
    )
   {
   IU8 data_byte;

   check_D(lin_addr, num_bytes);
   if ( nr_data_break ) {
      check_for_data_exception(lin_addr, D_W, D_BYTE);
   }
   if ( phy_addr ) {
	phy_addr += (num_bytes - 1);
	while (num_bytes--) {
		data_byte = *data++;
      		phy_write_byte(phy_addr, data_byte);
		phy_addr--;
	}
   } else {
	lin_addr += (num_bytes - 1);
	while (num_bytes--) {
		data_byte = *data++;
		spr_write_byte(lin_addr, data_byte);
		lin_addr--;
      }
   }
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Write a Byte to memory.                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
vir_write_byte
       	    	                        
IFN3(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr,	/* Physical Address, if non zero */
	IU8, data
    )


   {
   check_D(lin_addr, 1);
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_W, D_BYTE);
      }

   if ( phy_addr )
      {
      phy_write_byte(phy_addr, data);
      }
   else
      {
      spr_write_byte(lin_addr, data);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Write a Double Word to memory.                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
vir_write_dword
       	    	                        
IFN3(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr,	/* Physical Address, if non zero */
	IU32, data
    )


   {
   check_D(lin_addr, 4);
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_W, D_DWORD);
      }

   if ( phy_addr )
      {
      phy_write_dword(phy_addr, data);
      }
   else
      {
      spr_write_dword(lin_addr, data);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Write a Word to memory.                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
vir_write_word
       	    	                        
IFN3(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr,	/* Physical Address, if non zero */
	IU16, data
    )


   {
   check_D(lin_addr, 2);
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_W, D_WORD);
      }

   if ( phy_addr )
      {
      phy_write_word(phy_addr, data);
      }
   else
      {
      spr_write_word(lin_addr, data);
      }
   }



#ifdef PIG
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Write a Byte to memory                                  */
/* But when Pigging INSD we have no data to write. Just flag address. */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
cannot_spr_write_byte
       	                   
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	IU8, valid_mask
    )


   {
   if ( GET_PG() == 1 )
      {
      lin_addr = lin2phy(lin_addr, PG_W | PG_S);
      }

   cannot_phy_write_byte(lin_addr, valid_mask);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Write a Double Word to memory                           */
/* But when Pigging INSD we have no data to write. Just flag address. */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
cannot_spr_write_dword
       	                   
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	IU32, valid_mask
    )


   {
   if ( GET_PG() == 1 )
      {
      if ( (lin_addr & OFFSET_MASK) > LAST_DWORD_ON_PAGE )
	 {
	 /* Spans two pages */
	 cannot_spr_write_word(lin_addr, valid_mask & 0xffff);
	 cannot_spr_write_word(lin_addr + 2, valid_mask >> 16);
         return;
	 }
      else
	 {
	 lin_addr = lin2phy(lin_addr, PG_W | PG_S);
	 }
      }

   cannot_phy_write_dword(lin_addr, valid_mask);
   }
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Supervisor Write a Word to memory.                                 */
/* But when Pigging INSW we have no data to write. Just flag address. */
/* May cause #PF.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
cannot_spr_write_word
       	                   
IFN2(
	LIN_ADDR, lin_addr,	/* Linear Address */
	IU16, valid_mask
    )


   {
   if ( GET_PG() == 1 )
      {
      if ( (lin_addr & OFFSET_MASK) > LAST_WORD_ON_PAGE )
	 {
	 /* Spans two pages */
	 cannot_spr_write_byte(lin_addr, valid_mask & 0xff);
	 cannot_spr_write_byte(lin_addr + 1, valid_mask >> 8);
	 return;
	 }
      else
	 {
	 lin_addr = lin2phy(lin_addr, PG_W | PG_S);
	 }
      }

   cannot_phy_write_word(lin_addr, valid_mask);
   }


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Write a Byte to memory.                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
cannot_vir_write_byte
       	    	                        
IFN3(
	LIN_ADDR, lin_addr,	/* Linear Address */
	LIN_ADDR, phy_addr,	/* Physical Address, if non zero */
	IU8, valid_mask
    )


   {
   check_D(lin_addr, 1);
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_W, D_BYTE);
      }

   if ( phy_addr )
      {
      cannot_phy_write_byte(phy_addr, valid_mask);
      }
   else
      {
      cannot_spr_write_byte(lin_addr, valid_mask);
      }
   }
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Write a Double Word to memory.                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
cannot_vir_write_dword
       	    	                        
IFN3(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr,	/* Physical Address, if non zero */
	IU32, valid_mask
    )


   {
   check_D(lin_addr, 4);
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_W, D_DWORD);
      }

   if ( phy_addr )
      {
      cannot_phy_write_dword(phy_addr, valid_mask);
      }
   else
      {
      cannot_spr_write_dword(lin_addr, valid_mask);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Virtual Write a Word to memory.                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
cannot_vir_write_word
       	    	                        
IFN3(
	LIN_ADDR, lin_addr,	/* Linear Address */
	PHY_ADDR, phy_addr,	/* Physical Address, if non zero */
	IU16, valid_mask
    )


   {
   check_D(lin_addr, 2);
   if ( nr_data_break )
      {
      check_for_data_exception(lin_addr, D_W, D_WORD);
      }

   if ( phy_addr )
      {
      cannot_phy_write_word(phy_addr, valid_mask);
      }
   else
      {
      cannot_spr_write_word(lin_addr, valid_mask);
      }
   }
#endif	/* PIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_page.h ===
/*[

c_page.h

Paging Support.
---------------

LOCAL CHAR SccsID[]="@(#)c_page.h	1.7 02/28/95";

]*/


/*
   Page Access Types.
 */
#define PG_R 0x0 /* Read */
#define PG_W 0x1 /* Write */

/*
   Supervisor Memory Access Check Functions.

   Will Check Access as per Supervisor (taking #PF if reqd.), 'A/D' bits
   will be set in the Page Entries, no other action occurs.
   Normally these routines will be followed by vir_.. calls.
 */
IMPORT IU32 spr_chk_byte
           
IPT2(
	IU32, lin_addr,
	ISM32, access_type

   );

IMPORT VOID spr_chk_dword
           
IPT2(
	IU32, lin_addr,
	ISM32, access_type

   );

IMPORT VOID spr_chk_word
           
IPT2(
	IU32, lin_addr,
	ISM32, access_type

   );


/*
   User Memory Access Check Functions.

   Will Check Access as per User (taking #PF if reqd.), 'A/D' bits will
   be set in the Page Entries, no other action occurs.
   Normally these routines will be followed by vir_.. calls.
 */
IMPORT IU32 usr_chk_byte
           
IPT2(
	IU32, lin_addr,
	ISM32, access_type

   );

IMPORT IU32 usr_chk_dword
           
IPT2(
	IU32, lin_addr,
	ISM32, access_type

   );

IMPORT IU32 usr_chk_word
           
IPT2(
	IU32, lin_addr,
	ISM32, access_type

   );


/*
   Supervisor Memory Access Functions.

   Will Check Access as per Supervisor (taking #PF if reqd.), 'A/D'
   bits will be set in the Page Entries, Map Address and Perform
   Read or Write.
 */
IMPORT IU8 spr_read_byte
       
IPT1(
	IU32, lin_addr

   );

IMPORT IU32 spr_read_dword
       
IPT1(
	IU32, lin_addr

   );

IMPORT IU16 spr_read_word
       
IPT1(
	IU32, lin_addr

   );

IMPORT VOID spr_write_byte
           
IPT2(
	IU32, lin_addr,
	IU8, data

   );

IMPORT VOID spr_write_dword
           
IPT2(
	IU32, lin_addr,
	IU32, data

   );

IMPORT VOID spr_write_word
           
IPT2(
	IU32, lin_addr,
	IU16, data

   );


/*
   Virtual Memory Access Functions.

   No Checks are made (assumed already done), just Perform Read or
   Write.
   This is also the point at which data breakpoints are checked.
 */

#define NO_PHYSICAL_MAPPING 0   /* Indicates no physical address is
				   available, the linear address will be
				   re-mapped. */

IMPORT IU8 vir_read_byte
           
IPT2(
	IU32, lin_addr,
	IU32, phy_addr

   );

IMPORT IU32 vir_read_dword
           
IPT2(
	IU32, lin_addr,
	IU32, phy_addr

   );

IMPORT IU16 vir_read_word
           
IPT2(
	IU32, lin_addr,
	IU32, phy_addr

   );

IMPORT VOID vir_write_byte
               
IPT3(
	IU32, lin_addr,
	IU32, phy_addr,
	IU8, data

   );

IMPORT VOID vir_write_dword
               
IPT3(
	IU32, lin_addr,
	IU32, phy_addr,
	IU32, data

   );

IMPORT VOID vir_write_word
               
IPT3(
	IU32, lin_addr,
	IU32, phy_addr,
	IU16, data

   );

#ifdef	PIG
IMPORT VOID cannot_vir_write_byte
               
IPT3(
	IU32, lin_addr,
	IU32, phy_addr,
	IU8, valid_mask
   );

IMPORT VOID cannot_vir_write_dword
               
IPT3(
	IU32, lin_addr,
	IU32, phy_addr,
	IU32, valid_mask
   );

IMPORT VOID cannot_vir_write_word
               
IPT3(
	IU32, lin_addr,
	IU32, phy_addr,
	IU16, valid_mask
   );
#endif	/* PIG */

extern void vir_write_bytes IPT4(LIN_ADDR, lin_addr,PHY_ADDR, phy_addr, IU8 *, data, IU32, num_bytes);
extern void vir_read_bytes IPT4(IU8 *, destbuff, LIN_ADDR, lin_addr, PHY_ADDR, phy_addr, IU32, num_bytes);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_oprnd.h ===
/*[

c_oprnd.h

LOCAL CHAR SccsID[]="@(#)c_oprnd.h	1.12 03/07/95";

Operand Decoding Functions (Macros).
------------------------------------

]*/


/*[

   There exists 51 different Intel argument types, for each type a
   Decode (D_), Fetch (F_), Commit (C_) and Put (P_) 'function' may
   be written. (In fact 'null' functions aren't actually defined.)

   The Decode (D_) 'function' decodes and validates the argument and
   stores information in an easy to handle form (host variables). For
   example memory addressing is resolved to a segment identifier and
   offset, access to the memory location is checked at this point.

   The Fetch (F_) 'function' uses the easy to handle host variables to
   actually retrieve the operand.

   The Commit (C_) 'function' handles any post instruction operand
   functions. At present only string operands actually use this function
   to update SI, DI and CX. This update can only be 'committed' after we
   are sure no exception can be generated, which is why the Fetch macro
   can not handle this update.

   The Put (P_) 'function' stores the operand, it may reference the easy
   to handle host variables when deciding where the operand is stored.

   These 'functions' are invoked as follows for the 3 operand cases:-

	    -------------------------------
	    |  src    |  dst    | dst/src |
	    |  r-     |  -w     | rw      |
	    |-----------------------------|
	    |  D_     |  D_     |  D_     |
	    |  F_     |         |  F_     |
	    |  <<Instruction Processing>> |
	    |  C_     |  C_     |  C_     |
	    |         |  P_     |  P_     |
	    -------------------------------

   ie: Decode and Commit (if they exist) are called for all arguments;
   Fetch (if it exists) is only called for source arguments; Put is only
   called for destination arguments.

   Operand type naming conventions are broadly based on "Appendix A -
   Opcode Map in 80386 Programmer's Reference Manual" A brief one line
   description of each type is given below before the actual 'function'
   definitions.

   The 51 types are composed of those available on the 286,386 and 486:-

	 Aw     Eb     Ew     Fal    Fax    Fcl
	 Fdx    Gb     Gw     Hb     Hw     I0
	 I1     I3     Ib     Iw     Ix     Jb
	 Jw     M      Ma16   Mp16   Ms     Nw
	 Ob     Ow     Pw     Xb     Xw     Yb
	 Yw     Z
   
   those available on the 386 and 486:-

	 Ad     Cd     Dd     Ed     Feax   Gd
	 Hd     Id     Iy     Jd     Ma32   Mp32
	 Od     Qw     Rd     Td     Xd     Yd
   
   and those available on the 486:-

	 Mm

   The following table indicates which functions actually exist. A
   dot(.) indicates a 'null' or undefined function.

	 ===================================================
	      D F C P|     D F C P|     D F C P|     D F C P
	 ------------|------------|------------|------------
	 Aw   D . . .|Ib   D . . .|Xw   D F C .|Ma32 D F . .
	 Eb   D F . P|Iw   D . . .|Yb   D F C P|Mm   D F . .
	 Ew   D F . P|Ix   D . . .|Yw   D F C P|Mp32 D F . .
	 Fal  . F . P|Jb   D . . .|Z    D F . .|Od   D F . P
	 Fax  . F . P|Jw   D . . .|Ad   D . . .|Qw   D F . .
	 Fcl  . F . P|M    D F . .|Cd   D F . .|Rd   D F . P
	 Fdx  . F . P|Ma16 D F . .|Dd   D F . .|Td   D F . .
	 Gb   D F . P|Mp16 D F . .|Ed   D F . P|Xd   D F C .
	 Gw   D F . P|Ms   D F . P|Feax . F . P|Yd   D F C P
	 Hb   D F . P|Nw   D F . P|Gd   D F . P|
	 Hw   D F . P|Ob   D F . P|Hd   D F . P|
	 I0   . F . .|Ow   D F . P|Id   D . . .|
	 I1   . F . .|Pw   D F . P|Iy   D . . .|
	 I3   . F . .|Xb   D F C .|Jd   D . . .|
	 ===================================================

   Each Intel combination of source and destination is categorised by
   a numeric instruction type as follows:-

	 --------------------------------------------------
	 | Id | Intel assembler      | arg1 | arg2 | arg3 |
	 |----|----------------------|------|------|------|
	 | 0  | INST                 |  --  |  --  |  --  |
	 | 1  | INST dst/src         |  rw  |  --  |  --  |
	 | 2  | INST src             |  r-  |  --  |  --  |
	 | 3  | INST dst             |  -w  |  --  |  --  |
	 | 4  | INST dst,src         |  -w  |  r-  |  --  |
	 | 5  | INST dst/src,src     |  rw  |  r-  |  --  |
	 | 6  | INST src,src         |  r-  |  r-  |  --  |
	 | 7  | INST dst,src,src     |  -w  |  r-  |  r-  |
	 | 8  | INST dst/src,dst/src |  rw  |  rw  |  --  |
	 | 9  | INST dst/src,src,src |  rw  |  r-  |  r-  |
	 --------------------------------------------------
   
   Each instruction type defines the calling sequences for the
   pre-instruction (Leading) 'functions' (D_, F_) and the post-
   instruction (Trailing) 'functions' (C_, P_).


   BUT (Mike says)
   ---

This is all OK, until we get to the BT (bit test) familly of instructions,
where unfortunately the manual is a little economic with the truth.  If the
bit offset parameter is specified by a register, part of the value in
the register will actually be used as a (d)word offset if the other operand
is in memory.

This means that the bit offset operand must be fetched before the other
operand can be decoded.  Yuck.

So for these instructions we're not going to use separate fetch and decode
stages.  Maybe there's a better way of doing this, but I don't know it.
(Note that this doesn't apply to the BTx instructions with an immediate
operand)
]*/


/* Segment access checking functions <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/*    RO = Read Only                                                  */
/*    WO = Write Only                                                 */
/*    RW = Read and Write                                             */

#define RO0							\
   if ( !GET_SR_AR_R(m_seg[0]) )					\
      GP((USHORT)0, FAULT_OP0_SEG_NOT_READABLE);

#define WO0							\
   if ( !GET_SR_AR_W(m_seg[0]) )					\
      GP((USHORT)0, FAULT_OP0_SEG_NOT_WRITABLE);

#define RW0							\
   if ( !GET_SR_AR_R(m_seg[0]) || !GET_SR_AR_W(m_seg[0]) )	\
      GP((USHORT)0, FAULT_OP0_SEG_NO_READ_OR_WRITE);

#define RO1							\
   if ( !GET_SR_AR_R(m_seg[1]) )					\
      GP((USHORT)0, FAULT_OP1_SEG_NOT_READABLE);

#define WO1							\
   if ( !GET_SR_AR_W(m_seg[1]) )					\
      GP((USHORT)0, FAULT_OP1_SEG_NOT_WRITABLE);

#define RW1							\
   if ( !GET_SR_AR_R(m_seg[1]) || !GET_SR_AR_W(m_seg[1]) )	\
      GP((USHORT)0, FAULT_OP1_SEG_NO_READ_OR_WRITE);

/* String Count access function <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define STRING_COUNT						\
   if ( repeat == REP_CLR )					\
      {								\
      rep_count = 1;						\
      }								\
   else								\
      {								\
      if ( GET_ADDRESS_SIZE() == USE16 )				\
	 rep_count = GET_CX();					\
      else   /* USE32 */					\
	 rep_count = GET_ECX();					\
      }


/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/* 286,386 and 486                                                    */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */



/* Aw == direct address <off16><seg> in instruction stream <<<<<<<<<< */

#define D_Aw(ARG)						\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   ops[ARG].mlt[0] = immed;					\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   ops[ARG].mlt[1] = immed;

#define D_E08(ARG, TYPE, PAGE)					\
      m_isreg[ARG] = FALSE;					\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)8);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);

#define F_E08(ARG)						\
      vir_read_bytes(&ops[ARG].npxbuff[0], m_la[ARG], m_pa[ARG], 0x08);

#define P_E08(ARG)						\
	vir_write_bytes(m_la[ARG], m_pa[ARG], &ops[ARG].npxbuff[0], 0x08);

#define D_E0a(ARG, TYPE, PAGE)					\
      m_isreg[ARG] = FALSE;					\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)10);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);

#define F_E0a(ARG)						\
      vir_read_bytes(&ops[ARG].npxbuff[0], m_la[ARG], m_pa[ARG], 0x0a);

#define P_E0a(ARG)						\
	vir_write_bytes(m_la[ARG], m_pa[ARG], &ops[ARG].npxbuff[0], 0x0a);

#define D_E0e(ARG, TYPE, PAGE)					\
      m_isreg[ARG] = FALSE;					\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      if (NPX_ADDRESS_SIZE_32) {                                \
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)28);	\
      } else {							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)14);	\
      }								\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);

#define F_E0e(ARG)						\
      if (NPX_ADDRESS_SIZE_32) {				\
	vir_read_bytes(&ops[ARG].npxbuff[0], m_la[ARG], m_pa[ARG], 0x1c);	\
      } else {	\
	vir_read_bytes(&ops[ARG].npxbuff[0], m_la[ARG], m_pa[ARG], 0x0e);	\
      }

#define P_E0e(ARG)						\
      if (NPX_ADDRESS_SIZE_32) {                                \
	vir_write_bytes(m_la[ARG], m_pa[ARG], &ops[ARG].npxbuff[0], 0x1c);	\
      } else {	\
	vir_write_bytes(m_la[ARG], m_pa[ARG], &ops[ARG].npxbuff[0], 0x0e);	\
      }

#define D_E5e(ARG, TYPE, PAGE)					\
      m_isreg[ARG] = FALSE;					\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      if (NPX_ADDRESS_SIZE_32) {                                \
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)94);	\
      } else {							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)106);	\
      }								\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);

#define F_E5e(ARG)						\
      if (NPX_ADDRESS_SIZE_32) {				\
	vir_read_bytes(&ops[ARG].npxbuff[0], m_la[ARG], m_pa[ARG], 0x6c);	\
      } else {	\
	vir_read_bytes(&ops[ARG].npxbuff[0], m_la[ARG], m_pa[ARG], 0x5e);	\
      }

#define P_E5e(ARG)						\
      if (NPX_ADDRESS_SIZE_32) {                                \
	vir_write_bytes(m_la[ARG], m_pa[ARG], &ops[ARG].npxbuff[0], 0x6c);	\
      } else {	\
	vir_write_bytes(m_la[ARG], m_pa[ARG], &ops[ARG].npxbuff[0], 0x5e);	\
      }


/* Eb == 'mode'+'r/m' fields refer to byte register/memory <<<<<<<<<< */

#define D_Eb(ARG, TYPE, PAGE)					\
   if ( GET_MODE(modRM) == 3 )					\
      {								\
      save_id[ARG] = GET_R_M(modRM);				\
      m_isreg[ARG] = TRUE;					\
      }								\
   else								\
      {								\
      m_isreg[ARG] = FALSE;					\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)1);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_byte(m_la[ARG], PAGE);		\
      }

#define F_Eb(ARG)						\
   if ( m_isreg[ARG] )						\
      ops[ARG].sng = GET_BR(save_id[ARG]);			\
   else								\
      ops[ARG].sng = vir_read_byte(m_la[ARG], m_pa[ARG]);

#define P_Eb(ARG)						\
   if ( m_isreg[ARG] )						\
      SET_BR(save_id[ARG], ops[ARG].sng);			\
   else								\
      vir_write_byte(m_la[ARG], m_pa[ARG], (UTINY)ops[ARG].sng);

/* Ew == 'mode'+'r/m' fields refer to word register/memory <<<<<<<<<< */

#define D_Ew(ARG, TYPE, PAGE)					\
   if ( GET_MODE(modRM) == 3 )					\
      {								\
      save_id[ARG] = GET_R_M(modRM);				\
      m_isreg[ARG] = TRUE;					\
      }								\
   else								\
      {								\
      m_isreg[ARG] = FALSE;					\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)2);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);		\
      }

#define F_Ew(ARG)						\
   if ( m_isreg[ARG] )						\
      ops[ARG].sng = GET_WR(save_id[ARG]);			\
   else								\
      ops[ARG].sng = vir_read_word(m_la[ARG], m_pa[ARG]);

#define P_Ew(ARG)						\
   if ( m_isreg[ARG] )						\
      SET_WR(save_id[ARG], ops[ARG].sng);			\
   else								\
      vir_write_word(m_la[ARG], m_pa[ARG], (USHORT)ops[ARG].sng);

/* Fal == fixed register, AL <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define F_Fal(ARG) ops[ARG].sng = GET_BR(A_AL);

#define P_Fal(ARG) SET_BR(A_AL, ops[ARG].sng);

/* Fax == fixed register, AX <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define F_Fax(ARG) ops[ARG].sng = GET_WR(A_AX);

#define P_Fax(ARG) SET_WR(A_AX, ops[ARG].sng);

/* Fcl == fixed register, CL <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define F_Fcl(ARG) ops[ARG].sng = GET_BR(A_CL);

#define P_Fcl(ARG) SET_BR(A_CL, ops[ARG].sng);

/* Fdx == fixed register, DX <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define F_Fdx(ARG) ops[ARG].sng = GET_WR(A_DX);

#define P_Fdx(ARG) SET_WR(A_DX, ops[ARG].sng);

/* Gb == 'reg' field of modR/M byte denotes byte reg <<<<<<<<<<<<<<<< */

#define D_Gb(ARG) save_id[ARG] = GET_REG(modRM);

#define F_Gb(ARG) ops[ARG].sng = GET_BR(save_id[ARG]);

#define P_Gb(ARG) SET_BR(save_id[ARG], ops[ARG].sng);

/* Gw == 'reg' field of modR/M byte denotes word reg <<<<<<<<<<<<<<<< */

#define D_Gw(ARG) save_id[ARG] = GET_REG(modRM);

#define F_Gw(ARG) ops[ARG].sng = GET_WR(save_id[ARG]);

#define P_Gw(ARG) SET_WR(save_id[ARG], ops[ARG].sng);

/* Hb == low 3 bits of opcode denote byte register <<<<<<<<<<<<<<<<<< */

#define D_Hb(ARG) save_id[ARG] = GET_LOW3(opcode);

#define F_Hb(ARG) ops[ARG].sng = GET_BR(save_id[ARG]);

#define P_Hb(ARG) SET_BR(save_id[ARG], ops[ARG].sng);

/* Hw == low 3 bits of opcode denote word register <<<<<<<<<<<<<<<<<< */

#define D_Hw(ARG) save_id[ARG] = GET_LOW3(opcode);

#define F_Hw(ARG) ops[ARG].sng = GET_WR(save_id[ARG]);

#define P_Hw(ARG) SET_WR(save_id[ARG], ops[ARG].sng);

/* I0 == immediate(0) implied within instruction <<<<<<<<<<<<<<<<<<<< */

#define F_I0(ARG) ops[ARG].sng = 0;

/* I1 == immediate(1) implied within instruction <<<<<<<<<<<<<<<<<<<< */

#define F_I1(ARG) ops[ARG].sng = 1;

/* I3 == immediate(3) implied within instruction <<<<<<<<<<<<<<<<<<<< */

#define F_I3(ARG) ops[ARG].sng = 3;

/* Ib == immediate byte <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Ib(ARG) ops[ARG].sng = GET_INST_BYTE(p);

/* Iw == immediate word <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Iw(ARG)						\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   ops[ARG].sng = immed;

/* Ix == immediate byte sign extended to word <<<<<<<<<<<<<<<<<<<<<<< */

#define D_Ix(ARG)						\
   immed = GET_INST_BYTE(p);					\
   if ( immed & 0x80 )						\
      immed |= 0xff00;						\
   ops[ARG].sng = immed;

/* Jb == relative offset byte sign extended to double word <<<<<<<<<< */

#define D_Jb(ARG)						\
   immed = GET_INST_BYTE(p);					\
   if ( immed & 0x80 )						\
      immed |= 0xffffff00;					\
   ops[ARG].sng = immed;

/* Jw == relative offset word sign extended to double word <<<<<<<<<< */

#define D_Jw(ARG)						\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   if ( immed & 0x8000 )					\
      immed |= 0xffff0000;					\
   ops[ARG].sng = immed;

/* M == address (ie offset) of memory operand <<<<<<<<<<<<<<<<<<<<<<< */

#define D_M(ARG)						\
   if ( GET_MODE(modRM) == 3 )					\
      Int6(); /* Register operand not allowed */		\
   else								\
      {								\
      d_mem(modRM, &p, segment_override, &m_seg[ARG],		\
					 &m_off[ARG]);		\
      }

#define F_M(ARG) ops[ARG].sng = m_off[ARG];

/* Ma16 == word operand pair, as used by BOUND <<<<<<<<<<<<<<<<<<<<< */

#define D_Ma16(ARG, TYPE, PAGE)					\
   if ( GET_MODE(modRM) == 3 )					\
      {								\
      Int6(); /* Register operand not allowed */		\
      }								\
   else								\
      {								\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)2, (INT)2);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);		\
      m_off[ARG] = address_add(m_off[ARG], (LONG)2);		\
      m_la2[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa2[ARG] = usr_chk_word(m_la2[ARG], PAGE);		\
      }

#define F_Ma16(ARG)						\
   ops[ARG].mlt[0] = vir_read_word(m_la[ARG], m_pa[ARG]);	\
   ops[ARG].mlt[1] = vir_read_word(m_la2[ARG], m_pa2[ARG]);

/* Mp16 == 32-bit far pointer:- <word><word> (16:16) <<<<<<<<<<<<<<<< */

#define D_Mp16(ARG, TYPE, PAGE)					\
   if ( GET_MODE(modRM) == 3 )					\
      {								\
      Int6(); /* Register operand not allowed */		\
      }								\
   else								\
      {								\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)2, (INT)2);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);		\
      m_off[ARG] = address_add(m_off[ARG], (LONG)2);		\
      m_la2[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa2[ARG] = usr_chk_word(m_la2[ARG], PAGE);		\
      }

#define F_Mp16(ARG)						\
   ops[ARG].mlt[0] = vir_read_word(m_la[ARG], m_pa[ARG]);	\
   ops[ARG].mlt[1] = vir_read_word(m_la2[ARG], m_pa2[ARG]);

/* Ms == six byte pseudo decriptor <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Ms(ARG, TYPE, PAGE)					\
   d_mem(modRM, &p, segment_override, &m_seg[ARG], &m_off[ARG]);\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)3, (INT)2);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);			\
   m_off[ARG] = address_add(m_off[ARG], (LONG)2);		\
   m_la2[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa2[ARG] = usr_chk_dword(m_la2[ARG], PAGE);

#define F_Ms(ARG)						\
   ops[ARG].mlt[0] = vir_read_word(m_la[ARG], m_pa[ARG]);	\
   ops[ARG].mlt[1] = vir_read_dword(m_la2[ARG], m_pa2[ARG]);

#define P_Ms(ARG)						\
   vir_write_word(m_la[ARG], m_pa[ARG], (USHORT)ops[ARG].mlt[0]);	\
   vir_write_dword(m_la2[ARG], m_pa2[ARG], (ULONG)ops[ARG].mlt[1]);

/* Nw == 'reg' field of modR/M byte denotes segment register <<<<<<<< */

#define D_Nw(ARG) ops[ARG].sng = GET_SEG(modRM);

#define F_Nw(ARG) ops[ARG].sng = GET_SR_SELECTOR(ops[ARG].sng);

/* Ob == offset to byte encoded in instruction stream <<<<<<<<<<<<<<< */

#define D_Ob(ARG, TYPE, PAGE)					\
   m_seg[ARG] = (segment_override == SEG_CLR) ?			\
      DS_REG : segment_override;				\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   if ( GET_ADDRESS_SIZE() == USE32 )				\
      {								\
      immed |= (ULONG)GET_INST_BYTE(p) << 16;			\
      immed |= (ULONG)GET_INST_BYTE(p) << 24;			\
      }								\
   m_off[ARG] = immed;						\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)1);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_byte(m_la[ARG], PAGE);

#define F_Ob(ARG) ops[ARG].sng = vir_read_byte(m_la[ARG], m_pa[ARG]);

#define P_Ob(ARG)						\
   vir_write_byte(m_la[ARG], m_pa[ARG], (UTINY)ops[ARG].sng);

/* Ow == offset to word encoded in instruction stream <<<<<<<<<<<<<<< */

#define D_Ow(ARG, TYPE, PAGE)					\
   m_seg[ARG] = (segment_override == SEG_CLR) ?			\
      DS_REG : segment_override;				\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   if ( GET_ADDRESS_SIZE() == USE32 )				\
      {								\
      immed |= (ULONG)GET_INST_BYTE(p) << 16;			\
      immed |= (ULONG)GET_INST_BYTE(p) << 24;			\
      }								\
   m_off[ARG] = immed;						\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)2);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);

#define F_Ow(ARG)						\
   ops[ARG].sng = vir_read_word(m_la[ARG], m_pa[ARG]);

#define P_Ow(ARG)						\
   vir_write_word(m_la[ARG], m_pa[ARG], (USHORT)ops[ARG].sng);

/* Pw == 2 bits(4-3) of opcode byte denote segment register <<<<<<<<< */

#define D_Pw(ARG) ops[ARG].sng = GET_SEG2(opcode);

#define F_Pw(ARG) ops[ARG].sng = GET_SR_SELECTOR(ops[ARG].sng);

/* Xb == byte string source addressing <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Xb(ARG, TYPE, PAGE)					\
   m_seg[ARG] = (segment_override == SEG_CLR) ?			\
      DS_REG : segment_override;				\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      m_off[ARG] = GET_SI();					\
   else   /* USE32 */						\
      m_off[ARG] = GET_ESI();					\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)1);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_byte(m_la[ARG], PAGE);

#define F_Xb(ARG) ops[ARG].sng = vir_read_byte(m_la[ARG], m_pa[ARG]);

#define C_Xb(ARG)						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      {								\
      if ( GET_DF() )						\
	 SET_SI(GET_SI() - 1);					\
      else							\
	 SET_SI(GET_SI() + 1);					\
      if ( repeat != REP_CLR )					\
	 SET_CX(rep_count);					\
      }								\
   else   /* USE32 */						\
      {								\
      if ( GET_DF() )						\
	 SET_ESI(GET_ESI() - 1);					\
      else							\
	 SET_ESI(GET_ESI() + 1);					\
      if ( repeat != REP_CLR )					\
	 SET_ECX(rep_count);					\
      }

/* Xw == word string source addressing <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Xw(ARG, TYPE, PAGE)					\
   m_seg[ARG] = (segment_override == SEG_CLR) ?			\
      DS_REG : segment_override;				\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      m_off[ARG] = GET_SI();					\
   else   /* USE32 */						\
      m_off[ARG] = GET_ESI();					\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)2);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);

#define F_Xw(ARG)						\
   ops[ARG].sng = vir_read_word(m_la[ARG], m_pa[ARG]);

#define C_Xw(ARG)						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      {								\
      if ( GET_DF() )						\
	 SET_SI(GET_SI() - 2);					\
      else							\
	 SET_SI(GET_SI() + 2);					\
      if ( repeat != REP_CLR )					\
	 SET_CX(rep_count);					\
      }								\
   else   /* USE32 */						\
      {								\
      if ( GET_DF() )						\
	 SET_ESI(GET_ESI() - 2);					\
      else							\
	 SET_ESI(GET_ESI() + 2);					\
      if ( repeat != REP_CLR )					\
	 SET_ECX(rep_count);					\
      }

/* Yb == byte string 'destination' addressing <<<<<<<<<<<<<<<<<<<<<<< */

#define D_Yb(ARG, TYPE, PAGE)					\
   m_seg[ARG] = ES_REG;						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      m_off[ARG] = GET_DI();					\
   else   /* USE32 */						\
      m_off[ARG] = GET_EDI();					\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)1);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_byte(m_la[ARG], PAGE);

#define F_Yb(ARG) ops[ARG].sng = vir_read_byte(m_la[ARG], m_pa[ARG]);

#define C_Yb(ARG)						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      {								\
      if ( GET_DF() )						\
	 SET_DI(GET_DI() - 1);					\
      else							\
	 SET_DI(GET_DI() + 1);					\
      if ( repeat != REP_CLR )					\
	 SET_CX(rep_count);					\
      }								\
   else   /* USE32 */						\
      {								\
      if ( GET_DF() )						\
	 SET_EDI(GET_EDI() - 1);					\
      else							\
	 SET_EDI(GET_EDI() + 1);					\
      if ( repeat != REP_CLR )					\
	 SET_ECX(rep_count);					\
      }

#define P_Yb(ARG)						\
   vir_write_byte(m_la[ARG], m_pa[ARG], (IU8)ops[ARG].sng);

#ifdef	PIG
#define PIG_P_Yb(ARG)						\
   cannot_vir_write_byte(m_la[ARG], m_pa[ARG], 0x00);
#else
#define PIG_P_Yb(ARG)						\
   vir_write_byte(m_la[ARG], m_pa[ARG], (IU8)ops[ARG].sng);
#endif	/* PIG */


/* Yw == word string 'destination' addressing <<<<<<<<<<<<<<<<<<<<<<< */

#define D_Yw(ARG, TYPE, PAGE)					\
   m_seg[ARG] = ES_REG;						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      m_off[ARG] = GET_DI();					\
   else   /* USE32 */						\
      m_off[ARG] = GET_EDI();					\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)2);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_word(m_la[ARG], PAGE);

#define F_Yw(ARG)						\
   ops[ARG].sng = vir_read_word(m_la[ARG], m_pa[ARG]);

#define C_Yw(ARG)						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      {								\
      if ( GET_DF() )						\
	 SET_DI(GET_DI() - 2);					\
      else							\
	 SET_DI(GET_DI() + 2);					\
      if ( repeat != REP_CLR )					\
	 SET_CX(rep_count);					\
      }								\
   else   /* USE32 */						\
      {								\
      if ( GET_DF() )						\
	 SET_EDI(GET_EDI() - 2);					\
      else							\
	 SET_EDI(GET_EDI() + 2);					\
      if ( repeat != REP_CLR )					\
	 SET_ECX(rep_count);					\
      }

#define P_Yw(ARG)						\
   vir_write_word(m_la[ARG], m_pa[ARG], (IU16)ops[ARG].sng);

#ifdef	PIG
#define PIG_P_Yw(ARG)						\
   cannot_vir_write_word(m_la[ARG], m_pa[ARG], 0x0000);
#else
#define PIG_P_Yw(ARG)						\
   vir_write_word(m_la[ARG], m_pa[ARG], (IU16)ops[ARG].sng);
#endif	/* PIG */

/* Z == 'xlat' addressing form <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Z(ARG, TYPE, PAGE)					\
   m_seg[ARG] = (segment_override == SEG_CLR) ?			\
      DS_REG : segment_override;				\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      m_off[ARG] = GET_BX() + GET_AL() & WORD_MASK;		\
   else   /* USE32 */						\
      m_off[ARG] = GET_EBX() + GET_AL();				\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)1);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_byte(m_la[ARG], PAGE);

#define F_Z(ARG) ops[ARG].sng = vir_read_byte(m_la[ARG], m_pa[ARG]);


/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/* 386 and 486                                                        */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */


/* Ad == direct address <off32><seg> in instruction stream <<<<<<<<<< */

#define D_Ad(ARG)						\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   immed |= (ULONG)GET_INST_BYTE(p) << 16;			\
   immed |= (ULONG)GET_INST_BYTE(p) << 24;			\
   ops[ARG].mlt[0] = immed;					\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   ops[ARG].mlt[1] = immed;

/* Cd == 'reg' field of modR/M byte denotes control register <<<<<<<< */

#define D_Cd(ARG) ops[ARG].sng = GET_EEE(modRM);

#define F_Cd(ARG) ops[ARG].sng = GET_CR(ops[ARG].sng);

/* Dd == 'reg' field of modR/M byte denotes debug register <<<<<<<<<< */

#define D_Dd(ARG) ops[ARG].sng = GET_EEE(modRM);

#define F_Dd(ARG) ops[ARG].sng = GET_DR(ops[ARG].sng);

/* Ed == 'mode'+'r/m' fields refer to double word register/memory <<< */

#define D_Ed(ARG, TYPE, PAGE)					\
   if ( GET_MODE(modRM) == 3 )					\
      {								\
      save_id[ARG] = GET_R_M(modRM);				\
      m_isreg[ARG] = TRUE;					\
      }								\
   else								\
      {								\
      m_isreg[ARG] = FALSE;					\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)4);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_dword(m_la[ARG], PAGE);		\
      }

#define F_Ed(ARG)						\
   if ( m_isreg[ARG] )						\
      ops[ARG].sng = GET_GR(save_id[ARG]);			\
   else								\
      ops[ARG].sng = vir_read_dword(m_la[ARG], m_pa[ARG]);

#define P_Ed(ARG)						\
   if ( m_isreg[ARG] )						\
      SET_GR(save_id[ARG], ops[ARG].sng);			\
   else								\
      vir_write_dword(m_la[ARG], m_pa[ARG], (ULONG)ops[ARG].sng);

/* Feax == fixed register, EAX <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define F_Feax(ARG) ops[ARG].sng = GET_GR(A_EAX);

#define P_Feax(ARG) SET_GR(A_EAX, ops[ARG].sng);

/* Gd == 'reg' field of modR/M byte denotes double word reg <<<<<<<<< */

#define D_Gd(ARG) save_id[ARG] = GET_REG(modRM);

#define F_Gd(ARG) ops[ARG].sng = GET_GR(save_id[ARG]);

#define P_Gd(ARG) SET_GR(save_id[ARG], ops[ARG].sng);

/* Hd == low 3 bits of opcode denote double word register <<<<<<<<<<< */

#define D_Hd(ARG) save_id[ARG] = GET_LOW3(opcode);

#define F_Hd(ARG) ops[ARG].sng = GET_GR(save_id[ARG]);

#define P_Hd(ARG) SET_GR(save_id[ARG], ops[ARG].sng);

/* Id == immediate double word <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Id(ARG)						\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   immed |= (ULONG)GET_INST_BYTE(p) << 16;			\
   immed |= (ULONG)GET_INST_BYTE(p) << 24;			\
   ops[ARG].sng = immed;

/* Iy == immediate byte sign extended to double word <<<<<<<<<<<<<<<< */

#define D_Iy(ARG)						\
   immed = GET_INST_BYTE(p);					\
   if ( immed & 0x80 )						\
      immed |= 0xffffff00;					\
   ops[ARG].sng = immed;

/* Jd == relative offset double word <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Jd(ARG)						\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   immed |= (ULONG)GET_INST_BYTE(p) << 16;			\
   immed |= (ULONG)GET_INST_BYTE(p) << 24;			\
   ops[ARG].sng = immed;

/* Ma32 == double word operand pair, as used by BOUND <<<<<<<<<<<<<<< */

#define D_Ma32(ARG, TYPE, PAGE)					\
   if ( GET_MODE(modRM) == 3 )					\
      {								\
      Int6(); /* Register operand not allowed */		\
      }								\
   else								\
      {								\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)2, (INT)4);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_dword(m_la[ARG], PAGE);		\
      m_off[ARG] = address_add(m_off[ARG], (LONG)4);		\
      m_la2[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa2[ARG] = usr_chk_dword(m_la2[ARG], PAGE);		\
      }

#define F_Ma32(ARG)						\
   ops[ARG].mlt[0] = vir_read_dword(m_la[ARG], m_pa[ARG]);	\
   ops[ARG].mlt[1] = vir_read_dword(m_la2[ARG], m_pa2[ARG]);

/* Mp32 == 48-bit far pointer:- <double word><word> (32:16) <<<<<<<<< */

#define D_Mp32(ARG, TYPE, PAGE)					\
   if ( GET_MODE(modRM) == 3 )					\
      {								\
      Int6(); /* Register operand not allowed */		\
      }								\
   else								\
      {								\
      d_mem(modRM, &p, segment_override,			\
	    &m_seg[ARG], &m_off[ARG]);				\
      TYPE							\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)4);	\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_off[ARG] = address_add(m_off[ARG], (LONG)4);		\
      limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)2);	\
      m_la2[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      m_pa[ARG] = usr_chk_dword(m_la[ARG], PAGE);		\
      m_pa2[ARG] = usr_chk_word(m_la2[ARG], PAGE);		\
      }

#define F_Mp32(ARG)						\
   ops[ARG].mlt[0] = vir_read_dword(m_la[ARG], m_pa[ARG]);	\
   ops[ARG].mlt[1] = vir_read_word(m_la2[ARG], m_pa2[ARG]);

/* Od == offset to double word encoded in instruction stream <<<<<<<< */

#define D_Od(ARG, TYPE, PAGE)					\
   m_seg[ARG] = (segment_override == SEG_CLR) ?			\
      DS_REG : segment_override;				\
   immed = GET_INST_BYTE(p);					\
   immed |= (ULONG)GET_INST_BYTE(p) << 8;			\
   if ( GET_ADDRESS_SIZE() == USE32 )				\
      {								\
      immed |= (ULONG)GET_INST_BYTE(p) << 16;			\
      immed |= (ULONG)GET_INST_BYTE(p) << 24;			\
      }								\
   m_off[ARG] = immed;						\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)4);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_dword(m_la[ARG], PAGE);

#define F_Od(ARG)						\
   ops[ARG].sng = vir_read_dword(m_la[ARG], m_pa[ARG]);

#define P_Od(ARG)						\
   vir_write_dword(m_la[ARG], m_pa[ARG], (ULONG)ops[ARG].sng);

/* Qw == 3 bits(5-3) of opcode byte denote segment register <<<<<<<<< */

#define D_Qw(ARG) ops[ARG].sng = GET_SEG3(opcode);

#define F_Qw(ARG) ops[ARG].sng = GET_SR_SELECTOR(ops[ARG].sng);

/* Rd == ('mode') + 'r/m' fields refer to a double word register <<<< */

#define D_Rd(ARG) save_id[ARG] = GET_R_M(modRM);

#define F_Rd(ARG) ops[ARG].sng = GET_GR(save_id[ARG]);

#define P_Rd(ARG) SET_GR(save_id[ARG], ops[ARG].sng);

/* Td == 'reg' field of modR/M byte denotes test register <<<<<<<<<<< */

#define D_Td(ARG) ops[ARG].sng = GET_EEE(modRM);

#define F_Td(ARG) ops[ARG].sng = GET_TR(ops[ARG].sng);

/* Xd == double word string source addressing <<<<<<<<<<<<<<<<<<<<<<< */

#define D_Xd(ARG, TYPE, PAGE)					\
   m_seg[ARG] = (segment_override == SEG_CLR) ?			\
      DS_REG : segment_override;				\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      m_off[ARG] = GET_SI();					\
   else   /* USE32 */						\
      m_off[ARG] = GET_ESI();					\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)4);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_dword(m_la[ARG], PAGE);

#define F_Xd(ARG)						\
   ops[ARG].sng = vir_read_dword(m_la[ARG], m_pa[ARG]);

#define C_Xd(ARG)						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      {								\
      if ( GET_DF() )						\
	 SET_SI(GET_SI() - 4);					\
      else							\
	 SET_SI(GET_SI() + 4);					\
      if ( repeat != REP_CLR )					\
	 SET_CX(rep_count);					\
      }								\
   else   /* USE32 */						\
      {								\
      if ( GET_DF() )						\
	 SET_ESI(GET_ESI() - 4);					\
      else							\
	 SET_ESI(GET_ESI() + 4);					\
      if ( repeat != REP_CLR )					\
	 SET_ECX(rep_count);					\
      }

/* Yd == double word string 'destination' addressing <<<<<<<<<<<<<<<< */

#define D_Yd(ARG, TYPE, PAGE)					\
   m_seg[ARG] = ES_REG;						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      m_off[ARG] = GET_DI();					\
   else   /* USE32 */						\
      m_off[ARG] = GET_EDI();					\
   TYPE								\
   limit_check(m_seg[ARG], m_off[ARG], (INT)1, (INT)4);		\
   m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
   m_pa[ARG] = usr_chk_dword(m_la[ARG], PAGE);

#define F_Yd(ARG)						\
   ops[ARG].sng = vir_read_dword(m_la[ARG], m_pa[ARG]);

#define C_Yd(ARG)						\
   if ( GET_ADDRESS_SIZE() == USE16 )				\
      {								\
      if ( GET_DF() )						\
	 SET_DI(GET_DI() - 4);					\
      else							\
	 SET_DI(GET_DI() + 4);					\
      if ( repeat != REP_CLR )					\
	 SET_CX(rep_count);					\
      }								\
   else   /* USE32 */						\
      {								\
      if ( GET_DF() )						\
	 SET_EDI(GET_EDI() - 4);					\
      else							\
	 SET_EDI(GET_EDI() + 4);					\
      if ( repeat != REP_CLR )					\
	 SET_ECX(rep_count);					\
      }

#define P_Yd(ARG)						\
   vir_write_dword(m_la[ARG], m_pa[ARG], (IU32)ops[ARG].sng);

#ifdef	PIG
#define PIG_P_Yd(ARG)						\
   cannot_vir_write_dword(m_la[ARG], m_pa[ARG], 0x00000000);
#else
#define PIG_P_Yd(ARG)						\
   vir_write_dword(m_la[ARG], m_pa[ARG], (IU32)ops[ARG].sng);
#endif	/* PIG */


/*
 * The macros for decoding and fetching the operands for a BTx instruction.
 * See the file header for a description of why these are required.
 */

#define BT_OPSw(TYPE, PAGE) \
	if ( GET_MODE(modRM) == 3 ) {				\
		/*						\
		 * Register operand, no frigging required.	\
		 */						\
      								\
		save_id[0] = GET_R_M(modRM);			\
		m_isreg[0] = TRUE;				\
		D_Gw(1)						\
		F_Ew(0)						\
		F_Gw(1)						\
      }	else {							\
		D_Gw(1)						\
		F_Gw(1)						\
		m_isreg[0] = FALSE;				\
		d_mem(modRM, &p, segment_override,		\
			&m_seg[0], &m_off[0]);			\
		m_off[0] += (ops[1].sng >> 3) & ~1;		\
		TYPE						\
		limit_check(m_seg[0], m_off[0], (INT)1, (INT)2);	\
		m_la[0] = GET_SR_BASE(m_seg[0]) + m_off[0];	\
		m_pa[0] = usr_chk_word(m_la[0], PAGE);		\
		F_Ew(0)						\
      }								\

#define BT_OPSd(TYPE, PAGE) \
	if ( GET_MODE(modRM) == 3 ) {				\
		/*						\
		 * Register operand, no frigging required.	\
		 */						\
      								\
		save_id[0] = GET_R_M(modRM);			\
		m_isreg[0] = TRUE;				\
		D_Gd(1)						\
		F_Ed(0)						\
		F_Gd(1)						\
      }	else {							\
		D_Gd(1)						\
		F_Gd(1)						\
		m_isreg[0] = FALSE;				\
		d_mem(modRM, &p, segment_override,		\
			&m_seg[0], &m_off[0]);			\
		m_off[0] += (ops[1].sng >> 3) & ~3;		\
		TYPE						\
		limit_check(m_seg[0], m_off[0], (INT)1, (INT)4);	\
		m_la[0] = GET_SR_BASE(m_seg[0]) + m_off[0];	\
		m_pa[0] = usr_chk_dword(m_la[0], PAGE);		\
		F_Ed(0)						\
      }								\

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/* 486 only                                                           */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */


/* Mm == address of memory operand <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

#define D_Mm(ARG)						\
   if ( GET_MODE(modRM) == 3 )					\
      Int6(); /* Register operand not allowed */		\
   else								\
      {								\
      d_mem(modRM, &p, segment_override, &m_seg[ARG],		\
					 &m_off[ARG]);		\
      m_la[ARG] = GET_SR_BASE(m_seg[ARG]) + m_off[ARG];		\
      }

#define F_Mm(ARG) ops[ARG].sng = m_la[ARG];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_reg.h ===
/*[

c_reg.h

LOCAL CHAR SccsID[]="@(#)c_reg.h	1.8 08/26/94";

Access to CPU Registers.
------------------------

NB. This file is *NOT* a description of the 'c_reg.c' functions. Those
    are given in 'cpu.h'. However it is analogous in that 'c_reg.c'
    defines the CPU Registers for the outside world. This file defines
    the CPU Registers for access internal to the C CPU.

]*/


/* CS, SS, DS, ES, FS and GS */
typedef struct
   {
   IU16 selector;	/* 16-bit selector */
   IU32 ar_dpl;		/* privilege */
   IU32 ar_e;		/* expansion direction */
   IU32 ar_r;		/* readable */
   IU32 ar_w;		/* writable */
   IU32 ar_c;		/* conforming */
   IU32 ar_x;		/* default (CS) big (SS,DS,ES,FS,GS) */
   IU32 base;		/* 32-bit base address (286 = 24-bit) */
   IU32 limit;		/* 32-bit offset limit (286 = 16-bit) */
   } SEGMENT_REGISTER;

/* LDTR and TR */
typedef struct
   {
   IU16 selector;	/* 16-bit selector */
   ISM32 ar_super;	/* descriptor type (only used for TR) */
   IU32 base;		/* 32-bit base address (286 = 24-bit) */
   IU32 limit;		/* 32-bit offset limit (286 = 16-bit) */
   } SYSTEM_ADDRESS_REGISTER;

/* GDTR and IDTR */
typedef struct
   {
   IU32 base;  /* 32-bit base (286 = 24-bit) */
   IU16 limit;  /* 16-bit limit */
   } SYSTEM_TABLE_ADDRESS_REGISTER;


/*
   C CPU Registers. (See c_main.c for full description.)
 */
IMPORT IU32	CCPU_TR[];
IMPORT IU32	CCPU_DR[];
IMPORT IU32	CCPU_CR[];
IMPORT IU32	CCPU_GR[];
IMPORT IU16	*CCPU_WR[];
IMPORT IU8	*CCPU_BR[];
IMPORT IU32	CCPU_IP;
IMPORT IU32	CCPU_FLAGS[];
IMPORT IU32	CCPU_CPL;
IMPORT IU32	CCPU_MODE[];
IMPORT SEGMENT_REGISTER			CCPU_SR[];
IMPORT SYSTEM_ADDRESS_REGISTER		CCPU_SAR[];
IMPORT SYSTEM_TABLE_ADDRESS_REGISTER	CCPU_STAR[];


/*
   Access to the emulation register set.
 */


/* Double Word General Registers */
#define GET_GR(i)	CCPU_GR[(i)]
#define SET_GR(i, x)	CCPU_GR[(i)] = (x)

#define A_EAX   0
#define A_ECX   1
#define A_EDX   2
#define A_EBX   3
#define A_ESP   4
#define A_EBP   5
#define A_ESI   6
#define A_EDI   7

#define GET_EAX()	GET_GR(A_EAX)
#define GET_ECX()	GET_GR(A_ECX)
#define GET_EDX()	GET_GR(A_EDX)
#define GET_EBX()	GET_GR(A_EBX)
#define GET_ESP()	GET_GR(A_ESP)
#define GET_EBP()	GET_GR(A_EBP)
#define GET_ESI()	GET_GR(A_ESI)
#define GET_EDI()	GET_GR(A_EDI)

#define SET_EAX(x)	SET_GR(A_EAX, (x))
#define SET_ECX(x)	SET_GR(A_ECX, (x))
#define SET_EDX(x)	SET_GR(A_EDX, (x))
#define SET_EBX(x)	SET_GR(A_EBX, (x))
#define SET_ESP(x)	SET_GR(A_ESP, (x))
#define SET_EBP(x)	SET_GR(A_EBP, (x))
#define SET_ESI(x)	SET_GR(A_ESI, (x))
#define SET_EDI(x)	SET_GR(A_EDI, (x))

/* Word Registers */
#define GET_WR(i)	(*CCPU_WR[(i)])
#define SET_WR(i, x)	*CCPU_WR[(i)] = (x)

#define A_AX	0
#define A_CX	1
#define A_DX	2
#define A_BX	3
#define A_SP	4
#define A_BP	5
#define A_SI	6
#define A_DI	7

#define GET_AX()		GET_WR(A_AX)
#define GET_CX()		GET_WR(A_CX)
#define GET_DX()		GET_WR(A_DX)
#define GET_BX()		GET_WR(A_BX)
#define GET_SP()		GET_WR(A_SP)
#define GET_BP()		GET_WR(A_BP)
#define GET_SI()		GET_WR(A_SI)
#define GET_DI()		GET_WR(A_DI)

#define SET_AX(x)	SET_WR(A_AX, (x))
#define SET_CX(x)	SET_WR(A_CX, (x))
#define SET_DX(x)	SET_WR(A_DX, (x))
#define SET_BX(x)	SET_WR(A_BX, (x))
#define SET_SP(x)	SET_WR(A_SP, (x))
#define SET_BP(x)	SET_WR(A_BP, (x))
#define SET_SI(x)	SET_WR(A_SI, (x))
#define SET_DI(x)	SET_WR(A_DI, (x))

#define GET_EIP()	CCPU_IP
#define SET_EIP(x)	CCPU_IP = (x)

/* Byte Registers */
#define GET_BR(i)	(*CCPU_BR[(i)])
#define SET_BR(i, x)	*CCPU_BR[(i)] = (x)

#define A_AL	0
#define A_CL	1
#define A_DL	2
#define A_BL	3
#define A_AH	4
#define A_CH	5
#define A_DH	6
#define A_BH	7

#define GET_AL()		GET_BR(A_AL)
#define GET_CL()		GET_BR(A_CL)
#define GET_DL()		GET_BR(A_DL)
#define GET_BL()		GET_BR(A_BL)
#define GET_AH()		GET_BR(A_AH)
#define GET_CH()		GET_BR(A_CH)
#define GET_DH()		GET_BR(A_DH)
#define GET_BH()		GET_BR(A_BH)

#define SET_AL(x)	SET_BR(A_AL, (x))
#define SET_CL(x)	SET_BR(A_CL, (x))
#define SET_DL(x)	SET_BR(A_DL, (x))
#define SET_BL(x)	SET_BR(A_BL, (x))
#define SET_AH(x)	SET_BR(A_AH, (x))
#define SET_CH(x)	SET_BR(A_CH, (x))
#define SET_DH(x)	SET_BR(A_DH, (x))
#define SET_BH(x)	SET_BR(A_BH, (x))

/* Segment Registers */
#define GET_SR_SELECTOR(i)	CCPU_SR[(i)].selector
#define GET_SR_BASE(i)		CCPU_SR[(i)].base
#define GET_SR_LIMIT(i)		CCPU_SR[(i)].limit
#define GET_SR_AR_DPL(i)		CCPU_SR[(i)].ar_dpl
#define GET_SR_AR_E(i)		CCPU_SR[(i)].ar_e
#define GET_SR_AR_W(i)		CCPU_SR[(i)].ar_w
#define GET_SR_AR_R(i)		CCPU_SR[(i)].ar_r
#define GET_SR_AR_C(i)		CCPU_SR[(i)].ar_c
#define GET_SR_AR_X(i)		CCPU_SR[(i)].ar_x

#define SET_SR_SELECTOR(i, x)	CCPU_SR[(i)].selector = (x)
#define SET_SR_BASE(i, x)	CCPU_SR[(i)].base = (x)
#define SET_SR_LIMIT(i, x)	CCPU_SR[(i)].limit = (x)
#define SET_SR_AR_DPL(i, x)	CCPU_SR[(i)].ar_dpl = (x)
#define SET_SR_AR_E(i, x)	CCPU_SR[(i)].ar_e = (x)
#define SET_SR_AR_W(i, x)	CCPU_SR[(i)].ar_w = (x)
#define SET_SR_AR_R(i, x)	CCPU_SR[(i)].ar_r = (x)
#define SET_SR_AR_C(i, x)	CCPU_SR[(i)].ar_c = (x)
#define SET_SR_AR_X(i, x)	CCPU_SR[(i)].ar_x = (x)

#define ES_REG 0
#define CS_REG 1
#define SS_REG 2
#define DS_REG 3
#define FS_REG 4
#define GS_REG 5

#define GET_ES_SELECTOR()	GET_SR_SELECTOR(ES_REG)
#define GET_ES_BASE()		GET_SR_BASE(ES_REG)
#define GET_ES_LIMIT()		GET_SR_LIMIT(ES_REG)
#define GET_ES_AR_DPL()		GET_SR_AR_DPL(ES_REG)
#define GET_ES_AR_E()		GET_SR_AR_E(ES_REG)
#define GET_ES_AR_W()		GET_SR_AR_W(ES_REG)
#define GET_ES_AR_R()		GET_SR_AR_R(ES_REG)
#define GET_ES_AR_C()		GET_SR_AR_C(ES_REG)
#define GET_ES_AR_X()		GET_SR_AR_X(ES_REG)

#define SET_ES_SELECTOR(x)	SET_SR_SELECTOR(ES_REG, (x))
#define SET_ES_BASE(x)		SET_SR_BASE(ES_REG, (x))
#define SET_ES_LIMIT(x)		SET_SR_LIMIT(ES_REG, (x))
#define SET_ES_AR_DPL(x)		SET_SR_AR_DPL(ES_REG, (x))
#define SET_ES_AR_E(x)		SET_SR_AR_E(ES_REG, (x))
#define SET_ES_AR_W(x)		SET_SR_AR_W(ES_REG, (x))
#define SET_ES_AR_R(x)		SET_SR_AR_R(ES_REG, (x))
#define SET_ES_AR_C(x)		SET_SR_AR_C(ES_REG, (x))
#define SET_ES_AR_X(x)		SET_SR_AR_X(ES_REG, (x))

#define GET_CS_SELECTOR()	GET_SR_SELECTOR(CS_REG)
#define GET_CS_BASE()		GET_SR_BASE(CS_REG)
#define GET_CS_LIMIT()		GET_SR_LIMIT(CS_REG)
#define GET_CS_AR_DPL()		GET_SR_AR_DPL(CS_REG)
#define GET_CS_AR_E()		GET_SR_AR_E(CS_REG)
#define GET_CS_AR_W()		GET_SR_AR_W(CS_REG)
#define GET_CS_AR_R()		GET_SR_AR_R(CS_REG)
#define GET_CS_AR_C()		GET_SR_AR_C(CS_REG)
#define GET_CS_AR_X()		GET_SR_AR_X(CS_REG)

#define SET_CS_SELECTOR(x)	SET_SR_SELECTOR(CS_REG, (x))
#define SET_CS_BASE(x)		SET_SR_BASE(CS_REG, (x))
#define SET_CS_LIMIT(x)		SET_SR_LIMIT(CS_REG, (x))
#define SET_CS_AR_DPL(x)		SET_SR_AR_DPL(CS_REG, (x))
#define SET_CS_AR_E(x)		SET_SR_AR_E(CS_REG, (x))
#define SET_CS_AR_W(x)		SET_SR_AR_W(CS_REG, (x))
#define SET_CS_AR_R(x)		SET_SR_AR_R(CS_REG, (x))
#define SET_CS_AR_C(x)		SET_SR_AR_C(CS_REG, (x))
#define SET_CS_AR_X(x)		SET_SR_AR_X(CS_REG, (x))

#define GET_SS_SELECTOR()	GET_SR_SELECTOR(SS_REG)
#define GET_SS_BASE()		GET_SR_BASE(SS_REG)
#define GET_SS_LIMIT()		GET_SR_LIMIT(SS_REG)
#define GET_SS_AR_DPL()		GET_SR_AR_DPL(SS_REG)
#define GET_SS_AR_E()		GET_SR_AR_E(SS_REG)
#define GET_SS_AR_W()		GET_SR_AR_W(SS_REG)
#define GET_SS_AR_R()		GET_SR_AR_R(SS_REG)
#define GET_SS_AR_C()		GET_SR_AR_C(SS_REG)
#define GET_SS_AR_X()		GET_SR_AR_X(SS_REG)

#define SET_SS_SELECTOR(x)	SET_SR_SELECTOR(SS_REG, (x))
#define SET_SS_BASE(x)		SET_SR_BASE(SS_REG, (x))
#define SET_SS_LIMIT(x)		SET_SR_LIMIT(SS_REG, (x))
#define SET_SS_AR_DPL(x)		SET_SR_AR_DPL(SS_REG, (x))
#define SET_SS_AR_E(x)		SET_SR_AR_E(SS_REG, (x))
#define SET_SS_AR_W(x)		SET_SR_AR_W(SS_REG, (x))
#define SET_SS_AR_R(x)		SET_SR_AR_R(SS_REG, (x))
#define SET_SS_AR_C(x)		SET_SR_AR_C(SS_REG, (x))
#define SET_SS_AR_X(x)		SET_SR_AR_X(SS_REG, (x))

#define GET_DS_SELECTOR()	GET_SR_SELECTOR(DS_REG)
#define GET_DS_BASE()		GET_SR_BASE(DS_REG)
#define GET_DS_LIMIT()		GET_SR_LIMIT(DS_REG)
#define GET_DS_AR_DPL()		GET_SR_AR_DPL(DS_REG)
#define GET_DS_AR_E()		GET_SR_AR_E(DS_REG)
#define GET_DS_AR_W()		GET_SR_AR_W(DS_REG)
#define GET_DS_AR_R()		GET_SR_AR_R(DS_REG)
#define GET_DS_AR_C()		GET_SR_AR_C(DS_REG)
#define GET_DS_AR_X()		GET_SR_AR_X(DS_REG)

#define SET_DS_SELECTOR(x)	SET_SR_SELECTOR(DS_REG, (x))
#define SET_DS_BASE(x)		SET_SR_BASE(DS_REG, (x))
#define SET_DS_LIMIT(x)		SET_SR_LIMIT(DS_REG, (x))
#define SET_DS_AR_DPL(x)		SET_SR_AR_DPL(DS_REG, (x))
#define SET_DS_AR_E(x)		SET_SR_AR_E(DS_REG, (x))
#define SET_DS_AR_W(x)		SET_SR_AR_W(DS_REG, (x))
#define SET_DS_AR_R(x)		SET_SR_AR_R(DS_REG, (x))
#define SET_DS_AR_C(x)		SET_SR_AR_C(DS_REG, (x))
#define SET_DS_AR_X(x)		SET_SR_AR_X(DS_REG, (x))

#define GET_FS_SELECTOR()	GET_SR_SELECTOR(FS_REG)
#define GET_FS_BASE()		GET_SR_BASE(FS_REG)
#define GET_FS_LIMIT()		GET_SR_LIMIT(FS_REG)
#define GET_FS_AR_DPL()		GET_SR_AR_DPL(FS_REG)
#define GET_FS_AR_E()		GET_SR_AR_E(FS_REG)
#define GET_FS_AR_W()		GET_SR_AR_W(FS_REG)
#define GET_FS_AR_R()		GET_SR_AR_R(FS_REG)
#define GET_FS_AR_C()		GET_SR_AR_C(FS_REG)
#define GET_FS_AR_X()		GET_SR_AR_X(FS_REG)

#define SET_FS_SELECTOR(x)	SET_SR_SELECTOR(FS_REG, (x))
#define SET_FS_BASE(x)		SET_SR_BASE(FS_REG, (x))
#define SET_FS_LIMIT(x)		SET_SR_LIMIT(FS_REG, (x))
#define SET_FS_AR_DPL(x)		SET_SR_AR_DPL(FS_REG, (x))
#define SET_FS_AR_E(x)		SET_SR_AR_E(FS_REG, (x))
#define SET_FS_AR_W(x)		SET_SR_AR_W(FS_REG, (x))
#define SET_FS_AR_R(x)		SET_SR_AR_R(FS_REG, (x))
#define SET_FS_AR_C(x)		SET_SR_AR_C(FS_REG, (x))
#define SET_FS_AR_X(x)		SET_SR_AR_X(FS_REG, (x))

#define GET_GS_SELECTOR()	GET_SR_SELECTOR(GS_REG)
#define GET_GS_BASE()		GET_SR_BASE(GS_REG)
#define GET_GS_LIMIT()		GET_SR_LIMIT(GS_REG)
#define GET_GS_AR_DPL()		GET_SR_AR_DPL(GS_REG)
#define GET_GS_AR_E()		GET_SR_AR_E(GS_REG)
#define GET_GS_AR_W()		GET_SR_AR_W(GS_REG)
#define GET_GS_AR_R()		GET_SR_AR_R(GS_REG)
#define GET_GS_AR_C()		GET_SR_AR_C(GS_REG)
#define GET_GS_AR_X()		GET_SR_AR_X(GS_REG)

#define SET_GS_SELECTOR(x)	SET_SR_SELECTOR(GS_REG, (x))
#define SET_GS_BASE(x)		SET_SR_BASE(GS_REG, (x))
#define SET_GS_LIMIT(x)		SET_SR_LIMIT(GS_REG, (x))
#define SET_GS_AR_DPL(x)		SET_SR_AR_DPL(GS_REG, (x))
#define SET_GS_AR_E(x)		SET_SR_AR_E(GS_REG, (x))
#define SET_GS_AR_W(x)		SET_SR_AR_W(GS_REG, (x))
#define SET_GS_AR_R(x)		SET_SR_AR_R(GS_REG, (x))
#define SET_GS_AR_C(x)		SET_SR_AR_C(GS_REG, (x))
#define SET_GS_AR_X(x)		SET_SR_AR_X(GS_REG, (x))

/* System Table  Address Registers */
#define GET_STAR_BASE(i)		CCPU_STAR[(i)].base
#define GET_STAR_LIMIT(i)	CCPU_STAR[(i)].limit

#define SET_STAR_BASE(i, x)	CCPU_STAR[(i)].base = (x)
#define SET_STAR_LIMIT(i, x)	CCPU_STAR[(i)].limit = (x)

#define GDT_REG 0
#define IDT_REG 1

#define GET_GDT_BASE()	GET_STAR_BASE(GDT_REG)
#define GET_GDT_LIMIT()	GET_STAR_LIMIT(GDT_REG)
#define GET_IDT_BASE()	GET_STAR_BASE(IDT_REG)
#define GET_IDT_LIMIT()	GET_STAR_LIMIT(IDT_REG)

#define SET_GDT_BASE(x)	SET_STAR_BASE(GDT_REG, (x))
#define SET_GDT_LIMIT(x)	SET_STAR_LIMIT(GDT_REG, (x))
#define SET_IDT_BASE(x)	SET_STAR_BASE(IDT_REG, (x))
#define SET_IDT_LIMIT(x)	SET_STAR_LIMIT(IDT_REG, (x))

/* System Address Registers */
#define GET_SAR_SELECTOR(i)	CCPU_SAR[(i)].selector
#define GET_SAR_AR_SUPER(i)	CCPU_SAR[(i)].ar_super
#define GET_SAR_BASE(i)		CCPU_SAR[(i)].base
#define GET_SAR_LIMIT(i)		CCPU_SAR[(i)].limit

#define SET_SAR_SELECTOR(i, x)	CCPU_SAR[(i)].selector = (x)
#define SET_SAR_AR_SUPER(i, x)	CCPU_SAR[(i)].ar_super = (x)
#define SET_SAR_BASE(i, x)	CCPU_SAR[(i)].base = (x)
#define SET_SAR_LIMIT(i, x)	CCPU_SAR[(i)].limit = (x)

#define LDT_REG 0
#define TR_REG  1

#define GET_LDT_SELECTOR()	GET_SAR_SELECTOR(LDT_REG)
#define GET_LDT_BASE()		GET_SAR_BASE(LDT_REG)
#define GET_LDT_LIMIT()		GET_SAR_LIMIT(LDT_REG)
#define GET_TR_SELECTOR()	GET_SAR_SELECTOR(TR_REG)
#define GET_TR_AR_SUPER()	GET_SAR_AR_SUPER(TR_REG)
#define GET_TR_BASE()		GET_SAR_BASE(TR_REG)
#define GET_TR_LIMIT()		GET_SAR_LIMIT(TR_REG)

#define SET_LDT_SELECTOR(x)	SET_SAR_SELECTOR(LDT_REG, (x))
#define SET_LDT_BASE(x)		SET_SAR_BASE(LDT_REG, (x))
#define SET_LDT_LIMIT(x)		SET_SAR_LIMIT(LDT_REG, (x))
#define SET_TR_SELECTOR(x)	SET_SAR_SELECTOR(TR_REG, (x))
#define SET_TR_AR_SUPER(x)	SET_SAR_AR_SUPER(TR_REG, (x))
#define SET_TR_BASE(x)		SET_SAR_BASE(TR_REG, (x))
#define SET_TR_LIMIT(x)		SET_SAR_LIMIT(TR_REG, (x))

/* Flag Register */
#define GET_CF()		CCPU_FLAGS[0]
#define GET_PF()		CCPU_FLAGS[2]
#define GET_AF()		CCPU_FLAGS[4]
#define GET_ZF()		CCPU_FLAGS[6]
#define GET_SF()		CCPU_FLAGS[7]
#define GET_TF()		CCPU_FLAGS[8]
#define GET_IF()		CCPU_FLAGS[9]
#define GET_DF()		CCPU_FLAGS[10]
#define GET_OF()		CCPU_FLAGS[11]
#define GET_IOPL()	CCPU_FLAGS[12]
#define GET_NT()		CCPU_FLAGS[14]
#define GET_RF()		CCPU_FLAGS[16]
#define GET_VM()		CCPU_FLAGS[17]
#define GET_AC()		CCPU_FLAGS[18]

#define SET_CF(x)	CCPU_FLAGS[0] = (x)
#define SET_PF(x)	CCPU_FLAGS[2] = (x)
#define SET_AF(x)	CCPU_FLAGS[4] = (x)
#define SET_ZF(x)	CCPU_FLAGS[6] = (x)
#define SET_SF(x)	CCPU_FLAGS[7] = (x)
#define SET_TF(x)	CCPU_FLAGS[8] = (x)
#ifdef SFELLOW
extern IU32 DisableEE IPT0();
extern void EnableEE IPT0();
#define SET_IF(x)	\
{ \
	if (x) \
	{ \
		EnableEE(); \
	} \
	else \
	{ \
		DisableEE(); \
	} \
	CCPU_FLAGS[9] = (x); \
}
#else
#define SET_IF(x)	CCPU_FLAGS[9] = (x)
#endif /* SFELLOW */
#define SET_DF(x)	CCPU_FLAGS[10] = (x)
#define SET_OF(x)	CCPU_FLAGS[11] = (x)
#define SET_IOPL(x)	CCPU_FLAGS[12] = (x)
#define SET_NT(x)	CCPU_FLAGS[14] = (x)
#define SET_RF(x)	CCPU_FLAGS[16] = (x)
#define SET_VM(x)	CCPU_FLAGS[17] = (x)
#define SET_AC(x)	CCPU_FLAGS[18] = (x)

/* Test Registers */
#define TR_TDR 7
#define TR_TCR 6
#define TR_CCR 5
#define TR_CSR 4
#define TR_CDR 3

#define GET_TR(i)        CCPU_TR[(i)]
#define SET_TR(i, x)     CCPU_TR[(i)] = (x)

/* Debug Registers */
#define DR_DCR  7
#define DR_DSR  6
#define DR_DAR3 3
#define DR_DAR2 2
#define DR_DAR1 1
#define DR_DAR0 0

#define DSR_BT_MASK BIT15_MASK
#define DSR_BS_MASK BIT14_MASK
#define DSR_B3_MASK BIT3_MASK
#define DSR_B2_MASK BIT2_MASK
#define DSR_B1_MASK BIT1_MASK
#define DSR_B0_MASK BIT0_MASK

#define GET_DR(i)        CCPU_DR[(i)]
#define SET_DR(i, x)     CCPU_DR[(i)] = (x)

/* Control Registers */
#define CR_PDBR 3
#define CR_PFLA 2
#define CR_RSVD 1
#define CR_STAT 0

#define GET_CR(i)        CCPU_CR[(i)]
#define SET_CR(i, x)     CCPU_CR[(i)] = (x)

#define GET_PE()		( CCPU_CR[CR_STAT] & BIT0_MASK)
#define GET_MP()		((CCPU_CR[CR_STAT] & BIT1_MASK) != 0)
#define GET_EM()		((CCPU_CR[CR_STAT] & BIT2_MASK) != 0)
#define GET_TS()		((CCPU_CR[CR_STAT] & BIT3_MASK) != 0)
#define GET_ET()		((CCPU_CR[CR_STAT] & BIT4_MASK) != 0)
#define GET_PG()		((CCPU_CR[CR_STAT] & BIT31_MASK) != 0)

/* 486 only */
#define GET_NE()		((CCPU_CR[CR_STAT] & BIT5_MASK) != 0)
#define GET_WP()		((CCPU_CR[CR_STAT] & BIT16_MASK) != 0)
#define GET_AM()		((CCPU_CR[CR_STAT] & BIT18_MASK) != 0)
#define GET_NW()		((CCPU_CR[CR_STAT] & BIT29_MASK) != 0)
#define GET_CD()		((CCPU_CR[CR_STAT] & BIT30_MASK) != 0)

#define SET_PE(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT0_MASK  | ((x) & 1))
#define SET_MP(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT1_MASK  | ((x) & 1) <<  1)
#define SET_EM(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT2_MASK  | ((x) & 1) <<  2)
#define SET_TS(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT3_MASK  | ((x) & 1) <<  3)
#define SET_ET(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT4_MASK  | ((x) & 1) <<  4)
#define SET_PG(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT31_MASK | ((x) & 1) << 31)

/* 486 only */
#define SET_NE(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT5_MASK  | ((x) & 1) <<  5)
#define SET_WP(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT16_MASK | ((x) & 1) << 16)
#define SET_AM(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT18_MASK | ((x) & 1) << 18)
#define SET_NW(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT29_MASK | ((x) & 1) << 29)
#define SET_CD(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~BIT30_MASK | ((x) & 1) << 30)
#define GET_MSW()	CCPU_CR[CR_STAT] & WORD_MASK
#define SET_MSW(x)\
   (CCPU_CR[CR_STAT] = CCPU_CR[CR_STAT] & ~WORD_MASK | ((x) & WORD_MASK))

/* Current Privilege Level */
#define GET_CPL()	CCPU_CPL
#define SET_CPL(x)	CCPU_CPL = (x)

/* Current Operating Mode */
#define USE16 0
#define USE32 1

#define GET_OPERAND_SIZE()	CCPU_MODE[0]
#define GET_ADDRESS_SIZE()	CCPU_MODE[1]

#define SET_OPERAND_SIZE(x)	CCPU_MODE[0] = (x)
#define SET_ADDRESS_SIZE(x)	CCPU_MODE[1] = (x)

#define GET_POP_DISP()	CCPU_MODE[2]
#define SET_POP_DISP(x)	CCPU_MODE[2] = (x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_prot.h ===
/*[

c_prot.h

Protected Mode Support (Misc).
------------------------------

LOCAL CHAR SccsID[]="@(#)c_prot.h	1.4 02/09/94";

]*/


IMPORT VOID check_SS
                   
IPT4(
	IU16, selector,
	ISM32, privilege,
	IU32 *, descr_addr,
	CPU_DESCR *, entry

   );

IMPORT VOID get_stack_selector_from_TSS
               
IPT3(
	IU32, priv,
	IU16 *, new_ss,
	IU32 *, new_sp

   );

IMPORT VOID load_data_seg_new_privilege
       
IPT1(
	ISM32, indx

   );

IMPORT VOID validate_SS_on_stack_change
                   
IPT4(
	IU32, priv,
	IU16, selector,
	IU32 *, descr,
	CPU_DESCR *, entry

   );

IMPORT ISM32  validate_TSS
               
IPT3(
	IU16, selector,
	IU32 *, descr_addr,
	BOOL, is_switch

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_prot.c ===
/*[

c_prot.c

LOCAL CHAR SccsID[]="@(#)c_prot.c	1.7 01/19/95";

Protected Mode Support (Misc).
------------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_page.h>
#include <fault.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check selector is valid for load into SS register.                 */
/* Only invoked in protected mode.                                    */
/* Take GP if segment not valid.                                      */
/* Take SF if segment not present.                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
check_SS
       	    	    	    		                         
IFN4(
	IU16, selector,	/* (I) 16-bit selector to stack segment */
	ISM32, privilege,	/* (I) privilege level to check against */
	IU32 *, descr_addr,	/* (O) address of stack segment descriptor */
	CPU_DESCR *, entry	/* (O) the decoded descriptor */
    )


   {
   /* must be within GDT or LDT */
   if ( selector_outside_GDT_LDT(selector, descr_addr) )
      GP(selector, FAULT_CHECKSS_SELECTOR);
   
   read_descriptor_linear(*descr_addr, entry);

   /* must be writable data */
   switch ( descriptor_super_type(entry->AR) )
      {
   case EXPANDUP_WRITEABLE_DATA:
   case EXPANDDOWN_WRITEABLE_DATA:
      break;          /* good type */
   
   default:
      GP(selector, FAULT_CHECKSS_BAD_SEG_TYPE);   /* bad type */
      }

   /* access check requires RPL == DPL == privilege */
   if ( GET_SELECTOR_RPL(selector) != privilege ||
	GET_AR_DPL(entry->AR) != privilege )
      GP(selector, FAULT_CHECKSS_ACCESS);

   /* finally it must be present */
   if ( GET_AR_P(entry->AR) == NOT_PRESENT )
      SF(selector, FAULT_CHECKSS_NOTPRESENT);

   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Get SS:(E)SP for a given privilege from the TSS                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
get_stack_selector_from_TSS
       		    	    	                    
IFN3(
	IU32, priv,	/* (I) priv level for which stack is reqd */
	IU16 *, new_ss,	/* (O) SS as retrieved from TSS */
	IU32 *, new_sp	/* (O) (E)SP as retrieved from TSS */
    )


   {
   IU32 address;

   if ( GET_TR_AR_SUPER() == BUSY_TSS )
      {
      /* 286 TSS */
      switch ( priv )
	 {
      case 0: address = 0x02; break;
      case 1: address = 0x06; break;
      case 2: address = 0x0a; break;
	 }

      address += GET_TR_BASE();

      *new_sp = (IU32)spr_read_word(address);
      *new_ss = spr_read_word(address+2);
      }
   else
      {
      /* 386 TSS */
      switch ( priv )
	 {
      case 0: address = 0x04; break;
      case 1: address = 0x0c; break;
      case 2: address = 0x14; break;
	 }

      address += GET_TR_BASE();

      *new_sp = spr_read_dword(address);
      *new_ss = spr_read_word(address+4);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check a Data Segment Register (DS, ES, FS, GS) during              */
/* a Privilege Change.                                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
load_data_seg_new_privilege
       	          
IFN1(
	ISM32, indx	/* Segment Register identifier */
    )


   {
   IU16 selector;   /* selector to be examined                        */
   IU32 descr;     /* ... its associated decriptor location          */
   ISM32 dpl;         /*         ... its associated DPL                 */
   BOOL valid;      /* selector validity */

   selector = GET_SR_SELECTOR(indx);   /* take local copy */

   if ( !selector_outside_GDT_LDT(selector, &descr) )
      {
      valid = TRUE;   /* at least its in table */

      /* Type must be ok, else it would not have been loaded. */

      /* for data and non-conforming code the access check applies */
      if ( GET_SR_AR_C(indx) == 0 )
	 {
	 /* The access check is:-  DPL >= CPL and DPL >= RPL */
	 dpl = GET_SR_AR_DPL(indx);
	 if ( dpl >= GET_CPL() && dpl >= GET_SELECTOR_RPL(selector) )
	    ;   /* ok */
	 else
	    valid = FALSE;   /* fails privilege check */
	 }
      }
   else
      {
      valid = FALSE;   /* not in table */
      }
   
   if ( !valid )
      {
      /* segment can't be seen at new privilege */
      SET_SR_SELECTOR(indx, 0);
      SET_SR_AR_W(indx, 0);   /* deny write */
      SET_SR_AR_R(indx, 0);   /* deny read */

      /* the following lines were added to make the C-CPU act like the Soft-486
       * in this respect... an investigation is under way to see how the real
       * i486 behaves - this code may need to be changed in the future
       */
      SET_SR_BASE(indx, 0);
      SET_SR_LIMIT(indx, 0);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Validate a stack segment selector, during a stack change           */
/* Take #TS(selector) if not valid stack selector                     */
/* Take #SF(selector) if segment not present                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID 
validate_SS_on_stack_change
       		    	    	    		                         
IFN4(
	IU32, priv,	/* (I) privilege level to check against */
	IU16, selector,	/* (I) selector to be checked */
	IU32 *, descr,	/* (O) address of related descriptor */
	CPU_DESCR *, entry	/* (O) the decoded descriptor */
    )


   {
   if ( selector_outside_GDT_LDT(selector, descr) )
      TS(selector, FAULT_VALSS_CHG_SELECTOR);
   
   read_descriptor_linear(*descr, entry);

   /* do access check */
   if ( GET_SELECTOR_RPL(selector) != priv ||
	GET_AR_DPL(entry->AR) != priv )
      TS(selector, FAULT_VALSS_CHG_ACCESS);
   
   /* do type check */
   switch ( descriptor_super_type(entry->AR) )
      {
   case EXPANDUP_WRITEABLE_DATA:
   case EXPANDDOWN_WRITEABLE_DATA:
      break;   /* ok */
   
   default:
      TS(selector, FAULT_VALSS_CHG_BAD_SEG_TYPE);   /* wrong type */
      }

   /* finally check it is present */
   if ( GET_AR_P(entry->AR) == NOT_PRESENT )
      SF(selector, FAULT_VALSS_CHG_NOTPRESENT);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Validate TSS selector.                                             */
/* Take #GP(selector) or #TS(selector) if not valid TSS.              */
/* Take #NP(selector) if TSS not present                              */
/* Return super type of TSS decscriptor.                              */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL ISM32
validate_TSS
       	    	    	                    
IFN3(
	IU16, selector,	/* (I) selector to be checked */
	IU32 *, descr_addr,	/* (O) address of related descriptor */
	BOOL, is_switch	/* (I) if true we are in task switch */
    )


   {
   BOOL is_ok = TRUE;
   IU8 AR;
   ISM32 super;

   /* must be in GDT */
   if ( selector_outside_GDT(selector, descr_addr) )
      {
      is_ok = FALSE;
      }
   else
      {
      /* is it really an available TSS segment (is_switch false) or
	 is it really a busy TSS segment (is_switch true) */
      AR = spr_read_byte((*descr_addr)+5);
      super = descriptor_super_type((IU16)AR);
      if ( ( !is_switch &&
	     (super == AVAILABLE_TSS || super == XTND_AVAILABLE_TSS) )
	   ||
           ( is_switch &&
	     (super == BUSY_TSS || super == XTND_BUSY_TSS) ) )
	 ;   /* ok */
      else
	 is_ok = FALSE;
      }
   
   /* handle invalid TSS */
   if ( !is_ok )
      {
      if ( is_switch )
	 TS(selector, FAULT_VALTSS_SELECTOR);
      else
	 GP(selector, FAULT_VALTSS_SELECTOR);
      }

   /* must be present */
   if ( GET_AR_P(AR) == NOT_PRESENT )
      NP(selector, FAULT_VALTSS_NP);

   return super;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_seg.c ===
/*[

c_seg.c

LOCAL CHAR SccsID[]="@(#)c_seg.c	1.10 03/02/95";

Segment Register Support.
-------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>

#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_page.h>
#include <fault.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load CS, both selector and hidden cache. Selector must be valid.   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
load_CS_cache
       	    	    		                    
IFN3(
	IU16, selector,	/* (I) 16-bit selector to code segment */
	IU32, descr_addr,	/* (I) address of code segment descriptor */
	CPU_DESCR *, entry	/* (I) the decoded descriptor */
    )


   {
   if ( GET_PE() == 0 || GET_VM() == 1 )
      {
      /* Real Mode or V86 Mode */
      SET_CS_SELECTOR(selector);
      SET_CS_BASE((IU32)selector << 4);

      /* LIMIT is untouched. (cf 80386 PRM Pg14-4) */
      /*                     (cf  i486 PRM Pg22-4) */

      /* But access rights are updated */
      SET_CS_AR_W(1);     /* allow write access */
      SET_CS_AR_R(1);     /* allow read access */
      SET_CS_AR_E(0);     /* expand up */
      SET_CS_AR_C(0);     /* not conforming */
      SET_CS_AR_X(0);     /* not big (16-bit) */

      if ( GET_VM() == 1 )
	 SET_CS_AR_DPL(3);
      else
	 SET_CS_AR_DPL(0);
      }
   else
      {
      /* Protected Mode */

      /* show segment has been accessed (i486 only writes if changed) */
#ifdef	SPC486
      if ((entry->AR & ACCESSED) == 0)
#endif	/* SPC486 */
	 spr_write_byte(descr_addr+5, (IU8)entry->AR | ACCESSED);
      entry->AR |= ACCESSED;

      /* the visible bit */
      SET_CS_SELECTOR(selector);

      /* load hidden cache */
      SET_CS_BASE(entry->base);
      SET_CS_LIMIT(entry->limit);
			      /* load attributes from descriptor */
      SET_CS_AR_DPL(GET_AR_DPL(entry->AR));
      SET_CS_AR_R(GET_AR_R(entry->AR));
      SET_CS_AR_C(GET_AR_C(entry->AR));
      SET_CS_AR_X(GET_AR_X(entry->AR));

      SET_CS_AR_E(0);   /* expand up */
      SET_CS_AR_W(0);   /* deny write */
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load SS, both selector and hidden cache. Selector must be valid.   */
/* Only invoked in protected mode.                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
load_SS_cache
       	    	    		                    
IFN3(
	IU16, selector,	/* (I) 16-bit selector to stack segment */
	IU32, descr_addr,	/* (I) address of stack segment descriptor */
	CPU_DESCR *, entry	/* (I) the decoded descriptor */
    )


   {
   /* show segment has been accessed (i486 only writes if changed) */
#ifdef	SPC486
   if ((entry->AR & ACCESSED) == 0)
#endif	/* SPC486 */
      spr_write_byte(descr_addr+5, (IU8)entry->AR | ACCESSED);
   entry->AR |= ACCESSED;

   /* the visible bit */
   SET_SS_SELECTOR(selector);

   /* load hidden cache */
   SET_SS_BASE(entry->base);
   SET_SS_LIMIT(entry->limit);
			   /* load attributes from descriptor */
   SET_SS_AR_DPL(GET_AR_DPL(entry->AR));
   SET_SS_AR_E(GET_AR_E(entry->AR));
   SET_SS_AR_X(GET_AR_X(entry->AR));

   SET_SS_AR_W(1);   /* must be writeable */
   SET_SS_AR_R(1);   /* must be readable */
   SET_SS_AR_C(0);   /* not conforming */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load CS selector.                                                  */
/* Take #GP if segment not valid                                      */
/* Take #NP if segment not present                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
load_code_seg
                 
IFN1(
	IU16, new_cs
    )


   {
   IU32 cs_descr_addr;	/* code segment descriptor address */
   CPU_DESCR cs_entry;	/* code segment descriptor entry */

   /*
      Given that the CPU should be started from a valid state, we
      check CS selectors as if a far call to the same privilege
      level was being generated. This is in effect saying yes the
      CS could have been loaded by a valid Intel instruction.
      This logic may have to be revised if strange LOADALL usage is
      found.
    */

   if ( GET_PE() == 0 || GET_VM() == 1 )
      {
      /* Real Mode or V86 Mode */
      load_CS_cache(new_cs, (IU32)0, (CPU_DESCR *)0);
      }
   else
      {
      /* Protected Mode */

      if ( selector_outside_GDT_LDT(new_cs, &cs_descr_addr) )
	 GP(new_cs, FAULT_LOADCS_SELECTOR);

      /* load descriptor */
      read_descriptor_linear(cs_descr_addr, &cs_entry);

      /* validate possible types of target */
      switch ( descriptor_super_type(cs_entry.AR) )
	 {
      case CONFORM_NOREAD_CODE:
      case CONFORM_READABLE_CODE:
	 /* access check requires DPL <= CPL */
	 if ( GET_AR_DPL(cs_entry.AR) > GET_CPL() )
	    GP(new_cs, FAULT_LOADCS_ACCESS_1);

	 /* it must be present */
	 if ( GET_AR_P(cs_entry.AR) == NOT_PRESENT )
	    NP(new_cs, FAULT_LOADCS_NOTPRESENT_1);
	 break;

      case NONCONFORM_NOREAD_CODE:
      case NONCONFORM_READABLE_CODE:
	 /* access check requires RPL <= CPL and DPL == CPL */
	 if ( GET_SELECTOR_RPL(new_cs) > GET_CPL() ||
	      GET_AR_DPL(cs_entry.AR) != GET_CPL() )
	    GP(new_cs, FAULT_LOADCS_ACCESS_2);

	 /* it must be present */
	 if ( GET_AR_P(cs_entry.AR) == NOT_PRESENT )
	    NP(new_cs, FAULT_LOADCS_NOTPRESENT_2);
	 break;

      default:
	 GP(new_cs, FAULT_LOADCS_BAD_SEG_TYPE);
	 }

      /* stamp new selector with CPL */
      SET_SELECTOR_RPL(new_cs, GET_CPL());

      load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load A Data Segment Register. (DS, ES, FS, GS)                     */
/* Take #GP if segment not valid                                      */
/* Take #NP if segment not present                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
load_data_seg
                          
IFN2(
	ISM32, indx,
	IU16, selector
    )


   {
   IU32 descr_addr;
   CPU_DESCR entry;
   ISM32 super;
   ISM32 dpl;
   BOOL is_data;

   if ( GET_PE() == 0 || GET_VM() == 1 )
      {
      /* Real Mode or V86 Mode */
      SET_SR_SELECTOR(indx, selector);
      SET_SR_BASE(indx, (IU32)selector << 4);
      }
   else
      {
      /* Protected Mode */
      if ( selector_is_null(selector) )
	 {
	 /* load is allowed - but later access will fail
	  * Since the program can not see the internal changes
	  * performed to achieve this, we make the behaviour
	  * match the easiest implementation in the A4CPU
	  */
	 SET_SR_SELECTOR(indx, selector);

	 /* the following lines were added to make the C-CPU behave like
	  * the Soft 486 CPU - an investigation is being made to see if this
	  * behaviour corresponds with the real i486 - this code may have to
	  * change.
	  */
	 SET_SR_BASE(indx, 0);
	 SET_SR_LIMIT(indx, 0);
         SET_SR_AR_W(indx, 0);
         SET_SR_AR_R(indx, 0);
	 }
      else
	 {
	 if ( selector_outside_GDT_LDT(selector, &descr_addr) )
	    GP(selector, FAULT_LOADDS_SELECTOR);

	 read_descriptor_linear(descr_addr, &entry);

	 /* check type */
	 switch ( super = descriptor_super_type(entry.AR) )
	    {
	 case CONFORM_READABLE_CODE:
	 case NONCONFORM_READABLE_CODE:
	    is_data = FALSE;
	    break;

	 case EXPANDUP_READONLY_DATA:
	 case EXPANDUP_WRITEABLE_DATA:
	 case EXPANDDOWN_READONLY_DATA:
	 case EXPANDDOWN_WRITEABLE_DATA:
	    is_data = TRUE;
	    break;
	 
	 default:
	    GP(selector, FAULT_LOADDS_BAD_SEG_TYPE);	/* bad type */
	    }

	 /* for data and non-conforming code the access check applies */
	 if ( super != CONFORM_READABLE_CODE )
	    {
	    /* access check requires CPL <= DPL and RPL <= DPL */
	    dpl = GET_AR_DPL(entry.AR);
	    if ( GET_CPL() > dpl || GET_SELECTOR_RPL(selector) > dpl )
	       GP(selector, FAULT_LOADDS_ACCESS);
	    }

	 /* must be present */
	 if ( GET_AR_P(entry.AR) == NOT_PRESENT )
	    NP(selector, FAULT_LOADDS_NOTPRESENT);

	 /* show segment has been accessed (i486 only writes if changed) */
#ifdef	SPC486
	 if ((entry.AR & ACCESSED) == 0)
#endif	/* SPC486 */
	    spr_write_byte(descr_addr+5, (IU8)entry.AR | ACCESSED);
	 entry.AR |= ACCESSED;

	 /* OK - load up */

	 /* the visible bit */
	 SET_SR_SELECTOR(indx, selector);

	 /* load hidden cache */
	 SET_SR_BASE(indx, entry.base);
	 SET_SR_LIMIT(indx, entry.limit);
				 /* load attributes from descriptor */
	 SET_SR_AR_DPL(indx, GET_AR_DPL(entry.AR));

	 if ( is_data )
	    {
	    SET_SR_AR_W(indx, GET_AR_W(entry.AR));
	    SET_SR_AR_E(indx, GET_AR_E(entry.AR));
	    SET_SR_AR_C(indx, 0);   /* not conforming */
	    }
	 else
	    {
	    SET_SR_AR_C(indx, GET_AR_C(entry.AR));
	    SET_SR_AR_W(indx, 0);   /* deny write access */
	    SET_SR_AR_E(indx, 0);   /* expand up */
	    }

	 SET_SR_AR_X(indx, GET_AR_X(entry.AR));

	 SET_SR_AR_R(indx, 1);   /* must be readable */
	 }
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load Pseudo Descriptor Semantics for Real Mode or V86 Mode.        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
load_pseudo_descr
       	          
IFN1(
	ISM32, index	/* index to segment register */
    )


   {
   SET_SR_LIMIT(index, 0xffff);
   SET_SR_AR_W(index, 1);     /* allow write access */
   SET_SR_AR_R(index, 1);     /* allow read access */
   SET_SR_AR_E(index, 0);     /* expand up */
   SET_SR_AR_C(index, 0);     /* not conforming */
   SET_SR_AR_X(index, 0);     /* not big (16-bit) */

   if ( GET_VM() == 1 )
      SET_SR_AR_DPL(index, 3);
   else
      SET_SR_AR_DPL(index, 0);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load Stack Segment Register. (SS)                                  */
/* Take #GP if segment not valid                                      */
/* Take #SF if segment not present                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
load_stack_seg
                 
IFN1(
	IU16, selector
    )


   {
   IU32 descr_addr;
   CPU_DESCR entry;

   if ( GET_PE() == 0 || GET_VM() == 1 )
      {
      /* Real Mode or V86 Mode */
      SET_SS_SELECTOR(selector);
      SET_SS_BASE((IU32)selector << 4);
      }
   else
      {
      /* Protected Mode */
      check_SS(selector, (ISM32)GET_CPL(), &descr_addr, &entry);
      load_SS_cache(selector, descr_addr, &entry);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_seg.h ===
/*[

c_seg.h

LOCAL CHAR SccsID[]="@(#)c_seg.h	1.4 02/09/94";

Segment Register Support.
-------------------------

]*/


IMPORT VOID load_CS_cache
               
IPT3(
	IU16, selector,
	IU32, descr_addr,
	CPU_DESCR *, entry

   );

IMPORT VOID load_SS_cache
               
IPT3(
	IU16, selector,
	IU32, descr_addr,
	CPU_DESCR *, entry

   );

IMPORT VOID load_code_seg
       
IPT1(
	IU16, selector

   );

IMPORT VOID load_data_seg
           
IPT2(
	ISM32, index,
	IU16, selector

   );

IMPORT VOID load_pseudo_descr
       
IPT1(
	ISM32, index

   );

IMPORT VOID load_stack_seg
       
IPT1(
	IU16, selector

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_reg.c ===
/*[

c_reg.c

LOCAL CHAR SccsID[]="@(#)c_reg.c	1.24 02/13/95 Copyright Insignia Solutions Ltd.";

Provide External Interface to CPU Registers.
--------------------------------------------

]*/

#include <insignia.h>

#include <host_def.h>

#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
			/* NB our own interface is actually defined
			   in 'cpu.h', however we can not include it
			   here as it would redefine all the internal
			   macros. This is the only file were the
			   internal register definitions meet the
			   external definitions. Obviously the external
			   definitions here and in 'cpu.h' must aggree
			   with each other. We just can't get the
			   compiler to prove it for us! */
#include <c_xtrn.h>
#include <mov.h>

#include <Fpu_c.h>
#include <Pigger_c.h>
#ifdef PIG
#include <gdpvar.h>
#define AR_FIXUP				\
{						\
	if (GLOBAL_AR_FixupWanted)		\
	{					\
		if (GET_PE()==0)		\
			return 0x93;		\
		if (GET_VM()!=0)		\
			return 0xF3;		\
	}					\
}
#else /* PIG */
#define	AR_FIXUP
#endif /* PIG */

/*
   Prototype our internal functions.
 */
LOCAL IU16 get_seg_ar IPT1(ISM32, indx);

LOCAL VOID set_seg_ar IPT2(ISM32, indx, IU16, val);

LOCAL IU32 get_seg_limit IPT1(ISM32, indx);

LOCAL VOID set_seg_limit IPT2(ISM32, indx, IU32, val);

/*
   =====================================================================
   INTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Get segment register access rights.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL IU16
get_seg_ar
       	          
IFN1(
	ISM32, indx	/* index to segment register */
    )


   {
   IU16 ar;

   /*
      Note we return only the essentials that describe the current
      semantics we are applying to the segment, not necessarily the
      access rights actually loaded. However the value provided may be
      used to restore the segment register via the associated 'set'
      function.

      We don't provide G or AVL. P and A are assumed to be set.

      We do provide DPL, X(B), E, W for DATA(SS,DS,ES,FS,GS) segments.
      We do provide DPL, X(D), C, R for CODE(CS) or DATA(SS,DS,ES,FS,GS)
      segments.
    */

   if ( GET_SR_AR_W(indx) == 0 && GET_SR_AR_R(indx) == 0 && indx != CS_REG )
      return (IU16)0;   /* Invalid */

   /* Conforming attribute or CS_REG with non writeable segment
      means CODE segment */
   if ( GET_SR_AR_C(indx) || (indx == CS_REG && !GET_SR_AR_W(indx)) )
      {
      /* Set Bits 4 and 3 and output C and R attributes */
      ar = BIT4_MASK | BIT3_MASK |
	   GET_SR_AR_C(indx) << 2 |
	   GET_SR_AR_R(indx) << 1;
      }
   else   /* DATA segment */
      {
      /* Set Bit 4 and output E and W attributes */
      ar = BIT4_MASK |
	   GET_SR_AR_E(indx) << 2 |
	   GET_SR_AR_W(indx) << 1;
      }

   /* Add in DPL and X attributes */
   ar = ar | GET_SR_AR_DPL(indx) << 5 | GET_SR_AR_X(indx) << 14;

   /* Add in P and A (always set) */
   ar = ar | BIT7_MASK | BIT0_MASK;

   return ar;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set segment register access rights.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
set_seg_ar
       	                   
IFN2(
	ISM32, indx,	/* index to segment register */
	IU16, val
    )


   {
   /*
      Note we expect to be given an access rights similar to the one
      provided by the get_seg_ar() function. We extract the essential
      information from it into our internal variables.

      We ignore P and A, and Bit 4.

      We use DPL, X(B), E, W for CODE(CS) or DATA(SS,DS,ES,FS,GS)
      segments.
      We use DPL, X(D), C, R for CODE(CS) segments.
    */

   if ( val == 0x0 )
      {
      /* Invalid */
      SET_SR_AR_R(indx, 0);   /* !read */
      SET_SR_AR_W(indx, 0);   /* !write */
      return;
      }

   SET_SR_AR_X(indx, GET_AR_X(val));
   SET_SR_AR_DPL(indx, GET_AR_DPL(val));

   if ( val & BIT3_MASK )
      {
      /* CODE segment */
      SET_SR_AR_W(indx, 0);   /* !write */
      SET_SR_AR_E(indx, 0);   /* expand up */
      SET_SR_AR_R(indx, GET_AR_R(val));
      SET_SR_AR_C(indx, GET_AR_C(val));
      }
   else
      {
      /* DATA segment */
      SET_SR_AR_R(indx, 1);   /* readable */
      SET_SR_AR_C(indx, 0);   /* !conform */
      SET_SR_AR_W(indx, GET_AR_W(val));
      SET_SR_AR_E(indx, GET_AR_E(val));
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Get segment register limit.                                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL IU32
get_seg_limit
       	          
IFN1(
	ISM32, indx	/* index to segment register */
    )


   {
   /* Note limit already expanded to take account of G bit */
   return GET_SR_LIMIT(indx);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set segment register limit.                                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
set_seg_limit
       	    	               
IFN2(
	ISM32, indx,	/* index to segment register */
	IU32, val	/* new value for limit */
    )


   {
   /* Note limit assumed already expanded to take account of G bit */
   SET_SR_LIMIT(indx, val);
   }


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Byte Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL IU8
c_getAL()
   {
   return (IU8)GET_AL();
   }
   
GLOBAL IU8
c_getCL()
   {
   return (IU8)GET_CL();
   }
   
GLOBAL IU8
c_getDL()
   {
   return (IU8)GET_DL();
   }
   
GLOBAL IU8
c_getBL()
   {
   return (IU8)GET_BL();
   }
   
GLOBAL IU8
c_getAH()
   {
   return (IU8)GET_AH();
   }
   
GLOBAL IU8
c_getCH()
   {
   return (IU8)GET_CH();
   }
   
GLOBAL IU8
c_getDH()
   {
   return (IU8)GET_DH();
   }
   
GLOBAL IU8
c_getBH()
   {
   return (IU8)GET_BH();
   }
   
GLOBAL VOID
c_setAL
                 
IFN1(
	IU8, val
    )


   {
   SET_AL(val);
   }
   
GLOBAL VOID
c_setCL
                 
IFN1(
	IU8, val
    )


   {
   SET_CL(val);
   }
   
GLOBAL VOID
c_setDL
                 
IFN1(
	IU8, val
    )


   {
   SET_DL(val);
   }
   
GLOBAL VOID
c_setBL
                 
IFN1(
	IU8, val
    )


   {
   SET_BL(val);
   }
   
GLOBAL VOID
c_setAH
                 
IFN1(
	IU8, val
    )


   {
   SET_AH(val);
   }
   
GLOBAL VOID
c_setCH
                 
IFN1(
	IU8, val
    )


   {
   SET_CH(val);
   }
   
GLOBAL VOID
c_setDH
                 
IFN1(
	IU8, val
    )


   {
   SET_DH(val);
   }
   
GLOBAL VOID
c_setBH
                 
IFN1(
	IU8, val
    )


   {
   SET_BH(val);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Word Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL IU16
c_getAX()
   {
   return (IU16)GET_AX();
   }

GLOBAL IU16
c_getCX()
   {
   return (IU16)GET_CX();
   }

GLOBAL IU16
c_getDX()
   {
   return (IU16)GET_DX();
   }

GLOBAL IU16
c_getBX()
   {
   return (IU16)GET_BX();
   }

GLOBAL IU16
c_getSP()
   {
   return (IU16)GET_SP();
   }

GLOBAL IU16
c_getBP()
   {
   return (IU16)GET_BP();
   }

GLOBAL IU16
c_getSI()
   {
   return (IU16)GET_SI();
   }

GLOBAL IU16
c_getDI()
   {
   return (IU16)GET_DI();
   }

GLOBAL IU32
c_getEIP()
   {
   return (IU32)GET_EIP();
   }

GLOBAL IU16
c_getIP()
   {
   return (IU16)GET_EIP();
   }

GLOBAL VOID
c_setAX
                 
IFN1(
	IU16, val
    )


   {
   SET_AX(val);
   }

GLOBAL VOID
c_setCX
                 
IFN1(
	IU16, val
    )


   {
   SET_CX(val);
   }

GLOBAL VOID
c_setDX
                 
IFN1(
	IU16, val
    )


   {
   SET_DX(val);
   }

GLOBAL VOID
c_setBX
                 
IFN1(
	IU16, val
    )


   {
   SET_BX(val);
   }

GLOBAL VOID
c_setSP
                 
IFN1(
	IU16, val
    )


   {
   SET_SP(val);
   }

GLOBAL VOID
c_setBP
                 
IFN1(
	IU16, val
    )


   {
   SET_BP(val);
   }

GLOBAL VOID
c_setSI
                 
IFN1(
	IU16, val
    )


   {
   SET_SI(val);
   }

GLOBAL VOID
c_setDI
                 
IFN1(
	IU16, val
    )


   {
   SET_DI(val);
   }

GLOBAL VOID
c_setEIP
                 
IFN1(
	IU32, val
    )


   {
   SET_EIP(val);
   }

GLOBAL VOID
c_setIP
                 
IFN1(
	IU16, val
    )


   {
   SET_EIP(val);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Double Word Registers.                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL IU32
c_getEAX()
   {
   return (IU32)GET_EAX();
   }

GLOBAL IU32
c_getECX()
   {
   return (IU32)GET_ECX();
   }

GLOBAL IU32
c_getEDX()
   {
   return (IU32)GET_EDX();
   }

GLOBAL IU32
c_getEBX()
   {
   return (IU32)GET_EBX();
   }

GLOBAL IU32
c_getESP()
   {
   return (IU32)GET_ESP();
   }

GLOBAL IU32
c_getEBP()
   {
   return (IU32)GET_EBP();
   }

GLOBAL IU32
c_getESI()
   {
   return (IU32)GET_ESI();
   }

GLOBAL IU32
c_getEDI()
   {
   return (IU32)GET_EDI();
   }

GLOBAL VOID
c_setEAX
                 
IFN1(
	IU32, val
    )


   {
   SET_EAX(val);
   }

GLOBAL VOID
c_setECX
                 
IFN1(
	IU32, val
    )


   {
   SET_ECX(val);
   }

GLOBAL VOID
c_setEDX
                 
IFN1(
	IU32, val
    )


   {
   SET_EDX(val);
   }

GLOBAL VOID
c_setEBX
                 
IFN1(
	IU32, val
    )


   {
   SET_EBX(val);
   }

GLOBAL VOID
c_setESP
                 
IFN1(
	IU32, val
    )


   {
   SET_ESP(val);
   }

GLOBAL VOID
c_setEBP
                 
IFN1(
	IU32, val
    )


   {
   SET_EBP(val);
   }

GLOBAL VOID
c_setESI
                 
IFN1(
	IU32, val
    )


   {
   SET_ESI(val);
   }

GLOBAL VOID
c_setEDI
                 
IFN1(
	IU32, val
    )


   {
   SET_EDI(val);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Segment Registers.                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL IU16
c_getES()
   {
   return (IU16)GET_ES_SELECTOR();
   }

GLOBAL IU16
c_getCS()
   {
   return (IU16)GET_CS_SELECTOR();
   }

GLOBAL IU16
c_getSS()
   {
   return (IU16)GET_SS_SELECTOR();
   }

GLOBAL IU16
c_getDS()
   {
   return (IU16)GET_DS_SELECTOR();
   }

GLOBAL IU16
c_getFS()
   {
   return (IU16)GET_FS_SELECTOR();
   }

GLOBAL IU16
c_getGS()
   {
   return (IU16)GET_GS_SELECTOR();
   }

GLOBAL ISM32
c_setES
                 
IFN1(
	IU16, val
    )


   {
   return call_cpu_function((CALL_CPU *)load_data_seg, TYPE_I_W, ES_REG, val);
   }

GLOBAL ISM32
c_setCS
                 
IFN1(
	IU16, val
    )


   {
   return call_cpu_function((CALL_CPU *)load_code_seg, TYPE_W, CS_REG, val);
   }

GLOBAL ISM32
c_setSS
                 
IFN1(
	IU16, val
    )


   {
   return call_cpu_function((CALL_CPU *)load_stack_seg, TYPE_W, SS_REG, val);
   }

GLOBAL ISM32
c_setDS
                 
IFN1(
	IU16, val
    )


   {
   return call_cpu_function((CALL_CPU *)load_data_seg, TYPE_I_W, DS_REG, val);
   }

GLOBAL ISM32
c_setFS
                 
IFN1(
	IU16, val
    )


   {
   return call_cpu_function((CALL_CPU *)load_data_seg, TYPE_I_W, FS_REG, val);
   }

GLOBAL ISM32
c_setGS
                 
IFN1(
	IU16, val
    )


   {
   return call_cpu_function((CALL_CPU *)load_data_seg, TYPE_I_W, GS_REG, val);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Full(Private) Segment Registers.                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL IU16
c_getES_SELECTOR()
   {
   return (IU16)GET_ES_SELECTOR();
   }

GLOBAL IU16
c_getCS_SELECTOR()
   {
   return (IU16)GET_CS_SELECTOR();
   }

GLOBAL IU16
c_getSS_SELECTOR()
   {
   return (IU16)GET_SS_SELECTOR();
   }

GLOBAL IU16
c_getDS_SELECTOR()
   {
   return (IU16)GET_DS_SELECTOR();
   }

GLOBAL IU16
c_getFS_SELECTOR()
   {
   return (IU16)GET_FS_SELECTOR();
   }

GLOBAL IU16
c_getGS_SELECTOR()
   {
   return (IU16)GET_GS_SELECTOR();
   }

GLOBAL IU32
c_getES_BASE()
   {
   return (IU32)GET_ES_BASE();
   }

GLOBAL IU32
c_getCS_BASE()
   {
   return (IU32)GET_CS_BASE();
   }

GLOBAL IU32
c_getSS_BASE()
   {
   return (IU32)GET_SS_BASE();
   }

GLOBAL IU32
c_getDS_BASE()
   {
   return (IU32)GET_DS_BASE();
   }

GLOBAL IU32
c_getFS_BASE()
   {
   return (IU32)GET_FS_BASE();
   }

GLOBAL IU32
c_getGS_BASE()
   {
   return (IU32)GET_GS_BASE();
   }

GLOBAL IU32
c_getES_LIMIT()
   {
   return (IU32)get_seg_limit(ES_REG);
   }

GLOBAL IU32
c_getCS_LIMIT()
   {
   return (IU32)get_seg_limit(CS_REG);
   }

GLOBAL IU32
c_getSS_LIMIT()
   {
   return (IU32)get_seg_limit(SS_REG);
   }

GLOBAL IU32
c_getDS_LIMIT()
   {
   return (IU32)get_seg_limit(DS_REG);
   }

GLOBAL IU32
c_getFS_LIMIT()
   {
   return (IU32)get_seg_limit(FS_REG);
   }

GLOBAL IU32
c_getGS_LIMIT()
   {
   return (IU32)get_seg_limit(GS_REG);
   }

GLOBAL IU16
c_getES_AR()
   {
   AR_FIXUP;
   return (IU16)get_seg_ar(ES_REG);
   }

GLOBAL IU16
c_getCS_AR()
   {
   AR_FIXUP;
   return (IU16)get_seg_ar(CS_REG);
   }

GLOBAL IU16
c_getSS_AR()
   {
   AR_FIXUP;
   return (IU16)get_seg_ar(SS_REG);
   }

GLOBAL IU16
c_getDS_AR()
   {
   AR_FIXUP;
   return (IU16)get_seg_ar(DS_REG);
   }

GLOBAL IU16
c_getFS_AR()
   {
   AR_FIXUP;
   return (IU16)get_seg_ar(FS_REG);
   }

GLOBAL IU16
c_getGS_AR()
   {
   AR_FIXUP;
   return (IU16)get_seg_ar(GS_REG);
   }

GLOBAL VOID
c_setES_SELECTOR
                 
IFN1(
	IU16, val
    )


   {
   SET_ES_SELECTOR(val);
   }

GLOBAL VOID
c_setCS_SELECTOR
                 
IFN1(
	IU16, val
    )


   {
   SET_CS_SELECTOR(val);
   }

GLOBAL VOID
c_setSS_SELECTOR
                 
IFN1(
	IU16, val
    )


   {
   SET_SS_SELECTOR(val);
   }

GLOBAL VOID
c_setDS_SELECTOR
                 
IFN1(
	IU16, val
    )


   {
   SET_DS_SELECTOR(val);
   }

GLOBAL VOID
c_setFS_SELECTOR
                 
IFN1(
	IU16, val
    )


   {
   SET_FS_SELECTOR(val);
   }

GLOBAL VOID
c_setGS_SELECTOR
                 
IFN1(
	IU16, val
    )


   {
   SET_GS_SELECTOR(val);
   }

GLOBAL VOID
c_setES_BASE_LIMIT_AR

IFN3(
	IU32, base,
	IU32, limit,
	IU16, ar
    )
   {
   SET_ES_BASE(base);
   set_seg_limit(ES_REG, limit);
   set_seg_ar(ES_REG, ar);
   }

GLOBAL VOID
c_setCS_BASE_LIMIT_AR

IFN3(
	IU32, base,
	IU32, limit,
	IU16, ar
    )
   {
   SET_CS_BASE(base);
   set_seg_limit(CS_REG, limit);
   set_seg_ar(CS_REG, ar);
   }

GLOBAL VOID
c_setSS_BASE_LIMIT_AR

IFN3(
	IU32, base,
	IU32, limit,
	IU16, ar
    )
   {
   SET_SS_BASE(base);
   set_seg_limit(SS_REG, limit);
   set_seg_ar(SS_REG, ar);
   }

GLOBAL VOID
c_setDS_BASE_LIMIT_AR
                 
IFN3(
	IU32, base,
	IU32, limit,
	IU16, ar
    )
   {
   SET_DS_BASE(base);
   set_seg_limit(DS_REG, limit);
   set_seg_ar(DS_REG, ar);
   }

GLOBAL VOID
c_setFS_BASE_LIMIT_AR

IFN3(
	IU32, base,
	IU32, limit,
	IU16, ar
    )
   {
   SET_FS_BASE(base);
   set_seg_limit(FS_REG, limit);
   set_seg_ar(FS_REG, ar);
   }

GLOBAL VOID
c_setGS_BASE_LIMIT_AR
                 
IFN3(
	IU32, base,
	IU32, limit,
	IU16, ar
    )
   {
   SET_GS_BASE(base);
   set_seg_limit(GS_REG, limit);
   set_seg_ar(GS_REG, ar);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Flags.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL ISM32
c_getAF()
   {
   return (ISM32)GET_AF();
   }

GLOBAL ISM32
c_getCF()
   {
   return (ISM32)GET_CF();
   }

GLOBAL ISM32
c_getDF()
   {
   return (ISM32)GET_DF();
   }

GLOBAL ISM32
c_getIF()
   {
   return (ISM32)GET_IF();
   }

GLOBAL ISM32
c_getOF()
   {
   return (ISM32)GET_OF();
   }

GLOBAL ISM32
c_getPF()
   {
   return (ISM32)GET_PF();
   }

GLOBAL ISM32
c_getSF()
   {
   return (ISM32)GET_SF();
   }

GLOBAL ISM32
c_getTF()
   {
   return (ISM32)GET_TF();
   }

GLOBAL ISM32
c_getZF()
   {
   return (ISM32)GET_ZF();
   }

GLOBAL ISM32
c_getIOPL()
   {
   return (ISM32)GET_IOPL();
   }

GLOBAL ISM32
c_getNT()
   {
   return (ISM32)GET_NT();
   }

GLOBAL ISM32
c_getRF()
   {
   return (ISM32)GET_RF();
   }

GLOBAL ISM32
c_getVM()
   {
   return (ISM32)GET_VM();
   }

#ifdef	SPC486
GLOBAL ISM32
c_getAC()
   {
   return (ISM32)GET_AC();
   }

GLOBAL ISM32
c_getET()
   {
   return (ISM32)GET_ET();
   }

GLOBAL ISM32
c_getNE()
   {
   return (ISM32)GET_NE();
   }

GLOBAL ISM32
c_getWP()
   {
   return (ISM32)GET_WP();
   }

GLOBAL ISM32
c_getAM()
   {
   return (ISM32)GET_AM();
   }

GLOBAL ISM32
c_getNW()
   {
   return (ISM32)GET_NW();
   }

GLOBAL ISM32
c_getCD()
   {
   return (ISM32)GET_CD();
   }
#endif	/* SPC486 */

GLOBAL IU16
c_getSTATUS()
   {
   return (IU16)getFLAGS();
   }

GLOBAL VOID
c_setAF
                 
IFN1(
	ISM32, val
    )


   {
   SET_AF(val);
   }

GLOBAL VOID
c_setCF
                 
IFN1(
	ISM32, val
    )


   {
   SET_CF(val);
   }

GLOBAL VOID
c_setDF
                 
IFN1(
	ISM32, val
    )


   {
   SET_DF(val);
   }

GLOBAL VOID
c_setIF
                 
IFN1(
	ISM32, val
    )


   {
   SET_IF(val);
   }

GLOBAL VOID
c_setOF
                 
IFN1(
	ISM32, val
    )


   {
   SET_OF(val);
   }

GLOBAL VOID
c_setPF
                 
IFN1(
	ISM32, val
    )


   {
   SET_PF(val);
   }

GLOBAL VOID
c_setSF
                 
IFN1(
	ISM32, val
    )


   {
   SET_SF(val);
   }

GLOBAL VOID
c_setTF
                 
IFN1(
	ISM32, val
    )


   {
   SET_TF(val);
   }

GLOBAL VOID
c_setZF
                 
IFN1(
	ISM32, val
    )


   {
   SET_ZF(val);
   }

GLOBAL VOID
c_setIOPL
                 
IFN1(
	ISM32, val
    )


   {
   SET_IOPL(val);
   }

GLOBAL VOID
c_setNT
                 
IFN1(
	ISM32, val
    )


   {
   SET_NT(val);
   }

GLOBAL VOID
c_setRF
                 
IFN1(
	ISM32, val
    )


   {
   SET_RF(val);
   }

GLOBAL VOID
c_setVM
                 
IFN1(
	ISM32, val
    )


   {
   SET_VM(val);
   }



#ifdef	SPC486
GLOBAL VOID
c_setAC
                 
IFN1(
	ISM32, val
    )


   {
   SET_AC(val);
   }
#endif	/* SPC486 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Control Registers.                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL ISM32
c_getPE()
   {
   return (ISM32)GET_PE();
   }

GLOBAL ISM32
c_getMP()
   {
   return (ISM32)GET_MP();
   }

GLOBAL ISM32
c_getEM()
   {
   return (ISM32)GET_EM();
   }

GLOBAL ISM32
c_getTS()
   {
   return (ISM32)GET_TS();
   }

GLOBAL ISM32
c_getPG()
   {
   return (ISM32)GET_PG();
   }

GLOBAL IU16
c_getMSW()
   {
   return (IU16)GET_MSW();
   }

GLOBAL IU32
c_getCR0
IFN0()
   {
   return (IU32)GET_CR(0);
   }

GLOBAL IU32
c_getCR2
IFN0()
   {
   return (IU32)GET_CR(2);
   }

GLOBAL IU32
c_getCR3
IFN0()
   {
   return (IU32)GET_CR(3);
   }

GLOBAL VOID
c_setPE
                 
IFN1(
	ISM32, val
    )


   {
   SET_PE(val);
   }

GLOBAL VOID
c_setMP
                 
IFN1(
	ISM32, val
    )


   {
   SET_MP(val);
   }

GLOBAL VOID
c_setEM
                 
IFN1(
	ISM32, val
    )


   {
   SET_EM(val);
   }

GLOBAL VOID
c_setTS
                 
IFN1(
	ISM32, val
    )


   {
   SET_TS(val);
   }

GLOBAL VOID
c_setET
                 
IFN1(
	ISM32, val
    )


   {
   /* Quietly ignore outside interference. Once set at RESET
      time ET remains unchanged. */
   UNUSED(val);
   }

#ifdef	SPC486
GLOBAL VOID
c_setNE
                 
IFN1(
	ISM32, val
    )


   {
   SET_NE(val);
   }

GLOBAL VOID
c_setWP
                 
IFN1(
	ISM32, val
    )


   {
   SET_WP(val);
   }

GLOBAL VOID
c_setAM
                 
IFN1(
	ISM32, val
    )


   {
   SET_AM(val);
   }

GLOBAL VOID
c_setNW
                 
IFN1(
	ISM32, val
    )


   {
   SET_NW(val);
   }

GLOBAL VOID
c_setCD
                 
IFN1(
	ISM32, val
    )


   {
   SET_CD(val);
   }
#endif	/* SPC486 */

GLOBAL VOID
c_setPG
                 
IFN1(
	ISM32, val
    )


   {
   SET_PG(val);
   }

GLOBAL VOID
c_setMSW
                 
IFN1(
	IU16, val
    )


   {
   IU32 keep_et;
   /*
      Does not allow ET to be changed!
      Ideally this external interface should be removed.
    */
   keep_et = GET_ET();
   SET_MSW(val);
   SET_ET(keep_et);
   MOV_CR(0, (IU32)((GET_CR(0)&0xFFFF0000) | ((IU32)val)));
   }

GLOBAL VOID
c_setCR0
IFN1(
	IU32, val
    )
   {
	   MOV_CR(0, (IU32)val);
   }

/* CR1 is reserved on the 486 */

GLOBAL VOID
c_setCR2
IFN1(
	IU32, val
    )
   {
	   MOV_CR(2, (IU32)val);
   }

GLOBAL VOID
c_setCR3
IFN1(
	IU32, val
    )
   {
	   MOV_CR(3, (IU32)val);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Descriptor Registers.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL IU32
c_getGDT_BASE()
   {
   return (IU32)GET_GDT_BASE();
   }

GLOBAL IU16
c_getGDT_LIMIT()
   {
   return (IU16)GET_GDT_LIMIT();
   }

GLOBAL IU32
c_getIDT_BASE()
   {
   return (IU32)GET_IDT_BASE();
   }

GLOBAL IU16
c_getIDT_LIMIT()
   {
   return (IU16)GET_IDT_LIMIT();
   }

GLOBAL IU16
c_getLDT_SELECTOR()
   {
   return (IU16)GET_LDT_SELECTOR();
   }

GLOBAL IU32
c_getLDT_BASE()
   {
   return (IU32)GET_LDT_BASE();
   }

GLOBAL IU32
c_getLDT_LIMIT()
   {
   return (IU32)GET_LDT_LIMIT();
   }

GLOBAL IU16
c_getTR_SELECTOR()
   {
   return (IU16)GET_TR_SELECTOR();
   }

GLOBAL IU32
c_getTR_BASE()
   {
   return (IU32)GET_TR_BASE();
   }

GLOBAL IU32
c_getTR_LIMIT()
   {
   return (IU32)GET_TR_LIMIT();
   }

GLOBAL IU16
c_getTR_AR()
   {
   return (IU16)GET_TR_AR_SUPER();
   }

GLOBAL VOID
c_setGDT_BASE_LIMIT
                 
IFN2(
	IU32, base,
	IU16, limit
    )


   {
   SET_GDT_BASE(base);
   SET_GDT_LIMIT(limit);
   }

GLOBAL VOID
c_setIDT_BASE_LIMIT
                 
IFN2(
	IU32, base,
	IU16, limit
    )


   {
   SET_IDT_BASE(base);
   SET_IDT_LIMIT(limit);
   }

GLOBAL VOID
c_setLDT_SELECTOR
                 
IFN1(
	IU16, val
    )


   {
   SET_LDT_SELECTOR(val);
   }

GLOBAL VOID
c_setLDT_BASE_LIMIT
                 
IFN2(
	IU32, base,
	IU32, limit
    )


   {
   SET_LDT_BASE(base);
   SET_LDT_LIMIT(limit);
   }

GLOBAL VOID
c_setTR_SELECTOR
                 
IFN1(
	IU16, val
    )


   {
   SET_TR_SELECTOR(val);
   }

GLOBAL VOID
c_setTR_BASE_LIMIT
                 
IFN2(
	IU32, base,
	IU32, limit
    )


   {
   SET_TR_BASE(base);
   SET_TR_LIMIT(limit);
   SET_TR_AR_SUPER(BUSY_TSS);
   }


GLOBAL VOID
c_setTR_BASE_LIMIT_AR
                 
IFN3(
	IU32, base,
	IU32, limit,
	IU16, ar
    )


   {
   if (GET_AR_SUPER(ar) == BUSY_TSS || GET_AR_SUPER(ar) == XTND_BUSY_TSS)
      {
      SET_TR_BASE(base);
      SET_TR_LIMIT(limit);
      SET_TR_AR_SUPER(GET_AR_SUPER(ar));
      }
   else
      {
      if (ar != 0)
         printf ("%s:%d Invalid Task Reg AR byte %02x supplied.\n",
							__FILE__, __LINE__, ar);
      SET_TR_BASE(base);
      SET_TR_LIMIT(limit);
      SET_TR_AR_SUPER(BUSY_TSS);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Current Privilege Level.                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

GLOBAL ISM32
c_getCPL()
   {
   return (ISM32)GET_CPL();
   }

GLOBAL VOID
c_setCPL
                 
IFN1(
	ISM32, val
    )


   {
   SET_CPL(val);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_stack.c ===
/*[

c_stack.c

LOCAL CHAR SccsID[]="@(#)c_stack.c	1.14 03/03/95";

Stack (and related SP/BP access) Support.
-----------------------------------------

]*/


#include <insignia.h>
#include <host_def.h>

#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_page.h>
#include <c_tlb.h>
#include <fault.h>
#include <ccpupig.h>

#if	defined(PIG) && !defined(PROD)
/* The Soft486 CPU may (when not constrained SAFE_PUSH) corrupt the unwritten
 * parts of, say, an interrupt fram which contains 16-bit items pushed into
 * 32-bit allocated slots. This defines makes the Pigger blind to these locations.
 */
#define PIG_DONT_CHECK_OTHER_WORD_ON_STACK
#endif	/* PIG && !PROD */

/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Semi-intelligent support for Incrementing/Decrementing the Stack   */
/* Pointer(E)SP.                                                      */
/* Alters ESP or SP depending on StackAddrSize.                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
byte_change_SP
                 
IFN1(
	IS32, delta
    )


   {
   if ( GET_SS_AR_X() == USE32 )   /* look at SS 'B' bit */
      SET_ESP(GET_ESP() + delta);
   else
      SET_SP(GET_SP() + delta);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Intelligent support for Incrementing/Decrementing the Stack        */
/* Pointer(E)SP by either words or double words items depending on    */
/* OperandSize.                                                       */
/* Alters ESP or SP depending on StackAddrSize.                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
change_SP
                 
IFN1(
	IS32, items
    )


   {
   if ( GET_OPERAND_SIZE() == USE16 )
      items = items * 2;
   else   /* USE32 */
      items = items * 4;

   if ( GET_SS_AR_X() == USE32 )   /* look at SS 'B' bit */
      SET_ESP(GET_ESP() + items);
   else
      SET_SP(GET_SP() + items);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Intelligent support for Reading the Frame Pointer(E)BP.            */
/* Returns either EBP or BP depending on StackAddrSize.               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
get_current_BP()
   {
   if ( GET_SS_AR_X() == USE32 )   /* look at SS 'B' bit */
      return GET_EBP();

   return GET_BP();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Intelligent support for Reading the Stack Pointer(E)SP.            */
/* Returns either ESP or SP depending on StackAddrSize.               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
GetStackPointer()
   {
   if ( GET_SS_AR_X() == USE32 )   /* look at SS 'B' bit */
      return GET_ESP();

   return GET_SP();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Intelligent support for Writing the Frame Pointer (E)BP.           */
/* Writes EBP or BP depending on StackAddrSize                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
set_current_BP
                 
IFN1(
	IU32, new_bp
    )


   {
   if ( GET_SS_AR_X() == USE32 )
      SET_EBP(new_bp);
   else   /* USE16 */
      SET_BP(new_bp);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Intelligent support for Writing the Stack Pointer (E)SP.           */
/* Writes ESP or SP depending on StackAddrSize                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
set_current_SP
                 
IFN1(
	IU32, new_sp
    )


   {
   if ( GET_SS_AR_X() == USE32 )
      SET_ESP(new_sp);
   else   /* USE16 */
      SET_SP(new_sp);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Pop word or double word from the stack.                            */
/* Used by instructions which implicitly reference the stack.         */
/* Stack Checking MUST have been completed earlier.                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
spop()
   {
   IU32 addr;	/* stack address */
   IU32 val;

   /*
      Intel describe the algorithm as:-

      if ( StackAddrSize == 16 )
	 if ( OperandSize == 16 )
	    val <- SS:[SP]  // 2-byte
	    SP = SP + 2
	 else // OperandSize == 32
	    val <- SS:[SP]  // 4-byte
	    SP = SP + 4
      else // StackAddrSize == 32
	 if ( OperandSize == 16 )
	    val <- SS:[ESP]  // 2-byte
	    ESP = ESP + 2
	 else // OperandSize == 32
	    val <- SS:[ESP]  // 4-byte
	    ESP = ESP + 4
   
      We achieve the same effect by calling 'intelligent' SP functions
      which take account of the StackAddrSize, and concentrate here on
      the OperandSize.
    */

   addr = GET_SS_BASE() + GetStackPointer();

   if ( GET_OPERAND_SIZE() == USE16 )
      {
      val = (IU32)vir_read_word(addr, NO_PHYSICAL_MAPPING);
      byte_change_SP((IS32)2);
      }
   else   /* USE32 */
      {
      val = (IU32)vir_read_dword(addr, NO_PHYSICAL_MAPPING);
      byte_change_SP((IS32)4);
      }

   return val;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Push word or double word onto the stack.                           */
/* Used by instructions which implicitly reference the stack.         */
/* Stack Checking MUST have been completed earlier.                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spush
       	          
IFN1(
	IU32, data	/* value to be pushed */
    )


   {
   IU32 addr;	/* stack address */

   /*
      Intel describe the algorithm as:-

      if ( StackAddrSize == 16 )
	 if ( OperandSize == 16 )
	    SP = SP - 2
	    SS:[SP] <- val  // 2-byte
	 else // OperandSize == 32
	    SP = SP - 4
	    SS:[SP] <- val  // 4-byte
      else // StackAddrSize == 32
	 if ( OperandSize == 16 )
	    ESP = ESP - 2
	    SS:[ESP] <- val  // 2-byte
	 else // OperandSize == 32
	    ESP = ESP - 4
	    SS:[ESP] <- val  // 4-byte
   
      We achieve the same effect by calling 'intelligent' SP functions
      which take account of the StackAddrSize, and concentrate here on
      the OperandSize.
    */

   if ( GET_OPERAND_SIZE() == USE16 )
      {
      /* push word */
      byte_change_SP((IS32)-2);
      addr = GET_SS_BASE() + GetStackPointer();
      vir_write_word(addr, NO_PHYSICAL_MAPPING, (IU16)data);
      }
   else   /* USE32 */
      {
      /* push double word */
      byte_change_SP((IS32)-4);
      addr = GET_SS_BASE() + GetStackPointer();
      vir_write_dword(addr, NO_PHYSICAL_MAPPING, (IU32)data);
      }
   }

#ifdef PIG
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Push word or double word onto the stack.                           */
/* Used by instructions which implicitly reference the stack.         */
/* Stack Checking MUST have been completed earlier.                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spush_flags
       	          
IFN1(
	IU32, data	/* value to be pushed */
    )


   {
   IU32 addr;	/* stack address */

   /*
    * see comment for spush().
    */

   if ( GET_OPERAND_SIZE() == USE16 )
      {
      /* push word */
      byte_change_SP((IS32)-2);
      addr = GET_SS_BASE() + GetStackPointer();
      vir_write_word(addr, NO_PHYSICAL_MAPPING, (IU16)data);

      /*
       * record the address at which we may not know the flags value
       * -- we will examine PigIgnoreFlags when the EDL CPU runs to check
       * if there's a problem.
       */
      record_flags_addr(addr);
      }
   else   /* USE32 */
      {
      /* push double word */
      byte_change_SP((IS32)-4);
      addr = GET_SS_BASE() + GetStackPointer();
      vir_write_dword(addr, NO_PHYSICAL_MAPPING, (IU32)data);

      /*
       * no need to record word at addr+2 as the flags are always known for this word
       */
      record_flags_addr(addr);
      }
   }
#endif /* PIG */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Push word onto the stack.                                          */
/* Operand size of 32 will still push 16 bits of data, but the stack  */
/* pointer is adjusted by 4.                                          */
/* Used by PUSH segment-register                                      */
/* Stack Checking MUST have been completed earlier.                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spush16
       	          
IFN1(
	IU32, data	/* value to be pushed */
    )


   {
   IU32 addr;	/* stack address */

   if ( GET_OPERAND_SIZE() == USE16 )
      {
      /* stack item size is word */
      byte_change_SP((IS32)-2);
      addr = GET_SS_BASE() + GetStackPointer();
      vir_write_word(addr, NO_PHYSICAL_MAPPING, (IU16)data);
      }
   else   /* USE32 */
      {
      /* stack item size is double word */
      byte_change_SP((IS32)-4);
      addr = GET_SS_BASE() + GetStackPointer();
      vir_write_word(addr, NO_PHYSICAL_MAPPING, (IU16)data);
#ifdef	PIG_DONT_CHECK_OTHER_WORD_ON_STACK
      cannot_vir_write_word(addr+2, NO_PHYSICAL_MAPPING, 0x0000);
#endif	/* PIG_DONT_CHECK_OTHER_WORD_ON_STACK */
      }
   }

#ifdef PIG
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Push word onto the stack.                                          */
/* Operand size of 32 will still push 16 bits of data, but the stack  */
/* pointer is adjusted by 4.                                          */
/* Used by PUSH segment-register                                      */
/* Stack Checking MUST have been completed earlier.                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
spush16_flags
       	          
IFN1(
	IU32, data	/* value to be pushed */
    )


   {
   IU32 addr;	/* stack address */

   if ( GET_OPERAND_SIZE() == USE16 )
      {
      /* stack item size is word */
      byte_change_SP((IS32)-2);
      addr = GET_SS_BASE() + GetStackPointer();
      vir_write_word(addr, NO_PHYSICAL_MAPPING, (IU16)data);
      record_flags_addr(addr);
      }
   else   /* USE32 */
      {
      /* stack item size is double word */
      byte_change_SP((IS32)-4);
      addr = GET_SS_BASE() + GetStackPointer();
      vir_write_word(addr, NO_PHYSICAL_MAPPING, (IU16)data);
      record_flags_addr(addr);
#ifdef	PIG_DONT_CHECK_OTHER_WORD_ON_STACK
      cannot_vir_write_word(addr+2, NO_PHYSICAL_MAPPING, 0x0000);
#endif	/* PIG_DONT_CHECK_OTHER_WORD_ON_STACK */
      }
   }
#endif /* PIG */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Temporary Pop word or double word from the stack.                  */
/* (E)SP is not changed by this instruction.                          */
/* Used by instructions which implicitly reference the stack.         */
/* Stack Checking MUST have been completed earlier.                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
tpop
                                 
IFN2(
	LIN_ADDR, item_offset,	/* item offset(from stack top) to required item */
	LIN_ADDR, byte_offset	/* byte offset (additional to item_offset) */
    )


   {
   IU32 addr;	/* stack address */
   IS32 offset;	/* total offset from stack top */
   IU32 val;

   if ( GET_OPERAND_SIZE() == USE16 )
      offset = item_offset * 2 + byte_offset;
   else   /* USE32 */
      offset = item_offset * 4 + byte_offset;

   /* calculate offset address in 32/16bit arithmetic */
   addr = GetStackPointer() + offset;
   if ( GET_SS_AR_X() == 0 )   /* look at SS 'B' bit */
      addr &= WORD_MASK;

   /* then add segment address */
   addr += GET_SS_BASE();

   if ( GET_OPERAND_SIZE() == USE16 )
      val = (IU32)vir_read_word(addr, NO_PHYSICAL_MAPPING);
   else   /* USE32 */
      val = (IU32)vir_read_dword(addr, NO_PHYSICAL_MAPPING);

   return val;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check new stack has space for a given number of bytes.             */
/* Take #SF(0) if insufficient room on stack (as in 80386 manual)     */
/* Take #SF(sel) if insufficient room on stack (as in i486 manual)    */
/* Take #PF if page fault.                                            */
/* Stack wrapping is not supported by this routine.                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
validate_new_stack_space
       	    	    		                    
IFN4(
	LIN_ADDR, nr_items,	/* (I) number of items which must exist */
	LIN_ADDR, stack_top,	/* (I) stack pointer */
	CPU_DESCR *, entry,	/* (I) pntr to descriptor cache entry for
			       stack */
	IU16, stack_sel		/* (I) selector of new stack */
    )


   {
   ISM32 bytes;
   IU32 upper;
   IU32 offset;
   ISM32 i;

/* The 80386 & i486 PRMs disagree on this matter... the EDL i486 CPU matches
   the i486 manual - which seems to do the more sensible thing - until an
   experiment is done to show which is the correct behaviour, we'll do what
   the book says...
 */

#ifdef SPC486
#define XX_error_code stack_sel
#else
#define XX_error_code 0
#endif

   if ( GET_OPERAND_SIZE() == USE16 )
      bytes = nr_items * 2;
   else   /* USE32 */
      bytes = nr_items * 4;

   if ( GET_AR_E(entry->AR) == 0 )
      {
      /* expand up */
      if ( stack_top < bytes || (stack_top - 1) > entry->limit )
	 SF(XX_error_code, FAULT_VALNEWSPC_SS_LIMIT_16);   /* limit check fails */
      }
   else
      {
      /* expand down */
      if ( GET_AR_X(entry->AR) == USE16 )
	 upper = 0xffff;
      else   /* USE32 */
	 upper = 0xffffffff;

      if ( stack_top <= (entry->limit + bytes) ||
	   (stack_top - 1) > upper )
	 SF(XX_error_code, FAULT_VALNEWSPC_SS_LIMIT_32);   /* limit check fails */
      }

   /* finally do paging unit checks */
   offset = stack_top - bytes;

   for ( i = 0; i < nr_items; i++ )
      {
      if ( GET_OPERAND_SIZE() == USE16 )
	 {
	 spr_chk_word(entry->base + offset, PG_W);
	 offset += 2;
	 }
      else
	 {
	 spr_chk_dword(entry->base + offset, PG_W);
	 offset += 4;
	 }
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check stack holds a given number of operands.                      */
/* Take #GP(0) or #SF(0) if insufficient data on stack.               */
/* Take #PF if page fault.                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
validate_stack_exists
       	    		               
IFN2(
	BOOL, use_bp,	/* (I) if true use (E)BP not (E)SP to address
			       stack */
	LIN_ADDR, nr_items	/* (I) number of operands which must exist on
			       stack */
    )


   {
   IU32 offset;
   ISM32 operand_size;
   ISM32 i;

   offset = use_bp ? get_current_BP() : GetStackPointer();

   if ( GET_OPERAND_SIZE() == USE16 )
      operand_size = 2;   /* word */
   else   /* USE32 */
      operand_size = 4;   /* double word */

   /* do access check */
   if ( GET_SS_AR_R() == 0 )
      {
      /* raise exception - something wrong with stack access */
      if ( GET_PE() == 0 || GET_VM() == 1 )
	 GP((IU16)0, FAULT_VALSTACKEX_ACCESS);
      else
	 SF((IU16)0, FAULT_VALSTACKEX_ACCESS);
      }

   /* do limit check */
   limit_check(SS_REG, offset, nr_items, operand_size);

   /* finally do paging unit checks */
   for ( i = 0; i < nr_items; i++ )
      {
      if ( operand_size == 2 )
	 {
	 (VOID)usr_chk_word(GET_SS_BASE() + offset, PG_R);
	 }
      else
	 {
	 (VOID)usr_chk_dword(GET_SS_BASE() + offset, PG_R);
	 }

      offset += operand_size;
      if ( GET_SS_AR_X() == 0 )   /* look at SS 'B' bit */
	 offset &= WORD_MASK;    /* apply 16-bit arith if reqd */
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check stack has space for a given number of operands.              */
/* Take #GP(0) or #SF(0) if insufficient room on stack.               */
/* Take #PF if page fault.                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
validate_stack_space
       	    		               
IFN2(
	BOOL, use_bp,	/* (I) if true use (E)BP not (E)SP to address
			       stack */
	LIN_ADDR, nr_items	/* (I) number of items which must exist on
			       stack */
    )


   {
   IU32 offset;
   ISM32 operand_size;
   IS32  size;
   ISM32 i;

   if ( GET_OPERAND_SIZE() == USE16 )
      operand_size = 2;   /* word */
   else   /* USE32 */
      operand_size = 4;   /* double word */

   /* calculate (-ve) total data size */
   size = nr_items * -operand_size;

   /* get current stack base */
   offset = use_bp ? get_current_BP() : GetStackPointer();

   /* hence form lowest memory address of new data to be pushed */
   /*    in 32/16bit arithmetic */
   offset = offset + size;
   if ( GET_SS_AR_X() == 0 )   /* look at SS 'B' bit */
      offset &= WORD_MASK;

   /* do access check */
   if ( GET_SS_AR_W() == 0 )
      {
      /* raise exception - something wrong with stack access */
      if ( GET_PE() == 0 || GET_VM() == 1 )
	 GP((IU16)0, FAULT_VALSTKSPACE_ACCESS);
      else
	 SF((IU16)0, FAULT_VALSTKSPACE_ACCESS);
      }

   /* do limit check */
   limit_check(SS_REG, offset, nr_items, operand_size);

   /* finally do paging unit checks */
   for ( i = 0; i < nr_items; i++ )
      {
      if ( operand_size == 2 )
	 {
	 (VOID)usr_chk_word(GET_SS_BASE() + offset, PG_W);
	 }
      else
	 {
	 (VOID)usr_chk_dword(GET_SS_BASE() + offset, PG_W);
	 }

      offset += operand_size;
      if ( GET_SS_AR_X() == 0 )   /* look at SS 'B' bit */
	 offset &= WORD_MASK;    /* apply 16-bit arith if reqd */
      }
   }

#ifdef PIG

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Record a (physical) ESP value for later use if PigIgnoreFlags is   */
/* set by the EDL CPU after the pigger has run.                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL void
record_flags_addr IFN1(LIN_ADDR, lin_addr)
{
	IU32 phy_addr;

	if ( GET_PG() == 1 )
	{
		/*
		 * we ask for supervisor access because the access has
		 * already been checked by the push. We dont know the
		 * U/S used then but asking for PG_S will always work.
		 */
		phy_addr = lin2phy(lin_addr, PG_S | PG_W);
	}
	else
		phy_addr = lin_addr;

	/* printf("recording stack flags push @ lin: %x, phy %x\n", lin_addr, phy_addr); */

	pig_fault_write(phy_addr, (~ARITH_FLAGS_BITS) & 0xff);

	/*
	 * short-cut - if bottom bits not 0xfff then we can just add 1
	 * to the physical addr for byte 2. Otherwise we have to recalculate
	 * the whole address.
	 */
	if (((phy_addr & 0xfff) != 0xfff) || (GET_PG() == 0))
		pig_fault_write(phy_addr + 1, ((~ARITH_FLAGS_BITS) >> 8) & 0xff);
	else
	{
		phy_addr = lin2phy(lin_addr + 1, PG_S | PG_W);
		pig_fault_write(phy_addr, ((~ARITH_FLAGS_BITS) >> 8) & 0xff);
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_stack.h ===
/*[

c_stack.h

LOCAL CHAR SccsID[]="@(#)c_stack.h	1.11 03/03/95";

Stack (and related SP/BP access) Support.
-----------------------------------------

]*/


/*
   SP/BP indicator for stack checking operations.
 */
#define USE_SP FALSE
#define USE_BP TRUE

/*
   Useful defines for tpop(),validate_stack_exists(),
   validate_stack_space() and change_SP() parameters.
 */
#define NR_ITEMS_1 1
#define NR_ITEMS_2 2
#define NR_ITEMS_3 3
#define NR_ITEMS_4 4
#define NR_ITEMS_5 5
#define NR_ITEMS_6 6
#define NR_ITEMS_8 8
#define NR_ITEMS_9 9

#define STACK_ITEM_1 (IUM32)0
#define STACK_ITEM_2 (IUM32)1
#define STACK_ITEM_3 (IUM32)2
#define STACK_ITEM_4 (IUM32)3
#define STACK_ITEM_5 (IUM32)4
#define STACK_ITEM_6 (IUM32)5
#define STACK_ITEM_7 (IUM32)6
#define STACK_ITEM_8 (IUM32)7
#define STACK_ITEM_9 (IUM32)8

#define NULL_BYTE_OFFSET (IUM32)0


IMPORT VOID byte_change_SP
       
IPT1(
	IS32, delta

   );

IMPORT VOID change_SP
       
IPT1(
	IS32, items

   );

IMPORT IU32 get_current_BP IPT0();

IMPORT IU32 GetStackPointer IPT0();

IMPORT VOID set_current_BP
       
IPT1(
	IU32, new_bp

   );

IMPORT VOID set_current_SP
       
IPT1(
	IU32, new_sp

   );

IMPORT IU32 spop IPT0();

IMPORT VOID spush
       
IPT1(
	IU32, data

   );

#ifdef PIG
IMPORT VOID spush_flags
       
IPT1(
	IU32, data

   );
#endif /* PIG */

IMPORT VOID spush16
       
IPT1(
	IU32, data

   );

#ifdef PIG
IMPORT VOID spush16_flags
       
IPT1(
	IU32, data

   );
#endif /* PIG */


IMPORT IU32 tpop
           
IPT2(
	LIN_ADDR, item_offset,
	LIN_ADDR, byte_offset

   );

IMPORT VOID validate_new_stack_space
               
IPT4(
	LIN_ADDR, bytes,
	LIN_ADDR, stack_top,
	CPU_DESCR *, entry,
	IU16, stack_sel

   );

IMPORT VOID validate_stack_exists
           
IPT2(
	BOOL, use_bp,
	LIN_ADDR, nr_items

   );

IMPORT VOID validate_stack_space
           
IPT2(
	BOOL, use_bp,
	LIN_ADDR, nr_items

   );

IMPORT void touch_flags_memory IPT0();
IMPORT void init_flags_esp_list IPT0();
IMPORT void record_flags_addr IPT1(LIN_ADDR, addr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_tlb.c ===
/*[

c_tlb.c

LOCAL CHAR SccsID[]="@(#)c_tlb.c	1.17 03/15/95";

Translation Lookaside Buffer Emulation.
---------------------------------------

]*/


/*
   Indicator for 'optimised lookup' format TLB.
 */
#define FAST_TLB

#include <stdio.h>

#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_tlb.h>
#include <c_page.h>
#include <c_mem.h>
#include <ccpusas4.h>
#include <ccpupig.h>
#include <fault.h>


/*
   The 386 TLB is an 8 entry 4 way set associative cache. It is known
   that cache sets are not allocated on an LRU basis, we assume simple
   round robin allocation per entry.
 */

typedef struct
   {
   IU32 la;	/* Bits 32-12 => 20-bit Linear Address */
   IU32 pa;	/* Bits 32-12 => 20-bit Physical Address */
   BOOL v;	/* Validity indicator, true means valid */
   BOOL d;	/* Dirty indicator, true means dirty */
   IU32  mode;	/* 2-bit Mode indicator
		      Bit 0 => R/W
		      Bit 1 => U/S */
   } TLB_ENTRY;

#define NR_TLB_SETS    4
#define NR_TLB_ENTRIES 8

/*
   The Intel format TLB data structures.
 */
LOCAL TLB_ENTRY tlb[NR_TLB_SETS][NR_TLB_ENTRIES];
LOCAL IU32 next_set[NR_TLB_ENTRIES] =
   {
   0, 0, 0, 0, 0, 0, 0, 0
   };

#ifdef FAST_TLB

/*
   We allocate one byte per Intel page; this 'page_index' allows us
   to tell quickly if a page translation is held in the TLB and where
   we can find the translated address. The format is arranged for
   minimal access checks. Each byte has the format:-

      1)  7      0
	 ==========
         |00000000| Page Not Mapped.
	 ==========
      
      2)  7 6 5 4   2 10
	 ================
         |1|Set|Entry|00| Page Mapped in given set and entry of TLB.
	 ================
 */

#define NR_PAGES 1048576   /* 2^20 */

LOCAL IU8 page_index[NR_PAGES];

#define PI_NOT_VALID 0
#define PI_VALID     0x80
#define PI_SET_ENTRY_MASK 0x7c
#define PI_SET_SHIFT   5
#define PI_ENTRY_SHIFT 2

/*
   We also allocate an array of translated (ie physical) addresses,
   indexed by the Set:Entry combination in the page_index. For each
   combination four sequential addresses are allocated for the various
   access modes:-

      Supervisor Read
      Supervisor Write
      User Read
      User Write
   
   A translation address of zero is taken to mean that no translation
   is held (It is easy to check for zero). This has the slight side
   effect that though we may enter address translations for zero (ie
   the first page of physical memory) we never get a 'hit' for them, so
   access to the first page of physical memory is always through the
   slow Intel format TLB.
 */

#define NR_ACCESS_MODES 4

#define NO_MAPPED_ADDRESS 0

LOCAL IU32 page_address[NR_TLB_SETS * NR_TLB_ENTRIES * NR_ACCESS_MODES];

#endif /* FAST_TLB */

/*
   Linear Addresses are composed as follows:-

       3        2 2        1 1
       1        2 1        2 1          0
      ====================================
      |directory |   table  |   offset   |
      ====================================
 */

#define OFFSET_MASK 0xfff
#define TBL_MASK    0x3ff
#define DIR_MASK    0x3ff
#define TBL_SHIFT 12
#define DIR_SHIFT 22
#define DIR_TBL_SHIFT 12

/*
   Page Directory Entries (PDE) or
   Page Table Entries (PTE) are composed as follows:-

      3                   2
      1                   2       6 5    2 1 0
      =========================================
      |                    |     | | |  |U|R| |
      | page frame address |     |D|A|  |/|/|P|
      |                    |     | | |  |S|W| |
      =========================================
 */

#define PE_PFA_MASK 0xfffff000
#define PE_P_MASK   0x1
#define PE_U_S_MASK 0x4
#define PE_R_W_MASK 0x2

#define PE_DIRTY    0x40
#define PE_ACCESSED 0x20

/*
   TR7 = Test Data Register:-

       3                  1
       1                  2         4 32
      ======================================
      |                    |       |H| R|  |
      |  Physical Address  |       |T| E|  |
      |                    |       | | P|  |
      ======================================
   
   TR6 = Test Command Register:-

       3                  1 1 1
       1                  2 1 0 9 8 7 6 5      0
      ===========================================
      |   Linear Address   |V|D|D|U|U|W|W|    |C|
      |                    | | |#| |#| |#|    | |
      ===========================================
 */

#define TCR_LA_MASK   0xfffff000
#define TCR_V_MASK    0x800
#define TCR_D_MASK    0x400
#define TCR_ND_MASK   0x200
#define TCR_U_MASK    0x100
#define TCR_NU_MASK   0x80
#define TCR_W_MASK    0x40
#define TCR_NW_MASK   0x20
#define TCR_C_MASK    0x1
#define TCR_ATTR_MASK 0x7e0

#define TDR_PA_MASK   0xfffff000
#define TDR_HT_MASK   0x10
#define TDR_REP_MASK  0xc

#define TDR_REP_SHIFT 2

/*
   Encoded access check matrix, true indicates access failure.
 */

#ifdef SPC486

/*                      WP reqd avail */
LOCAL BOOL access_check[2] [4] [4] =
   {
      {  /* WP = 0 */
	 /*  S_R     S_W     U_R     U_W  */
	 { FALSE, FALSE, FALSE, FALSE },   /* S_R */
	 { FALSE, FALSE, FALSE, FALSE },   /* S_W */
	 { TRUE , TRUE , FALSE, FALSE },   /* U_R */
	 { TRUE , TRUE , TRUE , FALSE }    /* U_W */
      },
      {  /* WP = 1 */
	 /*  S_R     S_W     U_R     U_W  */
	 { FALSE, FALSE, FALSE, FALSE },   /* S_R */
	 { FALSE, FALSE, TRUE , FALSE },   /* S_W */
	 { TRUE , TRUE , FALSE, FALSE },   /* U_R */
	 { TRUE , TRUE , TRUE , FALSE }    /* U_W */
      }
   };

#else

/*                     reqd avail */
LOCAL BOOL access_check[4] [4] =
   {
      /*  S_R     S_W     U_R     U_W  */
      { FALSE, FALSE, FALSE, FALSE },   /* S_R */
      { FALSE, FALSE, FALSE, FALSE },   /* S_W */
      { TRUE , TRUE , FALSE, FALSE },   /* U_R */
      { TRUE , TRUE , TRUE , FALSE }    /* U_W */
   };

#endif /* SPC486 */

LOCAL void deal_with_pte_cache_hit IPT1(IU32, linearAddress);
GLOBAL void Pig_NotePDECacheAccess IPT2(IU32, linearAddress, IU32, accessBits);
GLOBAL void Pig_NotePTECacheAccess IPT2(IU32, linearAddress, IU32, accessBits);

/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Flush TLB.                                                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
flush_tlb()
   {
   ISM32 set, entry;
   TLB_ENTRY *e;

   for ( set = 0; set < NR_TLB_SETS; set++ )
      for ( entry = 0; entry < NR_TLB_ENTRIES; entry++ )
	 {
	 e = &tlb[set][entry];
#ifdef FAST_TLB
	 if ( e->v )
	    {
	    /* Remove associated page_index entry */
	    page_index[e->la >> DIR_TBL_SHIFT] = PI_NOT_VALID;
	    }
#endif /* FAST_TLB */
	 e->v = FALSE;
	 }
   }

#ifdef SPC486

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Invalidate TLB entry.                                              */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
invalidate_tlb_entry
       	          
IFN1(
	IU32, lin	/* Linear Address */
    )


   {
   ISM32 set, entry;
   TLB_ENTRY *e;	/* current tlb entry */

   entry = lin >> DIR_TBL_SHIFT & 0x07;   /* isolate bits 14-12 */
   lin = lin & ~OFFSET_MASK;	/* drop any offset */

   for ( set = 0; set < NR_TLB_SETS; set++ )
      {
      e = &tlb[set][entry];

      if ( e->v && e->la == lin )
	 {
	 /* Valid entry for given address: Flush it. */
#ifdef FAST_TLB
	 /* Remove associated page_index entry */
	 page_index[e->la >> DIR_TBL_SHIFT] = PI_NOT_VALID;
#endif /* FAST_TLB */
	 e->v = FALSE;
	 }
      }
   }

#endif /* SPC486 */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Map linear address to physical address.                            */
/* May take #PF. Used by all internal C CPU functions.                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU32
lin2phy
       	    	               
IFN2(
	IU32, lin,	/* Linear Address */
	ISM32, access	/* access mode Bit 0 => R/W
			       Bit 1 => U/S */
    )


   {
   IU8 pi;		/* page_index entry */
   IU32 ma;		/* mapped address */

   IU32 pde_addr;	/* Address of Page Directory Entry */
   IU32 pte_addr;	/* Address of Page Table Entry */
   IU32 pde;		/* Page Directory Entry */
   IU32 pte;		/* Page Table Entry */
   IU32 new_pde;	/* Page Directory Entry (to write back) */
   IU32 new_pte;	/* Page Table Entry (to write back) */

   ISM32 set, entry;
   IU32 lookup;	/* Linear address minus offset */
   BOOL read_op;	/* true if read operation */
   IU32 comb;		/* Combined protection of pde and pte */
   TLB_ENTRY *e;	/* current tlb entry */

#ifdef FAST_TLB

   /* Search optimised format TLB */
   if ( pi = page_index[lin >> DIR_TBL_SHIFT] )
      {
      /* we have hit for the page, get mapped address */
      if ( ma = page_address[(pi & PI_SET_ENTRY_MASK) + access] )
	 {
	 /* we have hit for access type */
	 return ma | lin & OFFSET_MASK;
	 }
      }
   
   /* Otherwise do things the Intel way. */

#endif /* FAST_TLB */

   /* Check for entry in TLB <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/

   entry = lin >> DIR_TBL_SHIFT & 0x07;   /* isolate bits 14-12 */
   lookup = lin & ~OFFSET_MASK;
   read_op = (access & PG_W) ? FALSE : TRUE;

   for ( set = 0; set < NR_TLB_SETS; set++ )
      {
      e = &tlb[set][entry];
      /*
	 The TLB may have a READ miss (address not in TLB) or a WRITE
	 miss (address not in TLB or address in TLB but dirty bit not
	 set). For either case a new cache entry is created.
       */
      if ( e->v && e->la == lookup && (read_op || e->d) )
	 {
	 /* Cache Hit <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

	 /* check access validity */
#ifdef SPC486
	 if ( access_check[GET_WP()][access][e->mode] )
#else
	 if ( access_check[access][e->mode] )
#endif /* SPC486 */
	    {
	    /* Protection Failure */
	    SET_CR(CR_PFLA, lin);
	    PF((IU16)(access << 1 | 1), FAULT_LIN2PHY_ACCESS);
	    }

	 /* return cached physical address */
	 return e->pa | lin & OFFSET_MASK;
	 }
      }
   
   /* Cache Miss <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/

   /* check that pde is present */
   pde_addr = (GET_CR(CR_PDBR) & PE_PFA_MASK) +
		 ((lin >> DIR_SHIFT & DIR_MASK) << 2);
   pde = phy_read_dword(pde_addr);

   if ( (pde & PE_P_MASK) == 0 )
      {
      /* pde not present */
      SET_CR(CR_PFLA, lin);
      PF((IU16)(access << 1), FAULT_LIN2PHY_PDE_NOTPRESENT);
      }

   /* check that pte is present */
   pte_addr = (pde & PE_PFA_MASK) +
		 ((lin >> TBL_SHIFT & TBL_MASK) << 2);
   pte = phy_read_dword(pte_addr);

   if ( (pte & PE_P_MASK) == 0 )
      {
      /* pte not present */
      SET_CR(CR_PFLA, lin);
      PF((IU16)(access << 1), FAULT_LIN2PHY_PTE_NOTPRESENT);
      }

   /* combine pde and pte protection (and convert into our format)
    *
    * The i486 HARDWARE manual says take the numerically lower of
    * the combined bits.
    */

   if ( (pde & ( PE_U_S_MASK|PE_R_W_MASK )) < (pte & ( PE_U_S_MASK|PE_R_W_MASK )))
   {
	   /* The pde defines protection */
	   comb = PG_R | PG_S;
	   if ( pde & PE_U_S_MASK )
		   comb |= PG_U;
	   if ( pde & PE_R_W_MASK )
		   comb |= PG_W;
   }
   else
   {
	   /* The pte defines protection */
	   comb = PG_R | PG_S;
	   if ( pte & PE_U_S_MASK )
		   comb |= PG_U;
	   if ( pte & PE_R_W_MASK )
		   comb |= PG_W;
   }


   /* check access validity */
#ifdef SPC486
   if ( access_check[GET_WP()][access][comb] )
#else
   if ( access_check[access][comb] )
#endif /* SPC486 */
      {
      /* Protection Failure */
      SET_CR(CR_PFLA, lin);
      PF((IU16)(access << 1 | 1), FAULT_LIN2PHY_PROTECT_FAIL);
      }

   /* OK - allocate cache entry */
   set = next_set[entry];
   next_set[entry] += 1;
   next_set[entry] &= 0x3;   /* 0,1,2,3,0,1,2.... */

   e = &tlb[set][entry];

#ifdef FAST_TLB

   /* Clear any page_index for old entry */
   if ( e->v )
      {
      page_index[e->la >> DIR_TBL_SHIFT] = PI_NOT_VALID;
      }

#endif /* FAST_TLB */

   e->la = lookup;
   e->v = TRUE;
   e->mode = comb;
   e->pa = pte & PE_PFA_MASK;
   e->d = !read_op;

#ifdef FAST_TLB

   /* Set up page_index and associated addresses */
   pi = set << PI_SET_SHIFT | entry << PI_ENTRY_SHIFT;
   page_index[e->la >> DIR_TBL_SHIFT] = PI_VALID | pi;

   /* minimal mappings */
   page_address[pi | PG_S | PG_R] = e->pa;
   page_address[pi | PG_S | PG_W] = NO_MAPPED_ADDRESS;
   page_address[pi | PG_U | PG_R] = NO_MAPPED_ADDRESS;
   page_address[pi | PG_U | PG_W] = NO_MAPPED_ADDRESS;

   /* now augment mappings if possible */
   if ( e->d )
      {
      page_address[pi | PG_S | PG_W] = e->pa;
      }

   if ( e->mode >= PG_U )
      {
      page_address[pi | PG_U | PG_R] = e->pa;

      if ( e->mode & PG_W && e->d )
	 {
	 page_address[pi | PG_U | PG_W] = e->pa;
	 }
      }

#endif /* FAST_TLB */

   /* update in memory page entries */
   new_pde = pde | PE_ACCESSED;
   new_pte = pte | PE_ACCESSED;

   if ( e->d )
      {
      new_pte |= PE_DIRTY;
      }

   if (new_pte != pte)
      {
      phy_write_dword(pte_addr, new_pte);
#ifdef	PIG
      save_last_xcptn_details("PTE %08x: %03x => %03x", pte_addr, pte & 0xFFF, new_pte & 0xFFF, 0, 0);
      if (((new_pte ^ pte) == PE_ACCESSED) && ignore_page_accessed())
         cannot_phy_write_byte(pte_addr, ~PE_ACCESSED);
#endif
      }

   if (new_pde != pde)
      {
      phy_write_dword(pde_addr, new_pde);
#ifdef	PIG
      save_last_xcptn_details("PDE %08x: %03x => %03x", pde_addr, pde & 0xFFF, new_pde & 0xFFF, 0, 0);
      if ((new_pde ^ pde) == PE_ACCESSED)
         cannot_phy_write_byte(pde_addr, ~PE_ACCESSED);
#endif
      }

   /* return newly cached physical address */
   return e->pa | lin & OFFSET_MASK;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* TLB Test Operation ie writes to Test Registers.                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
test_tlb()
   {
   ISM32 set, entry;
   TLB_ENTRY *e;	/* current TLB entry */
   IU32 tcr;		/* local copy of test command register */
   IU32 tdr;		/* local copy of test data register */
   IU32 lookup;	/* linear address to be looked up */
   BOOL reqd_v;	/* validity required in lookup mode */
   IU32 temp_u;		/* U/S to be set in write mode */

   fprintf(stderr, "Testing TLB.\n");

   tcr = GET_TR(TR_TCR);
   tdr = GET_TR(TR_TDR);
   entry = tcr >> DIR_TBL_SHIFT & 0x7;   /* Take bits 14-12 */

   if ( tcr & TCR_C_MASK )
      {
      /* C = 1 => lookup TLB entry */
      lookup = tcr & TCR_LA_MASK;
      reqd_v = (tcr & TCR_V_MASK) != 0;

      for ( set = 0; set < NR_TLB_SETS; set++ )
	 {
	 /* Note search in test mode includes the validity bit */
	 e = &tlb[set][entry];
	 if ( e->v == reqd_v && e->la == lookup )
	    {
	    /* HIT */

	    tdr = e->pa;			/* write phys addr */
	    tdr = tdr | TDR_HT_MASK;		/* HT = 1 */
	    tdr = tdr | set << TDR_REP_SHIFT;	/* REP = set */
	    SET_TR(TR_TDR, tdr);

	    tcr = tcr & ~TCR_ATTR_MASK;	/* clear all attributes */

	    /* set attributes from cached values */
	    if ( e->d )
	       tcr = tcr | TCR_D_MASK;
	    else
	       tcr = tcr | TCR_ND_MASK;

	    if ( e->mode & PG_U )
	       tcr = tcr | TCR_U_MASK;
	    else
	       tcr = tcr | TCR_NU_MASK;

	    if ( e->mode & PG_W )
	       tcr = tcr | TCR_W_MASK;
	    else
	       tcr = tcr | TCR_NW_MASK;

	    SET_TR(TR_TCR, tcr);
	    return;
	    }
	 }
      
      /* lookup MISS */
      tdr = tdr & ~TDR_HT_MASK;	/* HT = 0 */
      SET_TR(TR_TDR, tdr);
      }
   else
      {
      /* C = 0 => write TLB entry */

      if ( tdr & TDR_HT_MASK )
	 {
	 /* REP field gives set */
	 set = (tdr & TDR_REP_MASK) >> TDR_REP_SHIFT;
	 }
      else
	 {
	 /* choose set ourselves */
	 set = next_set[entry];
	 next_set[entry] += 1;
	 next_set[entry] &= 0x3;   /* 0,1,2,3,0,1,2.... */
	 }

      e = &tlb[set][entry];

#ifdef FAST_TLB

      /* Clear any page_index for old entry */
      if ( e->v )
	 {
	 page_index[e->la >> DIR_TBL_SHIFT] = PI_NOT_VALID;
	 }

#endif /* FAST_TLB */

      /* set up cache info. */
      e->pa = tdr & TDR_PA_MASK;
      e->la = tcr & TCR_LA_MASK;
      e->v = (tcr & TCR_V_MASK) != 0;
      e->d = (tcr & TCR_D_MASK) != 0;
      e->mode = (tcr & TCR_W_MASK) != 0;
      temp_u  = (tcr & TCR_U_MASK) != 0;
      e->mode = e->mode | temp_u << 1;
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Map external linear address to physical address.                   */
/* Used only by functions external to the C CPU.                      */
/* Does not take #PF and does not alter contents of TLB.              */
/* Returns TRUE if mapping done, else FALSE.                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IBOOL
xtrn2phy IFN3
   (
   LIN_ADDR, lin,		/* Linear Address */
   IUM8, access_request,	/* access mode request */
				/* Bit 0 => R/W (as per 486) */
				/* Bit 1 => U/S (as per 486) */
				/* Bit 2 => if set only return mapping
				   if accessed and dirty bits are set
				   for the required address translation.
				   */
   PHY_ADDR *, phy		/* pntr to Physical Address */
   )
   {
   IU32 pde_addr;	/* Address of PDE */
   IU32 pte_addr;	/* Address of PTE */
   IU32 pde;		/* Page Directory Entry */
   IU32 pte;		/* Page Table Entry */
   IU32 new_pde;	/* Page Directory Entry (to write back) */
   IU32 new_pte;	/* Page Table Entry (to write back) */

   ISM32 set, entry;
   IUM8 access;		/* 486 access mode */
   BOOL read_op;	/* true if read operation */
   IU32 comb;		/* Combined protection of pde and pte */
   IU32 lookup;		/* Linear address minus offset */
   IU8 pi;		/* page_index entry */
   IU32 ma;		/* mapped address */
   TLB_ENTRY *e;	/* current tlb entry */

   access = access_request & 0x3;   /* isolate 486 part of access mode */

#ifdef FAST_TLB

   /* Search optimised format TLB */
   if ( pi = page_index[lin >> DIR_TBL_SHIFT] )
      {
      /* we have hit for the page, get mapped address */
      if ( ma = page_address[(pi & PI_SET_ENTRY_MASK) + access] )
	 {
	 /* we have hit for access type */
	 *phy = ma | lin & OFFSET_MASK;
	 return TRUE;
	 }
      }
   
   /* Otherwise do things the Intel way. */

#endif /* FAST_TLB */

   /* Check for entry in TLB */

   entry = lin >> DIR_TBL_SHIFT & 0x07;   /* isolate bits 14-12 */
   lookup = lin & ~OFFSET_MASK;
   read_op = (access & PG_W) ? FALSE : TRUE;

   for ( set = 0; set < NR_TLB_SETS; set++ )
      {
      e = &tlb[set][entry];
      if ( e->v && e->la == lookup && (read_op || e->d) )
	 {
	 /* Cache Hit */

	 /* check access validity */
#ifdef SPC486
	 if ( access_check[GET_WP()][access][e->mode] )
#else
	 if ( access_check[access][e->mode] )
#endif /* SPC486 */
	    {
	    return FALSE;
	    }

	 *phy = e->pa | lin & OFFSET_MASK;
	 return TRUE;
	 }
      }
   
   /* Cache Miss */

   /* check that pde is present */
   pde_addr = (GET_CR(CR_PDBR) & PE_PFA_MASK) +
	     ((lin >> DIR_SHIFT & DIR_MASK) << 2);
   pde = phy_read_dword(pde_addr);

   if ( (pde & PE_P_MASK) == 0 )
      return FALSE;   /* pde not present */

   /* check that pte is present */
   pte_addr = (pde & PE_PFA_MASK) +
	     ((lin >> TBL_SHIFT & TBL_MASK) << 2);
   pte = phy_read_dword(pte_addr);

   if ( (pte & PE_P_MASK) == 0 )
      return FALSE;   /* pte not present */

   /* combine pde and pte protection */
   comb = PG_R | PG_S;
   if ( (pde | pte) & PE_U_S_MASK )
      comb |= PG_U;   /* at least one table says user */
   if ( (pde & pte) & PE_R_W_MASK )
      comb |= PG_W;   /* both tables allow write */

   /* check access validity */
#ifdef SPC486
   if ( access_check[GET_WP()][access][comb] )
#else
   if ( access_check[access][comb] )
#endif /* SPC486 */
      {
      return FALSE;
      }

   /* Finally check that A and D bits reflect the requested
      translation. */
   if ( access_request & 0x4 )   /* Bit 2 == 1 */
      {
      /*
	 This check may be made in two ways.
	 
	 Firstly we might simply return FALSE, thus causing a new
	 invocation of host_simulate() to run, so that assembler
	 routines may load the TLB and set the accessed and dirty bits.

	 Secondly we may just ensure that the accessed and dirty bits
	 are set directly here. Providing we don't require that the
	 TLB is faithfully emulated, this is a more efficient method.
       */

      /* Check current settings */
      if ( ((pde & PE_ACCESSED) == 0) ||
	   ((pte & PE_ACCESSED) == 0) ||
           (!read_op && ((pte & PE_DIRTY) == 0)) )
	 {
	 /* update in memory page entries */
	 new_pde = pde | PE_ACCESSED;
	 new_pte = pte | PE_ACCESSED;

	 if ( !read_op )
	    {
	    new_pte |= PE_DIRTY;
	    }

         if (new_pte != pte)
            {
            phy_write_dword(pte_addr, new_pte);
#ifdef	PIG
            save_last_xcptn_details("PTE %08x: %03x -> %03x", pte_addr, pte & 0xFFF, new_pte & 0xFFF, 0, 0);
	    if ((new_pte ^ pte) == PE_ACCESSED)
		cannot_phy_write_byte(pte_addr, ~PE_ACCESSED);
#endif
            }
         if (new_pde != pde)
            {
            IU8 mask;
            phy_write_dword(pde_addr, new_pde);
#ifdef	PIG
            save_last_xcptn_details("PDE %08x: %03x -> %03x", pde_addr, pde & 0xFFF, new_pde & 0xFFF, 0, 0);
	    mask = 0xff;
	    if (((new_pde ^ pde) == PE_ACCESSED) && ignore_page_accessed())
		cannot_phy_write_byte(pde_addr, ~PE_ACCESSED);
#endif
            }
	 }
      }

   *phy = (pte & PE_PFA_MASK) | lin & OFFSET_MASK;
   return TRUE;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* DEBUGGING. Dump tlb information.                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
zdumptlb
                 
IFN1(
	FILE *, out
    )


   {
   ISM32 set, entry;
   TLB_ENTRY *e;	/* current TLB entry */

   fprintf(out, "set entry lin_addr V phy_addr D U W\n");

   for ( set = 0; set < NR_TLB_SETS; set++ )
      {
      for ( entry = 0; entry < NR_TLB_ENTRIES; entry++ )
	 {
	 e = &tlb[set][entry];
	 fprintf(out, " %d    %d   %08x %d %08x %d %d %d\n",
	    set, entry, e->la, e->v, e->pa, e->d,
	    (e->mode & BIT1_MASK) != 0 ,
	    e->mode & BIT0_MASK);
	 }
      }
   }

#ifdef PIG

GLOBAL void Pig_NotePDECacheAccess IFN2(IU32, linearAddress, IU32, accessBits)
{
	return;
}

GLOBAL void Pig_NotePTECacheAccess IFN2(IU32, linearAddress, IU32, accessBits)
{
   IU8 pi;		/* page_index entry */
   IU32 ma;		/* mapped address */

   ISM32 set, entry;
   IU32 lookup;	/* Linear address minus offset */
   BOOL read_op;	/* true if read operation */
   TLB_ENTRY *e;	/* current tlb entry */

#ifdef FAST_TLB

   /* Search optimised format TLB */
   if ( pi = page_index[linearAddress >> DIR_TBL_SHIFT] )
      {
      /* we have hit for the page, get mapped address */
      if ( ma = page_address[(pi & PI_SET_ENTRY_MASK) + accessBits] )
	 {
	 deal_with_pte_cache_hit(linearAddress & OFFSET_MASK);
	 return;
	 }
      }
   
   /* Otherwise do things the Intel way. */

#endif /* FAST_TLB */

   /* Check for entry in TLB <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/

   entry = linearAddress >> DIR_TBL_SHIFT & 0x07;   /* isolate bits 14-12 */
   lookup = linearAddress & ~OFFSET_MASK;
   read_op = (accessBits & PG_W) ? FALSE : TRUE;

   for ( set = 0; set < NR_TLB_SETS; set++ )
      {
      e = &tlb[set][entry];
      if ( e->v && e->la == lookup && (read_op || e->d) )
	 {
	 /* Cache Hit <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

	 /* check access validity */
#ifdef SPC486
	 if ( access_check[GET_WP()][accessBits][e->mode] )
#else
	 if ( access_check[accessBits][e->mode] )
#endif /* SPC486 */
	    {
		/* would page fault. Ignore it */
		return;
	    }

	 deal_with_pte_cache_hit(linearAddress & OFFSET_MASK);
	 return;
	 }
      }
   /* not in cache - no need to do anything */
}

LOCAL void
deal_with_pte_cache_hit IFN1(IU32, linearAddress)
{
   IU32 pde_addr;	/* Address of Page Directory Entry */
   IU32 pde;		/* Page Directory Entry */
   IU32 pte_addr;	/* Address of Page Table Entry */
   IU32 pte;		/* Page Table Entry */

   /* check that pde is present */
   pde_addr = (GET_CR(CR_PDBR) & PE_PFA_MASK) +
		 ((linearAddress >> DIR_SHIFT & DIR_MASK) << 2);
   pde = phy_read_dword(pde_addr);

   /* check pde present */
   if ( (pde & PE_P_MASK) == 0 )
      return;

   /* check that pte is present */
   pte_addr = (pde & PE_PFA_MASK) + ((linearAddress >> TBL_SHIFT & TBL_MASK) << 2);
   pte = phy_read_dword(pte_addr);

   if ( (pte & PE_P_MASK) == 0 )
      return;

   /* fprintf(trace_file, "deal_with_pte_cache_hit: addr %08lx, pte=%08lx @ %08lx\n",
    * 	linearAddress, pte, pte_addr);
    */
   cannot_phy_write_byte(pte_addr, ~PE_ACCESSED);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_tlb.h ===
/*[

c_tlb.h

Translation Lookaside Buffer Emulation.
---------------------------------------

LOCAL CHAR SccsID[]="@(#)c_tlb.h	1.5 02/25/94";

]*/


/*
   Page Accessor Types.
 */
#define PG_S 0x0 /* Supervisor */
#define PG_U 0x2 /* User */

IMPORT VOID flush_tlb IPT0();

IMPORT VOID invalidate_tlb_entry IPT1
   (
   IU32, lin
   );

IMPORT IU32 lin2phy IPT2
   (
   IU32, lin,
   ISM32, access
   );

IMPORT VOID test_tlb IPT0();

extern IBOOL xtrn2phy IPT3
   (
   LIN_ADDR,   lin,
   IUM8,       access_request,
   PHY_ADDR *, phy
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_xcptn.h ===
/*[

c_xcptn.h

LOCAL CHAR SccsID[]="@(#)c_xcptn.h	1.6 01/19/95";

Exception Handling Support.
---------------------------

]*/


/*
   Intel exception types.
 */
#define INTERNAL 0
#define EXTERNAL 1


/*
   Interrupt Controls.
 */
IMPORT BOOL	doing_contributory;
IMPORT BOOL	doing_double_fault;
IMPORT BOOL	doing_page_fault;
IMPORT BOOL	doing_fault;
IMPORT ISM32	EXT;
IMPORT IU32	CCPU_save_EIP;


IMPORT VOID Int0 IPT0();

IMPORT VOID Int1_f IPT0();  /* fault */

IMPORT VOID Int1_t IPT0();  /* trap */
      
IMPORT VOID Int5 IPT0();

IMPORT VOID Int6 IPT0();

IMPORT VOID Int7 IPT0();

IMPORT VOID Int16 IPT0();

IMPORT VOID DF IPT1( IU16, xcode);

IMPORT VOID TS IPT2( IU16, selector, IU16, xcode );

IMPORT VOID NP  IPT2( IU16, selector, IU16, xcode );

IMPORT VOID SF  IPT2( IU16, selector, IU16, xcode );

IMPORT VOID GP  IPT2( IU16, selector, IU16, xcode );

IMPORT VOID PF  IPT2( IU16, page_error, IU16, xcode );

IMPORT VOID NP_INT  IPT2( IU16, vector, IU16, xcode );

IMPORT VOID GP_INT  IPT2( IU16, vector, IU16, xcode );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_xcptn.c ===
/*[

c_xcptn.c

LOCAL CHAR SccsID[]="@(#)c_xcptn.c	1.14 01/31/95";

Exception Handling Support.
---------------------------

]*/


#include <stdio.h>
#include <insignia.h>

#include <host_def.h>
#include StringH
#include <xt.h>

#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_intr.h>
#include <c_xtrn.h>
#include <ccpupig.h>
#include <fault.h>

/*
   Allow print out of exceptions or disallow it.
 */
GLOBAL BOOL show_exceptions = FALSE;
GLOBAL BOOL trap_exceptions = FALSE;
LOCAL  BOOL first_exception = TRUE;

#define check_exception_env()						\
{									\
	IMPORT char *host_getenv IPT1 (char *, name);			\
	if (first_exception)						\
	{								\
		char *env = host_getenv ("CCPU_SHOW_EXCEPTIONS");	\
		if (env != NULL)					\
		{							\
			show_exceptions = TRUE;				\
			if (strcasecmp(env, "TRAP") == 0)		\
				trap_exceptions = TRUE;			\
		}							\
	}								\
	first_exception = FALSE;					\
}

IMPORT FILE *trace_file;
IMPORT IBOOL took_absolute_toc;

/*
   Intel interrupt(exception) numbers.
 */
#define I0_INT_NR   0
#define I1_INT_NR   1
#define I5_INT_NR   5
#define I6_INT_NR   6
#define I7_INT_NR   7
#define I16_INT_NR 16
#define DF_INT_NR   8
#define GP_INT_NR  13
#define NP_INT_NR  11
#define PF_INT_NR  14
#define SF_INT_NR  12
#define TS_INT_NR  10

#define NULL_ERROR_CODE (IU16)0

/*
   Intel IDT Error Code format.
 */
#define IDT_VECTOR_MASK 0xff
#define IDT_VECTOR_SHIFT   3
#define IDT_INDICATOR_BIT  2

/*
   Interrupt/Fault Status.
 */
GLOBAL BOOL doing_contributory;
GLOBAL BOOL doing_page_fault;
GLOBAL BOOL doing_double_fault;
GLOBAL BOOL doing_fault;	/* true: FAULT, false: TRAP or ABORT */
GLOBAL ISM32 EXT;			/* external/internal source */
GLOBAL IU32 CCPU_save_EIP;	/* IP at start of instruction */

/*
   Prototype our internal functions.
 */
LOCAL VOID check_for_double_fault IPT1(IU16, xcode);

LOCAL VOID check_for_shutdown IPT1(IU16, xcode);

LOCAL VOID benign_exception  IPT3( ISM32, nmbr, ISM32, source, IU16, xcode);

LOCAL VOID contributory_exception  IPT3( IU16, selector, ISM32, nmbr, IU16, xcode);

LOCAL VOID contributory_idt_exception  IPT3( IU16, vector, ISM32, nmbr, IU16, xcode);

LOCAL char *faultstr IPT1(ISM32, nmbr );


/*
   =====================================================================
   INTERNAL ROUTINES START HERE.
   =====================================================================
 */

LOCAL char *faultstr IFN1(ISM32, nmbr )
{
	char *faulttable[] =
	{
		"DIV", "DBG", "NMI", "BPT",
		"OVF", "BND", "OPC", "NAV",
		"DF", "9", "TSS", "NP", "SF",
		"GP", "PF", "15", "FPE", "ALN"
	};
	SAVED char buf[4];

	if (nmbr > 16)
	{
		sprintf(buf, "%d", nmbr);
		return buf;
	}
	else
		return faulttable[nmbr];
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Determine if things are so bad we need a double fault.             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID 
check_for_double_fault IFN1( IU16, xcode)
   {
   if ( doing_contributory || doing_page_fault )
      DF(xcode);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Determine if things are so bad we need to close down.              */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID check_for_shutdown IFN1(IU16, xcode)
   {
   if ( doing_double_fault )
      {
      doing_contributory = FALSE;
      doing_page_fault = FALSE;
      doing_double_fault = FALSE;
      EXT = INTERNAL;

      /* force a reset - see schematic for AT motherboard */
      c_cpu_reset();

#ifdef	PIG
      save_last_xcptn_details("Exception:- Shutdown @%2d\n", xcode, 0, 0, 0, 0);
      ccpu_synch_count++;
      pig_cpu_action = CHECK_ALL;
      c_cpu_unsimulate();
#endif	/* PIG */

      /* then carry on */
      c_cpu_continue();   /* DOES NOT RETURN */
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Handle Benign Exception                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
benign_exception
       	    	               
IFN3(
	ISM32, nmbr,	/* exception number */
	ISM32, source,	/* internal/external interrupt cause */
	IU16, xcode	/* insignia exception code */
    )


   {
   SET_EIP(CCPU_save_EIP);

#ifdef NTVDM
   {
   extern BOOL host_exint_hook IPT2(IS32, exp_no, IS32, error_code);

   if(GET_PE() && host_exint_hook((IS32) nmbr, NULL_ERROR_CODE))
	c_cpu_continue();	/* DOES NOT RETURN */
   }
#endif

   /* Set default mode up */
   SET_OPERAND_SIZE(GET_SR_AR_X(CS_REG));
   SET_ADDRESS_SIZE(GET_SR_AR_X(CS_REG));
   SET_POP_DISP(0);

   EXT = source;
   check_exception_env();
#ifdef	PIG
   save_last_xcptn_details("Exception:- #%s-%d @%2d \n", (IUH)faultstr(nmbr), nmbr, xcode, 0, 0);
#endif	/* PIG */
   if (show_exceptions){
	fprintf(trace_file, "(%04x:%08x)Exception:- %d.\n",
		       GET_CS_SELECTOR(), GET_EIP(), nmbr);
	if (trap_exceptions) force_yoda();
   }
	took_absolute_toc = TRUE;
   do_intrupt((IU16)nmbr, FALSE, FALSE, NULL_ERROR_CODE);

   c_cpu_continue();   /* DOES NOT RETURN */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Handle Contributory Exception                                      */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
contributory_exception
       	    		               
IFN3(
	IU16, selector,	/* failing selector */
	ISM32, nmbr,	/* exception number */
	IU16, xcode	/* insignia exception code */
    )


   {
   IU16 error_code;


   /* check if exception caused by external caller */
   check_interface_active(nmbr);

   check_for_shutdown(xcode);
   check_for_double_fault(xcode);

   doing_contributory = TRUE;

   error_code = (selector & 0xfffc) | EXT;

   SET_EIP(CCPU_save_EIP);

#ifdef NTVDM
    {
	extern BOOL host_exint_hook IPT2(IS32, exp_no, IS32, error_code);

	if(GET_PE() && host_exint_hook((IS32) nmbr, (IS32)error_code))
        doing_contributory = FALSE;
	    c_cpu_continue();	    /* DOES NOT RETURN */
    }
#endif

   /* Set default mode up */
   SET_OPERAND_SIZE(GET_SR_AR_X(CS_REG));
   SET_ADDRESS_SIZE(GET_SR_AR_X(CS_REG));
   SET_POP_DISP(0);

   EXT = INTERNAL;
   check_exception_env();
#ifdef	PIG
   save_last_xcptn_details("Exception:- #%s-%d(%04x) @%2d\n", (IUH)faultstr(nmbr), nmbr, error_code, xcode, 0);
#endif	/* PIG */
   if (show_exceptions){
	fprintf(trace_file, "(%04x:%08x)Exception:- %d(%04x).\n",
		       GET_CS_SELECTOR(), GET_EIP(), nmbr, error_code);
        if (trap_exceptions) force_yoda();
   }
	took_absolute_toc = TRUE;
   do_intrupt((IU16)nmbr, FALSE, TRUE, error_code);

   c_cpu_continue();   /* DOES NOT RETURN */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Handle Contributory Exception (Via IDT).                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
contributory_idt_exception
       	    	               
IFN3(
	IU16, vector,	/* failing interrupt vector */
	ISM32, nmbr,	/* exception number */
	IU16, xcode	/* insignia exception code */
    )


   {
   IU16 error_code;

   /* check if exception caused by external caller */
   check_interface_active(nmbr);

   check_for_shutdown(xcode);
   check_for_double_fault(xcode);

   doing_contributory = TRUE;
   error_code = ((vector & IDT_VECTOR_MASK) << IDT_VECTOR_SHIFT)
		| IDT_INDICATOR_BIT
		| EXT;

   SET_EIP(CCPU_save_EIP);

#ifdef NTVDM
      {
	  extern BOOL host_exint_hook IPT2(IS32, exp_no, IS32, error_code);

	  if(GET_PE() && host_exint_hook((IS32) nmbr, (IS32)error_code))
          doing_contributory = FALSE;
	      c_cpu_continue();	/* DOES NOT RETURN */
      }
#endif

   /* Set default mode up */
   SET_OPERAND_SIZE(GET_SR_AR_X(CS_REG));
   SET_ADDRESS_SIZE(GET_SR_AR_X(CS_REG));
   SET_POP_DISP(0);

   EXT = INTERNAL;
   check_exception_env();
#ifdef	PIG
   save_last_xcptn_details("Exception:- %s-%d(%04x) @%2d\n", (IUH)faultstr(nmbr), nmbr, error_code, xcode, 0);
#endif	/* PIG */
   if (show_exceptions){
	if ( GET_IDT_LIMIT() != 0 ){
           fprintf(trace_file, "(%04x:%08x)Exception:- %d(%04x).\n",
                       GET_CS_SELECTOR(), GET_EIP(), nmbr, error_code);
           if (trap_exceptions) force_yoda();
	}
   }
	took_absolute_toc = TRUE;
   do_intrupt((IU16)nmbr, FALSE, TRUE, error_code);

   c_cpu_continue();   /* DOES NOT RETURN */
   }


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Interrupt Table Too Small/Double Fault Exception.                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
DF

IFN1(
	IU16, xcode	/* insignia exception code */
    )
   {
   doing_fault = FALSE;

   if ( GET_PE() == 1 )
      {
      check_for_shutdown(xcode);
      doing_double_fault = TRUE;
      }

   SET_EIP(CCPU_save_EIP);

#ifdef NTVDM
      {
	  extern BOOL host_exint_hook IPT2(IS32, exp_no, IS32, error_code);

	  if(GET_PE() && host_exint_hook((IS32) DF_INT_NR, (IS32)NULL_ERROR_CODE))
            doing_double_fault = FALSE;
		    c_cpu_continue(); /* DOES NOT RETURN */
      }
#endif

   /* Set default mode up */
   SET_OPERAND_SIZE(GET_SR_AR_X(CS_REG));
   SET_ADDRESS_SIZE(GET_SR_AR_X(CS_REG));
   SET_POP_DISP(0);

   EXT = INTERNAL;
   check_exception_env();
#ifdef	PIG
   save_last_xcptn_details("Exception:- #DF-8 @%2d\n", xcode, 0, 0, 0, 0);
#endif	/* PIG */
   if (show_exceptions){
        if ( GET_IDT_LIMIT() != 0 ){
           fprintf(trace_file, "(%04x:%08x)Exception:- %d.\n",
			  GET_CS_SELECTOR(), GET_EIP(), DF_INT_NR);
           if (trap_exceptions) force_yoda();
        }
   }
	took_absolute_toc = TRUE;
   do_intrupt((IU16)DF_INT_NR, FALSE, TRUE, NULL_ERROR_CODE);

   c_cpu_continue();   /* DOES NOT RETURN */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* General Protection Exception.                                      */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID GP  IFN2( IU16, selector, IU16, xcode)
   {
   doing_fault = TRUE;
   contributory_exception(selector, GP_INT_NR, xcode);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* General Protection Exception. (Via IDT)                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID GP_INT  IFN2( IU16, vector, IU16, xcode)
   {
   doing_fault = TRUE;
   contributory_idt_exception(vector, GP_INT_NR, xcode);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Divide Error Exception.                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID Int0 IFN0 ()
   {
   doing_fault = TRUE;
   if ( GET_PE() == 1 )
      {
      doing_contributory = TRUE;
      }

   SET_EIP(CCPU_save_EIP);

#ifdef NTVDM
      {
	  extern BOOL host_exint_hook IPT2(IS32, exp_no, IS32, error_code);

	  if(GET_PE() && host_exint_hook((IS32) I0_INT_NR, (IS32)NULL_ERROR_CODE))
          doing_fault = FALSE;
          doing_contributory = FALSE;
	      c_cpu_continue(); /* DOES NOT RETURN */
      }
#endif

   /* Set default mode up */
   SET_OPERAND_SIZE(GET_SR_AR_X(CS_REG));
   SET_ADDRESS_SIZE(GET_SR_AR_X(CS_REG));
   SET_POP_DISP(0);

   EXT = INTERNAL;

   check_exception_env();
#ifdef	PIG
   save_last_xcptn_details("Exception:- #DIV-0\n", 0, 0, 0, 0, 0);
#endif	/* PIG */
   if (show_exceptions){
        fprintf(trace_file, "(%04x:%08x)Exception:- %d.\n",
		       GET_CS_SELECTOR(), GET_EIP(), I0_INT_NR);
        if (trap_exceptions) force_yoda();
   }
	took_absolute_toc = TRUE;
   do_intrupt((IU16)I0_INT_NR, FALSE, FALSE, NULL_ERROR_CODE);

   c_cpu_continue();   /* DOES NOT RETURN */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Single Step Exception. (FAULT)                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
Int1_f()
   {
   doing_fault = TRUE;
   benign_exception(I1_INT_NR, EXTERNAL, -1);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Single Step Exception. (TRAP)                                      */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
Int1_t()
   {
   doing_fault = FALSE;
   benign_exception(I1_INT_NR, EXTERNAL, -1);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Bounds Check Exception.                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
Int5()
   {
   doing_fault = TRUE;
   benign_exception(I5_INT_NR, INTERNAL, -1);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Invalid Opcode Exception.                                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
Int6()
   {
   doing_fault = TRUE;
   benign_exception(I6_INT_NR, INTERNAL, -1);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* NPX Not Available Exception.                                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
Int7()
   {
   doing_fault = TRUE;
   benign_exception(I7_INT_NR, INTERNAL, -1);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* NPX Error Exception.                                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
Int16()
   {
   doing_fault = TRUE;
   benign_exception(I16_INT_NR, EXTERNAL, -1);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Not Present Exception.                                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID NP  IFN2( IU16, selector, IU16, xcode)
   {
   doing_fault = TRUE;
   contributory_exception(selector, NP_INT_NR, xcode);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Not Present Exception. (Via IDT)                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
NP_INT

IFN2(
	IU16, vector,
	IU16, xcode
    )

   {
   doing_fault = TRUE;
   contributory_idt_exception(vector, NP_INT_NR, xcode);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Page Fault Exception.                                              */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
PF
       	          
IFN2(
	IU16, page_error,	/* correctly formatted page fault error code */
	IU16, xcode
    )


   {
   /* check if exception caused by external caller */
   check_interface_active(PF_INT_NR);

   doing_fault = TRUE;

   check_for_shutdown(xcode);

   /* Check for double page fault */
   if ( doing_page_fault )
      DF(xcode);

   doing_page_fault = TRUE;

   SET_EIP(CCPU_save_EIP);

#ifdef NTVDM
      {
	  extern BOOL host_exint_hook IPT2(IS32, exp_no, IS32, error_code);

	  if(GET_PE() && host_exint_hook((IS32) PF_INT_NR, (IS32)page_error))
          doing_fault = FALSE;
          doing_page_fault = FALSE;
	      c_cpu_continue(); /* DOES NOT RETURN */
      }
#endif

   /* Set default mode up */
   SET_OPERAND_SIZE(GET_SR_AR_X(CS_REG));
   SET_ADDRESS_SIZE(GET_SR_AR_X(CS_REG));
   SET_POP_DISP(0);

   check_exception_env();
#ifdef	PIG
   save_last_xcptn_details("Exception:- #PF-14(%04x) CR2=%08x @%2d\n", page_error, GET_CR(CR_PFLA), xcode, 0, 0);
#endif	/* PIG */
   if (show_exceptions){
	fprintf(trace_file, "(%04x:%08x)Exception:- %d(%04x) CR2=%08x.\n",
           GET_CS_SELECTOR(), GET_EIP(), PF_INT_NR, page_error, GET_CR(CR_PFLA));
        if (trap_exceptions) force_yoda();
   }
	took_absolute_toc = TRUE;
   do_intrupt((IU16)PF_INT_NR, FALSE, TRUE, page_error);

   c_cpu_continue();   /* DOES NOT RETURN */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Stack Fault Exception.                                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SF
                 
IFN2(
	IU16, selector,
	IU16, xcode
    )

   {
   doing_fault = TRUE;
   contributory_exception(selector, SF_INT_NR, xcode);
   }


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Task Switch Exception.                                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
TS
                 
IFN2(
	IU16, selector,
	IU16, xcode
    )

   {
   doing_fault = TRUE;
   contributory_exception(selector, TS_INT_NR, xcode);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_xfer.h ===
/*[

c_xfer.h

Transfer of Control Support.
----------------------------

LOCAL CHAR SccsID[]="@(#)c_xfer.h	1.5 02/17/95";

]*/


/*
   Bit mapped identities (caller_id) for the invokers of far
   transfers of control.
 */
#define CALL_ID 0
#define JMP_ID  1
#define INT_ID  0

/*
   Legal far destinations (dest_type).
 */

/* greater privilege is mapped directly to the Intel privilege */
#define MORE_PRIVILEGE0 0
#define MORE_PRIVILEGE1 1
#define MORE_PRIVILEGE2 2
/* our own (arbitary) mappings */
#define SAME_LEVEL      3
#define LOWER_PRIVILEGE 4
#define NEW_TASK        5


IMPORT VOID update_relative_ip
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID validate_far_dest
                           
IPT6(
	IU16 *, cs,
	IU32 *, ip,
	IU32 *, descr_addr,
	IU8 *, count,
	ISM32 *, dest_type,
	ISM32, caller_id

   );

IMPORT VOID validate_gate_dest
                   
IPT4(
	ISM32, caller_id,
	IU16, new_cs,
	IU32 *, descr_addr,
	ISM32 *, dest_type

   );

IMPORT ISM32 validate_task_dest
           
IPT2(
	IU16, selector,
	IU32 *, descr_addr

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_tsksw.h ===
/*[

c_tsksw.h

LOCAL CHAR SccsID[]="@(#)c_tsksw.h	1.5 02/09/94";

Task Switch Support.
--------------------

]*/


/*
   Switch Task: Control Options.
 */
#define NESTING       1
#define RETURNING     1
#define NOT_NESTING   0
#define NOT_RETURNING 0


IMPORT VOID switch_tasks
                       
IPT5(
	BOOL, returning,
	BOOL, nesting,
	IU16, TSS_selector,
	IU32, descr,
	IU32, return_ip

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_tsksw.c ===
/*[

c_tsksw.c

LOCAL CHAR SccsID[]="@(#)c_tsksw.c	1.11 03/03/95";

Task Switch Support.
--------------------

]*/


#include <stdio.h>
#include <insignia.h>

#include <host_def.h>

#include <xt.h>
#include CpuH
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_tsksw.h>
#include <c_page.h>
#include <mov.h>
#include <fault.h>

/*[

   The 286 TSS is laid out as follows:-

      =============================
      | Back Link to TSS Selector | +00 =
      | SP for CPL 0              | +02 *
      | SS for CPL 0              | +04 *
      | SP for CPL 1              | +06 * Initial Stacks (STATIC)
      | SS for CPL 1              | +08 *
      | SP for CPL 2              | +0a *
      | SS for CPL 2              | +0c *
      | IP                        | +0e =
      | FLAG Register             | +10 =
      | AX                        | +12 =
      | CX                        | +14 =
      | DX                        | +16 =
      | BX                        | +18 =
      | SP                        | +1a = Current State (DYNAMIC)
      | BP                        | +1c =
      | SI                        | +1e =
      | DI                        | +20 =
      | ES                        | +22 =
      | CS                        | +24 =
      | SS                        | +26 =
      | DS                        | +28 =
      | Task LDT Selector         | +2a *
      =============================

   The 386 TSS is laid out as follows:-

      ===========================================
      |         0          | Back Link          | +00 =
      |               ESP for CPL 0             | +04 *
      |         0          | SS for CPL 0       | +08 *
      |               ESP for CPL 1             | +0c *
      |         0          | SS for CPL 1       | +10 *
      |               ESP for CPL 2             | +14 *
      |         0          | SS for CPL 2       | +18 *
      |                   CR3                   | +1c *
      |                   EIP                   | +20 =
      |                  EFLAG                  | +24 =
      |                   EAX                   | +28 =
      |                   ECX                   | +2c =
      |                   EDX                   | +30 =
      |                   EBX                   | +34 =
      |                   ESP                   | +38 =
      |                   EBP                   | +3c =
      |                   ESI                   | +40 =
      |                   EDI                   | +44 =
      |         0          |         ES         | +48 =
      |         0          |         CS         | +4c =
      |         0          |         SS         | +50 =
      |         0          |         DS         | +54 =
      |         0          |         FS         | +58 =
      |         0          |         GS         | +5c =
      |         0          |    LDT Selector    | +60 *
      | I/O Map Base Addr. |          0       |T| +64 *
      |-----------------------------------------|
      |                   ...                   |
      |-----------------------------------------|
      | I/O Permission Bit Map                  | +I/O Map Base Addr.
      |                                         |
      |11111111|                                |
      ===========================================

]*/

/*
   Prototype our internal functions.
 */
LOCAL VOID load_LDT_in_task_switch
       
IPT1(
	IU16, tss_selector

   );

LOCAL VOID load_data_seg_new_task
           
IPT2(
	ISM32, indx,
	IU16, selector

   );


#define IP_OFFSET_IN_286_TSS 0x0e
#define IP_OFFSET_IN_386_TSS 0x20

#define CR3_OFFSET_IN_386_TSS 0x1c

#define LOCAL_BRK_ENABLE 0x155   /* LE,L3,L2,L1 and L0 bits of DCR */

/*
   =====================================================================
   INTERNAL FUNCTIONS STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load LDT selector during a task switch.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
load_LDT_in_task_switch
                 
IFN1(
	IU16, tss_selector
    )


   {
   IU16 selector;
   IU32 descr_addr;
   CPU_DESCR entry;

   /* The selector is already loaded into LDTR */
   selector = GET_LDT_SELECTOR();

   /* A null selector can be left alone */
   if ( !selector_is_null(selector) )
      {
      /* must be in GDT */
      if ( selector_outside_GDT(selector, &descr_addr) )
	 {
	 SET_LDT_SELECTOR(0);   /* invalidate selector */
	 TS(tss_selector, FAULT_LOADLDT_SELECTOR);
	 }
      
      read_descriptor_linear(descr_addr, &entry);

      /* is it really a LDT segment */
      if ( descriptor_super_type(entry.AR) != LDT_SEGMENT )
	 {
	 SET_LDT_SELECTOR(0);   /* invalidate selector */
	 TS(tss_selector, FAULT_LOADLDT_NOT_AN_LDT);
	 }
      
      /* must be present */
      if ( GET_AR_P(entry.AR) == NOT_PRESENT )
	 {
	 SET_LDT_SELECTOR(0);   /* invalidate selector */
	 TS(tss_selector, FAULT_LOADLDT_NOTPRESENT);
	 }

      /* ok, good selector, load register */
      SET_LDT_BASE(entry.base);
      SET_LDT_LIMIT(entry.limit);
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load a Data Segment Register (DS, ES, FS, GS) during               */
/* a Task Switch .                                                    */
/* Take #GP(selector) if segment not valid                            */
/* Take #NP(selector) if segment not present                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
load_data_seg_new_task
       		    	               
IFN2(
	ISM32, indx,	/* Segment Register identifier */
	IU16, selector	/* value to be loaded */
    )


   {
   load_data_seg(indx, selector);

   /* Reload pseudo descriptors if V86 Mode */
   if ( GET_VM() == 1 )
      load_pseudo_descr(indx);
   }


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Switch tasks                                                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
switch_tasks
       	    	    	    		    	                              
IFN5(
	BOOL, returning,	/* (I) if true doing return from task */
	BOOL, nesting,	/* (I) if true switch with nesting */
	IU16, TSS_selector,	/* (I) selector for new task */
	IU32, descr,	/* (I) memory address of new task descriptor */
	IU32, return_ip	/* (I) offset to restart old task at */
    )


   {
   IU16      old_tss;	/* components of old descriptor */
   IU8 old_AR;
   IU32     old_descr;

   CPU_DESCR new_tss;	/* components of new descriptor */

   IU32 tss_addr;	/* variables used to put/get TSS state */
   IU32 next_addr;
   IU32 flags;
   ISM32   save_cpl;
   IU8 T_byte;	/* Byte holding the T bit */

   IU32 ss_descr;	/* variables defining new SS and CS values */
   CPU_DESCR ss_entry;
   IU16 new_cs;
   IU32 cs_descr;
   CPU_DESCR cs_entry;

   IU32 pdbr;		/* New value for PDBR */

   if ( GET_TR_SELECTOR() == 0 )
      TS(TSS_selector, FAULT_SWTASK_NULL_TR_SEL);

   /* get new TSS info. */
   read_descriptor_linear(descr, &new_tss);

   /* calc address of descriptor related to old TSS */
   old_tss = GET_TR_SELECTOR();
   old_descr = GET_GDT_BASE() + GET_SELECTOR_INDEX_TIMES8(old_tss);
   old_AR = spr_read_byte(old_descr+5);

   /* SAVE OUTGOING STATE */

   if ( GET_TR_AR_SUPER() == XTND_BUSY_TSS )
      {
      /* check outgoing TSS is large enough to save current state */
      if ( GET_TR_LIMIT() < 0x67 )
	 {
	 TS(TSS_selector, FAULT_SWTASK_BAD_TSS_SIZE_1);
	 }
      
      tss_addr = GET_TR_BASE();
      next_addr = tss_addr + CR3_OFFSET_IN_386_TSS;

      spr_write_dword(next_addr, GET_CR(3));
      next_addr += 4;

      spr_write_dword(next_addr, return_ip);
      next_addr += 4;

      flags = c_getEFLAGS();
      if ( returning )
	 flags = flags & ~BIT14_MASK;   /* clear NT */
      spr_write_dword(next_addr, (IU32)flags);
#ifdef PIG
      /* Note the possibility of unknown flags "pushed" */
      record_flags_addr(next_addr);
#endif /* PIG */
      next_addr += 4;

      spr_write_dword(next_addr, GET_EAX());
      next_addr += 4;
      spr_write_dword(next_addr, GET_ECX());
      next_addr += 4;
      spr_write_dword(next_addr, GET_EDX());
      next_addr += 4;
      spr_write_dword(next_addr, GET_EBX());
      next_addr += 4;
      spr_write_dword(next_addr, GET_ESP());
      next_addr += 4;
      spr_write_dword(next_addr, GET_EBP());
      next_addr += 4;
      spr_write_dword(next_addr, GET_ESI());
      next_addr += 4;
      spr_write_dword(next_addr, GET_EDI());
      next_addr += 4;
      spr_write_word(next_addr, GET_ES_SELECTOR());
      next_addr += 4;
      spr_write_word(next_addr, GET_CS_SELECTOR());
      next_addr += 4;
      spr_write_word(next_addr, GET_SS_SELECTOR());
      next_addr += 4;
      spr_write_word(next_addr, GET_DS_SELECTOR());
      next_addr += 4;
      spr_write_word(next_addr, GET_FS_SELECTOR());
      next_addr += 4;
      spr_write_word(next_addr, GET_GS_SELECTOR());
      }
   else   /* 286 TSS */
      {
      /* check outgoing TSS is large enough to save current state */
      if ( GET_TR_LIMIT() < 0x29 )
	 {
	 TS(TSS_selector, FAULT_SWTASK_BAD_TSS_SIZE_2);
	 }
      
      tss_addr = GET_TR_BASE();
      next_addr = tss_addr + IP_OFFSET_IN_286_TSS;

      spr_write_word(next_addr, (IU16)return_ip);
      next_addr += 2;

      flags = getFLAGS();
      if ( returning )
	 flags = flags & ~BIT14_MASK;   /* clear NT */
      spr_write_word(next_addr, (IU16)flags);
#ifdef PIG
      /* Note the possibility of unknown flags "pushed" */
      record_flags_addr(next_addr);
#endif /* PIG */
      next_addr += 2;

      spr_write_word(next_addr, GET_AX());
      next_addr += 2;
      spr_write_word(next_addr, GET_CX());
      next_addr += 2;
      spr_write_word(next_addr, GET_DX());
      next_addr += 2;
      spr_write_word(next_addr, GET_BX());
      next_addr += 2;
      spr_write_word(next_addr, GET_SP());
      next_addr += 2;
      spr_write_word(next_addr, GET_BP());
      next_addr += 2;
      spr_write_word(next_addr, GET_SI());
      next_addr += 2;
      spr_write_word(next_addr, GET_DI());
      next_addr += 2;
      spr_write_word(next_addr, GET_ES_SELECTOR());
      next_addr += 2;
      spr_write_word(next_addr, GET_CS_SELECTOR());
      next_addr += 2;
      spr_write_word(next_addr, GET_SS_SELECTOR());
      next_addr += 2;
      spr_write_word(next_addr, GET_DS_SELECTOR());
      }

   /* LOAD TASK REGISTER */

   /* mark incoming TSS as busy */
   new_tss.AR |= BIT1_MASK;
   spr_write_byte(descr+5, (IU8)new_tss.AR);

   /* update task register */
   SET_TR_SELECTOR(TSS_selector);
   SET_TR_BASE(new_tss.base);
   SET_TR_LIMIT(new_tss.limit);
   SET_TR_AR_SUPER(descriptor_super_type(new_tss.AR));
   tss_addr = GET_TR_BASE();

   /* save back link if nesting, else make outgoing TSS available */
   if ( nesting )
      {
      spr_write_word(tss_addr, old_tss);
      }
   else
      {
      /* mark old TSS as available */
      old_AR = old_AR & ~BIT1_MASK;
      spr_write_byte(old_descr+5, old_AR);
      }

   /* Note: Exceptions now happen in the incoming task */

   /* EXTRACT NEW STATE */

   if ( GET_TR_AR_SUPER() == XTND_BUSY_TSS )
      {
      /* check new TSS is large enough to extract new state from */
      if ( GET_TR_LIMIT() < 0x67 )
	 TS(TSS_selector, FAULT_SWTASK_BAD_TSS_SIZE_3);

      next_addr = tss_addr + CR3_OFFSET_IN_386_TSS;
      pdbr = (IU32)spr_read_dword(next_addr);
      if ( pdbr != GET_CR(CR_PDBR) )
	 {
	 /* Only reload PDBR if diferent */
	 MOV_CR(CR_PDBR, pdbr);
	 }

      next_addr = tss_addr + IP_OFFSET_IN_386_TSS;

      SET_EIP(spr_read_dword(next_addr));   next_addr += 4;

      flags = (IU32)spr_read_dword(next_addr);   next_addr += 4;
      save_cpl = GET_CPL();
      SET_CPL(0);   /* act like highest privilege to set all flags */
      c_setEFLAGS(flags);
      SET_CPL(save_cpl);

      if ( flags & BIT17_MASK )
	 fprintf(stderr, "(Task Switch)Entering V86 Mode.\n");

      SET_EAX(spr_read_dword(next_addr));   next_addr += 4;
      SET_ECX(spr_read_dword(next_addr));   next_addr += 4;
      SET_EDX(spr_read_dword(next_addr));   next_addr += 4;
      SET_EBX(spr_read_dword(next_addr));   next_addr += 4;
      SET_ESP(spr_read_dword(next_addr));   next_addr += 4;
      SET_EBP(spr_read_dword(next_addr));   next_addr += 4;
      SET_ESI(spr_read_dword(next_addr));   next_addr += 4;
      SET_EDI(spr_read_dword(next_addr));   next_addr += 4;

      SET_ES_SELECTOR(spr_read_word(next_addr));   next_addr += 4;
      SET_CS_SELECTOR(spr_read_word(next_addr));   next_addr += 4;
      SET_SS_SELECTOR(spr_read_word(next_addr));   next_addr += 4;
      SET_DS_SELECTOR(spr_read_word(next_addr));   next_addr += 4;
      SET_FS_SELECTOR(spr_read_word(next_addr));   next_addr += 4;
      SET_GS_SELECTOR(spr_read_word(next_addr));   next_addr += 4;

      SET_LDT_SELECTOR(spr_read_word(next_addr));  next_addr += 4;
      T_byte = spr_read_byte(next_addr);
      }
   else   /* 286 TSS */
      {
      /* check new TSS is large enough to extract new state from */
      if ( GET_TR_LIMIT() < 0x2b )
	 TS(TSS_selector, FAULT_SWTASK_BAD_TSS_SIZE_4);

      next_addr = tss_addr + IP_OFFSET_IN_286_TSS;

      SET_EIP(spr_read_word(next_addr));   next_addr += 2;

      flags = (IU32)spr_read_word(next_addr);   next_addr += 2;
      save_cpl = GET_CPL();
      SET_CPL(0);   /* act like highest privilege to set all flags */
      setFLAGS(flags);
      SET_VM(0);
      SET_CPL(save_cpl);

      SET_AX(spr_read_word(next_addr));   next_addr += 2;
      SET_CX(spr_read_word(next_addr));   next_addr += 2;
      SET_DX(spr_read_word(next_addr));   next_addr += 2;
      SET_BX(spr_read_word(next_addr));   next_addr += 2;
      SET_SP(spr_read_word(next_addr));   next_addr += 2;
      SET_BP(spr_read_word(next_addr));   next_addr += 2;
      SET_SI(spr_read_word(next_addr));   next_addr += 2;
      SET_DI(spr_read_word(next_addr));   next_addr += 2;

      SET_ES_SELECTOR(spr_read_word(next_addr));   next_addr += 2;
      SET_CS_SELECTOR(spr_read_word(next_addr));   next_addr += 2;
      SET_SS_SELECTOR(spr_read_word(next_addr));   next_addr += 2;
      SET_DS_SELECTOR(spr_read_word(next_addr));   next_addr += 2;
      SET_FS_SELECTOR(0);
      SET_GS_SELECTOR(0);

      SET_LDT_SELECTOR(spr_read_word(next_addr));
      T_byte = 0;
      }

   /* invalidate cache entries for segment registers */
   SET_CS_AR_R(0);   SET_CS_AR_W(0);
   SET_DS_AR_R(0);   SET_DS_AR_W(0);
   SET_ES_AR_R(0);   SET_ES_AR_W(0);
   SET_SS_AR_R(0);   SET_SS_AR_W(0);
   SET_FS_AR_R(0);   SET_FS_AR_W(0);
   SET_GS_AR_R(0);   SET_GS_AR_W(0);

   /* update NT bit */
   if ( nesting )
      SET_NT(1);
   else
      if ( !returning )
	 SET_NT(0);
   
   /* update TS */
   SET_CR(CR_STAT, GET_CR(CR_STAT) | BIT3_MASK);

   /* kill local breakpoints */
   SET_DR(DR_DCR, GET_DR(DR_DCR) & ~LOCAL_BRK_ENABLE);

   /* set up trap on T-bit */
   if ( T_byte & BIT0_MASK )
      {
      SET_DR(DR_DSR, GET_DR(DR_DSR) | DSR_BT_MASK);
      }

   /* ERROR CHECKING */

   /* check new LDT and load hidden cache if ok */
   load_LDT_in_task_switch(TSS_selector);

   if ( GET_VM() == 1 )
      {
      SET_CPL(3);	/* set V86 privilege level */
      /* CS selector requires no checks */
      }
   else
      {
      /* change CPL to that of incoming code segment */
      SET_CPL(GET_SELECTOR_RPL(GET_CS_SELECTOR()));

      /* check new code selector... */
      new_cs = GET_CS_SELECTOR();
      if ( selector_outside_GDT_LDT(new_cs, &cs_descr) )
	 TS(new_cs, FAULT_SWTASK_BAD_CS_SELECTOR);

      read_descriptor_linear(cs_descr, &cs_entry);

      /* check type and privilege of new cs selector */
      switch ( descriptor_super_type(cs_entry.AR) )
	 {
      case CONFORM_NOREAD_CODE:
      case CONFORM_READABLE_CODE:
	 /* check code is present */
	 if ( GET_AR_P(cs_entry.AR) == NOT_PRESENT )
	    NP(new_cs, FAULT_SWTASK_CONFORM_CS_NP);

	 /* privilege check requires DPL <= CPL */
	 if ( GET_AR_DPL(cs_entry.AR) > GET_CPL() )
	    TS(new_cs, FAULT_SWTASK_ACCESS_1);
	 break;

      case NONCONFORM_NOREAD_CODE:
      case NONCONFORM_READABLE_CODE:
	 /* check code is present */
	 if ( GET_AR_P(cs_entry.AR) == NOT_PRESENT )
	    NP(new_cs, FAULT_SWTASK_NOCONFORM_CS_NP);

	 /* privilege check requires DPL == CPL */
	 if ( GET_AR_DPL(cs_entry.AR) != GET_CPL() )
	    TS(new_cs, FAULT_SWTASK_ACCESS_2);
	 break;
      
      default:
	 TS(new_cs, FAULT_SWTASK_BAD_SEG_TYPE);
	 }
      }

   /* code ok, load hidden cache */
   load_CS_cache(new_cs, cs_descr, &cs_entry);
#if 0
   /* retain operand size from gate until first instruction fetch */
   if ( GET_CS_AR_X() == USE16 )
      SET_OPERAND_SIZE(USE16);
   else   /* USE32 */
      SET_OPERAND_SIZE(USE32);
#endif

   /* check new SS and load if ok */
   if ( GET_VM() == 1 )
      {
      /* SS selector requires no checks */
      load_stack_seg(GET_SS_SELECTOR());
      load_pseudo_descr(SS_REG);
      }
   else
      {
      validate_SS_on_stack_change(GET_CPL(), GET_SS_SELECTOR(),
				  &ss_descr, &ss_entry);
      load_SS_cache(GET_SS_SELECTOR(), ss_descr, &ss_entry);
      }

   /* finally check new DS, ES, FS and GS */
   load_data_seg_new_task(DS_REG, GET_DS_SELECTOR());
   load_data_seg_new_task(ES_REG, GET_ES_SELECTOR());
   load_data_seg_new_task(FS_REG, GET_FS_SELECTOR());
   load_data_seg_new_task(GS_REG, GET_GS_SELECTOR());
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_xfer.c ===
/*[

c_xfer.c

LOCAL CHAR SccsID[]="@(#)c_xfer.c	1.14 02/17/95";

Transfer of Control Support.
----------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <c_xfer.h>
#include <c_page.h>
#include <fault.h>

/*
   Prototype our internal functions.
 */
LOCAL VOID read_call_gate
                       
IPT5(
	IU32, descr_addr,
	ISM32, super,
	IU16 *, selector,
	IU32 *, offset,
	IU8 *, count

   );

IMPORT IBOOL took_relative_jump;



/*
   =====================================================================
   INTERNAL FUNCTIONS STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Read call gate descriptor.                                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL VOID
read_call_gate
       	    		    	    	    	                              
IFN5(
	IU32, descr_addr,	/* (I) memory address of call gate descriptor */
	ISM32, super,	/* (I) descriptor type
			       (CALL_GATE|XTND_CALL_GATE) */
	IU16 *, selector,	/* (O) selector retrieved from descriptor */
	IU32 *, offset,	/* (O) offset retrieved from descriptor */
	IU8 *, count	/* (O) count retrieved from descriptor */
    )


   {
   /*
      The format of a gate descriptor is:-

	 ===========================
      +1 |        LIMIT 15-0       | +0
	 ===========================
      +3 |        SELECTOR         | +2
	 ===========================
      +5 |     AR     |    COUNT   | +4
	 ===========================
      +7 |       LIMIT 31-16       | +6
	 ===========================
   */

   IU32 first_dword;
   IU32 second_dword;

   /* read in descriptor with minimum interaction with memory */
   first_dword  = spr_read_dword(descr_addr);
   second_dword = spr_read_dword(descr_addr+4);

   /* unpack selector */
   *selector = first_dword >> 16;

   /* unpack lower bits of offset */
   *offset = first_dword & WORD_MASK;

   /* unpack count */
   *count = second_dword & BYTE_MASK;

   if ( super == XTND_CALL_GATE )
      {
      /* unpack higer bits of offset */
      *offset = second_dword & ~WORD_MASK | *offset;

      *count &= 0x0f;   /* 4-bit double word count */
      SET_OPERAND_SIZE(USE32);   /* Gate Overrides all else. */
      }
   else
      {
      *count &= 0x1f;   /* 5-bit word count */
      SET_OPERAND_SIZE(USE16);  /* Gate Overrides all else. */
      }
   }


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Update IP with relative offset. Check new IP is valid.             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
update_relative_ip
       	          
IFN1(
	IU32, rel_offset	/* sign extended relative offset */
    )


   {
   IU32 new_dest;

   new_dest = GET_EIP() + rel_offset;

   if ( GET_OPERAND_SIZE() == USE16 )
      new_dest &= WORD_MASK;

#ifdef	TAKE_REAL_MODE_LIMIT_FAULT

   if ( new_dest > GET_CS_LIMIT() )
      GP((IU16)0, FAULT_RM_REL_IP_CS_LIMIT);

#else	/* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#ifdef TAKE_PROT_MODE_LIMIT_FAILURE

      /* The Soft486 EDL CPU does not take Protected Mode limit failues
       * for the instructions with relative offsets, Jxx, LOOPxx, JCXZ,
       * JMP rel and CALL rel, or instructions with near offsets,
       * JMP near and CALL near.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

   if ( GET_PE() == 1 && GET_VM() == 0 )
      {
      if ( new_dest > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_PM_REL_IP_CS_LIMIT);
      }

#endif /* TAKE_PROT_MODE_LIMIT_FAILURE */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */

   SET_EIP(new_dest);
   took_relative_jump = TRUE;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Validate far call or far jump destination                          */
/* Take #GP if invalid or access check fail.                          */
/* Take #NP if not present.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
validate_far_dest
       		    		    	    	    	    	                                   
IFN6(
	IU16 *, cs,	/* (I/O) segment of target address */
	IU32 *, ip,	/* (I/O) offset  of target address */
	IU32 *, descr_addr,	/*   (O) related descriptor memory address */
	IU8 *, count,	/*   (O) call gate count(valid if CALL_GATE) */
	ISM32 *, dest_type,	/*   (O) destination type */
	ISM32, caller_id	/* (I)   bit mapped caller identifier */
    )


   {
   IU16 new_cs;
   IU32 new_ip;
   IU32 cs_descr_addr;
   IU8 AR;
   ISM32 super;

   new_cs = *cs;	/* take local copies */
   new_ip = *ip;

   *dest_type = SAME_LEVEL;   /* default to commonest type */

   if ( selector_outside_GDT_LDT(new_cs, &cs_descr_addr) )
      GP(new_cs, FAULT_FAR_DEST_SELECTOR);

   /* load access rights */
   AR = spr_read_byte(cs_descr_addr+5);

   /* validate possible types of target */
   switch ( super = descriptor_super_type((IU16)AR) )
      {
   case CONFORM_NOREAD_CODE:
   case CONFORM_READABLE_CODE:
      /* access check requires DPL <= CPL */
      if ( GET_AR_DPL(AR) > GET_CPL() )
	 GP(new_cs, FAULT_FAR_DEST_ACCESS_1);

      /* it must be present */
      if ( GET_AR_P(AR) == NOT_PRESENT )
	 NP(new_cs, FAULT_FAR_DEST_NP_CONFORM);
      break;

   case NONCONFORM_NOREAD_CODE:
   case NONCONFORM_READABLE_CODE:
      /* access check requires RPL <= CPL and DPL == CPL */
      if ( GET_SELECTOR_RPL(new_cs) > GET_CPL() ||
	   GET_AR_DPL(AR) != GET_CPL() )
	 GP(new_cs, FAULT_FAR_DEST_ACCESS_2);

      /* it must be present */
      if ( GET_AR_P(AR) == NOT_PRESENT )
	 NP(new_cs, FAULT_FAR_DEST_NP_NONCONFORM);
      break;
   
   case CALL_GATE:
   case XTND_CALL_GATE:
      /* Check gate present and access allowed */

      /* access check requires DPL >= RPL and DPL >= CPL */
      if (  GET_SELECTOR_RPL(new_cs) > GET_AR_DPL(AR) ||
	    GET_CPL() > GET_AR_DPL(AR) )
	 GP(new_cs, FAULT_FAR_DEST_ACCESS_3);

      if ( GET_AR_P(AR) == NOT_PRESENT )
	 NP(new_cs, FAULT_FAR_DEST_NP_CALLG);

      /* OK, get real destination from gate */
      read_call_gate(cs_descr_addr, super, &new_cs, &new_ip, count);

      validate_gate_dest(caller_id, new_cs, &cs_descr_addr, dest_type);
      break;
   
   case TASK_GATE:
      /* Check gate present and access allowed */

      /* access check requires DPL >= RPL and DPL >= CPL */
      if (  GET_SELECTOR_RPL(new_cs) > GET_AR_DPL(AR) ||
	    GET_CPL() > GET_AR_DPL(AR) )
	 GP(new_cs, FAULT_FAR_DEST_ACCESS_4);

      if ( GET_AR_P(AR) == NOT_PRESENT )
	 NP(new_cs, FAULT_FAR_DEST_NP_TASKG);

      /* OK, get real destination from gate */
      new_cs = spr_read_word(cs_descr_addr+2);

      /* Check out new destination */
      (void)validate_task_dest(new_cs, &cs_descr_addr);

      *dest_type = NEW_TASK;
      break;
   
   case AVAILABLE_TSS:
   case XTND_AVAILABLE_TSS:
      /* TSS must be in GDT */
      if ( GET_SELECTOR_TI(new_cs) == 1 )
	 GP(new_cs, FAULT_FAR_DEST_TSS_IN_LDT);

      /* access check requires DPL >= RPL and DPL >= CPL */
      if (  GET_SELECTOR_RPL(new_cs) > GET_AR_DPL(AR) ||
	    GET_CPL() > GET_AR_DPL(AR) )
	 GP(new_cs, FAULT_FAR_DEST_ACCESS_5);

      /* it must be present */
      if ( GET_AR_P(AR) == NOT_PRESENT )
	 NP(new_cs, FAULT_FAR_DEST_NP_TSS);

      *dest_type = NEW_TASK;
      break;
   
   default:
      GP(new_cs, FAULT_FAR_DEST_BAD_SEG_TYPE);   /* bad type for far destination */
      }

   *cs = new_cs;	/* Return final values */
   *ip = new_ip;
   *descr_addr = cs_descr_addr;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Validate transfer of control to a call gate destination.           */
/* Take #GP if invalid or access check fail.                          */
/* Take #NP if not present.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
validate_gate_dest
       	    		    	    	                         
IFN4(
	ISM32, caller_id,	/* (I) bit mapped caller identifier */
	IU16, new_cs,	/* (I) segment of target address */
	IU32 *, descr_addr,	/* (O) related descriptor memory address */
	ISM32 *, dest_type	/* (O) destination type */
    )


   {
   IU8 AR;

   *dest_type = SAME_LEVEL;	/* default */

   /* Check out new destination */
   if ( selector_outside_GDT_LDT(new_cs, descr_addr) )
      GP(new_cs, FAULT_GATE_DEST_SELECTOR);

   /* load access rights */
   AR = spr_read_byte((*descr_addr)+5);

   /* must be a code segment */
   switch ( descriptor_super_type((IU16)AR) )
      {
   case CONFORM_NOREAD_CODE:
   case CONFORM_READABLE_CODE:
      /* access check requires DPL <= CPL */
      if ( GET_AR_DPL(AR) > GET_CPL() )
	 GP(new_cs, FAULT_GATE_DEST_ACCESS_1);
      break;
   
   case NONCONFORM_NOREAD_CODE:
   case NONCONFORM_READABLE_CODE:
      /* access check requires DPL <= CPL */
      if ( GET_AR_DPL(AR) > GET_CPL() )
	 GP(new_cs, FAULT_GATE_DEST_ACCESS_2);

      /* but jumps must have DPL == CPL */
      if ( (caller_id & JMP_ID) && (GET_AR_DPL(AR) != GET_CPL()) )
	 GP(new_cs, FAULT_GATE_DEST_ACCESS_3);

      /* set MORE_PRIVILEGE(0|1|2) */
      if ( GET_AR_DPL(AR) < GET_CPL() )
	 *dest_type = GET_AR_DPL(AR);
      break;
   
   default:
      GP(new_cs, FAULT_GATE_DEST_BAD_SEG_TYPE);
      }

   if ( GET_VM() == 1 )
      {
      /*
	 We must be called by ISM32, so ensure we go to CPL 0 via
	 a 32-bit gate.
       */
      if ( *dest_type != MORE_PRIVILEGE0 || GET_OPERAND_SIZE() != USE32 )
	 GP(new_cs, FAULT_GATE_DEST_GATE_SIZE);
      }

   /* it must be present */
   if ( GET_AR_P(AR) == NOT_PRESENT )
      NP(new_cs, FAULT_GATE_DEST_NP);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Validate transfer of control to a task gate destination.           */
/* Take #GP if invalid or access check fail.                          */
/* Take #NP if not present.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IMPORT ISM32
validate_task_dest
       	    	               
IFN2(
	IU16, selector,	/* (I) segment of target address */
	IU32 *, descr_addr	/* (O) related descriptor memory address */
    )


   {
   IU8 AR;
   ISM32 super;

   /* must be in GDT */
   if ( selector_outside_GDT(selector, descr_addr) )
      GP(selector, FAULT_TASK_DEST_SELECTOR);
   
   /* load access rights */
   AR = spr_read_byte((*descr_addr)+5);

   /* is it really an available TSS segment */
   super = descriptor_super_type((IU16)AR);
   if ( super == AVAILABLE_TSS || super == XTND_AVAILABLE_TSS )
      ; /* ok */
   else
      GP(selector, FAULT_TASK_DEST_NOT_TSS);

   /* it must be present */
   if ( GET_AR_P(AR) == NOT_PRESENT )
      NP(selector, FAULT_TASK_DEST_NP);
   return super;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_xtrn.h ===
/*[

c_xtrn.h

External Interface Support.
---------------------------

LOCAL CHAR SccsID[]="@(#)c_xtrn.h	1.4 02/09/94";

]*/


/*
   Supported Interface Types.
 */
#define TYPE_I_W 1	/* (ISM32 , IU16) */
#define TYPE_W   2	/* (IU16) */

IMPORT VOID check_interface_active
       
IPT1(
	ISM32, except_nmbr

   );

typedef void CALL_CPU IPT0();
typedef void CALL_CPU_1 IPT1(ISM32, p1);
typedef void CALL_CPU_2 IPT2(ISM32, p1, IU16, p2);

IMPORT ISM32 call_cpu_function
                   
IPT4(
	CALL_CPU *,func,
	ISM32, type,
	ISM32, arg1,
	IU16, arg2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\daa.h ===
/* 
   daa.h

   Define all DAA CPU functions.
 */

/*
   static char SccsID[]="@(#)daa.h	1.5 09/01/94";
 */

IMPORT VOID DAA IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\c_xtrn.c ===
/*[

c_xtrn.c

LOCAL CHAR SccsID[]="@(#)c_xtrn.c	1.9 04/22/94";

Interface routines used by BIOS code.
-------------------------------------


]*/


#include <insignia.h>

#include <host_def.h>

#include <stdio.h>
#include <setjmp.h>
#include <xt.h>

#if 0
#include <sas.h>
#endif

#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <c_xtrn.h>
#include <c_mem.h>


LOCAL jmp_buf interface_abort;
LOCAL BOOL   interface_active;
LOCAL ISM32     interface_error;


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Call CPU Function and catch any resulting exception.               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL ISM32
call_cpu_function IFN4(CALL_CPU *, func, ISM32, type, ISM32, arg1, IU16, arg2)
   {
   if ( setjmp(interface_abort) == 0 )
      {
      interface_active = TRUE;

      /* Do the CPU Function */
      switch ( type )
	 {
      case 1:
	 (*(CALL_CPU_2 *)func)(arg1, arg2);
	 break;

      case 2:
	 (*(CALL_CPU_1 *)func)(arg2);
	 break;

      default:
	 break;
	 }

      interface_error = 0;   /* All went OK */
      }

   interface_active = FALSE;

   return interface_error;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Check if external interface is active.                             */
/* And Bail Out if it is!                                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
check_interface_active
                 
IFN1(
	ISM32, except_nmbr
    )


   {
   if ( interface_active )
      {
      /* YES CPU Function was called by an interface routine. */
      interface_error = except_nmbr;	/* save error */
      longjmp(interface_abort, 1);	/* Bail Out */
      }
   }

/*(
 *========================= Cpu_find_dcache_entry ==============================
 * Cpu_find_dcache_entry
 *
 * Purpose
 *	In an assembler CPU, this function allows non-CPU code to try and look
 *	up a selector in the dcache, rather than constructing it from memory.
 *	We don't have a dcache, but it gives us a chance to intercept
 *	CS selector calls, as the CS descriptor may not be available.
 *
 * Input
 *	selector,	The selector to look-up
 *
 * Outputs
 *	returns		TRUE if selector found (i.e. CS in our case)
 *	base		The linear address of the base of the segment.
 *
 * Description
 *	Just look out for CS, and return the stored base if we get it.
)*/

GLOBAL IBOOL 
Cpu_find_dcache_entry IFN2(IU16, seg, LIN_ADDR *, base)
{

	if (GET_CS_SELECTOR() == seg) {
		*base = GET_CS_BASE();
		return(TRUE);
	} else {
		return(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\das.h ===
/* 
   das.h

   Define all DAS CPU functions.
 */

/*
   static char SccsID[]="@(#)das.h	1.5 09/01/94";
 */

IMPORT VOID DAS IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\daa.c ===
/*[

daa.c

LOCAL CHAR SccsID[]="@(#)daa.c	1.5 02/09/94";

DAA CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <daa.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
DAA()
   {
   IU8 temp_al;

   temp_al = GET_AL();

   if ( (temp_al & 0xf) > 9 || GET_AF() )
      {
      temp_al += 6;
      SET_AF(1);
      }

   if ( GET_AL() > 0x99 || GET_CF() )
      {
      temp_al += 0x60;
      SET_CF(1);
      }

   SET_AL(temp_al);

   /* set ZF,SF,PF according to result */
   SET_ZF(temp_al == 0);
   SET_SF((temp_al & BIT7_MASK) != 0);
   SET_PF(pf_table[temp_al]);

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_OF(UNDEFINED_FLAG);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\das.c ===
/*[

das.c

LOCAL CHAR SccsID[]="@(#)das.c	1.5 02/09/94";

DAS CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <das.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
DAS()
   {
   IU8 temp_al;

   temp_al = GET_AL();

   if ( (temp_al & 0xf) > 9 || GET_AF() )
      {
      temp_al -= 6;
      SET_AF(1);
      }

   if ( GET_AL() > 0x99 || GET_CF() )
      {
      temp_al -= 0x60;
      SET_CF(1);
      }
   else if ( temp_al > 0x9f )
      {
      SET_CF(1);
      }

   SET_AL(temp_al);

   /* set ZF,SF,PF according to result */
   SET_ZF(temp_al == 0);
   SET_SF((temp_al & BIT7_MASK) != 0);
   SET_PF(pf_table[temp_al]);

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_OF(UNDEFINED_FLAG);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\dec.c ===
/*[

dec.c

LOCAL CHAR SccsID[]="@(#)dec.c	1.5 02/09/94";

DEC CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <dec.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'dec'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
DEC
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 msb;
   IU32 op1_msb;
   IU32 res_msb;

   msb = SZ2MSB(op_sz);

   result = *pop1 - 1 & SZ2MASK(op_sz);		/* Do operation */
   op1_msb = (*pop1  & msb) != 0;	/* Isolate all msb's */
   res_msb = (result & msb) != 0;
					/* Determine flags */
   SET_OF(op1_msb & !res_msb);		/* OF = op1 & !res */
					/* CF left unchanged */
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */
   SET_AF(((*pop1 ^ result) & BIT4_MASK) != 0);	/* AF = Bit 4 carry */
   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\div.c ===
/*[

div.c

LOCAL CHAR SccsID[]="@(#)div.c	1.8 02/12/95";

DIV CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <div.h>
#include <c_div64.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Unsigned Divide.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
DIV8
       	          
IFN1(
	IU32, op2	/* divisor operand */
    )


   {
   IU32 result;
   IU32 op1;

   if ( op2 == 0 )
      Int0();   /* Divide by Zero Exception */
   
   op1 = GET_AX();
   result = op1 / op2;		/* Do operation */

   if ( result & 0xff00 )
      Int0();   /* Result doesn't fit in destination */
   
   SET_AL(result);	/* Store Quotient */
   SET_AH(op1 % op2);	/* Store Remainder */

   /* 
    * PCBench attempts to distinguish between processors by checking for
    * the DIV8 instruction leaving all flags unchanged or clear. It is
    * important we behave through this test in the same way as the 'real'
    * 486 otherwise the app asks us to perform some unsupported ops.
    *
    * The real 486 has the following ('undefined') behaviour:
    *	CF set
    *   PF = pf_table[op2 - 1]
    *   AF = !( (op2 & 0xf) == 0 )
    *	ZF clear
    *	SF = (op2 <= 0x80)
    *   OF = some function of the actual division
    *
    * Given that the PCBench test is for a simple all-zero case, and that
    * implementing the above is a needless overhead on the assembler CPU,
    * we take the simplified form of ZF clear, CF set.
    */
#ifdef SET_UNDEFINED_DIV_FLAG
   SET_CF(1);
   SET_ZF(0);
   SET_SF(UNDEFINED_FLAG);
   SET_OF(UNDEFINED_FLAG);
   SET_PF(UNDEFINED_FLAG);
   SET_AF(UNDEFINED_FLAG);
#endif
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Unsigned Divide.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
DIV16
       	          
IFN1(
	IU32, op2	/* divisor operand */
    )


   {
   IU32 result;
   IU32 op1;

   if ( op2 == 0 )
      Int0();   /* Divide by Zero Exception */
   
   op1 = (IU32)GET_DX() << 16 | GET_AX();
   result = op1 / op2;		/* Do operation */

   if ( result & 0xffff0000 )
      Int0();   /* Result doesn't fit in destination */
   
   SET_AX(result);	/* Store Quotient */
   SET_DX(op1 % op2);	/* Store Remainder */

   /* Set all undefined flag(s) */
#ifdef SET_UNDEFINED_DIV_FLAG
   SET_CF(1);		/* see DIV8 for flag choice reasoning */
   SET_ZF(0);
   SET_OF(UNDEFINED_FLAG);
   SET_SF(UNDEFINED_FLAG);
   SET_PF(UNDEFINED_FLAG);
   SET_AF(UNDEFINED_FLAG);
#endif
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Unsigned Divide.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
DIV32
       	          
IFN1(
	IU32, op2	/* divisor operand */
    )


   {
   IU32 lr;   /* low result */
   IU32 hr;   /* high result */
   IU32 rem;  /* remainder */

   if ( op2 == 0 )
      Int0();   /* Divide by Zero Exception */
   
   hr = GET_EDX();
   lr = GET_EAX();
   divu64(&hr, &lr, op2, &rem);	/* Do operation */

   if ( hr )
      Int0();   /* Result doesn't fit in destination */
   
   SET_EAX(lr);	/* Store Quotient */
   SET_EDX(rem);	/* Store Remainder */

   /* Set all undefined flag(s) */
#ifdef SET_UNDEFINED_DIV_FLAG
   SET_CF(1);		/* see DIV8 for flag choice reasoning */
   SET_ZF(0);
   SET_OF(UNDEFINED_FLAG);
   SET_SF(UNDEFINED_FLAG);
   SET_PF(UNDEFINED_FLAG);
   SET_AF(UNDEFINED_FLAG);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\enter.c ===
/*[

enter.c

LOCAL CHAR SccsID[]="@(#)enter.c	1.7 01/19/95";

ENTER CPU functions.
--------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <enter.h>
#include <c_page.h>
#include <fault.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
ENTER16
       	    	               
IFN2(
	IU32, op1,	/* immediate data space required */
	IU32, op2	/* level (indicates parameters which must be copied) */
    )


   {
   IU32 frame_ptr;

   IS32  p_delta = 0;   /* posn of parameter relative to BP */
   IU32 p_addr;        /* memory address of parameter */
   IU32 param;         /* parameter read via BP */

   op2 &= 0x1f;   /* take level MOD 32 */

   /* check room on stack for new data */
   validate_stack_space(USE_SP, (ISM32)op2+1);

   /* check old parameters exist */
   if ( op2 > 1 )
      {
      /*
	 BP is pointing to the old stack before the parameters
	 were actually pushed, we therefore test for the presence
	 of the parameters by seeing if they could have been pushed,
	 if so they exist now.

	 We have to take care of the READ/WRITE stack addressability
	 ourselves. Because we have checked the new data can be
	 written we know the next call can not fail because of access
	 problems, however we don't yet know if the stack is readable.

	 Note we have been a bit severe on the paging unit because we
	 are asking if the old parameters could be written, if so they
	 can certainly be read from the point of view of the paging
	 unit!
       */
      /* do access check */
      if ( GET_SS_AR_R() == 0 )
	 SF((IU16)0, FAULT_ENTER16_ACCESS);

      /* now we know 'frigged' limit check is ok */
      validate_stack_space(USE_BP, (ISM32)op2-1);
      }

   /* all ok - process instruction */

   spush((IU32)GET_BP());		/* push BP */
   frame_ptr = GetStackPointer();	/* save (E)SP */

   if ( op2 > 0 )
      {
      /* level is >=1, copy stack parameters if they exist */
      while ( --op2 > 0 )
	 {
	 /* copy parameter */
	 p_delta -= 2;   /* decrement to next parameter */

	 /* calculate parameter address in 32/16bit arithmetic */
	 p_addr = get_current_BP() + p_delta;
	 if ( GET_SS_AR_X() == 0 )   /* look at SS 'B' bit */
	    p_addr &= WORD_MASK;

	 p_addr += GET_SS_BASE();

	 param = (IU32)vir_read_word(p_addr, NO_PHYSICAL_MAPPING);
	 spush(param);
	 }
      spush((IU32)frame_ptr);	/* save old (E)SP */
      }
   
   /* update (E)BP */
   set_current_BP(frame_ptr);

   /* finally allocate immediate data space on stack */
   if ( op1 )
      byte_change_SP((IS32)-op1);
   }

GLOBAL VOID
ENTER32
       	    	               
IFN2(
	IU32, op1,	/* immediate data space required */
	IU32, op2	/* level (indicates parameters which must be copied) */
    )


   {
   IU32 frame_ptr;

   IS32  p_delta = 0;   /* posn of parameter relative to EBP */
   IU32 p_addr;        /* memory address of parameter */
   IU32 param;         /* parameter read via EBP */

   op2 &= 0x1f;   /* take level MOD 32 */

   /* check room on stack for new data */
   validate_stack_space(USE_SP, (ISM32)op2+1);

   /* check old parameters exist */
   if ( op2 > 1 )
      {
      /*
	 EBP is pointing to the old stack before the parameters
	 were actually pushed, we therefore test for the presence
	 of the parameters by seeing if they could have been pushed,
	 if so they exist now.

	 We have to take care of the READ/WRITE stack addressability
	 ourselves. Because we have checked the new data can be
	 written we know the next call can not fail because of access
	 problems, however we don't yet know if the stack is readable.

	 Note we have been a bit severe on the paging unit because we
	 are asking if the old parameters could be written, if so they
	 can certainly be read from the point of view of the paging
	 unit!
       */
      /* do access check */
      if ( GET_SS_AR_R() == 0 )
	 SF((IU16)0, FAULT_ENTER32_ACCESS);

      /* now we know 'frigged' limit check is ok */
      validate_stack_space(USE_BP, (ISM32)op2-1);
      }

   /* all ok - process instruction */

   spush((IU32)GET_EBP());		/* push EBP */
   frame_ptr = GetStackPointer();	/* save (E)SP */

   if ( op2 > 0 )
      {
      /* level is >=1, copy stack parameters if they exist */
      while ( --op2 > 0 )
	 {
	 /* copy parameter */
	 p_delta -= 4;   /* decrement to next parameter */

	 /* calculate parameter address in 32/16bit arithmetic */
	 p_addr = get_current_BP() + p_delta;
	 if ( GET_SS_AR_X() == 0 )   /* look at SS 'B' bit */
	    p_addr &= WORD_MASK;

	 p_addr += GET_SS_BASE();

	 param = (IU32)vir_read_dword(p_addr, NO_PHYSICAL_MAPPING);
	 spush(param);
	 }
      spush((IU32)frame_ptr);	/* save old (E)SP */
      }
   
   /* update (E)BP */
   set_current_BP(frame_ptr);

   /* finally allocate immediate data space on stack */
   if ( op1 )
      byte_change_SP((IS32)-op1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\div.h ===
/* 
   div.h

   Define all DIV CPU functions.
 */

/*
   static char SccsID[]="@(#)div.h	1.4 02/09/94";
 */

IMPORT VOID DIV8
       
IPT1(
	IU32, op2

   );

IMPORT VOID DIV16
       
IPT1(
	IU32, op2

   );

IMPORT VOID DIV32
       
IPT1(
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\dec.h ===
/* 
   dec.h

   Define all DEC CPU functions.
 */

/*
   static char SccsID[]="@(#)dec.h	1.4 02/09/94";
 */

IMPORT VOID DEC
           
IPT2(
	IU32 *, pop1,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\enter.h ===
/* 
   enter.h

   Define all ENTER CPU functions.
 */

/*
   static char SccsID[]="@(#)enter.h	1.4 02/09/94";
 */

IMPORT VOID ENTER16
           
IPT2(
	IU32, op1,
	IU32, op2

   );

IMPORT VOID ENTER32
           
IPT2(
	IU32, op1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\evidfunc.h ===
extern void S_2451_SimpleByteWrite IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2454_SimpleWordWrite IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2457_SimpleDwordWrite IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2452_SimpleByteFill IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2455_SimpleWordFill IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2458_SimpleDwordFill IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2453_SimpleByteMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2456_SimpleWordMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2459_SimpleDwordMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2460_SimpleByteMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2461_SimpleWordMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2462_SimpleDwordMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2550_GenericByteWrite IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2553_GenericWordWrite IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2556_GenericDwordWrite IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2551_GenericByteFill IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2554_GenericWordFill IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2557_GenericDwordFill IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2552_GenericByteMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2555_GenericWordMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2558_GenericDwordMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2559_GenericByteMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2560_GenericWordMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2561_GenericDwordMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2463_UnchainedByteWrite_00_0e_01 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2469_UnchainedWordWrite_00_0e_01 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2475_UnchainedDwordWrite_00_0e_01 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2464_UnchainedByteFill_00_0e_01 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2470_UnchainedWordFill_00_0e_01 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2476_UnchainedDwordFill_00_0e_01 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2466_UnchainedByteMove_00_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2472_UnchainedWordMove_00_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2477_UnchainedDwordMove_00_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2517_UnchainedByteMove_00_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2520_UnchainedWordMove_00_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2523_UnchainedDwordMove_00_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2478_UnchainedByteWrite_01_0e_01 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2483_UnchainedWordWrite_01_0e_01 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2488_UnchainedDwordWrite_01_0e_01 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2479_UnchainedByteFill_01_0e_01 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2484_UnchainedWordFill_01_0e_01 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2489_UnchainedDwordFill_01_0e_01 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2480_UnchainedByteMove_01_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2485_UnchainedWordMove_01_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2490_UnchainedDwordMove_01_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2524_UnchainedByteMove_01_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2527_UnchainedWordMove_01_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2530_UnchainedDwordMove_01_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2491_UnchainedByteWrite_02_0e_01 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2496_UnchainedWordWrite_02_0e_01 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2501_UnchainedDwordWrite_02_0e_01 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2492_UnchainedByteFill_02_0e_01 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2497_UnchainedWordFill_02_0e_01 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2502_UnchainedDwordFill_02_0e_01 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2493_UnchainedByteMove_02_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2498_UnchainedWordMove_02_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2503_UnchainedDwordMove_02_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2531_UnchainedByteMove_02_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2534_UnchainedWordMove_02_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2537_UnchainedDwordMove_02_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2504_UnchainedByteWrite_03_0e_01 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2509_UnchainedWordWrite_03_0e_01 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2514_UnchainedDwordWrite_03_0e_01 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2505_UnchainedByteFill_03_0e_01 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2510_UnchainedWordFill_03_0e_01 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2515_UnchainedDwordFill_03_0e_01 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2506_UnchainedByteMove_03_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2511_UnchainedWordMove_03_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2516_UnchainedDwordMove_03_0e_01_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2538_UnchainedByteMove_03_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2541_UnchainedWordMove_03_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2544_UnchainedDwordMove_03_0e_01_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2936_Chain2ByteWrite_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2942_Chain2WordWrite_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2948_Chain2DwordWrite_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2938_Chain2ByteFill_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2944_Chain2WordFill_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2950_Chain2DwordFill_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2940_Chain2ByteMove_00_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2946_Chain2WordMove_00_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2952_Chain2DwordMove_00_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3017_Chain2ByteMove_00_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3019_Chain2WordMove_00_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3021_Chain2DwordMove_00_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2954_Chain2ByteWrite_01 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2960_Chain2WordWrite_01 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2966_Chain2DwordWrite_01 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2956_Chain2ByteFill_01 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2962_Chain2WordFill_01 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2968_Chain2DwordFill_01 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2958_Chain2ByteMove_01_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2964_Chain2WordMove_01_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2970_Chain2DwordMove_01_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3023_Chain2ByteMove_01_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3025_Chain2WordMove_01_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3027_Chain2DwordMove_01_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2972_Chain2ByteWrite_02 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2978_Chain2WordWrite_02 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2984_Chain2DwordWrite_02 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2974_Chain2ByteFill_02 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2980_Chain2WordFill_02 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2986_Chain2DwordFill_02 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2976_Chain2ByteMove_02_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2982_Chain2WordMove_02_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2988_Chain2DwordMove_02_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3029_Chain2ByteMove_02_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3031_Chain2WordMove_02_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3033_Chain2DwordMove_02_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2990_Chain2ByteWrite_03 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2996_Chain2WordWrite_03 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3002_Chain2DwordWrite_03 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2992_Chain2ByteFill_03 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2998_Chain2WordFill_03 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3004_Chain2DwordFill_03 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2994_Chain2ByteMove_03_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3000_Chain2WordMove_03_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3006_Chain2DwordMove_03_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3035_Chain2ByteMove_03_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3037_Chain2WordMove_03_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3039_Chain2DwordMove_03_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3008_Chain2ByteWrite_Copy IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3011_Chain2WordWrite_Copy IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3014_Chain2DwordWrite_Copy IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3009_Chain2ByteFill_Copy IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3012_Chain2WordFill_Copy IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3015_Chain2DwordFill_Copy IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3010_Chain2ByteMove_Copy_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3013_Chain2WordMove_Copy_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3016_Chain2DwordMove_Copy_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3041_Chain2ByteMove_Copy_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3042_Chain2WordMove_Copy_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3043_Chain2DwordMove_Copy_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2562_UnchainedByteWrite_00_08_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2617_UnchainedWordWrite_00_08_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2672_UnchainedDwordWrite_00_08_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2574_UnchainedByteFill_00_08_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2629_UnchainedWordFill_00_08_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2684_UnchainedDwordFill_00_08_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2587_UnchainedByteMove_00_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2642_UnchainedWordMove_00_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2696_UnchainedDwordMove_00_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2813_UnchainedByteMove_00_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2843_UnchainedWordMove_00_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2873_UnchainedDwordMove_00_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2563_UnchainedByteWrite_00_09_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2618_UnchainedWordWrite_00_09_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2673_UnchainedDwordWrite_00_09_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2575_UnchainedByteFill_00_09_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2630_UnchainedWordFill_00_09_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2685_UnchainedDwordFill_00_09_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2590_UnchainedByteMove_00_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2645_UnchainedWordMove_00_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2697_UnchainedDwordMove_00_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2816_UnchainedByteMove_00_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2846_UnchainedWordMove_00_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2874_UnchainedDwordMove_00_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2564_UnchainedByteWrite_00_0e_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2619_UnchainedWordWrite_00_0e_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2674_UnchainedDwordWrite_00_0e_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2577_UnchainedByteFill_00_0e_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2632_UnchainedWordFill_00_0e_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2686_UnchainedDwordFill_00_0e_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2592_UnchainedByteMove_00_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2647_UnchainedWordMove_00_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2698_UnchainedDwordMove_00_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2818_UnchainedByteMove_00_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2848_UnchainedWordMove_00_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2875_UnchainedDwordMove_00_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2565_UnchainedByteWrite_00_0f_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2620_UnchainedWordWrite_00_0f_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2675_UnchainedDwordWrite_00_0f_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2578_UnchainedByteFill_00_0f_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2633_UnchainedWordFill_00_0f_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2687_UnchainedDwordFill_00_0f_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2595_UnchainedByteMove_00_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2650_UnchainedWordMove_00_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2699_UnchainedDwordMove_00_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2821_UnchainedByteMove_00_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2851_UnchainedWordMove_00_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2876_UnchainedDwordMove_00_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2566_UnchainedByteWrite_00_10_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2621_UnchainedWordWrite_00_10_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2676_UnchainedDwordWrite_00_10_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2579_UnchainedByteFill_00_10_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2634_UnchainedWordFill_00_10_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2688_UnchainedDwordFill_00_10_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2597_UnchainedByteMove_00_10_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2652_UnchainedWordMove_00_10_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2700_UnchainedDwordMove_00_10_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2823_UnchainedByteMove_00_10_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2853_UnchainedWordMove_00_10_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2877_UnchainedDwordMove_00_10_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2567_UnchainedByteWrite_00_11_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2622_UnchainedWordWrite_00_11_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2677_UnchainedDwordWrite_00_11_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2580_UnchainedByteFill_00_11_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2635_UnchainedWordFill_00_11_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2689_UnchainedDwordFill_00_11_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2600_UnchainedByteMove_00_11_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2655_UnchainedWordMove_00_11_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2701_UnchainedDwordMove_00_11_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2826_UnchainedByteMove_00_11_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2856_UnchainedWordMove_00_11_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2878_UnchainedDwordMove_00_11_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2568_UnchainedByteWrite_00_16_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2623_UnchainedWordWrite_00_16_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2678_UnchainedDwordWrite_00_16_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2581_UnchainedByteFill_00_16_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2636_UnchainedWordFill_00_16_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2690_UnchainedDwordFill_00_16_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2602_UnchainedByteMove_00_16_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2657_UnchainedWordMove_00_16_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2702_UnchainedDwordMove_00_16_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2828_UnchainedByteMove_00_16_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2858_UnchainedWordMove_00_16_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2879_UnchainedDwordMove_00_16_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2569_UnchainedByteWrite_00_17_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2624_UnchainedWordWrite_00_17_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2679_UnchainedDwordWrite_00_17_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2582_UnchainedByteFill_00_17_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2637_UnchainedWordFill_00_17_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2691_UnchainedDwordFill_00_17_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2605_UnchainedByteMove_00_17_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2660_UnchainedWordMove_00_17_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2703_UnchainedDwordMove_00_17_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2831_UnchainedByteMove_00_17_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2861_UnchainedWordMove_00_17_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2880_UnchainedDwordMove_00_17_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2570_UnchainedByteWrite_00_18_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2625_UnchainedWordWrite_00_18_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2680_UnchainedDwordWrite_00_18_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2583_UnchainedByteFill_00_18_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2638_UnchainedWordFill_00_18_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2692_UnchainedDwordFill_00_18_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2607_UnchainedByteMove_00_18_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2662_UnchainedWordMove_00_18_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2704_UnchainedDwordMove_00_18_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2833_UnchainedByteMove_00_18_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2863_UnchainedWordMove_00_18_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2881_UnchainedDwordMove_00_18_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2571_UnchainedByteWrite_00_19_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2626_UnchainedWordWrite_00_19_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2681_UnchainedDwordWrite_00_19_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2584_UnchainedByteFill_00_19_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2639_UnchainedWordFill_00_19_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2693_UnchainedDwordFill_00_19_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2610_UnchainedByteMove_00_19_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2665_UnchainedWordMove_00_19_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2705_UnchainedDwordMove_00_19_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2836_UnchainedByteMove_00_19_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2866_UnchainedWordMove_00_19_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2882_UnchainedDwordMove_00_19_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2572_UnchainedByteWrite_00_1e_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2627_UnchainedWordWrite_00_1e_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2682_UnchainedDwordWrite_00_1e_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2585_UnchainedByteFill_00_1e_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2640_UnchainedWordFill_00_1e_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2694_UnchainedDwordFill_00_1e_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2612_UnchainedByteMove_00_1e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2667_UnchainedWordMove_00_1e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2706_UnchainedDwordMove_00_1e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2838_UnchainedByteMove_00_1e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2868_UnchainedWordMove_00_1e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2883_UnchainedDwordMove_00_1e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2573_UnchainedByteWrite_00_1f_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2628_UnchainedWordWrite_00_1f_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2683_UnchainedDwordWrite_00_1f_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2586_UnchainedByteFill_00_1f_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2641_UnchainedWordFill_00_1f_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2695_UnchainedDwordFill_00_1f_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2615_UnchainedByteMove_00_1f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2670_UnchainedWordMove_00_1f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2707_UnchainedDwordMove_00_1f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2841_UnchainedByteMove_00_1f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2871_UnchainedWordMove_00_1f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2884_UnchainedDwordMove_00_1f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2708_UnchainedByteWrite_01_00_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2711_UnchainedWordWrite_01_00_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2714_UnchainedDwordWrite_01_00_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2709_UnchainedByteFill_01_00_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2712_UnchainedWordFill_01_00_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2715_UnchainedDwordFill_01_00_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2710_UnchainedByteMove_01_00_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2713_UnchainedWordMove_01_00_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2716_UnchainedDwordMove_01_00_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2885_UnchainedByteMove_01_00_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2886_UnchainedWordMove_01_00_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2887_UnchainedDwordMove_01_00_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2717_UnchainedByteWrite_02_08_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2735_UnchainedWordWrite_02_08_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2753_UnchainedDwordWrite_02_08_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2721_UnchainedByteFill_02_08_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2739_UnchainedWordFill_02_08_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2757_UnchainedDwordFill_02_08_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2725_UnchainedByteMove_02_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2743_UnchainedWordMove_02_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2761_UnchainedDwordMove_02_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2888_UnchainedByteMove_02_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2898_UnchainedWordMove_02_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2908_UnchainedDwordMove_02_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2718_UnchainedByteWrite_02_09_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2736_UnchainedWordWrite_02_09_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2754_UnchainedDwordWrite_02_09_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2722_UnchainedByteFill_02_09_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2740_UnchainedWordFill_02_09_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2758_UnchainedDwordFill_02_09_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2728_UnchainedByteMove_02_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2746_UnchainedWordMove_02_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2762_UnchainedDwordMove_02_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2891_UnchainedByteMove_02_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2901_UnchainedWordMove_02_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2909_UnchainedDwordMove_02_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2719_UnchainedByteWrite_02_0e_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2737_UnchainedWordWrite_02_0e_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2755_UnchainedDwordWrite_02_0e_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2723_UnchainedByteFill_02_0e_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2741_UnchainedWordFill_02_0e_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2759_UnchainedDwordFill_02_0e_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2730_UnchainedByteMove_02_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2748_UnchainedWordMove_02_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2763_UnchainedDwordMove_02_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2893_UnchainedByteMove_02_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2903_UnchainedWordMove_02_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2910_UnchainedDwordMove_02_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2720_UnchainedByteWrite_02_0f_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2738_UnchainedWordWrite_02_0f_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2756_UnchainedDwordWrite_02_0f_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2724_UnchainedByteFill_02_0f_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2742_UnchainedWordFill_02_0f_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2760_UnchainedDwordFill_02_0f_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2733_UnchainedByteMove_02_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2751_UnchainedWordMove_02_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2764_UnchainedDwordMove_02_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2896_UnchainedByteMove_02_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2906_UnchainedWordMove_02_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2911_UnchainedDwordMove_02_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2765_UnchainedByteWrite_03_08_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2783_UnchainedWordWrite_03_08_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2801_UnchainedDwordWrite_03_08_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2769_UnchainedByteFill_03_08_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2787_UnchainedWordFill_03_08_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2805_UnchainedDwordFill_03_08_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2773_UnchainedByteMove_03_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2791_UnchainedWordMove_03_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2809_UnchainedDwordMove_03_08_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2912_UnchainedByteMove_03_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2922_UnchainedWordMove_03_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2932_UnchainedDwordMove_03_08_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2766_UnchainedByteWrite_03_09_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2784_UnchainedWordWrite_03_09_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2802_UnchainedDwordWrite_03_09_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2770_UnchainedByteFill_03_09_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2788_UnchainedWordFill_03_09_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2806_UnchainedDwordFill_03_09_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2776_UnchainedByteMove_03_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2794_UnchainedWordMove_03_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2810_UnchainedDwordMove_03_09_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2915_UnchainedByteMove_03_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2925_UnchainedWordMove_03_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2933_UnchainedDwordMove_03_09_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2767_UnchainedByteWrite_03_0e_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2785_UnchainedWordWrite_03_0e_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2803_UnchainedDwordWrite_03_0e_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2771_UnchainedByteFill_03_0e_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2789_UnchainedWordFill_03_0e_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2807_UnchainedDwordFill_03_0e_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2778_UnchainedByteMove_03_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2796_UnchainedWordMove_03_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2811_UnchainedDwordMove_03_0e_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2917_UnchainedByteMove_03_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2927_UnchainedWordMove_03_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2934_UnchainedDwordMove_03_0e_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2768_UnchainedByteWrite_03_0f_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2786_UnchainedWordWrite_03_0f_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2804_UnchainedDwordWrite_03_0f_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2772_UnchainedByteFill_03_0f_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2790_UnchainedWordFill_03_0f_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2808_UnchainedDwordFill_03_0f_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2781_UnchainedByteMove_03_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2799_UnchainedWordMove_03_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2812_UnchainedDwordMove_03_0f_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2920_UnchainedByteMove_03_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2930_UnchainedWordMove_03_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2935_UnchainedDwordMove_03_0f_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3044_Chain4ByteWrite_00_08 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3094_Chain4WordWrite_00_08 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3143_Chain4DwordWrite_00_08 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3056_Chain4ByteFill_00_08 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3106_Chain4WordFill_00_08 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3155_Chain4DwordFill_00_08 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3070_Chain4ByteMove_00_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3119_Chain4WordMove_00_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3167_Chain4DwordMove_00_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3277_Chain4ByteMove_00_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3301_Chain4WordMove_00_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3325_Chain4DwordMove_00_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3045_Chain4ByteWrite_00_09 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3095_Chain4WordWrite_00_09 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3144_Chain4DwordWrite_00_09 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3058_Chain4ByteFill_00_09 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3107_Chain4WordFill_00_09 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3156_Chain4DwordFill_00_09 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3072_Chain4ByteMove_00_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3121_Chain4WordMove_00_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3168_Chain4DwordMove_00_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3279_Chain4ByteMove_00_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3303_Chain4WordMove_00_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3326_Chain4DwordMove_00_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3046_Chain4ByteWrite_00_0e IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3096_Chain4WordWrite_00_0e IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3145_Chain4DwordWrite_00_0e IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3060_Chain4ByteFill_00_0e IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3109_Chain4WordFill_00_0e IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3157_Chain4DwordFill_00_0e IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3074_Chain4ByteMove_00_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3123_Chain4WordMove_00_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3169_Chain4DwordMove_00_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3281_Chain4ByteMove_00_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3305_Chain4WordMove_00_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3327_Chain4DwordMove_00_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3047_Chain4ByteWrite_00_0f IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3097_Chain4WordWrite_00_0f IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3146_Chain4DwordWrite_00_0f IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3061_Chain4ByteFill_00_0f IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3110_Chain4WordFill_00_0f IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3158_Chain4DwordFill_00_0f IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3076_Chain4ByteMove_00_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3125_Chain4WordMove_00_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3170_Chain4DwordMove_00_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3283_Chain4ByteMove_00_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3307_Chain4WordMove_00_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3328_Chain4DwordMove_00_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3048_Chain4ByteWrite_00_10 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3098_Chain4WordWrite_00_10 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3147_Chain4DwordWrite_00_10 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3062_Chain4ByteFill_00_10 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3111_Chain4WordFill_00_10 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3159_Chain4DwordFill_00_10 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3078_Chain4ByteMove_00_10_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3127_Chain4WordMove_00_10_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3171_Chain4DwordMove_00_10_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3285_Chain4ByteMove_00_10_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3309_Chain4WordMove_00_10_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3329_Chain4DwordMove_00_10_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3049_Chain4ByteWrite_00_11 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3099_Chain4WordWrite_00_11 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3148_Chain4DwordWrite_00_11 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3063_Chain4ByteFill_00_11 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3112_Chain4WordFill_00_11 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3160_Chain4DwordFill_00_11 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3080_Chain4ByteMove_00_11_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3129_Chain4WordMove_00_11_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3172_Chain4DwordMove_00_11_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3287_Chain4ByteMove_00_11_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3311_Chain4WordMove_00_11_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3330_Chain4DwordMove_00_11_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3050_Chain4ByteWrite_00_16 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3100_Chain4WordWrite_00_16 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3149_Chain4DwordWrite_00_16 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3064_Chain4ByteFill_00_16 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3113_Chain4WordFill_00_16 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3161_Chain4DwordFill_00_16 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3082_Chain4ByteMove_00_16_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3131_Chain4WordMove_00_16_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3173_Chain4DwordMove_00_16_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3289_Chain4ByteMove_00_16_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3313_Chain4WordMove_00_16_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3331_Chain4DwordMove_00_16_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3051_Chain4ByteWrite_00_17 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3101_Chain4WordWrite_00_17 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3150_Chain4DwordWrite_00_17 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3065_Chain4ByteFill_00_17 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3114_Chain4WordFill_00_17 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3162_Chain4DwordFill_00_17 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3084_Chain4ByteMove_00_17_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3133_Chain4WordMove_00_17_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3174_Chain4DwordMove_00_17_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3291_Chain4ByteMove_00_17_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3315_Chain4WordMove_00_17_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3332_Chain4DwordMove_00_17_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3052_Chain4ByteWrite_00_18 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3102_Chain4WordWrite_00_18 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3151_Chain4DwordWrite_00_18 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3066_Chain4ByteFill_00_18 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3115_Chain4WordFill_00_18 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3163_Chain4DwordFill_00_18 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3086_Chain4ByteMove_00_18_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3135_Chain4WordMove_00_18_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3175_Chain4DwordMove_00_18_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3293_Chain4ByteMove_00_18_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3317_Chain4WordMove_00_18_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3333_Chain4DwordMove_00_18_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3053_Chain4ByteWrite_00_19 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3103_Chain4WordWrite_00_19 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3152_Chain4DwordWrite_00_19 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3067_Chain4ByteFill_00_19 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3116_Chain4WordFill_00_19 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3164_Chain4DwordFill_00_19 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3088_Chain4ByteMove_00_19_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3137_Chain4WordMove_00_19_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3176_Chain4DwordMove_00_19_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3295_Chain4ByteMove_00_19_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3319_Chain4WordMove_00_19_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3334_Chain4DwordMove_00_19_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3054_Chain4ByteWrite_00_1e IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3104_Chain4WordWrite_00_1e IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3153_Chain4DwordWrite_00_1e IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3068_Chain4ByteFill_00_1e IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3117_Chain4WordFill_00_1e IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3165_Chain4DwordFill_00_1e IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3090_Chain4ByteMove_00_1e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3139_Chain4WordMove_00_1e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3177_Chain4DwordMove_00_1e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3297_Chain4ByteMove_00_1e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3321_Chain4WordMove_00_1e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3335_Chain4DwordMove_00_1e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3055_Chain4ByteWrite_00_1f IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3105_Chain4WordWrite_00_1f IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3154_Chain4DwordWrite_00_1f IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3069_Chain4ByteFill_00_1f IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3118_Chain4WordFill_00_1f IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3166_Chain4DwordFill_00_1f IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3092_Chain4ByteMove_00_1f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3141_Chain4WordMove_00_1f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3178_Chain4DwordMove_00_1f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3299_Chain4ByteMove_00_1f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3323_Chain4WordMove_00_1f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3336_Chain4DwordMove_00_1f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3179_Chain4ByteWrite_01_00 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3183_Chain4WordWrite_01_00 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3186_Chain4DwordWrite_01_00 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3180_Chain4ByteFill_01_00 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3184_Chain4WordFill_01_00 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3187_Chain4DwordFill_01_00 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3181_Chain4ByteMove_01_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3185_Chain4WordMove_01_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3188_Chain4DwordMove_01_00_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3337_Chain4ByteMove_01_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3339_Chain4WordMove_01_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3340_Chain4DwordMove_01_00_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3189_Chain4ByteWrite_02_08 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3205_Chain4WordWrite_02_08 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3221_Chain4DwordWrite_02_08 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3193_Chain4ByteFill_02_08 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3209_Chain4WordFill_02_08 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3225_Chain4DwordFill_02_08 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3197_Chain4ByteMove_02_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3213_Chain4WordMove_02_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3229_Chain4DwordMove_02_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3341_Chain4ByteMove_02_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3349_Chain4WordMove_02_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3357_Chain4DwordMove_02_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3190_Chain4ByteWrite_02_09 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3206_Chain4WordWrite_02_09 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3222_Chain4DwordWrite_02_09 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3194_Chain4ByteFill_02_09 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3210_Chain4WordFill_02_09 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3226_Chain4DwordFill_02_09 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3199_Chain4ByteMove_02_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3215_Chain4WordMove_02_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3230_Chain4DwordMove_02_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3343_Chain4ByteMove_02_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3351_Chain4WordMove_02_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3358_Chain4DwordMove_02_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3191_Chain4ByteWrite_02_0e IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3207_Chain4WordWrite_02_0e IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3223_Chain4DwordWrite_02_0e IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3195_Chain4ByteFill_02_0e IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3211_Chain4WordFill_02_0e IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3227_Chain4DwordFill_02_0e IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3201_Chain4ByteMove_02_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3217_Chain4WordMove_02_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3231_Chain4DwordMove_02_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3345_Chain4ByteMove_02_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3353_Chain4WordMove_02_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3359_Chain4DwordMove_02_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3192_Chain4ByteWrite_02_0f IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3208_Chain4WordWrite_02_0f IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3224_Chain4DwordWrite_02_0f IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3196_Chain4ByteFill_02_0f IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3212_Chain4WordFill_02_0f IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3228_Chain4DwordFill_02_0f IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3203_Chain4ByteMove_02_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3219_Chain4WordMove_02_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3232_Chain4DwordMove_02_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3347_Chain4ByteMove_02_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3355_Chain4WordMove_02_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3360_Chain4DwordMove_02_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3233_Chain4ByteWrite_03_08 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3249_Chain4WordWrite_03_08 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3265_Chain4DwordWrite_03_08 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3237_Chain4ByteFill_03_08 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3253_Chain4WordFill_03_08 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3269_Chain4DwordFill_03_08 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3241_Chain4ByteMove_03_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3257_Chain4WordMove_03_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3273_Chain4DwordMove_03_08_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3361_Chain4ByteMove_03_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3369_Chain4WordMove_03_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3377_Chain4DwordMove_03_08_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3234_Chain4ByteWrite_03_09 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3250_Chain4WordWrite_03_09 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3266_Chain4DwordWrite_03_09 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3238_Chain4ByteFill_03_09 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3254_Chain4WordFill_03_09 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3270_Chain4DwordFill_03_09 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3243_Chain4ByteMove_03_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3259_Chain4WordMove_03_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3274_Chain4DwordMove_03_09_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3363_Chain4ByteMove_03_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3371_Chain4WordMove_03_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3378_Chain4DwordMove_03_09_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3235_Chain4ByteWrite_03_0e IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3251_Chain4WordWrite_03_0e IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3267_Chain4DwordWrite_03_0e IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3239_Chain4ByteFill_03_0e IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3255_Chain4WordFill_03_0e IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3271_Chain4DwordFill_03_0e IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3245_Chain4ByteMove_03_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3261_Chain4WordMove_03_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3275_Chain4DwordMove_03_0e_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3365_Chain4ByteMove_03_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3373_Chain4WordMove_03_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3379_Chain4DwordMove_03_0e_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3236_Chain4ByteWrite_03_0f IPT2(IU32, eaOff, IU8, eaVal);
extern void S_3252_Chain4WordWrite_03_0f IPT2(IU32, eaOff, IU16, eaVal);
extern void S_3268_Chain4DwordWrite_03_0f IPT2(IU32, eaOff, IU32, eaVal);
extern void S_3240_Chain4ByteFill_03_0f IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_3256_Chain4WordFill_03_0f IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_3272_Chain4DwordFill_03_0f IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_3247_Chain4ByteMove_03_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3263_Chain4WordMove_03_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3276_Chain4DwordMove_03_0f_00 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3367_Chain4ByteMove_03_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3375_Chain4WordMove_03_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3380_Chain4DwordMove_03_0f_01 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);


/*========= Mark Functions ============ */

extern S_2438_SimpleMark IPT0();
extern S_2439_CGAMarkByte IPT1(IU32, eaOff);
extern S_2440_CGAMarkWord IPT1(IU32, eaOff);
extern S_2441_CGAMarkDword IPT1(IU32, eaOff);
extern S_2442_CGAMarkString IPT2(IU32, eaOff, IU32, count);
extern S_2443_UnchainedMarkByte IPT1(IU32, eaOff);
extern S_2444_UnchainedMarkWord IPT1(IU32, eaOff);
extern S_2445_UnchainedMarkDword IPT1(IU32, eaOff);
extern S_2446_UnchainedMarkString IPT2(IU32, eaOff, IU32, count);
extern S_2447_Chain4MarkByte IPT1(IU32, eaOff);
extern S_2448_Chain4MarkWord IPT1(IU32, eaOff);
extern S_2449_Chain4MarkDword IPT1(IU32, eaOff);
extern S_2450_Chain4MarkString IPT2(IU32, eaOff, IU32, count);
extern S_2447_Chain4MarkByte IPT1(IU32, eaOff);
extern S_2448_Chain4MarkWord IPT1(IU32, eaOff);
extern S_2449_Chain4MarkDword IPT1(IU32, eaOff);
extern S_2450_Chain4MarkString IPT2(IU32, eaOff, IU32, count);


/*========= Read Functions ============ */

extern IU32 S_2427_SimpleByteRead IPT1(IU32, eaOff);
extern IU32 S_2428_SimpleWordRead IPT1(IU32, eaOff);
extern IU32 S_2429_SimpleDwordRead IPT1(IU32, eaOff);
extern void S_2430_SimpleStringRead IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2430_SimpleStringRead IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2423_DisabledRAMByteRead IPT1(IU32, eaOff);
extern IU32 S_2424_DisabledRAMWordRead IPT1(IU32, eaOff);
extern IU32 S_2425_DisabledRAMDwordRead IPT1(IU32, eaOff);
extern void S_2426_DisabledRAMStringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2437_DisabledRAMStringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2407_RdMode0UnchainedByteRead IPT1(IU32, eaOff);
extern IU32 S_2408_RdMode0UnchainedWordRead IPT1(IU32, eaOff);
extern IU32 S_2409_RdMode0UnchainedDwordRead IPT1(IU32, eaOff);
extern void S_2410_RdMode0UnchainedStringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2433_RdMode0UnchainedStringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2419_RdMode1UnchainedByteRead IPT1(IU32, eaOff);
extern IU32 S_2420_RdMode1UnchainedWordRead IPT1(IU32, eaOff);
extern IU32 S_2421_RdMode1UnchainedDwordRead IPT1(IU32, eaOff);
extern void S_2422_RdMode1UnchainedStringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2436_RdMode1UnchainedStringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2399_RdMode0Chain2ByteRead IPT1(IU32, eaOff);
extern IU32 S_2400_RdMode0Chain2WordRead IPT1(IU32, eaOff);
extern IU32 S_2401_RdMode0Chain2DwordRead IPT1(IU32, eaOff);
extern void S_2402_RdMode0Chain2StringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2431_RdMode0Chain2StringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2411_RdMode1Chain2ByteRead IPT1(IU32, eaOff);
extern IU32 S_2412_RdMode1Chain2WordRead IPT1(IU32, eaOff);
extern IU32 S_2413_RdMode1Chain2DwordRead IPT1(IU32, eaOff);
extern void S_2414_RdMode1Chain2StringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2434_RdMode1Chain2StringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2403_RdMode0Chain4ByteRead IPT1(IU32, eaOff);
extern IU32 S_2404_RdMode0Chain4WordRead IPT1(IU32, eaOff);
extern IU32 S_2405_RdMode0Chain4DwordRead IPT1(IU32, eaOff);
extern void S_2406_RdMode0Chain4StringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2432_RdMode0Chain4StringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2415_RdMode1Chain4ByteRead IPT1(IU32, eaOff);
extern IU32 S_2416_RdMode1Chain4WordRead IPT1(IU32, eaOff);
extern IU32 S_2417_RdMode1Chain4DwordRead IPT1(IU32, eaOff);
extern void S_2418_RdMode1Chain4StringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2435_RdMode1Chain4StringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern EVID_WRT_POINTERS simple_evid;
extern EVID_WRT_POINTERS gricvid_evid;
extern EVID_WRT_POINTERS dith_evid[];
extern EVID_WRT_POINTERS chain2_evid[];
extern EVID_WRT_POINTERS unchained_evid[];
extern EVID_WRT_POINTERS chain4_evid[];
extern EVID_READ_POINTERS simple_read_evid;
extern EVID_READ_POINTERS ram_dsbld_read_evid;
extern EVID_READ_POINTERS read_mode0_evid[];
extern EVID_READ_POINTERS read_mode1_evid[];
extern EVID_MARK_POINTERS simple_mark_evid;
extern EVID_MARK_POINTERS cga_mark_evid;
extern EVID_MARK_POINTERS unchained_mark_evid;
extern EVID_MARK_POINTERS chain4_mark_evid;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\evidgen.h ===
/*[
 * Generated File: evidgen.h
 *
]*/

#ifndef _EVIDGEN_H_
#define _EVIDGEN_H_

struct	VideoVector	{
	IU32	(*GetVideolatches)	IPT0();
	void	(*SetVideolatches)	IPT1(IU32,	value);
	void	(*setWritePointers)	IPT0();
	void	(*setReadPointers)	IPT1(IUH,	readset);
	void	(*setMarkPointers)	IPT1(IUH,	markset);
};

extern	struct	VideoVector	Video;

#define	getVideolatches()	(*(Video.GetVideolatches))()
#define	setVideolatches(value)	(*(Video.SetVideolatches))(value)
#define	SetWritePointers()	(*(Video.setWritePointers))()
#define	SetReadPointers(readset)	(*(Video.setReadPointers))(readset)
#define	SetMarkPointers(markset)	(*(Video.setMarkPointers))(markset)
#endif	/* _EVIDGEN_H_ */
/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\evid_c.h ===
#ifndef _Evid_c_h
#define _Evid_c_h
#define MODE_0 (0)
#define MODE_1 (1)
#define MODE_2 (2)
#define MODE_3 (3)
#define COPY_MODE (4)
#define VGA_SRC (0)
#define RAM_SRC (1)
#define FORWARDS (0)
#define BACKWARDS (1)
#define FWD_BYTE (0)
#define BWD_BYTE (1)
#define FWD_WORD (2)
#define BWD_WORD (3)
#define UNCHAINED (0)
#define CHAIN_2 (1)
#define CHAIN_4 (2)
#define SIMPLE_WRITES (3)
#define FUNC_COPY (0)
#define FUNC_AND (1)
#define FUNC_OR (2)
#define FUNC_XOR (3)
#define FUNC_SHIFT (1)
#define PLANE_ENABLE (1)
#define FUNC_CODE (6)
#define BIT_PROT (8)
#define SET_RESET (16)
#define PROT_OR_FUNC (14)
#define READ_MODE_0 (0)
#define READ_MODE_1 (1)
#define DISABLED_RAM (2)
#define SIMPLE_READ (3)
#define SIMPLE_MARK (0)
#define CGA_MARK (1)
#define UNCHAINED_MARK (2)
#define CHAIN_4_MARK (3)
#define BYTE_SIZE (0)
#define WORD_SIZE (1)
#define DWORD_SIZE (2)
#define STRING_SIZE (3)
#define WRITE_RTN (0)
#define FILL_RTN (1)
#define MOVE_RTN (2)
#define READ_RTN (3)
#define EGA_INDEX (0)
#define VGA_INDEX (1)
#define GC_MASK (2)
#define GC_MASK_FF (3)
#define NUM_UNCHAINED_WRITES (21)
#define NUM_CHAIN4_WRITES (21)
#define NUM_CHAIN2_WRITES (5)
#define NUM_DITHER_WRITES (4)
#define NUM_M0_WRITES (12)
#define NUM_M1_WRITES (1)
#define NUM_M23_WRITES (4)
#define NUM_READ_M0_READS (3)
#define NUM_READ_M1_READS (3)
struct VGAGLOBALSETTINGS
{
	IU32 latches;
	IU8 *VGA_rplane;
	IU8 *VGA_wplane;
	IU8 *scratch;
	IU32 sr_masked_val;
	IU32 sr_nmask;
	IU32 data_and_mask;
	IU32 data_xor_mask;
	IU32 latch_xor_mask;
	IU32 bit_prot_mask;
	IU32 plane_enable;
	IU32 plane_enable_mask;
	IUH *sr_lookup;
	IU32*fwd_str_read_addr;
	IU32*bwd_str_read_addr;
	IU32 dirty_total;
	IS32 dirty_low;
	IS32 dirty_high;
	IU8 *video_copy;
	IU32*mark_byte;
	IU32*mark_word;
	IU32*mark_string;
	IU32 read_shift_count;
	IU32 read_mapped_plane;
	IU32 colour_comp;
	IU32 dont_care;
	IU32 v7_bank_vid_copy_off;
	void *video_base_ls0;
	IU8 *route_reg1;
	IU8 *route_reg2;
	IU8 *screen_ptr;
	IU32 rotate;
	IU32 calc_data_xor;
	IU32 calc_latch_xor;
	IU32*read_byte_addr;
	IU32 v7_fg_latches;
	IUH **GCRegs;
	IU8 lastGCindex;
	IU8 dither;
	IU8 wrmode;
	IU8 chain;
	IU8 wrstate;
};
struct EVIDWRITES
{
	IU32*byte_write;
	IU32*word_write;
	IU32*dword_write;
	IU32*byte_fill;
	IU32*word_fill;
	IU32*dword_fill;
	IU32*byte_fwd_move;
	IU32*byte_bwd_move;
	IU32*word_fwd_move;
	IU32*word_bwd_move;
	IU32*dword_fwd_move;
	IU32*dword_bwd_move;
};
struct EVIDREADS
{
	IU32*byte_read;
	IU32*word_read;
	IU32*dword_read;
	IU32*str_fwd_read;
	IU32*str_bwd_read;
};
struct EVIDMARKS
{
	IU32*byte_mark;
	IU32*word_mark;
	IU32*dword_mark;
	IU32*str_mark;
};
enum VidSections
{
	READ_FUNC = 0,
	MARK_FUNC = 1,
	SIMPLE_FUNC = 2,
	DITHER_FUNC = 3,
	PORT_FUNC = 4,
	GENERIC_WRITES = 5,
	UNCHAINED_WRITES = 6,
	CHAIN4_WRITES = 7,
	CHAIN2_WRITES = 8
};
#endif /* ! _Evid_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\fault.h ===
/*[

fault.h

"@(#)fault.h	1.2 01/19/95"

Fault codes for exceptions; one per call instance of
any of the exception routines to enable tracking of the
original cause of an exception in the CCPU.

Currently the Int0, Int1 etc routines are not counted
as exceptions for this purpose.

]*/

 
/*
 * Fault codes for: c_addr.c
 */
#define FAULT_LIMITCHK_SEG_LIMIT                  1
 
/*
 * Fault codes for: c_intr.c
 */
#define FAULT_INT_DEST_NOT_IN_IDT                 2
#define FAULT_INT_DEST_BAD_SEG_TYPE               3
#define FAULT_INT_DEST_ACCESS                     4
#define FAULT_INT_DEST_NOTPRESENT                 5
#define FAULT_INTR_RM_CS_LIMIT                    6
#define FAULT_INTR_TASK_CS_LIMIT                  7
#define FAULT_INTR_PM_CS_LIMIT_1                  8
#define FAULT_INTR_PM_CS_LIMIT_2                  9
 
/*
 * Fault codes for: c_main.c
 */
#define FAULT_CCPU_LLDT_ACCESS                   10
#define FAULT_CCPU_LTR_ACCESS                    11
#define FAULT_CCPU_LGDT_ACCESS                   12
#define FAULT_CCPU_LMSW_ACCESS                   13
#define FAULT_CCPU_INVLPG_ACCESS                 14
#define FAULT_CCPU_CLTS_ACCESS                   15
#define FAULT_CCPU_INVD_ACCESS                   16
#define FAULT_CCPU_WBIND_ACCESS                  17
#define FAULT_CCPU_MOV_R_C_ACCESS                18
#define FAULT_CCPU_MOV_R_D_ACCESS                19
#define FAULT_CCPU_MOV_C_R_ACCESS                20
#define FAULT_CCPU_MOV_D_R_ACCESS                21
#define FAULT_CCPU_MOV_R_T_ACCESS                22
#define FAULT_CCPU_MOV_T_R_ACCESS                23
#define FAULT_CCPU_PUSHF_ACCESS                  24
#define FAULT_CCPU_POPF_ACCESS                   25
#define FAULT_CCPU_INT_ACCESS                    26
#define FAULT_CCPU_IRET_ACCESS                   27
#define FAULT_CCPU_HLT_ACCESS                    28
#define FAULT_CCPU_CLI_ACCESS                    29
#define FAULT_CCPU_STI_ACCESS                    30
#define FAULT_CHKIOMAP_BAD_TSS                   31
#define FAULT_CHKIOMAP_BAD_MAP                   32
#define FAULT_CHKIOMAP_BAD_TR                    33
#define FAULT_CHKIOMAP_ACCESS                    34
 
/*
 * Fault codes for: c_oprnd.h
 */
#define FAULT_OP0_SEG_NOT_READABLE               35
#define FAULT_OP0_SEG_NOT_WRITABLE               36
#define FAULT_OP0_SEG_NO_READ_OR_WRITE           37
#define FAULT_OP1_SEG_NOT_READABLE               38
#define FAULT_OP1_SEG_NOT_WRITABLE               39
#define FAULT_OP1_SEG_NO_READ_OR_WRITE           40
 
/*
 * Fault codes for: c_prot.c
 */
#define FAULT_CHECKSS_SELECTOR                   41
#define FAULT_CHECKSS_BAD_SEG_TYPE               42
#define FAULT_CHECKSS_ACCESS                     43
#define FAULT_CHECKSS_NOTPRESENT                 44
#define FAULT_VALSS_CHG_SELECTOR                 45
#define FAULT_VALSS_CHG_ACCESS                   46
#define FAULT_VALSS_CHG_BAD_SEG_TYPE             47
#define FAULT_VALSS_CHG_NOTPRESENT               48
#define FAULT_VALTSS_SELECTOR                    49
#define FAULT_VALTSS_NP                          50
 
/*
 * Fault codes for: c_seg.c
 */
#define FAULT_LOADCS_SELECTOR                    51
#define FAULT_LOADCS_ACCESS_1                    52
#define FAULT_LOADCS_NOTPRESENT_1                53
#define FAULT_LOADCS_ACCESS_2                    54
#define FAULT_LOADCS_NOTPRESENT_2                55
#define FAULT_LOADCS_BAD_SEG_TYPE                56
#define FAULT_LOADDS_SELECTOR                    57
#define FAULT_LOADDS_BAD_SEG_TYPE                58
#define FAULT_LOADDS_ACCESS                      59
#define FAULT_LOADDS_NOTPRESENT                  60
 
/*
 * Fault codes for: c_stack.c
 */
#define FAULT_VALNEWSPC_SS_LIMIT_16              61
#define FAULT_VALNEWSPC_SS_LIMIT_32              62
#define FAULT_VALSTACKEX_ACCESS                  63
#define FAULT_VALSTKSPACE_ACCESS                 64
 
/*
 * Fault codes for: c_tlb.c
 */
#define FAULT_LIN2PHY_ACCESS                     65
#define FAULT_LIN2PHY_PDE_NOTPRESENT             66
#define FAULT_LIN2PHY_PTE_NOTPRESENT             67
#define FAULT_LIN2PHY_PROTECT_FAIL               68
 
/*
 * Fault codes for: c_tsksw.c
 */
#define FAULT_LOADLDT_SELECTOR                   69
#define FAULT_LOADLDT_NOT_AN_LDT                 70
#define FAULT_LOADLDT_NOTPRESENT                 71
#define FAULT_SWTASK_NULL_TR_SEL                 72
#define FAULT_SWTASK_BAD_TSS_SIZE_1              73
#define FAULT_SWTASK_BAD_TSS_SIZE_2              74
#define FAULT_SWTASK_BAD_TSS_SIZE_3              75
#define FAULT_SWTASK_BAD_TSS_SIZE_4              76
#define FAULT_SWTASK_BAD_CS_SELECTOR             77
#define FAULT_SWTASK_CONFORM_CS_NP               78
#define FAULT_SWTASK_ACCESS_1                    79
#define FAULT_SWTASK_NOCONFORM_CS_NP             80
#define FAULT_SWTASK_ACCESS_2                    81
#define FAULT_SWTASK_BAD_SEG_TYPE                82
 
/*
 * Fault codes for: c_xfer.c
 */
#define FAULT_RM_REL_IP_CS_LIMIT                 83
#define FAULT_PM_REL_IP_CS_LIMIT                 84
#define FAULT_FAR_DEST_SELECTOR                  85
#define FAULT_FAR_DEST_ACCESS_1                  86
#define FAULT_FAR_DEST_NP_CONFORM                87
#define FAULT_FAR_DEST_ACCESS_2                  88
#define FAULT_FAR_DEST_NP_NONCONFORM             89
#define FAULT_FAR_DEST_ACCESS_3                  90
#define FAULT_FAR_DEST_NP_CALLG                  91
#define FAULT_FAR_DEST_ACCESS_4                  92
#define FAULT_FAR_DEST_NP_TASKG                  93
#define FAULT_FAR_DEST_TSS_IN_LDT                94
#define FAULT_FAR_DEST_ACCESS_5                  95
#define FAULT_FAR_DEST_NP_TSS                    96
#define FAULT_FAR_DEST_BAD_SEG_TYPE              97
#define FAULT_GATE_DEST_SELECTOR                 98
#define FAULT_GATE_DEST_ACCESS_1                 99
#define FAULT_GATE_DEST_ACCESS_2                 100
#define FAULT_GATE_DEST_ACCESS_3                 101
#define FAULT_GATE_DEST_BAD_SEG_TYPE             102
#define FAULT_GATE_DEST_GATE_SIZE                103
#define FAULT_GATE_DEST_NP                       104
#define FAULT_TASK_DEST_SELECTOR                 105
#define FAULT_TASK_DEST_NOT_TSS                  106
#define FAULT_TASK_DEST_NP                       107
 
/*
 * Fault codes for: call.c
 */
#define FAULT_CALLF_RM_CS_LIMIT                  108
#define FAULT_CALLF_TASK_CS_LIMIT                109
#define FAULT_CALLF_PM_CS_LIMIT_1                110
#define FAULT_CALLF_PM_CS_LIMIT_2                111
#define FAULT_CALLN_RM_CS_LIMIT                  112
#define FAULT_CALLN_PM_CS_LIMIT                  113
#define FAULT_CALLR_RM_CS_LIMIT                  114
#define FAULT_CALLR_PM_CS_LIMIT                  115
 
/*
 * Fault codes for: enter.c
 */
#define FAULT_ENTER16_ACCESS                     116
#define FAULT_ENTER32_ACCESS                     117
 
/*
 * Fault codes for: iret.c
 */
#define FAULT_IRET_RM_CS_LIMIT                   118
#define FAULT_IRET_PM_TASK_CS_LIMIT              119
#define FAULT_IRET_VM_CS_LIMIT                   120
#define FAULT_IRET_CS_ACCESS_1                   121
#define FAULT_IRET_SELECTOR                      122
#define FAULT_IRET_ACCESS_2                      123
#define FAULT_IRET_ACCESS_3                      124
#define FAULT_IRET_BAD_SEG_TYPE                  125
#define FAULT_IRET_NP_CS                         126
#define FAULT_IRET_PM_CS_LIMIT_1                 127
#define FAULT_IRET_PM_CS_LIMIT_2                 128
 
/*
 * Fault codes for: jmp.c
 */
#define FAULT_JMPF_RM_CS_LIMIT                   129
#define FAULT_JMPF_TASK_CS_LIMIT                 130
#define FAULT_JMPF_PM_CS_LIMIT                   131
#define FAULT_JMPN_RM_CS_LIMIT                   132
#define FAULT_JMPN_PM_CS_LIMIT                   133
 
/*
 * Fault codes for: lldt.c
 */
#define FAULT_LLDT_SELECTOR                      134
#define FAULT_LLDT_NOT_LDT                       135
#define FAULT_LLDT_NP                            136
 
/*
 * Fault codes for: mov.c
 */
#define FAULT_MOV_CR_PAGE_IN_RM                  137
 
/*
 * Fault codes for: ret.c
 */
#define FAULT_RETF_RM_CS_LIMIT                   138
#define FAULT_RETF_PM_ACCESS                     139
#define FAULT_RETF_SELECTOR                      140
#define FAULT_RETF_ACCESS_1                      141
#define FAULT_RETF_ACCESS_2                      142
#define FAULT_RETF_BAD_SEG_TYPE                  143
#define FAULT_RETF_CS_NOTPRESENT                 144
#define FAULT_RETF_PM_CS_LIMIT_1                 145
#define FAULT_RETF_PM_CS_LIMIT_2                 146
#define FAULT_RETN_CS_LIMIT                      147
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\gdpvar.h ===
#ifndef _gdpvar_h
#define _gdpvar_h
#define GLOBAL_EDL_WORKSPACE_0 (*(IUH *)((IUH)Gdp + 43))
#define SET_GLOBAL_EDL_WORKSPACE_0(v) (GLOBAL_EDL_WORKSPACE_0 = (v))
#define GLOBAL_EDL_WORKSPACE_1 (*(IUH *)((IUH)Gdp + 47))
#define SET_GLOBAL_EDL_WORKSPACE_1(v) (GLOBAL_EDL_WORKSPACE_1 = (v))
#define GLOBAL_EDL_WORKSPACE_2 (*(IUH *)((IUH)Gdp + 51))
#define SET_GLOBAL_EDL_WORKSPACE_2(v) (GLOBAL_EDL_WORKSPACE_2 = (v))
#define GLOBAL_EDL_WORKSPACE_3 (*(IUH *)((IUH)Gdp + 55))
#define SET_GLOBAL_EDL_WORKSPACE_3(v) (GLOBAL_EDL_WORKSPACE_3 = (v))
#define GLOBAL_EDL_WORKSPACE_4 (*(IUH *)((IUH)Gdp + 59))
#define SET_GLOBAL_EDL_WORKSPACE_4(v) (GLOBAL_EDL_WORKSPACE_4 = (v))
#define GLOBAL_EDL_WORKSPACE_5 (*(IUH *)((IUH)Gdp + 63))
#define SET_GLOBAL_EDL_WORKSPACE_5(v) (GLOBAL_EDL_WORKSPACE_5 = (v))
#define GLOBAL_EDL_WORKSPACE_6 (*(IUH *)((IUH)Gdp + 67))
#define SET_GLOBAL_EDL_WORKSPACE_6(v) (GLOBAL_EDL_WORKSPACE_6 = (v))
#define GLOBAL_EDL_WORKSPACE_7 (*(IUH *)((IUH)Gdp + 71))
#define SET_GLOBAL_EDL_WORKSPACE_7(v) (GLOBAL_EDL_WORKSPACE_7 = (v))
#define GLOBAL_EDL_WORKSPACE_8 (*(IUH *)((IUH)Gdp + 75))
#define SET_GLOBAL_EDL_WORKSPACE_8(v) (GLOBAL_EDL_WORKSPACE_8 = (v))
#define GLOBAL_EDL_WORKSPACE_9 (*(IUH *)((IUH)Gdp + 79))
#define SET_GLOBAL_EDL_WORKSPACE_9(v) (GLOBAL_EDL_WORKSPACE_9 = (v))
#define GLOBAL_EDL_WORKSPACE_10 (*(IUH *)((IUH)Gdp + 83))
#define SET_GLOBAL_EDL_WORKSPACE_10(v) (GLOBAL_EDL_WORKSPACE_10 = (v))
#define GLOBAL_EDL_WORKSPACE_11 (*(IUH *)((IUH)Gdp + 87))
#define SET_GLOBAL_EDL_WORKSPACE_11(v) (GLOBAL_EDL_WORKSPACE_11 = (v))
#define GLOBAL_EDL_WORKSPACE_12 (*(IUH *)((IUH)Gdp + 91))
#define SET_GLOBAL_EDL_WORKSPACE_12(v) (GLOBAL_EDL_WORKSPACE_12 = (v))
#define GLOBAL_EDL_WORKSPACE_13 (*(IUH *)((IUH)Gdp + 95))
#define SET_GLOBAL_EDL_WORKSPACE_13(v) (GLOBAL_EDL_WORKSPACE_13 = (v))
#define GLOBAL_EDL_WORKSPACE_14 (*(IUH *)((IUH)Gdp + 99))
#define SET_GLOBAL_EDL_WORKSPACE_14(v) (GLOBAL_EDL_WORKSPACE_14 = (v))
#define GLOBAL_EDL_WORKSPACE_15 (*(IUH *)((IUH)Gdp + 103))
#define SET_GLOBAL_EDL_WORKSPACE_15(v) (GLOBAL_EDL_WORKSPACE_15 = (v))
#define GLOBAL_EDL_WORKSPACE_16 (*(IUH *)((IUH)Gdp + 107))
#define SET_GLOBAL_EDL_WORKSPACE_16(v) (GLOBAL_EDL_WORKSPACE_16 = (v))
#define GLOBAL_EDL_WORKSPACE_17 (*(IUH *)((IUH)Gdp + 111))
#define SET_GLOBAL_EDL_WORKSPACE_17(v) (GLOBAL_EDL_WORKSPACE_17 = (v))
#define GLOBAL_EDL_WORKSPACE_18 (*(IUH *)((IUH)Gdp + 115))
#define SET_GLOBAL_EDL_WORKSPACE_18(v) (GLOBAL_EDL_WORKSPACE_18 = (v))
#define GLOBAL_EDL_WORKSPACE_19 (*(IUH *)((IUH)Gdp + 119))
#define SET_GLOBAL_EDL_WORKSPACE_19(v) (GLOBAL_EDL_WORKSPACE_19 = (v))
#define GLOBAL_EDL_WORKSPACE_20 (*(IUH *)((IUH)Gdp + 123))
#define SET_GLOBAL_EDL_WORKSPACE_20(v) (GLOBAL_EDL_WORKSPACE_20 = (v))
#define GLOBAL_EDL_WORKSPACE_21 (*(IUH *)((IUH)Gdp + 127))
#define SET_GLOBAL_EDL_WORKSPACE_21(v) (GLOBAL_EDL_WORKSPACE_21 = (v))
#define GLOBAL_EDL_WORKSPACE_22 (*(IUH *)((IUH)Gdp + 131))
#define SET_GLOBAL_EDL_WORKSPACE_22(v) (GLOBAL_EDL_WORKSPACE_22 = (v))
#define GLOBAL_EDL_WORKSPACE_23 (*(IUH *)((IUH)Gdp + 135))
#define SET_GLOBAL_EDL_WORKSPACE_23(v) (GLOBAL_EDL_WORKSPACE_23 = (v))
#define GLOBAL_EDL_WORKSPACE_24 (*(IUH *)((IUH)Gdp + 139))
#define SET_GLOBAL_EDL_WORKSPACE_24(v) (GLOBAL_EDL_WORKSPACE_24 = (v))
#define GLOBAL_EDL_WORKSPACE_25 (*(IUH *)((IUH)Gdp + 143))
#define SET_GLOBAL_EDL_WORKSPACE_25(v) (GLOBAL_EDL_WORKSPACE_25 = (v))
#define GLOBAL_EDL_WORKSPACE_26 (*(IUH *)((IUH)Gdp + 147))
#define SET_GLOBAL_EDL_WORKSPACE_26(v) (GLOBAL_EDL_WORKSPACE_26 = (v))
#define GLOBAL_EDL_WORKSPACE_27 (*(IUH *)((IUH)Gdp + 151))
#define SET_GLOBAL_EDL_WORKSPACE_27(v) (GLOBAL_EDL_WORKSPACE_27 = (v))
#define GLOBAL_EDL_WORKSPACE_28 (*(IUH *)((IUH)Gdp + 155))
#define SET_GLOBAL_EDL_WORKSPACE_28(v) (GLOBAL_EDL_WORKSPACE_28 = (v))
#define GLOBAL_EDL_WORKSPACE_29 (*(IUH *)((IUH)Gdp + 159))
#define SET_GLOBAL_EDL_WORKSPACE_29(v) (GLOBAL_EDL_WORKSPACE_29 = (v))
#define GLOBAL_EDL_WORKSPACE_30 (*(IUH *)((IUH)Gdp + 163))
#define SET_GLOBAL_EDL_WORKSPACE_30(v) (GLOBAL_EDL_WORKSPACE_30 = (v))
#define GLOBAL_EDL_WORKSPACE_31 (*(IUH *)((IUH)Gdp + 167))
#define SET_GLOBAL_EDL_WORKSPACE_31(v) (GLOBAL_EDL_WORKSPACE_31 = (v))
#define GLOBAL_EDL_WORKSPACE_32 (*(IUH *)((IUH)Gdp + 171))
#define SET_GLOBAL_EDL_WORKSPACE_32(v) (GLOBAL_EDL_WORKSPACE_32 = (v))
#define GLOBAL_EDL_WORKSPACE_33 (*(IUH *)((IUH)Gdp + 175))
#define SET_GLOBAL_EDL_WORKSPACE_33(v) (GLOBAL_EDL_WORKSPACE_33 = (v))
#define GLOBAL_EDL_WORKSPACE_34 (*(IUH *)((IUH)Gdp + 179))
#define SET_GLOBAL_EDL_WORKSPACE_34(v) (GLOBAL_EDL_WORKSPACE_34 = (v))
#define GLOBAL_EDL_WORKSPACE_35 (*(IUH *)((IUH)Gdp + 183))
#define SET_GLOBAL_EDL_WORKSPACE_35(v) (GLOBAL_EDL_WORKSPACE_35 = (v))
#define GLOBAL_EDL_WORKSPACE_36 (*(IUH *)((IUH)Gdp + 187))
#define SET_GLOBAL_EDL_WORKSPACE_36(v) (GLOBAL_EDL_WORKSPACE_36 = (v))
#define GLOBAL_EDL_WORKSPACE_37 (*(IUH *)((IUH)Gdp + 191))
#define SET_GLOBAL_EDL_WORKSPACE_37(v) (GLOBAL_EDL_WORKSPACE_37 = (v))
#define GLOBAL_EDL_WORKSPACE_38 (*(IUH *)((IUH)Gdp + 195))
#define SET_GLOBAL_EDL_WORKSPACE_38(v) (GLOBAL_EDL_WORKSPACE_38 = (v))
#define GLOBAL_EDL_WORKSPACE_39 (*(IUH *)((IUH)Gdp + 199))
#define SET_GLOBAL_EDL_WORKSPACE_39(v) (GLOBAL_EDL_WORKSPACE_39 = (v))
#define GLOBAL_EDL_WORKSPACE_40 (*(IUH *)((IUH)Gdp + 203))
#define SET_GLOBAL_EDL_WORKSPACE_40(v) (GLOBAL_EDL_WORKSPACE_40 = (v))
#define GLOBAL_EDL_WORKSPACE_41 (*(IUH *)((IUH)Gdp + 207))
#define SET_GLOBAL_EDL_WORKSPACE_41(v) (GLOBAL_EDL_WORKSPACE_41 = (v))
#define GLOBAL_EDL_WORKSPACE_42 (*(IUH *)((IUH)Gdp + 211))
#define SET_GLOBAL_EDL_WORKSPACE_42(v) (GLOBAL_EDL_WORKSPACE_42 = (v))
#define GLOBAL_EDL_WORKSPACE_43 (*(IUH *)((IUH)Gdp + 215))
#define SET_GLOBAL_EDL_WORKSPACE_43(v) (GLOBAL_EDL_WORKSPACE_43 = (v))
#define GLOBAL_EDL_WORKSPACE_44 (*(IUH *)((IUH)Gdp + 219))
#define SET_GLOBAL_EDL_WORKSPACE_44(v) (GLOBAL_EDL_WORKSPACE_44 = (v))
#define GLOBAL_EDL_WORKSPACE_45 (*(IUH *)((IUH)Gdp + 223))
#define SET_GLOBAL_EDL_WORKSPACE_45(v) (GLOBAL_EDL_WORKSPACE_45 = (v))
#define GLOBAL_EDL_WORKSPACE_46 (*(IUH *)((IUH)Gdp + 227))
#define SET_GLOBAL_EDL_WORKSPACE_46(v) (GLOBAL_EDL_WORKSPACE_46 = (v))
#define GLOBAL_EDL_WORKSPACE_47 (*(IUH *)((IUH)Gdp + 231))
#define SET_GLOBAL_EDL_WORKSPACE_47(v) (GLOBAL_EDL_WORKSPACE_47 = (v))
#define GLOBAL_EDL_WORKSPACE_48 (*(IUH *)((IUH)Gdp + 235))
#define SET_GLOBAL_EDL_WORKSPACE_48(v) (GLOBAL_EDL_WORKSPACE_48 = (v))
#define GLOBAL_EDL_WORKSPACE_49 (*(IUH *)((IUH)Gdp + 239))
#define SET_GLOBAL_EDL_WORKSPACE_49(v) (GLOBAL_EDL_WORKSPACE_49 = (v))
#define GLOBAL_EDL_WORKSPACE_50 (*(IUH *)((IUH)Gdp + 243))
#define SET_GLOBAL_EDL_WORKSPACE_50(v) (GLOBAL_EDL_WORKSPACE_50 = (v))
#define GLOBAL_EDL_WORKSPACE_51 (*(IUH *)((IUH)Gdp + 247))
#define SET_GLOBAL_EDL_WORKSPACE_51(v) (GLOBAL_EDL_WORKSPACE_51 = (v))
#define GLOBAL_EDL_WORKSPACE_52 (*(IUH *)((IUH)Gdp + 251))
#define SET_GLOBAL_EDL_WORKSPACE_52(v) (GLOBAL_EDL_WORKSPACE_52 = (v))
#define GLOBAL_EDL_WORKSPACE_53 (*(IUH *)((IUH)Gdp + 255))
#define SET_GLOBAL_EDL_WORKSPACE_53(v) (GLOBAL_EDL_WORKSPACE_53 = (v))
#define GLOBAL_EDL_WORKSPACE_54 (*(IUH *)((IUH)Gdp + 259))
#define SET_GLOBAL_EDL_WORKSPACE_54(v) (GLOBAL_EDL_WORKSPACE_54 = (v))
#define GLOBAL_EDL_WORKSPACE_55 (*(IUH *)((IUH)Gdp + 263))
#define SET_GLOBAL_EDL_WORKSPACE_55(v) (GLOBAL_EDL_WORKSPACE_55 = (v))
#define GLOBAL_WhereAmI (*(IU32* *)((IUH)Gdp + 7))
#define SET_GLOBAL_WhereAmI(v) (GLOBAL_WhereAmI = (v))
#define GLOBAL_CoRoRet (*(IU32* *)((IUH)Gdp + 11))
#define SET_GLOBAL_CoRoRet(v) (GLOBAL_CoRoRet = (v))
#define GLOBAL_WhichAssertion (*(ISH *)((IUH)Gdp + 35))
#define SET_GLOBAL_WhichAssertion(v) (GLOBAL_WhichAssertion = (v))
#define GLOBAL_SimulateContext (*(IU8* *)((IUH)Gdp + 19))
#define SET_GLOBAL_SimulateContext(v) (GLOBAL_SimulateContext = (v))
#define GLOBAL_ErrorNumber (*(IUH *)((IUH)Gdp + 39))
#define SET_GLOBAL_ErrorNumber(v) (GLOBAL_ErrorNumber = (v))
#define GLOBAL_EDL_WORKSPACE_56 (*(IUH *)((IUH)Gdp + 267))
#define SET_GLOBAL_EDL_WORKSPACE_56(v) (GLOBAL_EDL_WORKSPACE_56 = (v))
#define GLOBAL_EDL_WORKSPACE_57 (*(IUH *)((IUH)Gdp + 271))
#define SET_GLOBAL_EDL_WORKSPACE_57(v) (GLOBAL_EDL_WORKSPACE_57 = (v))
#define GLOBAL_EDL_WORKSPACE_58 (*(IUH *)((IUH)Gdp + 275))
#define SET_GLOBAL_EDL_WORKSPACE_58(v) (GLOBAL_EDL_WORKSPACE_58 = (v))
#define GLOBAL_EDL_WORKSPACE_59 (*(IUH *)((IUH)Gdp + 279))
#define SET_GLOBAL_EDL_WORKSPACE_59(v) (GLOBAL_EDL_WORKSPACE_59 = (v))
#define GLOBAL_EDL_WORKSPACE_60 (*(IUH *)((IUH)Gdp + 283))
#define SET_GLOBAL_EDL_WORKSPACE_60(v) (GLOBAL_EDL_WORKSPACE_60 = (v))
#define GLOBAL_TraceRingRec (*(struct TraceRingREC *)((IUH)Gdp + 287))
#define SET_GLOBAL_TraceRingRec(v) (GLOBAL_TraceRingRec = (v))
#define GLOBAL_SubrNumber (*(IUH *)((IUH)Gdp + 3))
#define SET_GLOBAL_SubrNumber(v) (GLOBAL_SubrNumber = (v))
#define GLOBAL_SubrRingPtr (*(IUH* *)((IUH)Gdp + 23))
#define SET_GLOBAL_SubrRingPtr(v) (GLOBAL_SubrRingPtr = (v))
#define GLOBAL_SubrRingLowIncl (*(IUH* *)((IUH)Gdp + 27))
#define SET_GLOBAL_SubrRingLowIncl(v) (GLOBAL_SubrRingLowIncl = (v))
#define GLOBAL_SubrRingHighIncl (*(IUH* *)((IUH)Gdp + 31))
#define SET_GLOBAL_SubrRingHighIncl(v) (GLOBAL_SubrRingHighIncl = (v))
#define GLOBAL_HookNumber (*(IUH *)((IUH)Gdp + -1))
#define SET_GLOBAL_HookNumber(v) (GLOBAL_HookNumber = (v))
#define GLOBAL_EfiNumber (*(IUH *)((IUH)Gdp + 15))
#define SET_GLOBAL_EfiNumber(v) (GLOBAL_EfiNumber = (v))
#define GLOBAL_R_EAX (*(IUH *)((IUH)Gdp + 307))
#define SET_GLOBAL_R_EAX(v) (GLOBAL_R_EAX = (v))
#define GLOBAL_R_EBX (*(IUH *)((IUH)Gdp + 311))
#define SET_GLOBAL_R_EBX(v) (GLOBAL_R_EBX = (v))
#define GLOBAL_R_ECX (*(IUH *)((IUH)Gdp + 315))
#define SET_GLOBAL_R_ECX(v) (GLOBAL_R_ECX = (v))
#define GLOBAL_R_EDX (*(IUH *)((IUH)Gdp + 319))
#define SET_GLOBAL_R_EDX(v) (GLOBAL_R_EDX = (v))
#define GLOBAL_R_EBP (*(IUH *)((IUH)Gdp + 323))
#define SET_GLOBAL_R_EBP(v) (GLOBAL_R_EBP = (v))
#define GLOBAL_R_ESI (*(IUH *)((IUH)Gdp + 327))
#define SET_GLOBAL_R_ESI(v) (GLOBAL_R_ESI = (v))
#define GLOBAL_R_EDI (*(IUH *)((IUH)Gdp + 331))
#define SET_GLOBAL_R_EDI(v) (GLOBAL_R_EDI = (v))
#define GLOBAL_EsBase (*(IU32 *)((IUH)Gdp + 335))
#define SET_GLOBAL_EsBase(v) (GLOBAL_EsBase = (v))
#define GLOBAL_EsSel (*(IU16 *)((IUH)Gdp + 339))
#define SET_GLOBAL_EsSel(v) (GLOBAL_EsSel = (v))
#define GLOBAL_EsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 343))
#define SET_GLOBAL_EsDesc(v) (GLOBAL_EsDesc = (v))
#define GLOBAL_EsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 347))
#define SET_GLOBAL_EsDescSanctuary(v) (GLOBAL_EsDescSanctuary = (v))
#define GLOBAL_CsBase (*(IU32 *)((IUH)Gdp + 351))
#define SET_GLOBAL_CsBase(v) (GLOBAL_CsBase = (v))
#define GLOBAL_CsSel (*(IU16 *)((IUH)Gdp + 355))
#define SET_GLOBAL_CsSel(v) (GLOBAL_CsSel = (v))
#define GLOBAL_CsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 359))
#define SET_GLOBAL_CsDesc(v) (GLOBAL_CsDesc = (v))
#define GLOBAL_CsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 363))
#define SET_GLOBAL_CsDescSanctuary(v) (GLOBAL_CsDescSanctuary = (v))
#define GLOBAL_SsBase (*(IU32 *)((IUH)Gdp + 367))
#define SET_GLOBAL_SsBase(v) (GLOBAL_SsBase = (v))
#define GLOBAL_SsSel (*(IU16 *)((IUH)Gdp + 371))
#define SET_GLOBAL_SsSel(v) (GLOBAL_SsSel = (v))
#define GLOBAL_SsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 375))
#define SET_GLOBAL_SsDesc(v) (GLOBAL_SsDesc = (v))
#define GLOBAL_SsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 379))
#define SET_GLOBAL_SsDescSanctuary(v) (GLOBAL_SsDescSanctuary = (v))
#define GLOBAL_DsBase (*(IU32 *)((IUH)Gdp + 383))
#define SET_GLOBAL_DsBase(v) (GLOBAL_DsBase = (v))
#define GLOBAL_DsSel (*(IU16 *)((IUH)Gdp + 387))
#define SET_GLOBAL_DsSel(v) (GLOBAL_DsSel = (v))
#define GLOBAL_DsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 391))
#define SET_GLOBAL_DsDesc(v) (GLOBAL_DsDesc = (v))
#define GLOBAL_DsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 395))
#define SET_GLOBAL_DsDescSanctuary(v) (GLOBAL_DsDescSanctuary = (v))
#define GLOBAL_FsBase (*(IU32 *)((IUH)Gdp + 399))
#define SET_GLOBAL_FsBase(v) (GLOBAL_FsBase = (v))
#define GLOBAL_FsSel (*(IU16 *)((IUH)Gdp + 403))
#define SET_GLOBAL_FsSel(v) (GLOBAL_FsSel = (v))
#define GLOBAL_FsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 407))
#define SET_GLOBAL_FsDesc(v) (GLOBAL_FsDesc = (v))
#define GLOBAL_FsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 411))
#define SET_GLOBAL_FsDescSanctuary(v) (GLOBAL_FsDescSanctuary = (v))
#define GLOBAL_GsBase (*(IU32 *)((IUH)Gdp + 415))
#define SET_GLOBAL_GsBase(v) (GLOBAL_GsBase = (v))
#define GLOBAL_GsSel (*(IU16 *)((IUH)Gdp + 419))
#define SET_GLOBAL_GsSel(v) (GLOBAL_GsSel = (v))
#define GLOBAL_GsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 423))
#define SET_GLOBAL_GsDesc(v) (GLOBAL_GsDesc = (v))
#define GLOBAL_GsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 427))
#define SET_GLOBAL_GsDescSanctuary(v) (GLOBAL_GsDescSanctuary = (v))
#define GLOBAL_LinearDesc (*(struct GLDC_REC* *)((IUH)Gdp + 431))
#define SET_GLOBAL_LinearDesc(v) (GLOBAL_LinearDesc = (v))
#define GLOBAL_SystemDesc (*(struct GLDC_REC* *)((IUH)Gdp + 435))
#define SET_GLOBAL_SystemDesc(v) (GLOBAL_SystemDesc = (v))
#define GLOBAL_CPL (*(IUH *)((IUH)Gdp + 439))
#define SET_GLOBAL_CPL(v) (GLOBAL_CPL = (v))
#define GLOBAL_GdtrBase (*(IU32 *)((IUH)Gdp + 443))
#define SET_GLOBAL_GdtrBase(v) (GLOBAL_GdtrBase = (v))
#define GLOBAL_GdtrLimit (*(IU16 *)((IUH)Gdp + 447))
#define SET_GLOBAL_GdtrLimit(v) (GLOBAL_GdtrLimit = (v))
#define GLOBAL_LdtSel (*(IU16 *)((IUH)Gdp + 451))
#define SET_GLOBAL_LdtSel(v) (GLOBAL_LdtSel = (v))
#define GLOBAL_LdtrBase (*(IU32 *)((IUH)Gdp + 455))
#define SET_GLOBAL_LdtrBase(v) (GLOBAL_LdtrBase = (v))
#define GLOBAL_LdtrLimit (*(IU32 *)((IUH)Gdp + 459))
#define SET_GLOBAL_LdtrLimit(v) (GLOBAL_LdtrLimit = (v))
#define GLOBAL_TrSel (*(IU16 *)((IUH)Gdp + 463))
#define SET_GLOBAL_TrSel(v) (GLOBAL_TrSel = (v))
#define GLOBAL_TrBase (*(IU32 *)((IUH)Gdp + 467))
#define SET_GLOBAL_TrBase(v) (GLOBAL_TrBase = (v))
#define GLOBAL_TrLimit (*(IU32 *)((IUH)Gdp + 471))
#define SET_GLOBAL_TrLimit(v) (GLOBAL_TrLimit = (v))
#define GLOBAL_TrDescSt (*(IUH *)((IUH)Gdp + 475))
#define SET_GLOBAL_TrDescSt(v) (GLOBAL_TrDescSt = (v))
#define GLOBAL_TrIoBase (*(IU32 *)((IUH)Gdp + 479))
#define SET_GLOBAL_TrIoBase(v) (GLOBAL_TrIoBase = (v))
#define GLOBAL_TrIoLimit (*(IS32 *)((IUH)Gdp + 483))
#define SET_GLOBAL_TrIoLimit(v) (GLOBAL_TrIoLimit = (v))
#define GLOBAL_IdtrBase (*(IU32 *)((IUH)Gdp + 487))
#define SET_GLOBAL_IdtrBase(v) (GLOBAL_IdtrBase = (v))
#define GLOBAL_IdtrLimit (*(IU16 *)((IUH)Gdp + 491))
#define SET_GLOBAL_IdtrLimit(v) (GLOBAL_IdtrLimit = (v))
#define GLOBAL_AbortPigRun (*(IUH *)((IUH)Gdp + 495))
#define SET_GLOBAL_AbortPigRun(v) (GLOBAL_AbortPigRun = (v))
#define GLOBAL_RegsAndFlagsUndefined (*(IUH *)((IUH)Gdp + 499))
#define SET_GLOBAL_RegsAndFlagsUndefined(v) (GLOBAL_RegsAndFlagsUndefined = (v))
#define GLOBAL_SigalrmOccurred (*(IUH *)((IUH)Gdp + 503))
#define SET_GLOBAL_SigalrmOccurred(v) (GLOBAL_SigalrmOccurred = (v))
#define GLOBAL_PigEnabled (*(IUH *)((IUH)Gdp + 507))
#define SET_GLOBAL_PigEnabled(v) (GLOBAL_PigEnabled = (v))
#define GLOBAL_EFLAGS (*(IUH *)((IUH)Gdp + 511))
#define SET_GLOBAL_EFLAGS(v) (GLOBAL_EFLAGS = (v))
#define GLOBAL_Ft (*(IUH *)((IUH)Gdp + 515))
#define SET_GLOBAL_Ft(v) (GLOBAL_Ft = (v))
#define GLOBAL_F1 (*(IUH *)((IUH)Gdp + 519))
#define SET_GLOBAL_F1(v) (GLOBAL_F1 = (v))
#define GLOBAL_F2 (*(IUH *)((IUH)Gdp + 523))
#define SET_GLOBAL_F2(v) (GLOBAL_F2 = (v))
#define GLOBAL_F3 (*(IUH *)((IUH)Gdp + 527))
#define SET_GLOBAL_F3(v) (GLOBAL_F3 = (v))
#define GLOBAL_R_CR0 (*(IUH *)((IUH)Gdp + 531))
#define SET_GLOBAL_R_CR0(v) (GLOBAL_R_CR0 = (v))
#define GLOBAL_R_CR1 (*(IUH *)((IUH)Gdp + 535))
#define SET_GLOBAL_R_CR1(v) (GLOBAL_R_CR1 = (v))
#define GLOBAL_R_CR2 (*(IUH *)((IUH)Gdp + 539))
#define SET_GLOBAL_R_CR2(v) (GLOBAL_R_CR2 = (v))
#define GLOBAL_R_CR3 (*(IUH *)((IUH)Gdp + 543))
#define SET_GLOBAL_R_CR3(v) (GLOBAL_R_CR3 = (v))
#define GLOBAL_R_CR4 (*(IUH *)((IUH)Gdp + 547))
#define SET_GLOBAL_R_CR4(v) (GLOBAL_R_CR4 = (v))
#define GLOBAL_R_CR5 (*(IUH *)((IUH)Gdp + 551))
#define SET_GLOBAL_R_CR5(v) (GLOBAL_R_CR5 = (v))
#define GLOBAL_R_CR6 (*(IUH *)((IUH)Gdp + 555))
#define SET_GLOBAL_R_CR6(v) (GLOBAL_R_CR6 = (v))
#define GLOBAL_R_CR7 (*(IUH *)((IUH)Gdp + 559))
#define SET_GLOBAL_R_CR7(v) (GLOBAL_R_CR7 = (v))
#define GLOBAL_R_TR0 (*(IUH *)((IUH)Gdp + 563))
#define SET_GLOBAL_R_TR0(v) (GLOBAL_R_TR0 = (v))
#define GLOBAL_R_TR1 (*(IUH *)((IUH)Gdp + 567))
#define SET_GLOBAL_R_TR1(v) (GLOBAL_R_TR1 = (v))
#define GLOBAL_R_TR2 (*(IUH *)((IUH)Gdp + 571))
#define SET_GLOBAL_R_TR2(v) (GLOBAL_R_TR2 = (v))
#define GLOBAL_R_TR3 (*(IUH *)((IUH)Gdp + 575))
#define SET_GLOBAL_R_TR3(v) (GLOBAL_R_TR3 = (v))
#define GLOBAL_R_TR4 (*(IUH *)((IUH)Gdp + 579))
#define SET_GLOBAL_R_TR4(v) (GLOBAL_R_TR4 = (v))
#define GLOBAL_R_TR5 (*(IUH *)((IUH)Gdp + 583))
#define SET_GLOBAL_R_TR5(v) (GLOBAL_R_TR5 = (v))
#define GLOBAL_R_TR6 (*(IUH *)((IUH)Gdp + 587))
#define SET_GLOBAL_R_TR6(v) (GLOBAL_R_TR6 = (v))
#define GLOBAL_R_TR7 (*(IUH *)((IUH)Gdp + 591))
#define SET_GLOBAL_R_TR7(v) (GLOBAL_R_TR7 = (v))
#define GLOBAL_R_DR0 (*(IUH *)((IUH)Gdp + 595))
#define SET_GLOBAL_R_DR0(v) (GLOBAL_R_DR0 = (v))
#define GLOBAL_R_DR1 (*(IUH *)((IUH)Gdp + 599))
#define SET_GLOBAL_R_DR1(v) (GLOBAL_R_DR1 = (v))
#define GLOBAL_R_DR2 (*(IUH *)((IUH)Gdp + 603))
#define SET_GLOBAL_R_DR2(v) (GLOBAL_R_DR2 = (v))
#define GLOBAL_R_DR3 (*(IUH *)((IUH)Gdp + 607))
#define SET_GLOBAL_R_DR3(v) (GLOBAL_R_DR3 = (v))
#define GLOBAL_R_DR4 (*(IUH *)((IUH)Gdp + 611))
#define SET_GLOBAL_R_DR4(v) (GLOBAL_R_DR4 = (v))
#define GLOBAL_R_DR5 (*(IUH *)((IUH)Gdp + 615))
#define SET_GLOBAL_R_DR5(v) (GLOBAL_R_DR5 = (v))
#define GLOBAL_R_DR6 (*(IUH *)((IUH)Gdp + 619))
#define SET_GLOBAL_R_DR6(v) (GLOBAL_R_DR6 = (v))
#define GLOBAL_R_DR7 (*(IUH *)((IUH)Gdp + 623))
#define SET_GLOBAL_R_DR7(v) (GLOBAL_R_DR7 = (v))
#define GLOBAL_InNanoCpu (((*(IBOOL *)((IUH)Gdp + 627)) & 1) != 0)
#define SET_GLOBAL_InNanoCpu(v) ((*(IBOOL *)((IUH)Gdp + 627)) = (v) ? 1: 0)
#define GLOBAL_UseNanoCpu (((*(IBOOL *)((IUH)Gdp + 631)) & 1) != 0)
#define SET_GLOBAL_UseNanoCpu(v) ((*(IBOOL *)((IUH)Gdp + 631)) = (v) ? 1: 0)
#define GLOBAL_UseLightCompiler (((*(IBOOL *)((IUH)Gdp + 635)) & 1) != 0)
#define SET_GLOBAL_UseLightCompiler(v) ((*(IBOOL *)((IUH)Gdp + 635)) = (v) ? 1: 0)
#define GLOBAL_NeedInterInstructionAction (((*(IBOOL *)((IUH)Gdp + 639)) & 1) != 0)
#define SET_GLOBAL_NeedInterInstructionAction(v) ((*(IBOOL *)((IUH)Gdp + 639)) = (v) ? 1: 0)
#define GLOBAL_UseCCodeCopier (((*(IBOOL *)((IUH)Gdp + 643)) & 1) != 0)
#define SET_GLOBAL_UseCCodeCopier(v) ((*(IBOOL *)((IUH)Gdp + 643)) = (v) ? 1: 0)
#define GLOBAL_seenWithFlags (((*(IBOOL *)((IUH)Gdp + 647)) & 1) != 0)
#define SET_GLOBAL_seenWithFlags(v) ((*(IBOOL *)((IUH)Gdp + 647)) = (v) ? 1: 0)
#define GLOBAL_SeenPrePatchJcond (((*(IBOOL *)((IUH)Gdp + 651)) & 1) != 0)
#define SET_GLOBAL_SeenPrePatchJcond(v) ((*(IBOOL *)((IUH)Gdp + 651)) = (v) ? 1: 0)
#define GLOBAL_needNextIntelEip (((*(IBOOL *)((IUH)Gdp + 655)) & 1) != 0)
#define SET_GLOBAL_needNextIntelEip(v) ((*(IBOOL *)((IUH)Gdp + 655)) = (v) ? 1: 0)
#define GLOBAL_CopierUniverse (*(IU32 *)((IUH)Gdp + 659))
#define SET_GLOBAL_CopierUniverse(v) (GLOBAL_CopierUniverse = (v))
#define GLOBAL_lastCopierUniverse (*(IU32 *)((IUH)Gdp + 663))
#define SET_GLOBAL_lastCopierUniverse(v) (GLOBAL_lastCopierUniverse = (v))
#define GLOBAL_LastSetCopierUniverse (*(IU32 *)((IUH)Gdp + 667))
#define SET_GLOBAL_LastSetCopierUniverse(v) (GLOBAL_LastSetCopierUniverse = (v))
#define GLOBAL_currPFragInfoRec (*(struct FragmentInfoREC* *)((IUH)Gdp + 671))
#define SET_GLOBAL_currPFragInfoRec(v) (GLOBAL_currPFragInfoRec = (v))
#define GLOBAL_maxPFragInfoRec (*(struct FragmentInfoREC* *)((IUH)Gdp + 675))
#define SET_GLOBAL_maxPFragInfoRec(v) (GLOBAL_maxPFragInfoRec = (v))
#define GLOBAL_copierCleanups (*(IU8* *)((IUH)Gdp + 679))
#define SET_GLOBAL_copierCleanups(v) (GLOBAL_copierCleanups = (v))
#define GLOBAL_lastHostCleanup (*(IU8* *)((IUH)Gdp + 683))
#define SET_GLOBAL_lastHostCleanup(v) (GLOBAL_lastHostCleanup = (v))
#define GLOBAL_lastHostAddress (*(IU32* *)((IUH)Gdp + 687))
#define SET_GLOBAL_lastHostAddress(v) (GLOBAL_lastHostAddress = (v))
#define GLOBAL_lastIntelAddress (*(IU32 *)((IUH)Gdp + 691))
#define SET_GLOBAL_lastIntelAddress(v) (GLOBAL_lastIntelAddress = (v))
#define GLOBAL_destHashTable (*(struct JUMP_REC** *)((IUH)Gdp + 695))
#define SET_GLOBAL_destHashTable(v) (GLOBAL_destHashTable = (v))
#define GLOBAL_jumpHashTable (*(struct JUMP_REC** *)((IUH)Gdp + 699))
#define SET_GLOBAL_jumpHashTable(v) (GLOBAL_jumpHashTable = (v))
#define GLOBAL_freeJumpRecPtr (*(struct JUMP_REC* *)((IUH)Gdp + 703))
#define SET_GLOBAL_freeJumpRecPtr(v) (GLOBAL_freeJumpRecPtr = (v))
#define GLOBAL_nextFreeJumpRec (*(struct JUMP_REC* *)((IUH)Gdp + 707))
#define SET_GLOBAL_nextFreeJumpRec(v) (GLOBAL_nextFreeJumpRec = (v))
#define GLOBAL_freeJumpRecCount (*(IS32 *)((IUH)Gdp + 711))
#define SET_GLOBAL_freeJumpRecCount(v) (GLOBAL_freeJumpRecCount = (v))
#define GLOBAL_poolJumpRecCount (*(IU32 *)((IUH)Gdp + 715))
#define SET_GLOBAL_poolJumpRecCount(v) (GLOBAL_poolJumpRecCount = (v))
#define GLOBAL_vctOffsets (*(IU16* *)((IUH)Gdp + 719))
#define SET_GLOBAL_vctOffsets(v) (GLOBAL_vctOffsets = (v))
#define GLOBAL_anonOffsets (*(IU16* *)((IUH)Gdp + 723))
#define SET_GLOBAL_anonOffsets(v) (GLOBAL_anonOffsets = (v))
#define GLOBAL_selectionDataBasePtr (*(struct selectionDataREC* *)((IUH)Gdp + 727))
#define SET_GLOBAL_selectionDataBasePtr(v) (GLOBAL_selectionDataBasePtr = (v))
#define GLOBAL_soloCodeBasePtr (*(struct codeAndActionDataREC* *)((IUH)Gdp + 731))
#define SET_GLOBAL_soloCodeBasePtr(v) (GLOBAL_soloCodeBasePtr = (v))
#define GLOBAL_multiCodeBasePtr (*(struct codeAndActionDataREC* *)((IUH)Gdp + 735))
#define SET_GLOBAL_multiCodeBasePtr(v) (GLOBAL_multiCodeBasePtr = (v))
#define GLOBAL_codeOffsScaleShift (*(IU32 *)((IUH)Gdp + 739))
#define SET_GLOBAL_codeOffsScaleShift(v) (GLOBAL_codeOffsScaleShift = (v))
#define GLOBAL_tuples (*(struct TUPLE_REC* *)((IUH)Gdp + 743))
#define SET_GLOBAL_tuples(v) (GLOBAL_tuples = (v))
#define GLOBAL_cursor (*(struct TUPLE_REC* *)((IUH)Gdp + 747))
#define SET_GLOBAL_cursor(v) (GLOBAL_cursor = (v))
#define GLOBAL_tuplePtr (*(struct TUPLE_REC* *)((IUH)Gdp + 751))
#define SET_GLOBAL_tuplePtr(v) (GLOBAL_tuplePtr = (v))
#define GLOBAL_patchRecPtr (*(IU8* *)((IUH)Gdp + 755))
#define SET_GLOBAL_patchRecPtr(v) (GLOBAL_patchRecPtr = (v))
#define GLOBAL_srcPtr (*(IU32* *)((IUH)Gdp + 759))
#define SET_GLOBAL_srcPtr(v) (GLOBAL_srcPtr = (v))
#define GLOBAL_dstPtr (*(IU32* *)((IUH)Gdp + 763))
#define SET_GLOBAL_dstPtr(v) (GLOBAL_dstPtr = (v))
#define GLOBAL_BackoverMarkerAddr (*(IU32* *)((IUH)Gdp + 767))
#define SET_GLOBAL_BackoverMarkerAddr(v) (GLOBAL_BackoverMarkerAddr = (v))
#define GLOBAL_patchTable (*(IU32** *)((IUH)Gdp + 771))
#define SET_GLOBAL_patchTable(v) (GLOBAL_patchTable = (v))
#define GLOBAL_patchNames (*(IU8** *)((IUH)Gdp + 775))
#define SET_GLOBAL_patchNames(v) (GLOBAL_patchNames = (v))
#define GLOBAL_CopierFt (*(IUH *)((IUH)Gdp + 779))
#define SET_GLOBAL_CopierFt(v) (GLOBAL_CopierFt = (v))
#define GLOBAL_FtIsLazy (((*(IBOOL *)((IUH)Gdp + 783)) & 1) != 0)
#define SET_GLOBAL_FtIsLazy(v) ((*(IBOOL *)((IUH)Gdp + 783)) = (v) ? 1: 0)
#define GLOBAL_UnivIsLazy (((*(IBOOL *)((IUH)Gdp + 787)) & 1) != 0)
#define SET_GLOBAL_UnivIsLazy(v) ((*(IBOOL *)((IUH)Gdp + 787)) = (v) ? 1: 0)
#define GLOBAL_FlagsAreSuppressed (((*(IBOOL *)((IUH)Gdp + 791)) & 1) != 0)
#define SET_GLOBAL_FlagsAreSuppressed(v) ((*(IBOOL *)((IUH)Gdp + 791)) = (v) ? 1: 0)
#define GLOBAL_lastLazyFt (*(IUH *)((IUH)Gdp + 795))
#define SET_GLOBAL_lastLazyFt(v) (GLOBAL_lastLazyFt = (v))
#define GLOBAL_univVarMask (*(IU32 *)((IUH)Gdp + 799))
#define SET_GLOBAL_univVarMask(v) (GLOBAL_univVarMask = (v))
#define GLOBAL_zSafeContinueCheckEFI (*(IU16 *)((IUH)Gdp + 803))
#define SET_GLOBAL_zSafeContinueCheckEFI(v) (GLOBAL_zSafeContinueCheckEFI = (v))
#define GLOBAL_zCoRoRetEFI (*(IU16 *)((IUH)Gdp + 807))
#define SET_GLOBAL_zCoRoRetEFI(v) (GLOBAL_zCoRoRetEFI = (v))
#define GLOBAL_zPatchMeEFI (*(IU16 *)((IUH)Gdp + 811))
#define SET_GLOBAL_zPatchMeEFI(v) (GLOBAL_zPatchMeEFI = (v))
#define GLOBAL_zPostPopEFI (*(IU16 *)((IUH)Gdp + 815))
#define SET_GLOBAL_zPostPopEFI(v) (GLOBAL_zPostPopEFI = (v))
#define GLOBAL_zAdjustHspEFI (*(IU16 *)((IUH)Gdp + 819))
#define SET_GLOBAL_zAdjustHspEFI(v) (GLOBAL_zAdjustHspEFI = (v))
#define GLOBAL_zLssSpEFI (*(IU16 *)((IUH)Gdp + 823))
#define SET_GLOBAL_zLssSpEFI(v) (GLOBAL_zLssSpEFI = (v))
#define GLOBAL_zLssEspEFI (*(IU16 *)((IUH)Gdp + 827))
#define SET_GLOBAL_zLssEspEFI(v) (GLOBAL_zLssEspEFI = (v))
#define GLOBAL_lastInstructionInFragment (((*(IBOOL *)((IUH)Gdp + 831)) & 1) != 0)
#define SET_GLOBAL_lastInstructionInFragment(v) ((*(IBOOL *)((IUH)Gdp + 831)) = (v) ? 1: 0)
#define GLOBAL_lateInInstruction (((*(IBOOL *)((IUH)Gdp + 835)) & 1) != 0)
#define SET_GLOBAL_lateInInstruction(v) ((*(IBOOL *)((IUH)Gdp + 835)) = (v) ? 1: 0)
#define GLOBAL_stackDestViaAdjust (((*(IBOOL *)((IUH)Gdp + 839)) & 1) != 0)
#define SET_GLOBAL_stackDestViaAdjust(v) ((*(IBOOL *)((IUH)Gdp + 839)) = (v) ? 1: 0)
#define GLOBAL_stackDestAdjustPositive (((*(IBOOL *)((IUH)Gdp + 843)) & 1) != 0)
#define SET_GLOBAL_stackDestAdjustPositive(v) ((*(IBOOL *)((IUH)Gdp + 843)) = (v) ? 1: 0)
#define GLOBAL_stackDestAdjustUnitary (((*(IBOOL *)((IUH)Gdp + 847)) & 1) != 0)
#define SET_GLOBAL_stackDestAdjustUnitary(v) ((*(IBOOL *)((IUH)Gdp + 847)) = (v) ? 1: 0)
#define GLOBAL_suppressHspCheck (((*(IBOOL *)((IUH)Gdp + 851)) & 1) != 0)
#define SET_GLOBAL_suppressHspCheck(v) ((*(IBOOL *)((IUH)Gdp + 851)) = (v) ? 1: 0)
#define GLOBAL_suppressHbpCheck (((*(IBOOL *)((IUH)Gdp + 855)) & 1) != 0)
#define SET_GLOBAL_suppressHbpCheck(v) ((*(IBOOL *)((IUH)Gdp + 855)) = (v) ? 1: 0)
#define GLOBAL_ReSelectVariant (((*(IBOOL *)((IUH)Gdp + 859)) & 1) != 0)
#define SET_GLOBAL_ReSelectVariant(v) ((*(IBOOL *)((IUH)Gdp + 859)) = (v) ? 1: 0)
#define GLOBAL_ReSelectTupleSkipCnt (*(ISH *)((IUH)Gdp + 863))
#define SET_GLOBAL_ReSelectTupleSkipCnt(v) (GLOBAL_ReSelectTupleSkipCnt = (v))
#define GLOBAL_suppressEaThread (((*(IBOOL *)((IUH)Gdp + 867)) & 1) != 0)
#define SET_GLOBAL_suppressEaThread(v) ((*(IBOOL *)((IUH)Gdp + 867)) = (v) ? 1: 0)
#define GLOBAL_postPopPending (((*(IBOOL *)((IUH)Gdp + 871)) & 1) != 0)
#define SET_GLOBAL_postPopPending(v) ((*(IBOOL *)((IUH)Gdp + 871)) = (v) ? 1: 0)
#define GLOBAL_postPopSize (*(IU32 *)((IUH)Gdp + 875))
#define SET_GLOBAL_postPopSize(v) (GLOBAL_postPopSize = (v))
#define GLOBAL_PatchIdLazyPatch (*(IU16 *)((IUH)Gdp + 879))
#define SET_GLOBAL_PatchIdLazyPatch(v) (GLOBAL_PatchIdLazyPatch = (v))
#define GLOBAL_PatchIdBailoutDispatch (*(IU16 *)((IUH)Gdp + 883))
#define SET_GLOBAL_PatchIdBailoutDispatch(v) (GLOBAL_PatchIdBailoutDispatch = (v))
#define GLOBAL_PatchIdCondRetDispatch (*(IU16 *)((IUH)Gdp + 887))
#define SET_GLOBAL_PatchIdCondRetDispatch(v) (GLOBAL_PatchIdCondRetDispatch = (v))
#define GLOBAL_compTimeFtBitNum (*(IU32 *)((IUH)Gdp + 891))
#define SET_GLOBAL_compTimeFtBitNum(v) (GLOBAL_compTimeFtBitNum = (v))
#define GLOBAL_realmodeBitNum (*(IU32 *)((IUH)Gdp + 895))
#define SET_GLOBAL_realmodeBitNum(v) (GLOBAL_realmodeBitNum = (v))
#define GLOBAL_pmSrSemanticsBitNum (*(IU32 *)((IUH)Gdp + 899))
#define SET_GLOBAL_pmSrSemanticsBitNum(v) (GLOBAL_pmSrSemanticsBitNum = (v))
#define GLOBAL_v8086BitNum (*(IU32 *)((IUH)Gdp + 903))
#define SET_GLOBAL_v8086BitNum(v) (GLOBAL_v8086BitNum = (v))
#define GLOBAL_accIsReadBitMask (*(IU32 *)((IUH)Gdp + 907))
#define SET_GLOBAL_accIsReadBitMask(v) (GLOBAL_accIsReadBitMask = (v))
#define GLOBAL_SOBbitMask (*(IU32 *)((IUH)Gdp + 911))
#define SET_GLOBAL_SOBbitMask(v) (GLOBAL_SOBbitMask = (v))
#define GLOBAL_BOBbitMask (*(IU32 *)((IUH)Gdp + 915))
#define SET_GLOBAL_BOBbitMask(v) (GLOBAL_BOBbitMask = (v))
#define GLOBAL_CCObitMask (*(IU32 *)((IUH)Gdp + 919))
#define SET_GLOBAL_CCObitMask(v) (GLOBAL_CCObitMask = (v))
#define GLOBAL_useHbpBitMask (*(IU32 *)((IUH)Gdp + 923))
#define SET_GLOBAL_useHbpBitMask(v) (GLOBAL_useHbpBitMask = (v))
#define GLOBAL_NeedSafeToContinueCheck (((*(IBOOL *)((IUH)Gdp + 927)) & 1) != 0)
#define SET_GLOBAL_NeedSafeToContinueCheck(v) ((*(IBOOL *)((IUH)Gdp + 927)) = (v) ? 1: 0)
#define GLOBAL_ContinueCheckFailure (((*(IBOOL *)((IUH)Gdp + 931)) & 1) != 0)
#define SET_GLOBAL_ContinueCheckFailure(v) ((*(IBOOL *)((IUH)Gdp + 931)) = (v) ? 1: 0)
#define GLOBAL_NeedCoRoutineReturn (((*(IBOOL *)((IUH)Gdp + 935)) & 1) != 0)
#define SET_GLOBAL_NeedCoRoutineReturn(v) ((*(IBOOL *)((IUH)Gdp + 935)) = (v) ? 1: 0)
#define GLOBAL_SuppressCoRoutineReturn (((*(IBOOL *)((IUH)Gdp + 939)) & 1) != 0)
#define SET_GLOBAL_SuppressCoRoutineReturn(v) ((*(IBOOL *)((IUH)Gdp + 939)) = (v) ? 1: 0)
#define GLOBAL_RwCopyingWriteBack (((*(IBOOL *)((IUH)Gdp + 943)) & 1) != 0)
#define SET_GLOBAL_RwCopyingWriteBack(v) ((*(IBOOL *)((IUH)Gdp + 943)) = (v) ? 1: 0)
#define GLOBAL_LazyCoRoRet (((*(IBOOL *)((IUH)Gdp + 947)) & 1) != 0)
#define SET_GLOBAL_LazyCoRoRet(v) ((*(IBOOL *)((IUH)Gdp + 947)) = (v) ? 1: 0)
#define GLOBAL_noFlagsBitMask (*(IU32 *)((IUH)Gdp + 951))
#define SET_GLOBAL_noFlagsBitMask(v) (GLOBAL_noFlagsBitMask = (v))
#define GLOBAL_currCompileMinLa (*(IU32 *)((IUH)Gdp + 955))
#define SET_GLOBAL_currCompileMinLa(v) (GLOBAL_currCompileMinLa = (v))
#define GLOBAL_currCompileMaxLa (*(IU32 *)((IUH)Gdp + 959))
#define SET_GLOBAL_currCompileMaxLa(v) (GLOBAL_currCompileMaxLa = (v))
#define GLOBAL_DoRWImmOpt (((*(IBOOL *)((IUH)Gdp + 963)) & 1) != 0)
#define SET_GLOBAL_DoRWImmOpt(v) ((*(IBOOL *)((IUH)Gdp + 963)) = (v) ? 1: 0)
#define GLOBAL_ImmRWOptMaskBit (*(IUH *)((IUH)Gdp + 967))
#define SET_GLOBAL_ImmRWOptMaskBit(v) (GLOBAL_ImmRWOptMaskBit = (v))
#define GLOBAL_NoImmRWOptMaskBit (*(IUH *)((IUH)Gdp + 971))
#define SET_GLOBAL_NoImmRWOptMaskBit(v) (GLOBAL_NoImmRWOptMaskBit = (v))
#define GLOBAL_ImmRWAddr32Mask (*(IUH *)((IUH)Gdp + 975))
#define SET_GLOBAL_ImmRWAddr32Mask(v) (GLOBAL_ImmRWAddr32Mask = (v))
#define GLOBAL_NaturalAlignmentCVMask (*(IUH *)((IUH)Gdp + 979))
#define SET_GLOBAL_NaturalAlignmentCVMask(v) (GLOBAL_NaturalAlignmentCVMask = (v))
#define GLOBAL_ImmRWPhysPtr (*(IU8* *)((IUH)Gdp + 983))
#define SET_GLOBAL_ImmRWPhysPtr(v) (GLOBAL_ImmRWPhysPtr = (v))
#define GLOBAL_InheritedDangerousCVs (*(IU32 *)((IUH)Gdp + 987))
#define SET_GLOBAL_InheritedDangerousCVs(v) (GLOBAL_InheritedDangerousCVs = (v))
#define GLOBAL_FragDangerousCVMask (*(IU32 *)((IUH)Gdp + 991))
#define SET_GLOBAL_FragDangerousCVMask(v) (GLOBAL_FragDangerousCVMask = (v))
#define GLOBAL_zFragProfEFI (*(IU16 *)((IUH)Gdp + 995))
#define SET_GLOBAL_zFragProfEFI(v) (GLOBAL_zFragProfEFI = (v))
#define GLOBAL_FragProfIndex (*(IUH *)((IUH)Gdp + 999))
#define SET_GLOBAL_FragProfIndex(v) (GLOBAL_FragProfIndex = (v))
#define GLOBAL_DynamicSrcRegActions (*(IU8* *)((IUH)Gdp + 1003))
#define SET_GLOBAL_DynamicSrcRegActions(v) (GLOBAL_DynamicSrcRegActions = (v))
#define GLOBAL_outlierAddr (*(IU32* *)((IUH)Gdp + 1007))
#define SET_GLOBAL_outlierAddr(v) (GLOBAL_outlierAddr = (v))
#define GLOBAL_jumpRecPtr (*(struct JUMP_REC* *)((IUH)Gdp + 1011))
#define SET_GLOBAL_jumpRecPtr(v) (GLOBAL_jumpRecPtr = (v))
#define GLOBAL_HbpIsSetup (((*(IBOOL *)((IUH)Gdp + 1015)) & 1) != 0)
#define SET_GLOBAL_HbpIsSetup(v) ((*(IBOOL *)((IUH)Gdp + 1015)) = (v) ? 1: 0)
#define GLOBAL_hbpMinDisp (*(IUH *)((IUH)Gdp + 1019))
#define SET_GLOBAL_hbpMinDisp(v) (GLOBAL_hbpMinDisp = (v))
#define GLOBAL_hbpMaxDisp (*(IUH *)((IUH)Gdp + 1023))
#define SET_GLOBAL_hbpMaxDisp(v) (GLOBAL_hbpMaxDisp = (v))
#define GLOBAL_DSTAT_DsBaseBailOuts (*(IUH *)((IUH)Gdp + 1027))
#define SET_GLOBAL_DSTAT_DsBaseBailOuts(v) (GLOBAL_DSTAT_DsBaseBailOuts = (v))
#define GLOBAL_DsIsChecked (((*(IBOOL *)((IUH)Gdp + 1031)) & 1) != 0)
#define SET_GLOBAL_DsIsChecked(v) ((*(IBOOL *)((IUH)Gdp + 1031)) = (v) ? 1: 0)
#define GLOBAL_EDL_WORKSPACE_61 (*(IUH *)((IUH)Gdp + 1035))
#define SET_GLOBAL_EDL_WORKSPACE_61(v) (GLOBAL_EDL_WORKSPACE_61 = (v))
#define GLOBAL_CleanedRec (*(struct CleanedREC *)((IUH)Gdp + 1039))
#define SET_GLOBAL_CleanedRec(v) (GLOBAL_CleanedRec = (v))
#define GLOBAL_CurrentUniverse (*(IU32 *)((IUH)Gdp + 1055))
#define SET_GLOBAL_CurrentUniverse(v) (GLOBAL_CurrentUniverse = (v))
#define GLOBAL_EntryPointCache (*(struct EntryPointCacheREC* *)((IUH)Gdp + 1059))
#define SET_GLOBAL_EntryPointCache(v) (GLOBAL_EntryPointCache = (v))
#define GLOBAL_CsSkewedEntryPointCache (*(struct EntryPointCacheREC* *)((IUH)Gdp + 1063))
#define SET_GLOBAL_CsSkewedEntryPointCache(v) (GLOBAL_CsSkewedEntryPointCache = (v))
#define GLOBAL_CsLinear (*(IU32 *)((IUH)Gdp + 1067))
#define SET_GLOBAL_CsLinear(v) (GLOBAL_CsLinear = (v))
#define GLOBAL_LruCountdown (*(IS32 *)((IUH)Gdp + 1071))
#define SET_GLOBAL_LruCountdown(v) (GLOBAL_LruCountdown = (v))
#define GLOBAL_LruCountdownResetValue (*(IS32 *)((IUH)Gdp + 1075))
#define SET_GLOBAL_LruCountdownResetValue(v) (GLOBAL_LruCountdownResetValue = (v))
#define GLOBAL_JumpCounter (*(ISH *)((IUH)Gdp + 1079))
#define SET_GLOBAL_JumpCounter(v) (GLOBAL_JumpCounter = (v))
#define GLOBAL_JumpRestart (*(ISH *)((IUH)Gdp + 1083))
#define SET_GLOBAL_JumpRestart(v) (GLOBAL_JumpRestart = (v))
#define GLOBAL_JumpCalibrate (*(ISH *)((IUH)Gdp + 1087))
#define SET_GLOBAL_JumpCalibrate(v) (GLOBAL_JumpCalibrate = (v))
#define GLOBAL_InitialJumpCounter (*(ISH *)((IUH)Gdp + 1091))
#define SET_GLOBAL_InitialJumpCounter(v) (GLOBAL_InitialJumpCounter = (v))
#define GLOBAL_minimumInitialVal (*(IUH *)((IUH)Gdp + 1095))
#define SET_GLOBAL_minimumInitialVal(v) (GLOBAL_minimumInitialVal = (v))
#define GLOBAL_cyclicJcRestartVal (*(IUH *)((IUH)Gdp + 1099))
#define SET_GLOBAL_cyclicJcRestartVal(v) (GLOBAL_cyclicJcRestartVal = (v))
#define GLOBAL_IretHookStack (*(struct IretHookStackREC* *)((IUH)Gdp + 1103))
#define SET_GLOBAL_IretHookStack(v) (GLOBAL_IretHookStack = (v))
#define GLOBAL_IretHookStackIndex (*(ISH *)((IUH)Gdp + 1107))
#define SET_GLOBAL_IretHookStackIndex(v) (GLOBAL_IretHookStackIndex = (v))
#define GLOBAL_InstructionCount (*(IUH *)((IUH)Gdp + 1111))
#define SET_GLOBAL_InstructionCount(v) (GLOBAL_InstructionCount = (v))
#define GLOBAL_Constraint2CvMap (*(IU32* *)((IUH)Gdp + 1115))
#define SET_GLOBAL_Constraint2CvMap(v) (GLOBAL_Constraint2CvMap = (v))
#define GLOBAL_InsertBPIs (((*(IBOOL *)((IUH)Gdp + 1119)) & 1) != 0)
#define SET_GLOBAL_InsertBPIs(v) ((*(IBOOL *)((IUH)Gdp + 1119)) = (v) ? 1: 0)
#define GLOBAL_CurrentCookie (*(IU32 *)((IUH)Gdp + 1123))
#define SET_GLOBAL_CurrentCookie(v) (GLOBAL_CurrentCookie = (v))
#define GLOBAL_ReadWriteCache (*(struct ReadWriteCacheRecord* *)((IUH)Gdp + 1127))
#define SET_GLOBAL_ReadWriteCache(v) (GLOBAL_ReadWriteCache = (v))
#define GLOBAL_ReadWriteBackup (*(struct ReadWriteBackupRecord* *)((IUH)Gdp + 1131))
#define SET_GLOBAL_ReadWriteBackup(v) (GLOBAL_ReadWriteBackup = (v))
#define GLOBAL_EsCookie (*(IU32 *)((IUH)Gdp + 1135))
#define SET_GLOBAL_EsCookie(v) (GLOBAL_EsCookie = (v))
#define GLOBAL_CsCookie (*(IU32 *)((IUH)Gdp + 1139))
#define SET_GLOBAL_CsCookie(v) (GLOBAL_CsCookie = (v))
#define GLOBAL_SsCookie (*(IU32 *)((IUH)Gdp + 1143))
#define SET_GLOBAL_SsCookie(v) (GLOBAL_SsCookie = (v))
#define GLOBAL_DsCookie (*(IU32 *)((IUH)Gdp + 1147))
#define SET_GLOBAL_DsCookie(v) (GLOBAL_DsCookie = (v))
#define GLOBAL_LinearCookie (*(IU32 *)((IUH)Gdp + 1151))
#define SET_GLOBAL_LinearCookie(v) (GLOBAL_LinearCookie = (v))
#define GLOBAL_SystemCookie (*(IU32 *)((IUH)Gdp + 1155))
#define SET_GLOBAL_SystemCookie(v) (GLOBAL_SystemCookie = (v))
#define GLOBAL_FsCookie (*(IU32 *)((IUH)Gdp + 1159))
#define SET_GLOBAL_FsCookie(v) (GLOBAL_FsCookie = (v))
#define GLOBAL_GsCookie (*(IU32 *)((IUH)Gdp + 1163))
#define SET_GLOBAL_GsCookie(v) (GLOBAL_GsCookie = (v))
#define GLOBAL_NextCookie (*(IU32 *)((IUH)Gdp + 1167))
#define SET_GLOBAL_NextCookie(v) (GLOBAL_NextCookie = (v))
#define GLOBAL_RealModeCookies (*(IU32* *)((IUH)Gdp + 1171))
#define SET_GLOBAL_RealModeCookies(v) (GLOBAL_RealModeCookies = (v))
#define GLOBAL_RealModeCurrentCookies (*(IU32* *)((IUH)Gdp + 1175))
#define SET_GLOBAL_RealModeCurrentCookies(v) (GLOBAL_RealModeCurrentCookies = (v))
#define GLOBAL_LinearCookies (*(IU32* *)((IUH)Gdp + 1179))
#define SET_GLOBAL_LinearCookies(v) (GLOBAL_LinearCookies = (v))
#define GLOBAL_SystemCookies (*(IU32* *)((IUH)Gdp + 1183))
#define SET_GLOBAL_SystemCookies(v) (GLOBAL_SystemCookies = (v))
#define GLOBAL_CookiesToReset (*(IU32** *)((IUH)Gdp + 1187))
#define SET_GLOBAL_CookiesToReset(v) (GLOBAL_CookiesToReset = (v))
#define GLOBAL_NrOfCookiesToReset (*(IUH *)((IUH)Gdp + 1191))
#define SET_GLOBAL_NrOfCookiesToReset(v) (GLOBAL_NrOfCookiesToReset = (v))
#define GLOBAL_ReadWriteScratchBuffer (*(IU8* *)((IUH)Gdp + 1195))
#define SET_GLOBAL_ReadWriteScratchBuffer(v) (GLOBAL_ReadWriteScratchBuffer = (v))
#define GLOBAL_ScratchSequenceNumber (*(IUH *)((IUH)Gdp + 1199))
#define SET_GLOBAL_ScratchSequenceNumber(v) (GLOBAL_ScratchSequenceNumber = (v))
#define GLOBAL_RdWrPrimaryHits (*(IUH *)((IUH)Gdp + 1203))
#define SET_GLOBAL_RdWrPrimaryHits(v) (GLOBAL_RdWrPrimaryHits = (v))
#define GLOBAL_RdWrVideoAccesses (*(IUH *)((IUH)Gdp + 1207))
#define SET_GLOBAL_RdWrVideoAccesses(v) (GLOBAL_RdWrVideoAccesses = (v))
#define GLOBAL_RdWrFastProtectedWrites (*(IUH *)((IUH)Gdp + 1211))
#define SET_GLOBAL_RdWrFastProtectedWrites(v) (GLOBAL_RdWrFastProtectedWrites = (v))
#define GLOBAL_RdWrSlowProtectedWrites (*(IUH *)((IUH)Gdp + 1215))
#define SET_GLOBAL_RdWrSlowProtectedWrites(v) (GLOBAL_RdWrSlowProtectedWrites = (v))
#define GLOBAL_RdWrLoads (*(IUH *)((IUH)Gdp + 1219))
#define SET_GLOBAL_RdWrLoads(v) (GLOBAL_RdWrLoads = (v))
#define GLOBAL_RdWrBackupLoads (*(IUH *)((IUH)Gdp + 1223))
#define SET_GLOBAL_RdWrBackupLoads(v) (GLOBAL_RdWrBackupLoads = (v))
#define GLOBAL_RdWrRemovals (*(IUH *)((IUH)Gdp + 1227))
#define SET_GLOBAL_RdWrRemovals(v) (GLOBAL_RdWrRemovals = (v))
#define GLOBAL_RdWrCookieAllocations (*(IUH *)((IUH)Gdp + 1231))
#define SET_GLOBAL_RdWrCookieAllocations(v) (GLOBAL_RdWrCookieAllocations = (v))
#define GLOBAL_RdWrReconstructs (*(IUH *)((IUH)Gdp + 1235))
#define SET_GLOBAL_RdWrReconstructs(v) (GLOBAL_RdWrReconstructs = (v))
#define GLOBAL_RdWrCacheResets (*(IUH *)((IUH)Gdp + 1239))
#define SET_GLOBAL_RdWrCacheResets(v) (GLOBAL_RdWrCacheResets = (v))
#define GLOBAL_RdWrCookieResets (*(IUH *)((IUH)Gdp + 1243))
#define SET_GLOBAL_RdWrCookieResets(v) (GLOBAL_RdWrCookieResets = (v))
#define GLOBAL_RdWrSegCookieInits (*(IUH *)((IUH)Gdp + 1247))
#define SET_GLOBAL_RdWrSegCookieInits(v) (GLOBAL_RdWrSegCookieInits = (v))
#define GLOBAL_RdWrStats1 (*(IUH *)((IUH)Gdp + 1251))
#define SET_GLOBAL_RdWrStats1(v) (GLOBAL_RdWrStats1 = (v))
#define GLOBAL_RdWrStats2 (*(IUH *)((IUH)Gdp + 1255))
#define SET_GLOBAL_RdWrStats2(v) (GLOBAL_RdWrStats2 = (v))
#define GLOBAL_RdWrStats3 (*(IUH *)((IUH)Gdp + 1259))
#define SET_GLOBAL_RdWrStats3(v) (GLOBAL_RdWrStats3 = (v))
#define GLOBAL_RdWrStats4 (*(IUH *)((IUH)Gdp + 1263))
#define SET_GLOBAL_RdWrStats4(v) (GLOBAL_RdWrStats4 = (v))
#define GLOBAL_RdWrStats5 (*(IUH *)((IUH)Gdp + 1267))
#define SET_GLOBAL_RdWrStats5(v) (GLOBAL_RdWrStats5 = (v))
#define GLOBAL_RdWrStats6 (*(IUH *)((IUH)Gdp + 1271))
#define SET_GLOBAL_RdWrStats6(v) (GLOBAL_RdWrStats6 = (v))
#define GLOBAL_RdWrStats7 (*(IUH *)((IUH)Gdp + 1275))
#define SET_GLOBAL_RdWrStats7(v) (GLOBAL_RdWrStats7 = (v))
#define GLOBAL_RdWrStats8 (*(IUH *)((IUH)Gdp + 1279))
#define SET_GLOBAL_RdWrStats8(v) (GLOBAL_RdWrStats8 = (v))
#define GLOBAL_RdWrStats9 (*(IUH *)((IUH)Gdp + 1283))
#define SET_GLOBAL_RdWrStats9(v) (GLOBAL_RdWrStats9 = (v))
#define GLOBAL_RdWrStats10 (*(IUH *)((IUH)Gdp + 1287))
#define SET_GLOBAL_RdWrStats10(v) (GLOBAL_RdWrStats10 = (v))
#define GLOBAL_RdWrStats11 (*(IUH *)((IUH)Gdp + 1291))
#define SET_GLOBAL_RdWrStats11(v) (GLOBAL_RdWrStats11 = (v))
#define GLOBAL_RdWrStats12 (*(IUH *)((IUH)Gdp + 1295))
#define SET_GLOBAL_RdWrStats12(v) (GLOBAL_RdWrStats12 = (v))
#define GLOBAL_VddAreaStart (*(IU8* *)((IUH)Gdp + 1299))
#define SET_GLOBAL_VddAreaStart(v) (GLOBAL_VddAreaStart = (v))
#define GLOBAL_VddAreaEnd (*(IU8* *)((IUH)Gdp + 1303))
#define SET_GLOBAL_VddAreaEnd(v) (GLOBAL_VddAreaEnd = (v))
#define GLOBAL_SafeToUseSas (((*(IBOOL *)((IUH)Gdp + 1307)) & 1) != 0)
#define SET_GLOBAL_SafeToUseSas(v) ((*(IBOOL *)((IUH)Gdp + 1307)) = (v) ? 1: 0)
#define GLOBAL_VirtualiseDataSel (*(IU16 *)((IUH)Gdp + 1311))
#define SET_GLOBAL_VirtualiseDataSel(v) (GLOBAL_VirtualiseDataSel = (v))
#define GLOBAL_VirtualiseCodeSel (*(IU16 *)((IUH)Gdp + 1315))
#define SET_GLOBAL_VirtualiseCodeSel(v) (GLOBAL_VirtualiseCodeSel = (v))
#define GLOBAL_VirtualiseSelsSet (((*(IBOOL *)((IUH)Gdp + 1319)) & 1) != 0)
#define SET_GLOBAL_VirtualiseSelsSet(v) ((*(IBOOL *)((IUH)Gdp + 1319)) = (v) ? 1: 0)
#define GLOBAL_EAXsaved (*(IUH *)((IUH)Gdp + 1323))
#define SET_GLOBAL_EAXsaved(v) (GLOBAL_EAXsaved = (v))
#define GLOBAL_EBXsaved (*(IUH *)((IUH)Gdp + 1327))
#define SET_GLOBAL_EBXsaved(v) (GLOBAL_EBXsaved = (v))
#define GLOBAL_ECXsaved (*(IUH *)((IUH)Gdp + 1331))
#define SET_GLOBAL_ECXsaved(v) (GLOBAL_ECXsaved = (v))
#define GLOBAL_EDXsaved (*(IUH *)((IUH)Gdp + 1335))
#define SET_GLOBAL_EDXsaved(v) (GLOBAL_EDXsaved = (v))
#define GLOBAL_ESIsaved (*(IUH *)((IUH)Gdp + 1339))
#define SET_GLOBAL_ESIsaved(v) (GLOBAL_ESIsaved = (v))
#define GLOBAL_EDIsaved (*(IUH *)((IUH)Gdp + 1343))
#define SET_GLOBAL_EDIsaved(v) (GLOBAL_EDIsaved = (v))
#define GLOBAL_EBPsaved (*(IUH *)((IUH)Gdp + 1347))
#define SET_GLOBAL_EBPsaved(v) (GLOBAL_EBPsaved = (v))
#define GLOBAL_SafeToContinueInFragment (((*(IBOOL *)((IUH)Gdp + 1351)) & 1) != 0)
#define SET_GLOBAL_SafeToContinueInFragment(v) ((*(IBOOL *)((IUH)Gdp + 1351)) = (v) ? 1: 0)
#define GLOBAL_InsideTheCpu (((*(IBOOL *)((IUH)Gdp + 1355)) & 1) != 0)
#define SET_GLOBAL_InsideTheCpu(v) ((*(IBOOL *)((IUH)Gdp + 1355)) = (v) ? 1: 0)
#define GLOBAL_SimulateNestingLevel (*(IUH *)((IUH)Gdp + 1359))
#define SET_GLOBAL_SimulateNestingLevel(v) (GLOBAL_SimulateNestingLevel = (v))
#define GLOBAL_CpuIsInitialised (((*(IBOOL *)((IUH)Gdp + 1363)) & 1) != 0)
#define SET_GLOBAL_CpuIsInitialised(v) ((*(IBOOL *)((IUH)Gdp + 1363)) = (v) ? 1: 0)
#define GLOBAL_AR_FixupWanted (((*(IBOOL *)((IUH)Gdp + 1367)) & 1) != 0)
#define SET_GLOBAL_AR_FixupWanted(v) ((*(IBOOL *)((IUH)Gdp + 1367)) = (v) ? 1: 0)
#define GLOBAL_BopCausedTimesliceNap (((*(IBOOL *)((IUH)Gdp + 1371)) & 1) != 0)
#define SET_GLOBAL_BopCausedTimesliceNap(v) ((*(IBOOL *)((IUH)Gdp + 1371)) = (v) ? 1: 0)
#define GLOBAL_D6isBop (((*(IBOOL *)((IUH)Gdp + 1375)) & 1) != 0)
#define SET_GLOBAL_D6isBop(v) ((*(IBOOL *)((IUH)Gdp + 1375)) = (v) ? 1: 0)
#define GLOBAL_BopTable (*(IU8** *)((IUH)Gdp + 1379))
#define SET_GLOBAL_BopTable(v) (GLOBAL_BopTable = (v))
#define GLOBAL_BopNumberAndArgument (*(IU32 *)((IUH)Gdp + 1383))
#define SET_GLOBAL_BopNumberAndArgument(v) (GLOBAL_BopNumberAndArgument = (v))
#define GLOBAL_MsWindowsParameters (*(IU16* *)((IUH)Gdp + 1387))
#define SET_GLOBAL_MsWindowsParameters(v) (GLOBAL_MsWindowsParameters = (v))
#define GLOBAL_UsingMsWindowsGlueBop (((*(IBOOL *)((IUH)Gdp + 1391)) & 1) != 0)
#define SET_GLOBAL_UsingMsWindowsGlueBop(v) ((*(IBOOL *)((IUH)Gdp + 1391)) = (v) ? 1: 0)
#define GLOBAL_LxS_hackyfix (*(IUH *)((IUH)Gdp + 1395))
#define SET_GLOBAL_LxS_hackyfix(v) (GLOBAL_LxS_hackyfix = (v))
#define GLOBAL_SavedFt (*(IUH *)((IUH)Gdp + 1399))
#define SET_GLOBAL_SavedFt(v) (GLOBAL_SavedFt = (v))
#define GLOBAL_SavedCF (*(IUH *)((IUH)Gdp + 1403))
#define SET_GLOBAL_SavedCF(v) (GLOBAL_SavedCF = (v))
#define GLOBAL_SavedZF (*(IUH *)((IUH)Gdp + 1407))
#define SET_GLOBAL_SavedZF(v) (GLOBAL_SavedZF = (v))
#define GLOBAL_SavedOF (*(IUH *)((IUH)Gdp + 1411))
#define SET_GLOBAL_SavedOF(v) (GLOBAL_SavedOF = (v))
#define GLOBAL_UsedD6 (*(IUH *)((IUH)Gdp + 1415))
#define SET_GLOBAL_UsedD6(v) (GLOBAL_UsedD6 = (v))
#define GLOBAL_buildOp1 (*(IUH *)((IUH)Gdp + 1419))
#define SET_GLOBAL_buildOp1(v) (GLOBAL_buildOp1 = (v))
#define GLOBAL_buildOp2 (*(IUH *)((IUH)Gdp + 1423))
#define SET_GLOBAL_buildOp2(v) (GLOBAL_buildOp2 = (v))
#define GLOBAL_buildOp3 (*(IU32 *)((IUH)Gdp + 1427))
#define SET_GLOBAL_buildOp3(v) (GLOBAL_buildOp3 = (v))
#define GLOBAL_buildOp4 (*(IU32 *)((IUH)Gdp + 1431))
#define SET_GLOBAL_buildOp4(v) (GLOBAL_buildOp4 = (v))
#define GLOBAL_buildOp5 (*(IUH *)((IUH)Gdp + 1435))
#define SET_GLOBAL_buildOp5(v) (GLOBAL_buildOp5 = (v))
#define GLOBAL_buildOp6 (((*(IBOOL *)((IUH)Gdp + 1439)) & 1) != 0)
#define SET_GLOBAL_buildOp6(v) ((*(IBOOL *)((IUH)Gdp + 1439)) = (v) ? 1: 0)
#define GLOBAL_EDL_WORKSPACE_62 (*(IUH *)((IUH)Gdp + 1443))
#define SET_GLOBAL_EDL_WORKSPACE_62(v) (GLOBAL_EDL_WORKSPACE_62 = (v))
#define GLOBAL_EDL_WORKSPACE_63 (*(IUH *)((IUH)Gdp + 1447))
#define SET_GLOBAL_EDL_WORKSPACE_63(v) (GLOBAL_EDL_WORKSPACE_63 = (v))
#define GLOBAL_EDL_WORKSPACE_64 (*(IUH *)((IUH)Gdp + 1451))
#define SET_GLOBAL_EDL_WORKSPACE_64(v) (GLOBAL_EDL_WORKSPACE_64 = (v))
#define GLOBAL_EDL_WORKSPACE_65 (*(IUH *)((IUH)Gdp + 1455))
#define SET_GLOBAL_EDL_WORKSPACE_65(v) (GLOBAL_EDL_WORKSPACE_65 = (v))
#define GLOBAL_EDL_WORKSPACE_66 (*(IUH *)((IUH)Gdp + 1459))
#define SET_GLOBAL_EDL_WORKSPACE_66(v) (GLOBAL_EDL_WORKSPACE_66 = (v))
#define GLOBAL_EDL_WORKSPACE_67 (*(IUH *)((IUH)Gdp + 1463))
#define SET_GLOBAL_EDL_WORKSPACE_67(v) (GLOBAL_EDL_WORKSPACE_67 = (v))
#define GLOBAL_EDL_WORKSPACE_68 (*(IUH *)((IUH)Gdp + 1467))
#define SET_GLOBAL_EDL_WORKSPACE_68(v) (GLOBAL_EDL_WORKSPACE_68 = (v))
#define GLOBAL_EDL_WORKSPACE_69 (*(IUH *)((IUH)Gdp + 1471))
#define SET_GLOBAL_EDL_WORKSPACE_69(v) (GLOBAL_EDL_WORKSPACE_69 = (v))
#define GLOBAL_EDL_WORKSPACE_70 (*(IUH *)((IUH)Gdp + 1475))
#define SET_GLOBAL_EDL_WORKSPACE_70(v) (GLOBAL_EDL_WORKSPACE_70 = (v))
#define GLOBAL_EDL_WORKSPACE_71 (*(IUH *)((IUH)Gdp + 1479))
#define SET_GLOBAL_EDL_WORKSPACE_71(v) (GLOBAL_EDL_WORKSPACE_71 = (v))
#define GLOBAL_EDL_WORKSPACE_72 (*(IUH *)((IUH)Gdp + 1483))
#define SET_GLOBAL_EDL_WORKSPACE_72(v) (GLOBAL_EDL_WORKSPACE_72 = (v))
#define GLOBAL_EDL_WORKSPACE_73 (*(IUH *)((IUH)Gdp + 1487))
#define SET_GLOBAL_EDL_WORKSPACE_73(v) (GLOBAL_EDL_WORKSPACE_73 = (v))
#define GLOBAL_EDL_WORKSPACE_74 (*(IUH *)((IUH)Gdp + 1491))
#define SET_GLOBAL_EDL_WORKSPACE_74(v) (GLOBAL_EDL_WORKSPACE_74 = (v))
#define GLOBAL_EDL_WORKSPACE_75 (*(IUH *)((IUH)Gdp + 1495))
#define SET_GLOBAL_EDL_WORKSPACE_75(v) (GLOBAL_EDL_WORKSPACE_75 = (v))
#define GLOBAL_EDL_WORKSPACE_76 (*(IUH *)((IUH)Gdp + 1499))
#define SET_GLOBAL_EDL_WORKSPACE_76(v) (GLOBAL_EDL_WORKSPACE_76 = (v))
#define GLOBAL_EDL_WORKSPACE_77 (*(IUH *)((IUH)Gdp + 1503))
#define SET_GLOBAL_EDL_WORKSPACE_77(v) (GLOBAL_EDL_WORKSPACE_77 = (v))
#define GLOBAL_EDL_WORKSPACE_78 (*(IUH *)((IUH)Gdp + 1507))
#define SET_GLOBAL_EDL_WORKSPACE_78(v) (GLOBAL_EDL_WORKSPACE_78 = (v))
#define GLOBAL_EDL_WORKSPACE_79 (*(IUH *)((IUH)Gdp + 1511))
#define SET_GLOBAL_EDL_WORKSPACE_79(v) (GLOBAL_EDL_WORKSPACE_79 = (v))
#define GLOBAL_EDL_WORKSPACE_80 (*(IUH *)((IUH)Gdp + 1515))
#define SET_GLOBAL_EDL_WORKSPACE_80(v) (GLOBAL_EDL_WORKSPACE_80 = (v))
#define GLOBAL_EDL_WORKSPACE_81 (*(IUH *)((IUH)Gdp + 1519))
#define SET_GLOBAL_EDL_WORKSPACE_81(v) (GLOBAL_EDL_WORKSPACE_81 = (v))
#define GLOBAL_EDL_WORKSPACE_82 (*(IUH *)((IUH)Gdp + 1523))
#define SET_GLOBAL_EDL_WORKSPACE_82(v) (GLOBAL_EDL_WORKSPACE_82 = (v))
#define GLOBAL_EDL_WORKSPACE_83 (*(IUH *)((IUH)Gdp + 1527))
#define SET_GLOBAL_EDL_WORKSPACE_83(v) (GLOBAL_EDL_WORKSPACE_83 = (v))
#define GLOBAL_EDL_WORKSPACE_84 (*(IUH *)((IUH)Gdp + 1531))
#define SET_GLOBAL_EDL_WORKSPACE_84(v) (GLOBAL_EDL_WORKSPACE_84 = (v))
#define GLOBAL_VGAGlobals (*(struct VGAGLOBALSETTINGS *)((IUH)Gdp + 1535))
#define SET_GLOBAL_VGAGlobals(v) (GLOBAL_VGAGlobals = (v))
#define GLOBAL_VidMarkFuncTable (*(IU32** *)((IUH)Gdp + 1691))
#define SET_GLOBAL_VidMarkFuncTable(v) (GLOBAL_VidMarkFuncTable = (v))
#define GLOBAL_VidReadFuncTable (*(IU32** *)((IUH)Gdp + 1695))
#define SET_GLOBAL_VidReadFuncTable(v) (GLOBAL_VidReadFuncTable = (v))
#define GLOBAL_VidWriteFuncTable (*(IU32** *)((IUH)Gdp + 1699))
#define SET_GLOBAL_VidWriteFuncTable(v) (GLOBAL_VidWriteFuncTable = (v))
#define GLOBAL_EDL_WORKSPACE_85 (*(IUH *)((IUH)Gdp + 1703))
#define SET_GLOBAL_EDL_WORKSPACE_85(v) (GLOBAL_EDL_WORKSPACE_85 = (v))
#define GLOBAL_EDL_WORKSPACE_86 (*(IUH *)((IUH)Gdp + 1707))
#define SET_GLOBAL_EDL_WORKSPACE_86(v) (GLOBAL_EDL_WORKSPACE_86 = (v))
#define GLOBAL_EDL_WORKSPACE_87 (*(IUH *)((IUH)Gdp + 1711))
#define SET_GLOBAL_EDL_WORKSPACE_87(v) (GLOBAL_EDL_WORKSPACE_87 = (v))
#define GLOBAL_EDL_WORKSPACE_88 (*(IUH *)((IUH)Gdp + 1715))
#define SET_GLOBAL_EDL_WORKSPACE_88(v) (GLOBAL_EDL_WORKSPACE_88 = (v))
#define GLOBAL_EDL_WORKSPACE_89 (*(IUH *)((IUH)Gdp + 1719))
#define SET_GLOBAL_EDL_WORKSPACE_89(v) (GLOBAL_EDL_WORKSPACE_89 = (v))
#define GLOBAL_EDL_WORKSPACE_90 (*(IUH *)((IUH)Gdp + 1723))
#define SET_GLOBAL_EDL_WORKSPACE_90(v) (GLOBAL_EDL_WORKSPACE_90 = (v))
#define GLOBAL_ActiveVideoWrites (*(struct EVIDWRITES *)((IUH)Gdp + 1727))
#define SET_GLOBAL_ActiveVideoWrites(v) (GLOBAL_ActiveVideoWrites = (v))
#define GLOBAL_EDL_WORKSPACE_91 (*(IUH *)((IUH)Gdp + 1775))
#define SET_GLOBAL_EDL_WORKSPACE_91(v) (GLOBAL_EDL_WORKSPACE_91 = (v))
#define GLOBAL_EDL_WORKSPACE_92 (*(IUH *)((IUH)Gdp + 1779))
#define SET_GLOBAL_EDL_WORKSPACE_92(v) (GLOBAL_EDL_WORKSPACE_92 = (v))
#define GLOBAL_EDL_WORKSPACE_93 (*(IUH *)((IUH)Gdp + 1783))
#define SET_GLOBAL_EDL_WORKSPACE_93(v) (GLOBAL_EDL_WORKSPACE_93 = (v))
#define GLOBAL_EDL_WORKSPACE_94 (*(IUH *)((IUH)Gdp + 1787))
#define SET_GLOBAL_EDL_WORKSPACE_94(v) (GLOBAL_EDL_WORKSPACE_94 = (v))
#define GLOBAL_ActiveVideoReads (*(struct EVIDREADS *)((IUH)Gdp + 1791))
#define SET_GLOBAL_ActiveVideoReads(v) (GLOBAL_ActiveVideoReads = (v))
#define GLOBAL_EDL_WORKSPACE_95 (*(IUH *)((IUH)Gdp + 1811))
#define SET_GLOBAL_EDL_WORKSPACE_95(v) (GLOBAL_EDL_WORKSPACE_95 = (v))
#define GLOBAL_EDL_WORKSPACE_96 (*(IUH *)((IUH)Gdp + 1815))
#define SET_GLOBAL_EDL_WORKSPACE_96(v) (GLOBAL_EDL_WORKSPACE_96 = (v))
#define GLOBAL_EDL_WORKSPACE_97 (*(IUH *)((IUH)Gdp + 1819))
#define SET_GLOBAL_EDL_WORKSPACE_97(v) (GLOBAL_EDL_WORKSPACE_97 = (v))
#define GLOBAL_ActiveVideoMarks (*(struct EVIDMARKS *)((IUH)Gdp + 1823))
#define SET_GLOBAL_ActiveVideoMarks(v) (GLOBAL_ActiveVideoMarks = (v))
#define GLOBAL_MaxIntelPageNumber (*(IU32 *)((IUH)Gdp + 1839))
#define SET_GLOBAL_MaxIntelPageNumber(v) (GLOBAL_MaxIntelPageNumber = (v))
#define GLOBAL_EmptyIntelPageNumber (*(IU32 *)((IUH)Gdp + 1843))
#define SET_GLOBAL_EmptyIntelPageNumber(v) (GLOBAL_EmptyIntelPageNumber = (v))
#define GLOBAL_PageDirectoryPtr (*(IU32* *)((IUH)Gdp + 1847))
#define SET_GLOBAL_PageDirectoryPtr(v) (GLOBAL_PageDirectoryPtr = (v))
#define GLOBAL_DebuggerPFLA (*(IU32 *)((IUH)Gdp + 1851))
#define SET_GLOBAL_DebuggerPFLA(v) (GLOBAL_DebuggerPFLA = (v))
#define GLOBAL_DebuggerFaultAction (*(IUH *)((IUH)Gdp + 1855))
#define SET_GLOBAL_DebuggerFaultAction(v) (GLOBAL_DebuggerFaultAction = (v))
#define GLOBAL_InsideDebugger (*(ISH *)((IUH)Gdp + 1859))
#define SET_GLOBAL_InsideDebugger(v) (GLOBAL_InsideDebugger = (v))
#define GLOBAL_EDL_WORKSPACE_98 (*(IUH *)((IUH)Gdp + 1863))
#define SET_GLOBAL_EDL_WORKSPACE_98(v) (GLOBAL_EDL_WORKSPACE_98 = (v))
#define GLOBAL_EDL_WORKSPACE_99 (*(IUH *)((IUH)Gdp + 1867))
#define SET_GLOBAL_EDL_WORKSPACE_99(v) (GLOBAL_EDL_WORKSPACE_99 = (v))
#define GLOBAL_EDL_WORKSPACE_100 (*(IUH *)((IUH)Gdp + 1871))
#define SET_GLOBAL_EDL_WORKSPACE_100(v) (GLOBAL_EDL_WORKSPACE_100 = (v))
#define GLOBAL_EDL_WORKSPACE_101 (*(IUH *)((IUH)Gdp + 1875))
#define SET_GLOBAL_EDL_WORKSPACE_101(v) (GLOBAL_EDL_WORKSPACE_101 = (v))
#define GLOBAL_EDL_WORKSPACE_102 (*(IUH *)((IUH)Gdp + 1879))
#define SET_GLOBAL_EDL_WORKSPACE_102(v) (GLOBAL_EDL_WORKSPACE_102 = (v))
#define GLOBAL_EDL_WORKSPACE_103 (*(IUH *)((IUH)Gdp + 1883))
#define SET_GLOBAL_EDL_WORKSPACE_103(v) (GLOBAL_EDL_WORKSPACE_103 = (v))
#define GLOBAL_EDL_WORKSPACE_104 (*(IUH *)((IUH)Gdp + 1887))
#define SET_GLOBAL_EDL_WORKSPACE_104(v) (GLOBAL_EDL_WORKSPACE_104 = (v))
#define GLOBAL_EDL_WORKSPACE_105 (*(IUH *)((IUH)Gdp + 1891))
#define SET_GLOBAL_EDL_WORKSPACE_105(v) (GLOBAL_EDL_WORKSPACE_105 = (v))
#define GLOBAL_EDL_WORKSPACE_106 (*(IUH *)((IUH)Gdp + 1895))
#define SET_GLOBAL_EDL_WORKSPACE_106(v) (GLOBAL_EDL_WORKSPACE_106 = (v))
#define GLOBAL_EDL_WORKSPACE_107 (*(IUH *)((IUH)Gdp + 1899))
#define SET_GLOBAL_EDL_WORKSPACE_107(v) (GLOBAL_EDL_WORKSPACE_107 = (v))
#define GLOBAL_EDL_WORKSPACE_108 (*(IUH *)((IUH)Gdp + 1903))
#define SET_GLOBAL_EDL_WORKSPACE_108(v) (GLOBAL_EDL_WORKSPACE_108 = (v))
#define GLOBAL_EDL_WORKSPACE_109 (*(IUH *)((IUH)Gdp + 1907))
#define SET_GLOBAL_EDL_WORKSPACE_109(v) (GLOBAL_EDL_WORKSPACE_109 = (v))
#define GLOBAL_EDL_WORKSPACE_110 (*(IUH *)((IUH)Gdp + 1911))
#define SET_GLOBAL_EDL_WORKSPACE_110(v) (GLOBAL_EDL_WORKSPACE_110 = (v))
#define GLOBAL_EDL_WORKSPACE_111 (*(IUH *)((IUH)Gdp + 1915))
#define SET_GLOBAL_EDL_WORKSPACE_111(v) (GLOBAL_EDL_WORKSPACE_111 = (v))
#define GLOBAL_VirtualisationBIOSOffsets (*(struct VirtualisationBIOSOffsetsREC *)((IUH)Gdp + 1919))
#define SET_GLOBAL_VirtualisationBIOSOffsets(v) (GLOBAL_VirtualisationBIOSOffsets = (v))
#define GLOBAL_DoingIoVirtTest (*(IUH *)((IUH)Gdp + 1967))
#define SET_GLOBAL_DoingIoVirtTest(v) (GLOBAL_DoingIoVirtTest = (v))
#define GLOBAL_IoVirtTestFailed (*(IUH *)((IUH)Gdp + 1971))
#define SET_GLOBAL_IoVirtTestFailed(v) (GLOBAL_IoVirtTestFailed = (v))
#define GLOBAL_NextHostCodeAddress (*(IU32* *)((IUH)Gdp + 1975))
#define SET_GLOBAL_NextHostCodeAddress(v) (GLOBAL_NextHostCodeAddress = (v))
#define GLOBAL_NextPhysicalPage (*(IUH *)((IUH)Gdp + 1979))
#define SET_GLOBAL_NextPhysicalPage(v) (GLOBAL_NextPhysicalPage = (v))
#define GLOBAL_TranslationHashTable (*(IU16* *)((IUH)Gdp + 1983))
#define SET_GLOBAL_TranslationHashTable(v) (GLOBAL_TranslationHashTable = (v))
#define GLOBAL_SasMemoryType (*(IU8* *)((IUH)Gdp + 1987))
#define SET_GLOBAL_SasMemoryType(v) (GLOBAL_SasMemoryType = (v))
#define GLOBAL_PhysicalPageRecords (*(struct PhysicalPageREC* *)((IUH)Gdp + 1991))
#define SET_GLOBAL_PhysicalPageRecords(v) (GLOBAL_PhysicalPageRecords = (v))
#define GLOBAL_PhysicalPageMemory (*(IU8** *)((IUH)Gdp + 1995))
#define SET_GLOBAL_PhysicalPageMemory(v) (GLOBAL_PhysicalPageMemory = (v))
#define GLOBAL_TwentyBitWrapStatus (((*(IBOOL *)((IUH)Gdp + 1999)) & 1) != 0)
#define SET_GLOBAL_TwentyBitWrapStatus(v) ((*(IBOOL *)((IUH)Gdp + 1999)) = (v) ? 1: 0)
#define GLOBAL_MultipleRecompilationCount (*(IUH *)((IUH)Gdp + 2003))
#define SET_GLOBAL_MultipleRecompilationCount(v) (GLOBAL_MultipleRecompilationCount = (v))
#define GLOBAL_MaxMultipleRecompilation (*(IUH *)((IUH)Gdp + 2007))
#define SET_GLOBAL_MaxMultipleRecompilation(v) (GLOBAL_MaxMultipleRecompilation = (v))
#define GLOBAL_HideCompiledFragment (((*(IBOOL *)((IUH)Gdp + 2011)) & 1) != 0)
#define SET_GLOBAL_HideCompiledFragment(v) ((*(IBOOL *)((IUH)Gdp + 2011)) = (v) ? 1: 0)
#define GLOBAL_RestartAfterCodeOverwrite (((*(IBOOL *)((IUH)Gdp + 2015)) & 1) != 0)
#define SET_GLOBAL_RestartAfterCodeOverwrite(v) ((*(IBOOL *)((IUH)Gdp + 2015)) = (v) ? 1: 0)
#define GLOBAL_DoingCompilation (((*(IBOOL *)((IUH)Gdp + 2019)) & 1) != 0)
#define SET_GLOBAL_DoingCompilation(v) ((*(IBOOL *)((IUH)Gdp + 2019)) = (v) ? 1: 0)
#define GLOBAL_SanityCheckStructures (((*(IBOOL *)((IUH)Gdp + 2023)) & 1) != 0)
#define SET_GLOBAL_SanityCheckStructures(v) ((*(IBOOL *)((IUH)Gdp + 2023)) = (v) ? 1: 0)
#define GLOBAL_BufferSelfOverwritten (((*(IBOOL *)((IUH)Gdp + 2027)) & 1) != 0)
#define SET_GLOBAL_BufferSelfOverwritten(v) ((*(IBOOL *)((IUH)Gdp + 2027)) = (v) ? 1: 0)
#define GLOBAL_RecentCodeOverwriteHashTable (*(IU8** *)((IUH)Gdp + 2031))
#define SET_GLOBAL_RecentCodeOverwriteHashTable(v) (GLOBAL_RecentCodeOverwriteHashTable = (v))
#define GLOBAL_DelayedGldtUnprotections (*(IU16 *)((IUH)Gdp + 2035))
#define SET_GLOBAL_DelayedGldtUnprotections(v) (GLOBAL_DelayedGldtUnprotections = (v))
#define GLOBAL_DelayedIdtUnprotections (*(IU16 *)((IUH)Gdp + 2039))
#define SET_GLOBAL_DelayedIdtUnprotections(v) (GLOBAL_DelayedIdtUnprotections = (v))
#define GLOBAL_DelayedIdtList (*(IU16* *)((IUH)Gdp + 2043))
#define SET_GLOBAL_DelayedIdtList(v) (GLOBAL_DelayedIdtList = (v))
#define GLOBAL_CoarseRecords (*(struct CoarseProtREC* *)((IUH)Gdp + 2047))
#define SET_GLOBAL_CoarseRecords(v) (GLOBAL_CoarseRecords = (v))
#define GLOBAL_FineRecords (*(struct FineProtREC* *)((IUH)Gdp + 2051))
#define SET_GLOBAL_FineRecords(v) (GLOBAL_FineRecords = (v))
#define GLOBAL_SlotRecords (*(struct SlotProtREC* *)((IUH)Gdp + 2055))
#define SET_GLOBAL_SlotRecords(v) (GLOBAL_SlotRecords = (v))
#define GLOBAL_DescriptorRecords (*(struct GLDC_REC* *)((IUH)Gdp + 2059))
#define SET_GLOBAL_DescriptorRecords(v) (GLOBAL_DescriptorRecords = (v))
#define GLOBAL_MapRecords (*(struct TranslationMapREC* *)((IUH)Gdp + 2063))
#define SET_GLOBAL_MapRecords(v) (GLOBAL_MapRecords = (v))
#define GLOBAL_DependencyRecords (*(struct DependencyREC* *)((IUH)Gdp + 2067))
#define SET_GLOBAL_DependencyRecords(v) (GLOBAL_DependencyRecords = (v))
#define GLOBAL_DeletionRecords (*(struct DeletionREC* *)((IUH)Gdp + 2071))
#define SET_GLOBAL_DeletionRecords(v) (GLOBAL_DeletionRecords = (v))
#define GLOBAL_NextPossSacrificeBuffNr (*(IUH *)((IUH)Gdp + 2075))
#define SET_GLOBAL_NextPossSacrificeBuffNr(v) (GLOBAL_NextPossSacrificeBuffNr = (v))
#define GLOBAL_BaseDescriptorBuffNr (*(IUH *)((IUH)Gdp + 2079))
#define SET_GLOBAL_BaseDescriptorBuffNr(v) (GLOBAL_BaseDescriptorBuffNr = (v))
#define GLOBAL_MaxDescriptorBuffNr (*(IUH *)((IUH)Gdp + 2083))
#define SET_GLOBAL_MaxDescriptorBuffNr(v) (GLOBAL_MaxDescriptorBuffNr = (v))
#define GLOBAL_FreeDataBuffers (*(struct BufferIndexREC* *)((IUH)Gdp + 2087))
#define SET_GLOBAL_FreeDataBuffers(v) (GLOBAL_FreeDataBuffers = (v))
#define GLOBAL_FreeCodeBuffers (*(struct BufferIndexREC* *)((IUH)Gdp + 2091))
#define SET_GLOBAL_FreeCodeBuffers(v) (GLOBAL_FreeCodeBuffers = (v))
#define GLOBAL_EntryPointHashTable (*(IU16* *)((IUH)Gdp + 2095))
#define SET_GLOBAL_EntryPointHashTable(v) (GLOBAL_EntryPointHashTable = (v))
#define GLOBAL_FragCounts (*(IU8* *)((IUH)Gdp + 2099))
#define SET_GLOBAL_FragCounts(v) (GLOBAL_FragCounts = (v))
#define GLOBAL_EDL_WORKSPACE_112 (*(IUH *)((IUH)Gdp + 2103))
#define SET_GLOBAL_EDL_WORKSPACE_112(v) (GLOBAL_EDL_WORKSPACE_112 = (v))
#define GLOBAL_EDL_WORKSPACE_113 (*(IUH *)((IUH)Gdp + 2107))
#define SET_GLOBAL_EDL_WORKSPACE_113(v) (GLOBAL_EDL_WORKSPACE_113 = (v))
#define GLOBAL_ControlBlock (*(struct CompilationControlREC *)((IUH)Gdp + 2111))
#define SET_GLOBAL_ControlBlock(v) (GLOBAL_ControlBlock = (v))
#define GLOBAL_EDL_WORKSPACE_114 (*(IUH *)((IUH)Gdp + 2127))
#define SET_GLOBAL_EDL_WORKSPACE_114(v) (GLOBAL_EDL_WORKSPACE_114 = (v))
#define GLOBAL_EDL_WORKSPACE_115 (*(IUH *)((IUH)Gdp + 2131))
#define SET_GLOBAL_EDL_WORKSPACE_115(v) (GLOBAL_EDL_WORKSPACE_115 = (v))
#define GLOBAL_EDL_WORKSPACE_116 (*(IUH *)((IUH)Gdp + 2135))
#define SET_GLOBAL_EDL_WORKSPACE_116(v) (GLOBAL_EDL_WORKSPACE_116 = (v))
#define GLOBAL_EDL_WORKSPACE_117 (*(IUH *)((IUH)Gdp + 2139))
#define SET_GLOBAL_EDL_WORKSPACE_117(v) (GLOBAL_EDL_WORKSPACE_117 = (v))
#define GLOBAL_EDL_WORKSPACE_118 (*(IUH *)((IUH)Gdp + 2143))
#define SET_GLOBAL_EDL_WORKSPACE_118(v) (GLOBAL_EDL_WORKSPACE_118 = (v))
#define GLOBAL_EDL_WORKSPACE_119 (*(IUH *)((IUH)Gdp + 2147))
#define SET_GLOBAL_EDL_WORKSPACE_119(v) (GLOBAL_EDL_WORKSPACE_119 = (v))
#define GLOBAL_EDL_WORKSPACE_120 (*(IUH *)((IUH)Gdp + 2151))
#define SET_GLOBAL_EDL_WORKSPACE_120(v) (GLOBAL_EDL_WORKSPACE_120 = (v))
#define GLOBAL_EDL_WORKSPACE_121 (*(IUH *)((IUH)Gdp + 2155))
#define SET_GLOBAL_EDL_WORKSPACE_121(v) (GLOBAL_EDL_WORKSPACE_121 = (v))
#define GLOBAL_EDL_WORKSPACE_122 (*(IUH *)((IUH)Gdp + 2159))
#define SET_GLOBAL_EDL_WORKSPACE_122(v) (GLOBAL_EDL_WORKSPACE_122 = (v))
#define GLOBAL_EDL_WORKSPACE_123 (*(IUH *)((IUH)Gdp + 2163))
#define SET_GLOBAL_EDL_WORKSPACE_123(v) (GLOBAL_EDL_WORKSPACE_123 = (v))
#define GLOBAL_EDL_WORKSPACE_124 (*(IUH *)((IUH)Gdp + 2167))
#define SET_GLOBAL_EDL_WORKSPACE_124(v) (GLOBAL_EDL_WORKSPACE_124 = (v))
#define GLOBAL_EDL_WORKSPACE_125 (*(IUH *)((IUH)Gdp + 2171))
#define SET_GLOBAL_EDL_WORKSPACE_125(v) (GLOBAL_EDL_WORKSPACE_125 = (v))
#define GLOBAL_CompilationBlock (*(struct BLOCK_TO_COMPILE *)((IUH)Gdp + 2175))
#define SET_GLOBAL_CompilationBlock(v) (GLOBAL_CompilationBlock = (v))
#define GLOBAL_EDL_WORKSPACE_126 (*(IUH *)((IUH)Gdp + 2211))
#define SET_GLOBAL_EDL_WORKSPACE_126(v) (GLOBAL_EDL_WORKSPACE_126 = (v))
#define GLOBAL_EDL_WORKSPACE_127 (*(IUH *)((IUH)Gdp + 2215))
#define SET_GLOBAL_EDL_WORKSPACE_127(v) (GLOBAL_EDL_WORKSPACE_127 = (v))
#define GLOBAL_EDL_WORKSPACE_128 (*(IUH *)((IUH)Gdp + 2219))
#define SET_GLOBAL_EDL_WORKSPACE_128(v) (GLOBAL_EDL_WORKSPACE_128 = (v))
#define GLOBAL_EDL_WORKSPACE_129 (*(IUH *)((IUH)Gdp + 2223))
#define SET_GLOBAL_EDL_WORKSPACE_129(v) (GLOBAL_EDL_WORKSPACE_129 = (v))
#define GLOBAL_EDL_WORKSPACE_130 (*(IUH *)((IUH)Gdp + 2227))
#define SET_GLOBAL_EDL_WORKSPACE_130(v) (GLOBAL_EDL_WORKSPACE_130 = (v))
#define GLOBAL_EDL_WORKSPACE_131 (*(IUH *)((IUH)Gdp + 2231))
#define SET_GLOBAL_EDL_WORKSPACE_131(v) (GLOBAL_EDL_WORKSPACE_131 = (v))
#define GLOBAL_EDL_WORKSPACE_132 (*(IUH *)((IUH)Gdp + 2235))
#define SET_GLOBAL_EDL_WORKSPACE_132(v) (GLOBAL_EDL_WORKSPACE_132 = (v))
#define GLOBAL_EDL_WORKSPACE_133 (*(IUH *)((IUH)Gdp + 2239))
#define SET_GLOBAL_EDL_WORKSPACE_133(v) (GLOBAL_EDL_WORKSPACE_133 = (v))
#define GLOBAL_EDL_WORKSPACE_134 (*(IUH *)((IUH)Gdp + 2243))
#define SET_GLOBAL_EDL_WORKSPACE_134(v) (GLOBAL_EDL_WORKSPACE_134 = (v))
#define GLOBAL_EDL_WORKSPACE_135 (*(IUH *)((IUH)Gdp + 2247))
#define SET_GLOBAL_EDL_WORKSPACE_135(v) (GLOBAL_EDL_WORKSPACE_135 = (v))
#define GLOBAL_EDL_WORKSPACE_136 (*(IUH *)((IUH)Gdp + 2251))
#define SET_GLOBAL_EDL_WORKSPACE_136(v) (GLOBAL_EDL_WORKSPACE_136 = (v))
#define GLOBAL_EDL_WORKSPACE_137 (*(IUH *)((IUH)Gdp + 2255))
#define SET_GLOBAL_EDL_WORKSPACE_137(v) (GLOBAL_EDL_WORKSPACE_137 = (v))
#define GLOBAL_EDL_WORKSPACE_138 (*(IUH *)((IUH)Gdp + 2259))
#define SET_GLOBAL_EDL_WORKSPACE_138(v) (GLOBAL_EDL_WORKSPACE_138 = (v))
#define GLOBAL_EDL_WORKSPACE_139 (*(IUH *)((IUH)Gdp + 2263))
#define SET_GLOBAL_EDL_WORKSPACE_139(v) (GLOBAL_EDL_WORKSPACE_139 = (v))
#define GLOBAL_EDL_WORKSPACE_140 (*(IUH *)((IUH)Gdp + 2267))
#define SET_GLOBAL_EDL_WORKSPACE_140(v) (GLOBAL_EDL_WORKSPACE_140 = (v))
#define GLOBAL_EDL_WORKSPACE_141 (*(IUH *)((IUH)Gdp + 2271))
#define SET_GLOBAL_EDL_WORKSPACE_141(v) (GLOBAL_EDL_WORKSPACE_141 = (v))
#define GLOBAL_EDL_WORKSPACE_142 (*(IUH *)((IUH)Gdp + 2275))
#define SET_GLOBAL_EDL_WORKSPACE_142(v) (GLOBAL_EDL_WORKSPACE_142 = (v))
#define GLOBAL_EDL_WORKSPACE_143 (*(IUH *)((IUH)Gdp + 2279))
#define SET_GLOBAL_EDL_WORKSPACE_143(v) (GLOBAL_EDL_WORKSPACE_143 = (v))
#define GLOBAL_EDL_WORKSPACE_144 (*(IUH *)((IUH)Gdp + 2283))
#define SET_GLOBAL_EDL_WORKSPACE_144(v) (GLOBAL_EDL_WORKSPACE_144 = (v))
#define GLOBAL_EDL_WORKSPACE_145 (*(IUH *)((IUH)Gdp + 2287))
#define SET_GLOBAL_EDL_WORKSPACE_145(v) (GLOBAL_EDL_WORKSPACE_145 = (v))
#define GLOBAL_EDL_WORKSPACE_146 (*(IUH *)((IUH)Gdp + 2291))
#define SET_GLOBAL_EDL_WORKSPACE_146(v) (GLOBAL_EDL_WORKSPACE_146 = (v))
#define GLOBAL_EDL_WORKSPACE_147 (*(IUH *)((IUH)Gdp + 2295))
#define SET_GLOBAL_EDL_WORKSPACE_147(v) (GLOBAL_EDL_WORKSPACE_147 = (v))
#define GLOBAL_EDL_WORKSPACE_148 (*(IUH *)((IUH)Gdp + 2299))
#define SET_GLOBAL_EDL_WORKSPACE_148(v) (GLOBAL_EDL_WORKSPACE_148 = (v))
#define GLOBAL_EDL_WORKSPACE_149 (*(IUH *)((IUH)Gdp + 2303))
#define SET_GLOBAL_EDL_WORKSPACE_149(v) (GLOBAL_EDL_WORKSPACE_149 = (v))
#define GLOBAL_EDL_WORKSPACE_150 (*(IUH *)((IUH)Gdp + 2307))
#define SET_GLOBAL_EDL_WORKSPACE_150(v) (GLOBAL_EDL_WORKSPACE_150 = (v))
#define GLOBAL_EDL_WORKSPACE_151 (*(IUH *)((IUH)Gdp + 2311))
#define SET_GLOBAL_EDL_WORKSPACE_151(v) (GLOBAL_EDL_WORKSPACE_151 = (v))
#define GLOBAL_EDL_WORKSPACE_152 (*(IUH *)((IUH)Gdp + 2315))
#define SET_GLOBAL_EDL_WORKSPACE_152(v) (GLOBAL_EDL_WORKSPACE_152 = (v))
#define GLOBAL_EDL_WORKSPACE_153 (*(IUH *)((IUH)Gdp + 2319))
#define SET_GLOBAL_EDL_WORKSPACE_153(v) (GLOBAL_EDL_WORKSPACE_153 = (v))
#define GLOBAL_EDL_WORKSPACE_154 (*(IUH *)((IUH)Gdp + 2323))
#define SET_GLOBAL_EDL_WORKSPACE_154(v) (GLOBAL_EDL_WORKSPACE_154 = (v))
#define GLOBAL_EDL_WORKSPACE_155 (*(IUH *)((IUH)Gdp + 2327))
#define SET_GLOBAL_EDL_WORKSPACE_155(v) (GLOBAL_EDL_WORKSPACE_155 = (v))
#define GLOBAL_EDL_WORKSPACE_156 (*(IUH *)((IUH)Gdp + 2331))
#define SET_GLOBAL_EDL_WORKSPACE_156(v) (GLOBAL_EDL_WORKSPACE_156 = (v))
#define GLOBAL_EDL_WORKSPACE_157 (*(IUH *)((IUH)Gdp + 2335))
#define SET_GLOBAL_EDL_WORKSPACE_157(v) (GLOBAL_EDL_WORKSPACE_157 = (v))
#define GLOBAL_EDL_WORKSPACE_158 (*(IUH *)((IUH)Gdp + 2339))
#define SET_GLOBAL_EDL_WORKSPACE_158(v) (GLOBAL_EDL_WORKSPACE_158 = (v))
#define GLOBAL_EDL_WORKSPACE_159 (*(IUH *)((IUH)Gdp + 2343))
#define SET_GLOBAL_EDL_WORKSPACE_159(v) (GLOBAL_EDL_WORKSPACE_159 = (v))
#define GLOBAL_EDL_WORKSPACE_160 (*(IUH *)((IUH)Gdp + 2347))
#define SET_GLOBAL_EDL_WORKSPACE_160(v) (GLOBAL_EDL_WORKSPACE_160 = (v))
#define GLOBAL_EDL_WORKSPACE_161 (*(IUH *)((IUH)Gdp + 2351))
#define SET_GLOBAL_EDL_WORKSPACE_161(v) (GLOBAL_EDL_WORKSPACE_161 = (v))
#define GLOBAL_EDL_WORKSPACE_162 (*(IUH *)((IUH)Gdp + 2355))
#define SET_GLOBAL_EDL_WORKSPACE_162(v) (GLOBAL_EDL_WORKSPACE_162 = (v))
#define GLOBAL_EDL_WORKSPACE_163 (*(IUH *)((IUH)Gdp + 2359))
#define SET_GLOBAL_EDL_WORKSPACE_163(v) (GLOBAL_EDL_WORKSPACE_163 = (v))
#define GLOBAL_EDL_WORKSPACE_164 (*(IUH *)((IUH)Gdp + 2363))
#define SET_GLOBAL_EDL_WORKSPACE_164(v) (GLOBAL_EDL_WORKSPACE_164 = (v))
#define GLOBAL_EDL_WORKSPACE_165 (*(IUH *)((IUH)Gdp + 2367))
#define SET_GLOBAL_EDL_WORKSPACE_165(v) (GLOBAL_EDL_WORKSPACE_165 = (v))
#define GLOBAL_EDL_WORKSPACE_166 (*(IUH *)((IUH)Gdp + 2371))
#define SET_GLOBAL_EDL_WORKSPACE_166(v) (GLOBAL_EDL_WORKSPACE_166 = (v))
#define GLOBAL_EDL_WORKSPACE_167 (*(IUH *)((IUH)Gdp + 2375))
#define SET_GLOBAL_EDL_WORKSPACE_167(v) (GLOBAL_EDL_WORKSPACE_167 = (v))
#define GLOBAL_EDL_WORKSPACE_168 (*(IUH *)((IUH)Gdp + 2379))
#define SET_GLOBAL_EDL_WORKSPACE_168(v) (GLOBAL_EDL_WORKSPACE_168 = (v))
#define GLOBAL_EDL_WORKSPACE_169 (*(IUH *)((IUH)Gdp + 2383))
#define SET_GLOBAL_EDL_WORKSPACE_169(v) (GLOBAL_EDL_WORKSPACE_169 = (v))
#define GLOBAL_EDL_WORKSPACE_170 (*(IUH *)((IUH)Gdp + 2387))
#define SET_GLOBAL_EDL_WORKSPACE_170(v) (GLOBAL_EDL_WORKSPACE_170 = (v))
#define GLOBAL_EDL_WORKSPACE_171 (*(IUH *)((IUH)Gdp + 2391))
#define SET_GLOBAL_EDL_WORKSPACE_171(v) (GLOBAL_EDL_WORKSPACE_171 = (v))
#define GLOBAL_EDL_WORKSPACE_172 (*(IUH *)((IUH)Gdp + 2395))
#define SET_GLOBAL_EDL_WORKSPACE_172(v) (GLOBAL_EDL_WORKSPACE_172 = (v))
#define GLOBAL_EDL_WORKSPACE_173 (*(IUH *)((IUH)Gdp + 2399))
#define SET_GLOBAL_EDL_WORKSPACE_173(v) (GLOBAL_EDL_WORKSPACE_173 = (v))
#define GLOBAL_EDL_WORKSPACE_174 (*(IUH *)((IUH)Gdp + 2403))
#define SET_GLOBAL_EDL_WORKSPACE_174(v) (GLOBAL_EDL_WORKSPACE_174 = (v))
#define GLOBAL_EDL_WORKSPACE_175 (*(IUH *)((IUH)Gdp + 2407))
#define SET_GLOBAL_EDL_WORKSPACE_175(v) (GLOBAL_EDL_WORKSPACE_175 = (v))
#define GLOBAL_EDL_WORKSPACE_176 (*(IUH *)((IUH)Gdp + 2411))
#define SET_GLOBAL_EDL_WORKSPACE_176(v) (GLOBAL_EDL_WORKSPACE_176 = (v))
#define GLOBAL_EDL_WORKSPACE_177 (*(IUH *)((IUH)Gdp + 2415))
#define SET_GLOBAL_EDL_WORKSPACE_177(v) (GLOBAL_EDL_WORKSPACE_177 = (v))
#define GLOBAL_EDL_WORKSPACE_178 (*(IUH *)((IUH)Gdp + 2419))
#define SET_GLOBAL_EDL_WORKSPACE_178(v) (GLOBAL_EDL_WORKSPACE_178 = (v))
#define GLOBAL_EDL_WORKSPACE_179 (*(IUH *)((IUH)Gdp + 2423))
#define SET_GLOBAL_EDL_WORKSPACE_179(v) (GLOBAL_EDL_WORKSPACE_179 = (v))
#define GLOBAL_EDL_WORKSPACE_180 (*(IUH *)((IUH)Gdp + 2427))
#define SET_GLOBAL_EDL_WORKSPACE_180(v) (GLOBAL_EDL_WORKSPACE_180 = (v))
#define GLOBAL_EDL_WORKSPACE_181 (*(IUH *)((IUH)Gdp + 2431))
#define SET_GLOBAL_EDL_WORKSPACE_181(v) (GLOBAL_EDL_WORKSPACE_181 = (v))
#define GLOBAL_EDL_WORKSPACE_182 (*(IUH *)((IUH)Gdp + 2435))
#define SET_GLOBAL_EDL_WORKSPACE_182(v) (GLOBAL_EDL_WORKSPACE_182 = (v))
#define GLOBAL_EDL_WORKSPACE_183 (*(IUH *)((IUH)Gdp + 2439))
#define SET_GLOBAL_EDL_WORKSPACE_183(v) (GLOBAL_EDL_WORKSPACE_183 = (v))
#define GLOBAL_EDL_WORKSPACE_184 (*(IUH *)((IUH)Gdp + 2443))
#define SET_GLOBAL_EDL_WORKSPACE_184(v) (GLOBAL_EDL_WORKSPACE_184 = (v))
#define GLOBAL_EDL_WORKSPACE_185 (*(IUH *)((IUH)Gdp + 2447))
#define SET_GLOBAL_EDL_WORKSPACE_185(v) (GLOBAL_EDL_WORKSPACE_185 = (v))
#define GLOBAL_EDL_WORKSPACE_186 (*(IUH *)((IUH)Gdp + 2451))
#define SET_GLOBAL_EDL_WORKSPACE_186(v) (GLOBAL_EDL_WORKSPACE_186 = (v))
#define GLOBAL_EDL_WORKSPACE_187 (*(IUH *)((IUH)Gdp + 2455))
#define SET_GLOBAL_EDL_WORKSPACE_187(v) (GLOBAL_EDL_WORKSPACE_187 = (v))
#define GLOBAL_EDL_WORKSPACE_188 (*(IUH *)((IUH)Gdp + 2459))
#define SET_GLOBAL_EDL_WORKSPACE_188(v) (GLOBAL_EDL_WORKSPACE_188 = (v))
#define GLOBAL_EDL_WORKSPACE_189 (*(IUH *)((IUH)Gdp + 2463))
#define SET_GLOBAL_EDL_WORKSPACE_189(v) (GLOBAL_EDL_WORKSPACE_189 = (v))
#define GLOBAL_EDL_WORKSPACE_190 (*(IUH *)((IUH)Gdp + 2467))
#define SET_GLOBAL_EDL_WORKSPACE_190(v) (GLOBAL_EDL_WORKSPACE_190 = (v))
#define GLOBAL_EDL_WORKSPACE_191 (*(IUH *)((IUH)Gdp + 2471))
#define SET_GLOBAL_EDL_WORKSPACE_191(v) (GLOBAL_EDL_WORKSPACE_191 = (v))
#define GLOBAL_EDL_WORKSPACE_192 (*(IUH *)((IUH)Gdp + 2475))
#define SET_GLOBAL_EDL_WORKSPACE_192(v) (GLOBAL_EDL_WORKSPACE_192 = (v))
#define GLOBAL_EDL_WORKSPACE_193 (*(IUH *)((IUH)Gdp + 2479))
#define SET_GLOBAL_EDL_WORKSPACE_193(v) (GLOBAL_EDL_WORKSPACE_193 = (v))
#define GLOBAL_EDL_WORKSPACE_194 (*(IUH *)((IUH)Gdp + 2483))
#define SET_GLOBAL_EDL_WORKSPACE_194(v) (GLOBAL_EDL_WORKSPACE_194 = (v))
#define GLOBAL_EDL_WORKSPACE_195 (*(IUH *)((IUH)Gdp + 2487))
#define SET_GLOBAL_EDL_WORKSPACE_195(v) (GLOBAL_EDL_WORKSPACE_195 = (v))
#define GLOBAL_EDL_WORKSPACE_196 (*(IUH *)((IUH)Gdp + 2491))
#define SET_GLOBAL_EDL_WORKSPACE_196(v) (GLOBAL_EDL_WORKSPACE_196 = (v))
#define GLOBAL_EDL_WORKSPACE_197 (*(IUH *)((IUH)Gdp + 2495))
#define SET_GLOBAL_EDL_WORKSPACE_197(v) (GLOBAL_EDL_WORKSPACE_197 = (v))
#define GLOBAL_EDL_WORKSPACE_198 (*(IUH *)((IUH)Gdp + 2499))
#define SET_GLOBAL_EDL_WORKSPACE_198(v) (GLOBAL_EDL_WORKSPACE_198 = (v))
#define GLOBAL_EDL_WORKSPACE_199 (*(IUH *)((IUH)Gdp + 2503))
#define SET_GLOBAL_EDL_WORKSPACE_199(v) (GLOBAL_EDL_WORKSPACE_199 = (v))
#define GLOBAL_EDL_WORKSPACE_200 (*(IUH *)((IUH)Gdp + 2507))
#define SET_GLOBAL_EDL_WORKSPACE_200(v) (GLOBAL_EDL_WORKSPACE_200 = (v))
#define GLOBAL_EDL_WORKSPACE_201 (*(IUH *)((IUH)Gdp + 2511))
#define SET_GLOBAL_EDL_WORKSPACE_201(v) (GLOBAL_EDL_WORKSPACE_201 = (v))
#define GLOBAL_EDL_WORKSPACE_202 (*(IUH *)((IUH)Gdp + 2515))
#define SET_GLOBAL_EDL_WORKSPACE_202(v) (GLOBAL_EDL_WORKSPACE_202 = (v))
#define GLOBAL_EDL_WORKSPACE_203 (*(IUH *)((IUH)Gdp + 2519))
#define SET_GLOBAL_EDL_WORKSPACE_203(v) (GLOBAL_EDL_WORKSPACE_203 = (v))
#define GLOBAL_EDL_WORKSPACE_204 (*(IUH *)((IUH)Gdp + 2523))
#define SET_GLOBAL_EDL_WORKSPACE_204(v) (GLOBAL_EDL_WORKSPACE_204 = (v))
#define GLOBAL_EDL_WORKSPACE_205 (*(IUH *)((IUH)Gdp + 2527))
#define SET_GLOBAL_EDL_WORKSPACE_205(v) (GLOBAL_EDL_WORKSPACE_205 = (v))
#define GLOBAL_EDL_WORKSPACE_206 (*(IUH *)((IUH)Gdp + 2531))
#define SET_GLOBAL_EDL_WORKSPACE_206(v) (GLOBAL_EDL_WORKSPACE_206 = (v))
#define GLOBAL_EDL_WORKSPACE_207 (*(IUH *)((IUH)Gdp + 2535))
#define SET_GLOBAL_EDL_WORKSPACE_207(v) (GLOBAL_EDL_WORKSPACE_207 = (v))
#define GLOBAL_EDL_WORKSPACE_208 (*(IUH *)((IUH)Gdp + 2539))
#define SET_GLOBAL_EDL_WORKSPACE_208(v) (GLOBAL_EDL_WORKSPACE_208 = (v))
#define GLOBAL_EDL_WORKSPACE_209 (*(IUH *)((IUH)Gdp + 2543))
#define SET_GLOBAL_EDL_WORKSPACE_209(v) (GLOBAL_EDL_WORKSPACE_209 = (v))
#define GLOBAL_EDL_WORKSPACE_210 (*(IUH *)((IUH)Gdp + 2547))
#define SET_GLOBAL_EDL_WORKSPACE_210(v) (GLOBAL_EDL_WORKSPACE_210 = (v))
#define GLOBAL_EDL_WORKSPACE_211 (*(IUH *)((IUH)Gdp + 2551))
#define SET_GLOBAL_EDL_WORKSPACE_211(v) (GLOBAL_EDL_WORKSPACE_211 = (v))
#define GLOBAL_EDL_WORKSPACE_212 (*(IUH *)((IUH)Gdp + 2555))
#define SET_GLOBAL_EDL_WORKSPACE_212(v) (GLOBAL_EDL_WORKSPACE_212 = (v))
#define GLOBAL_PoolAllocationRec (*(struct PoolAllocationREC *)((IUH)Gdp + 2559))
#define SET_GLOBAL_PoolAllocationRec(v) (GLOBAL_PoolAllocationRec = (v))
#define GLOBAL_LightCompiledLRUrec (*(struct BufferIndexREC* *)((IUH)Gdp + 2879))
#define SET_GLOBAL_LightCompiledLRUrec(v) (GLOBAL_LightCompiledLRUrec = (v))
#define GLOBAL_HSPinCodePages (((*(IBOOL *)((IUH)Gdp + 2883)) & 1) != 0)
#define SET_GLOBAL_HSPinCodePages(v) ((*(IBOOL *)((IUH)Gdp + 2883)) = (v) ? 1: 0)
#define GLOBAL_LastCompiledCsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 2887))
#define SET_GLOBAL_LastCompiledCsDesc(v) (GLOBAL_LastCompiledCsDesc = (v))
#define GLOBAL_CrossPageInstructions (*(IU8* *)((IUH)Gdp + 2891))
#define SET_GLOBAL_CrossPageInstructions(v) (GLOBAL_CrossPageInstructions = (v))
#define GLOBAL_FlushingCache (((*(IBOOL *)((IUH)Gdp + 2895)) & 1) != 0)
#define SET_GLOBAL_FlushingCache(v) ((*(IBOOL *)((IUH)Gdp + 2895)) = (v) ? 1: 0)
#define GLOBAL_suppressIroning (((*(IBOOL *)((IUH)Gdp + 2899)) & 1) != 0)
#define SET_GLOBAL_suppressIroning(v) ((*(IBOOL *)((IUH)Gdp + 2899)) = (v) ? 1: 0)
#define GLOBAL_IHook (*(IU32 *)((IUH)Gdp + 2903))
#define SET_GLOBAL_IHook(v) (GLOBAL_IHook = (v))
#define GLOBAL_EDL_WORKSPACE_213 (*(IUH *)((IUH)Gdp + 2907))
#define SET_GLOBAL_EDL_WORKSPACE_213(v) (GLOBAL_EDL_WORKSPACE_213 = (v))
#define GLOBAL_InterruptRec (*(struct InterruptREC *)((IUH)Gdp + 2911))
#define SET_GLOBAL_InterruptRec(v) (GLOBAL_InterruptRec = (v))
#define GLOBAL_SasReInitNow (((*(IBOOL *)((IUH)Gdp + 2923)) & 1) != 0)
#define SET_GLOBAL_SasReInitNow(v) ((*(IBOOL *)((IUH)Gdp + 2923)) = (v) ? 1: 0)
#define GLOBAL_SasReInitSize (*(IU32 *)((IUH)Gdp + 2927))
#define SET_GLOBAL_SasReInitSize(v) (GLOBAL_SasReInitSize = (v))
#define GLOBAL_EDL_WORKSPACE_214 (*(IUH *)((IUH)Gdp + 2931))
#define SET_GLOBAL_EDL_WORKSPACE_214(v) (GLOBAL_EDL_WORKSPACE_214 = (v))
#define GLOBAL_EDL_WORKSPACE_215 (*(IUH *)((IUH)Gdp + 2935))
#define SET_GLOBAL_EDL_WORKSPACE_215(v) (GLOBAL_EDL_WORKSPACE_215 = (v))
#define GLOBAL_EDL_WORKSPACE_216 (*(IUH *)((IUH)Gdp + 2939))
#define SET_GLOBAL_EDL_WORKSPACE_216(v) (GLOBAL_EDL_WORKSPACE_216 = (v))
#define GLOBAL_QuickTickerRec (*(struct QuickTickerREC *)((IUH)Gdp + 2943))
#define SET_GLOBAL_QuickTickerRec(v) (GLOBAL_QuickTickerRec = (v))
#define GLOBAL_PigSynchCount (*(IUH *)((IUH)Gdp + 2967))
#define SET_GLOBAL_PigSynchCount(v) (GLOBAL_PigSynchCount = (v))
#define GLOBAL_CodeBufferSizeBits (*(IUH *)((IUH)Gdp + 2971))
#define SET_GLOBAL_CodeBufferSizeBits(v) (GLOBAL_CodeBufferSizeBits = (v))
#define GLOBAL_CodeBufferSize (*(IUH *)((IUH)Gdp + 2975))
#define SET_GLOBAL_CodeBufferSize(v) (GLOBAL_CodeBufferSize = (v))
#define GLOBAL_DataBufferSize (*(IUH *)((IUH)Gdp + 2979))
#define SET_GLOBAL_DataBufferSize(v) (GLOBAL_DataBufferSize = (v))
#define GLOBAL_AllBuffers (*(struct BufferIndexREC* *)((IUH)Gdp + 2983))
#define SET_GLOBAL_AllBuffers(v) (GLOBAL_AllBuffers = (v))
#define GLOBAL_LightBufferLRU (*(struct BufferIndexREC* *)((IUH)Gdp + 2987))
#define SET_GLOBAL_LightBufferLRU(v) (GLOBAL_LightBufferLRU = (v))
#define GLOBAL_CompilationBuffer (*(struct BufferIndexREC* *)((IUH)Gdp + 2991))
#define SET_GLOBAL_CompilationBuffer(v) (GLOBAL_CompilationBuffer = (v))
#define GLOBAL_PendingDeletions (*(struct BufferIndexREC* *)((IUH)Gdp + 2995))
#define SET_GLOBAL_PendingDeletions(v) (GLOBAL_PendingDeletions = (v))
#define GLOBAL_FragmentInfoArray (*(struct FragmentInfoREC* *)((IUH)Gdp + 2999))
#define SET_GLOBAL_FragmentInfoArray(v) (GLOBAL_FragmentInfoArray = (v))
#define GLOBAL_HostCodeBufferLimit (*(IU32* *)((IUH)Gdp + 3003))
#define SET_GLOBAL_HostCodeBufferLimit(v) (GLOBAL_HostCodeBufferLimit = (v))
#define GLOBAL_CopiedCleanups (*(IU8* *)((IUH)Gdp + 3007))
#define SET_GLOBAL_CopiedCleanups(v) (GLOBAL_CopiedCleanups = (v))
#define GLOBAL_FreeDebugInfoList (*(struct DebugInfoREC* *)((IUH)Gdp + 3011))
#define SET_GLOBAL_FreeDebugInfoList(v) (GLOBAL_FreeDebugInfoList = (v))
#define GLOBAL_CodeBufferOverrun (*(IU32* *)((IUH)Gdp + 3015))
#define SET_GLOBAL_CodeBufferOverrun(v) (GLOBAL_CodeBufferOverrun = (v))
#define GLOBAL_OverrunHighWaterMark (*(IU32* *)((IUH)Gdp + 3019))
#define SET_GLOBAL_OverrunHighWaterMark(v) (GLOBAL_OverrunHighWaterMark = (v))
#define GLOBAL_NumberOfBuffers (*(IU16 *)((IUH)Gdp + 3023))
#define SET_GLOBAL_NumberOfBuffers(v) (GLOBAL_NumberOfBuffers = (v))
#define GLOBAL_NextFragmentIndex (*(struct FragmentIndexREC* *)((IUH)Gdp + 3027))
#define SET_GLOBAL_NextFragmentIndex(v) (GLOBAL_NextFragmentIndex = (v))
#define GLOBAL_NextFragmentData (*(struct FragmentDataREC* *)((IUH)Gdp + 3031))
#define SET_GLOBAL_NextFragmentData(v) (GLOBAL_NextFragmentData = (v))
#define GLOBAL_FpuDisabled (((*(IBOOL *)((IUH)Gdp + 3035)) & 1) != 0)
#define SET_GLOBAL_FpuDisabled(v) ((*(IBOOL *)((IUH)Gdp + 3035)) = (v) ? 1: 0)
#define GLOBAL_GenerateNPXexception (((*(IBOOL *)((IUH)Gdp + 3039)) & 1) != 0)
#define SET_GLOBAL_GenerateNPXexception(v) ((*(IBOOL *)((IUH)Gdp + 3039)) = (v) ? 1: 0)
#define GLOBAL_NpxExceptionEIP (*(IUH *)((IUH)Gdp + 3043))
#define SET_GLOBAL_NpxExceptionEIP(v) (GLOBAL_NpxExceptionEIP = (v))
#define GLOBAL_NpxControl (*(IUH *)((IUH)Gdp + 3047))
#define SET_GLOBAL_NpxControl(v) (GLOBAL_NpxControl = (v))
#define GLOBAL_NpxStatus (*(IUH *)((IUH)Gdp + 3051))
#define SET_GLOBAL_NpxStatus(v) (GLOBAL_NpxStatus = (v))
#define GLOBAL_NpxFEA (*(IUH *)((IUH)Gdp + 3055))
#define SET_GLOBAL_NpxFEA(v) (GLOBAL_NpxFEA = (v))
#define GLOBAL_NpxFDS (*(IUH *)((IUH)Gdp + 3059))
#define SET_GLOBAL_NpxFDS(v) (GLOBAL_NpxFDS = (v))
#define GLOBAL_NpxFIP (*(IUH *)((IUH)Gdp + 3063))
#define SET_GLOBAL_NpxFIP(v) (GLOBAL_NpxFIP = (v))
#define GLOBAL_NpxFOP (*(IUH *)((IUH)Gdp + 3067))
#define SET_GLOBAL_NpxFOP(v) (GLOBAL_NpxFOP = (v))
#define GLOBAL_NpxFCS (*(IUH *)((IUH)Gdp + 3071))
#define SET_GLOBAL_NpxFCS(v) (GLOBAL_NpxFCS = (v))
#define GLOBAL_NpxSWFlagC0 (*(IUH *)((IUH)Gdp + 3075))
#define SET_GLOBAL_NpxSWFlagC0(v) (GLOBAL_NpxSWFlagC0 = (v))
#define GLOBAL_NpxSWFlagC1 (*(IUH *)((IUH)Gdp + 3079))
#define SET_GLOBAL_NpxSWFlagC1(v) (GLOBAL_NpxSWFlagC1 = (v))
#define GLOBAL_NpxSWFlagC2 (*(IUH *)((IUH)Gdp + 3083))
#define SET_GLOBAL_NpxSWFlagC2(v) (GLOBAL_NpxSWFlagC2 = (v))
#define GLOBAL_NpxSWFlagC3 (*(IUH *)((IUH)Gdp + 3087))
#define SET_GLOBAL_NpxSWFlagC3(v) (GLOBAL_NpxSWFlagC3 = (v))
#define GLOBAL_NpxLastSel (*(IUH *)((IUH)Gdp + 3091))
#define SET_GLOBAL_NpxLastSel(v) (GLOBAL_NpxLastSel = (v))
#define GLOBAL_NpxLastOff (*(IUH *)((IUH)Gdp + 3095))
#define SET_GLOBAL_NpxLastOff(v) (GLOBAL_NpxLastOff = (v))
#define GLOBAL_NpxException (((*(IBOOL *)((IUH)Gdp + 3099)) & 1) != 0)
#define SET_GLOBAL_NpxException(v) ((*(IBOOL *)((IUH)Gdp + 3099)) = (v) ? 1: 0)
#define GLOBAL_npxRounding (*(IUH *)((IUH)Gdp + 3103))
#define SET_GLOBAL_npxRounding(v) (GLOBAL_npxRounding = (v))
#define GLOBAL_UnmaskedOUP (((*(IBOOL *)((IUH)Gdp + 3107)) & 1) != 0)
#define SET_GLOBAL_UnmaskedOUP(v) ((*(IBOOL *)((IUH)Gdp + 3107)) = (v) ? 1: 0)
#define GLOBAL_hostFpuExceptions (*(IUH *)((IUH)Gdp + 3111))
#define SET_GLOBAL_hostFpuExceptions(v) (GLOBAL_hostFpuExceptions = (v))
#define GLOBAL_savedFpuExceptions (*(IUH *)((IUH)Gdp + 3115))
#define SET_GLOBAL_savedFpuExceptions(v) (GLOBAL_savedFpuExceptions = (v))
#define GLOBAL_tempFpuExceptions (*(IUH *)((IUH)Gdp + 3119))
#define SET_GLOBAL_tempFpuExceptions(v) (GLOBAL_tempFpuExceptions = (v))
#define GLOBAL_savedFpuXcptnOverflow (*(IUH *)((IUH)Gdp + 3123))
#define SET_GLOBAL_savedFpuXcptnOverflow(v) (GLOBAL_savedFpuXcptnOverflow = (v))
#define GLOBAL_savedFpuXcptnUnderflow (*(IUH *)((IUH)Gdp + 3127))
#define SET_GLOBAL_savedFpuXcptnUnderflow(v) (GLOBAL_savedFpuXcptnUnderflow = (v))
#define GLOBAL_savedFpuXcptnPrecision (*(IUH *)((IUH)Gdp + 3131))
#define SET_GLOBAL_savedFpuXcptnPrecision(v) (GLOBAL_savedFpuXcptnPrecision = (v))
#define GLOBAL_MaxBCDValue (*(struct FPSTACKENTRY *)((IUH)Gdp + 3135))
#define SET_GLOBAL_MaxBCDValue(v) (GLOBAL_MaxBCDValue = (v))
#define GLOBAL_FPUpload (*(struct FPSTACKENTRY *)((IUH)Gdp + 3151))
#define SET_GLOBAL_FPUpload(v) (GLOBAL_FPUpload = (v))
#define GLOBAL_ConstTable (*(struct FPSTACKENTRY* *)((IUH)Gdp + 3167))
#define SET_GLOBAL_ConstTable(v) (GLOBAL_ConstTable = (v))
#define GLOBAL_FPTemp (*(struct FPSTACKENTRY* *)((IUH)Gdp + 3171))
#define SET_GLOBAL_FPTemp(v) (GLOBAL_FPTemp = (v))
#define GLOBAL_FPUStackBase (*(struct FPSTACKENTRY* *)((IUH)Gdp + 3175))
#define SET_GLOBAL_FPUStackBase(v) (GLOBAL_FPUStackBase = (v))
#define GLOBAL_TOSPtr (*(struct FPSTACKENTRY* *)((IUH)Gdp + 3179))
#define SET_GLOBAL_TOSPtr(v) (GLOBAL_TOSPtr = (v))
#define GLOBAL_Npx64BitZero (*(struct FP_I64 *)((IUH)Gdp + 3183))
#define SET_GLOBAL_Npx64BitZero(v) (GLOBAL_Npx64BitZero = (v))
#define GLOBAL_Npx64BitMaxNeg (*(struct FP_I64 *)((IUH)Gdp + 3191))
#define SET_GLOBAL_Npx64BitMaxNeg(v) (GLOBAL_Npx64BitMaxNeg = (v))
#define GLOBAL_Npx64BitHalfMaxNeg (*(struct FP_I64 *)((IUH)Gdp + 3199))
#define SET_GLOBAL_Npx64BitHalfMaxNeg(v) (GLOBAL_Npx64BitHalfMaxNeg = (v))
#define GLOBAL_Npx64BitVal1 (*(struct FP_I64 *)((IUH)Gdp + 3207))
#define SET_GLOBAL_Npx64BitVal1(v) (GLOBAL_Npx64BitVal1 = (v))
#define GLOBAL_FscaleTable (*(IUH* *)((IUH)Gdp + 3215))
#define SET_GLOBAL_FscaleTable(v) (GLOBAL_FscaleTable = (v))
#define GLOBAL_CompZeroTable (*(IU32* *)((IUH)Gdp + 3219))
#define SET_GLOBAL_CompZeroTable(v) (GLOBAL_CompZeroTable = (v))
#define GLOBAL_BCDLowNibble (*(struct FP_I64* *)((IUH)Gdp + 3223))
#define SET_GLOBAL_BCDLowNibble(v) (GLOBAL_BCDLowNibble = (v))
#define GLOBAL_BCDHighNibble (*(struct FP_I64* *)((IUH)Gdp + 3227))
#define SET_GLOBAL_BCDHighNibble(v) (GLOBAL_BCDHighNibble = (v))
#define GLOBAL_FpatanTable (*(struct FPSTACKENTRY* *)((IUH)Gdp + 3231))
#define SET_GLOBAL_FpatanTable(v) (GLOBAL_FpatanTable = (v))
#define GLOBAL_Pigging (((*(IBOOL *)((IUH)Gdp + 3235)) & 1) != 0)
#define SET_GLOBAL_Pigging(v) ((*(IBOOL *)((IUH)Gdp + 3235)) = (v) ? 1: 0)
#define GLOBAL_PigInterruptState (((*(IBOOL *)((IUH)Gdp + 3239)) & 1) != 0)
#define SET_GLOBAL_PigInterruptState(v) ((*(IBOOL *)((IUH)Gdp + 3239)) = (v) ? 1: 0)
#define GLOBAL_PigIgnoreFlags (((*(IBOOL *)((IUH)Gdp + 3243)) & 1) != 0)
#define SET_GLOBAL_PigIgnoreFlags(v) ((*(IBOOL *)((IUH)Gdp + 3243)) = (v) ? 1: 0)
#define GLOBAL_ApiPigSynchCount (*(IU16 *)((IUH)Gdp + 3247))
#define SET_GLOBAL_ApiPigSynchCount(v) (GLOBAL_ApiPigSynchCount = (v))
#define GLOBAL_ApiPigSynchTable (*(IU32* *)((IUH)Gdp + 3251))
#define SET_GLOBAL_ApiPigSynchTable(v) (GLOBAL_ApiPigSynchTable = (v))
#define GLOBAL_PigSynchWanted (((*(IBOOL *)((IUH)Gdp + 3255)) & 1) != 0)
#define SET_GLOBAL_PigSynchWanted(v) ((*(IBOOL *)((IUH)Gdp + 3255)) = (v) ? 1: 0)
#define GLOBAL_SadAX (*(ISH *)((IUH)Gdp + 3259))
#define SET_GLOBAL_SadAX(v) (GLOBAL_SadAX = (v))
#define GLOBAL_SadBX (*(ISH *)((IUH)Gdp + 3263))
#define SET_GLOBAL_SadBX(v) (GLOBAL_SadBX = (v))
#define GLOBAL_SadCX (*(ISH *)((IUH)Gdp + 3267))
#define SET_GLOBAL_SadCX(v) (GLOBAL_SadCX = (v))
#define GLOBAL_SadDX (*(ISH *)((IUH)Gdp + 3271))
#define SET_GLOBAL_SadDX(v) (GLOBAL_SadDX = (v))
#define GLOBAL_SadBP (*(ISH *)((IUH)Gdp + 3275))
#define SET_GLOBAL_SadBP(v) (GLOBAL_SadBP = (v))
#define GLOBAL_SadSP (*(ISH *)((IUH)Gdp + 3279))
#define SET_GLOBAL_SadSP(v) (GLOBAL_SadSP = (v))
#define GLOBAL_SadSI (*(ISH *)((IUH)Gdp + 3283))
#define SET_GLOBAL_SadSI(v) (GLOBAL_SadSI = (v))
#define GLOBAL_SadDI (*(ISH *)((IUH)Gdp + 3287))
#define SET_GLOBAL_SadDI(v) (GLOBAL_SadDI = (v))
#define GLOBAL_SadEIP (*(ISH *)((IUH)Gdp + 3291))
#define SET_GLOBAL_SadEIP(v) (GLOBAL_SadEIP = (v))
#define GLOBAL_SadEFLAGS (*(ISH *)((IUH)Gdp + 3295))
#define SET_GLOBAL_SadEFLAGS(v) (GLOBAL_SadEFLAGS = (v))
#define GLOBAL_Parameter1 (*(ISH *)((IUH)Gdp + 3299))
#define SET_GLOBAL_Parameter1(v) (GLOBAL_Parameter1 = (v))
#define GLOBAL_Parameter2 (*(ISH *)((IUH)Gdp + 3303))
#define SET_GLOBAL_Parameter2(v) (GLOBAL_Parameter2 = (v))
#define GLOBAL_BpiKnownTable (*(ISH* *)((IUH)Gdp + 3307))
#define SET_GLOBAL_BpiKnownTable(v) (GLOBAL_BpiKnownTable = (v))
#define GLOBAL_BpiWorkTable (*(ISH* *)((IUH)Gdp + 3311))
#define SET_GLOBAL_BpiWorkTable(v) (GLOBAL_BpiWorkTable = (v))
#define GLOBAL_BpiLabelTable (*(ISH* *)((IUH)Gdp + 3315))
#define SET_GLOBAL_BpiLabelTable(v) (GLOBAL_BpiLabelTable = (v))
#define GLOBAL_BpiFragment (*(struct FragmentDataREC* *)((IUH)Gdp + 3319))
#define SET_GLOBAL_BpiFragment(v) (GLOBAL_BpiFragment = (v))
#define GLOBAL_BpiCompilationBuffer (*(struct BufferIndexREC* *)((IUH)Gdp + 3323))
#define SET_GLOBAL_BpiCompilationBuffer(v) (GLOBAL_BpiCompilationBuffer = (v))
#define GLOBAL_BpiCompiledCode (*(IU32* *)((IUH)Gdp + 3327))
#define SET_GLOBAL_BpiCompiledCode(v) (GLOBAL_BpiCompiledCode = (v))
#define GLOBAL_BpiCompiledStep (*(IU32* *)((IUH)Gdp + 3331))
#define SET_GLOBAL_BpiCompiledStep(v) (GLOBAL_BpiCompiledStep = (v))
#define GLOBAL_BpiCompiledUser (*(IU32* *)((IUH)Gdp + 3335))
#define SET_GLOBAL_BpiCompiledUser(v) (GLOBAL_BpiCompiledUser = (v))
#define GLOBAL_SafeToReturnToSnippet (((*(IBOOL *)((IUH)Gdp + 3339)) & 1) != 0)
#define SET_GLOBAL_SafeToReturnToSnippet(v) ((*(IBOOL *)((IUH)Gdp + 3339)) = (v) ? 1: 0)
#define GLOBAL_BpiIntelStats (((*(IBOOL *)((IUH)Gdp + 3343)) & 1) != 0)
#define SET_GLOBAL_BpiIntelStats(v) ((*(IBOOL *)((IUH)Gdp + 3343)) = (v) ? 1: 0)
#define GLOBAL_BpiSuppressFunc (((*(IBOOL *)((IUH)Gdp + 3347)) & 1) != 0)
#define SET_GLOBAL_BpiSuppressFunc(v) ((*(IBOOL *)((IUH)Gdp + 3347)) = (v) ? 1: 0)
#define GLOBAL_BpiIntelStatFree (*(struct BpiIntelStatBlock* *)((IUH)Gdp + 3351))
#define SET_GLOBAL_BpiIntelStatFree(v) (GLOBAL_BpiIntelStatFree = (v))
#define GLOBAL_BpiIntelStatIndx (*(struct BpiIntelStatBlock** *)((IUH)Gdp + 3355))
#define SET_GLOBAL_BpiIntelStatIndx(v) (GLOBAL_BpiIntelStatIndx = (v))
#define GLOBAL_OpBpirealFt (*(IUH *)((IUH)Gdp + 3359))
#define SET_GLOBAL_OpBpirealFt(v) (GLOBAL_OpBpirealFt = (v))
#define GLOBAL_OpBpirealF1 (*(IUH *)((IUH)Gdp + 3363))
#define SET_GLOBAL_OpBpirealF1(v) (GLOBAL_OpBpirealF1 = (v))
#define GLOBAL_OpBpirealF2 (*(IUH *)((IUH)Gdp + 3367))
#define SET_GLOBAL_OpBpirealF2(v) (GLOBAL_OpBpirealF2 = (v))
#define GLOBAL_OpBpirealF3 (*(IUH *)((IUH)Gdp + 3371))
#define SET_GLOBAL_OpBpirealF3(v) (GLOBAL_OpBpirealF3 = (v))
#define GLOBAL_OpBpirealUniv (*(IU32 *)((IUH)Gdp + 3375))
#define SET_GLOBAL_OpBpirealUniv(v) (GLOBAL_OpBpirealUniv = (v))
#define GLOBAL_OpBpirealWhereAmI (*(IU32* *)((IUH)Gdp + 3379))
#define SET_GLOBAL_OpBpirealWhereAmI(v) (GLOBAL_OpBpirealWhereAmI = (v))
#define GLOBAL_EDL_WORKSPACE_217 (*(IUH *)((IUH)Gdp + 3383))
#define SET_GLOBAL_EDL_WORKSPACE_217(v) (GLOBAL_EDL_WORKSPACE_217 = (v))
#define GLOBAL_EDL_WORKSPACE_218 (*(IUH *)((IUH)Gdp + 3387))
#define SET_GLOBAL_EDL_WORKSPACE_218(v) (GLOBAL_EDL_WORKSPACE_218 = (v))
#define GLOBAL_ApiBufferChain (*(struct BufferIndexREC *)((IUH)Gdp + 3391))
#define SET_GLOBAL_ApiBufferChain(v) (GLOBAL_ApiBufferChain = (v))
#define GLOBAL_ApiCompilationBuffer (*(struct BufferIndexREC* *)((IUH)Gdp + 3427))
#define SET_GLOBAL_ApiCompilationBuffer(v) (GLOBAL_ApiCompilationBuffer = (v))
#define GLOBAL_ApiNumberOfBuffers (*(IU8 *)((IUH)Gdp + 3431))
#define SET_GLOBAL_ApiNumberOfBuffers(v) (GLOBAL_ApiNumberOfBuffers = (v))
#define GLOBAL_ApiNextFragmentIndex (*(struct FragmentIndexREC* *)((IUH)Gdp + 3435))
#define SET_GLOBAL_ApiNextFragmentIndex(v) (GLOBAL_ApiNextFragmentIndex = (v))
#define GLOBAL_ApiNextFragmentData (*(struct FragmentDataREC* *)((IUH)Gdp + 3439))
#define SET_GLOBAL_ApiNextFragmentData(v) (GLOBAL_ApiNextFragmentData = (v))
#define GLOBAL_ApiGDTBase (*(IU32 *)((IUH)Gdp + 3443))
#define SET_GLOBAL_ApiGDTBase(v) (GLOBAL_ApiGDTBase = (v))
#define GLOBAL_ApiGDTLimit (*(IU16 *)((IUH)Gdp + 3447))
#define SET_GLOBAL_ApiGDTLimit(v) (GLOBAL_ApiGDTLimit = (v))
#define GLOBAL_ApiMinBuffNr (*(IUH *)((IUH)Gdp + 3451))
#define SET_GLOBAL_ApiMinBuffNr(v) (GLOBAL_ApiMinBuffNr = (v))
#define GLOBAL_ApiMaxBuffNr (*(IUH *)((IUH)Gdp + 3455))
#define SET_GLOBAL_ApiMaxBuffNr(v) (GLOBAL_ApiMaxBuffNr = (v))
#define GLOBAL_EDL_WORKSPACE_219 (*(IUH *)((IUH)Gdp + 3459))
#define SET_GLOBAL_EDL_WORKSPACE_219(v) (GLOBAL_EDL_WORKSPACE_219 = (v))
#define GLOBAL_EDL_WORKSPACE_220 (*(IUH *)((IUH)Gdp + 3463))
#define SET_GLOBAL_EDL_WORKSPACE_220(v) (GLOBAL_EDL_WORKSPACE_220 = (v))
#define GLOBAL_EDL_WORKSPACE_221 (*(IUH *)((IUH)Gdp + 3467))
#define SET_GLOBAL_EDL_WORKSPACE_221(v) (GLOBAL_EDL_WORKSPACE_221 = (v))
#define GLOBAL_EDL_WORKSPACE_222 (*(IUH *)((IUH)Gdp + 3471))
#define SET_GLOBAL_EDL_WORKSPACE_222(v) (GLOBAL_EDL_WORKSPACE_222 = (v))
#define GLOBAL_EDL_WORKSPACE_223 (*(IUH *)((IUH)Gdp + 3475))
#define SET_GLOBAL_EDL_WORKSPACE_223(v) (GLOBAL_EDL_WORKSPACE_223 = (v))
#define GLOBAL_EDL_WORKSPACE_224 (*(IUH *)((IUH)Gdp + 3479))
#define SET_GLOBAL_EDL_WORKSPACE_224(v) (GLOBAL_EDL_WORKSPACE_224 = (v))
#define GLOBAL_EDL_WORKSPACE_225 (*(IUH *)((IUH)Gdp + 3483))
#define SET_GLOBAL_EDL_WORKSPACE_225(v) (GLOBAL_EDL_WORKSPACE_225 = (v))
#define GLOBAL_EDL_WORKSPACE_226 (*(IUH *)((IUH)Gdp + 3487))
#define SET_GLOBAL_EDL_WORKSPACE_226(v) (GLOBAL_EDL_WORKSPACE_226 = (v))
#define GLOBAL_EDL_WORKSPACE_227 (*(IUH *)((IUH)Gdp + 3491))
#define SET_GLOBAL_EDL_WORKSPACE_227(v) (GLOBAL_EDL_WORKSPACE_227 = (v))
#define GLOBAL_EDL_WORKSPACE_228 (*(IUH *)((IUH)Gdp + 3495))
#define SET_GLOBAL_EDL_WORKSPACE_228(v) (GLOBAL_EDL_WORKSPACE_228 = (v))
#define GLOBAL_EDL_WORKSPACE_229 (*(IUH *)((IUH)Gdp + 3499))
#define SET_GLOBAL_EDL_WORKSPACE_229(v) (GLOBAL_EDL_WORKSPACE_229 = (v))
#define GLOBAL_EDL_WORKSPACE_230 (*(IUH *)((IUH)Gdp + 3503))
#define SET_GLOBAL_EDL_WORKSPACE_230(v) (GLOBAL_EDL_WORKSPACE_230 = (v))
#define GLOBAL_EDL_WORKSPACE_231 (*(IUH *)((IUH)Gdp + 3507))
#define SET_GLOBAL_EDL_WORKSPACE_231(v) (GLOBAL_EDL_WORKSPACE_231 = (v))
#define GLOBAL_EDL_WORKSPACE_232 (*(IUH *)((IUH)Gdp + 3511))
#define SET_GLOBAL_EDL_WORKSPACE_232(v) (GLOBAL_EDL_WORKSPACE_232 = (v))
#define GLOBAL_EDL_WORKSPACE_233 (*(IUH *)((IUH)Gdp + 3515))
#define SET_GLOBAL_EDL_WORKSPACE_233(v) (GLOBAL_EDL_WORKSPACE_233 = (v))
#define GLOBAL_EDL_WORKSPACE_234 (*(IUH *)((IUH)Gdp + 3519))
#define SET_GLOBAL_EDL_WORKSPACE_234(v) (GLOBAL_EDL_WORKSPACE_234 = (v))
#define GLOBAL_EDL_WORKSPACE_235 (*(IUH *)((IUH)Gdp + 3523))
#define SET_GLOBAL_EDL_WORKSPACE_235(v) (GLOBAL_EDL_WORKSPACE_235 = (v))
#define GLOBAL_EDL_WORKSPACE_236 (*(IUH *)((IUH)Gdp + 3527))
#define SET_GLOBAL_EDL_WORKSPACE_236(v) (GLOBAL_EDL_WORKSPACE_236 = (v))
#define GLOBAL_EDL_WORKSPACE_237 (*(IUH *)((IUH)Gdp + 3531))
#define SET_GLOBAL_EDL_WORKSPACE_237(v) (GLOBAL_EDL_WORKSPACE_237 = (v))
#define GLOBAL_EDL_WORKSPACE_238 (*(IUH *)((IUH)Gdp + 3535))
#define SET_GLOBAL_EDL_WORKSPACE_238(v) (GLOBAL_EDL_WORKSPACE_238 = (v))
#define GLOBAL_EDL_WORKSPACE_239 (*(IUH *)((IUH)Gdp + 3539))
#define SET_GLOBAL_EDL_WORKSPACE_239(v) (GLOBAL_EDL_WORKSPACE_239 = (v))
#define GLOBAL_EDL_WORKSPACE_240 (*(IUH *)((IUH)Gdp + 3543))
#define SET_GLOBAL_EDL_WORKSPACE_240(v) (GLOBAL_EDL_WORKSPACE_240 = (v))
#define GLOBAL_EDL_WORKSPACE_241 (*(IUH *)((IUH)Gdp + 3547))
#define SET_GLOBAL_EDL_WORKSPACE_241(v) (GLOBAL_EDL_WORKSPACE_241 = (v))
#define GLOBAL_EDL_WORKSPACE_242 (*(IUH *)((IUH)Gdp + 3551))
#define SET_GLOBAL_EDL_WORKSPACE_242(v) (GLOBAL_EDL_WORKSPACE_242 = (v))
#define GLOBAL_EDL_WORKSPACE_243 (*(IUH *)((IUH)Gdp + 3555))
#define SET_GLOBAL_EDL_WORKSPACE_243(v) (GLOBAL_EDL_WORKSPACE_243 = (v))
#define GLOBAL_EDL_WORKSPACE_244 (*(IUH *)((IUH)Gdp + 3559))
#define SET_GLOBAL_EDL_WORKSPACE_244(v) (GLOBAL_EDL_WORKSPACE_244 = (v))
#define GLOBAL_EDL_WORKSPACE_245 (*(IUH *)((IUH)Gdp + 3563))
#define SET_GLOBAL_EDL_WORKSPACE_245(v) (GLOBAL_EDL_WORKSPACE_245 = (v))
#define GLOBAL_EDL_WORKSPACE_246 (*(IUH *)((IUH)Gdp + 3567))
#define SET_GLOBAL_EDL_WORKSPACE_246(v) (GLOBAL_EDL_WORKSPACE_246 = (v))
#define GLOBAL_EDL_WORKSPACE_247 (*(IUH *)((IUH)Gdp + 3571))
#define SET_GLOBAL_EDL_WORKSPACE_247(v) (GLOBAL_EDL_WORKSPACE_247 = (v))
#define GLOBAL_EDL_WORKSPACE_248 (*(IUH *)((IUH)Gdp + 3575))
#define SET_GLOBAL_EDL_WORKSPACE_248(v) (GLOBAL_EDL_WORKSPACE_248 = (v))
#define GLOBAL_EDL_WORKSPACE_249 (*(IUH *)((IUH)Gdp + 3579))
#define SET_GLOBAL_EDL_WORKSPACE_249(v) (GLOBAL_EDL_WORKSPACE_249 = (v))
#define GLOBAL_NpxOpndBuff (*(struct OpndBuffREC *)((IUH)Gdp + 3583))
#define SET_GLOBAL_NpxOpndBuff(v) (GLOBAL_NpxOpndBuff = (v))
#define GLOBAL_NewRingOffsetPtr (*(IUH* *)((IUH)Gdp + 3711))
#define SET_GLOBAL_NewRingOffsetPtr(v) (GLOBAL_NewRingOffsetPtr = (v))
#define GLOBAL_GLDC_NextCtxId (*(IUH *)((IUH)Gdp + 3715))
#define SET_GLOBAL_GLDC_NextCtxId(v) (GLOBAL_GLDC_NextCtxId = (v))
#define GLOBAL_GLDC_curCtxId (*(IUH *)((IUH)Gdp + 3719))
#define SET_GLOBAL_GLDC_curCtxId(v) (GLOBAL_GLDC_curCtxId = (v))
#define GLOBAL_GLDC_CxtIDs (*(IU8* *)((IUH)Gdp + 3723))
#define SET_GLOBAL_GLDC_CxtIDs(v) (GLOBAL_GLDC_CxtIDs = (v))
#define GLOBAL_GLDC_Index_High_Water (*(IUH *)((IUH)Gdp + 3727))
#define SET_GLOBAL_GLDC_Index_High_Water(v) (GLOBAL_GLDC_Index_High_Water = (v))
#define GLOBAL_GLDC_Context_High_Water (*(IUH *)((IUH)Gdp + 3731))
#define SET_GLOBAL_GLDC_Context_High_Water(v) (GLOBAL_GLDC_Context_High_Water = (v))
#define GLOBAL_GLDC_IndexPtr (*(struct GLDC_REC** *)((IUH)Gdp + 3735))
#define SET_GLOBAL_GLDC_IndexPtr(v) (GLOBAL_GLDC_IndexPtr = (v))
#define GLOBAL_GLDC_CrBase (*(IUH* *)((IUH)Gdp + 3739))
#define SET_GLOBAL_GLDC_CrBase(v) (GLOBAL_GLDC_CrBase = (v))
#define GLOBAL_GLDC_NULL_REC (*(struct GLDC_REC* *)((IUH)Gdp + 3743))
#define SET_GLOBAL_GLDC_NULL_REC(v) (GLOBAL_GLDC_NULL_REC = (v))
#define GLOBAL_GLDC_DUMMY_REC (*(struct GLDC_REC* *)((IUH)Gdp + 3747))
#define SET_GLOBAL_GLDC_DUMMY_REC(v) (GLOBAL_GLDC_DUMMY_REC = (v))
#define GLOBAL_hackyfix (*(IUH *)((IUH)Gdp + 3751))
#define SET_GLOBAL_hackyfix(v) (GLOBAL_hackyfix = (v))
#define GLOBAL_IDC_ArrayPtr (*(struct IDC_REC* *)((IUH)Gdp + 3755))
#define SET_GLOBAL_IDC_ArrayPtr(v) (GLOBAL_IDC_ArrayPtr = (v))
#define GLOBAL_IDC_BaseLimitCntxTable (*(struct IDC_BASE_LIMIT_CONTEXT* *)((IUH)Gdp + 3759))
#define SET_GLOBAL_IDC_BaseLimitCntxTable(v) (GLOBAL_IDC_BaseLimitCntxTable = (v))
#define GLOBAL_IDC_IdtSeqVal (*(IUH *)((IUH)Gdp + 3763))
#define SET_GLOBAL_IDC_IdtSeqVal(v) (GLOBAL_IDC_IdtSeqVal = (v))
#define GLOBAL_IDC_IdtHighWater (*(IUH *)((IUH)Gdp + 3767))
#define SET_GLOBAL_IDC_IdtHighWater(v) (GLOBAL_IDC_IdtHighWater = (v))
#define GLOBAL_IDC_IdtCntrlVal (*(IUH *)((IUH)Gdp + 3771))
#define SET_GLOBAL_IDC_IdtCntrlVal(v) (GLOBAL_IDC_IdtCntrlVal = (v))
#define GLOBAL_IDC_IdtCntrlValNoCheck (*(IUH *)((IUH)Gdp + 3775))
#define SET_GLOBAL_IDC_IdtCntrlValNoCheck(v) (GLOBAL_IDC_IdtCntrlValNoCheck = (v))
#define GLOBAL_IDC_IdtSeqMask (*(IUH *)((IUH)Gdp + 3779))
#define SET_GLOBAL_IDC_IdtSeqMask(v) (GLOBAL_IDC_IdtSeqMask = (v))
#define GLOBAL_PX_trace (((*(IBOOL *)((IUH)Gdp + 3783)) & 1) != 0)
#define SET_GLOBAL_PX_trace(v) ((*(IBOOL *)((IUH)Gdp + 3783)) = (v) ? 1: 0)
#define GLOBAL_PX_doing_contributory (((*(IBOOL *)((IUH)Gdp + 3787)) & 1) != 0)
#define SET_GLOBAL_PX_doing_contributory(v) ((*(IBOOL *)((IUH)Gdp + 3787)) = (v) ? 1: 0)
#define GLOBAL_PX_doing_page_fault (((*(IBOOL *)((IUH)Gdp + 3791)) & 1) != 0)
#define SET_GLOBAL_PX_doing_page_fault(v) ((*(IBOOL *)((IUH)Gdp + 3791)) = (v) ? 1: 0)
#define GLOBAL_PX_doing_double_fault (((*(IBOOL *)((IUH)Gdp + 3795)) & 1) != 0)
#define SET_GLOBAL_PX_doing_double_fault(v) ((*(IBOOL *)((IUH)Gdp + 3795)) = (v) ? 1: 0)
#define GLOBAL_PX_doing_fault (((*(IBOOL *)((IUH)Gdp + 3799)) & 1) != 0)
#define SET_GLOBAL_PX_doing_fault(v) ((*(IBOOL *)((IUH)Gdp + 3799)) = (v) ? 1: 0)
#define GLOBAL_PX_source (*(IUH *)((IUH)Gdp + 3803))
#define SET_GLOBAL_PX_source(v) (GLOBAL_PX_source = (v))
#define GLOBAL_RF_OnXcptnWanted (((*(IBOOL *)((IUH)Gdp + 3807)) & 1) != 0)
#define SET_GLOBAL_RF_OnXcptnWanted(v) ((*(IBOOL *)((IUH)Gdp + 3807)) = (v) ? 1: 0)
#define GLOBAL_PX_Cleaned_Eip (*(IU32 *)((IUH)Gdp + 3811))
#define SET_GLOBAL_PX_Cleaned_Eip(v) (GLOBAL_PX_Cleaned_Eip = (v))
#define GLOBAL_VDM_FaultHandler (*(IUH* *)((IUH)Gdp + 3815))
#define SET_GLOBAL_VDM_FaultHandler(v) (GLOBAL_VDM_FaultHandler = (v))
#define GLOBAL_IntrHasErrorCode (((*(IBOOL *)((IUH)Gdp + 3819)) & 1) != 0)
#define SET_GLOBAL_IntrHasErrorCode(v) ((*(IBOOL *)((IUH)Gdp + 3819)) = (v) ? 1: 0)
#define GLOBAL_IntrErrorCode (*(IU16 *)((IUH)Gdp + 3823))
#define SET_GLOBAL_IntrErrorCode(v) (GLOBAL_IntrErrorCode = (v))
#define GLOBAL_CInbTable (*(IUH** *)((IUH)Gdp + 3827))
#define SET_GLOBAL_CInbTable(v) (GLOBAL_CInbTable = (v))
#define GLOBAL_CInwTable (*(IUH** *)((IUH)Gdp + 3831))
#define SET_GLOBAL_CInwTable(v) (GLOBAL_CInwTable = (v))
#define GLOBAL_CIndTable (*(IUH** *)((IUH)Gdp + 3835))
#define SET_GLOBAL_CIndTable(v) (GLOBAL_CIndTable = (v))
#define GLOBAL_COutbTable (*(IUH** *)((IUH)Gdp + 3839))
#define SET_GLOBAL_COutbTable(v) (GLOBAL_COutbTable = (v))
#define GLOBAL_COutwTable (*(IUH** *)((IUH)Gdp + 3843))
#define SET_GLOBAL_COutwTable(v) (GLOBAL_COutwTable = (v))
#define GLOBAL_COutdTable (*(IUH** *)((IUH)Gdp + 3847))
#define SET_GLOBAL_COutdTable(v) (GLOBAL_COutdTable = (v))
#define GLOBAL_InAdapFromPort (*(IU8* *)((IUH)Gdp + 3851))
#define SET_GLOBAL_InAdapFromPort(v) (GLOBAL_InAdapFromPort = (v))
#define GLOBAL_OutAdapFromPort (*(IU8* *)((IUH)Gdp + 3855))
#define SET_GLOBAL_OutAdapFromPort(v) (GLOBAL_OutAdapFromPort = (v))
#define GLOBAL_InbFuncWrapper (*(IUH** *)((IUH)Gdp + 3859))
#define SET_GLOBAL_InbFuncWrapper(v) (GLOBAL_InbFuncWrapper = (v))
#define GLOBAL_InwFuncWrapper (*(IUH** *)((IUH)Gdp + 3863))
#define SET_GLOBAL_InwFuncWrapper(v) (GLOBAL_InwFuncWrapper = (v))
#define GLOBAL_IndFuncWrapper (*(IUH** *)((IUH)Gdp + 3867))
#define SET_GLOBAL_IndFuncWrapper(v) (GLOBAL_IndFuncWrapper = (v))
#define GLOBAL_OutbFuncWrapper (*(IUH** *)((IUH)Gdp + 3871))
#define SET_GLOBAL_OutbFuncWrapper(v) (GLOBAL_OutbFuncWrapper = (v))
#define GLOBAL_OutwFuncWrapper (*(IUH** *)((IUH)Gdp + 3875))
#define SET_GLOBAL_OutwFuncWrapper(v) (GLOBAL_OutwFuncWrapper = (v))
#define GLOBAL_OutdFuncWrapper (*(IUH** *)((IUH)Gdp + 3879))
#define SET_GLOBAL_OutdFuncWrapper(v) (GLOBAL_OutdFuncWrapper = (v))
#define GLOBAL_TempByteDest (*(IU8 *)((IUH)Gdp + 3883))
#define SET_GLOBAL_TempByteDest(v) (GLOBAL_TempByteDest = (v))
#define GLOBAL_TempWordDest (*(IU16 *)((IUH)Gdp + 3887))
#define SET_GLOBAL_TempWordDest(v) (GLOBAL_TempWordDest = (v))
#define GLOBAL_TempDoubleDest (*(IU32 *)((IUH)Gdp + 3891))
#define SET_GLOBAL_TempDoubleDest(v) (GLOBAL_TempDoubleDest = (v))
#define GLOBAL_MaxValidAdaptor (*(IUH *)((IUH)Gdp + 3895))
#define SET_GLOBAL_MaxValidAdaptor(v) (GLOBAL_MaxValidAdaptor = (v))
#define GLOBAL_IOSPortMask (*(IU16 *)((IUH)Gdp + 3899))
#define SET_GLOBAL_IOSPortMask(v) (GLOBAL_IOSPortMask = (v))
#define GLOBAL_nt_adaptor (*(IU8 *)((IUH)Gdp + 3903))
#define SET_GLOBAL_nt_adaptor(v) (GLOBAL_nt_adaptor = (v))
#define GLOBAL_EDL_WORKSPACE_250 (*(IUH *)((IUH)Gdp + 3907))
#define SET_GLOBAL_EDL_WORKSPACE_250(v) (GLOBAL_EDL_WORKSPACE_250 = (v))
#define GLOBAL_EDL_WORKSPACE_251 (*(IUH *)((IUH)Gdp + 3911))
#define SET_GLOBAL_EDL_WORKSPACE_251(v) (GLOBAL_EDL_WORKSPACE_251 = (v))
#define GLOBAL_EDL_WORKSPACE_252 (*(IUH *)((IUH)Gdp + 3915))
#define SET_GLOBAL_EDL_WORKSPACE_252(v) (GLOBAL_EDL_WORKSPACE_252 = (v))
#define GLOBAL_EDL_WORKSPACE_253 (*(IUH *)((IUH)Gdp + 3919))
#define SET_GLOBAL_EDL_WORKSPACE_253(v) (GLOBAL_EDL_WORKSPACE_253 = (v))
#define GLOBAL_EDL_WORKSPACE_254 (*(IUH *)((IUH)Gdp + 3923))
#define SET_GLOBAL_EDL_WORKSPACE_254(v) (GLOBAL_EDL_WORKSPACE_254 = (v))
#define GLOBAL_EDL_WORKSPACE_255 (*(IUH *)((IUH)Gdp + 3927))
#define SET_GLOBAL_EDL_WORKSPACE_255(v) (GLOBAL_EDL_WORKSPACE_255 = (v))
#define GLOBAL_EDL_WORKSPACE_256 (*(IUH *)((IUH)Gdp + 3931))
#define SET_GLOBAL_EDL_WORKSPACE_256(v) (GLOBAL_EDL_WORKSPACE_256 = (v))
#define GLOBAL_SegDescPtrLookupREC (*(struct DYNAMIC_DESC_PTR_LOOKUP *)((IUH)Gdp + 3935))
#define SET_GLOBAL_SegDescPtrLookupREC(v) (GLOBAL_SegDescPtrLookupREC = (v))
#define GLOBAL_SegBaseLookupREC (*(struct DYNAMIC_SEG_COOKIE_LOOKUP *)((IUH)Gdp + 3967))
#define SET_GLOBAL_SegBaseLookupREC(v) (GLOBAL_SegBaseLookupREC = (v))
#define GLOBAL_SegCookieLookupREC (*(struct DYNAMIC_SEG_COOKIE_LOOKUP *)((IUH)Gdp + 3999))
#define SET_GLOBAL_SegCookieLookupREC(v) (GLOBAL_SegCookieLookupREC = (v))
#define GLOBAL_ZeroValue (*(IU32 *)((IUH)Gdp + 4031))
#define SET_GLOBAL_ZeroValue(v) (GLOBAL_ZeroValue = (v))
#define GLOBAL_HSP (*(IU8* *)((IUH)Gdp + 4035))
#define SET_GLOBAL_HSP(v) (GLOBAL_HSP = (v))
#define GLOBAL_ESPsanctuary (*(IU32 *)((IUH)Gdp + 4039))
#define SET_GLOBAL_ESPsanctuary(v) (GLOBAL_ESPsanctuary = (v))
#define GLOBAL_exclPopLimit (*(IU8* *)((IUH)Gdp + 4043))
#define SET_GLOBAL_exclPopLimit(v) (GLOBAL_exclPopLimit = (v))
#define GLOBAL_inclPushLimit (*(IU8* *)((IUH)Gdp + 4047))
#define SET_GLOBAL_inclPushLimit(v) (GLOBAL_inclPushLimit = (v))
#define GLOBAL_notionalSsBase (*(IU8* *)((IUH)Gdp + 4051))
#define SET_GLOBAL_notionalSsBase(v) (GLOBAL_notionalSsBase = (v))
#define GLOBAL_notionalSsBase2 (*(IU8* *)((IUH)Gdp + 4055))
#define SET_GLOBAL_notionalSsBase2(v) (GLOBAL_notionalSsBase2 = (v))
#define GLOBAL_notionalSsBase4 (*(IU8* *)((IUH)Gdp + 4059))
#define SET_GLOBAL_notionalSsBase4(v) (GLOBAL_notionalSsBase4 = (v))
#define GLOBAL_stackIsWrappable (((*(IBOOL *)((IUH)Gdp + 4063)) & 1) != 0)
#define SET_GLOBAL_stackIsWrappable(v) ((*(IBOOL *)((IUH)Gdp + 4063)) = (v) ? 1: 0)
#define GLOBAL_stackIsBig (((*(IBOOL *)((IUH)Gdp + 4067)) & 1) != 0)
#define SET_GLOBAL_stackIsBig(v) ((*(IBOOL *)((IUH)Gdp + 4067)) = (v) ? 1: 0)
#define GLOBAL_stackIsExpandDown (((*(IBOOL *)((IUH)Gdp + 4071)) & 1) != 0)
#define SET_GLOBAL_stackIsExpandDown(v) ((*(IBOOL *)((IUH)Gdp + 4071)) = (v) ? 1: 0)
#define GLOBAL_stackMask (*(IU32 *)((IUH)Gdp + 4075))
#define SET_GLOBAL_stackMask(v) (GLOBAL_stackMask = (v))
#define GLOBAL_stackNeedsNormalising (((*(IBOOL *)((IUH)Gdp + 4079)) & 1) != 0)
#define SET_GLOBAL_stackNeedsNormalising(v) ((*(IBOOL *)((IUH)Gdp + 4079)) = (v) ? 1: 0)
#define GLOBAL_laInTopPage (*(IU32 *)((IUH)Gdp + 4083))
#define SET_GLOBAL_laInTopPage(v) (GLOBAL_laInTopPage = (v))
#define GLOBAL_laInBottomPage (*(IU32 *)((IUH)Gdp + 4087))
#define SET_GLOBAL_laInBottomPage(v) (GLOBAL_laInBottomPage = (v))
#define GLOBAL_hspOK (((*(IBOOL *)((IUH)Gdp + 4091)) & 1) != 0)
#define SET_GLOBAL_hspOK(v) ((*(IBOOL *)((IUH)Gdp + 4091)) = (v) ? 1: 0)
#define GLOBAL_pushScratch (*(IU8* *)((IUH)Gdp + 4095))
#define SET_GLOBAL_pushScratch(v) (GLOBAL_pushScratch = (v))
#define GLOBAL_pushScratchInUse (((*(IBOOL *)((IUH)Gdp + 4099)) & 1) != 0)
#define SET_GLOBAL_pushScratchInUse(v) ((*(IBOOL *)((IUH)Gdp + 4099)) = (v) ? 1: 0)
#define GLOBAL_pushScratchReqSize (*(IUH *)((IUH)Gdp + 4103))
#define SET_GLOBAL_pushScratchReqSize(v) (GLOBAL_pushScratchReqSize = (v))
#define GLOBAL_popScratch (*(IU8* *)((IUH)Gdp + 4107))
#define SET_GLOBAL_popScratch(v) (GLOBAL_popScratch = (v))
#define GLOBAL_popScratchInUse (((*(IBOOL *)((IUH)Gdp + 4111)) & 1) != 0)
#define SET_GLOBAL_popScratchInUse(v) ((*(IBOOL *)((IUH)Gdp + 4111)) = (v) ? 1: 0)
#define GLOBAL_SafeStackIronFrig (((*(IBOOL *)((IUH)Gdp + 4115)) & 1) != 0)
#define SET_GLOBAL_SafeStackIronFrig(v) ((*(IBOOL *)((IUH)Gdp + 4115)) = (v) ? 1: 0)
#define GLOBAL_SafeOutOfBoundsFrig (((*(IBOOL *)((IUH)Gdp + 4119)) & 1) != 0)
#define SET_GLOBAL_SafeOutOfBoundsFrig(v) ((*(IBOOL *)((IUH)Gdp + 4119)) = (v) ? 1: 0)
#define GLOBAL_HBP (*(IU8* *)((IUH)Gdp + 4123))
#define SET_GLOBAL_HBP(v) (GLOBAL_HBP = (v))
#define GLOBAL_newHSP (*(IU8* *)((IUH)Gdp + 4127))
#define SET_GLOBAL_newHSP(v) (GLOBAL_newHSP = (v))
#define GLOBAL_newExclPopLimit (*(IU8* *)((IUH)Gdp + 4131))
#define SET_GLOBAL_newExclPopLimit(v) (GLOBAL_newExclPopLimit = (v))
#define GLOBAL_newInclPushLimit (*(IU8* *)((IUH)Gdp + 4135))
#define SET_GLOBAL_newInclPushLimit(v) (GLOBAL_newInclPushLimit = (v))
#define GLOBAL_newNotionalSsBase (*(IU8* *)((IUH)Gdp + 4139))
#define SET_GLOBAL_newNotionalSsBase(v) (GLOBAL_newNotionalSsBase = (v))
#define GLOBAL_newStackIsWrappable (((*(IBOOL *)((IUH)Gdp + 4143)) & 1) != 0)
#define SET_GLOBAL_newStackIsWrappable(v) ((*(IBOOL *)((IUH)Gdp + 4143)) = (v) ? 1: 0)
#define GLOBAL_newStackIsBig (((*(IBOOL *)((IUH)Gdp + 4147)) & 1) != 0)
#define SET_GLOBAL_newStackIsBig(v) ((*(IBOOL *)((IUH)Gdp + 4147)) = (v) ? 1: 0)
#define GLOBAL_newStackIsExpandDown (((*(IBOOL *)((IUH)Gdp + 4151)) & 1) != 0)
#define SET_GLOBAL_newStackIsExpandDown(v) ((*(IBOOL *)((IUH)Gdp + 4151)) = (v) ? 1: 0)
#define GLOBAL_newStackMask (*(IU32 *)((IUH)Gdp + 4155))
#define SET_GLOBAL_newStackMask(v) (GLOBAL_newStackMask = (v))
#define GLOBAL_newLaInBottomPage (*(IU32 *)((IUH)Gdp + 4159))
#define SET_GLOBAL_newLaInBottomPage(v) (GLOBAL_newLaInBottomPage = (v))
#define GLOBAL_newHspOK (((*(IBOOL *)((IUH)Gdp + 4163)) & 1) != 0)
#define SET_GLOBAL_newHspOK(v) ((*(IBOOL *)((IUH)Gdp + 4163)) = (v) ? 1: 0)
#define GLOBAL_newPushScratch (*(IU8* *)((IUH)Gdp + 4167))
#define SET_GLOBAL_newPushScratch(v) (GLOBAL_newPushScratch = (v))
#define GLOBAL_newPushScratchInUse (((*(IBOOL *)((IUH)Gdp + 4171)) & 1) != 0)
#define SET_GLOBAL_newPushScratchInUse(v) ((*(IBOOL *)((IUH)Gdp + 4171)) = (v) ? 1: 0)
#define GLOBAL_newPushScratchReqSize (*(IUH *)((IUH)Gdp + 4175))
#define SET_GLOBAL_newPushScratchReqSize(v) (GLOBAL_newPushScratchReqSize = (v))
#define GLOBAL_newStackIsSupervisor (((*(IBOOL *)((IUH)Gdp + 4179)) & 1) != 0)
#define SET_GLOBAL_newStackIsSupervisor(v) ((*(IBOOL *)((IUH)Gdp + 4179)) = (v) ? 1: 0)
#define GLOBAL_SSTAT_PostDstOddBailOut (*(IUH *)((IUH)Gdp + 4183))
#define SET_GLOBAL_SSTAT_PostDstOddBailOut(v) (GLOBAL_SSTAT_PostDstOddBailOut = (v))
#define GLOBAL_SSTAT_PostDstBailOut (*(IUH *)((IUH)Gdp + 4187))
#define SET_GLOBAL_SSTAT_PostDstBailOut(v) (GLOBAL_SSTAT_PostDstBailOut = (v))
#define GLOBAL_SSTAT_JcProcBailOut (*(IUH *)((IUH)Gdp + 4191))
#define SET_GLOBAL_SSTAT_JcProcBailOut(v) (GLOBAL_SSTAT_JcProcBailOut = (v))
#define GLOBAL_SSTAT_CalcStackUniBailOut (*(IUH *)((IUH)Gdp + 4195))
#define SET_GLOBAL_SSTAT_CalcStackUniBailOut(v) (GLOBAL_SSTAT_CalcStackUniBailOut = (v))
#define GLOBAL_SSTAT_SetupHbpBailOut (*(IUH *)((IUH)Gdp + 4199))
#define SET_GLOBAL_SSTAT_SetupHbpBailOut(v) (GLOBAL_SSTAT_SetupHbpBailOut = (v))
#define GLOBAL_SSTAT_SetupHbpOddBailOut (*(IUH *)((IUH)Gdp + 4203))
#define SET_GLOBAL_SSTAT_SetupHbpOddBailOut(v) (GLOBAL_SSTAT_SetupHbpOddBailOut = (v))
#define GLOBAL_VDM_SoftIntHandler (*(IUH* *)((IUH)Gdp + 4207))
#define SET_GLOBAL_VDM_SoftIntHandler(v) (GLOBAL_VDM_SoftIntHandler = (v))
#define GLOBAL_EOIEnable (*(IU8* *)((IUH)Gdp + 4211))
#define SET_GLOBAL_EOIEnable(v) (GLOBAL_EOIEnable = (v))
#define GLOBAL_AddProfilePtr (*(IUH* *)((IUH)Gdp + 4215))
#define SET_GLOBAL_AddProfilePtr(v) (GLOBAL_AddProfilePtr = (v))
#define GLOBAL_MaxProfileData (*(IUH* *)((IUH)Gdp + 4219))
#define SET_GLOBAL_MaxProfileData(v) (GLOBAL_MaxProfileData = (v))
#define GLOBAL_FreeContextHead (*(struct ContextREC* *)((IUH)Gdp + 4223))
#define SET_GLOBAL_FreeContextHead(v) (GLOBAL_FreeContextHead = (v))
#define GLOBAL_ValidContextHead (*(struct ContextREC* *)((IUH)Gdp + 4227))
#define SET_GLOBAL_ValidContextHead(v) (GLOBAL_ValidContextHead = (v))
#define GLOBAL_CurrentContextPtr (*(struct ContextREC* *)((IUH)Gdp + 4231))
#define SET_GLOBAL_CurrentContextPtr(v) (GLOBAL_CurrentContextPtr = (v))
#define GLOBAL_CurrentContext (*(IU8 *)((IUH)Gdp + 4235))
#define SET_GLOBAL_CurrentContext(v) (GLOBAL_CurrentContext = (v))
#define GLOBAL_SeenGDTUse (((*(IBOOL *)((IUH)Gdp + 4239)) & 1) != 0)
#define SET_GLOBAL_SeenGDTUse(v) ((*(IBOOL *)((IUH)Gdp + 4239)) = (v) ? 1: 0)
#define GLOBAL_SeenLDTUse (((*(IBOOL *)((IUH)Gdp + 4243)) & 1) != 0)
#define SET_GLOBAL_SeenLDTUse(v) ((*(IBOOL *)((IUH)Gdp + 4243)) = (v) ? 1: 0)
#define GLOBAL_Context (*(struct ContextREC* *)((IUH)Gdp + 4247))
#define SET_GLOBAL_Context(v) (GLOBAL_Context = (v))
#define GLOBAL_diffLDTList (*(IU16* *)((IUH)Gdp + 4251))
#define SET_GLOBAL_diffLDTList(v) (GLOBAL_diffLDTList = (v))
#define GLOBAL_nextDiffLDT (*(IUH *)((IUH)Gdp + 4255))
#define SET_GLOBAL_nextDiffLDT(v) (GLOBAL_nextDiffLDT = (v))
#define GLOBAL_functions (*(IU32** *)((IUH)Gdp + 4259))
#define SET_GLOBAL_functions(v) (GLOBAL_functions = (v))
#define GLOBAL_selectedFunction (*(IU32* *)((IUH)Gdp + 4263))
#define SET_GLOBAL_selectedFunction(v) (GLOBAL_selectedFunction = (v))
#define GLOBAL_instrCountdown (*(ISH *)((IUH)Gdp + 4267))
#define SET_GLOBAL_instrCountdown(v) (GLOBAL_instrCountdown = (v))
#define GLOBAL_blockRecords (*(struct BLOCK_RECORD* *)((IUH)Gdp + 4271))
#define SET_GLOBAL_blockRecords(v) (GLOBAL_blockRecords = (v))
#define GLOBAL_patchRecords (*(struct PatchREC* *)((IUH)Gdp + 4275))
#define SET_GLOBAL_patchRecords(v) (GLOBAL_patchRecords = (v))
#define GLOBAL_nanoCompParameter (*(IUH *)((IUH)Gdp + 4279))
#define SET_GLOBAL_nanoCompParameter(v) (GLOBAL_nanoCompParameter = (v))
#define GLOBAL_intelCopyPtrComp (*(IU8* *)((IUH)Gdp + 4283))
#define SET_GLOBAL_intelCopyPtrComp(v) (GLOBAL_intelCopyPtrComp = (v))
#define GLOBAL_nrOfBlocksToCompile (*(IUH *)((IUH)Gdp + 4287))
#define SET_GLOBAL_nrOfBlocksToCompile(v) (GLOBAL_nrOfBlocksToCompile = (v))
#define GLOBAL_entryPointHashTable (*(IU16* *)((IUH)Gdp + 4291))
#define SET_GLOBAL_entryPointHashTable(v) (GLOBAL_entryPointHashTable = (v))
#define GLOBAL_nextFreeEntryPointRec (*(struct EntryPointREC* *)((IUH)Gdp + 4295))
#define SET_GLOBAL_nextFreeEntryPointRec(v) (GLOBAL_nextFreeEntryPointRec = (v))
#define GLOBAL_firstEntryPointPtr (*(struct EntryPointREC* *)((IUH)Gdp + 4299))
#define SET_GLOBAL_firstEntryPointPtr(v) (GLOBAL_firstEntryPointPtr = (v))
#define GLOBAL_blockPtr (*(struct BLOCK_RECORD* *)((IUH)Gdp + 4303))
#define SET_GLOBAL_blockPtr(v) (GLOBAL_blockPtr = (v))
#define GLOBAL_headAndTailBlockPtr (*(struct BLOCK_RECORD* *)((IUH)Gdp + 4307))
#define SET_GLOBAL_headAndTailBlockPtr(v) (GLOBAL_headAndTailBlockPtr = (v))
#define GLOBAL_nrOfInstrsParsed (*(IUH *)((IUH)Gdp + 4311))
#define SET_GLOBAL_nrOfInstrsParsed(v) (GLOBAL_nrOfInstrsParsed = (v))
#define GLOBAL_intelPtrLimit (*(IU8* *)((IUH)Gdp + 4315))
#define SET_GLOBAL_intelPtrLimit(v) (GLOBAL_intelPtrLimit = (v))
#define GLOBAL_blockStartIntelPtr (*(IU8* *)((IUH)Gdp + 4319))
#define SET_GLOBAL_blockStartIntelPtr(v) (GLOBAL_blockStartIntelPtr = (v))
#define GLOBAL_blockStartCodeOffset (*(IUH *)((IUH)Gdp + 4323))
#define SET_GLOBAL_blockStartCodeOffset(v) (GLOBAL_blockStartCodeOffset = (v))
#define GLOBAL_finalCodeOffset (*(IUH *)((IUH)Gdp + 4327))
#define SET_GLOBAL_finalCodeOffset(v) (GLOBAL_finalCodeOffset = (v))
#define GLOBAL_ni_BlockPtr (*(struct NI_BLOCK_RECORD* *)((IUH)Gdp + 4331))
#define SET_GLOBAL_ni_BlockPtr(v) (GLOBAL_ni_BlockPtr = (v))
#define GLOBAL_nanoOp3 (*(IUH *)((IUH)Gdp + 4335))
#define SET_GLOBAL_nanoOp3(v) (GLOBAL_nanoOp3 = (v))
#define GLOBAL_sibByte (*(IUH *)((IUH)Gdp + 4339))
#define SET_GLOBAL_sibByte(v) (GLOBAL_sibByte = (v))
#define GLOBAL_dynamicOffset (*(IU32 *)((IUH)Gdp + 4343))
#define SET_GLOBAL_dynamicOffset(v) (GLOBAL_dynamicOffset = (v))
#define GLOBAL_eaSegCode (*(IUH *)((IUH)Gdp + 4347))
#define SET_GLOBAL_eaSegCode(v) (GLOBAL_eaSegCode = (v))
#define GLOBAL_simpleAccess (((*(IBOOL *)((IUH)Gdp + 4351)) & 1) != 0)
#define SET_GLOBAL_simpleAccess(v) ((*(IBOOL *)((IUH)Gdp + 4351)) = (v) ? 1: 0)
#define GLOBAL_simpleAccessPtr (*(IU8* *)((IUH)Gdp + 4355))
#define SET_GLOBAL_simpleAccessPtr(v) (GLOBAL_simpleAccessPtr = (v))
#define GLOBAL_instrStartIntelPtr (*(IU8* *)((IUH)Gdp + 4359))
#define SET_GLOBAL_instrStartIntelPtr(v) (GLOBAL_instrStartIntelPtr = (v))
#define GLOBAL_npxIntelPtr (*(IU8* *)((IUH)Gdp + 4363))
#define SET_GLOBAL_npxIntelPtr(v) (GLOBAL_npxIntelPtr = (v))
#define GLOBAL_topLevel (*(IUH* *)((IUH)Gdp + 4367))
#define SET_GLOBAL_topLevel(v) (GLOBAL_topLevel = (v))
#define GLOBAL_defaultPrimaryActions (*(IU32** *)((IUH)Gdp + 4371))
#define SET_GLOBAL_defaultPrimaryActions(v) (GLOBAL_defaultPrimaryActions = (v))
#define GLOBAL_actualPrimaryActions (*(IU32** *)((IUH)Gdp + 4375))
#define SET_GLOBAL_actualPrimaryActions(v) (GLOBAL_actualPrimaryActions = (v))
#define GLOBAL_codeOffset (*(IUH *)((IUH)Gdp + 4379))
#define SET_GLOBAL_codeOffset(v) (GLOBAL_codeOffset = (v))
#define GLOBAL_destCodeSegment (*(IUH *)((IUH)Gdp + 4383))
#define SET_GLOBAL_destCodeSegment(v) (GLOBAL_destCodeSegment = (v))
#define GLOBAL_destCodeOffset (*(IUH *)((IUH)Gdp + 4387))
#define SET_GLOBAL_destCodeOffset(v) (GLOBAL_destCodeOffset = (v))
#define GLOBAL_nanoEax (*(IU32 *)((IUH)Gdp + 4391))
#define SET_GLOBAL_nanoEax(v) (GLOBAL_nanoEax = (v))
#define GLOBAL_nanoEcx (*(IU32 *)((IUH)Gdp + 4395))
#define SET_GLOBAL_nanoEcx(v) (GLOBAL_nanoEcx = (v))
#define GLOBAL_nanoEdx (*(IU32 *)((IUH)Gdp + 4399))
#define SET_GLOBAL_nanoEdx(v) (GLOBAL_nanoEdx = (v))
#define GLOBAL_nanoEbx (*(IU32 *)((IUH)Gdp + 4403))
#define SET_GLOBAL_nanoEbx(v) (GLOBAL_nanoEbx = (v))
#define GLOBAL_nanoEsp (*(IU32 *)((IUH)Gdp + 4407))
#define SET_GLOBAL_nanoEsp(v) (GLOBAL_nanoEsp = (v))
#define GLOBAL_nanoEbp (*(IU32 *)((IUH)Gdp + 4411))
#define SET_GLOBAL_nanoEbp(v) (GLOBAL_nanoEbp = (v))
#define GLOBAL_nanoEsi (*(IU32 *)((IUH)Gdp + 4415))
#define SET_GLOBAL_nanoEsi(v) (GLOBAL_nanoEsi = (v))
#define GLOBAL_nanoEdi (*(IU32 *)((IUH)Gdp + 4419))
#define SET_GLOBAL_nanoEdi(v) (GLOBAL_nanoEdi = (v))
#define GLOBAL_espToRestore (*(IU32 *)((IUH)Gdp + 4423))
#define SET_GLOBAL_espToRestore(v) (GLOBAL_espToRestore = (v))
#define GLOBAL_entryExitCount (*(IU32 *)((IUH)Gdp + 4427))
#define SET_GLOBAL_entryExitCount(v) (GLOBAL_entryExitCount = (v))
#define GLOBAL_instructionCount (*(IU32 *)((IUH)Gdp + 4431))
#define SET_GLOBAL_instructionCount(v) (GLOBAL_instructionCount = (v))
#define GLOBAL_nanoDebugControl (*(IU32 *)((IUH)Gdp + 4435))
#define SET_GLOBAL_nanoDebugControl(v) (GLOBAL_nanoDebugControl = (v))
#define GLOBAL_compilationThreshold (*(IU32 *)((IUH)Gdp + 4439))
#define SET_GLOBAL_compilationThreshold(v) (GLOBAL_compilationThreshold = (v))
#define GLOBAL_maxBlocksToCompile (*(IUH *)((IUH)Gdp + 4443))
#define SET_GLOBAL_maxBlocksToCompile(v) (GLOBAL_maxBlocksToCompile = (v))
#define GLOBAL_blocksToCompile (*(struct BLOCK_TO_COMPILE* *)((IUH)Gdp + 4447))
#define SET_GLOBAL_blocksToCompile(v) (GLOBAL_blocksToCompile = (v))
#define GLOBAL_byteMemory (*(IU8* *)((IUH)Gdp + 4451))
#define SET_GLOBAL_byteMemory(v) (GLOBAL_byteMemory = (v))
#define GLOBAL_wordMemory (*(IU16* *)((IUH)Gdp + 4455))
#define SET_GLOBAL_wordMemory(v) (GLOBAL_wordMemory = (v))
#define GLOBAL_longMemory (*(IU32* *)((IUH)Gdp + 4459))
#define SET_GLOBAL_longMemory(v) (GLOBAL_longMemory = (v))
#define GLOBAL_ni_BlockRecords (*(struct NI_BLOCK_RECORD* *)((IUH)Gdp + 4463))
#define SET_GLOBAL_ni_BlockRecords(v) (GLOBAL_ni_BlockRecords = (v))
#define GLOBAL_intelCopyMemoryExec (*(IU8* *)((IUH)Gdp + 4467))
#define SET_GLOBAL_intelCopyMemoryExec(v) (GLOBAL_intelCopyMemoryExec = (v))
#define GLOBAL_intelCopyMemoryComp (*(IU8* *)((IUH)Gdp + 4471))
#define SET_GLOBAL_intelCopyMemoryComp(v) (GLOBAL_intelCopyMemoryComp = (v))
#define GLOBAL_intelCopyMemoryCompEnd (*(IU8* *)((IUH)Gdp + 4475))
#define SET_GLOBAL_intelCopyMemoryCompEnd(v) (GLOBAL_intelCopyMemoryCompEnd = (v))
#define GLOBAL_PpcCR4Save (*(IUH *)((IUH)Gdp + 4479))
#define SET_GLOBAL_PpcCR4Save(v) (GLOBAL_PpcCR4Save = (v))
#define GLOBAL_SfDelayFlagPtr (*(struct SfDelayRecord* *)((IUH)Gdp + 4483))
#define SET_GLOBAL_SfDelayFlagPtr(v) (GLOBAL_SfDelayFlagPtr = (v))
#define GLOBAL_SfDelayFlagLim (*(IUH *)((IUH)Gdp + 4487))
#define SET_GLOBAL_SfDelayFlagLim(v) (GLOBAL_SfDelayFlagLim = (v))
#define GLOBAL_SfDecrementerVal (*(IUH *)((IUH)Gdp + 4491))
#define SET_GLOBAL_SfDecrementerVal(v) (GLOBAL_SfDecrementerVal = (v))
#define GLOBAL_SFPciPageCount (*(IU32 *)((IUH)Gdp + 4495))
#define SET_GLOBAL_SFPciPageCount(v) (GLOBAL_SFPciPageCount = (v))
#define GLOBAL_SfProcessorType (*(IUH *)((IUH)Gdp + 4499))
#define SET_GLOBAL_SfProcessorType(v) (GLOBAL_SfProcessorType = (v))
#define GLOBAL_SfQEventPending (((*(IBOOL *)((IUH)Gdp + 4503)) & 1) != 0)
#define SET_GLOBAL_SfQEventPending(v) ((*(IBOOL *)((IUH)Gdp + 4503)) = (v) ? 1: 0)
#define GLOBAL_AllowUncheckedMode (((*(IBOOL *)((IUH)Gdp + 4507)) & 1) != 0)
#define SET_GLOBAL_AllowUncheckedMode(v) ((*(IBOOL *)((IUH)Gdp + 4507)) = (v) ? 1: 0)
#define GLOBAL_AllowAnyUnchecked (((*(IBOOL *)((IUH)Gdp + 4511)) & 1) != 0)
#define SET_GLOBAL_AllowAnyUnchecked(v) ((*(IBOOL *)((IUH)Gdp + 4511)) = (v) ? 1: 0)
#define GLOBAL_LastProtected (*(IUH *)((IUH)Gdp + 4515))
#define SET_GLOBAL_LastProtected(v) (GLOBAL_LastProtected = (v))
#define GLOBAL_EmulationSR (*(IUH *)((IUH)Gdp + 4519))
#define SET_GLOBAL_EmulationSR(v) (GLOBAL_EmulationSR = (v))
#define GLOBAL_CurrentCheckLevel (*(IUH *)((IUH)Gdp + 4523))
#define SET_GLOBAL_CurrentCheckLevel(v) (GLOBAL_CurrentCheckLevel = (v))
#define GLOBAL_UnProtSegmentValue (*(IUH *)((IUH)Gdp + 4527))
#define SET_GLOBAL_UnProtSegmentValue(v) (GLOBAL_UnProtSegmentValue = (v))
#define GLOBAL_SavedSegmentValue (*(IUH *)((IUH)Gdp + 4531))
#define SET_GLOBAL_SavedSegmentValue(v) (GLOBAL_SavedSegmentValue = (v))
#define GLOBAL_SavedBATIValue (*(IUH *)((IUH)Gdp + 4535))
#define SET_GLOBAL_SavedBATIValue(v) (GLOBAL_SavedBATIValue = (v))
#define GLOBAL_SavedBATDValue (*(IUH *)((IUH)Gdp + 4539))
#define SET_GLOBAL_SavedBATDValue(v) (GLOBAL_SavedBATDValue = (v))
#define GLOBAL_LogicalBaseAddrForIO (*(IU8* *)((IUH)Gdp + 4543))
#define SET_GLOBAL_LogicalBaseAddrForIO(v) (GLOBAL_LogicalBaseAddrForIO = (v))
#define GLOBAL_WriteToOutputPort (((*(IBOOL *)((IUH)Gdp + 4547)) & 1) != 0)
#define SET_GLOBAL_WriteToOutputPort(v) ((*(IBOOL *)((IUH)Gdp + 4547)) = (v) ? 1: 0)
#define GLOBAL_GateA20Status (*(IU8 *)((IUH)Gdp + 4551))
#define SET_GLOBAL_GateA20Status(v) (GLOBAL_GateA20Status = (v))
#define GLOBAL_MmuInVideoUniverse (*(IUH *)((IUH)Gdp + 4555))
#define SET_GLOBAL_MmuInVideoUniverse(v) (GLOBAL_MmuInVideoUniverse = (v))
#define GLOBAL_MmuWpBit (*(IUH *)((IUH)Gdp + 4559))
#define SET_GLOBAL_MmuWpBit(v) (GLOBAL_MmuWpBit = (v))
#define GLOBAL_MmuUsBit (*(IUH *)((IUH)Gdp + 4563))
#define SET_GLOBAL_MmuUsBit(v) (GLOBAL_MmuUsBit = (v))
#define GLOBAL_SfSkipVideoWriteSync (((*(IBOOL *)((IUH)Gdp + 4567)) & 1) != 0)
#define SET_GLOBAL_SfSkipVideoWriteSync(v) ((*(IBOOL *)((IUH)Gdp + 4567)) = (v) ? 1: 0)
#define GLOBAL_SfSkipVideoReadSync (((*(IBOOL *)((IUH)Gdp + 4571)) & 1) != 0)
#define SET_GLOBAL_SfSkipVideoReadSync(v) ((*(IBOOL *)((IUH)Gdp + 4571)) = (v) ? 1: 0)
#define GLOBAL_forceVideoState (((*(IBOOL *)((IUH)Gdp + 4575)) & 1) != 0)
#define SET_GLOBAL_forceVideoState(v) ((*(IBOOL *)((IUH)Gdp + 4575)) = (v) ? 1: 0)
#define GLOBAL_EDL_WORKSPACE_257 (*(IUH *)((IUH)Gdp + 4579))
#define SET_GLOBAL_EDL_WORKSPACE_257(v) (GLOBAL_EDL_WORKSPACE_257 = (v))
#define GLOBAL_EDL_WORKSPACE_258 (*(IUH *)((IUH)Gdp + 4583))
#define SET_GLOBAL_EDL_WORKSPACE_258(v) (GLOBAL_EDL_WORKSPACE_258 = (v))
#define GLOBAL_EDL_WORKSPACE_259 (*(IUH *)((IUH)Gdp + 4587))
#define SET_GLOBAL_EDL_WORKSPACE_259(v) (GLOBAL_EDL_WORKSPACE_259 = (v))
#define GLOBAL_EDL_WORKSPACE_260 (*(IUH *)((IUH)Gdp + 4591))
#define SET_GLOBAL_EDL_WORKSPACE_260(v) (GLOBAL_EDL_WORKSPACE_260 = (v))
#define GLOBAL_EDL_WORKSPACE_261 (*(IUH *)((IUH)Gdp + 4595))
#define SET_GLOBAL_EDL_WORKSPACE_261(v) (GLOBAL_EDL_WORKSPACE_261 = (v))
#define GLOBAL_EDL_WORKSPACE_262 (*(IUH *)((IUH)Gdp + 4599))
#define SET_GLOBAL_EDL_WORKSPACE_262(v) (GLOBAL_EDL_WORKSPACE_262 = (v))
#define GLOBAL_EDL_WORKSPACE_263 (*(IUH *)((IUH)Gdp + 4603))
#define SET_GLOBAL_EDL_WORKSPACE_263(v) (GLOBAL_EDL_WORKSPACE_263 = (v))
#define GLOBAL_ProtectedSet (*(struct SfRegisterSetREC *)((IUH)Gdp + 4607))
#define SET_GLOBAL_ProtectedSet(v) (GLOBAL_ProtectedSet = (v))
#define GLOBAL_CurrentFullRegSet (*(IUH *)((IUH)Gdp + 4671))
#define SET_GLOBAL_CurrentFullRegSet(v) (GLOBAL_CurrentFullRegSet = (v))
#define GLOBAL_AltRegZeros (*(struct SfRegZeroAlternateREC* *)((IUH)Gdp + 4675))
#define SET_GLOBAL_AltRegZeros(v) (GLOBAL_AltRegZeros = (v))
#define GLOBAL_FullSets (*(struct SfFullRegSetREC* *)((IUH)Gdp + 4679))
#define SET_GLOBAL_FullSets(v) (GLOBAL_FullSets = (v))
#define GLOBAL_RegSetNextFree (*(struct SfFullRegSetREC* *)((IUH)Gdp + 4683))
#define SET_GLOBAL_RegSetNextFree(v) (GLOBAL_RegSetNextFree = (v))
#define GLOBAL_ValidRegSetHeadPtr (*(struct SfFullRegSetREC* *)((IUH)Gdp + 4687))
#define SET_GLOBAL_ValidRegSetHeadPtr(v) (GLOBAL_ValidRegSetHeadPtr = (v))
#define GLOBAL_AltRegZeroNextFree (*(struct SfRegZeroAlternateREC* *)((IUH)Gdp + 4691))
#define SET_GLOBAL_AltRegZeroNextFree(v) (GLOBAL_AltRegZeroNextFree = (v))
#define GLOBAL_SfPciBaseAddressRegCount (*(IUH *)((IUH)Gdp + 4695))
#define SET_GLOBAL_SfPciBaseAddressRegCount(v) (GLOBAL_SfPciBaseAddressRegCount = (v))
#define GLOBAL_SfPciBaseAddressRegRecs (*(struct SfPciBaseAddressRegREC* *)((IUH)Gdp + 4699))
#define SET_GLOBAL_SfPciBaseAddressRegRecs(v) (GLOBAL_SfPciBaseAddressRegRecs = (v))
#define GLOBAL_SfPciMemoryWindowBase (*(IUH *)((IUH)Gdp + 4703))
#define SET_GLOBAL_SfPciMemoryWindowBase(v) (GLOBAL_SfPciMemoryWindowBase = (v))
#define GLOBAL_tmpESP (*(IUH *)((IUH)Gdp + 4707))
#define SET_GLOBAL_tmpESP(v) (GLOBAL_tmpESP = (v))
#define GLOBAL_EaOffs (*(IU32 *)((IUH)Gdp + 4711))
#define SET_GLOBAL_EaOffs(v) (GLOBAL_EaOffs = (v))
#define GLOBAL_BusinessResult (*(IUH *)((IUH)Gdp + 4715))
#define SET_GLOBAL_BusinessResult(v) (GLOBAL_BusinessResult = (v))
#define GLOBAL_TraceVector ((IU8 *)((IUH)Gdp + 4719))
#define GLOBAL_TraceVectorSize (40000)
#define GDP_OFFSET 1
#define GDP_SIZE 44719
#define GDP_CHECKSUM 32240743
extern IHP Gdp;
#endif /* _gdpvar_h */

/* A total of 1053 T_GLOBALs */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\idiv.c ===
/*[

idiv.c

LOCAL CHAR SccsID[]="@(#)idiv.c	1.7 08/01/94";

IDIV CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <idiv.h>
#include <c_div64.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Signed Divide.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
IDIV8
       	          
IFN1(
	IU32, op2	/* divisor operand */
    )


   {
   IS32 sresult;
   IS32 sop1;
   IS32 sop2;

   if ( op2 == 0 )
      Int0();   /* Divide by Zero Exception */

   sop2 = (IS32)op2;
   sop1 = (IS32)GET_AX();

   if ( sop1 & BIT15_MASK )	/* Sign extend operands to 32 bits */
      sop1 |= ~WORD_MASK;
   if ( sop2 & BIT7_MASK )
      sop2 |= ~BYTE_MASK;
   
   sresult = sop1 / sop2;	/* Do operation */

   if ( (sresult & 0xff80) == 0 || (sresult & 0xff80) == 0xff80 )
      ;   /* it fits */
   else
      Int0();   /* Result doesn't fit in destination */
   
   SET_AL(sresult);	/* Store Quotient */
   SET_AH(sop1 % sop2);	/* Store Remainder */

   /* Set all undefined flag(s) */
#ifdef SET_UNDEFINED_DIV_FLAG
   SET_CF(UNDEFINED_FLAG);
   SET_OF(UNDEFINED_FLAG);
   SET_SF(UNDEFINED_FLAG);
   SET_ZF(UNDEFINED_FLAG);
   SET_PF(UNDEFINED_FLAG);
   SET_AF(UNDEFINED_FLAG);
#endif
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Signed Divide.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
IDIV16
       	          
IFN1(
	IU32, op2	/* divisor operand */
    )


   {
   IS32 sresult;
   IS32 sop1;
   IS32 sop2;

   if ( op2 == 0 )
      Int0();   /* Divide by Zero Exception */
   
   sop2 = (IS32)op2;
   sop1 = (IU32)GET_DX() << 16 | GET_AX();

   if ( sop2 & BIT15_MASK )	/* Sign extend operands to 32 bits */
      sop2 |= ~WORD_MASK;

   sresult = sop1 / sop2;	/* Do operation */

   if ( (sresult & 0xffff8000) == 0 || (sresult & 0xffff8000) == 0xffff8000 )
      ;   /* it fits */
   else
      Int0();   /* Result doesn't fit in destination */
   
   SET_AX(sresult);	/* Store Quotient */
   SET_DX(sop1 % sop2);	/* Store Remainder */

   /* Set all undefined flag(s) */
#ifdef SET_UNDEFINED_DIV_FLAG
   SET_CF(UNDEFINED_FLAG);
   SET_OF(UNDEFINED_FLAG);
   SET_SF(UNDEFINED_FLAG);
   SET_ZF(UNDEFINED_FLAG);
   SET_PF(UNDEFINED_FLAG);
   SET_AF(UNDEFINED_FLAG);
#endif
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Signed Divide.                                                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
IDIV32
       	          
IFN1(
	IU32, op2	/* divisor operand */
    )


   {
   IS32 slr;   /* low result */
   IS32 shr;   /* high result */
   IS32 srem;  /* remainder */

   if ( op2 == 0 )
      Int0();   /* Divide by Zero Exception */
   
   shr = GET_EDX();
   slr = GET_EAX();
   div64(&shr, &slr, (IS32)op2, &srem);

   if ( ((shr == 0x00000000) && ((slr & BIT31_MASK) == 0)) ||
	((shr == 0xffffffff) && ((slr & BIT31_MASK) != 0)) )
      ;   /* it fits */
   else
      Int0();   /* Result doesn't fit in destination */
   
   SET_EAX(slr);		/* Store Quotient */
   SET_EDX(srem);	/* Store Remainder */

   /* Set all undefined flag(s) */
#ifdef SET_UNDEFINED_DIV_FLAG
   SET_CF(UNDEFINED_FLAG);
   SET_OF(UNDEFINED_FLAG);
   SET_SF(UNDEFINED_FLAG);
   SET_ZF(UNDEFINED_FLAG);
   SET_PF(UNDEFINED_FLAG);
   SET_AF(UNDEFINED_FLAG);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\fpu.c ===
/*[
 * ============================================================================
 *
 *	Name:		fpu.c
 *
 *	Author:		Paul Murray
 *
 *	Sccs ID:	@(#)fpu.c	1.54 03/23/95
 *
 *	Purpose:
 *
 *		Implements the Npx functionality of the Ccpu.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1993,1994. All rights reserved.
 *
 * ============================================================================
]*/
#include "insignia.h"
#include "host_def.h"
#include <math.h>
#include "cfpu_def.h"
#include "ckmalloc.h"

typedef enum {
FPSTACK,
M16I,
M32I,
M64I,
M32R,
M64R,
M80R
} NPXOPTYPE;


/* Function prototypes - everything returns void */
LOCAL FPH npx_rint IPT1(FPH, fpval);
LOCAL VOID GetIntelStatusWord IPT0();
LOCAL VOID SetIntelTagword IPT1(IU32, new_tag);
LOCAL VOID ReadI16FromIntel IPT2(IU32 *, valI16, VOID *, memPtr);
LOCAL VOID ReadI32FromIntel IPT2(IU32 *, valI32, VOID *, memPtr);
LOCAL VOID WriteI16ToIntel IPT2(VOID *, memPtr, IU16, valI16);
LOCAL VOID WriteI32ToIntel IPT2(VOID *, memPtr, IU32, valI32);
LOCAL VOID WriteNaNToIntel IPT2(VOID *, memPtr, FPSTACKENTRY *, valPtr);
LOCAL VOID WriteZeroToIntel IPT2(VOID *, memPtr, IU16, negZero);
LOCAL VOID SetIntelStatusWord IPT1(IU32, new_stat);
LOCAL VOID AdjustOverflowResponse IPT0();
LOCAL VOID AdjustUnderflowResponse IPT0();
LOCAL VOID WriteIndefiniteToIntel IPT1(VOID *, memPtr);
LOCAL VOID SignalDivideByZero IPT1(FPSTACKENTRY *, stackPtr);
LOCAL VOID SetPrecisionBit IPT0();
LOCAL VOID GetIntelTagword IPT1(IU32 *, current_tag);
LOCAL VOID WriteFP32ToIntel IPT2(VOID *, destPtr, FPSTACKENTRY *, srcPtr);
LOCAL VOID WriteFP64ToIntel IPT2(VOID *, destPtr, FPSTACKENTRY *, srcPtr);
LOCAL VOID WriteFP80ToIntel IPT2(VOID *, destPtr, FPSTACKENTRY *, srcPtr);
LOCAL VOID Mul64Bit8Bit IPT2(FPU_I64 *, as64, IU8, mul_count);
LOCAL VOID CopyFP IPT2(FPSTACKENTRY *, dest_addr, FPSTACKENTRY *, src_addr);
LOCAL VOID WriteBiggestNaN IPT3(IU16, destInd, FPSTACKENTRY *, val1Ptr, FPSTACKENTRY *, val2Ptr);
LOCAL VOID Sub64Bit64Bit IPT2(FPU_I64 *, as64a, FPU_I64 *, as64b);
LOCAL VOID CVTR80FPH IPT2(FPSTACKENTRY *, destPtr, FPSTACKENTRY *, srcPtr);
LOCAL BOOL Cmp64BitGTE IPT2(FPU_I64 *, as64a, FPU_I64 *, as64b);
LOCAL VOID CopyR32 IPT2(FPSTACKENTRY *, destPtr, VOID *, srcPtr);
LOCAL VOID CVTI64FPH IPT1(FPU_I64 *, as64);
LOCAL VOID CVTFPHI64 IPT2(FPU_I64 *, as64, FPH *, FPPtr);
LOCAL VOID Add64Bit8Bit IPT2(FPU_I64 *, as64, IU8, small_val);
LOCAL VOID CopyR64 IPT2(FPSTACKENTRY *, destPtr, VOID *, srcPtr);
LOCAL VOID CopyR80 IPT2(FPSTACKENTRY *, destPtr, VOID *, srcPtr);
LOCAL VOID CVTFPHR80 IPT1(FPSTACKENTRY *, memPtr);
LOCAL VOID WriteInfinityToIntel IPT2(VOID *, memPtr, IU16, neg_val);
LOCAL VOID PopStack IPT0();
LOCAL VOID CPY64BIT8BIT IPT2(FPU_I64 *, as64, IU8 *, as8);
LOCAL VOID WriteIntegerIndefinite IPT1(VOID *, memPtr);
LOCAL VOID SignalStackOverflow IPT1(FPSTACKENTRY *, StackPtr);
LOCAL VOID Set64Bit IPT2(FPU_I64 *, as64, IU8, small_val);
LOCAL VOID Sub64Bit8Bit IPT2(FPU_I64 *, as64, IU8, small_val);
LOCAL VOID SignalBCDIndefinite IPT1(IU8 *, memPtr);
GLOBAL VOID InitNpx IPT1(IBOOL, disabled);
LOCAL VOID LoadValue IPT2(VOID *, SrcOp, IU16 *, IndexVal);
LOCAL VOID Loadi16ToFP IPT2(FPSTACKENTRY *, FPPtr, VOID *, memPtr);
LOCAL VOID Loadi32ToFP IPT2(FPSTACKENTRY *, FPPtr, VOID *, memPtr);
LOCAL VOID Loadi64ToFP IPT2(FPSTACKENTRY *, FPPtr, VOID *, memPtr);
LOCAL VOID Loadr32ToFP IPT3(FPSTACKENTRY *, FPPtr, VOID *, memPtr, BOOL, setTOS);
LOCAL VOID Loadr64ToFP IPT3(FPSTACKENTRY *, FPPtr, VOID *, memPtr, BOOL, setTOS);
LOCAL VOID Loadr80ToFP IPT2(FPSTACKENTRY *, FPPtr, VOID *, memPtr);
LOCAL VOID LoadTByteToFP IPT2(FPSTACKENTRY *, FPPtr, VOID *, memPtr);
LOCAL VOID ConvertR80 IPT1(FPSTACKENTRY *, memPtr);
LOCAL VOID PostCheckOUP IPT0();
LOCAL VOID CalcTagword IPT1(FPSTACKENTRY *, FPPtr);
LOCAL VOID SignalStackUnderflow IPT1(FPSTACKENTRY *, StackPtr);
LOCAL VOID SignalSNaN IPT1(FPSTACKENTRY *, StackPtr);
LOCAL VOID SignalIndefinite IPT1(FPSTACKENTRY *, StackPtr);
LOCAL VOID SignalInvalid IPT0();
LOCAL VOID WriteIndefinite IPT1(FPSTACKENTRY *, StackPtr);
LOCAL VOID Test2NaN IPT3(IU16, destIndex, FPSTACKENTRY *, src1_addr, FPSTACKENTRY *, src2_addr);
LOCAL VOID GenericAdd IPT3(IU16, destIndex, IU16, src1Index, IU16, src2Index);
LOCAL VOID AddBCDByte IPT2(FPU_I64 *, total, IU8, byte_val);
LOCAL VOID ConvertBCD IPT1(FPSTACKENTRY *, bcdPtr);
LOCAL VOID GenericCompare IPT1(IU16, src2Index);
LOCAL VOID GenericDivide IPT3(IU16, destIndex, IU16, src1Index, IU16, src2Index);
LOCAL VOID OpFpuStoreFpuState IPT2(VOID *, memPtr, IU32, fsave_offset);
LOCAL VOID OpFpuRestoreFpuState IPT2(VOID *, memPtr, IU32, frstor_offset);
LOCAL VOID GenericMultiply IPT3(IU16, destIndex, IU16, src1Index, IU16, src2Index);
LOCAL VOID CheckOUPForIntel IPT0();
LOCAL VOID GenericSubtract IPT3(IU16, destIndex, IU16, src1Index, IU16, src2Index);
GLOBAL VOID F2XM1 IPT0();
GLOBAL VOID FABS IPT0();
GLOBAL VOID FADD IPT3(IU16, destIndex, IU16, src1Index, VOID *, src2);
GLOBAL VOID FBLD IPT1(IU8 *, memPtr);
GLOBAL VOID FBSTP IPT1(IU8 *, memPtr);
GLOBAL VOID FCHS IPT0();
GLOBAL VOID FCLEX IPT0();
GLOBAL VOID FCOM IPT1(VOID *, src2);
GLOBAL VOID FCOS IPT0();
GLOBAL VOID FDECSTP IPT0();
GLOBAL VOID FDIV IPT3(IU16, destIndex, IU16, src1Index, VOID *, src2);
GLOBAL VOID FFREE IPT1(IU16, destIndex);
GLOBAL VOID FLD IPT1(VOID *, memPtr);
GLOBAL VOID FINCSTP IPT0();
GLOBAL VOID FINIT IPT0();
GLOBAL VOID FIST IPT1(VOID *, memPtr);
GLOBAL VOID FLDCONST IPT1(IU8, const_index);
GLOBAL VOID FLDCW IPT1(VOID *, memPtr);
GLOBAL VOID FLDCW16 IPT1(VOID *, memPtr);
GLOBAL VOID FLDENV IPT1(VOID *, memPtr);
GLOBAL VOID FMUL IPT3(IU16, destIndex, IU16, src1Index, VOID *, src2);
GLOBAL VOID PTOP IPT0();
GLOBAL VOID FPATAN IPT0();
GLOBAL VOID FPREM IPT0();
GLOBAL VOID FPREM1 IPT0();
GLOBAL VOID FPTAN IPT0();
GLOBAL VOID FRNDINT IPT0();
GLOBAL VOID FSTCW IPT1(VOID *, memPtr);
GLOBAL VOID FRSTOR IPT1(VOID *, memPtr);
GLOBAL VOID FSAVE IPT1(VOID *, memPtr);
GLOBAL VOID FSCALE IPT0();
GLOBAL VOID FSIN IPT0();
GLOBAL VOID FSINCOS IPT0();
GLOBAL VOID FSQRT IPT0();
GLOBAL VOID FST IPT1(VOID *, memPtr);
GLOBAL VOID FSTENV IPT1(VOID *, memPtr);
GLOBAL VOID FSTSW IPT2(VOID *, memPtr, BOOL, toAX);
GLOBAL VOID FSUB IPT3(IU16, destIndex, IU16, src1Index, VOID *, src2);
GLOBAL VOID FTST IPT0();
GLOBAL VOID FXAM IPT0();
GLOBAL VOID FXCH IPT1(IU16, destIndex);
GLOBAL VOID FXTRACT IPT1(IU16, destIndex);
GLOBAL VOID FYL2X IPT0();
GLOBAL VOID FYL2XP1 IPT0();
GLOBAL IU32 getNpxControlReg IPT0();
GLOBAL VOID setNpxControlReg IPT1(IU32, newControl);
GLOBAL IU32 getNpxStatusReg IPT0();
GLOBAL VOID setNpxStatusReg IPT1(IU32, newStatus);
GLOBAL IU32 getNpxTagwordReg IPT0();
GLOBAL VOID setNpxTagwordReg IPT1(IU32, newTag);
GLOBAL void getNpxStackRegs IPT1(FPSTACKENTRY *, dumpPtr);
GLOBAL void setNpxStackRegs IPT1(FPSTACKENTRY *, loadPtr);

/* DEFINED values */
#ifndef NULL
#define NULL ((VOID *)0)
#endif
#define TAG_NEGATIVE_MASK 1
#define TAG_ZERO_MASK 2
#define TAG_INFINITY_MASK 4
#define TAG_DENORMAL_MASK 8
#define TAG_NAN_MASK 16
#define TAG_SNAN_MASK 32
#define TAG_UNSUPPORTED_MASK 64
#define TAG_EMPTY_MASK 128
#define TAG_FSCALE_MASK 256
#define TAG_BCD_MASK 512
#define TAG_R80_MASK 1024
#define UNEVALMASK 1536
#define FPTEMP_INDEX (IU16)-1
#define SW_IE_MASK 1
#define SW_DE_MASK 2
#define SW_ZE_MASK 4
#define SW_OE_MASK 8
#define SW_UE_MASK 16
#define SW_PE_MASK 32
#define SW_SF_MASK 64
#define SW_ES_MASK 128
#define C3C2C0MASK 0xb8ff
#define FCLEX_MASK 0x7f00
#define CW_IM_MASK 1
#define CW_DM_MASK 2
#define CW_ZM_MASK 4
#define CW_OM_MASK 8
#define CW_UM_MASK 16
#define CW_PM_MASK 32
#define COMP_LT 0
#define COMP_GT 1
#define COMP_EQ 2
#define INTEL_COMP_NC 0x4500
#define INTEL_COMP_GT 0x0000
#define INTEL_COMP_LT 0x0100
#define INTEL_COMP_EQ 0x4000
#define ROUND_NEAREST 0x0000
#define ROUND_NEG_INFINITY 0x0400
#define ROUND_POS_INFINITY 0x0800
#define ROUND_ZERO 0x0c00

/* MACROS */
#define FlagC0(x) 	NpxStatus &= 0xfeff;	\
			NpxStatus |= ((x) << 8)
#define FlagC1(x) 	NpxStatus &= 0xfdff;	\
			NpxStatus |= ((x) << 9)
#define FlagC2(x) 	NpxStatus &= 0xfbff;	\
			NpxStatus |= ((x) << 10)
#define FlagC3(x) 	NpxStatus &= 0xbfff;	\
			NpxStatus |= ((x) << 14)
#define TestUneval(testPtr)	\
	if (((testPtr)->tagvalue & UNEVALMASK) != 0) {	\
		switch ((testPtr)->tagvalue & UNEVALMASK) {	\
			case TAG_BCD_MASK:	ConvertBCD((testPtr));	\
						break;	\
			case TAG_R80_MASK:	ConvertR80((testPtr));	\
						break;	\
		}	\
	}

#define	StackEntryByIndex(i)	(i==FPTEMP_INDEX? &FPTemp : &FPUStackBase[(TOSPtr-FPUStackBase+i)%8])

/*
 * Pigging the FYL2X & FYL2XP1 opcodes requires that we use the same
 * maths functions as the assembler CPU to avoid pig errors due to slight
 * algorithmic differences; so allow host to specify different functions
 * if it wants - by default we only require log().
 */
#ifndef host_log2
#define	host_log2(x)		(log(x)/log(2.0))
#endif /* !host_log2 */

#ifndef host_log1p
#define	host_log1p(x)		(host_log2(1.0 + x))
#endif /* !host_log1p */

/*
 * System wide variables
 */
GLOBAL IU8 FPtype;
GLOBAL IU32 NpxLastSel;
GLOBAL IU32 NpxLastOff;
GLOBAL IU32 NpxFEA;
GLOBAL IU32 NpxFDS;
GLOBAL IU32 NpxFIP;
GLOBAL IU32 NpxFOP;
GLOBAL IU32 NpxFCS;
GLOBAL BOOL POPST;
GLOBAL BOOL DOUBLEPOP;
GLOBAL BOOL UNORDERED;
GLOBAL BOOL REVERSE;
GLOBAL BOOL NPX_ADDRESS_SIZE_32;
GLOBAL BOOL NPX_PROT_MODE;
GLOBAL BOOL NpxException;

/*
 * FPU-wide variables
*/

#ifdef SUN4
LOCAL IU8 *FPout; /* HostGet*Exception() macros need this for Sparc ports. */
#endif /* SUN4 */

LOCAL IU32 NpxControl;
LOCAL IU32 NpxStatus;
LOCAL BOOL DoAPop;
LOCAL IU16 tag_or;
LOCAL IU16 tag_xor;
LOCAL FPSTACKENTRY IntelSpecial;
LOCAL FPSTACKENTRY *FPUpload = &IntelSpecial;
LOCAL FPSTACKENTRY FPTemp;
LOCAL FPSTACKENTRY *FPUStackBase;
LOCAL FPSTACKENTRY *TOSPtr;
LOCAL IU16 npxRounding;
LOCAL FPH FPRes;
LOCAL FPH MaxBCDValue=999999999999999999.0;

LOCAL IU8 zero_string[] = {"zero"};
LOCAL IU8 minus_zero_string[] = {"minus zero"};
LOCAL IU8 infinity_string[] = {"infinity"};
LOCAL IU8 minus_infinity_string[] = {"minus infinity"};
LOCAL IU8 nan_string[] = {" NaN"};
LOCAL IU8 minus_nan_string[] = {" Negative NaN"};
LOCAL IU8 unsupported_string[] = {"unsupported"};
LOCAL IU8 unevaluated_string[] = {"unevaluated"};
LOCAL IU8 empty_string[] = {"empty"};
LOCAL IU8 convert_string[100];

LOCAL IU16 FscaleTable[] = {
0,
0,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_INFINITY_MASK,
TAG_ZERO_MASK,
0,
0,
0,
0,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_INFINITY_MASK | TAG_NEGATIVE_MASK,
TAG_ZERO_MASK | TAG_NEGATIVE_MASK,
0,
0,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK | TAG_UNSUPPORTED_MASK,
TAG_FSCALE_MASK,
0,
0,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK | TAG_UNSUPPORTED_MASK,
TAG_ZERO_MASK | TAG_NEGATIVE_MASK,
0,
0,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_INFINITY_MASK,
TAG_FSCALE_MASK | TAG_UNSUPPORTED_MASK,
0,
0,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK,
TAG_FSCALE_MASK | TAG_UNSUPPORTED_MASK,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0};

LOCAL FPSTACKENTRY ConstTable[]= {
{1.0, 0, 0},		/* 1.0 */
{M_LN10/M_LN2, 0, 0},	/* Log2(10) */
{M_LOG2E, 0, 0},		/* Log2(e) */
{M_PI, 0, 0},		/* pi */
{M_LN2/M_LN10, 0, 0},	/* Log10(2) */
{M_LN2, 0, 0},		/* Loge(2) */
{0.0, 0, TAG_ZERO_MASK}	/* 0.0 */
};

LOCAL FPSTACKENTRY FPConstants[] = {
{0.0, 0, TAG_ZERO_MASK},
{-0.0, 0, (TAG_ZERO_MASK | TAG_NEGATIVE_MASK)},
{1.0, 0, 0},
{2.0, 0, 0},
{M_PI, 0, 0},
{-M_PI, 0, TAG_NEGATIVE_MASK},
{M_PI_2, 0, 0},
{-(M_PI_2), 0, TAG_NEGATIVE_MASK},
{M_PI_4, 0, 0},
{-(M_PI_4), 0, TAG_NEGATIVE_MASK},
{3.0*M_PI_4, 0, 0},
{-(3.0*M_PI_4), 0, TAG_NEGATIVE_MASK}
};

LOCAL FPSTACKENTRY *npx_zero = FPConstants + 0;
LOCAL FPSTACKENTRY *npx_minus_zero = FPConstants + 1;
LOCAL FPSTACKENTRY *npx_one = FPConstants + 2;
LOCAL FPSTACKENTRY *npx_two = FPConstants + 3;
LOCAL FPSTACKENTRY *npx_pi = FPConstants + 4;
LOCAL FPSTACKENTRY *npx_minus_pi = FPConstants + 5;
LOCAL FPSTACKENTRY *npx_pi_by_two = FPConstants + 6;
LOCAL FPSTACKENTRY *npx_minus_pi_by_two = FPConstants + 7;
LOCAL FPSTACKENTRY *npx_pi_by_four = FPConstants + 8;
LOCAL FPSTACKENTRY *npx_minus_pi_by_four = FPConstants + 9;
LOCAL FPSTACKENTRY *npx_three_pi_by_four = FPConstants + 10;
LOCAL FPSTACKENTRY *npx_minus_three_pi_by_four = FPConstants + 11;

LOCAL IU32 CompZeroTable[] = {
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_GT,
INTEL_COMP_GT,
INTEL_COMP_LT,
INTEL_COMP_GT,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_LT,
INTEL_COMP_LT,
INTEL_COMP_LT,
INTEL_COMP_GT,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_LT,	/* 16 */
INTEL_COMP_GT,
INTEL_COMP_EQ,
INTEL_COMP_EQ,
INTEL_COMP_LT,
INTEL_COMP_GT,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_LT,
INTEL_COMP_GT,
INTEL_COMP_EQ,
INTEL_COMP_EQ,
INTEL_COMP_LT,
INTEL_COMP_GT,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_GT,	/* 32 */
INTEL_COMP_GT,
INTEL_COMP_GT,
INTEL_COMP_GT,
INTEL_COMP_EQ,
INTEL_COMP_GT,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_LT,
INTEL_COMP_LT,
INTEL_COMP_LT,
INTEL_COMP_LT,
INTEL_COMP_LT,
INTEL_COMP_EQ,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,	/* 48 */
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC,
INTEL_COMP_NC
};

#ifdef BIGEND
/* Note enforcement of word ordering as high word/low word */
LOCAL FPU_I64 BCDLowNibble[] = {
{0x002386f2, 0x6fc10000},
{0x00005af3, 0x107a4000},
{0x000000e8, 0xd4a51000},
{0x00000002, 0x540be400},
{0x00000000, 0x05f5e100},
{0x00000000, 0x000f4240},
{0x00000000, 0x00002710},
{0x00000000, 0x00000064},
{0x00000000, 0x00000001}
};

LOCAL FPU_I64 BCDHighNibble[] = {
{0x01634578, 0x5d8a0000},
{0x00038d7e, 0xa4c68000},
{0x00000918, 0x4e72a000},
{0x00000017, 0x4876e800},
{0x00000000, 0x3b9aca00},
{0x00000000, 0x00989680},
{0x00000000, 0x000186a0},
{0x00000000, 0x000003e8},
{0x00000000, 0x0000000a}
};
#else	/* !BIGEND */
LOCAL FPU_I64 BCDLowNibble[] = {
{0x6fc10000, 0x002386f2},
{0x107a4000, 0x00005af3},
{0xd4a51000, 0x000000e8},
{0x540be400, 0x00000002},
{0x05f5e100, 0x00000000},
{0x000f4240, 0x00000000},
{0x00002710, 0x00000000},
{0x00000064, 0x00000000},
{0x00000001, 0x00000000}
};

LOCAL FPU_I64 BCDHighNibble[] = {
{0x5d8a0000, 0x01634578},
{0xa4c68000, 0x00038d7e},
{0x4e72a000, 0x00000918},
{0x4876e800, 0x00000017},
{0x3b9aca00, 0x00000000},
{0x00989680, 0x00000000},
{0x000186a0, 0x00000000},
{0x000003e8, 0x00000000},
{0x0000000a, 0x00000000}
};
#endif	/* !BIGEND */


LOCAL FPSTACKENTRY *FpatanTable[64];

LOCAL IBOOL NpxDisabled = FALSE; /* Set by the UIF */

/* Imported functions */
IMPORT VOID DoNpxException();


LOCAL FPH npx_rint IFN1(FPH, fpval)
{
	FPH localfp;

	switch (NpxControl & ROUND_ZERO) {
		case ROUND_NEAREST	:
			localfp = fpval - floor(fpval);
			if (localfp > 0.5) {
				localfp = ceil(fpval);
			} else {
				if (localfp < 0.5) {
					localfp = floor(fpval);
				} else {
					if ((fpval-localfp)/2.0 != floor((fpval-localfp)/2.0)) {
						localfp = ceil(fpval);
					} else {
						localfp = floor(fpval);
					}
				}
			}
			break;
		case ROUND_NEG_INFINITY	:
			localfp = floor(fpval);
			/* help the poor HP over this hurdle... */
			if ( fpval >= localfp + 1.0 )
				localfp += 1.0;
			break;
		case ROUND_POS_INFINITY	:
			localfp = ceil(fpval);
			/* help the poor HP over this hurdle... */
			if ( fpval <= localfp - 1.0 )
				localfp -= 1.0;
			break;
		case ROUND_ZERO	:
			if (fpval < 0.0) {
				localfp = ceil(fpval);
			} else {
				localfp = floor(fpval);
			}
			break;
	}
	/* Check sign of zero */
	if (localfp == 0.0) {
		if (fpval < 0.0) {
			((FPHOST *)&(localfp))->hiword.sign = 1;
		} else {
			((FPHOST *)&(localfp))->hiword.sign = 0;
		}
	}
	return(localfp);
}


LOCAL VOID GetIntelStatusWord IFN0()
{
	/* The status word already contains the correct 'sticky' bits */
	/* for any potential exceptions. What need to be filled in are */
	/* the flag bits and the ST value */
	NpxStatus &= 0xc7ff;	/* Clear the st bits */
	NpxStatus |= ((TOSPtr-FPUStackBase) << 11);
}


LOCAL VOID SetIntelTagword IFN1(IU32, new_tag)
{
	FPSTACKENTRY *tagPtr = FPUStackBase;
	IU8 counter = 0;

	/* We only consider whether the thing is marked as empty or not.
	If it is anything other than empty we will want to precisely calculate
	it by using CalcTagword() */
	while (counter++ < 8) {
		if ((new_tag & 3) == 3) {
			/* It's empty */
			tagPtr->tagvalue = TAG_EMPTY_MASK;
		} else {
			tagPtr->tagvalue = 0;
		}
		new_tag >>= 2;
		tagPtr++;
	}
}


/* Reads and writes for 16 and 32 bit integers are easy as they are handled
correctly in order to satisfy the integer CPU */
/* This function is only called from fldenv/frstor where 16-bit data has to
be extracted from a large (bigendian organised) buffer */
LOCAL VOID ReadI16FromIntel IFN2(IU32 *, valI16, VOID *, memPtr)
{
	IU32 res;

	res = *((IU8 *)memPtr + 0);
	res <<= 8;
	res |= *((IU8 *)memPtr + 1);
	*valI16 = res;
}


/* This function is only called from fldwnv/frstor where 32-bit data has to
be extrated from a large (bigendian organised) buffer */
LOCAL VOID ReadI32FromIntel IFN2(IU32 *, valI32, VOID *, memPtr)
{
	IU32 res;

	res = *((IU8 *)memPtr + 0);
	res <<= 8;
	res |= *((IU8 *)memPtr + 1);
	res <<= 8;
	res |= *((IU8 *)memPtr + 2);
	res <<= 8;
	res |= *((IU8 *)memPtr + 3);
	*valI32 = res;
}

/* This function is only used in fsave/fstenv */
LOCAL VOID WriteI16ToIntel IFN2(VOID *, memPtr, IU16, valI16)
{
	*((IU8 *)memPtr + 1) = (IU8)(valI16 & 0xff);
	valI16 >>= 8;
	*((IU8 *)memPtr + 0) = (IU8)(valI16 & 0xff);
}


/* And so is this one */
LOCAL VOID WriteI32ToIntel IFN2(VOID *, memPtr, IU32, valI32)
{
	*((IU8 *)memPtr + 3) = (IU8)(valI32 & 0xff);
	valI32 >>= 8;
	*((IU8 *)memPtr + 2) = (IU8)(valI32 & 0xff);
	valI32 >>= 8;
	*((IU8 *)memPtr + 1) = (IU8)(valI32 & 0xff);
	valI32 >>= 8;
	*((IU8 *)memPtr + 0) = (IU8)(valI32 & 0xff);
}


/* Anything over 32-bits becomes painful as data is read and written using
the vir_read_bytes and vir_write_bytes routines respectively, which simply
dump data from the topmost intel address to the lowest intel address. The
value of the offsets is defined one way round for bigendian ports and the
other way for little-endian */
LOCAL VOID WriteNaNToIntel IFN2(VOID *, memPtr, FPSTACKENTRY *, valPtr)
{
	IU32 mant_hi;
	IU32 mant_lo;

	/* Ok for endian-ness as we FORCE this presentation */
	mant_hi = ((IU32 *)&(valPtr->fpvalue))[NPX_HIGH_32_BITS];
	mant_lo = ((IU32 *)&(valPtr->fpvalue))[NPX_LOW_32_BITS];
	if (FPtype == M32R) {
		/* OK since this forces the output to be independent of
		endian-ness. */
		mant_hi |= 0x40000000;	/* Make it quiet */
		mant_hi >>= 8;
		if ((valPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			mant_hi |= 0xff000000;
		} else {
			mant_hi |= 0x7f000000;
		}
		*(IU32 *)memPtr = mant_hi;
	}
	if (FPtype == M64R) {
		mant_hi |= 0x40000000;	/* Make it quiet */
		if ((valPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			*((IU8 *)memPtr + 0) = 0xff;
		} else {
			*((IU8 *)memPtr + 0) = 0x7f;
		}
		mant_lo >>= 3;
		mant_lo |= (mant_hi << 29);
		mant_hi >>= 3;
		mant_hi |= 0xe0000000;
		mant_lo >>= 8;
		*((IU8 *)memPtr + 7) = (mant_lo & 0xff);
		mant_lo >>= 8;
		*((IU8 *)memPtr + 6) = (mant_lo & 0xff);
		mant_lo >>= 8;
		*((IU8 *)memPtr + 5) = (mant_lo & 0xff);
		*((IU8 *)memPtr + 4) = (mant_hi & 0xff);
		mant_hi >>= 8;
		*((IU8 *)memPtr + 3) = (mant_hi & 0xff);
		mant_hi >>= 8;
		*((IU8 *)memPtr + 2) = (mant_hi & 0xff);
		mant_hi >>= 8;
		*((IU8 *)memPtr + 1) = (mant_hi & 0xff);
	}
	if (FPtype == M80R) {
		if ((valPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			*((IU8 *)memPtr + 0) = 0xff;
		} else {
			*((IU8 *)memPtr + 0) = 0x7f;
		}
		*((IU8 *)memPtr + 1) = 0xff;
		*((IU8 *)memPtr + 9) = (mant_lo & 0xff);
		mant_lo >>= 8;
		*((IU8 *)memPtr + 8) = (mant_lo & 0xff);
		mant_lo >>= 8;
		*((IU8 *)memPtr + 7) = (mant_lo & 0xff);
		mant_lo >>= 8;
		*((IU8 *)memPtr + 6) = (mant_lo & 0xff);
		*((IU8 *)memPtr + 5) = (mant_hi & 0xff);
		mant_hi >>= 8;
		*((IU8 *)memPtr + 4) = (mant_hi & 0xff);
		mant_hi >>= 8;
		*((IU8 *)memPtr + 3) = (mant_hi & 0xff);
		mant_hi >>= 8;
		*((IU8 *)memPtr + 2) = (mant_hi & 0xff);
	}
}


LOCAL VOID WriteZeroToIntel IFN2(VOID *, memPtr, IU16, negZero)
{
	if (FPtype == M32R) {
		if (negZero == 0) {
			*(IU32 *)memPtr = 0x00000000;
		} else {
			*(IU32 *)memPtr = 0x80000000;
		}
	} else {
		if (FPtype == M80R) {
			if (negZero == 0) {
				*((IU8 *)memPtr + 0) = 0;
			} else {
				*((IU8 *)memPtr + 0) = 0x80;
			}
			*((IU8 *)memPtr + 1) = 0;
			*((IU8 *)memPtr + 2) = 0;
			*((IU8 *)memPtr + 3) = 0;
			*((IU8 *)memPtr + 4) = 0;
			*((IU8 *)memPtr + 5) = 0;
			*((IU8 *)memPtr + 6) = 0;
			*((IU8 *)memPtr + 7) = 0;
			*((IU8 *)memPtr + 8) = 0;
			*((IU8 *)memPtr + 9) = 0;
		} else {
			if (negZero == 0) {
				*((IU8 *)memPtr + 0) = 0;
			} else {
				*((IU8 *)memPtr + 0) = 0x80;
			}
			*((IU8 *)memPtr + 1) = 0;
			*((IU8 *)memPtr + 2) = 0;
			*((IU8 *)memPtr + 3) = 0;
			*((IU8 *)memPtr + 4) = 0;
			*((IU8 *)memPtr + 5) = 0;
			*((IU8 *)memPtr + 6) = 0;
			*((IU8 *)memPtr + 7) = 0;
		}
	}
}


LOCAL VOID SetIntelStatusWord IFN1(IU32, new_stat)
{
	TOSPtr = &FPUStackBase[(new_stat >> 11) & 0x7];
	NpxStatus = new_stat;
}


LOCAL VOID AdjustOverflowResponse IFN0()
{
}


LOCAL VOID AdjustUnderflowResponse IFN0()
{
}


LOCAL VOID WriteIndefiniteToIntel IFN1(VOID *, memPtr)
{
	switch (FPtype) {
		case M32R	: *(IU32 *)memPtr = 0xffc00000;
			  	  break;
		case M64R 	: *((IU8 *)memPtr + 0) = 0xff;
				  *((IU8 *)memPtr + 1) = 0xf8;
				  *((IU8 *)memPtr + 2) = 0;
				  *((IU8 *)memPtr + 3) = 0;
				  *((IU8 *)memPtr + 4) = 0;
				  *((IU8 *)memPtr + 5) = 0;
				  *((IU8 *)memPtr + 6) = 0;
				  *((IU8 *)memPtr + 7) = 0;
			  	  break;
		case M80R	: *((IU8 *)memPtr + 0) = 0xff;
				  *((IU8 *)memPtr + 1) = 0xff;
				  *((IU8 *)memPtr + 2) = 0xc0;
				  *((IU8 *)memPtr + 3) = 0;
				  *((IU8 *)memPtr + 4) = 0;
				  *((IU8 *)memPtr + 5) = 0;
				  *((IU8 *)memPtr + 6) = 0;
				  *((IU8 *)memPtr + 7) = 0;
				  *((IU8 *)memPtr + 8) = 0;
				  *((IU8 *)memPtr + 9) = 0;
				  break;
	}
}


LOCAL VOID SignalDivideByZero IFN1(FPSTACKENTRY *, stackPtr)
{
	/* Raise divide by zero */
	NpxStatus |= SW_ZE_MASK;
	if ((NpxControl & CW_ZM_MASK) == 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
	}
	stackPtr->tagvalue = TAG_INFINITY_MASK + (tag_xor & TAG_NEGATIVE_MASK);
}

LOCAL VOID SetPrecisionBit IFN0()
{
	NpxStatus |= SW_PE_MASK;
	if (npxRounding == ROUND_POS_INFINITY) {
		FlagC1(1);
	} else {
		FlagC1(0);
	}
}

LOCAL VOID GetIntelTagword IFN1(IU32 *, current_tag)
{
	FPSTACKENTRY *tagPtr = &FPUStackBase[7];
	IU8 counter = 0;

	*current_tag = 0;
	while (counter++ < 8) {
		TestUneval(tagPtr);
		*current_tag <<= 2;
		if ((tagPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			*current_tag |= 3;
		} else {
			if ((tagPtr->tagvalue & TAG_ZERO_MASK) != 0) {
				*current_tag |= 1;
			} else {
				if ((tagPtr->tagvalue & ~TAG_NEGATIVE_MASK) != 0) {
					*current_tag |= 2;
				}
			}
		}
		tagPtr--;
	}
}


/* These functions write host format quantities out to the (bigendian
organised) intel memory. This requires that we define an ordering between the
two. The values in HOST_xxx are dependent upon the endian-ness of the port */
/* According to this organisation, HOST_nnn_BYTE_0 is the offset to the most
significant byte in the representation of this format, and so on. */
LOCAL VOID WriteFP32ToIntel IFN2(VOID *, destPtr, FPSTACKENTRY *, srcPtr)
{
	*(IU32 *)destPtr = *(IU32 *)srcPtr;
}


LOCAL VOID WriteFP64ToIntel IFN2(VOID *, destPtr, FPSTACKENTRY *, srcPtr)
{
	*((IU8 *)destPtr + 0) = *((IU8 *)srcPtr + HOST_R64_BYTE_0);
	*((IU8 *)destPtr + 1) = *((IU8 *)srcPtr + HOST_R64_BYTE_1);
	*((IU8 *)destPtr + 2) = *((IU8 *)srcPtr + HOST_R64_BYTE_2);
	*((IU8 *)destPtr + 3) = *((IU8 *)srcPtr + HOST_R64_BYTE_3);
	*((IU8 *)destPtr + 4) = *((IU8 *)srcPtr + HOST_R64_BYTE_4);
	*((IU8 *)destPtr + 5) = *((IU8 *)srcPtr + HOST_R64_BYTE_5);
	*((IU8 *)destPtr + 6) = *((IU8 *)srcPtr + HOST_R64_BYTE_6);
	*((IU8 *)destPtr + 7) = *((IU8 *)srcPtr + HOST_R64_BYTE_7);
}


LOCAL VOID WriteFP80ToIntel IFN2(VOID *, destPtr, FPSTACKENTRY *, srcPtr)
{
	*((IU8 *)destPtr + 0) = *((IU8 *)srcPtr + HOST_R80_BYTE_0);
	*((IU8 *)destPtr + 1) = *((IU8 *)srcPtr + HOST_R80_BYTE_1);
	*((IU8 *)destPtr + 2) = *((IU8 *)srcPtr + HOST_R80_BYTE_2);
	*((IU8 *)destPtr + 3) = *((IU8 *)srcPtr + HOST_R80_BYTE_3);
	*((IU8 *)destPtr + 4) = *((IU8 *)srcPtr + HOST_R80_BYTE_4);
	*((IU8 *)destPtr + 5) = *((IU8 *)srcPtr + HOST_R80_BYTE_5);
	*((IU8 *)destPtr + 6) = *((IU8 *)srcPtr + HOST_R80_BYTE_6);
	*((IU8 *)destPtr + 7) = *((IU8 *)srcPtr + HOST_R80_BYTE_7);
	*((IU8 *)destPtr + 8) = *((IU8 *)srcPtr + HOST_R80_BYTE_8);
	*((IU8 *)destPtr + 9) = *((IU8 *)srcPtr + HOST_R80_BYTE_9);
}


LOCAL VOID Mul64Bit8Bit IFN2(FPU_I64 *, as64, IU8, mul_count)
{
	CVTI64FPH(as64);
	FPRes *= (FPH)mul_count;
	CVTFPHI64(as64, &FPRes);
}


LOCAL VOID CopyFP IFN2(FPSTACKENTRY *, dest_addr, FPSTACKENTRY *, src_addr)
{
	(VOID)memcpy((VOID *)dest_addr, (VOID *)src_addr, sizeof(FPSTACKENTRY));
}


LOCAL VOID MakeNaNQuiet IFN1(FPSTACKENTRY *, srcPtr)
{
	NpxStatus |= SW_IE_MASK;
	NpxStatus &= ~SW_SF_MASK;
	if ((NpxControl & CW_IM_MASK) == 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
		DoAPop=FALSE;
	} else {
		srcPtr->tagvalue ^= TAG_SNAN_MASK;
		((IU32 *)&(srcPtr->fpvalue))[NPX_HIGH_32_BITS] |= 0x40000000;
	}
}


LOCAL VOID WriteBiggestNaN IFN3(IU16, destInd, FPSTACKENTRY *, val1Ptr, FPSTACKENTRY *, val2Ptr)
{
	FPSTACKENTRY *destPtr = StackEntryByIndex(destInd);

	/* We explicitely and deliberately store NaNs as two 32-bit values high word then low word */
	if (((IU32 *)&(val1Ptr->fpvalue))[NPX_HIGH_32_BITS] == ((IU32 *)&(val2Ptr->fpvalue))[NPX_HIGH_32_BITS]) {
		if (((IU32 *)&(val1Ptr->fpvalue))[NPX_LOW_32_BITS] >= ((IU32 *)&(val2Ptr->fpvalue))[NPX_LOW_32_BITS]) {
			/* It's val1 */
			CopyFP(destPtr, val1Ptr);
		} else {
			CopyFP(destPtr, val2Ptr);
		}
	} else {
		if (((IU32 *)&(val1Ptr->fpvalue))[NPX_HIGH_32_BITS] > ((IU32 *)&(val2Ptr->fpvalue))[NPX_HIGH_32_BITS]) {
			/* It's val1 */
			CopyFP(destPtr, val1Ptr);
		} else {
			CopyFP(destPtr, val2Ptr);
		}
	}
	/* Always make it a quiet NaN */
	((IU32 *)&(destPtr->fpvalue))[NPX_HIGH_32_BITS] |= 0x40000000;
	destPtr->tagvalue &= ~TAG_SNAN_MASK;
}


LOCAL VOID Sub64Bit64Bit IFN2(FPU_I64 *, as64a, FPU_I64 *, as64b)
{
	FPH FPlocal;

	CVTI64FPH(as64b);
	FPlocal = FPRes;
	CVTI64FPH(as64a);
	FPRes -= FPlocal;
	CVTFPHI64(as64a, &FPRes);
}


LOCAL VOID CVTR80FPH IFN2(FPSTACKENTRY *, destPtr, FPSTACKENTRY *, srcPtr)
{
	IU32 munger;
	IU16 bitleft;

	/* First, copy the sign bit */
	((FPHOST *)&(destPtr->fpvalue))->hiword.sign = ((FP80 *)&(srcPtr->fpvalue))->sign_exp.sign;
	/* Then, copy the modified exponent */
	munger = (IU32)((FP80 *)&(srcPtr->fpvalue))->sign_exp.exp;
	munger -= (16383 - HOST_BIAS);
	((FPHOST *)&(destPtr->fpvalue))->hiword.exp = munger;
	/* Finally, the mantissa */
	munger = (IU32)((FP80 *)&(srcPtr->fpvalue))->mant_hi;
	munger <<= 1;
	((FPHOST *)&(destPtr->fpvalue))->hiword.mant_hi = (munger >> 12);
	munger <<= 20;
	munger |= ((FP80 *)&(srcPtr->fpvalue))->mant_lo >> 11;
	bitleft = ((FP80 *)&(srcPtr->fpvalue))->mant_lo & 0x7ff;

	if (bitleft != 0) {
		switch (NpxControl & ROUND_ZERO) {
		case ROUND_NEAREST	:
			if (bitleft > 0x3ff) {
				munger += 1;
			}
			break;
		case ROUND_NEG_INFINITY	:
			if (((FPHOST *)&(destPtr->fpvalue))->hiword.sign = 1) {
				munger += 1;
			}
			break;
		case ROUND_POS_INFINITY	:
			if (((FPHOST *)&(destPtr->fpvalue))->hiword.sign = 0) {
				munger += 1;
			}
			break;
		case ROUND_ZERO	:
			/* Do nothing */
			break;
		}
	}
	((FPHOST *)&(destPtr->fpvalue))->mant_lo = munger;
}


LOCAL BOOL Cmp64BitGTE IFN2(FPU_I64 *, as64a, FPU_I64 *, as64b)
{
	FPH FPlocal;

	CVTI64FPH(as64b);
	FPlocal = FPRes;
	CVTI64FPH(as64a);
	return(FPRes >= FPlocal);
}


LOCAL VOID CopyR32 IFN2(FPSTACKENTRY *, destPtr, VOID *, srcPtr)
{
	*(IU32 *)destPtr = *(IU32 *)srcPtr;
}


LOCAL VOID CVTI64FPH IFN1(FPU_I64 *, as64)
{
	FPRes = (FPH)as64->high_word * 4294967296.0 + (FPH)as64->low_word;
}


LOCAL VOID CVTFPHI64 IFN2(FPU_I64 *, as64, FPH *, FPPtr)
{
	IU32    high32 = 0;
	IU32	low32 = 0;
	IS32	exp;
	IU32	holder;
	IU32	signbit = 0;

	exp = ((FPHOST *)FPPtr)->hiword.exp;
	if (exp != 0) {
		high32 = ((FPHOST *)FPPtr)->hiword.mant_hi;
		low32 = ((FPHOST *)FPPtr)->mant_lo;
		/* Now stick a 1 at the top of the mantissa */
		/* Calculate where this is */
		holder = HOST_MAX_EXP+1;
		signbit = 1;
		while (holder >>= 1) {
			signbit += 1;
		}
		high32 |= (1 << (32-signbit));
		exp -= HOST_BIAS;
		exp -= (64-signbit);

		signbit = ((FPHOST *)FPPtr)->hiword.sign;

		/* high32 and low32 are (mantissa)*(2^52 )
		 * exp is (true exponent-52) = number of bit positions to shift
		 *   +ve implies shift left, -ve implies shift right
		*/
		if (exp > 0) {
			if (exp >= 32) {
				high32 = low32 << ( exp - 32 ) ;
				low32 = 0;
			} else {
				high32 = high32 << exp ;
				holder = low32 >> ( 32 -exp ) ;
				high32 = high32 | holder ;
				low32  = low32 << exp ;
			}
		} else {
			if ( exp < 0) {
				exp = -exp;
				if ( exp >= 32 ) {
					low32 = high32 >>  ( exp - 32 ) ;
					high32 = 0 ;
				} else {
					low32  = low32 >>  exp ;
					holder = high32 <<  ( 32 -exp ) ;
					low32  = low32 | holder ;
					high32 = high32 >>  exp ;
				}
			}
		}
	}
	if (signbit != 0) {
		/* Make it negative */
		high32 ^= 0xffffffff;
		low32 ^= 0xffffffff;
		low32 += 1;
		if (low32 == 0) {
			high32 += 1;
		}
	}
	as64->high_word = high32;
	as64->low_word = low32;
}


LOCAL VOID Add64Bit8Bit IFN2(FPU_I64 *, as64, IU8, small_val)
{
	CVTI64FPH(as64);
	FPRes += (FPH)small_val;
	CVTFPHI64(as64, &FPRes);
}


LOCAL VOID CopyR64 IFN2(FPSTACKENTRY *, destPtr, VOID *, srcPtr)
{
	*((IU8 *)destPtr + HOST_R64_BYTE_0) = *((IU8 *)srcPtr + 0);
	*((IU8 *)destPtr + HOST_R64_BYTE_1) = *((IU8 *)srcPtr + 1);
	*((IU8 *)destPtr + HOST_R64_BYTE_2) = *((IU8 *)srcPtr + 2);
	*((IU8 *)destPtr + HOST_R64_BYTE_3) = *((IU8 *)srcPtr + 3);
	*((IU8 *)destPtr + HOST_R64_BYTE_4) = *((IU8 *)srcPtr + 4);
	*((IU8 *)destPtr + HOST_R64_BYTE_5) = *((IU8 *)srcPtr + 5);
	*((IU8 *)destPtr + HOST_R64_BYTE_6) = *((IU8 *)srcPtr + 6);
	*((IU8 *)destPtr + HOST_R64_BYTE_7) = *((IU8 *)srcPtr + 7);
}

/*
 * CopyR80 is different from the above as it is called to copy
 * between FPSTACKENTRYs. Copy straight through.
 */
LOCAL VOID CopyR80 IFN2(FPSTACKENTRY *, destPtr, VOID *, srcPtr)
{
	*(FP80 *)destPtr = *(FP80 *)srcPtr;
}


LOCAL VOID CVTFPHR80 IFN1(FPSTACKENTRY *, memPtr)
{
	IU32 munger;

	/* First, copy the sign bit */
	((FP80 *)&(FPTemp.fpvalue))->sign_exp.sign = ((FPHOST *)&(memPtr->fpvalue))->hiword.sign;
	/* Then, copy the modified exponent */
	munger = (IU32)((FPHOST *)&(memPtr->fpvalue))->hiword.exp;
	munger += (16383 - HOST_BIAS);
	((FP80 *)&(FPTemp.fpvalue))->sign_exp.exp = munger;
	/* Finally, the mantissa */
	m