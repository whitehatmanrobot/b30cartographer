g to
;   resolve that particular misbehavior.  We will enforce correct behaviour in
;   FCBs when they refer to a network file or when there is file sharing on
;   the local machine.
;
;   The reserved fields of the FCB (10 bytes worth) is divided up into various
;   structures depending on the file itself and the state of operations of the
;   OS.  The information contained in this reserved field is enough to
;   regenerate the SFT for the local non-shared file.  It is assumed that this
;   regeneration procedure may be expensive.  The SFT for the FCB is
;   maintained in a LRU cache as the ONLY performance inprovement.
;
;   No regeneration of SFTs is attempted for network FCBs.
;
;   To regenerate the SFT for a local FCB, it is necessary to determine if the
;   file sharer is working.  If the file sharer is present then the SFT is not
;   regenerated.
;
;   Finally, if there is no local sharing, the full name of the file is no
;   longer available.  We can make up for this by using the following
;   information:
;
;	The Drive number (from the DPB).
;	The physical sector of the directory that contains the entry.
;	The relative position of the entry in the sector.
;	The first cluster field.
;	The last used SFT.
;      OR In the case of a device FCB
;	The low 6 bits of sf_flags (indicating device type)
;	The pointer to the device header
;
;
;   We read in the particular directory sector and examine the indicated
;   directory entry.  If it matches, then we are kosher; otherwise, we fail.
;
;   Some key items need to be remembered:
;
;	Even though we are caching SFTs, they may contain useful sharing
;	information.  We enforce good behavior on the FCBs.
;
;	Network support must not treat FCBs as impacting the ref counts on
;	open VCs.  The VCs may be closed only at process termination.
;
;	If this is not an installed version of the DOS, file sharing will
;	always be present.
;
;	We MUST always initialize lstclus to = firclus when regenerating a
;	file. Otherwise we start allocating clusters up the wazoo.
;
;	Always initialize, during regeneration, the mode field to both isFCB
;	and open_for_both.  This is so the FCB code in the sharer can find the
;	proper OI record.
;
;   The test bits are:
;
;	00 -> local file
;	40 -> sharing local
;	80 -> network
;	C0 -> local device

Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
;
;----------------------------------------------------------------------------
;
;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
;	pieces of information into the FCB.
;
;   Inputs:	ThisSFT points to a complete SFT.
;		DS:SI point to the FCB (not an extended one)
;   Outputs:	The relevant reserved fields in the FCB are filled in.
;		DS:SI preserved
;		ES:DI point to sft
;   Registers modified: All
;
;
;----------------------------------------------------------------------------
;
Procedure   SaveFCBInfo,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	LES	DI,ThisSFT		; SS override

	Assert	ISSFT,<ES,DI>,"SaveFCBInfo"

	LEA	AX,[DI-SFTable] 	; Adjust for offset to table.
	SUB	AX,WORD PTR SftFCB	; SS override for SftFCB

	MOV	BL,SIZE sf_entry
	DIV	BL
	MOV	[SI].FCB_sfn,AL 	; last used SFN

	call	UpdateLRU
	return

EndProc SaveFCBInfo

Procedure UpdateLRU,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	LES	DI,ThisSFT		; SS override
	PUSH    Proc_ID                 ; set process id
	POP     ES:[DI].sf_PID
	MOV	AX,FCBLRU		; get lru count
	INC	AX
	MOV	WORD PTR ES:[DI].sf_LRU,AX
	JNZ	SimpleStuff
	;
	; lru flag overflowed.	Run through all FCB sfts and adjust:  
	; LRU < 8000H get set to 0.  Others -= 8000h.  This LRU = 8000h
	;
	MOV	BX,sf_position
	call	ResetLRU

	;	Set new LRU to AX

SimpleStuff:
	MOV	FCBLRU,AX
	return

EndProc UpdateLRU


Break	<ResetLRU - reset overflowed lru counts>

;
;----------------------------------------------------------------------------
;
;   ResetLRU - during lru updates, we may wrap at 64K.	We must walk the
;   entire set of SFTs and subtract 8000h from their lru counts and truncate
;   at 0.
;
;   Inputs:	BX is offset into SFT field where lru firld is kept
;		ES:DI point to SFT currently being updated
;   Outputs:	All FCB SFTs have their lru fields truncated
;		AX has 8000h
;   Registers modified: none
;
;----------------------------------------------------------------------------
;

Procedure   ResetLRU,NEAR

	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
	; DOSDATA

	ASSUME CS:DOSCODE

	DOSAssume <SS>, "ResetLRU"

	Assert	ISSFT,<ES,DI>,"ResetLRU"
	MOV	AX,8000h
	SAVE	<ES,DI>
	LES	DI,sftFCB		; get pointer to head
	MOV	CX,ES:[DI].sfCount
	LEA	DI,[DI].sfTable 	; point at table
ovScan:
	SUB	WORD PTR ES:[DI+BX],AX	; decrement lru count
	JA	ovLoop
	MOV	WORD PTR ES:[DI.BX],AX	; truncate at 0
ovLoop:
	ADD	DI,SIZE SF_Entry	; advance to next
	LOOP	ovScan
	RESTORE <DI,ES>
	MOV	ES:[DI+BX],AX
	return

EndProc ResetLRU

IF  0  ; We dont need this routine any more.

Break	<SetOpenAge - update the open age of a SFT>

;
;----------------------------------------------------------------------------
;
;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
;   we keep the 'open age' or an LRU count based on opens.  We update the
;   count here and fill in the appropriate field.
;
;   Inputs:	ES:DI point to SFT
;   Outputs:	ES:DI has the open age field filled in.
;		If open age has wraparound, we will have subtracted 8000h
;		    from all open ages.
;   Registers modified: AX
;
;----------------------------------------------------------------------------
;


Procedure   SetOpenAge,NEAR

	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.

	ASSUME CS:DOSCODE

	DOSAssume <SS>, "SetOpenAge"

	Assert	ISSFT,<ES,DI>,"SetOpenAge"

	MOV	AX,OpenLRU		; SS override
	INC	AX
	MOV	ES:[DI].sf_OpenAge,AX
	JNZ	SetDone
	MOV	BX,sf_Position+2
	call	ResetLRU
SetDone:
	MOV	OpenLRU,AX
	return
EndProc SetOpenAge

ENDIF	; SetOpenAge no longer needed


Break	<LRUFCB - perform LRU on FCB sfts>

;
;----------------------------------------------------------------------------
;
;   LRUFCB - find LRU fcb in cache.  Set ThisSFT and return it.  We preserve
;	the first keepcount sfts if they are network sfts or if sharing is
;	loaded.  If carry is set then NO BLASTING is NECESSARY.
;
;   Inputs:	none
;   Outputs:	ES:DI point to SFT
;		ThisSFT points to SFT
;		SFT is zeroed
;		Carry set of closes failed
;   Registers modified: none
;
;----------------------------------------------------------------------------
;
IF 0	; rewritten this routine

Procedure   LRUFCB,NEAR
	ASSUME CS:DOSCODE,SS:NOTHING

	Save_World
	getdseg	<ds>			; ds -> dosdata

; Find nth oldest NET/SHARE FCB.  We want to find its age for the second scan
; to find the lease recently used one that is younger than the open age.  We
; operate be scanning the list n times finding the least age that is greater
; or equal to the previous minimum age.
;
;   BP is the count of times we need to go through this loop.
;   AX is the current acceptable minimum age to consider
;
	mov	bp,KeepCount		; k = keepcount;
	XOR	AX,AX			; low = 0;
;
; If we've scanned the table n times, then we are done.
;
lru1:
	CMP	bp,0			; while (k--) {
	JZ	lru75
	DEC	bp
;
; Set up for scan.
;
;   AX is the minimum age for consideration
;   BX is the minimum age found during the scan
;   SI is the position of the entry that corresponds to BX
;
	MOV	BX,-1			;     min = 0xffff;
	MOV	si,BX			;     pos = 0xffff;
	LES	DI,SFTFCB		;     for (CX=FCBCount; CX>0; CX--)
	MOV	CX,ES:[DI].sfCount
	LEA	DI,[DI].sfTable
;
; Innermost loop.  If the current entry is free, then we are done.  Or, if the
; current entry is busy (indicating a previous aborted allocation), then we
; are done.  In both cases, we use the found entry.
;
lru2:
	cmp	es:[di].sf_ref_count,0
	jz	lru25
	cmp	es:[di].sf_ref_count,sf_busy
	jnz	lru3
;
; The entry is usable without further scan.  Go and use it.
;
lru25:
	MOV	si,DI			;	      pos = i;
	JMP	short lru11		;	      goto got;
;
; See if the entry is for the network or for the sharer.
;
;  If for the sharer or network then
;	if the age < current minimum AND >= allowed minimum then
;	    this entry becomes current minimum
;
lru3:
	TESTB	ES:[DI].sf_flags,sf_isnet   ;	  if (!net[i]
	JNZ	lru35
if installed
	jmp	lru5
;	call	CheckShare		;		&& !sharing)
;	JZ	lru5			;	  else
ENDIF
;
; This SFT is for the net or is for the sharer.  See if it less than the
; current minimum.
;
lru35:
	MOV	DX,ES:[DI].sf_OpenAge
	CMP	DX,AX			;	  if (age[i] >= low &&
	JB	lru5
	CMP	DX,BX
	JAE	lru5			;	      age[i] < min) {
;
; entry is new minimum.  Remember his age.
;
	mov	bx,DX			;	      min = age[i];
	mov	si,di			;	      pos = i;
;
; End of loop.	gp back for more
;
lru5:
add	di,size sf_entry
	loop	lru2			;	      }
;
; The scan is complete.  If we have successfully found a new minimum (pos != -1)
; set then threshold value to this new minimum + 1.  Otherwise, the scan is
; complete.  Go find LRU.
;
lru6:	cmp	si,-1			; position not -1?
	jz	lru75			; no, done with everything
	lea	ax,[bx+1]		; set new threshold age
	jmp	lru1			; go and loop for more
lru65:	stc
	jmp	short	lruDead 	;	  return -1;
;
; Main loop is done.  We have AX being the age+1 of the nth oldest sharer or
; network entry.  We now make a second pass through to find the LRU entry
; that is local-no-share or has age >= AX
;
lru75:
	mov	bx,-1			; min = 0xffff;
	mov	si,bx			; pos = 0xffff;
	LES	DI,SFTFCB		; for (CX=FCBCount; CX>0; CX--)
	MOV	CX,ES:[DI].sfCount
	LEA	DI,[DI].sfTable
;
; If this is is local-no-share then go check for LRU else if age >= threshold
; then check for lru.
;
lru8:
	TESTB	ES:[DI].sf_flags,sf_isnet
	jnz	lru85			; is for network, go check age
;	call	CheckShare		; sharer here?
;	jz	lru86			; no, go check lru
;
; Network or sharer.  Check age
;
;lru85:
;	cmp	es:[di].sf_OpenAge,ax
;	jb	lru9			; age is before threshold, skip it
;
; Check LRU
;
lru86:
	cmp	es:[di].sf_LRU,bx	; is LRU less than current LRU?
	jae	lru9			; no, skip this
	mov	si,di			; remember position
	mov	bx,es:[di].sf_LRU	; remember new minimum LRU
;
; Done with this entry, go back for more.
;
lru9:
	add	di,size sf_entry
	loop	lru8
;
; Scan is complete.  If we found NOTHING that satisfied us then we bomb
; out.	The conditions here are:
;
;   No local-no-shares AND all net/share entries are older than threshold
;
lru10:
	cmp	si,-1			; if no one f
	jz	lru65			;     return -1;
lru11:
	mov	di,si
	MOV	WORD PTR ThisSFT,DI	; set thissft
	MOV	WORD PTR ThisSFT+2,ES
;
; If we have sharing or thisSFT is a net sft, then close it until ref count
; is 0.
;
	TESTB	ES:[DI].sf_flags,sf_isNet
	JNZ	LRUClose
IF INSTALLED
	jmp	LRUDone
;	call	CheckShare
;	JZ	LRUDone
ENDIF
;
; Repeat close until ref count is 0
;
LRUClose:

;	DS already set up at beginnnig of proceure.
; 	Context DS

	LES	DI,ThisSFT
	CMP	ES:[DI].sf_ref_count,0	; is ref count still <> 0?
	JZ	LRUDone 		; nope, all done

;	Message     1,"LRUFCB: closing "
;	MessageNum  <WORD PTR THISSFT+2>
;	Message     1,":"
;	MessageNum  <WORD PTR THISSFT>

	Invoke	DOS_Close
	jnc	LRUClose		; no error => clean up
	cmp	al,error_invalid_handle
	jz	LRUClose
	stc
	JMP	short LRUDead
LRUDone:
	XOR	AL,AL
	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared

LRUDead:
	Restore_World			; use macro

	getdseg	<es>			; es -> dosdata
 	LES     DI,ES:ThisSFT
	assume	es:NOTHING	

	Assert	ISSFT,<ES,DI>,"LRUFCB return"
	retnc
	MOV	AL,error_FCB_unavailable
	return
EndProc LRUFCB

ENDIF	; LRUFCB has been rewritten below.


;******* LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
; maintains separate counts for net/Share and local SFTs. We allocate a 
; net/Share SFT only if we do not find a local SFT. This helps keep
; net/Share SFTs which cannot be regenerated for as long as possible. We
; optimize regeneration operations by keeping track of the current local
; SFT. This avoids scanning of the SFTs as long as we have at least one 
; local SFT in the SFT Block.
;
; Inputs: al = 0 => Regenerate SFT operation
;	    = 1 => Allocate new SFT for Open/Create
;
; Outputs: Carry clear
;	 	es:di = Address of allocated SFT
;	  	ThisSFT = Address of allocated SFT
;
;	  carry set if closes of net/Share files failed 
;		al = error_FCB_unavailable
;
; Registers affected: None
;


PUBLIC	LruFCB
LruFCB	PROC	NEAR
	assume	ds:nothing, es:nothing,ss:nothing

	Save_world
	getdseg	<ds>		;ds = DOSDATA

	or	al,al		;Check if regenerate allocation
	jnz	lru1		;Try to find SFT to use

	;
	; This is a regen call. If LocalSFT contains the address of a valid 
	; local SFT, just return that SFT to reuse
	;

	mov	di,word ptr LocalSFT
	or	di,word ptr LocalSFT+2	;is address == 0?
	jz	lru1			;invalid local SFT, find one

	;
	; We have found a valid local SFT. Recycle this SFT
	;

	les	di,LocalSFT

gotlocalSFT:
	mov	word ptr ThisSFT,di
	mov	word ptr ThisSFT+2,es
	clc
	jmp	LRUDone	;clear up SFT and return

lru1:
	les	di,SFTFCB	;es:di = SF Table for FCBs
	mov	cx,es:[di].sfCount	;cx = number of SFTs
	lea	di,[di].sfTable	;es:di = first SFT

	;
	; We scan through all the SFTs scanning for a free one. It also 
	; remembers the LRU SFT for net/Share SFTs and local SFTs separately. 
	; bx = min. LRU for local SFTs
	; si = pos. of local SFT with min. LRU
	; dx = min. LRU for net/Share SFTs
	; bp = pos. of net/Share SFT with min. LRU
	;

	mov	bx,-1		; init. to 0xffff ( max. LRU value )
	mov	si,bx
	mov	dx,bx
	mov	bp,bx

findSFT:
	;
	;See if this SFT is a free one. If so, return it
	;

	or	es:[di].sf_ref_count,0	;reference count = 0 ?
	jz	gotSFT		;yes, SFT is free
	cmp	es:[di].sf_ref_count,sf_busy	;Is it busy?
	jz	gotSFT		;no, can use it

	;
	; Check if this SFT is local and store its address in LocalSFT. Can be 
	; used for a later regen.
	;

 	test	es:[di].sf_flags,sf_isnet ;network SFT?
	jnz	lru5		;yes, get net/Share LRU
IF installed
;	call	CheckShare	;Share present?
ENDIF
;	jnz	lru5		;yes, get net/Share LRU

	;
	;Local SFT, register its address
	;

	; !!HACK!!!
	; There is a slightly dirty hack out here in a desperate bid to save  
	; code space. There is similar code duplicated at label 'gotSFT'. We 
	; enter from there if al = 0, update the LocalSFT variable, and since 
	; al = 0, we jump out of the loop to the exit point. I have commented 
	; out the code that previously existed at label 'gotSFT'
	;

hackpoint:
	mov	word ptr LocalSFT,di
	mov	word ptr LocalSFT+2,es	;store local SFT address

	or	al,al		;Is operation = REGEN?
	jz	gotlocalSFT 	;yes, return this SFT for reuse

	;
	;Get LRU for local files
	;

	cmp	es:[di].sf_LRU,bx	;SFT.LRU < min?
	jae	lru4		;no, skip 

	mov	bx,es:[di].sf_LRU	;yes, store new minimum
	mov	si,di		;store SFT position

lru4:
	add	di,SIZE sf_entry	;go to next SFT
	loop	findSFT

	;
	; Check whether we got a net/Share or local SFT. If local SFT 
	; available, we will reuse it instead of net/Share LRU
	;

	mov	di,si
	cmp	si,-1		;local SFT available?
	jnz	gotSFT		;yes, return it

	;
	;No local SFT, see if we got a net/Share SFT
	;

	mov	di,bp
	cmp	bp,-1		;net/Share SFT available?
	jnz	gotnetSFT	;yes, return it
noSFT:

	;
	; NB: This error should never occur. We always must have an LRU SFT. 
	; This error can occur only if the SFT has been corrupted or the LRU 
	; count is not maintained properly.
	;

	jmp	short errorbadSFT	;error, no FCB available.

	;
	; Handle the LRU for net/Share SFTs
	;

lru5:
	cmp	es:[di].sf_LRU,dx	;SFT.LRU < min?
	jae	lru4		;no, skip 

	mov	dx,es:[di].sf_LRU	;yes, store new minimum
	mov	bp,di		;store SFT position
	jmp	short lru4	;continue with next SFT

gotSFT:
	or	al,al
	jz	hackpoint	;save es:di in LocalSFT

	;
	; HACK!!!
	; The code here differs from the code at 'hackpoint' only in the 
	; order of the check for al. If al = 0, we can junp to 'hackpoint' 
	; and then from  there jump out to 'gotlocalSFT'. The original code 
	; has been commented out below and replaced by the code just above.
	;

;
;If regen, then this SFT can be registered as a local one ( even if free ).
;
;	or	al,al		;Regen?
;	jnz	notlocaluse	;yes, register it and return
;
;Register this SFT as a local one
;
;	mov	word ptr LocalSFT,di
;	mov	word ptr LocalSFT+2,es
;	jmp	gotlocalSFT	;return to caller
;
;notlocaluse:

	;
	; The caller is probably going to use this SFT for a net/Share file. 
	; We will come here only on a Open/Create when the caller($FCB_OPEN) 
	; does not really know whether it is a local file or not. We 
	; invalidate LocalSFT if the SFT we are going to use was previously 
	; registered as a local SFT that can be recycled.
	;

	mov	ax,es
	cmp	word ptr LocalSFT,di		;Offset same?
	jnz	notinvalid
	cmp	word ptr LocalSFT+2,ax	;Segments same?
	jz	zerolocalSFT		;no, no need to invalidate
notinvalid:
	jmp	gotlocalSFT

	;
	; The SFT we are going to use was registered in the LocalSFT variable. 
	; Invalidate this variable i.e LocalSFT = NULL
	;

zerolocalSFT:
	xor	ax,ax
	mov	word ptr LocalSFT,ax
	mov	word ptr LocalSFT+2,ax

	jmp	gotlocalSFT

gotnetSFT:

	;
	; We have an SFT that is currently net/Share. If it is going to be 
	; used for a regen, we know it has to be a local SFT. Update the 
	; LocalSFT variable
	;

	or	al,al
	jnz	closenet

	mov	word ptr LocalSFT,di
	mov	word ptr LocalSFT+2,es	;store local SFT address
closenet:
	mov	word ptr ThisSFT,di	; set thissft
	mov	word ptr ThisSFT+2,es	

	;
	; If we have sharing or thisSFT is a net sft, then close it until ref 
	; count is 0.
	; NB: We come here only if it is a net/Share SFT that is going to be 
	; recycled -- no need to check for this.
	;

LRUClose:

	cmp	es:[di].sf_ref_count,0	; is ref count still <> 0?
	jz	LRUDone 		; nope, all done
	push	si
	mov	si,word ptr es:[di].sf_NTHandle
	mov	ax,word ptr es:[di].sf_NTHandle+2

	HRDSVC	SVC_DEMCLOSEFCB		; ax:si is NT handle
	pop	si
	jnc	LRUClose		; no error => clean up

	;
	; Bugbug: I dont know why we are trying to close after we get an 
	; error closing. Seems like we could have a potential infinite loop  
	; here. This has to be verified.
	;

	cmp	al,error_invalid_handle
	jz	LRUClose
errorbadSFT:
	stc
	JMP	short LRUDead
LRUDone:
	XOR	AL,AL
	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared

LRUDead:
	Restore_World			; use macro

	getdseg	<es>
	les	di,es:ThisSFT		;es:di points at allocated SFT

	retnc
	MOV	AL,error_FCB_unavailable
	ret
	
LruFCB	ENDP

if 0

;**** RegenCopyName -- This function copies the filename from the FCB to
; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
; to copy the name to different destinations
;
; Inputs: ds:si = source string
;	 es:di = destination string
;	 cx = length of string
;
; Outputs: String copied to destination
;
; Registers affected: cx,di,si
;

Procedure  RegenCopyName  NEAR
	
CopyName:
	lodsb			;load character

 IFDEF  DBCS				
	call	testkanj		
	jz	notkanj9		
	STOSB				
	DEC	CX			
	JCXZ	DoneName		; Ignore split kanji char error
	LODSB				
	jmp	short StuffChar2	
					
notkanj9:				
 ENDIF					

	call	UCase		; convert char to upper case
StuffChar2:
	STOSB			;store converted character
	LOOP	CopyName	;
DoneName:
	ret

EndProc	RegenCopyName


Break	<FCBRegen - regenerate a sft from the info in the FCB>
;
;----------------------------------------------------------------------------
;
;   FCBRegen - examine reserved field of FCB and attempt to generate the SFT
;	from it.
;
;   Inputs:	DS:SI point to FCB
;   Outputs:	carry clear Filled in SFT
;		Carry set unrecoverable error
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure   FCBRegen,NEAR

	; called from SFTFromFCB. SS already DOSDATA

	DOSAssume <SS>, "FCBRegen"

	; General data filling.  Mode is sf_isFCB + open_for_both, date/time 
	; we do not fill, size we do no fill, position we do not fill,
	; bit 14 of flags = TRUE, other bits = FALSE

	MOV	AL,[SI].fcb_l_drive

	; We discriminate based on the first two bits in the reserved field.

	test	AL,FCBSPECIAL		; check for no sharing test
	JZ	RegenNoSharing		; yes, go regen from no sharing

	;
	; The FCB is for a network or a sharing based system.  At this point 
	; we have already closed the SFT for this guy and reconnection is 
	; impossible.
	;
	; Remember that he may have given us a FCB with bogus information in
	; it. Check to see if sharing is present or if the redir is present.
	; If either is around, presume that we have cycled out the FCB and 
	; give the hard error. Otherwise, just return with carry set.
	;

;	call	CheckShare		; test for sharer
;	JNZ	RegenFail		; yep, fail this.
	MOV	AX,multNet SHL 8	; install check on multnet
	INT	2FH
	OR	AL,AL			; is it there?
	JZ	RegenDead		; no, just fail the operation
RegenFail:
	MOV	AX,User_In_AX		; SS override
	cmp	AH,fcb_close
	jz	RegenDead
	invoke	FCBHardErr		; massive hard error.
RegenDead:
	STC
	return				; carry set

	;
	; Local FCB without sharing.  Check to see if sharing is loaded.  If 
	; so fail the operation.
	;
RegenNoSharing:
	call	CheckShare		; Sharing around?
	JNZ	RegenFail
	;
	; Find an SFT for this guy.
	;
	push	ax
	mov	al,0		;indicate it is a regen operation
	invoke	LRUFcb
	pop	ax

	retc
	MOV	ES:[DI].sf_mode,SF_IsFCB + open_for_both + sharing_compat
	AND	AL,3Fh			; get drive number for flags
	CBW
	OR	AX,sf_close_noDate	; normal FCB operation

	;
	; The bits field consists of the upper two bits (dirty and device) 
	; from the SFT and the low 4 bits from the open mode.
	;

	MOV	CL,[SI].FCB_nsl_bits	; stick in dirty bits.
	MOV	CH,CL
	AND	CH,0C0h 		; mask off the dirty/device bits
	OR	AL,CH
	AND	CL,access_mask		; get the mode bits
	MOV	BYTE PTR ES:[DI].sf_mode,CL
	MOV	ES:[DI].sf_flags,AX	; initial flags
	MOV     AX,Proc_ID		; SS override
	MOV	ES:[DI].sf_PID,AX
	SAVE	<DS,SI,ES,DI>
	Context	<es>

	MOV	DI,OFFSET DOSDATA:Name1	; NAME1 is in DOSDATA

	MOV	CX,8
	INC	SI			; Skip past drive byte to name in FCB

	call	RegenCopyName	;copy the name to NAME1

	context	<ds>			; SS is DOSDATA

	MOV	[ATTRIB],attr_hidden + attr_system + attr_directory
					; Must set this to something interesting
					; to call DEVNAME.
	Invoke	DevName 		; check for device
	ASSUME	DS:NOTHING,ES:NOTHING
	RESTORE <DI,ES,SI,DS>
	JC	RegenFileNoSharing	; not found on device list => file

	;
	; Device found.  We can ignore disk-specific info
	;

	MOV	BYTE PTR ES:[DI].sf_flags,BH   ; device parms
	MOV	ES:[DI].sf_attr,0	; attribute
					; SS override
	LDS	SI,DEVPT		; get device driver
	MOV	WORD PTR ES:[DI].sf_devptr,SI
	MOV	WORD PTR ES:[DI].sf_devptr+2,DS
	ret				; carry is clear

RegenDeadJ:
	JMP	RegenDead

	;
	; File found.  Just copy in the remaining pieces.
	;

RegenFileNoSharing:
	MOV	AX,ES:[DI].sf_flags
	AND	AX,03Fh
	SAVE	<DS,SI>
	Invoke	Find_DPB
	MOV	WORD PTR ES:[DI].sf_devptr,SI
	MOV	WORD PTR ES:[DI].sf_devptr+2,DS
	RESTORE <SI,DS>
	jc	RegenDeadJ		; if find DPB fails, then drive
					; indicator was bogus
	MOV	AX,[SI].FCB_nsl_dirsec
	MOV	WORD PTR ES:[DI].sf_dirsec,AX

	; SR;
	; Update the higher word of the directory sector from the FCB
	;

; 	MOV	WORD PTR ES:[DI].sf_dirsec+2,0	;AN000;>32mb

	; SR;
	; Extract the read-only and archive bits from the top 2 bits of the sector
	; number
	;

	mov	al,[si].fcb_sfn
	and	al,0c0h		;get the 2 attribute bits
	mov	ah,al
	rol	ah,1
	shr	al,1
	or	al,ah
	and	al,03fH		;mask off unused bits
	mov	es:[di].sf_attr,al

	mov	al,[si].fcb_sfn
	and	al,03fh		;mask off top 2 bits -- attr bits
	sub	ah,ah
	mov	word ptr es:[di].sf_dirsec+2,ax ;update high word

	MOV	AX,[SI].FCB_nsl_firclus
	MOV	ES:[DI].sf_firclus,AX
	MOV	ES:[DI].sf_lstclus,AX
	MOV	AL,[SI].FCB_nsl_dirpos
	MOV	ES:[DI].sf_dirpos,AL
	INC	ES:[DI].sf_ref_count	; Increment reference count.
					; Existing FCB entries would be
					; flushed unnecessarily because of
					; check in CheckFCB of the ref_count.
					; July 22/85 - BAS
	LEA	SI,[SI].FCB_name
	LEA	DI,[DI].sf_name
	MOV	CX,fcb_extent-fcb_name

	call	RegenCopyName	;copy name to SFT 

	clc
	ret
EndProc FCBRegen

endif



;**	BlastSFT - FIll SFT with Garbage
;
;	BlastSFT is used when an SFT is no longer needed; it's called with
;	various garbage values to put into the SFT.  I don't know why,
;	presumably to help with debugging (jgl).  We clear the few fields
;	necessary to show that the SFT is free after filling it.
;
;	ENTRY	(es:di) = address of SFT
;		(al) = fill character
;	EXIT	(ax) = -1
;		'C' clear
;	USES	AX, CX, Flags


Procedure   BlastSFT,NEAR
	INTTEST

	push	di
	mov	cx,size sf_entry
	rep	stosb
	pop	di
	sub	ax,ax			; clear 'C'-----------------;
	mov	es:[di].sf_ref_count,ax ; set ref count 	    ;
	mov	es:[di].sf_lru,ax	; set lru		    ;
	dec	ax						    ;
	mov	es:[di].sf_openage,ax	; set open age to -1	    ;
	ret				; return with 'C' clear     ;

EndProc BlastSFT

Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
;
;----------------------------------------------------------------------------
;
;   CheckFCB - examine an FCB and its contents to see if it is OK.
;
;   Inputs:	DS:SI point to FCB (not extended)
;		AL is SFT index
;   Outputs:	Carry Set - FCB is bad
;		Carry clear - FCB is OK. ES:DI point to SFT
;   Registers modified: AX and BX
;
;----------------------------------------------------------------------------
;

Procedure   CheckFCB,NEAR
		
	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA

	DOSAssume <SS>, "CheckFCB"

	LES     DI,sftFCB		; SS override

	CMP	BYTE PTR ES:[DI].SFCount,AL
	JC	BadSFT
	MOV	BL,SIZE sf_entry
	MUL	BL
	LEA	DI,[DI].sftable
	ADD	DI,AX
	MOV     AX,Proc_ID		; SS override
	CMP	ES:[DI].sf_PID,AX
	JNZ	BadSFT			; must match process

	CMP	ES:[DI].sf_ref_count,0
	JZ	BadSFT			; must also be in use

	cmp	byte ptr ds:[si].fcb_res_dev,1		; Is FCB for a device
	je	CheckFCBDevice

	mov	AX, word ptr ds:[si].fcb_res_Sig
	cmp	word ptr es:[di].sf_NTHandle, AX
	jnz	BadSFT

	mov	AX, word ptr ds:[si].fcb_res_Sig+2
	cmp	word ptr es:[di].sf_NTHandle+2, AX
	jnz	BadSFT


GoodSFT:
	CLC
	ret				; carry is clear

BadSFT: STC
	ret				; carry is set

CheckFCBDevice:
	MOV	BX,WORD PTR [SI].FCB_res_Sig
	CMP	BX,WORD PTR ES:[DI].sf_devptr
	JNZ	BadSFT
	MOV	BX,WORD PTR [SI].FCB_res_Sig + 2
	CMP	BX,WORD PTR ES:[DI].sf_devptr + 2
	JNZ	BadSFT
	JMP	GoodSFT

EndProc CheckFCB

Break	<SFTFromFCB - take a FCB and obtain a SFT from it>

;----------------------------------------------------------------------------
;
;   SFTFromFCB - the workhorse of this compatability stuff.  Check to see if
;	the SFT for the FCB is Good.  If so, make ThisSFT point to it.	If not
;	good, get one from the cache and regenerate it.  Overlay the LRU field
;	with PID
;
;   Inputs:	DS:SI point to FCB
;   Outputs:	ThisSFT point to appropriate SFT
;		Carry clear -> OK ES:DI -> SFT
;		Carry set -> error in ax
;   Registers modified: ES,DI, AX
;
;----------------------------------------------------------------------------

Procedure   SFTFromFCB,NEAR

	; called from fcbio and $fcb_close. SS already set up to DOSDATA

	DOSAssume <SS>, "SFTFromFCB"

	SAVE	<AX,BX>

	MOV	AL,[SI].fcb_sfn 	; set SFN for check
	invoke	CheckFCB
	RESTORE <BX,AX>

	MOV     WORD PTR ThisSFT,DI     ; SS override
	MOV     WORD PTR ThisSFT+2,ES

	JNC	SetSFT			; no problems, just set thissft

; Sudeepb 19-Nov-1991 We are'nt supporting Regen
;
;	Save_World			; use macro
;	invoke	FCBRegen
;	Restore_World			; use macro restore world

	MOV	AX,User_In_AX		; SS override
	cmp	AH,fcb_close
	jz	Retur

	invoke	FCBHardErr		; massive hard error.
	mov	ax, EXTERR

Retur:
	STC
	return				; carry set

;	Message 1,<"FCBRegen Succeeded",13,10>

SetSFT: 
	LES     DI,ThisSFT		; SS override for THISSFT & PROC_ID
	PUSH    Proc_ID                 ; set process id
	POP	ES:[DI].sf_PID
	clc
	ret				; carry is clear
EndProc SFTFromFCB

Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
;
;----------------------------------------------------------------------------
;
;   FCBHardErr - signal to a user app that he is trying to use an
;	unavailable FCB.
;
;   Inputs:	none.
;   Outputs:	none.
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

Procedure   FCBHardErr,NEAR
	Assume	SS:NOTHING

	getdseg	<es>			; es -> dosdata

	MOV	AX,error_FCB_Unavailable
	MOV	ES:[ALLOWED],allowed_FAIL
;	LES	BP,ES:[THISDPB]
	MOV	DI,1			; Fake some registers
	MOV	CX,DI
;	MOV	DX,ES:[BP.dpb_first_sector]
	invoke	HARDERR
	STC
	return
EndProc FCBHardErr

DOSCODE ENDS
END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\exepatch.asm ===
;** EXEPATCH.ASM 
;
;	Contains the foll:
;
;		- code to find and overlay buggy unpack code
;		- new code to be overlayed on buggy unpack code 
;		- old code sequence to identify buggy unpack code
;
;	Revision history:
;
;		Created: 5/14/90
;
;
;
;----------------------------------------------------------------------------
;
; M020 : Fix for rational bug - for details see routine header
; M028 : 4b04 implementation
; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
; M032 : set turnoff bit only if DOS in HMA.
; M033 : if IP < 2 then not exepacked.
; M046 : support for a 4th version of exepacked files.
; M068 : support for copy protected apps.
; M071 : use A20OFF_COUNT of 10.
;
;----------------------------------------------------------------------------
;
.XLIST
.XCREF

INCLUDE version.inc
INCLUDE dosseg.inc
INCLUDE DOSSYM.INC
INCLUDE exe.inc
INCLUDE	PDB.INC

.CREF
.LIST


	public	exepatch
	public	RationalPatch				; M020
	public	IsCopyProt

PATCH1_COM_OFFSET	EQU	06CH
PATCH1_OFFSET		EQU	028H
PATCH1_CHKSUM		EQU	0EF4EH
CHKSUM1_LEN		EQU	11CH/2

PATCH2_COM_OFFSET	EQU	076H
PATCH2_OFFSET		EQU	032H

	; The strings that start at offset 076h have two possible 
	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM

PATCH2_CHKSUM		EQU	78B2H
CHKSUM2_LEN		EQU	119H/2
PATCH2A_CHKSUM		EQU	1C47H		; M046
CHKSUM2A_LEN		EQU	103H/2		; M046

PATCH3_COM_OFFSET	EQU	074H
PATCH3_OFFSET		EQU	032H
PATCH3_CHKSUM		EQU	4EDEH
CHKSUM3_LEN		EQU	117H/2




DOSDATA	SEGMENT

;	EXTRN	exec_signature	:WORD	; Must contain 4D5A  (yay zibo!)

;	EXTRN	exec_init_IP 	:WORD	; IP of entry
;	EXTRN	exec_init_CS 	:WORD	; CS of entry

	EXTRN	UNPACK_OFFSET	:WORD
	EXTRN	RatBugCode	:FAR
	EXTRN	RationalPatchPtr:word
	EXTRN	fixexepatch	:word		; M028
	EXTRN	Special_Version	:word		; M028
;	EXTRN	A20OFF_FLAG	:byte
	extrn	DosHasHMA	:byte		
	extrn	A20OFF_COUNT	:byte		; M068
	extrn	A20OFF_PSP	:word		; M068
	extrn	DOS_FLAG	:byte		; M068

DOSDATA	ENDS


DOSCODE	SEGMENT

; M028 - BEGIN

	EXTRN	Scan_Execname1:near
	EXTRN	Scan_Special_Entries:near

	ASSUME	CS:DOSCODE, SS:DOSDATA

	public	ExecReady

;-------------------------------------------------------------------------
;
;	Procedure Name		: ExecReady
;
;	Input			: DS:DX -> ERStruc (see exe.inc)
;
;--------------------------------------------------------------------------

ExecReady	proc	near

	mov	si, dx			; move the pointer into a friendly one
	test	[si].ER_Flags, ER_EXE	; COM or EXE ?
	jz	er_setver		; only setver for .COM files

	mov	ax, [si].ER_PSP
	add	ax, 10h
	mov	es, ax

	mov	cx, word ptr ds:[si].ER_StartAddr	; M030
	mov	ax, word ptr ds:[si+2].ER_StartAddr	; M030

	call	[fixexepatch]
er_setver:
					; Q: is this an overlay
	test	[si].ER_Flags, ER_OVERLAY
	jnz	er_chkdoshi		; Y: set A20OFF_COUNT if DOS high
					; N: set up lie version first
	push	ds
	push	si
	lds	si, [si].ER_ProgName
	call	Scan_Execname1
	call	Scan_Special_Entries
	pop	si
	pop	ds
	mov	es, [si].ER_PSP
	mov	ax, Special_Version
	mov	es:[0].PDB_Version, ax
er_chkdoshi:
	cmp	[DosHasHMA], 0		; M032: Q: is dos in HMA (M021)
	je	er_done			; M032: N: done

					; M068 - Start
	mov	ax, [si].ER_PSP		; ax = PSP

	or	[DOS_FLAG], EXECA20OFF	; Set bit to signal int 21
					; ah = 25 & ah= 49. See dossym.inc 
					; under TAG M003 & M009 for 
					; explanation

	test	[si].ER_Flags, ER_EXE	; Q: COM file
	jnz	er_setA20		; N: inc a20off_count , set 
					;    a20off_psp and ret
   	push	ds
	mov	ds, ax			; DS = load segment of com file.
	call	IsCopyProt		; check if copy protected
	pop	ds

er_seta20:

	;
	; We need to inc the A20OFF_COUNT here. Note that if the count
	; is non-zero at this point it indicates that the A20 is to be 
	; turned off for that many int 21 calls made by the app. In 
	; addition the A20 has to be turned off when we exit from this 
	; call. Hence the inc.
	;

	inc	[A20OFF_COUNT]		
	mov	[A20OFF_PSP], ax	; set the PSP for which A20 is to be
					; turned OFF.
er_done:				; M068 - End
	xor	ax, ax
	ret
ExecReady	endp

; M028 - END

public		exepatch_start
exepatch_start	label 	byte

	;
	; The following is the code that'll be layed over the buggy unpack
	; code.
	;
str1	label	byte

	db  06h	  		;push	es		 
	db  8Ch, 0D8h		;mov	ax,ds 

first_stop	equ	$ - str1
			
	db  2Bh, 0C2h		;sub	ax, dx			

first		label	byte

	db  8Eh, 0D8h		;mov	ds,ax			
	db  8Eh, 0C0h		;mov	es,ax			
	db  0BFh, 0Fh, 00h	;mov	di,000FH
	db  57h	    		;push	di
	db  0B9h, 10h, 00h	;mov	cx,0010H
	db  0B0h, 0FFh 		;mov	al,0FFH 		
	db  0F3h, 0AEh 		;repz	scasb			
	db  47h	    		;inc	di			
	db  8Bh, 0F7h  		;mov	si,di			
	db  5Fh	    		;pop	di
	db  58h	    		;pop	ax

second_stop	equ	$ - first

	db  2Bh, 0C2h  		;sub	ax, dx			

second		label	byte

	db  8Eh, 0C0h  		;mov	es,ax			
		    		;NextRec:				
	db  0B9h, 04h, 02h	;mov	cx, 0204h
		    		;norm_agn:				
	db  8Bh, 0C6h		;mov	ax,si			
	db  0F7h, 0D0h		;not	ax		
	db  0D3h, 0E8h		;shr	ax,cl		
	db  74h, 13h		;jz	SI_ok			
	db  8Ch, 0DAh		;mov	dx,ds			
	db  83h, 0CEh, 0F0h	;or	si,0FFF0H
	db  2Bh, 0D0h		;sub	dx,ax			
	db  73h, 08h		;jnc	SItoDS			
	db  0F7h, 0DAh		;neg	dx			
	db  0D3h, 0E2h		;shl	dx,cl			
	db  2Bh, 0F2h		;sub	si,dx			
	db  33h, 0D2h		;xor	dx,dx			
				;SItoDS: 				
	db  8Eh, 0DAh		;mov	ds,dx		
				;SI_ok:					
	db  87h, 0F7h		;xchg	si,di			
	db  1Eh			;push	ds			
	db  06h			;push	es			
	db  1Fh			;pop	ds			
	db  07h			;pop	es			
	db  0FEh, 0CDh		;dec	ch			
	db  75h, 0DBh		;jnz	norm_agn		
	db  0ACh		;lodsb			
	db  92h			;xchg	dx,ax
	db  4Eh			;dec	si
	db  0ADh		;lodsw			
	db  8Bh, 0C8h		;mov	cx,ax		
	db  46h			;inc	si		
	db  8Ah, 0C2h		;mov	al,dl		
	db  24h, 0FEh		;and	al,0FEH		
	db  3Ch, 0B0h		;cmp	al,RPTREC
	db  75h, 05h		;jne	TryEnum
	db  0ACh		;lodsb				
	db  0F3h, 0AAh		;rep stosb			

;	db  0EBh, 07h, 90h	;jmp	TryNext
	db  0EBh, 06h		;jmp	TryNext

				;TryEnum:
	db  3Ch, 0B2h		;cmp	al,ENMREC
	db  75h, 6Ch		;jne	CorruptExe		
	db  0F3h, 0A4h		;rep movsb			
				;TryNext:

	db  92h			;xchg	dx,ax
;	db  8Ah, 0C2h		;mov	al,dl			

	db  0A8h, 01h		;test	al,1			
	db  74h, 0B9h		;jz	NextRec			
	db  90h, 90h		;nop, nop
	

last_stop	equ	$ - second
size_str1	equ	$-str1


	;
	; The following is the code that we need to look for in the exe
	; file.
	;
scan_patch1	label	byte

	db  8Ch, 0C3h		;mov	bx,es			
	db  8Ch, 0D8h		;mov	ax,ds
	db  2Bh, 0C2h		;sub	ax, dx
	db  8Eh, 0D8h		;mov	ds,ax			
	db  8Eh, 0C0h		;mov	es,ax			
	db  0BFh, 0Fh,00h	;mov	di,000FH
	db  0B9h, 10h, 00h	;mov	cx,0010H
	db  0B0h, 0FFh		;mov	al,0FFH
	db  0F3h, 0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh, 0F7h		;mov	si,di
	db  8Bh, 0C3h		;mov	ax,bx			
	db  2Bh, 0C2h		;sub	ax, dx
	db  8Eh, 0C0h		;mov	es,ax
	db  0BFh, 0fh,00h	;mov	di,000FH
				;NextRec:
	db  0B1h, 04h		;mov	cl,4
	db  8Bh, 0C6h		;mov	ax,si
	db  0F7h, 0D0h		;not	ax		
	db  0D3h, 0E8h		;shr	ax,cl		
	db  74h, 09h		;jz	SI_ok
	db  8Ch, 0DAh		;mov	dx,ds
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0DAh		;mov	ds,dx		
	db  83h, 0CEh, 0F0h	;or	si,0FFF0H	       
	       			;SI_ok:
	db  8Bh, 0C7h		;mov	ax,di		
	db  0F7h, 0D0h		;not	ax
	db  0D3h, 0E8h		;shr	ax,cl
	db  74h, 09h		;jz	DI_ok
	db  8Ch, 0C2h		;mov	dx,es
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0C2h		;mov	es,dx
	db  83h, 0CFh, 0F0h	;or	di,0FFF0H
				;DI_ok:

size_scan_patch1	equ	$-scan_patch1


scan_patch2	label	byte

			
	db  8Ch, 0C3h		;mov	bx,es			
	db  8Ch, 0D8h		;mov	ax,ds
	db  48h			;dec	ax
	db  8Eh, 0D8h		;mov	ds,ax			
	db  8Eh, 0C0h		;mov	es,ax			
	db  0BFh, 0Fh, 00h	;mov	di,000FH
	db  0B9h, 10h, 00h	;mov	cx,0010H
	db  0B0h, 0FFh		;mov	al,0FFH
	db  0F3h, 0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh, 0F7h		;mov	si,di
	db  8Bh, 0C3h		;mov	ax,bx			
	db  48h			;dec	ax
	db  8Eh, 0C0h		;mov	es,ax
	db  0BFh, 0Fh, 00h	;mov	di,000FH		
				;NextRec:
	db  0B1h, 04h		;mov	cl,4
	db  8Bh, 0C6h		;mov	ax,si
	db  0F7h, 0D0h		;not	ax		
	db  0D3h, 0E8h		;shr	ax,cl		
	db  74h, 0Ah		;jz	SI_ok
	db  8Ch, 0DAh		;mov	dx,ds
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0DAh		;mov	ds,dx		
	db  81h, 0CEh, 0F0h, 0FFh
				;or	si,0FFF0H
				;SI_ok:
	db  8Bh, 0C7h		;mov	ax,di		
	db  0F7h, 0D0h		;not	ax
	db  0D3h, 0E8h		;shr	ax,cl
	db  74h, 0Ah		;jz	DI_ok
	db  8Ch, 0C2h		;mov	dx,es
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0C2h		;mov	es,dx
	db  81h, 0CFh, 0F0h, 0FFh
				;or	di,0FFF0H
				;DI_ok:


size_scan_patch2	equ	$-scan_patch2


scan_patch3	label	byte

			
	db  8Ch, 0C3h		;mov	bx,es			
	db  8Ch, 0D8h		;mov	ax,ds
	db  48h			;dec	ax
	db  8Eh, 0D8h		;mov	ds,ax			
	db  8Eh, 0C0h		;mov	es,ax			
	db  0BFh, 0Fh, 00h	;mov	di,000FH
	db  0B9h, 10h, 00h	;mov	cx,0010H
	db  0B0h, 0FFh		;mov	al,0FFH
	db  0F3h, 0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh, 0F7h		;mov	si,di
	db  8Bh, 0C3h		;mov	ax,bx			
	db  48h			;dec	ax
	db  8Eh, 0C0h		;mov	es,ax
	db  0BFh, 0Fh, 00h	;mov	di,000FH		
				;NextRec:
	db  0B1h, 04h		;mov	cl,4
	db  8Bh, 0C6h		;mov	ax,si
	db  0F7h, 0D0h		;not	ax		
	db  0D3h, 0E8h		;shr	ax,cl		
	db  74h, 09h		;jz	SI_ok
	db  8Ch, 0DAh		;mov	dx,ds
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0DAh		;mov	ds,dx	
	db  83h, 0CEh, 0F0h	;or	si,0FFF0H	
				;SI_ok:
	db  8Bh, 0C7h		;mov	ax,di		
	db  0F7h, 0D0h		;not	ax
	db  0D3h, 0E8h		;shr	ax,cl
	db  74h, 09h		;jz	DI_ok
	db  8Ch, 0C2h		;mov	dx,es
	db  2Bh, 0D0h		;sub	dx,ax
	db  8Eh, 0C2h		;mov	es,dx
	db  83h, 0CFh, 0F0h	;or	di,0FFF0H
				;DI_ok:


size_scan_patch3	equ	$-scan_patch3


scan_com	label	byte

	db  0ACh		;lodsb			
	db  8Ah, 0D0h		;mov	dl,al		
	db  4Eh			;dec	si
	db  0ADh		;lodsw			
	db  8Bh, 0C8h		;mov	cx,ax		
	db  46h			;inc	si		
	db  8Ah, 0C2h		;mov	al,dl		
	db  24h, 0FEh		;and	al,0FEH		
	db  3Ch, 0B0h		;cmp	al,RPTREC
	db  75h, 06h		;jne	TryEnum
	db  0ACh		;lodsb				
	db  0F3h, 0AAh		;rep stosb			
	db  0EBh, 07h, 90h	;jmp	TryNext
				;TryEnum:
	db  3Ch, 0B2h		;cmp	al,ENMREC
	db  75h, 6Bh		;jne	CorruptExe		
	db  0F3h, 0A4h		;rep movsb			
				;TryNext:
	db  8Ah, 0C2h		;mov	al,dl			
	db  0A8h, 01h		;test	al,1			
;	db  74h, 0BAh		;jz	NextRec			

size_scan_com	equ	$-scan_com

ExePatch	proc	near
		call	ExePackPatch
		call	word ptr RationalPatchPtr
		ret
ExePatch	endp



;---------------------------------------------------------------------------
;
; Procedure Name 	: ExePackPatch
;
; Inputs	 	: DS 			-> DOSDATA
;			  ES:0 			-> read in image
;			  ax:cx = start cs:ip of program
; Output		:		
;
;	1. If ES <= 0fffh
;	   2. if exepack signature ('RB') found
;	      3. if common code to patch compares (for 3 diff. versions)
;	       	 4. if rest of the code & checksum compares
;	  	    5. overlay buggy code with code in 
;		       doscode:str1.
;		 6. endif
;	      7. endif
;	   8. endif
;	9. endif
;
;
; Uses			: NONE
;
;---------------------------------------------------------------------------
		

ExePackPatch	proc	near

	push	bx
	mov	bx, es			; bx has load segment
	cmp	bx, 0fffh		; Q: is the load segment > 64K
	jbe	ep_cont			; N: 
	pop	bx			; Y: no need to patch
	ret

ep_cont:
	push	ds
	push	es
	push	ax
	push	cx
	push	si
	push	di
	
		; M033 - start
		; exepacked prgrams have an IP of 12h (>=2)

	sub	cx, 2			; Q: is IP >=2 
	ljc	ep_notpacked		; N: exit
					; ax:cx now points to location of
					; 'RB' if this is an exepacked file.

		; M033 - end

	mov	di, cx
	mov	es, ax
	mov	[unpack_offset], di	; save pointer to 'RB' in 
					; unpack_offset


	cmp	word ptr es:[di], 'BR'
	ljne	ep_notpacked

	push	cs
	pop	ds			; set ds to cs
	assume	ds:nothing

	add	di, PATCH1_COM_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 

	call	chk_common_str		; check for match

	jnz	ep_chkpatch2		; Q: does the patch match
					; N: check at patch2_offset
					; Y: check for rest of patch string

	mov	si, offset DOSCODE:scan_patch1
					; ds:si -> scan string 
	mov	di, [unpack_offset]	; restore di to point to 'RB'

	add	di, PATCH1_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 
	mov	cx, size_scan_patch1
	mov	bx, CHKSUM1_LEN
	mov	ax, PATCH1_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
	jc	ep_done1		; Q: did we pass the test
					; N: exit
					; Y: overlay code with new 
	
	mov	si, offset DOSCODE:str1
	mov	cx, size_str1
	
rep	movsb


ep_done1:
	jmp	ep_done


ep_chkpatch2:
	mov	di, PATCH2_COM_OFFSET	; es:di -> possible loaction of patch
					; in another version of unpack
	call	chk_common_str		; check for match

	jnz	ep_chkpatch3		; Q: does the patch match
					; N: check for patch3_offset
					; Y: check for rest of patch string

	mov	si, offset DOSCODE:scan_patch2
					; ds:si -> scan string 

	mov	di, PATCH2_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 
	mov	cx, size_scan_patch2
	mov	bx, CHKSUM2_LEN
	mov	ax, PATCH2_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare

					; M046 - Start
					; Q: did we pass the test
	jnc	ep_patchcode2		; Y: overlay code with new 
					; N: try with a different chksum


	mov	si, offset DOSCODE:scan_patch2
					; ds:si -> scan string 
	mov	cx, size_scan_patch2
	mov	bx, CHKSUM2A_LEN
	mov	ax, PATCH2A_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
					; Q: did we pass the test
	jc	ep_notpacked		; N: try with a different chksum
					; Y: overlay code with new 
						
ep_patchcode2:			       	; M046 - End
	mov	si, offset DOSCODE:str1
	mov	cx, first_stop
	
rep	movsb

	mov	ax, 4890h		; ax = opcodes for dec ax, nop
	stosw
	add	si, 2

	mov	cx, second_stop

rep	movsb

	stosw				; put in dec ax and nop
	add	si, 2

	mov	cx, last_stop

rep	movsb

	jmp	short ep_done

ep_chkpatch3:

	mov	di, PATCH3_COM_OFFSET	; es:di -> possible loaction of patch
					; in another version of unpack
	call	chk_common_str		; check for match

	jnz	ep_notpacked		; Q: does the patch match
					; N: exit
					; Y: check for rest of patch string


	mov	si, offset DOSCODE:scan_patch3
					; ds:si -> scan string 

	mov	di, PATCH3_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 
	mov	cx, size_scan_patch3
	mov	bx, CHKSUM3_LEN
	mov	ax, PATCH3_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
	jc	ep_notpacked		; Q: did we pass the test
					; N: exit
					; Y: overlay code with new 

	mov	si, offset DOSCODE:str1
	mov	cx, first_stop
	
rep	movsb

	mov	al, 48h			; al = opcode for dec ax
	stosb
	add	si, 2

	mov	cx, second_stop

rep	movsb

	stosb				; put in dec ax
	add	si, 2

	mov	cx, last_stop

rep	movsb

	

ep_notpacked:

;	stc
;

ep_done:

	pop	di
	pop	si
	pop	cx
	pop	ax
	pop	es
	pop	ds
	pop	bx
	ret

;-------------------------------------------------------------------------
;
; 	Procedure Name	: chk_common_str
;
;	Input		: DS = DOSCODE
;			; ES:DI points to string in packed file
;
;	Output		; Z if match else NZ
;
;-----------------------------------------------------------------------

chk_common_str	proc	near

	mov	si, offset DOSCODE:scan_com
					; ds:si -> scan string 
	mov	cx, size_scan_com

repe	cmpsb	       

					; M046 - start
	; a fourth possible version of these exepacked programs have a 
	; 056h instead of 06bh. See scan_com above
	;
	; 	db  75h, 6Bh		;jne	CorruptExe		
	;
	; If the mismatch at this point is due to a 56h instead of 6bh 
	; we shall try to match the rest of the string
	;

	jz	ccs_done
	cmp	byte ptr es:[di-1], 56h
	jnz	ccs_done

repe	cmpsb	    
  
ccs_done:				; M046 - end
	ret

chk_common_str	endp		


;---------------------------------------------------------------------------
;
;	Procedure Name	: chk_patchsum
;
;	Input		: DS:SI -> string we're looking for
;			: ES:DI -> offset in packed file
;			: CX 	= scan length
;			: BX	= length of check sum
;			: AX 	= value of check sum
;
;	Output		: if patch & check sum compare
;				NC
;			  else
;				CY
;
;	Uses		: AX, BX, CX, SI
;----------------------------------------------------------------------------

chk_patchsum	proc	near

	push	di

repe	cmpsb			   

	jnz	cp_fail			; Q: does the patch match
					; N: exit
					; Y:	


		; we do a check sum starting from the location of the 
		; exepack signature 'RB' up to 11c/2 bytes, the end of the
		; unpacking code.


	mov	di, [unpack_offset]	; di -> start of unpack code
	mov	cx, bx			; cx = length of check sum

	mov	bx, ax			; save check sum passed to us in bx
	xor	ax, ax

ep_chksum:
	add	ax, word ptr es:[di]
	add	di, 2
	loop	ep_chksum

	pop	di			; restore di

	cmp	ax, bx		 	; Q: does the check sum match
	jnz	cp_fail			; N: exit
					; Y: 

	clc	
	ret

cp_fail:
	stc
	ret

chk_patchsum	endp


ExePackPatch	endp
;
; M020 : BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : RationalPatch
;
; A routine (in Ration DOS extender) which is invoked at hardware interrupts
; clobbers CX registeron 286 machines. (123 release 3 uses Rational DOS
; extender). This routine identfies Buggy Rational EXEs and fixes the bug.
;
; THE BUG is in the following code sequence:
;
;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
;90		even				; word align
;e2 fe		loop	$			; wait		CLOBBERS CX
;e8 xx xx	call	set_A20			; enable A20
;
; This patch routine replaces the mov & the loop with a far call into a
; routine in DOS data segment which is in low memory (because A20 line
; is off). The routine (RatBugCode) in DOS data saves & restores CX around
; a mov & loop.
;
; Identification of Buggy Rational EXE
; ====================================
;
; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
;
; OFFSET				Contains
; ------				--------
; 0000h			100 times Version number in binary
;			bug exists in version 3.48 thru 3.83 (both inclusive)
;
; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
;
; 002ah			offset where version number is stored in ASCII
;				e.g. '3.48A'
;
; 0030h			offset of copyright string. Copyright strings either
;			start with "DOS/16M Copyright...." or
;			"Copyright.....". The string contains
;			"Rational Systems, Inc."
;
; 0020h			word : Paragraph offset of the buggy code segment
;				from the program image
; 0016h			word : size of buggy code segment
;
;	Buggy code is definite to start after offset 200h in its segment
;
;----------------------------------------------------------------------------
;
RScanPattern1	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0
RLen1		equ	$ - offset RScanPattern1

RScanPattern2	db	8bh, 0eh, 10h, 00h, 90h, 0e2h, 0feh, 0e8h
RLen2		equ	$ - offset RScanPattern2

RScanPattern3	db	8bh, 0eh, 10h, 00h, 0e2h, 0feh, 0e8h
RLen3		equ	$ - offset RScanPattern2
;
;----------------------------------------------------------------------------
;
; INPUT : ES = segment where program got loaded
;
;----------------------------------------------------------------------------
RationalPatch	proc	near
		cld
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	es
		push	ds			; we use all of them
		mov	di, 0ah			; look for pat1 at offset 0a
		push	cs
		pop	ds
		assume	ds:nothing
		mov	si, offset RScanPattern1
		mov	cx, RLen1
		rep	cmpsb			; do we have the pattern ?
		jne	rpexit
		mov	ax, es:[0]
		cmp	ax, 348			; is it a buggy version ?
		jb	rpexit
		cmp	ax, 383			; is it a buggy version
		ja	rpexit

		call	VerifyVersion
		jne	rpexit

		mov	cx, es:[16h]		; Length of buggy code seg
		sub	cx, 200h		; Length we search (we start
						;  at offset 200h)
		mov	es, word ptr es:[20h]	; es=buggy code segment
		mov	si, offset RScanPattern2
		mov	dx, RLen2
		call	ScanCodeSeq		; look for code seq with nop
		jz	rpfound

		mov	si, offset RScanPattern3
		mov	dx, RLen3
		call	ScanCodeSeq		; look for code seq w/o nop
		jnz	rpexit
rpfound:

;		we set up a far call into DOS data
;		dx has the length of the doce seq we were searching for

		mov	al, 9ah			; far call opcode
		stosb
		mov	ax, offset RatBugCode
		stosw
		mov	ax, ss
		stosw
		mov	cx, dx
		sub	cx, 6			; filler (with NOPs)
		mov	al, 90h
		rep	stosb
rpexit:
		pop	ds
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		ret
RationalPatch	endp
;
;----------------------------------------------------------------------------
;
; ScanCodeSeq
;
; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
;
; returns in ES:DI the start of the pattern if Zero flag is set
;
;----------------------------------------------------------------------------
;
ScanCodeSeq	proc	near
		push	cx
		sub	cx, dx
		inc	cx
		mov	di, 200h
scsagain:
		push	si
		push	di
		push	cx
		mov	cx, dx
		rep	cmpsb
		pop	cx
		pop	di
		pop	si
		je	scsfound
		inc	di
		loop	scsagain
scsfound:
		pop	cx
		ret
ScanCodeSeq	endp
	
;
;----------------------------------------------------------------------------
;
; VerifyVersion
;
; Checks whther the binary version 
;----------------------------------------------------------------------------
;
VerifyVersion	proc	near
		mov	si, es:[2ah]		; offset of version number
						;  in ascii
		mov	bl, 10
		add	si, 3			; point to last digit

		call	VVDigit
		jne	vvexit
		call	VVDigit
		jne	vvexit
		cmp	byte ptr es:[si], '.'
		jne	vvexit
		dec	si
		call	VVDigit
vvexit:
		ret
VerifyVersion	endp

VVDigit		proc	near
		div	bl
		add	ah, '0'
		dec	si
		cmp	es:[si+1], ah
		mov	ah, 0			; do not xor or sub we need Z
		ret
VVDigit		endp
;
; M020 END
;

;---------------------------------------------------------------------------
;
;	M068
;
; 	Procedure Name	: IsCopyProt
;
;	Inputs		: DS:100 -> start of com file just read in
;
;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
;			  the program loaded in DS:100 uses a MICROSOFT
;			  copy protect scheme that relies on the A20 line
;			  being turned off for it's scheme to work.
;
;			  Note: The int 21 function dispatcher will turn 
;				a20 off, if the A20OFF_COUNT is non-zero 
;				and dec the A20OFF_COUNT before	iretting 
;				to the user. 
;
;	Uses		: ES, DI, SI, CX
;
;---------------------------------------------------------------------------

CPStartOffset	EQU	0175h
CPID1Offset	EQU	011bh
CPID2Offset	EQU	0173h
CPID3Offset	EQU	0146h
CPID4Offset	EQU	0124h
ID1		EQU	05343h
ID2		EQU	05044h
ID3		EQU	0F413h
ID4		EQU	08000h

CPScanPattern	db	089h, 026h, 048h, 01h		; mov [148], sp
		db	08ch, 0eh , 04ch, 01h		; mov [14c], cs
		db	0c7h, 06h , 04ah, 01h, 0h, 01h	; mov [14a], 100h 
		db 	08ch, 0eh , 013h, 01h		; mov [113], cs
		db	0b8h, 020h, 01h			; mov ax, 120h
		db	0beh, 00h , 01h			; mov si, 100h

CPSPlen		EQU	$ - CPScanPattern

IsCopyProt	proc	near

	cmp	ds:[CPID1Offset], ID1
	jne	CP_done

	cmp	ds:[CPID2Offset], ID2
	jne	CP_done

	cmp	ds:[CPID3Offset], ID3
	jne	CP_done

	cmp	ds:[CPID4Offset], ID4
	jne	CP_done

	push	cs
	pop	es
	mov	di, offset CPScanPattern	; es:di -> Pattern to find

	mov	si, CPStartOffset		; ds:si -> possible location 
						; of pattern

	mov	cx, CPSPlen			; cx = length of pattern

repe	cmpsb

	jnz	CP_done
	mov	ss:[A20OFF_COUNT], 0AH		; M071
CP_done:
	ret
	
IsCopyProt	endp

		
DOSCODE	ENDS

	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\fcbio2.asm ===
;	SCCSID = @(#)fcbio2.asm 1.2 85/07/23
	TITLE	FCBIO2 - FCB system calls
	NAME	FCBIO2

;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
;
;	GetRR
;	GetExtent
;	SetExtent
;	GetExtended
;	GetRecSize
;	FCBIO
;	$FCB_OPEN
;	$FCB_CREATE
;	$FCB_RANDOM_WRITE_BLOCK
;	$FCB_RANDOM_READ_BLOCK
;	$FCB_SEQ_READ
;	$FCB_SEQ_WRITE
;	$FCB_RANDOM_READ
;	$FCB_RANDOM_WRITE
;
;	Revision history:
;
;	Sudeep Bharati 19-Nov-1991 Ported on NT
;

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include cpmfcb.inc
	include filemode.inc
	include bugtyp.inc
	include dossvc.inc
	.cref
	.list


	I_need	WFP_Start,WORD		; pointer to beginning of expansion
	I_need	DMAAdd,DWORD		; current user's DMA address
	I_need	OpenBuf,128		; buffer for translating paths
	I_need	ThisSFT,DWORD		; SFT in use
	I_need	sftFCB,DWORD		; pointer to SFTs for FCB cache
	I_need	FCBLRU,WORD		; least recently used count
	I_need	DISK_FULL,BYTE		; flag for disk full

	I_need	LocalSFT,DWORD		;Cache for new FCB implementation

; Defintions for FCBOp flags

Random	=   2				; random operation
FCBRead =   4				; doing a read
Block	=   8				; doing a block I/O


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


	EXTRN	DOS_Read:NEAR, DOS_Write:NEAR
	EXTRN	DOS_Open:NEAR
	EXTRN	DOS_Create:NEAR


 Break <GetRR - return the random record field in DX:AX>
;---------------------------------------------------------------------------
;
;
;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
;	from the FCB pointed to by DS:SI
;
;   Inputs:	DS:SI point to an FCB
;		BX has record size
;   Outputs:	DX:AX contain the contents of the random record field
;   Registers modified: none
;---------------------------------------------------------------------------

Procedure   GetRR,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AX,WORD PTR [SI.FCB_RR] ; get low order part
	MOV	DX,WORD PTR [SI.FCB_RR+2]   ; get high order part
	CMP	BX,64			; ignore MSB of RR if recsiz > 64
	JB	GetRRBye
	XOR	DH,DH
GetRRBye:
	return
EndProc GetRR

Break <GetExtent - retrieve next location for sequential IO>
;---------------------------------------------------------------------------
;
;   GetExtent - Construct the next record to perform I/O from the EXTENT and
;	NR fields in the FCB.
;
;   Inputs:	DS:SI - point to FCB
;   Outputs:	DX:AX contain the contents of the random record field
;   Registers modified: none
;---------------------------------------------------------------------------

Procedure   GetExtent,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,[SI.fcb_NR]		; get low order piece
	MOV	DX,[SI.fcb_EXTENT]	; get high order piece
	SHL	AL,1
	SHR	DX,1
	RCR	AL,1			; move low order bit of DL to high order of AH
	MOV	AH,DL
	MOV	DL,DH
	XOR	DH,DH
	return
EndProc GetExtent

Break <SetExtent - update the extent/NR field>
;---------------------------------------------------------------------------
;
;   SetExtent - change the position of an FCB by filling in the extent/NR
;	fields
;
;   Inputs:	DS:SI point to FCB
;		DX:AX is a record location in file
;   Outputs:	Extent/NR fields are filled in
;   Registers modified: CX
;---------------------------------------------------------------------------

Procedure SetExtent,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<AX,DX>
	MOV	CX,AX
	AND	AL,7FH			; next rec field
	MOV	[SI.fcb_NR],AL
	AND	CL,80H			; save upper bit
	SHL	CX,1
	RCL	DX,1			; move high bit of CX to low bit of DX
	MOV	AL,CH
	MOV	AH,DL
	MOV	[SI.fcb_EXTENT],AX	; all done
	RESTORE <DX,AX>
	return
EndProc SetExtent


Break <GetExtended - find FCB in potential extended fcb>
;---------------------------------------------------------------------------
;
;   GetExtended - Make DS:SI point to FCB from DS:DX
;
;   Inputs:	DS:DX point to a possible extended FCB
;   Outputs:	DS:SI point to the FCB part
;		zeroflag set if not extended fcb
;   Registers modified: SI
;---------------------------------------------------------------------------

Procedure   GetExtended,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	SI,DX			; point to Something
	CMP	BYTE PTR DS:[SI],-1	; look for extention
	JNZ	GetBye			; not there
	ADD	SI,7			; point to FCB
GetBye:
	CMP	SI,DX			; set condition codes
	return
EndProc GetExtended


Break <GetRecSize - return in BX the FCB record size>
;---------------------------------------------------------------------------
;
;   GetRecSize - return in BX the record size from the FCB at DS:SI
;
;   Inputs:	DS:SI point to a non-extended FCB
;   Outputs:	BX contains the record size
;   Registers modified: None
;---------------------------------------------------------------------------

Procedure   GetRecSize,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	BX,[SI.fcb_RECSIZ]	; get his record size
	OR	BX,BX			; is it nul?
	retnz
	MOV	BX,128			; use default size
	MOV	[SI.fcb_RECSIZ],BX	; stuff it back
	return
EndProc GetRecSize

BREAK <FCBIO - do internal FCB I/O>
;---------------------------------------------------------------------------
;
;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
;
;   Inputs:	FCBOP flags which operations need to be performed
;		DS:DX point to FCB
;		CX may have count of number of records to xfer
;   Outputs:	AL has error code
;   Registers modified: all
;---------------------------------------------------------------------------

Procedure   FCBIO,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

PUBLIC FCBIO001S,FCBIO001E
FCBIO001S:
	LocalVar    FCBErr,BYTE
	LocalVar    cRec,WORD
	LocalVar    RecPos,DWORD
	LocalVar    RecSize,WORD
	LocalVar    bPos,DWORD
	LocalVar    cByte,WORD
	LocalVar    cResult,WORD
	LocalVar    cRecRes,WORD
	LocalVar    FCBOp,BYTE
FCBIO001E:
	Enter

FEOF	EQU	1
FTRIM	EQU	2
	MOV	FCBOp,AL
	MOV	FCBErr,0		;   FCBErr = 0;
	invoke	GetExtended		;   FCB = GetExtended ();
	TESTB	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
	JNZ	GetPos
	MOV	CX,1			;	cRec = 1;
GetPos:
	MOV	cRec,CX 		;*Tail coalesce
	invoke	GetExtent		;   RecPos = GetExtent ();
	invoke	GetRecSize		;   RecSize = GetRecSize ();
	MOV	RecSize,BX
	TESTB	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
	JZ	GetRec
	invoke	GetRR			;	RecPos = GetRR ();
GetRec:
	MOV	RecPosL,AX		;*Tail coalesce
	MOV	RecPosH,DX
	invoke	SetExtent		;   SetExtent (RecPos);
	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
	MUL	BX
	MOV	DI,AX
	MOV	AX,RecPosL
	MUL	BX
	ADD	DX,DI
	MOV	bPosL,AX
	MOV	bPosH,DX
	MOV	AX,cRec 		;   cByte = cRec * RecSize;
	MUL	BX
	MOV	cByte,AX

	ADD	AX,WORD PTR DMAAdd	;   if (cByte+DMA > 64K) {
	ADC	DX,0
	JZ	DoOper
	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;

	MOV	AX,WORD PTR DMAAdd	;	cRec = (64K-DMA)/RecSize;
	NEG	AX
	JNZ	DoDiv
	DEC	AX
DoDiv:
	XOR	DX,DX
	DIV	BX
	MOV	cRec,AX
	MUL	BX			;	cByte = cRec * RecSize;
	MOV	cByte,AX		;	}
DoOper:
	XOR	BX,BX
	MOV	cResult,BX		;   cResult = 0;
	CMP	cByte,BX		;   if (cByte <> 0 ||
	JNZ	DoGetExt
	TESTB	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
	JZ	DoGetExt
	JMP	SkipOp

DoGetExt:
	invoke	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
	JNC	ContinueOp
FCBDeath:
	invoke	FCB_Ret_Err		; signal error, map for extended
	MOV	cRecRes,0		; no bytes transferred
	MOV	FCBErr,FEOF		;	    return FTRIM;
	JMP	FCBSave 		; bam!
ContinueOp:
	Assert	ISSFT,<ES,DI>,"ContinueOP"
	MOV	AX,WORD PTR [SI].fcb_filsiz
	MOV	WORD PTR ES:[DI].sf_size,AX
	MOV	AX,WORD PTR [SI].fcb_filsiz+2
	MOV	WORD PTR ES:[DI].sf_size+2,AX
	MOV	AX,bPosL
	MOV	DX,bPosH
	MOV	WORD PTR ES:[DI.sf_position],AX
	XCHG	WORD PTR ES:[DI.sf_position+2],DX
	PUSH	DX			; save away Open age.
	MOV	CX,cByte		;	cResult =


	mov	ax,es:[dI].sf_flags
	and	ax,  devid_device	; file or device
	jnz	FCBIODev

FCBIOFile:
;	MOV	AL,BYTE PTR ES:[DI.sf_mode]
;	AND	AL,access_mask
;	TESTB	FCBOp,FCBRead		; Is Read Operation
;	JNZ	testread

;	CMP	AL,open_for_write

;	JNE	testok			;Is read or both
;BadMode:
;	POP	DX			; clean-up the stack
;	Leave
;	transfer   SET_ACC_ERR

;testread:
;	CMP	AL,open_for_read
;	JNE	Check_FCB_RO		 ;Is write or both
;	JMP	BadMode 		; Can't write to Read_Only files via FCB

;
; NOTE: The following check for writting to a Read Only File is performed
;	    ONLY on FCBs!!!!
;	We ALLOW writes to Read Only files via handles to allow a CREATE
;	    of a read only file which can then be written to.
;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
;	    CREATing a NEW RO file, or RE-CREATing an existing file which
;	    is NOT RO to be RO, via handles are the only times we can write
;	    to a read-only file.
;
;Check_FCB_RO:
;	TESTB	ES:[DI].sf_attr,attr_read_only
;	JNZ	BadMode 		; Can't write to Read_Only files via FCB
;testok:
	SAVE	<BP,DI,SI>

	MOV	dx,bPosL
	MOV	si,bPosH		; si:dx is offset
	mov	bx,1			; Assume Read operation
	TESTB	FCBOp,FCBRead		; Is Read Operation
	JNZ	FCBIOCommon
	xor	bx,bx			; write operation
FCBIOCommon:				; Input:

	mov	bp,word ptr es:[di].sf_NTHandle
	mov	ax,word ptr es:[di].sf_NTHandle+2
	mov	di,si
	HRDSVC	SVC_DEMFCBIO		; BX = 1 if read, 0 if write operation
					; AX:BP is the NT Handle
					; DI:DX is offset
					; CX is count to read/write
					; Output:
					;   CY Clear, CX is count;AX:BX is size
					;   CY Set,   CX =0 ; AX has error code
	RESTORE	<SI,DI,BP>
	jmp	devfile

FCBIODev:
	MOV	DI,OFFSET DOSCODE:DOS_Read ;	    *(OP&FCBRead ? DOS_Read
	TESTB	FCBOp,FCBRead		;			 : DOS_Write)(cRec);
	JNZ	DoContext

	MOV	DI,OFFSET DOSCODE:DOS_Write
DoContext:
	SAVE	<BP,DS,SI>

	Context DS
	CALL	DI
	RESTORE <SI,DS,BP>
	ASSUME	DS:NOTHING

	JNC	devcont
	JMP	FCBDeath
devcont:
	xor	ax, ax	; AX:BX is size of file in FCBio10, but
	xor	bx, bx	; DOS_WRITE or DOS_READ destroys these regs(YST)

	JMP	short fcbio10

devfile:
	JNC	fcbio10
	JMP	FCBDeath
fcbio10:
	MOV	cResult,CX
	SAVE	<AX,BX>
	invoke	UpdateLRU		;Update LRU
	RESTORE	<BX,AX>
;	BUGBUG - why not just use the SF_OPENAGE symbol?
	.errnz	SF_POSITION+2-SF_OPENAGE
	POP	WORD PTR ES:[DI].sf_Position+2	; restore open age
	MOV	WORD PTR [SI].fcb_filsiz,BX
	MOV	WORD PTR [SI].fcb_filsiz+2,AX
SkipOp:
	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
	XOR	DX,DX
	DIV	RecSize
	MOV	cRecRes,AX
	ADD	RecPosL,AX		;   RecPos += cRecResult;
	ADC	RecPosH,0
;
; If we have not gotten the expected number of records, we signal an EOF
; condition.  On input, this is EOF.  On output this is usually disk full.
; BUT...  Under 2.0 and before, all device output IGNORED this condition.  So
; do we.
;
	CMP	AX,cRec 		;   if (cRecRes <> cRec)
	JZ	TryBlank
	TESTB	FCBOp,FCBRead		;	if (OP&FCBRead || !DEVICE)
	JNZ	SetEOF
	TESTB	ES:[DI].sf_flags,devid_device
	JNZ	TryBlank
SetEOF:
	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
TryBlank:				;
	OR	DX,DX			;   if (cResult%RecSize <> 0) {
	JZ	SetExt
	ADD	RecPosL,1		;	RecPos++;
	ADC	RecPosH,0
	TESTB	FCBOp,FCBRead		;	if(OP&FCBRead) <> 0) {
	JZ	SetExt
	INC	cRecRes 		;	cRecRes++;
	MOV	FCBErr,FTRIM + FEOF	;	FCBErr = FTRIM | FEOF;
	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
	SUB	CX,DX			;	       DMA+cResult);
	XOR	AL,AL

;hkn; 	SS override
	LES	DI,DMAAdd
	ADD	DI,cResult
	REP	STOSB			;   }	}
SetExt:
	MOV	DX,RecPosH
	MOV	AX,RecPosL
	TESTB	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
	JZ	DoSetExt
	TESTB	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
	JZ	TrySetRR
DoSetExt:
	invoke	SetExtent		;	SetExtent (RecPos, FCB);
TrySetRR:
	TESTB	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
	JZ	TryReturn
	MOV	WORD PTR [SI.FCB_RR],AX ;	FCB->RR = RecPos;
	MOV	BYTE PTR [SI.FCB_RR+2],DL
	CMP	[SI.fcb_RECSIZ],64
	JAE	TryReturn
	MOV	[SI+fcb_RR+2+1],DH	; Set 4th byte only if record size < 64
TryReturn:
	TESTB	FCBOP,FCBRead		;   if (!(FCBOP & FCBREAD)) {
	JNZ	FCBSave
	SAVE	<DS>			;	FCB->FDate = date;
	SVC	SVC_DEMDATE16		;	FCB->FTime = time;
	RESTORE <DS>
	MOV	[SI].FCB_FDate,AX
	MOV	[SI].FCB_FTime,DX	;	}
FCBSave:
	TESTB	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
	JZ	DoReturn
	MOV	CX,cRecRes		;	user_CX = cRecRes;
	invoke	Get_User_Stack
	MOV	[SI.User_CX],CX
DoReturn:
	MOV	AL,FCBErr		;   return (FCBERR);
	Leave
	return
EndProc FCBIO

Break <$FCB_Open - open an old-style FCB>
;---------------------------------------------------------------------------
;
;   $FCB_Open - CPM compatability file open.  The user has formatted an FCB
;	for us and asked to have the rest filled in.
;
;   Inputs:	DS:DX point to an unopenned FCB
;   Outputs:	AL indicates status 0 is ok FF is error
;		FCB has the following fields filled in:
;		    Time/Date Extent/NR Size
;---------------------------------------------------------------------------

Procedure $FCB_Open,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AX,sharing_Compat+Open_For_Both

;hkn; DOS_Open is in DOSCODE
	MOV	CX,OFFSET DOSCODE:DOS_Open
;
; The following is common code for Creation and openning of FCBs.  AX is
; either attributes (for create) or open mode (for open)...  DS:DX points to
; the FCB
;
DoAccess:
	SAVE	<DS,DX,CX,AX>		; save FCB pointer away

	MOV	DI,OFFSET DOSDATA:OpenBuf
	invoke	TransFCB		; crunch the fcb
	mov	bx,ax			; save dev/file/unc code; ax = 0 for devices
	RESTORE <AX,CX,DX,DS>		; get fcb
	JNC	FindFCB 		; everything seems ok
FCBOpenErr:
	transfer    FCB_Ret_Err
FindFCB:
	push	bx
	invoke	GetExtended		; DS:SI will point to FCB

	push	ax
	mov	al,1			;indicate Open/Create operation
	invoke	LRUFCB			; get a sft entry (no error)
	pop	ax
	pop	bx			; BX has return code from TransFCB

	JNC	fcbo10
	JMP	HardMessage
fcbo10:
	ASSUME	ES:NOTHING

;	Message 1,"Entering "
;	MessageNum  ES
;	Message 1,":"
;	MessageNum  DI
;	Message 1,<13,10>

	MOV	ES:[DI].sf_mode,sf_ISFCB
	push	bp
	push	dx
	push	ds
	push	si			;SAVE	<DS,SI> save fcb pointer
	MOV	SI,CX

;hkn; SS is DOSDATA
	Context DS			; let DOS_Open see variables
	or	bx,bx			; IF BX == 0 Then its a device
	jz	DODeviceFCB

;	invoke	DOS_Open_Checks
;	JC	failopen
	mov	si,WFP_START
	cmp	cx,OFFSET DOSCODE:DOS_Create
	jne	OpenCallFCB

	HRDSVC	SVC_DEMCREATEFCB	; Input - AX = Create Modes,
					;	  DS:SI - PathName
					; Output- CY = 0 SUCCESS
					;	  AX:BP - NT handle
					;	  BX	- Time
					;	  CX	- Date
					;	  DX:SI - Size
	jmp	short commonFCB

OpenCallFCB:

	mov	bx,ax			; AX = Open Modes
	HRDSVC	SVC_DEMOPENFCB		; Rest same as SVC_DEMCREATEFCB

CommonFCB:

	LES	DI,ThisSFT
	jc	failopen
	mov	word ptr es:[di].sf_NTHandle,bp 	; Store NT handle in SFT
	mov	word ptr es:[di].sf_NTHandle+2,ax
	mov	word ptr es:[di].sf_time,bx
	mov	word ptr es:[di].sf_date,cx
	mov	word ptr es:[di].sf_size,si
	mov	word ptr es:[di].sf_size+2,dx
	and	byte ptr es:[dI].sf_flags, not devid_device	; Mark it file
	pop	si
	pop	ds
	mov	word ptr ds:[si].fcb_res_Sig,bp
	mov	word ptr ds:[si].fcb_res_Sig+2,ax	; Store NT handle in FCB as a signature
	mov	byte ptr ds:[si].fcb_res_dev,0		; FCB for a file
	jmp	FCBOK


DODeviceFCB:
	CALL	SI			; go open the file
	ASSUME	DS:NOTHING

;hkn; SS override
	LES	DI,ThisSFT		; get sf pointer
	JC	failopen
	pop	si
	pop	ds
	mov	byte ptr ds:[si].fcb_res_dev,1		; FCB for a device
	mov	ax,word ptr es:[di].sf_devptr
	mov	word ptr ds:[si].fcb_res_Sig,ax
	mov	ax,word ptr es:[di].sf_devptr+2
	mov	word ptr ds:[si].fcb_res_Sig+2,ax
	JMP	short FCBOK

failopen:
	pop	si
	pop	ds
	pop	dx
	pop	bp
	PUSH	AX
	MOV	AL,"R"                  ; clear out field (free sft)
	invoke	BlastSFT
	POP	AX
	CMP	AX,error_too_many_open_files
	JZ	HardMessage
	CMP	AX,error_sharing_buffer_exceeded
	jnz	DeadFCB
HardMessage:
	PUSH	AX
	invoke	FCBHardErr
	POP	AX
DeadFCB:
	transfer    FCB_Ret_Err

FCBOK:
	pop	dx
	pop	bp
	mov	word ptr LocalSFT,di	;
	mov	word ptr LocalSFT+2,es	; Store the SFT address

	INC	ES:[DI].sf_ref_count	; increment reference count
	invoke	SaveFCBInfo
	Assert	ISSFT,<ES,DI>,"FCBOK"

	TESTB	ES:[DI].sf_flags,devid_device
	JNZ	FCBNoDrive		; do not munge drive on devices
	MOV	AL,DS:[SI]		; get drive byte
	invoke	GetThisDrv		; convert
	INC	AL
	MOV	DS:[SI],AL		; stash in good drive letter
FCBNoDrive:
	MOV	[SI].FCB_RecSiz,80h	; stuff in default record size
	MOV	AX,ES:[DI].SF_Time	; set time
	MOV	[SI].FCB_FTime,AX
	MOV	AX,ES:[DI].SF_Date	; set date
	MOV	[SI].FCB_FDate,AX
	MOV	AX,WORD PTR ES:[DI].SF_Size ; set sizes
	MOV	[SI].FCB_FILSIZ,AX
	MOV	AX,WORD PTR ES:[DI].SF_Size+2
	MOV	[SI].FCB_FILSIZ+2,AX
	XOR	AX,AX			; convenient zero
	MOV	[SI].FCB_Extent,AX	; point to beginning of file
;
; We must scan the set of FCB SFTs for one that appears to match the current
; one.	We cheat and use CheckFCB to match the FCBs.
;

;hkn; 	SS override
	LES	DI,SFTFCB		; get the pointer to head of the list
	MOV	AH,BYTE PTR ES:[DI].sfCount ; get number of SFTs to scan bp
OpenScan:
	CMP	AL,[SI].fcb_sfn 	; don't compare ourselves
	JZ	SkipCheck
	SAVE	<AX>			; preserve count

	invoke	CheckFCB		; do they match
	RESTORE <AX>			; get count back
	JNC	OpenFound		; found a match!
SkipCheck:
	INC	AL			; advance to next FCB
	CMP	AL,AH			; table full?
	JNZ	OpenScan		; no, go for more
OpenDone:
	xor	al,al			; return success
	return
;
; The SFT at ES:DI is the one that is already in use for this FCB.  We set the
; FCB to use this one.	We increment its ref count.  We do NOT close it at all.
; Consider:
;
;   open (foo)	delete (foo) open (bar)
;
; This causes us to recycle (potentially) bar through the same local SFT as
; foo even though foo is no longer needed; this is due to the server closing
; foo for us when we delete it.  Unfortunately, we cannot see this closure.
; If we were to CLOSE bar, the server would then close the only reference to
; bar and subsequent I/O would be lost to the redirector.
;
; This gets solved by NOT closing the sft, but zeroing the ref count
; (effectively freeing the SFT) and informing the sharer (if relevant) that
; the SFT is no longer in use.	Note that the SHARER MUST keep its ref counts
; around.  This will allow us to access the same file through multiple network
; connections and NOT prematurely terminate when the ref count on one
; connection goes to zero.
;
OpenFound:
	MOV	[SI].fcb_SFN,AL 	; assign with this
;	INC	ES:[DI].sf_ref_count	; remember this new invocation
	MOV	AX,FCBLRU		; update LRU counts
	MOV	ES:[DI].sf_LRU,AX
;
; We have an FCB sft that is now of no use.  We release sharing info and then
; blast it to prevent other reuse.
;

;hkn; SS is DOSDATA
	context DS
	LES	DI,ThisSFT
	mov	si,word ptr es:[di].sf_NTHandle
	mov	ax,word ptr es:[di].sf_NTHandle+2
	HRDSVC	SVC_DEMCLOSEFCB

	DEC	ES:[DI].sf_ref_count	; free the newly allocated SFT
;	invoke	ShareEnd
	Assert	ISSFT,<ES,DI>,"Open blasting"
	MOV	AL,'C'
	invoke	BlastSFT
	JMP	OpenDone
EndProc $FCB_Open

BREAK	<$FCB_Create - create a new directory entry>
;----------------------------------------------------------------------------
;
;   $FCB_Create - CPM compatability file create.  The user has formatted an
;	FCB for us and asked to have the rest filled in.
;
;   Inputs:	DS:DX point to an unopenned FCB
;   Outputs:	AL indicates status 0 is ok FF is error
;		FCB has the following fields filled in:
;		    Time/Date Extent/NR Size
;----------------------------------------------------------------------------

Procedure $FCB_Create,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	MOV	CX,OFFSET DOSCODE:DOS_Create	; routine to call
	XOR	AX,AX			; attributes to create
	invoke	GetExtended		; get extended FCB
	JZ	DoAccessJ		; not an extended FCB
	MOV	AL,[SI-1]		; get attributes
DoAccessJ:
	JMP	DoAccess		; do dirty work
EndProc $FCB_Create

BREAK <$FCB_Random_write_Block - write a block of records to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
;	and write a number of blocks from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = 0 write was successful and the FCB position is updated
;		AL <> 0 Not enough room on disk for the output
;
;----------------------------------------------------------------------------

Procedure $FCB_Random_Write_Block,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,Random+Block
	JMP	FCBIO

EndProc $FCB_Random_Write_Block

BREAK <$FCB_Random_Read_Block - read a block of records to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
;	and read a number of blocks from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Random_Read_Block,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,Random+FCBRead+Block
	JMP	FCBIO

EndProc $FCB_Random_Read_Block

BREAK <$FCB_Seq_Read - read the next record from a file >
;----------------------------------------------------------------------------
;
;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
;	memory
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Seq_Read,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,FCBRead
	JMP	FCBIO

EndProc $FCB_Seq_Read

BREAK <$FCB_Seq_Write - write the next record to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
;	file
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Seq_Write,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,0
	jmp	FCBIO

EndProc $FCB_SEQ_WRITE

BREAK <$FCB_Random_Read - Read a single record from a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
;	record from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Random_Read,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,Random+FCBRead
	jmp	FCBIO			; single block

EndProc $FCB_RANDOM_READ

BREAK <$FCB_Random_Write - write a single record to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
;	a record to it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

Procedure $FCB_Random_Write,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,Random
	jmp	FCBIO

EndProc $FCB_RANDOM_WRITE

DOSCODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\getset.asm ===
TITLE  GETSET - GETting and SETting MS-DOS system calls
	NAME   GETSET

; ==========================================================================
;**	GETSET - System Calls which get and set various things
;
;	$GET_VERSION
;	$GET_VERIFY_ON_WRITE
;	$SET_VERIFY_ON_WRITE
;	$INTERNATIONAL
;	$GET_DRIVE_FREESPACE
;	$GET_DMA
;	$SET_DMA
;	$GET_DEFAULT_DRIVE
;	$SET_DEFAULT_DRIVE
;	$GET_INTERRUPT_VECTOR
;	$SET_INTERRUPT_VECTOR
;	RECSET
;	$CHAR_OPER
;	$GetExtendedError		DOS 3.3
;	Get_Global_CdPg			DOS 4.0
;	$ECS_CALL			DOS 4.0
;
;	Revision history:
;
;	sudeepb 13-Mar-1991 Ported for NT DOSEm
; ==========================================================================

.xlist
.xcref
	INCLUDE version.inc
	INCLUDE dosseg.inc
	INCLUDE dossym.inc
	INCLUDE devsym.inc
	INCLUDE doscntry.inc
	INCLUDE mult.inc
	INCLUDE pdb.inc
	INCLUDE dossvc.inc
	include bop.inc
.cref
.list

IFNDEF	ALTVECT
	ALTVECT EQU	0			; FALSE
ENDIF

; ==========================================================================

DosData SEGMENT WORD PUBLIC 'DATA'

	EXTRN	USERNUM 	:WORD
	EXTRN	MSVERS		:WORD
	EXTRN	VERFLG		:BYTE
	EXTRN	CNTCFLAG	:BYTE
	EXTRN	DMAADD		:DWORD
	EXTRN	CURDRV		:BYTE
	EXTRN	chSwitch	:BYTE
	EXTRN	COUNTRY_CDPG	:byte		;DOS 3.3
	EXTRN	CDSCount	:BYTE
	EXTRN	ThisCDS 	:DWORD
	EXTRN	EXTERR		:WORD
	EXTRN	EXTERR_ACTION	:BYTE
	EXTRN	EXTERR_CLASS	:BYTE
	EXTRN	EXTERR_LOCUS	:BYTE
	EXTRN	EXTERRPT	:DWORD
	EXTRN	UCASE_TAB	:BYTE
	EXTRN	FILE_UCASE_TAB	:BYTE
	EXTRN	InterCon	:BYTE
	EXTRN	CURRENTPDB	:WORD

	EXTRN	DBCS_TAB	:BYTE
	EXTRN	NLS_YES 	:BYTE
	EXTRN	NLS_yes2	:BYTE
	EXTRN	NLS_NO		:BYTE
	EXTRN	NLS_no2 	:BYTE

	EXTRN	Special_version :WORD
	EXTRN	Fake_Count	:BYTE
	EXTRN	A20OFF_COUNT	:BYTE	; M068, M004
	EXTRN	DOS_FLAG	:BYTE	; M068

DosData ENDS

; ==========================================================================

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	allow_getdseg

	EXTRN	CurrentPDB	:WORD

	EXTRN	Get_User_Stack	:NEAR	; return pointer to user stack

BREAK <$Get_Version -- Return DOS version number>
; =========================================================================
;	$Get_Version - Return DOS Version Number
;
;	Fake_Count is used to lie about the version numbers to support
;	old binarys.  See ms_table.asm for more info.
;
;	ENTRY	al = Information Format
;	EXIT	(bl:cx) = user number (24 bits)
;		(al.ah) = version # (in binary)
;	
;		if input al = 00
;		  (bh) = OEM number			
;		else if input al = 01
;		  (bh) = version flags
;		 
;		       	 bits 0-2 = DOS internal revision
;		       	 bits 3-7 = DOS type flags
;		              bit 3    = DOS is in ROM
;		              bit 4    = DOS in in HMA
;		              bits 5-7 = reserved
;               M007 change - only bit 3 is now valid.  Other bits
;               are 0 when AL = 1

;	USES	all
; =========================================================================

PROCEDURE $Get_Version ,NEAR

	context DS			; SS is DOSDATA

	mov	BX,[UserNum + 2]
	mov	CX,[UserNum]

	cmp	AL,1
	jnz	Norm_Vers

        xor     bh,bh                   ; Otherwise return 0
                                        ;
norm_vers:				; MSVERS is a label in TABLE segment
	push	DS			; Get the version number from the
	mov	DS,CurrentPDB 		; current app's PSP segment
	mov	AX,DS:[PDB_Version] 	; AX = DOS version number
	pop	DS


	call	Get_User_Stack 		; Returns DS:SI --> Caller's stack

	ASSUME	DS:NOTHING

	mov	[SI.User_AX],AX		; Put values for return registers 
	mov	[SI.User_BX],BX		; in the proper place on the user's
	mov	[SI.User_CX],CX		; stack addressed by DS:SI

	return

ENDPROC $Get_Version

; =========================================================================


BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
; =========================================================================
;**	$Get_Verify_On_Write - Get Status of Verify on write flag
;
;	ENTRY	none
;	EXIT	(al) = value of VERIFY flag
;	USES	all
; =========================================================================

procedure   $GET_VERIFY_ON_WRITE,NEAR

;hkn; SS override
	MOV	AL,[VERFLG]
	return

EndProc $GET_VERIFY_ON_WRITE



;**	$Set_Verify_On_Write - Set Status of Verify on write flag
;
;	ENTRY	(al) = value of VERIFY flag
;	EXIT	none
;	USES	all

procedure   $SET_VERIFY_ON_WRITE,NEAR

	AND	AL,1
;hkn; SS override
	MOV	[VERFLG],AL
	return

EndProc $SET_VERIFY_ON_WRITE

BREAK <$International - return country-dependent information>
;----------------------------------------------------------------------------
;
; Procedure Name : $INTERNATIONAL
;
; Inputs:
;	MOV	AH,International
;	MOV	AL,country	(al = 0 => current country)
;      [MOV	BX,country]
;	LDS	DX,block
;	INT	21
; Function:
;	give users an idea of what country the application is running
; Outputs:
;	IF DX != -1 on input (get country)
;	  AL = 0 means return current country table.
;	  0<AL<0FFH means return country table for country AL
;	  AL = 0FF means return country table for country BX
;	  No Carry:
;	     Register BX will contain the 16-bit country code.
;	     Register AL will contain the low 8 bits of the country code.
;	     The block pointed to by DS:DX is filled in with the information
;	     for the particular country.
;		BYTE  Size of this table excluding this byte and the next
;		BYTE  Country code represented by this table
;			A sequence of n bytes, where n is the number specified
;			by the first byte above and is not > internat_block_max,
;			in the correct order for being returned by the
;			INTERNATIONAL call as follows:
;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
;		5 BYTE	Currency symbol null terminated
;		2 BYTE	thousands separator null terminated
;		2 BYTE	Decimal point null terminated
;		2 BYTE	Date separator null terminated
;		2 BYTE	Time separator null terminated
;		1 BYTE	Bit field.  Currency format.
;			Bit 0.	=0 $ before #  =1 $ after #
;			Bit 1.	no. of spaces between # and $ (0 or 1)
;		1 BYTE	No. of significant decimal digits in currency
;		1 BYTE	Bit field.  Time format.
;			Bit 0.	=0 12 hour clock  =1 24 hour
;		DWORD	Call address of case conversion routine
;		2 BYTE	Data list separator null terminated.
;	  Carry:
;	     Register AX has the error code.
;	IF DX = -1 on input (set current country)
;	  AL = 0 is an error
;	  0<AL<0FFH means set current country to country AL
;	  AL = 0FF means set current country to country BX
;	  No Carry:
;	    Current country SET
;	    Register AL will contain the low 8 bits of the country code.
;	  Carry:
;	     Register AX has the error code.
;-----------------------------------------------------------------------------

procedure   $INTERNATIONAL,NEAR   ; DOS 3.3


	CMP	AL,0FFH
	JZ	BX_HAS_CODE		; -1 means country code is in BX
	MOV	BL,AL			; Put AL country code in BX
	XOR	BH,BH
BX_HAS_CODE:
	PUSH	DS
	POP	ES
	PUSH	DX
	POP	DI			; User buffer to ES:DI

;hkn; SS is DOSDATA
	context DS

	CMP	DI,-1
	JZ	international_set
	OR	BX,BX
	JNZ	international_find

;hkn; country_cdpg is in DOSDATA segment.
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG

	JMP	SHORT international_copy

international_find:
	MOV	BP,0			 ; flag it for GetCntry only
	CALL	international_get
	JC	errtn
	CMP	BX,0			 ; nlsfunc finished it ?
	JNZ	SHORT international_copy ; no, copy by myself
	MOV	BX,DX			 ; put country back
	JMP	SHORT international_ok3

international_get:

;hkn; country_cdpg is in DOSDATA segment.
;hkn; use ss override to access COUNTRY_CDPG fields
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG
	CMP	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override

	retz				 ; return if equal
	MOV	DX,BX
	XOR	BX,BX			 ; bx = 0, default code page
	CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	CMP	AL,0FFH
	JNZ	interr			   ; not in memory
	or	bp,bp			 ; GetCntry ?
	JNZ	stcdpg
	CallInstall GetCntry,NLSFUNC,4	 ; get country info
	JMP	short chkok
stcdpg:
	CallInstall SetCodePage,NLSFUNC,3  ; set country info
chkok:
	or	al,al			   ; success ?
	retz				   ; yes
setcarry:
	STC				 ; set carry
	ret
interr:
	MOV	AL,0FFH 		   ; flag nlsfunc error
	JMP	setcarry

international_copy:

;hkn; country_cdpg is in DOSDATA segment.
;hkn; use ss override to access COUNTRY_CDPG fields
	MOV	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG.ccDFormat

	MOV	CX,OLD_COUNTRY_SIZE

;hkn;	must set up DS to SS so that international info can be copied
	push	ds
	push	ss					; cs -> ss
	pop	ds

	REP	MOVSB			 ;copy country info

;hkn;	restore ds
	pop	ds

international_ok3:
	call	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_BX],BX
international_ok:
	MOV	AX,BX		     ; Return country code in AX too.
	transfer SYS_RET_OK

international_set:

;hkn; ASSUME	DS:DOSGROUP
ASSUME	DS:DOSDATA

	MOV	BP,1		     ; flag it for SetCodePage only
	CALL	international_get
	JNC	international_ok
errtn:
	CMP	AL,0FFH
	JZ	errtn2
	transfer SYS_RET_ERR	     ; return what we got from NLSFUNC
errtn2:
	error	error_Invalid_Function	; NLSFUNC not existent

EndProc $INTERNATIONAL



BREAK <$GetExtCntry - return extended country-dependent information>
;---------------------------------------------------------------------------
;
; Procedure Name : $GetExtCntry
;
; Inputs:
;	if AL >= 20H
;	  AL= 20H    capitalize single char, DL= char
;	      21H    capitalize string ,CX= string length
;	      22H    capitalize ASCIIZ string
;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
;	      80H bit 0 = use normal upper case table
;		      1 = use file upper case table
;	   DS:DX points to string
;
;	else
;
;	MOV	AH,GetExtCntry	 ; DOS 3.3
;	MOV	AL,INFO_ID	( info type,-1	selects all)
;	MOV	BX,CODE_PAGE	( -1 = active code page )
;	MOV	DX,COUNTRY_ID	( -1 = active country )
;	MOV	CX,SIZE 	( amount of data to return)
;	LES	DI,COUNTRY_INFO ( buffer for returned data )
;	INT	21
; Function:
;	give users extended country dependent information
;	or capitalize chars
; Outputs:
;	  No Carry:
;	     extended country info is succesfully returned
;	  Carry:
;	     Register AX has the error code.
;	     AX=0, NO	 for YES/NO CHECK
;		1, YES
;-------------------------------------------------------------------------------

procedure   $GetExtCntry,NEAR	; DOS 3.3

	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
ifdef DBCS
	jnb	capcap
	jmp	notcap
else
	JB	notcap
endif
capcap: 				;
	TEST	AL,UPPER_TABLE		; which upper case table
	JNZ	fileupper		; file upper case

;hkn; UCASE_TAB in DOSDATA
	MOV	BX,OFFSET DOSDATA:UCASE_TAB+2 ; get normal upper case
	JMP	SHORT capit
fileupper:

;hkn; FILE_UCASE_TAB in DOSDATA
	MOV	BX,OFFSET DOSDATA:FILE_UCASE_TAB+2 ; get file upper case
capit:					;
	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
	JNZ	chkyes			; no
	MOV	AL,DL			; set up AL
	invoke	GETLET3 		; upper case it
	call	get_user_stack		; get user stack
	MOV	byte ptr [SI.user_DX],AL; user's DL=AL
	JMP	SHORT nono		; done
chkyes: 				;
	CMP	AL,CHECK_YES_NO 	; check YES or NO ?
	JNZ	capstring		; no
	XOR	AX,AX			; presume NO
IFDEF  DBCS				;
	PUSH	AX			;
	MOV	AL,DL			;
	invoke	TESTKANJ		; DBCS ?
	POP	AX			;
	JNZ	dbcs_char		; yes, return error
ENDIF					;
		      
;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
;hkn; included in yesno.asm in the DOSCODE segment.

	CMP	DL,cs:NLS_YES		; is 'Y' ?
	JZ	yesyes			; yes
	CMP	DL,cs:NLS_yes2		; is 'y' ?
	JZ	yesyes			; yes
	CMP	DL,cs:NLS_NO		; is  'N'?
	JZ	nono			; no
	CMP	DL,cs:NLS_no2		; is 'n' ?
	JZ	nono			; no
dbcs_char:				;
	INC	AX			; not YES or NO
yesyes: 				;
	INC	AX			; return 1
nono:					;
	transfer SYS_RET_OK		; done
capstring:				;
	MOV	SI,DX			; si=dx
	CMP	AL,CAP_STRING		; cap string ?
	JNZ	capascii		; no
	OR	CX,CX			; check count 0
	JZ	nono			; yes finished
concap: 				;
	LODSB				; get char
 IFDEF  DBCS				;
	invoke	TESTKANJ		; DBCS ?
	JZ	notdbcs 		; no
	INC	SI			; skip 2 chars
	DEC	CX			; bad input, one DBCS char at end
	JNZ	next99			 ; yes

notdbcs:				;
 ENDIF					;

	invoke	GETLET3 		; upper case it
	MOV	byte ptr [SI-1],AL	; store back
next99: 				;
	LOOP	concap			; continue
	JMP	nono			; done
capascii:				;
	CMP	AL,CAP_ASCIIZ		; cap ASCIIZ string ?
	JNZ	capinval		; no
concap2:				;
	LODSB				; get char
	or	al,al			; end of string ?
	JZ	nono			; yes
 IFDEF  DBCS				;
	invoke	TESTKANJ		; DBCS ?
	JZ	notdbcs2		; no
	CMP	BYTE PTR [SI],0 	; bad input, one DBCS char at end
	JZ	nono			; yes
	INC	SI			; skip 2 chars
	JMP	concap2 		;
notdbcs2:				;
 ENDIF					;
	invoke	GETLET3 		; upper case it
	MOV	byte ptr [SI-1],AL	; store back
	JMP	concap2 		; continue


notcap:
	CMP	CX,5			; minimum size is 5
	jb	short sizeerror

GEC_CONT:
;hkn; SS is DOSDATA
	context DS

;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG

	CMP	DX,-1			; active country ?
	JNZ	GETCDPG 		; no

;hkn; use DS override to accesss country_cdpg fields
	MOV	DX,[SI.ccDosCountry]	; get active country id;smr;use DS

GETCDPG:
	CMP	BX,-1			; active code page?
	JNZ	CHKAGAIN		; no, check again

;hkn; use DS override to accesss country_cdpg fields
	MOV	BX,[SI.ccDosCodePage]	; get active code page id;smr;Use DS

CHKAGAIN:
	CMP	DX,[SI.ccDosCountry]	; same as active country id?;smr;use DS
	JNZ	CHKNLS			; no
	CMP	BX,[SI.ccDosCodePage]	; same as active code pg id?;smr;use DS
	JNZ	CHKNLS			; no
CHKTYPE:
	MOV	BX,[SI.ccSysCodePage]	; bx = sys code page id;smr;use DS
;	CMP	AL,SetALL		; select all?
;	JNZ	SELONE
;	MOV	SI,OFFSET DOSGROUP:COUNTRY_CDPG.ccNumber_of_entries
SELONE:
	PUSH	CX			; save cx
	MOV	CX,[SI.ccNumber_of_entries]	;smr;use DS
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG.ccSetUcase;smr;CDPG in DOSDATA
NXTENTRY:
	CMP	AL,[SI] 		; compare info type;smr;use DS
	JZ	FOUNDIT
	ADD	SI,5			; next entry
	LOOP	NXTENTRY
	POP	CX
capinval:
	error	error_Invalid_Function	; info type not found
FOUNDIT:

	MOVSB				; move info id byte
	POP	CX			; retsore char count
	CMP	AL,SetCountryInfo	; select country info type ?
	JZ	setsize
	MOV	CX,4			; 4 bytes will be moved
	MOV	AX,5			; 5 bytes will be returned in CX
OK_RETN:

	REP	MOVSB			; copy info
	MOV	CX,AX			; CX = actual length returned
	MOV	AX,BX			; return sys code page in ax
GETDONE:
	call	get_user_stack		; return actual length to user's CX
	MOV	[SI.user_CX],CX
	transfer SYS_RET_OK
setsize:
	SUB	CX,3			; size after length field
	CMP	WORD PTR [SI],CX	; less than table size;smr;use ds
	JAE	setsize2		; no
	MOV	CX,WORD PTR [SI]	; truncate to table size;smr;use ds
setsize2:
	MOV	ES:[DI],CX		; copy actual length to user's
	ADD	DI,2			; update index
	ADD	SI,2
	MOV	AX,CX
	ADD	AX,3			; AX has the actual length
	JMP	OK_RETN 		; go move it
CHKNLS:
	XOR	AH,AH
	PUSH	AX			   ; save info type
	POP	BP			   ; bp = info type
	CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	CMP	AL,0FFH
	JZ	NLSNXT			   ;	 in memory
sizeerror:
	error	error_Invalid_Function
NLSNXT: CallInstall GetExtInfo,NLSFUNC,2  ;get extended info
	CMP	AL,0			   ; success ?
	JNZ	NLSERROR
	MOV	AX,[SI.ccSysCodePage]	; ax = sys code page id;smr;use ds;BUGBUG;check whether DS is OK after the above calls
	JMP	GETDONE
NLSERROR:
	transfer SYS_RET_ERR		; return what is got from NLSFUNC
EndProc $GetExtCntry

BREAK <$GetSetCdPg - get or set global code page>

;**	$GetSetCdPg - Get or Set Global Code Pagech
;
;   System call format:
;
;	MOV	AH,GetSetCdPg	; DOS 3.3
;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
;	MOV	BX,CODE_PAGE	( set code page only)
;	INT	21
;
;	ENTRY	(al) = n
;		(bx) = code page
;	EXIT	'C' clear
;		  global code page is set	(set global code page)
;		  (BX) = active code page id	(get global code page)
;		  (DX) = system code page id	(get global code page)
;		'C' set
;		  (AX) = error code

procedure   $GetSetCdPg,NEAR   ; DOS 3.3

;hkn; SS is DOSDATA
	context DS

;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG

	CMP	AL,1		       ; get global code page
	JNZ	setglpg 	       ; set global cod epage
	MOV	BX,[SI.ccDosCodePage]  ; get active code page id;smr;use ds
	MOV	DX,[SI.ccSysCodePage]  ; get sys code page id;smr;use ds
	call	get_user_stack
ASSUME DS:NOTHING
	MOV	[SI.user_BX],BX        ; update returned bx
	MOV	[SI.user_DX],DX        ; update returned dx
OK_RETURN:
	transfer SYS_RET_OK
;hkn; ASSUME DS:DOSGROUP
ASSUME	DS:DOSDATA

setglpg:
	CMP	AL,2
	JNZ	nomem
;;;;;;; CMP	BX,[SI.ccDosCodePage]  ; same as active code page
;;;;;;; JZ	OK_RETURN	       ; yes
	MOV	DX,[SI.ccDosCountry]			;smr;use ds
	CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	CMP	AL,0FFH
	JNZ	nomem			   ; not in memory
	CallInstall SetCodePage,NLSFUNC,1  ;set the code page
	or	al,al			   ; success ?
	JZ	OK_RETURN		   ; yes
	CMP	AL,65			   ; set device code page failed
	JNZ	seterr
	MOV	AX,65
	MOV	[EXTERR],AX
	MOV	[EXTERR_ACTION],errACT_Ignore
	MOV	[EXTERR_CLASS],errCLASS_HrdFail
	MOV	[EXTERR_LOCUS],errLOC_SerDev
	transfer   From_GetSet

seterr:
	transfer  SYS_RET_ERR
nomem:
	error	error_Invalid_Function ; function not defined
;
ifdef NTDOS
	SVC	SVC_DEMGSETCDPG
	transfer  SYS_RET_ERR
endif
EndProc $GetSetCdPg


BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>


;**	$Get_Drive_Freespace - Return amount of drive free space
;
;	$Get_Drive_Freespace returns the # of free allocation units on a
;		drive.
;
;	This call returns the same info in the same registers (except for the
;	FAT pointer) as the old FAT pointer calls
;
;	ENTRY	DL = Drive number
;	EXIT	AX = Sectors per allocation unit
;		   = -1 if bad drive specified
;		On User Stack
;		    BX = Number of free allocation units
;		    DX = Total Number of allocation units on disk
;		    CX = Sector size

procedure   $GET_DRIVE_FREESPACE,NEAR

;hkn; SS is DOSDATA
	context DS

	MOV	AL,DL
	invoke	GetThisDrv		; Get drive
SET_AX_RET:
	JC	BADFDRV
	HRDSVC	SVC_DEMGETDRIVEFREESPACE
	jc	badfdrv
	mov	ax,si			; AX = sectors per allocation unit
DoSt:
	call	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_DX],DX
	MOV	[SI.user_CX],CX
	MOV	[SI.user_BX],BX
	MOV	[SI.user_AX],AX
	return
BADFDRV:
;	MOV	AL,error_invalid_drive	; Assume error
	invoke	FCB_RET_ERR
	MOV	AX,-1
	JMP	DoSt
EndProc $GET_DRIVE_FREESPACE

	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>


;**	$Get_DMA - Get Disk Transfer Address
;
;	ENTRY	none
;	EXIT	ES:BX is current transfer address
;	USES	all

procedure   $GET_DMA,NEAR

;hkn; ss override for DMAADD
	MOV	BX,WORD PTR [DMAADD]
	MOV	CX,WORD PTR [DMAADD+2]
	call	get_user_stack
    ASSUME DS:nothing
	MOV	[SI.user_BX],BX
	MOV	[SI.user_ES],CX
	return

EndProc $GET_DMA



;**	$Set_DMA - Set Disk Transfer Address
;
;	ENTRY	DS:DX is current transfer address
;	EXIT	none
;	USES	all

procedure   $SET_DMA,NEAR
;hkn; ss override for DMAADD
	MOV	WORD PTR [DMAADD],DX
	MOV	WORD PTR [DMAADD+2],DS
	return

EndProc $SET_DMA

	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>

;**	$Get_Default_Drive - Get Current Default Drive
;
;	ENTRY	none
;	EXIT	(AL) = drive number
;	USES	all

procedure   $GET_DEFAULT_DRIVE,NEAR

;hkn; SS override
	MOV	AL,[CURDRV]
	return

EndProc $GET_DEFAULT_DRIVE


;**	$Set_Default_Drive - Specify new Default Drive
;
;	$Set_Default_Drive sets a new default drive.
;
;	ENTRY	(DL) = Drive number for new default drive
;       EXIT    (AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
;
; NTVDM EXIT    (al) = 26 always!
;       return max possible as we only have one CDS for all network drives.
;       ntio.sys ignores "lastdrive=" command 18-Aug-1992 Jonle
;

procedure   $SET_DEFAULT_DRIVE,NEAR

        push    dx
        mov     al, dl
        inc     al                      ; A=1, b=2...
	invoke	GetVisDrv		; see if visible drive
ifdef	JAPAN
	; ntraid:mskkbug#3001,3102: Cannot install HANAKO2.0/ICHITARO4.3
	; 10/27/93 yasuho
	;
	; HACK HACK HACK !!!. This code need for MS-DOS5/V compatibility.
	; Basically, error occured SetDefaultDrive(DriveB) if you don't
	; have floppy drive B:. But, MS-DOS5/V was successfully that
	; function call.
	; I know this is fake code, but we need this code for Japanese
	; major DOS application of ICHITARO4.3 and HANAKO2.0
	;
	jnc	sdd_success
	cmp	dl, 1			; Drive B?
	jne	sdd_error		; No. error
	mov	al, dl			; Set current drive (fake!!)
	jmp	sdd_success
sdd_error:
	stc
	jmp	nsetret
sdd_success:
else	;JAPAN
        jc      nsetret                 ; errors do not set
endif	;JAPAN
        ; set the win32 process current drive and directory.
        lds     SI,ThisCDS              ; get current director string
        SVC     SVC_DEMSETDEFAULTDRIVE
        jc      nsetret

        mov     [curdrv],al

nsetret:
        pop     dx
        mov     al, 26                 ; Max num drives possible!
        return

if 0
        MOV     AL,[CDSCOUNT]           ; let user see the count
        cmp     al,5
        jae     sdd_go
        mov     al,5                    ; We have to return at least 5
sdd_go:
	return
SETRET:
	MOV	[CURDRV],AL		; no, set
;	LDS	SI,ThisCDS		; get current director string
        POP     DX

;       SVC     SVC_DEMSETDEFAULTDRIVE

	MOV	AL,[CDSCOUNT]		; let user see what the count really is
	cmp	al,5
	jae	sdd_go
	mov	al,5			; We have to return at least 5
        return
endif

EndProc $SET_DEFAULT_DRIVE

BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>


;**	$Get_Interrupt_Vector - Get Interrupt Vector
;
;	$Get_Interrupt_Vector is the official way for user pgms to get the
;	contents of an interrupt vector.
;
;	ENTRY	(AL) = interrupt number
;	EXIT	(ES:BX) = current interrupt vector

procedure   $GET_INTERRUPT_VECTOR,NEAR

	CALL	RECSET
	LES	BX,DWORD PTR ES:[BX]
	call	get_user_stack
	MOV	[SI.user_BX],BX
	MOV	[SI.user_ES],ES
	return

EndProc $GET_INTERRUPT_VECTOR



;**	$Set_Interrupt_Vector - Set Interrupt Vector
;
;	$Set_Interrupt_Vector is the official way for user pgms to set the
;	contents of an interrupt vector.
;
;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
;	for explanation.
;
;	ENTRY	(AL) = interrupt number
;		(ds:dx) = desired new vector value
;	EXIT	none
;	USES	all

procedure   $SET_INTERRUPT_VECTOR,NEAR

	CALL	RECSET
        invoke  DOCLI                   ; Watch out!!!!! Folks sometimes use
	MOV	ES:[BX],DX		;   this for hardware ints (like timer).
	MOV	ES:[BX+2],DS
        invoke  DOSTI
					; M004, M068 - Start
	test	[DOS_FLAG], EXECA20OFF
					; Q: was the previous call an int 21
					;    exec call
	jnz	@f			; Y: go set count
	return				; N: return

@@:	
	cmp	[A20OFF_COUNT], 0	; Q: is count 0
	jne	@f			; N: done 
	mov	[A20OFF_COUNT], 1	; Y: set it to 1 to indicate to dos 
					; dispatcher to turn A20 Off before 
					; returning to user.
@@:
	ret				; M004, M068 - End
	
EndProc $SET_INTERRUPT_VECTOR


procedure   RECSET,NEAR

	IF	ALTVECT
	context ES

;hkn; SS override for LSTVEC and LSTVEC2
	MOV	[LSTVEC],AL		; Terminate list with real vector
	MOV	[LSTVEC2],AL		; Terminate list with real vector
	MOV	CX,NUMVEC		; Number of possible translations

;hkn; VECIN is in DOSDATA
	MOV	DI,OFFSET DOSDATA:VECIN    ; Point to vectors

	REPNE	SCASB
	MOV	AL,ES:[DI+NUMVEC-1]	; Get translation
	ENDIF

	XOR	BX,BX
	MOV	ES,BX
	MOV	BL,AL
	SHL	BX,1
	SHL	BX,1
	return
EndProc recset

	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>


;**	$Char_Oper - Manipulate Switch Character
;
;	This function was put in to facilitate XENIX path/switch compatibility
;
;	ENTRY	AL = function:
;		    0 - read switch char
;		    1 - set switch char (char in DL)
;		    2 - read device availability
;			Always returns available
;		    3 - set device availability
;			No longer supported (NOP)
;	EXIT	(al) = 0xff iff error
;		(al) != 0xff if ok
;		  (dl) = character/flag, iff "read switch char" subfunction
;	USES	AL, DL
;
;	NOTE	This already obsolete function has been deactivated in DOS 5.0
;		The character / is always returned for subfunction 0,
;		subfunction 2 always returns -1, all other subfunctions are ignored.

procedure   $CHAR_OPER,NEAR

	or	al,al				; get switch?
	mov	dl,'/'				; assume yes
	jz	chop_1				; jump if yes
	cmp	al,2				; check device availability?
	mov	dl,-1				; assume yes
	jz	chop_1				; jump if yes
	return					; otherwise just quit

; subfunctions requiring return of value to user come here.  DL holds
; value to return

chop_1:
	call	Get_User_Stack
	ASSUME	DS:Nothing
	mov	[si].User_DX,dx 		; store value for user
	return


EndProc $CHAR_OPER

BREAK <$GetExtendedError - Return Extended DOS error code>


;**	$GetExtendedError - Return Extended error code
;
;	This function reads up the extended error info from the static
;	variables where it was stored.
;
;	ENTRY	none
;	EXIT	AX = Extended error code (0 means no extended error)
;		BL = recommended action
;		BH = class of error
;		CH = locus of error
;		ES:DI = may be pointer
;	USES	ALL

procedure   $GetExtendedError,NEAR

;hkn; SS is DOSDATA
	Context DS
	MOV	AX,[EXTERR]
	LES	DI,[EXTERRPT]
	MOV	BX,WORD PTR [EXTERR_ACTION]	; BL = Action, BH = Class
	MOV	CH,[EXTERR_LOCUS]
	call	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_DI],DI
	MOV	[SI.user_ES],ES
	MOV	[SI.user_BX],BX
	MOV	[SI.user_CX],CX
	transfer SYS_RET_OK

EndProc $GetExtendedError

BREAK <$Get_Global_CdPg  - Return Global Code Page>
;---------------------------------------------------------------------------
;
; input:    None
; output:   AX = Global Code Page
;
;---------------------------------------------------------------------------

Procedure   Get_Global_CdPg,NEAR
	PUSH	SI

;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG
	MOV	AX,SS:[SI.ccDosCodePage]			;smr;CS->SS
	POP	SI
	return

EndProc Get_Global_CdPg

;-------------------------------Start of DBCS 2/13/KK
BREAK	<ECS_call - Extended Code System support function>

;---------------------------------------------------------------------------
; Inputs:
;	AL = 0	get lead byte table
;		on return DS:SI has the table location
;
;	AL = 1	set / reset interim console flag
;		DL = flag (00H or 01H)
;		no return
;
;	AL = 2	get interim console flag
;		on return DL = current flag value
;
;	AL = OTHER then error, and returns with:
;		AX = error_invalid_function
;
;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
;	 SS:SP WILL BE PRESERVED!
;---------------------------------------------------------------------------

procedure   $ECS_call,NEAR

 IFDEF  DBCS									;AN000;
										;AN000;
	or	al, al			; AL = 0 (get table)?			;AN000;
	je	get_lbt 							;AN000;
	cmp	al, SetInterimMode	; AL = 1 (set / reset interim flag)?	;AN000;
	je	set_interim							;AN000;
	cmp	al, GetInterimMode	; AL = 2 (get interim flag)?		;AN000;
	je	get_interim							;AN000;
	error	error_invalid_function						;AN000;
										;AN000;
get_lbt:				; get lead byte table			;AN000;
	push	ax								;AN000;
	push	bx								;AN000;
	push	ds								;AN000;

;hkn; SS is DOSDATA
	context DS								;AN000;
	MOV	BX,offset DOSDATA:COUNTRY_CDPG.ccSetDBCS			;AN000;
	MOV	AX,[BX+1]		; set EV address to DS:SI		;AN000;smr;use ds
	MOV	BX,[BX+3]							;AN000;smr;use ds
	ADD	AX,2			; Skip Lemgth				;AN000;
	call	get_user_stack							;AN000;
 assume ds:nothing								;AN000;
	MOV	[SI.user_SI], AX						;AN000;
	MOV	[SI.user_DS], BX						;AN000;
	pop	ds								;AN000;
	pop	bx								;AN000;
	pop	ax								;AN000;
	transfer SYS_RET_OK							;AN000;

set_interim:				; Set interim console flag		;AN000;
	push	dx								;AN000;
	and	dl,01			; isolate bit 1 			;AN000;

;hkn; SS override
	mov	[InterCon], dl							;AN000;
	push	ds
;hkn; SS override
	mov	ds, [CurrentPDB]						;AN000;
	mov	byte ptr ds:[PDB_InterCon], dl	; update value in pdb		;AN000;
	pop	ds								;AN000;
	pop	dx								;AN000;
	transfer SYS_RET_OK							;AN000;

get_interim:									;AN000;
	push	dx								;AN000;
	push	ds								;AN000;
;hkn; SS override
	mov	dl,[InterCon]							;AN000;
	call	get_user_stack		; get interim console flag		;AN000;
 assume ds:nothing								;AN000;
	mov	[SI.user_DX],DX 						;AN000;
	pop	ds								;AN000;
	pop	dx								;AN000;
	transfer SYS_RET_OK							;AN000;
 ELSE										;AN000;
	or	al, al			; AL = 0 (get table)?
	jnz	okok
get_lbt:
	call	get_user_stack
 assume ds:nothing

;hkn; dbcs_table moved low to dosdata
	MOV	[SI.user_SI], Offset DOSDATA:DBCS_TAB+2

	push	es
	getdseg <es>			; es = DOSDATA
	assume	es:nothing
	MOV	[SI.user_DS], es
	pop	es

okok:
	transfer SYS_RET_OK		;

 ENDIF

$ECS_call endp

DOSCODE	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\file.asm ===
TITLE   FILE - Pathname related system calls
        NAME    FILE

;**     FILE.ASM - Pathname Related System Calls
;
;       $Open
;       $Creat
;       $ChMod
;       $Unlink
;       $Rename
;       $CreateTempFile
;       $CreateNewFile
;       $Extended_Open
;
;       $LongFileNameAPI
;
;       Revision history:
;
;       sudeepb 06-Mar-1991 Ported for DOSEm.
;       vadimb  01-Sep-1996 Added LFN apis

        .xlist
        .xcref
        include version.inc
        include dosseg.inc
        include dossym.inc
        include devsym.inc
        include sf.inc
        include filemode.inc
        include bugtyp.inc
        include dossvc.inc
        .cref
        .list

        I_need  WFP_Start,WORD          ; pointer to beginning of expansion
        I_Need  ThisCDS,DWORD           ; pointer to curdir in use
        I_need  ThisSft,DWORD           ; SFT pointer for DOS_Open
        I_need  pJFN,DWORD              ; temporary spot for pointer to JFN
        I_need  JFN,WORD                ; word JFN for process
        I_need  SFN,WORD                ; word SFN for process
        I_Need  OpenBuf,128             ; buffer for filename
        I_Need  RenBuf,128              ; buffer for filename in rename
        I_need  Sattrib,BYTE            ; byte attribute to search for
        I_need  Ren_WFP,WORD            ; pointer to real path
        I_need  cMeta,BYTE
        I_need  EXTERR,WORD             ; extended error code
        I_need  EXTERR_LOCUS,BYTE       ; Extended Error Locus
        I_need  EXTERR_CLASS,BYTE
        I_need  EXTERR_ACTION set
        i_need  JShare,DWORD            ; share jump table
        I_need  fSharing,BYTE           ; TRUE => via ServerDOSCall
        I_need  FastOpenTable,BYTE
        I_need  CPSWFLAG,BYTE           ;AN000;FT. cpsw falg
        I_need  EXTOPEN_FLAG,WORD       ;AN000;FT. extended file open flag
        I_need  EXTOPEN_ON,BYTE         ;AN000;FT. extended open flag
        I_need  EXTOPEN_IO_MODE,WORD    ;AN000;FT. IO mode
        I_need  SAVE_ES,WORD            ;AN000;;FT. for get/set XA
        I_need  SAVE_DI,WORD            ;AN000;;FT. for get/set XA
        I_need  SAVE_DS,WORD            ;AN000;;FT. for get/set XA
        I_need  SAVE_SI,WORD            ;AN000;;FT. for get/set XA
        I_need  SAVE_DX,WORD            ;AN000;;FT. for get/set XA
        I_need  SAVE_BX,WORD            ;AN000;;FT. for get/set XA
        I_need  SAVE_CX,WORD            ;AN000;;FT. for get/set XA
        I_need  Temp_Var,WORD           ;AN000;;
        I_need  DOS34_FLAG,WORD         ;AN000;;
        I_need  Temp_Var2,WORD          ;AN000;;

DOSCODE SEGMENT
        ASSUME  SS:DOSDATA,CS:DOSCODE
        EXTRN   DOS_OPEN:NEAR
        EXTRN   DOS_Create:NEAR
        EXTRN   DOS_Create_New:NEAR

        EXTRN   SFNFree:near

        BREAK <$Open - open a file from a path string>


;**     $OPen - Open a File
;
;       given a path name in DS:DX and an open mode in AL, $Open opens the
;       file and and returns a handle
;
;       ENTRY   (DS:DX) = pointer to asciz name
;               (AL) = open mode
;       EXIT    'C' clear if OK
;                 (ax) = file handle
;               'C' set iff error
;                 (ax) = error code
;       USES    all

Procedure   $Open,NEAR
        DOSAssume   <SS>,"Open"

        XOR     AH,AH
Entry $Open2                            ;AN000;
        mov     ch,attr_hidden+attr_system+attr_directory
        call    SetAttrib
        MOV     CX,OFFSET DOSCODE:DOS_Open ; address of routine to call
        SAVE    <AX>                    ; Save mode on stack
IFDEF DBCS                              ;AN000;
        MOV     Temp_Var,0              ;AN000;KK. set variable with 0;smr;SS Override
ENDIF                                   ;AN000;


;*      General file open/create code.  The $CREATE call and the various
;       $OPEN calls all come here.
;
;       We'll share a lot of the standard stuff of allocating SFTs, cracking
;       path names, etc., and then dispatch to our individual handlers.
;       WARNING - this info and list is just a guess, not definitive - jgl
;
;       (TOS) = create mode
;       (CX) = address of routine to call to do actual function
;       (DS:DX) = ASCIZ name
;       SAttrib = Attribute mask

;       Get a free SFT and mark it "being allocated"

AccessFile:
IFDEF  DBCS                             ;AN000;
        TEST    Temp_Var,ATTR_VOLUME_ID ; volume id bit set?
        JZ      novol
        OR      [DOS34_FLAG],DBCS_VOLID ; warn transpath about VOLID
novol:
ENDIF
        call    SFNFree                 ; get a free sfn
        JC      OpenFailJ               ; oops, no free sft's
        mov     es:[di.sf_flags],0      ; Clear flags
        MOV     SFN,BX                  ; save the SFN for later;smr;SS Override
        MOV     WORD PTR ThisSFT,DI     ; save the SF offset    ;smr;SS Override
        MOV     WORD PTR ThisSFT+2,ES   ; save the SF segment   ;smr;SS Override

;       Find a free area in the user's JFN table.

        invoke  JFNFree                 ; get a free jfn
        JNC     SaveJFN
OpenFailJ:
        JMP     OpenFail                ; there were free JFNs... try SFN

SaveJFN:MOV     WORD PTR pJFN,DI        ; save the jfn offset   ;smr;SS Override
        MOV     WORD PTR pJFN+2,ES      ; save the jfn segment  ;smr;SS Override
        MOV     JFN,BX                  ; save the jfn itself   ;smr;SS Override

;       We have been given an JFN.  We lock it down to prevent other tasks from
;       reusing the same JFN.

        MOV     BX,SFN                                          ;smr;SS Override
        MOV     ES:[DI],BL              ; assign the JFN
        MOV     SI,DX                   ; get name in appropriate place
        MOV     DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer
        SAVE    <CX>                    ; save routine to call
        invoke  TransPath               ; convert the path ; AX has return value
        mov     dx,ax
        RESTORE <BX>                    ; (bx) = routine to call
        LDS     SI,ThisSFT                                      ;smr;SS Override
    ASSUME DS:NOTHING
        JC      OpenCleanJ              ; no error, go and open file
        CMP     cMeta,-1                                        ;smr;SS Override
        JZ      SetSearch
        MOV     AL,error_file_not_found ; no meta chars allowed
OpenCleanJ:
        JMP     OpenClean

SetSearch:
        RESTORE <AX>            ; Mode (Open), Attributes (Create)

;       We need to get the new inheritance bits.

        xor     cx,cx
        MOV     [SI].sf_mode,cx         ; initialize mode field to 0
        CMP     BX,OFFSET DOSCODE:DOS_OPEN
        JNZ     DoOper
        TEST    AL,sharing_no_inherit   ; look for no inher
        JZ      DoOper
        AND     AL,07Fh                 ; mask off inherit bit
        MOV     CX,sf_no_inherit
DoOper:

;**     Check if this is an extended open. If so you must set the
;       modes in sf_mode. Call Set_EXT_mode to do all this.

        SAVE    <di, es>                ;M022 conditional removed here
        push    ds
        pop     es
        push    si
        pop     di                      ; (es:di) = SFT address
        call    Set_EXT_mode
        RESTORE <es, di>

        Context DS
        or      dx,dx                   ; IF DX == 0 Then its a device
        jnz     cont_bop
        jmp     DODevice
cont_bop:
        SAVE    <BX,CX,DX>              ; else its a file or UNC
        mov     si,WFP_START            ; default operation. it will
                                        ; come as 1 if pipe was opened.
        push    bp
        xor     dx,dx
        cmp     bx,OFFSET DOSCODE:DOS_Create
        je      CreateCall
        cmp     bx,OFFSET DOSCODE:DOS_Create_New
        jne     OpenCall
        mov     cx,ax                   ; cx = Create Modes
        HRDSVC  SVC_DEMCREATENEW        ; Create New File
        jmp     short common
CreateCall:
        mov     cx,ax                   ; CX = Create Modes
        HRDSVC  SVC_DEMCREATE           ; Create File
        jmp     short common
OpenCall:
        mov     bx,ax                   ; BX + Open Modes
        xor     ax,ax                   ; NO EAs
        HRDSVC  SVC_DEMOPEN             ; Open File or UNC
Common:
        mov     di,bp
        pop     bp
        LDS     SI,ThisSFT
        jc      err_tmp
        mov     word ptr [si].sf_NTHandle,di
        mov     word ptr [si].sf_NTHandle+2,ax
        mov     word ptr [si].sf_Position,0
        mov     word ptr [si].sf_Position+2,0
        mov     word ptr [si].sf_size,cx
        mov     word ptr [si].sf_size+2,bx
        or      dx,dx
        jz      not_a_Pipe
        or      [SI].sf_flags,sf_pipe
not_a_pipe:
        RESTORE <DX,CX,BX>
        push    ds
        Context DS
        mov     di,WFP_START
        cmp     byte ptr ds:[di],'A'
        jb      no_drv
        cmp     byte ptr ds:[di],'Z'
        ja      no_drv
        mov     al,byte ptr ds:[di]
        sub     al,'A'
        xor     ah,ah
        pop     ds
        or      [SI].sf_flags,ax                    ; Mark the driv
        jmp     short drive_marked
no_drv:
        pop     ds
drive_marked:
        and     [SI].sf_flags, not (devid_device OR sf_nt_seek)
        jmp     OpenOK

err_tmp:
        RESTORE <DX,CX,BX>
        jmp     short  OpenE

DODevice:
        cmp     bx,OFFSET DOSCODE:DOS_Create_New
        jne     opCheck
        mov     ax,error_access_denied
        jmp     OpenE2
opCheck:
        cmp     bx,OFFSET DOSCODE:DOS_Create
        jne     odev
        mov     bx,OFFSET DOSCODE:DOS_Open
odev:
        SAVE    <CX>
        CALL    BX                      ; blam!
        RESTORE <CX>
        push    AX
        lahf
        LDS     SI,ThisSFT
        ASSUME  DS:NOTHING
        or      [SI].sf_flags, devid_device        ; Mark it file
        sahf
        pop     ax
        JC      OpenE2                  ;AN000;FT. chek extended open hooks first

;       The SFT was successfully opened.  Remove busy mark.

OpenOK:
        ASSUME  DS:NOTHING
        MOV     [SI].sf_ref_count,1
        OR      [SI].sf_flags,CX        ; set no inherit bit if necessary


        MOV     AX,JFN                  ; SS Override
        MOV     SFN,-1                  ; clear out sfn pointer ;smr;SS Override
        transfer    Sys_Ret_OK          ; bye with no errors
;Extended Open hooks check
OpenE2:
        CMP     AX,error_invalid_parameter ; IFS extended open ?
        JNZ     OpenE                      ; no.
        JMP     short OpenCritLeave                ;AN000;;EO. keep handle

;       Extended Open hooks check
;
;       AL has error code.  Stack has argument to dos_open/dos_create.

OpenClean:
        RESTORE <bx>                    ; clean off stack
OpenE:
        MOV     [SI.SF_Ref_Count],0     ; release SFT
        LDS     SI,pJFN                                         ;smr;SS Override
        MOV     BYTE PTR [SI],0FFh      ; free the SFN...
        JMP     SHORT OpenCritLeave

OpenFail:
        invoke  DOSTI
        RESTORE <CX>            ; Clean stack
OpenCritLeave:
        MOV     SFN,-1                  ; remove mark.
        CMP     [EXTERR],error_Code_Page_Mismatched     ;code page mismatch;smr;SS Override
        JNZ     NORERR                                  ;no
        transfer From_GetSet                            ;yes
NORERR:

;; File Tagging DOS 4.00
        transfer    Sys_Ret_Err         ; no free, return error

EndProc $Open, NoCheck


        BREAK <$Creat - create a brand-new file>


;**     $Creat - Create a File
;
;       $Creat creates the directory entry specified in DS:DX and gives it the
;       initial attributes contained in CX
;
;       ENTRY   (DS:DX) = ASCIZ path name
;               (CX) = initial attributes
;       EXIT    'C' set if error
;                 (ax) = error code
;               'C' clear if OK
;                 (ax) = file handle
;       USES    all

Procedure   $Creat,NEAR
        DOSAssume   <SS>,"Creat"

IFDEF DBCS                              ;
        MOV     Temp_Var,CX             ; set variable with attribute         ;AN000;smr;SS Override
ENDIF                                   ;
        SAVE    <CX>                    ; Save attributes on stack
        MOV     CX,OFFSET DOSCODE:DOS_Create     ; routine to call
AccessSet:
        mov     SAttrib,attr_hidden+attr_system
        JMP     AccessFile              ; use good ol' open

EndProc $Creat, NoCheck


        BREAK <$CHMOD - change file attributes>

;**     $CHMOD - Change File Attributes
;
;   Assembler usage:
;           LDS     DX, name
;           MOV     CX, attributes
;           MOV     AL,func (0=get, 1=set)
;           INT     21h
;   Error returns:
;           AX = error_path_not_found
;           AX = error_access_denied
;

procedure $CHMOD,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        MOV     DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer
        SAVE    <AX,CX>                 ; save function and attributes
        MOV     SI,DX                   ; get things in appropriate places
        invoke  TransPathSet            ; get correct path
        mov     dx,ax                   ; Return value
        RESTORE <CX,AX>                 ; and get function and attrs back
        JC      ChModErr                ; errors get mapped to path not found
        Context DS                      ; set up for later possible calls
        or      dx,dx
        jz      ChModErr_d              ; Chmode not allowed on devices
        CMP     cMeta,-1
        JNZ     ChModErr
        cmp     AL,1                    ; fast way to discriminate
        Jbe     ChModGo                 ; 0 -> go get value
        MOV     EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus
        error   error_invalid_function  ; bad value
ChModGo:
        push    ax
        mov     dx,WFP_START            ; ds:dx file path
        HRDSVC  SVC_DEMCHMOD
        pop     dx
        jc      ChModE
        or      dl,dl
        jnz     chOK
        invoke  Get_User_stack          ; point to user saved vaiables
        assume  DS:NOTHING              ;
        MOV     [SI.User_CX],CX         ; return the attributes
chOK:
        transfer    Sys_Ret_OK          ; say sayonara

ChModErr_d:
        MOV     AX,error_file_not_found
        jmp     short ChmodE

ChModErr:
        mov     al,error_path_not_found
ChmodE:
        Transfer    SYS_RET_ERR
EndProc $ChMod

        BREAK <$UNLINK - delete a file entry>

;**     $UNLINK - Delete a File
;
;
;       Assembler usage:
;           LDS     DX, name
;           MOV     AH, Unlink
;           INT     21h
;
;       ENTRY   (ds:dx) = path name
;       EXIT    'C' clear if no error
;               'C' set if error
;                 (ax) = error code
;                       = error_file_not_found
;                       = error_access_denied

procedure $UNLINK,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA

        MOV     SI,DX                   ; Point at input string
        MOV     DI,OFFSET DOSDATA:OpenBuf  ; temp spot for path
        invoke  TransPathSet            ; go get normalized path
        JNC     unl05                   ; Good path
        mov     al,error_path_not_found
        MOV     EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus
        Transfer    SYS_RET_ERR
unl05:
        or      ax,ax
        jz      ChModErr                ; Cant unlink device
        CMP     cMeta,-1                ; meta chars?
        JNZ     NotFound
        Context DS
        mov     dx,WFP_START            ; ds:dx is file name
        HRDSVC  SVC_DEMDELETE
        JC      UnlinkE                 ; error is there
        xor     ax,ax                   ; DBASE does'nt look at CY
        transfer    Sys_Ret_OK          ; okey doksy
NotFound:
        MOV     AL,error_path_not_found
UnlinkE:
        transfer    Sys_Ret_Err         ; bye

EndProc $UnLink

BREAK <$RENAME - move directory entries around>
;
;   Assembler usage:
;           LDS     DX, source
;           LES     DI, dest
;           MOV     AH, Rename
;           INT     21h
;
;   Error returns:
;           AX = error_file_not_found
;              = error_not_same_device
;              = error_access_denied

procedure $RENAME,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        SAVE    <CX,DS,DX>              ; save source and possible CX arg
        PUSH    ES
        POP     DS                      ; move dest to source
        MOV     SI,DI                   ; save for offsets
        MOV     DI,OFFSET DOSDATA:RenBuf


        invoke  TransPathSet            ; munge the paths
        PUSH    WFP_Start               ; get pointer           ;smr;SS Override
        POP     Ren_WFP                 ; stash it              ;smr;SS Override
        RESTORE <SI,DS,CX>              ; get back source and possible CX arg
epjc2:  JC      ChModErr                ; get old error
        CMP     cMeta,-1                                        ;smr;SS Override
        JNZ     NotFound
        SAVE    <CX>                    ; Save possible CX arg
        MOV     DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer
        invoke  TransPathSet            ; wham
        RESTORE <CX>
        JC      EPJC2
        Context DS
        CMP     cMeta,-1
        JB      NotFound

        PUSH    WORD PTR [THISCDS]         ;AN000;;MS.save thiscds
        PUSH    WORD PTR [THISCDS+2]       ;AN000;;MS.
        MOV     DI,OFFSET DOSDATA:OpenBuf  ;AN000;;MS.
        PUSH    SS                         ;AN000;;MS.
        POP     ES                         ;AN000;;MS.es:di-> source
        XOR     AL,AL                      ;AN000;;MS.scan all CDS
rnloop:                                    ;AN000;
        invoke  GetCDSFromDrv              ;AN000;;MS.
        JC      dorn                       ;AN000;;MS.  end of CDS
        invoke  StrCmp                     ;AN000;;MS.  current dir ?
        JZ      rnerr                      ;AN000;;MS.  yes
        INC     AL                         ;AN000;;MS.  next
        JMP     rnloop                     ;AN000;;MS.
rnerr:                                     ;AN000;
        ADD     SP,4                       ;AN000;;MS. pop thiscds
        error   error_current_directory    ;AN000;;MS.
dorn:                                      ;AN000;
        POP     WORD PTR SS:[THISCDS+2]    ;AN000;;MS.;PBUGBUG;SS REQD??
        POP     WORD PTR SS:[THISCDS]      ;AN000;;MS.;PBUGBUG;SS REQD??
        Context DS
;       mov     ch,attr_directory+attr_hidden+attr_system; rename appropriate files
;       call    SetAttrib
        push    ds
        pop     es
        mov     dx,offset dosdata:OpenBuf
        mov     di,offset dosdata:RenBuf
        HRDSVC  SVC_DEMRENAME           ; do the deed
        JC      UnlinkE                 ; errors


        transfer    Sys_Ret_OK

EndProc $Rename

Break <$CreateNewFile - Create a new directory entry>

;
;   CreateNew - Create a new directory entry.  Return a file handle if there
;       was no previous directory entry, and fail if a directory entry with
;       the same name existed previously.
;
;   Inputs:     DS:DX point to an ASCIZ file name
;               CX contains default file attributes
;   Outputs:    Carry Clear:
;                   AX has file handle opened for read/write
;               Carry Set:
;                   AX has error code
;   Registers modified: All

Procedure $CreateNewFile,NEAR

        ASSUME  CS:DOSCODE,SS:DOSDATA
IFDEF DBCS                              ;AN000;
        MOV     Temp_Var,CX             ;AN000;KK. set variable with attribute;smr;SS Override
ENDIF                                   ;AN000;
        SAVE    <CX>                    ; Save attributes on stack
        MOV     CX,OFFSET DOSCODE:DOS_Create_New   ; routine to call
        JMP     AccessSet               ; use good ol' open

EndProc $CreateNewFile, NoCheck

        Break   <BinToAscii - convert a number to a string>

;**     BinToAscii - conver a number to a string.
;
;       BinToAscii converts a 16 bit number into a 4 ascii characters.
;       This routine is used to generate temp file names so we don't spend
;       the time and code needed for a true hex number, we just use
;       A thorugh O.
;
;       ENTRY   (ax) = value
;               (es:di) = destination
;       EXIT    (es:di) updated by 4
;       USES    cx, di, flags

Procedure   BinToAscii,NEAR
        mov     cx,404h                 ; (ch) = digit counter, (cl) = shift cnt
bta5:   ROL     AX,CL                   ; move leftmost nibble into rightmost
        SAVE    <AX>                    ; preserve remainder of digits
        AND     AL,0Fh                  ; grab low nibble
        ADD     AL,'A'                  ; turn into ascii
        STOSB                           ; drop in the character
        RESTORE <AX>                    ; (ax) = shifted number
        dec     ch
        jnz     bta5                    ; process 4 digits
        return

EndProc BinToAscii

Break   <$CreateTempFile - create a unique name>

;
;   $CreateTemp - given a directory, create a unique name in that directory.
;       Method used is to get the current time, convert to a name and attempt
;       a create new.  Repeat until create new succeeds.
;
;   Inputs:     DS:DX point to a null terminated directory name.
;               CX  contains default attributes
;   Outputs:    Unique name is appended to DS:DX directory.
;               AX has handle
;   Registers modified: all

Procedure $CreateTempFile,NEAR

        ASSUME  CS:DOSCODE,SS:DOSDATA

PUBLIC FILE001S,FILE001E
FILE001S:
        LocalVar    EndPtr,DWORD
        LocalVar    FilPtr,DWORD
        LocalVar    Attr,WORD
FILE001E:
        Enter
        TEST    CX,NOT attr_changeable
        JZ      OKatts                  ; Ok if no non-changeable bits set
;
; We need this "hook" here to detect these cases (like user sets one both of
; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
; below.  The code loops on error_access_denied, but if one of the non
; changeable attributes is specified, the loop COULD be infinite or WILL be
; infinite because CreateNewFile will fail with access_denied always.  Thus we
; need to detect these cases before getting to the loop.
;
        MOV     AX,error_access_denied
        JMP     SHORT SETTMPERR

OKatts:
        MOV     attr,CX                 ; save attribute
        MOV     FilPtrL,DX              ; pointer to file
        MOV     FilPtrH,DS
        MOV     EndPtrH,DS              ; seg pointer to end of dir
        PUSH    DS
        POP     ES                      ; destination for nul search
        MOV     DI,DX
        MOV     CX,DI
        NEG     CX                      ; number of bytes remaining in segment
 IFDEF  DBCS                            ;AN000;
Kloop:                                  ;AN000;; 2/13/KK
        MOV     AL, BYTE PTR ES:[DI]    ;AN000;; 2/13/KK
        INC     DI                      ;AN000;; 2/13/KK
        OR      AL,AL                   ;AN000;; 2/13/KK
        JZ      GOTEND                  ;AN000;; 2/13/KK
        invoke  testkanj                ;AN000;; 2/13/KK
        jz      Kloop                   ;AN000;; 2/13/KK
        inc     di                      ;AN000;; Skip over second kanji byte 2/13/KK
        CMP     BYTE PTR ES:[DI],0      ;AN000;; 2/13/KK
        JZ      STOREPTH                ;AN000; When char before NUL is sec Kanji byte
                                        ;AN000; do not look for path char. 2/13/KK
        jmp     Kloop                   ;AN000; 2/13/KK
GOTEND:                                 ;AN000; 2/13/KK
 ELSE                                   ;AN000;
        OR      CX,CX                   ;AN000;MS.  cx=0 ? ds:dx on segment boundary
        JNZ     okok                    ;AN000;MS.  no
        MOV     CX,-1                   ;AN000;MS.
okok:                                   ;AN000;
        XOR     AX,AX                   ;AN000;
        REPNZ   SCASB                   ;AN000;
 ENDIF                                  ;AN000;
        DEC     DI                      ; point back to the null
        MOV     AL,ES:[DI-1]            ; Get char before the NUL
        invoke  PathChrCmp              ; Is it a path separator?
        JZ      SETENDPTR               ; Yes
STOREPTH:
        MOV     AL,'\'
        STOSB                           ; Add a path separator (and INC DI)
SETENDPTR:
        MOV     EndPtrL,DI              ; pointer to the tail
CreateLoop:
        Context DS                      ; let ReadTime see variables
        SVC     SVC_DEMQUERYTIME        ; cx:dx = time
;
; Time is in CX:DX.  Go drop it into the string.
;
        les     di,EndPtr               ; point to the string
        mov     ax,cx
        call    BinToAscii              ; store upper word
        mov     ax,dx
        call    BinToAscii              ; store lower word
        xor     al,al
        STOSB                           ; nul terminate
        LDS     DX,FilPtr               ; get name
ASSUME  DS:NOTHING
        MOV     CX,Attr                 ; get attr
        SAVE    <BP>
        CALL    $CreateNewFile          ; try to create a new file
        RESTORE <BP>
        JNC     CreateDone              ; failed, go try again
;
; The operation failed and the error has been mapped in AX.  Grab the extended
; error and figure out what to do.
;
                                        ; M049 - start
;;      mov     ax,ExtErr                                       ;smr;SS Override
;;      cmp     al,error_file_exists
;;      jz      CreateLoop              ; file existed => try with new name
;;      cmp     al,error_access_denied
;;      jz      CreateLoop              ; access denied (attr mismatch)
;;;;;;;; for NT
        mov     ax, ExtErr
;;;;;;;;
        CMP     AL,error_file_exists    ; Q: did file already exist
        JZ      CreateLoop              ; Y: try again

SETTMPERR:
        STC
CreateDone:
        Leave
        JC      CreateFail
        transfer    Sys_Ret_OK          ; success!
CreateFail:
        transfer    Sys_Ret_Err
EndProc $CreateTempFile

Break   <SetAttrib - set the search attrib>

;
;   SetAttrib will set the search attribute (SAttrib) either to the normal
;   (CH) or to the value in CL if the current system call is through
;   serverdoscall.
;
;   Inputs:     fSharing == FALSE => set sattrib to CH
;               fSharing == TRUE => set sattrib to CL
;   Outputs:    none
;   Registers changed:  CX

procedure   SetAttrib,NEAR
        assume  SS:DOSDATA                      ;smr;
        test    fSharing,-1                                     ;smr;SS Override
        jnz     Set
        mov     cl,ch
Set:
        mov     SAttrib,cl                                      ;smr;SS Override
        return
EndProc SetAttrib


Break   <Extended_Open- Extended open the file>

; Input: AL= 0 reserved  AH=6CH
;        BX= mode
;        CL= create attribute  CH=search attribute (from server)
;        DX= flag
;        DS:SI = file name
;        ES:DI = parm list
;                          DD  SET EA list (-1) null
;                          DW  n  parameters
;                          DB  type (TTTTTTLL)
;                          DW  IOMODE
; Function: Extended Open
; Output: carry clear
;                    AX= handle
;                    CX=1 file opened
;                       2 file created/opened
;                       3 file replaced/opened
;         carry set: AX has error code
;


procedure   $Extended_Open,NEAR                                ;AN000;

        ASSUME  CS:DOSCODE,SS:DOSDATA   ;AN000;

        MOV     [EXTOPEN_FLAG],DX         ;AN000;EO. save ext. open flag;smr;SS Override
        MOV     [EXTOPEN_IO_MODE],0       ;AN000;EO. initialize IO mode;smr;SS Override
        TEST    DX,reserved_bits_mask     ;AN000;EO. reserved bits 0  ?
        JNZ     ext_inval2                ;AN000;EO. no
        MOV     AH,DL                     ;AN000;EO. make sure flag is right
        CMP     DL,0                      ;AN000;EO. all fail ?
        JZ      ext_inval2                ;AN000;EO. yes, error
        AND     DL,exists_mask            ;AN000;EO. get exists action byte
        CMP     DL,2                      ;AN000;EO, > 02
        JA      ext_inval2                ;AN000;EO. yes ,error
        AND     AH,not_exists_mask        ;AN000;EO. get no exists action byte
        CMP     AH,10H                    ;AN000;EO. > 10
        JA      ext_inval2                ;AN000;EO. yes error

        MOV     [SAVE_ES],ES              ;AN000;EO. save API parms;smr;SS Override
        MOV     [SAVE_DI],DI              ;AN000;EO.;smr;SS Override
        PUSH    [EXTOPEN_FLAG]            ;AN000;EO.;smr;SS Override
        POP     [SAVE_DX]                 ;AN000;EO.;smr;SS Override
        MOV     [SAVE_CX],CX              ;AN000;EO.;smr;SS Override
        MOV     [SAVE_BX],BX              ;AN000;EO.;smr;SS Override
        MOV     [SAVE_DS],DS              ;AN000;EO.;smr;SS Override
        MOV     [SAVE_SI],SI              ;AN000;EO.;smr;SS Override
        MOV     DX,SI                     ;AN000;EO. ds:dx points to file name
        MOV     AX,BX                     ;AN000;EO. ax= mode

        JMP     SHORT goopen2                    ;AN000;;EO.  do nromal
ext_inval2:                                      ;AN000;;EO.
        error   error_Invalid_Function           ;AN000;EO..  invalid function
ext_inval_parm:                                  ;AN000;EO..
        POP     CX                               ;AN000;EO..  pop up satck
        POP     SI                               ;AN000;EO..
        error   error_Invalid_data               ;AN000;EO..  invalid parms
error_return:                                    ;AN000;EO.
        ret                                      ;AN000;EO..  return with error
goopen2:                                         ;AN000;
        TEST    BX,int_24_error                  ;AN000;EO..  disable INT 24 error ?
        JZ      goopen                           ;AN000;EO..  no
        OR      [EXTOPEN_ON],EXT_OPEN_I24_OFF    ;AN000;EO..  set bit to disable;smr;SS Override

goopen:                                          ;AN000;
        OR      [EXTOPEN_ON],EXT_OPEN_ON         ;AN000;EO..  set Extended Open active;smr;SS Override
        AND     [EXTOPEN_FLAG],0FFH              ;AN000;EO.create new ?;smr;SS Override
        CMP     [EXTOPEN_FLAG],ext_exists_fail + ext_nexists_create ;AN000;FT.;smr;SS Override
        JNZ     chknext                          ;AN000;;EO.  no
        invoke  $CreateNewFile                   ;AN000;;EO.  yes
        JC      error_return                     ;AN000;;EO.  error
        CMP     [EXTOPEN_ON],0                   ;AN000;;EO.  IFS does it;smr;SS Override
        JZ      ok_return2                       ;AN000;;EO.  yes
        MOV     [EXTOPEN_FLAG],action_created_opened ;AN000;EO. creted/opened;smr;SS Override
        JMP     setXAttr                         ;AN000;;EO.  set XAs
ok_return2:
        transfer SYS_RET_OK                      ;AN000;;EO.
chknext:
        TEST    [EXTOPEN_FLAG],ext_exists_open   ;AN000;;EO.  exists open;smr;SS Override
        JNZ     exist_open                       ;AN000;;EO.  yes
        invoke  $Creat                           ;AN000;;EO.  must be replace open
        JC      error_return                     ;AN000;;EO.  return with error
        CMP     [EXTOPEN_ON],0                   ;AN000;;EO.  IFS does it;smr;SS Override
        JZ      ok_return2                       ;AN000;;EO.  yes
        MOV     [EXTOPEN_FLAG],action_created_opened  ;AN000;EO. prsume create/open;smr;SS Override
        TEST    [EXTOPEN_ON],ext_file_not_exists      ;AN000;;EO. file not exists ?;smr;SS Override
        JNZ     setXAttr                              ;AN000;;EO. no
        MOV     [EXTOPEN_FLAG],action_replaced_opened ;AN000;;EO. replaced/opened;smr;SS Override
        JMP     SHORT setXAttr                        ;AN000;;EO. set XAs
error_return2:
        STC                         ; Set Carry again to flag error     ;AN001;
        ret                                      ;AN000;;EO.  return with error
                                                 ;AN000;
exist_open:                                      ;AN000;
        test    fSharing,-1                      ;AN000;;EO. server doscall?;smr;SS Override
        jz      noserver                         ;AN000;;EO. no
        MOV     CL,CH                            ;AN000;;EO. cl=search attribute

noserver:
        call    $Open2                           ;AN000;;EO.  do open
        JNC     ext_ok                           ;AN000;;EO.
        CMP     [EXTOPEN_ON],0                   ;AN000;;EO.  error and IFS call;smr;SS Override
        JZ      error_return2                    ;AN000;;EO.  return with error
local_extopen:

        CMP     AX,error_file_not_found          ;AN000;;EO.  file not found error
        JNZ     error_return2                    ;AN000;;EO.  no,
        TEST    [EXTOPEN_FLAG],ext_nexists_create;AN000;;EO.  want to fail;smr;SS Override
        JNZ     do_creat                         ;AN000;;EO.  yes
        JMP     short extexit                    ;AN000;;EO.  yes
do_creat:
        MOV     CX,[SAVE_CX]                     ;AN000;;EO.  get ds:dx for file name;smr;SS Override
        LDS     SI,DWORD PTR [SAVE_SI]           ;AN000;;EO.  cx = attribute;smr;SS Override
        MOV     DX,SI                            ;AN000;;EO.
        invoke  $Creat                           ;AN000;;EO.  do create
        JC      extexit                          ;AN000;;EO.  error
        MOV     [EXTOPEN_FLAG],action_created_opened  ;AN000;;EO. is created/opened;smr;SS Override
        JMP     SHORT setXAttr                        ;AN000;;EO.   set XAs

ext_ok:
        CMP     [EXTOPEN_ON],0                   ;AN000;;EO.  IFS call ?;smr;SS Override
        JZ      ok_return                        ;AN000;;EO.  yes
        MOV     [EXTOPEN_FLAG],action_opened     ;AN000;;EO.  opened;smr;SS Override
setXAttr:
        PUSH    AX                      ;AN000;;EO. save handle for final
        invoke  get_user_stack          ;AN000;;EO.
        MOV     AX,[EXTOPEN_FLAG]       ;AN000;;EO.;smr;SS Override
        MOV     [SI.USER_CX],AX         ;AN000;;EO. set action code for cx
        POP     AX                      ;AN000;;EO.
        MOV     [SI.USER_AX],AX         ;AN000;;EO. set handle for ax

ok_return:                              ;AN000;
        transfer SYS_RET_OK             ;AN000;;EO.

extexit2:                               ;AN000; ERROR RECOVERY

        POP     BX                      ;AN000;EO. close the handle
        PUSH    AX                      ;AN000;EO. save error code from set XA
        CMP     [EXTOPEN_FLAG],action_created_opened    ;AN000;EO. from create;smr;SS Override
        JNZ     justopen                ;AN000;EO.
        LDS     SI,DWORD PTR [SAVE_SI]           ;AN000;EO.  cx = attribute;smr;SS Override
        LDS     DX,DWORD PTR [SI]                ;AN000;EO.
        invoke  $UNLINK                 ;AN000;EO. delete the file
        JMP     SHORT reserror          ;AN000;EO.

justopen:                               ;AN000;
        invoke  $close                  ;AN000;EO. pretend never happend
reserror:                               ;AN000;
        POP     AX                      ;AN000;EO. retore error code from set XA
        JMP     SHORT extexit           ;AN000;EO.


ext_file_unfound:                       ;AN000;
        MOV     AX,error_file_not_found ;AN000;EO.
        JMP     SHORT extexit           ;AN000;EO.
ext_inval:                               ;AN000;
        MOV     AX,error_invalid_function;AN000;EO.
extexit:
        transfer SYS_RET_ERR            ;AN000;EO.

EndProc $Extended_Open                  ;AN000;

procedure   Set_EXT_mode,NEAR

        TEST    [EXTOPEN_ON],ext_open_on    ;AN000;EO. from extnded open
        JZ      NOTEX                       ;AN000;EO. no, do normal
        PUSH    AX                          ;AN000;EO.

        MOV     AX,[SAVE_BX]                ;AN000;EO.
        OR      ES:[DI.sf_mode],AX          ;AN000;EO.
        POP     AX                          ;AN000;EO.
        STC                                 ;AN000;EO.
NOTEX:                                      ;AN000;
        return                              ;AN000;EO.

EndProc Set_EXT_mode                        ;AN000;

procedure $LongFileNameAPI, NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA

        HRDSVC  SVC_DEMLFNENTRY
        jc LFNError
        transfer SYS_RET_OK
LFNError:
        transfer SYS_RET_ERR

EndProc $LongFileNameAPI



DOSCODE ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\ioctl.asm ===
PAGE	,132

	TITLE	IOCTL - IOCTL system call
	NAME	IOCTL

;**	IOCTL system call.
;
;	$IOCTL
;
;	Summary of DOS IOCTL support on NT:
;
;	0   IOCTL_GET_DEVICE_INFO	Supported Truely
;	1   IOCTL_SET_DEVICE_INFO	Supported Truely
;	2   IOCTL_READ_HANDLE		Supported Truely
;	3   IOCTL_WRITE_HANDLE		Supported Truely
;	4   IOCTL_READ_DRIVE		Not Supported (invlid function)
;	5   IOCTL_WRITE_DRIVE		Not Supported (invlid function)
;	6   IOCTL_GET_INPUT_STATUS	Supported Truely
;	7   IOCTL_GET_OUTPUT_STATUS	Supported Truely
;	8   IOCTL_CHANGEABLE?		Supported Truely
;	9   IOCTL_DeviceLocOrRem?	Always returns Local
;	a   IOCTL_HandleLocOrRem?	Always returns Local
;	b   IOCTL_SHARING_RETRY 	Supported Truely
;	c   GENERIC_IOCTL_HANDLE	Supported Truely
;	d   GENERIC_IOCTL		Not Supported (invlid function)
;	e   IOCTL_GET_DRIVE_MAP 	Always returns one letter assigned
;	f   IOCTL_SET_DRIVE_MAP 	Not Supported (invlid function)
;	10  IOCTL_QUERY_HANDLE		Supported Truely
;	11  IOCTL_QUERY_BLOCK		Not Supported (invlid function)
;
;	Revision history:
;
;	sudeepb 06-Mar-1991 Ported for NT
;


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
ifdef NEC_98
	include bpb.inc
	include dpb.inc
endif   ;NEC_98
	include mult.inc
	include sf.inc
	include vector.inc
	include curdir.inc
	include ioctl.inc
	include dossvc.inc
	.cref
	.list

	i_need	THISCDS,DWORD
	i_need	IOCALL,BYTE
	i_need	IOSCNT,WORD
	i_need	IOXAD,DWORD
	I_need	RetryCount,WORD
	I_need	RetryLoop,WORD
	I_need	EXTERR_LOCUS,BYTE
	I_need	OPENBUF,BYTE
	I_need	ExtErr,WORD
	I_need	DrvErr,BYTE
	I_need	USER_IN_AX,WORD 		;AN000;
	I_need	Temp_Var2,WORD			;AN000;
ifdef NEC_98
	i_need	IOMED,BYTE
endif   ;NEC_98

	EXTRN	CURDRV:BYTE
	extrn	GetThisDrv:near

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

BREAK <IOCTL - munge on a handle to do device specific stuff>
;---------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, Handle
;	    MOV     DX, Data
;
;	(or LDS     DX,BUF
;	    MOV     CX,COUNT)
;
;	    MOV     AH, Ioctl
;	    MOV     AL, Request
;	    INT     21h
;
;   AH = 0  Return a combination of low byte of sf_flags and device driver
;	    attribute word in DX, handle in BX:
;	    DH = high word of device driver attributes
;	    DL = low byte of sf_flags
;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
;	    in BX.
;	 2  Read CX bytes from the device control channel for handle in BX
;	    into DS:DX.  Return number read in AX.
;	 3  Write CX bytes to the device control channel for handle in BX from
;	    DS:DX.  Return bytes written in AX.
;	 4  Read CX bytes from the device control channel for drive in BX
;	    into DS:DX.  Return number read in AX.
;	 5  Write CX bytes to the device control channel for drive in BX from
;	    DS:DX.  Return bytes written in AX.
;	 6  Return input status of handle in BX. If a read will go to the
;	    device, AL = 0FFh, otherwise 0.
;	 7  Return output status of handle in BX. If a write will go to the
;	    device, AL = 0FFh, otherwise 0.
;	 8  Given a drive in BX, return 1 if the device contains non-
;	    removable media, 0 otherwise.
;	 9  Return the contents of the device attribute word in DX for the
;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
;	    network. 8000h is the bit for local use.
;	 A  Return 8000h if the handle in BX is for the network or not.
;	 B  Change the retry delay and the retry count for the system. BX is
;	    the count and CX is the delay.
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_invalid_data
;
;-------------------------------------------------------------------------------
;
;   This is the documentation copied from DOS 4.0 it is much better
;   than the above
;
;	There are several basic forms of IOCTL calls:
;
;
;	** Get/Set device information:	**
;
;	ENTRY	(AL) = function code
;		  0 - Get device information
;		  1 - Set device information
;		(BX) = file handle
;		(DX) = info for "Set Device Information"
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DX) = info for "Get Device Information"
;	USES	ALL
;
;
;	**  Read/Write Control Data From/To Handle  **
;
;	ENTRY	(AL) = function code
;		  2 - Read device control info
;		  3 - Write device control info
;		(BX) = file handle
;		(CX) = transfer count
;		(DS:DX) = address for data
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = count of bytes transfered
;	USES	ALL
;
;
;	**  Read/Write Control Data From/To Block Device  **
;
;	ENTRY	(AL) = function code
;		  4 - Read device control info
;		  5 - Write device control info
;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
;		(CX) = transfer count
;		(DS:DX) = address for data
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = count of bytes transfered
;	USES	ALL
;
;
;	**  Get Input/Output Status  **
;
;	ENTRY	(AL) = function code
;		  6 - Get Input status
;		  7 - Get Output Status
;		(BX) = file handle
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AL) = 00 if not ready
;		  (AL) = FF if ready
;	USES	ALL
;
;
;	**  Get Drive Information  **
;
;	ENTRY	(AL) = function code
;		  8 - Check for removable media
;		  9 - Get device attributes
;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = 0/1 media is removable/fixed (func. 8)
;		  (DX) = device attribute word (func. 9)
;	USES	ALL
;
;
;	**  Get Redirected bit	**
;
;	ENTRY	(AL) = function code
;		  0Ah - Network stuff
;		(BX) = file handle
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DX) = SFT flags word, 8000h set if network file
;	USES	ALL
;
;
;	**  Change sharer retry parameters  **
;
;	ENTRY	(AL) = function code
;		  0Bh - Set retry parameters
;		(CX) = retry loop count
;		(DX) = number of retries
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;	USES	ALL
;
;
;   =================================================================
;
;	**  New Standard Control  **
;
;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
;	FORMS ARE OBSOLETE.
;
;   =================================================================
;
;	ENTRY	(AL) = function code
;		  0Ch - Control Function subcode
;		(BX) = File Handle
;		(CH) = Category Indicator
;		(CL) = Function within category
;		(DS:DX) = address for data, if any
;		(SI) = Passed to device as argument, use depends upon function
;		(DI) = Passed to device as argument, use depends upon function
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (SI) = Return value, meaning is function dependent
;		  (DI) = Return value, meaning is function dependent
;		  (DS:DX) = Return address, use is function dependent
;	USES	ALL
;
;    ============== Generic IOCTL Definitions for DOS 3.2 ============
;     (See inc\ioctl.inc for more info)
;
;	ENTRY	(AL) = function code
;		  0Dh - Control Function subcode
;		(BL) = Drive Number (0 = Default, 1= 'A')
;		(CH) = Category Indicator
;		(CL) = Function within category
;		(DS:DX) = address for data, if any
;		(SI) = Passed to device as argument, use depends upon function
;		(DI) = Passed to device as argument, use depends upon function
;
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DS:DX) = Return address, use is function dependent
;	USES	ALL
;
;---------------------------------------------------------------------------

TABENT	macro ORDINAL, handler_address

;	.errnz	$-IOCTLJMPTABLE-2*ORDINAL
	DW	handler_address

	endm

IOCTLJMPTABLE	label	word
		TABENT	IOCTL_GET_DEVICE_INFO   , ioctl_getset_data	; 0
		TABENT	IOCTL_SET_DEVICE_INFO	, ioctl_getset_data   	; 1
		TABENT	IOCTL_READ_HANDLE	, ioctl_control_string	; 2
		TABENT	IOCTL_WRITE_HANDLE	, ioctl_control_string	; 3
		TABENT	IOCTL_READ_DRIVE	, ioctl_invalid		; 4
		TABENT	IOCTL_WRITE_DRIVE	, ioctl_invalid		; 5
		TABENT 	IOCTL_GET_INPUT_STATUS	, ioctl_status		; 6
		TABENT 	IOCTL_GET_OUTPUT_STATUS , ioctl_status		; 7
		TABENT	IOCTL_CHANGEABLE?	, ioctl_removable_media	; 8
		TABENT	IOCTL_DeviceLocOrRem?	, Ioctl_is_remote	; 9
		TABENT 	IOCTL_HandleLocOrRem?	, IOCTL_Handle_Redir	; a
		TABENT 	IOCTL_SHARING_RETRY	, Set_Retry_Parameters	; b
		TABENT 	GENERIC_IOCTL_HANDLE	, GENERICIOCTLHANDLE	; c
		TABENT	GENERIC_IOCTL		, GENERICIOCTL		; d
		TABENT	IOCTL_GET_DRIVE_MAP	, ioctl_get_logical	; e
		TABENT	IOCTL_SET_DRIVE_MAP	, ioctl_set_logical	; f
		TABENT 	IOCTL_QUERY_HANDLE	, query_handle_support	; 10
		TABENT	IOCTL_QUERY_BLOCK	, query_device_support	; 11

	procedure   $IOCTL,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING


	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
	context DS			;hkn; SS is DOSDATA

	cmp	al, 11h			; al must be between 0 & 11h
	ja	ioctl_bad_funj2		; if not bad function #

	push	AX			; Need to save AL for generic IOCTL
	mov	di, ax			; di NOT a PARM
	and	di, 0ffh		; di = al
	shl	di, 1			; di = index into jmp table
	pop	AX			; Restore AL for generic IOCTL

	jmp	word ptr cs:[IOCTLJMPTABLE+di]


ioctl_bad_funj2:
	JMP	ioctl_bad_fun


ioctl_invalid:
	JMP	ioctl_bad_fun
;--------------------------------------------------------------------------
;
; IOCTL: AL= 0,1
;
; ENTRY : DS = DOSDATA
;
;---------------------------------------------------------------------

ioctl_getset_data:

	invoke	SFFromHandle		; ES:DI -> SFT
	JNC	ioctl_check_permissions ; have valid handle
ioctl_bad_handle:
	error	error_invalid_handle

ioctl_check_permissions:
	CMP	AL,0
	MOV	AL,BYTE PTR ES:[DI].SF_FLAGS; Get low byte of flags
	JZ	ioctl_read		; read the byte

;**RMFHFE**	test	dh, 0feh		;AN000;MS.allow dh=1

	or	dh, dh
	JZ	ioctl_check_device	; can I set with this data?
	error	error_invalid_data	; no DH <> 0

ioctl_check_device:
	test	AL,devid_device 	; can I set this handle?

;**RMFHFE**	JZ	do_exception	; no, it is a file.

	jz	ioctl_bad_funj2
	OR	DL,devid_device 	; Make sure user doesn't turn off the
					;   device bit!! He can muck with the
					;   others at will.
	MOV	[EXTERR_LOCUS],errLOC_SerDev
	MOV	BYTE PTR ES:[DI].SF_FLAGS,DL  ;AC000;MS.; Set flags


;**RMFHFE**do_exception:
;**RMFHFE**	OR	BYTE PTR ES:[DI.sf_flags+1],DH;AN000;MS.;set 100H bit for disk full

	transfer    SYS_RET_OK



ioctl_read:
	MOV	[EXTERR_LOCUS],errLOC_Disk
	XOR	AH,AH
	test	AL,devid_device 	; Should I set high byte
	JZ	ioctl_no_high		; no
	MOV	[EXTERR_LOCUS],errLOC_SerDev
	LES	DI,ES:[DI.sf_devptr]	; Get device pointer
        MOV     AH,BYTE PTR ES:[DI.SDEVATT+1]   ; Get high byte
ifndef NEC_98
        jmp     short dev_cont
ioctl_no_high:
dev_cont:
else    ;NEC_98
ioctl_no_high:
endif   ;NEC_98
	MOV	DX,AX
	invoke	get_user_stack
	MOV	[SI.user_DX],DX
	transfer    SYS_RET_OK


;--------------------------------------------------------------------------
;
; IOCTL: 2,3
;
; ENTRY : DS = DOSDATA
;	  Si = user's DS
;
;--------------------------------------------------------------------------

ioctl_control_string:

	invoke	SFFromHandle		; ES:DI -> SFT
	JC	ioctl_bad_handle	; invalid handle
	TESTB	ES:[DI].SF_FLAGS,devid_device	; can I?
	jz	ioctl_bad_funj2			; No it is a file
	MOV	[EXTERR_LOCUS],errLOC_SerDev
	LES	DI,ES:[DI.sf_devptr]	; Get device pointer
	XOR	BL,BL			; Unit number of char dev = 0
	JMP	ioctl_do_string


;--------------------------------------------------------------------------
;
; IOCTL: AL = 6,7
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

ioctl_status:

	MOV	AH,1
	SUB	AL,6			; 6=0,7=1
	JZ	ioctl_get_status
	MOV	AH,3
ioctl_get_status:
	PUSH	AX
	invoke	GET_IO_SFT
	POP	AX
	JNC	DO_IOFUNC
	JMP	ioctl_bad_handle	; invalid SFT

DO_IOFUNC:
	invoke	IOFUNC
	MOV	AH,AL
	MOV	AL,0FFH
	JNZ	ioctl_status_ret
	INC	AL
ioctl_status_ret:
	transfer SYS_RET_OK

;--------------------------------------------------------------------------
;
; IOCTL: AL = 8,9,e
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

ioctl_get_logical:
        xor     al,al
        jmp     short icm_ok

ioctl_removable_media:
ioctl_is_remote:
        push    ax
	or	bl,bl
	jnz	icm_drvok
	mov	bl,CurDrv	      ; bl = drive (0=a;1=b ..etc)
	inc	bl
icm_drvok:
	dec	bl
	HRDSVC	SVC_DEMIOCTL	      ; bl is zero based drive,
                                      ; al is subfunction

        pop     bx                    ; bx is the sub-function
        jc      icm_err
        cmp     bl,8                  ; if function 9 then only change DX
        je      icm_ok

        invoke  get_user_stack
        MOV     [SI.user_DX],DX       ; Pass back the DX value too.

icm_ok:
	transfer    Sys_Ret_Ok	      ; Done
icm_err:
	transfer    Sys_Ret_Err


ioctl_set_logical:
	invoke	get_user_stack
	mov	[SI.user_AX], 0
	transfer    Sys_Ret_Ok

;------------------------------------------------------------------------
;
; IOCTL: AL = B
;
; ENTRY: DS = DOSDATA
;
;-------------------------------------------------------------------------

Set_Retry_Parameters:
	MOV	RetryLoop,CX		; 0 retry loop count allowed
	OR	DX,DX			; zero retries not allowed
	JZ	IoCtl_Bad_Fun
	MOV	RetryCount,DX		; Set new retry count
doneok:
	transfer	Sys_Ret_Ok	; Done

;--------------------------------------------------------------------------
;
; Generic IOCTL entry point. AL = C, D, 10h, 11h
;
;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
;	SI:DX -> Users Device Parameter Table
;	IOCALL -> IOCTL_Req structure
;
; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
;	call.
;
; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;----------------------------------------------------------------------------

query_handle_support:	; Entry point for handles
GENERICIOCTLHANDLE:

	invoke	SFFromHandle		; Get SFT for device.
	jc	ioctl_bad_handlej

	TESTB	ES:[DI].SF_FLAGS,sf_isnet	; M031;
	jnz	ioctl_bad_fun		; Cannot do this over net.

	test	ES:[DI].SF_FLAGS,devid_device	; Fail it if its a file
	JZ	ioctl_bad_fun

	mov	[EXTERR_LOCUS],ErrLOC_Serdev
	les	di,es:[di.sf_devptr]	; Get pointer to device.
	jmp	short Do_GenIOCTL

Do_GenIOCTL:

	TESTB	ES:[DI.SDEVATT],DEV320	; Can device handle Generic IOCTL funcs
	jz	ioctl_bad_fun

	mov	byte ptr IOCALL.ReqFunc,GENIOCTL ;Assume real Request
	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
	jl	SetIOCtlBlock

	TESTB	ES:[DI.SDEVATT],IOQUERY ; See if device supports a query
	jz	ioctl_bad_fun		  ; No support for query 

	mov	byte ptr IOCALL.ReqFunc,IOCTL_QUERY ; Just a query (5.00)

SetIOCtlBlock:
	PUSH	ES			; DEVIOCALL2 expects Device header block
	PUSH	DI			; in DS:SI
					; Setup Generic IOCTL Request Block
	mov	byte ptr IOCALL.ReqLen,(size IOCTL_Req)
	MOV	byte ptr IOCALL.ReqUnit,BL
	MOV	byte ptr IOCALL.MajorFunction,CH
	MOV	byte ptr IOCALL.MinorFunction,CL
	MOV	word ptr IOCALL.Reg_SI,SI
	MOV	word ptr IOCALL.Reg_DI,DI
	MOV	word ptr IOCALL.GenericIOCTL_Packet,DX
	MOV	word ptr IOCALL.GenericIOCTL_Packet + 2,SI

;hkn; IOCALL is in DOSDATA
	MOV	BX,offset DOSDATA:IOCALL

	PUSH	SS
	POP	ES

ASSUME DS:NOTHING			; DS:SI -> Device header.
	POP	SI
	POP	DS
	jmp	ioctl_do_IO		; Perform Call to device driver

ioctl_bad_fun:
	error	error_invalid_function

ioctl_bad_handlej:
	jmp	ioctl_bad_handle

ioctl_set_DX:
	invoke	get_user_stack
	MOV	[SI.user_DX],DX
	transfer    SYS_RET_OK

ifndef NEC_98
ioctl_drv_err:

	error	error_invalid_drive
endif   ;NEC_98

query_device_support:
GENERICIOCTL:
	mov	[EXTERR_LOCUS],ErrLOC_Disk
	cmp	ch,IOC_DC
	jne	ioctl_bad_fun
        cmp     cl,73h
        je      ioctl_bad_fun
        or      bl,bl
        jz      disk_ioctl_getcd
	dec	bl
	jmp	disk_ioctl_bop
disk_ioctl_getcd:
	mov	bl, CurDrv
disk_ioctl_bop:
	HRDSVC	SVC_DEMIOCTL
	jc	disk_ioctl_error
	transfer    SYS_RET_OK

disk_ioctl_error:
	mov	di, ax
	invoke	SET_I24_EXTENDED_ERROR
;hkn; uss SS override
;hkn;	mov	ax, cs:extErr
	mov	ax, ss:extErr
	transfer    SYS_RET_ERR

;--------------------------------------------------------------------------
; IOCTL: AL = A
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

Ioctl_Handle_redir:
	invoke	SFFromHandle		; ES:DI -> SFT
	JNC	ioctl_got_sft		; have valid handle
	jmp	ioctl_bad_handle

ioctl_got_sft:
	MOV	DX,ES:[DI].SF_FLAGS	; Get flags
	JMP	ioctl_set_DX		; pass dx to user and return

ioctl_bad_funj:
	JMP	ioctl_bad_fun

;--------------------------------------------------------------------------
;
; IOCTL: AL= 4,5
;
; ENTRY: DS = DOSDATA
;	 SI = user's DS
;
;
; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;-------------------------------------------------------------------------

ifdef 0 	; Subfunction 4,5 are not supported on NT

ioctl_get_dev:
 	
	DOSAssume   <DS>,"IOCtl_Get_Dev"

	CALL	Check_If_Net
	JNZ	ioctl_bad_funj		; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
endif

ioctl_do_string:
	TESTB	ES:[DI.SDEVATT],DEVIOCTL; See if device accepts control
	JZ	ioctl_bad_funj		; NO
					; assume IOCTL read
	MOV	[IOCALL.REQFUNC],DEVRDIOCTL

	TEST	AL, 1			; is it func. 4/5 or 2/3
	JZ	ioctl_control_call	; it is read. goto ioctl_control_call

					; it is an IOCTL write
	MOV	[IOCALL.REQFUNC],DEVWRIOCTL

ioctl_control_call:
	MOV	AL,DRDWRHL
ioctl_setup_pkt:
	MOV	AH,BL			; Unit number
	MOV	WORD PTR [IOCALL.REQLEN],AX
	XOR	AX,AX
	MOV	[IOCALL.REQSTAT],AX
ifdef NEC_98
	MOV	[IOMED],AL
endif   ;NEC_98
	MOV	[IOSCNT],CX
	MOV	WORD PTR [IOXAD],DX
	MOV	WORD PTR [IOXAD+2],SI
	PUSH	ES
	POP	DS
ASSUME	DS:NOTHING
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES

	MOV	BX,OFFSET DOSDATA:IOCALL   ; ES:BX -> Call header
ioctl_do_IO:
	invoke	DEVIOCALL2

	TESTB	[IOCALL.REQSTAT],STERR	    ;Error?
	JNZ	Ioctl_string_err

	MOV	AX,[IOSCNT]		; Get actual bytes transferred
	transfer    SYS_RET_OK

Ioctl_string_err:
	MOV	DI,[IOCALL.REQSTAT]	;Get Error
device_err:
	AND	DI,STECODE		; mask out irrelevant bits
	MOV	AX,DI
	invoke	SET_I24_EXTENDED_ERROR

	mov	ax, ss:extErr
	transfer    SYS_RET_ERR

;--------------------------------------------------------------------------
; Proc name : Get_Driver_BL
;
;	DS is DOSDATA
;	BL is drive number (0=default)
;	Returns pointer to device in ES:DI, unit number in BL if carry clear
;	No regs modified
;
;---------------------------------------------------------------------------

ifdef 0
Get_Driver_BL:

	DOSAssume   <DS>,"Get_Driver_BL"
    ASSUME ES:NOTHING

	PUSH	AX
	MOV	AL,BL			; Drive
	invoke	GETTHISDRV
	jc	ioctl_bad_drv
	XOR	BL,BL			; Unit zero on Net device
	MOV	[EXTERR_LOCUS],errLOC_Net
	LES	DI,[THISCDS]
	TESTB	ES:[DI.curdir_flags],curdir_isnet
	LES	DI,ES:[DI.curdir_devptr]; ES:DI -> Dpb or net dev
	JNZ	got_dev_ptr		; Is net
	MOV	[EXTERR_LOCUS],errLOC_Disk
	MOV	BL,ES:[DI.dpb_UNIT]	; Unit number
	LES	DI,ES:[DI.dpb_driver_addr]  ; Driver addr
got_dev_ptr:
	CLC
ioctl_bad_drv:
	POP	AX
	return

;-------------------------------------------------------------------------
; Proc Name : Check_If_Net:
;
;
; Checks if the device is over the net or not. Returns result in ZERO flag.
; If no device is found, the return address is popped off the stack, and a
; jump is made to ioctl_drv_err.
;
; On Entry:
; Registers same as those for Get_Driver_BL
;
; On Exit:
; ZERO flag	- set if not a net device
;		- reset if net device
; ES:DI -> the device
;
;
; BUGBUG: This function assumes the following stack setup on entry
;
;	  SP+2 -> Error return address
;	  SP   -> Normal return address
;
;-------------------------------------------------------------------------

Check_If_Net:
	CALL	Get_Driver_BL
	JC	ioctl_drv_err_pop	; invalid drive letter
	PUSH	ES
	PUSH	DI
	LES	DI,[THISCDS]
	TESTB	ES:[DI.curdir_flags],curdir_isnet
	POP	DI
	POP	ES
	ret

ioctl_drv_err_pop:
	pop	ax			; pop off return address
	jmp	ioctl_drv_err
endif

ioctl_bad_funj3:
	jmp	ioctl_bad_fun

ioctl_string_errj:
	jmp	ioctl_string_err

EndProc $IOCTL


DOSCODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\macro2.asm ===
TITLE	MACRO2 - Pathname and macro related internal routines
	NAME	MACRO2

;**	MACRO2.ASM
;
;	TransFCB
;	TransPath
;	TransPathSet
;	TransPathNoSet
;	Canonicalize
;	PathSep
;	SkipBack
;	CopyComponent
;	Splice
;	$NameTrans
;	DriveFromText
;	TextFromDrive
;	PathPref
;	ScanPathChar
;
;   Revision history:
;
;	Sudeepb 11-Mar-1991 Ported for NT DOSEm
;
;
;   MSDOS performs several types of name translation.  First, we maintain for
;   each valid drive letter the text of the current directory on that drive.
;   For invalid drive letters, there is no current directory so we pretend to
;   be at the root.  A current directory is either the raw local directory
;   (consisting of drive:\path) or a local network directory (consisting of
;   \\machine\path.  There is a limit on the point to which a ..  is allowed.
;
;   Given a path, MSDOS will transform this into a real from-the-root path
;   without .  or ..  entries.	Any component that is > 8.3 is truncated to
;   this and all * are expanded into ?'s.
;
;   The second part of name translation involves subtree aliasing.  A list of
;   subtree pairs is maintained by the external utility SUBST.	The results of
;   the previous 'canonicalization' are then examined to see if any of the
;   subtree pairs is a prefix of the user path.  If so, then this prefix is
;   replaced with the other subtree in the pair.
;
;   A third part involves mapping this "real" path into a "physical" path.  A
;   list of drive/subtree pairs are maintained by the external utility JOIN.
;   The output of the previous translation is examined to see if any of the
;   subtrees in this list are a prefix of the string.  If so, then the prefix
;   is replaced by the appropriate drive letter.  In this manner, we can
;   'mount' one device under another.
;
;   The final form of name translation involves the mapping of a user's
;   logical drive number into the internal physical drive.  This is
;   accomplished by converting the drive number into letter:CON, performing
;   the above translation and then converting the character back into a drive
;   number.
;


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include curdir.inc
	.cref
	.list

	I_need	Splices,BYTE		; TRUE => splices are being done.
	I_need	WFP_Start,WORD		; pointer to beginning of expansion
	I_need	Curr_Dir_End,WORD	; offset to end of current dir
	I_need	ThisCDS,DWORD		; pointer to CDS used
	I_need	NAME1,11		; Parse output of NameTrans
	I_need	OpenBuf,128		; ususal destination of strings
	I_need	ExtFCB,BYTE		; flag for extended FCBs
	I_need	Sattrib,BYTE		; attribute of search
	I_need	fSplice,BYTE		; TRUE => do splice after canonicalize
	I_need	fSharing,BYTE		; TRUE => no redirection allowed
	I_Need	NoSetDir,BYTE		; TRUE => syscall is interested in
					; entry, not contents.	We splice only
					; inexact matches
	I_Need	cMeta,BYTE		; count of meta chars in path
	I_Need	Temp_Var,WORD		;AN000; variable for temporary use 3/31/KK
	I_Need	DOS34_FLAG,WORD 	;AN000; variable for dos34

DOSCODE SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

ifdef DBCS
	EXTRN	TestKanj:near
endif
	EXTRN	PathChrCmp:near

BREAK <TransFCB - convert an FCB into a path, doing substitution>

;
;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
;	gritty substitution.
;
;   Inputs:	DS:DX - pointer to FCB
;		ES:DI - point to destination
;   Outputs:	Carry Set - invalid path in final map
;		Carry Clear - FCB has been mapped into ES:DI
;		    Sattrib is set from possibly extended FCB
;		    ExtFCB set if extended FCB found
;		    ax= 0 means local device found
;			ES:DI - points to WFP_START
;		    ax = -1 means file or UNC
;			ES:DI points to WFP_START
;   Registers modified: most

Procedure   TransFCB,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

PUBLIC MACRO001S,MACRO001E
MACRO001S:
	LocalVar    FCBTmp,16		; M015 - allocate even number of bytes on stack
MACRO001E:
	Enter
	Context ES			; get DOSDATA addressability
	SAVE	<ES,DI> 		; save away final destination
	LEA	DI,FCBTmp		; point to FCB temp area
	MOV	[ExtFCB],0		; no extended FCB found ;smr;SS Override
	MOV	[Sattrib],0		; default search attributes;smr;SS Override
	invoke	GetExtended		; get FCB, extended or not
	JZ	GetDrive		; not an extended FCB, get drive
	MOV	AL,[SI-1]		; get attributes
	MOV	[SAttrib],AL		; store search attributes;smr;SS Override
	MOV	[ExtFCB],-1		; signal extended FCB	;smr;SS Override
GetDrive:
	LODSB				; get drive byte
	invoke	GetThisDrv
	jc	BadPack
	CALL	TextFromDrive		; convert 0-based drive to text
;
; Scan the source to see if there are any illegal chars
;
 IFDEF  DBCS				;
;----------------------------- Start of DBCS 2/13/KK
	SAVE	<SI>			; back over name, ext
	MOV	CX,8			; 8 chars in main part of name
FCBScan:LODSB				; get a byte
	call	TestKanj		;
	jz	notkanj2		;
	DEC	CX			;
	JCXZ	VolidChck		; Kanji half char mess up
	LODSB				; second kanji byte
	jmp	short Nextch
VolidChck:
	TEST	[SAttrib],attr_volume_id ; volume id ?	 ;smr;SS Override
	JZ	Badpack 		 ; no, error
	OR	[DOS34_FLAG],DBCS_VOLID  ; no, error	 ;smr;SS Override
	DEC	CX			 ; cx=-1
	INC	SI			 ; next char
	JMP	SHORT FCBScango
notkanj2:
	invoke	GetCharType		 ;get bits;smr;
	TEST	AL,fFCB
	JZ	BadPack
NextCh:
	LOOP	FCBScan
FCBScango:
	ADD	CX,3			; Three chars in extension
FCBScanE:
	LODSB
	call	TestKanj
	jz	notkanj3
	DEC	CX
	JCXZ	BadPack 		; Kanji half char problem
	LODSB				; second kanji byte
	jmp	short NextChE
notkanj3:
	invoke	GetCharType		 ;get bits;smr;
	TEST	AL,fFCB
	JZ	BadPack
NextChE:
	LOOP	FCBScanE
;----------------------------- End of DBCS 2/13/KK
 ELSE

	MOV	CX,11
	SAVE	<SI>			; back over name, ext
FCBScan:LODSB				; get a byte
	invoke	GetCharType		 ;get bits;smr;
	TEST	AL,fFCB
	JZ	BadPack
NextCh: LOOP	FCBScan
 ENDIF
	RESTORE <SI>
	MOV	BX,DI
	invoke	PackName		; crunch the path
	RESTORE <DI,ES> 		; get original destination
	Context DS			; get DS addressability
	LEA	SI,FCBTmp		; point at new pathname
	CMP	BYTE PTR [BX],0
	JZ	BadPack
	SAVE	<BP>
	CALL	TransPathSet		; convert the path
	RESTORE <BP>
	JNC	FCBRet			; bye with transPath error code
BadPack:
	STC
	MOV	AL,error_path_not_found
FCBRet: Leave
	return
EndProc TransFCB,NoCheck

BREAK <TransPath - copy a path, do string sub and put in current dir>

;
;   TransPath - copy a path from DS:SI to ES:DI, performing component string
;	substitution, insertion of current directory and fixing .  and ..
;	entries.  Perform splicing.  Allow input string to match splice
;	exactly.
;
;   TransPathSet - Same as above except No splicing is performed if input path
;	matches splice.
;
;   TransPathNoSet - No splicing/local using is performed at all.
;
;   The following anomalous behaviour is required:
;
;	Drive letters on devices are ignored.  (set up DummyCDS)
;	Paths on devices are ignored. (truncate to 0-length)
;	Raw net I/O sets ThisCDS => NULL.
;	fSharing => dummyCDS and no subst/splice.  Only canonicalize.
;
;   Other behaviour:
;
;	ThisCDS set up.
;	ValidateCDS done on local CDS.
;
;   Brief flowchart:
;
;	if fSharing then
;	    set up DummyCDS (ThisCDS)
;	    canonicalize (sets cMeta)
;	    splice
;	    return
;	if \\ or d:\\ lead then
;	    set up null CDS (ThisCDS)
;	    canonicalize (sets cMeta)
;	    return
;	if device then
;	    set up dummyCDS (ThisCDS)
;	    canonicalize (sets cMeta)
;	    return
;	if file then
;	    getCDS (sets (ThisCDS) from name)
;	    validateCDS (may reset current dir)
;	    Copy current dir
;	    canonicalize (set cMeta)
;	    splice
;	    generate correct CDS (ThisCDS)
;	    if local then
;	    return
;
;   Inputs:	DS:SI - point to ASCIZ string path
;		DI - point to buffer in DOSDATA
;   Outputs:	Carry Set
;		  invalid path specification: too many .., bad
;		  syntax, etc. or user FAILed to I 24. DS:SI may be modified
;		Carry Clear
;		  ax= 0 means local device found
;		    ES:DI - points to WFP_START
;		  ax = -1 means file or UNC
;		    ES:DI points to WFP_START
;		  DS - DOSDATA
;   Registers modified: most
;
;  **** WARNING **** 14-Jan-1994 Jonle **** NTVDM port
;  Transpath does not verify that the path\drive actually exists, which
;  means that dos file apis which rely on Transpath for this validation
;  will not get a error_path_not_found error from transpath, and if special
;  handling is not done an incorrect error code will be generated
;  (usually error_access_denied). See $Mkdir,$Rmdir for an example of proper
;  error handling.
;

Procedure   TransPath,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	XOR	AL,AL
	JMP	SHORT SetSplice
	Entry	TransPathSet
	MOV	AL,-1
SetSplice:
	MOV	NoSetDir,AL		;   NoSetDir = !fExact; ;smr;SS Override
	MOV	AL,-1
	Entry	TransPathNoSet

	MOV	fSplice,AL		;   fSplice = TRUE;	;smr;SS Override
	MOV	cMeta,-1					;smr;SS Override
	MOV	WFP_Start,DI					;smr;SS Override
	MOV	Curr_Dir_End,-1 	; crack from start	;smr;SS Override
	Context ES
	LEA	BP,[DI+TEMPLEN] 	; end of buffer
;
; At this point the name is either a UNC-style name (prefixed with two leading
; \\s) or is a local file/device.
;
        CALL    DriveFromText           ; eat drive letter
	PUSH	AX			; save it
	MOV	AX,WORD PTR [SI]	; get first two bytes of path
	call	PathChrCmp		; convert to normal form
	XCHG	AH,AL			; swap for second byte
	call	PathChrCmp		; convert to normal form
	JNZ	CheckDevice		; not a path char
	CMP	AH,AL			; are they same?
	JNZ	CheckDevice		; nope
;
; We have a UNC request.
	POP	AX
	MOVSW				; get the lead \\
UNCCpy: LODSB				; get a byte
 IFDEF  DBCS				;AN000;
;----------------------------- Start of DBCS 2/23/KK
	call	TestKanj		;AN000;
	jz	notkanj1		;AN000;
	STOSB				;AN000;
	LODSB				;AN000;
	OR	AL,AL			;AN000;
	JZ	UNCTerm 		;AN000;; Ignore half kanji error for now
	STOSB				;AN000;
	jmp	UNCCpy			;AN000;
notkanj1:				;AN000;
;----------------------------- End of DBCS 2/23/KK
 ENDIF					;AN000;
	invoke	UCase			;AN000;; convert the char
	OR	AL,AL
	JZ	UNCTerm 		; end of string.  All done.
	STOSB
	JMP	UNCCpy			; no, go copy
UNCTerm:
	STOSB				;AN000;
	mov	ax,-1			;No Carry and ax = -1
	ret


CheckDevice:
;
; Check DS:SI for device.  First eat any path stuff
;
	POP	AX			; retrieve drive info
	CMP	BYTE PTR DS:[SI],0	; check for null file
	JNZ	CheckPath
	MOV	AL,error_file_not_found ; bad file error
	STC				; signal error on null input
	RETURN				; bye!
CheckPath:
	SAVE	<AX,BP> 		; save drive number
	Invoke	CheckThisDevice 	; snoop for device
	RESTORE <BP,AX> 		; get drive letter back
	JNC	DoFile			; yes we have a file.
;
; We have a device.  AX has drive letter.  At this point we may fake a CDS ala
; sharing DOS call.
;
; If DX != 0 then path not found

	or	dx, dx
	jz	DEV_CONT2
DEV_Err:
        MOV     AL,error_path_not_found
	STC				; signal error on null input
	RETURN				; bye!

DEV_CONT2:
        MOV     fSharing,-1             ; simulate sharing dos call;smr;SS Override
	invoke	GetThisDrv		; set ThisCDS and init DUMMYCDS
        MOV     fSharing,0              ;
        jc      DEV_Err

;
; Now that we have noted that we have a device, we put it into a form that
; getpath can understand.  Normally getpath requires d:\ to begin the input
; string.  We relax this to state that if the d:\ is present then the path
; may be a file.  If D:/ (note the forward slash) is present then we have
; a device.
;
	CALL	TextFromDrive
	MOV	AL,'/'			; path sep.
	STOSB

	invoke	StrCpy			; Copy Device Name to Buffer
	xor	ax,ax			; Clear Carry and ax = 0
	Context DS			; remainder of OK stuff
	return
;
; We have a file.  Get the raw CDS.
;
DoFile:
	ASSUME	DS:NOTHING
	invoke	GetVisDrv		; get proper CDS
	MOV	AL,error_path_not_found ; Set up for possible bad file error
	retc				; CARRY set -> bogus drive/spliced
;
; ThisCDS has correct CDS.  DS:SI advanced to point to beginning of path/file.
; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
; Use the one that we are going to use (ES:DI).
;
;        SAVE    <DS,SI,ES,DI>           ; save all string pointers.
;        invoke  ValidateCDS             ; poke CDS amd make everything OK
;        RESTORE <DI,ES,SI,DS>   ; get back pointers
;        MOV     AL,error_path_not_found ; Set up for possible bad path error
;        retc                            ; someone failed an operation
;
; ThisCDS points to correct CDS.  It contains the correct text of the
; current directory.  Copy it in.
;
	SAVE	<DS,SI>
	LDS	SI,ThisCDS		; point to CDS		;smr;SS Override
	MOV	BX,DI			; point to destination
	ADD	BX,[SI].curdir_end	; point to backup limit
;	LEA	SI,[SI].curdir_text	; point to text
	LEA	BP,[DI+TEMPLEN] 	; regenerate end of buffer
 IFDEF  DBCS				;AN000;
;------------------------ Start of DBCS 2/13/KK
Kcpylp: 				;AN000;
	LODSB				;AN000;
	call	TestKanj		;AN000;
	jz	Notkanjf		;AN000;
	STOSB				;AN000;
	MOVSB				;AN000;
	CMP	BYTE PTR [SI],0 	;AN000;
	JNZ	Kcpylp			;AN000;
	MOV	AL, '\'                 ;AN000;
	STOSB				;AN000;
	JMP	SHORT GetOrig		;AN000;
Notkanjf:				;AN000;
	STOSB				;AN000;
	OR	AL,AL			;AN000;
	JNZ	Kcpylp			;AN000;
	DEC	DI			;AN000;; point to NUL byte

;------------------------ End of DBCS 2/13/KK
 ELSE					;AN000;
	invoke	FStrCpy 		; copy string.	ES:DI point to end
	DEC	DI			; point to NUL byte
 ENDIF					;AN000;
;
; Make sure that there is a path char at end.
;
	MOV	AL,'\'
	CMP	ES:[DI-1],AL
	JZ	GetOrig
	STOSB
;
; Now get original string.
;
GetOrig:
	DEC	DI			; point to path char
	RESTORE <SI,DS>
;
; BX points to the end of the root part of the CDS (at where a path char
; should be) .	Now, we decide whether we use this root or extend it with the
; current directory.  See if the input string begins with a leading \
;
	CALL	PathSep 		; is DS:SI a path sep?
	JNZ	PathAssure		; no, DI is correct. Assure a path char
	OR	AL,AL			; end of string?
	JZ	DoCanon 		; yes, skip.
;
; The string does begin with a \.  Reset the beginning of the canonicalization
; to this root.  Make sure that there is a path char there and advance the
; source string over all leading \'s.
;
	MOV	DI,BX			; back up to root point.
SkipPath:
	LODSB
	call	PathChrCmp
	JZ	SkipPath
	DEC	SI
	OR	AL,AL
	JZ	DoCanon
;
; DS:SI start at some file name.  ES:DI points at some path char.  Drop one in
; for yucks.
;
PathAssure:
	MOV	AL,'\'
	STOSB
;
; ES:DI point to the correct spot for canonicalization to begin.
; BP is the max extent to advance DI
; BX is the backup limit for ..
;
DoCanon:
	CALL	Canonicalize		; wham.
	retc				; badly formatted path.
;
; The string has been moved to ES:DI.  Reset world to DOS context, pointers
; to wfp_start and do string substitution.  BP is still the max position in
; buffer.
;
	Context DS
	MOV	DI,wfp_start		; DS:SI point to string
	LDS	SI,ThisCDS		; point to CDS
	ASSUME	DS:NOTHING
;	LEA	SI,[SI].curdir_text	; point to text
	CALL	PathPref		; is there a prefix?
	JNZ	DoSplice		; no, do splice
;
; We have a match. Check to see if we ended in a path char.
;
 IFDEF  DBCS				;AN000;
;---------------------------- Start of DBCS 2/13/KK
	PUSH	BX			;AN000;
	MOV	BX,SI			;AN000;
	MOV	SI,WORD PTR ThisCDS	;AN000;; point to CDS	;smr;SS Override
LOOKDUAL:				;AN000;
	MOV	AL,BYTE PTR [SI]	;AN000;
	call	TestKanj		;AN000;
	JZ	ONEINC			;AN000;
	INC	SI			;AN000;
	INC	SI			;AN000;
	CMP	SI,BX			;AN000;
	JB	LOOKDUAL		;AN000;
	POP	BX			;AN000;; Last char was KANJI, don't look back
	JMP	SHORT Pathline		;AN000;;  for path sep, there isn't one.
					;AN000;
ONEINC: 				;AN000;
	INC	SI			;AN000;
	CMP	SI,BX			;AN000;
	JB	LOOKDUAL		;AN000;
	POP	BX			;AN000;
;------------------------ End of DBCS 2/13/KK
 ENDIF					;AN000;
	MOV	AL,DS:[SI-1]		; last char to match
	call	PathChrCmp		; did we end on a path char? (root)
	JZ	DoSplice		; yes, no current dir here.
Pathline:				; 2/13/KK
	CMP	BYTE PTR ES:[DI],0	; end at NUL?
	JZ	DoSplice
	INC	DI			; point to after current path char
	MOV	Curr_Dir_End,DI 	; point to correct spot ;smr;SS Override
;
; Splice the result.
;
DoSplice:
	Context DS			; back to DOSDATA
	MOV	SI,wfp_Start		; point to beginning of string
	XOR	CX,CX
	TEST	fSplice,-1
	JZ	SkipSplice
	CALL	Splice			; replaces in place.
SkipSplice:
	ASSUME	DS:NOTHING
	Context DS
;	LES	DI,ThisCDS		; point to correct drive
;	TEST	ES:[DI].curdir_flags,curdir_isnet
;	JNZ	Done			; net (retnz)
;	JCXZ	Done
;	MOV	AL,error_path_not_found ; Set up for possible bad path error
	mov	ax,-1
	clc
Done:	return				; any errors in carry flag.
EndProc TransPath

BREAK <Canonicalize - copy a path and remove . and .. entries>

;
;   Canonicalize - copy path removing . and .. entries.
;
;   Inputs:	DS:SI - point to ASCIZ string path
;		ES:DI - point to buffer
;		BX - backup limit (offset from ES) points to slash
;		BP - end of buffer
;   Outputs:	Carry Set - invalid path specification: too many .., bad
;		    syntax, etc.
;		Carry Clear -
;		    DS:DI - advanced to end of string
;		    ES:DI - advanced to end of canonicalized form after nul
;   Registers modified: AX CX DX (in addition to those above)

Procedure Canonicalize,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
;
; We copy all leading path separators.
;
	LODSB				;   while (PathChr (*s))
	call	PathChrCmp
 IFDEF  DBCS
	JNZ	CanonDec0		; 2/19/KK
 ELSE
	JNZ	CanonDec
 ENDIF
	CMP	DI,BP			;	if (d > dlim)
	JAE	CanonBad		;	    goto error;
	STOSB
	JMP	Canonicalize		;	    *d++ = *s++;
 IFDEF  DBCS				;AN000;
CanonDec0:				;AN000; 2/19/KK
;	mov	cs:Temp_Var,di		;AN000; 3/31/KK
 ENDIF					;AN000;
CanonDec:
	DEC	SI
;
; Main canonicalization loop.  We come here with DS:SI pointing to a textual
; component (no leading path separators) and ES:DI being the destination
; buffer.
;
CanonLoop:
;
; If we are at the end of the source string, then we need to check to see that
; a potential drive specifier is correctly terminated with a path sep char.
; Otherwise, do nothing
;
	XOR	AX,AX
	CMP	[SI],AL 		;	if (*s == 0) {
	JNZ	DoComponent
 IFDEF  DBCS				;AN000;
	call	chk_last_colon		;AN000; 2/18/KK
 ELSE					;AN000;
	CMP	BYTE PTR ES:[DI-1],':'	;	    if (d[-1] == ':')
 ENDIF					;AN000;
;	JNZ	DoTerminate

	jz	Do_Colon
;BUGBUG DBCS???
	CMP	BYTE PTR ES:[DI-1],'\'
	JNZ	DoTerminate
 IFDEF	DBCS
	; ntraid:mskkbug#3300,3302: Cannot CreateDir/BrowseDir
	; Check that really '\' character for DBCS
	; 10/30/93 yasuho
	push	ax
	mov	al, es:[di-2]
	call	TestKanj		; Really '\' ?
	pop	ax
	jnz	DoTerminate		; No. this is DBCS character
 ENDIF
	jmp	short CanonBad

Do_Colon:
	MOV	AL,'\'                  ;               *d++ = '\';
	STOSB
	MOV	AL,AH
DoTerminate:
	STOSB				;	    *d++ = 0;
	CLC				;	    return (0);
	return
 IFDEF  DBCS				;AN000;
;---------------- Start of DBCS 2/18/KK
chk_last_colon	proc			;AN000;
	push	si			;AN000;
	push	ax			;AN000;
	push	bx			;AN000;
	mov	si,[WFP_START]		;AN000;;PTM. for cd ..	use beginning of buf;smr;SS Override
	cmp	si,di			;AN000;; no data stored ?
	jb	CLC02			;AN000;;PTM. for cd ..
	inc	si			;AN000;; make NZ flag
	JMP	SHORT CLC09		;AN000;
CLC02:					;AN000;
	mov	bx,di			;AN000;
	dec	bx			;AN000;
CLC_lop:				;AN000;
	cmp	si,bx			;AN000;
	jb	CLC00			;AN000;
	jne	CLC09			;AN000;
CLC01:					;AN000;
	CMP	BYTE PTR ES:[DI-1],':'	;AN000;;	   if (d[-1] == ':')
	jmp	CLC09			;AN000;
CLC00:					;AN000;
	mov	al,es:[si]		;AN000;
	inc	si			;AN000;
	call	TestKanj		;AN000;
	je	CLC_lop 		;AN000;
	inc	si			;AN000;
	jmp	CLC_lop 		;AN000;
CLC09:					;AN000;
	pop	bx			;AN000;
	pop	ax			;AN000;
	pop	si			;AN000;
	ret				;AN000;
chk_last_colon	endp			;AN000;
;---------------- Endt of DBCS 2/18/KK
 ENDIF					;AN000;

CanonBad:
	CALL	ScanPathChar		; check for path chars in rest of string
	MOV	AL,error_path_not_found ; Set up for bad path error
	JZ	PathEnc 		; path character encountered in string
	MOV	AL,error_file_not_found ; Set bad file error
PathEnc:
	STC
	return
;
; We have a textual component that we must copy.  We uppercase it and truncate
; it to 8.3
;
DoComponent:				;	    }
	CALL	CopyComponent		;	if (!CopyComponent (s, d))
	retc				;	    return (-1);
;
; We special case the . and .. cases.  These will be backed up.
;
	CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
	JZ	Skip1
	CMP	WORD PTR ES:[DI],'..'
	JNZ	CanonNormal
	DEC	DI			;	    d--;
Skip1:	CALL	SkipBack		;	    SkipBack ();
	MOV	AL,error_path_not_found ; Set up for possible bad path error
	retc
	JMP	short CanonPath		;	    }
;
; We have a normal path.  Advance destination pointer over it.
;
CanonNormal:				;	else
	ADD	DI,CX			;	    d += ct;
;
; We have successfully copied a component.  We are now pointing at a path
; sep char or are pointing at a nul or are pointing at something else.
; If we point at something else, then we have an error.
;
CanonPath:
	CALL	PathSep
	JNZ	CanonBad		; something else...
;
; Copy the first path char we see.
;
	LODSB				; get the char
	call	PathChrCmp		; is it path char?
ifdef	DBCS
	JZ	Not_CanonDec
	JMP	CanonDec		; no, go test for nul
Not_CanonDec:
else
	JNZ	CanonDec		; no, go test for nul
endif
	CMP	DI,BP			; beyond buffer end?
	JAE	CanonBad		; yep, error.
	STOSB				; copy the one byte
;
; Skip all remaining path chars
;
CanonPathLoop:
	LODSB				; get next byte
	call	PathChrCmp		; path char again?
	JZ	CanonPathLoop		; yep, grab another
	DEC	SI			; back up
	JMP	CanonLoop		; go copy component
EndProc Canonicalize

BREAK <PathSep - determine if char is a path separator>

;
;   PathSep - look at DS:SI and see if char is / \ or NUL
;   Inputs:	DS:SI - point to a char
;   Outputs:	AL has char from DS:SI (/ => \)
;		Zero set if AL is / \ or NUL
;		Zero reset otherwise
;   Registers modified: AL

Procedure   PathSep,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	MOV	AL,[SI] 		; get the character
	entry	PathSepGotCh		; already have character
	OR	AL,AL			; test for zero
	retz				; return if equal to zero (NUL)
	call	PathChrCmp		; check for path character
	return				; and return HIS determination
EndProc PathSep

BREAK <SkipBack - move backwards to a path separator>

;
;   SkipBack - look at ES:DI and backup until it points to a / \
;   Inputs:	ES:DI - point to a char
;		BX has current directory back up limit (point to a / \)
;   Outputs:	ES:DI backed up to point to a path char
;		AL has char from output ES:DI (path sep if carry clear)
;		Carry set if illegal backup
;		Carry Clear if ok
;   Registers modified: DI,AL

Procedure   SkipBack,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
 IFDEF  DBCS		       ;AN000;
;-------------------------- Start of DBCS 2/13/KK
	PUSH	DS		;AN000;
	PUSH	SI		;AN000;
	PUSH	CX		;AN000;
	PUSH	ES		;AN000;
	POP	DS		;AN000;
	MOV	SI,BX		;AN000;; DS:SI -> start of ES:DI string
	MOV	CX,DI		;AN000;; Limit of forward scan is input DI
	MOV	AL,[SI] 	;AN000;
	call	PathChrCmp	;AN000;
	JNZ	SkipBadP	;AN000;; Backup limit MUST be path char
	CMP	DI,BX		;AN000;
	JBE	SkipBadP	;AN000;
	MOV	DI,BX		;AN000;; Init backup point to backup limit
Skiplp: 			;AN000;
	CMP	SI,CX		;AN000;
	JAE	SkipOK		;AN000;; Done, DI is correct backup point
	LODSB			;AN000;
	call	TestKanj	;AN000;
	jz	Notkanjv	;AN000;
	lodsb			;AN000;; Skip over second kanji byte
	JMP	Skiplp		;AN000;
NotKanjv:			;AN000;
	call	PathChrCmp	;AN000;
	JNZ	Skiplp		;AN000;; New backup point
	MOV	DI,SI		;AN000;; DI point to path sep
	DEC	DI		;AN000;
	jmp	Skiplp		;AN000;
SkipOK: 			;AN000;
	MOV	AL,ES:[DI]	;AN000;; Set output AL
	CLC			;AN000;; return (0);
	POP	CX		;AN000;
	POP	SI		;AN000;
	POP	DS		;AN000;
	return			;AN000;
				;AN000;
SkipBadP:			;AN000;
	POP	CX		;AN000;
	POP	SI		;AN000;
	POP	DS		;AN000;
;-------------------------- End of DBCS 2/13/KK
 ELSE				;AN000;
	CMP	DI,BX			;   while (TRUE) {
	JB	SkipBad 		;	if (d < dlim)
	DEC	DI			;	    goto err;
	MOV	AL,ES:[DI]		;	if (pathchr (*--d))
	call	PathChrCmp		;	    break;
	JNZ	SkipBack		;	}
	CLC				;   return (0);
	return				;
 ENDIF					;AN000;
SkipBad:				;err:
	MOV	AL,error_path_not_found ; bad path error
	STC				;   return (-1);
	return				;
EndProc SkipBack

Break <CopyComponent - copy out a file path component>

;
;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
;
;   Inputs:	DS:SI - source path
;		ES:DI - destination
;		ES:BP - end of buffer
;   Outputs:	Carry Set - too long
;		Carry Clear - DS:SI moved past component
;		    CX has length of destination
;   Registers modified: AX,CX,DX

Procedure   CopyComponent,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
CopyBP	    EQU     WORD PTR [BP]
CopyD	    EQU     DWORD PTR [BP+2]
CopyDoff    EQU     WORD PTR [BP+2]
CopyS	    EQU     DWORD PTR [BP+6]
CopySoff    EQU     WORD PTR [BP+6]
CopyTemp    EQU     BYTE PTR [BP+10]
	SUB	SP,14			; room for temp buffer
	SAVE	<DS,SI,ES,DI,BP>
	MOV	BP,SP
	MOV	AH,'.'
	LODSB
	STOSB
	CMP	AL,AH			;   if ((*d++=*s++) == '.') {
	JNZ	NormalComp
	CALL	PathSep 		;	if (!pathsep(*s))
	JZ	NulTerm
TryTwoDot:
	LODSB				;	    if ((*d++=*s++) != '.'
	STOSB
	CMP	AL,AH
	JNZ	CopyBad
	CALL	PathSep
	JNZ	CopyBad 		;		|| !pathsep (*s))
NulTerm:				;		return -1;
	XOR	AL,AL			;	*d++ = 0;
	STOSB
	MOV	CopySoff,SI
	JMP	SHORT GoodRet		;	}
NormalComp:				;   else {
	MOV	SI,CopySoff
	Invoke	NameTrans		;	s = NameTrans (s, Name1);
	CMP	SI,CopySOff		;	if (s == CopySOff)
	JZ	CopyBad 		;	    return (-1);
	TEST	fSharing,-1		;	if (!fSharing) {;smr;SS Override
	JNZ	DoPack
	AND	DL,1			;	    cMeta += fMeta;
	ADD	cMeta,DL		;	    if (cMeta > 0);smr;SS Override
	JG	CopyBad 		;		return (-1);
	JNZ	DoPack			;	    else
	OR	DL,DL			;	    if (cMeta == 0 && fMeta == 0)
	JZ	CopyBadPath		;		return (-1);
DoPack: 				;	    }
	MOV	CopySoff,SI
	Context DS
	MOV	SI,OFFSET DOSDATA:NAME1
	LEA	DI,CopyTemp
	SAVE	<DI>
	Invoke	PackName		;	PackName (Name1, temp);
	RESTORE <DI>
	Invoke	StrLen			;	if (strlen(temp)+d > bp)
	DEC	CX
	ADD	CX,CopyDoff
	CMP	CX,CopyBP
	JAE	CopyBad 		;	    return (-1);
	MOV	SI,DI			;	strcpy (d, temp);
	LES	DI,CopyD
	Invoke	FStrCpy
GoodRet:				;	}
	CLC
	JMP	SHORT CopyEnd		;   return 0;
CopyBad:
	STC
	CALL	ScanPathChar		; check for path chars in rest of string
	MOV	AL,error_file_not_found ; Set up for bad file error
	JNZ	CopyEnd
CopyBadPath:
	STC
	MOV	AL,error_path_not_found ; Set bad path error
CopyEnd:
	RESTORE <BP,DI,ES,SI,DS>
	LAHF
	ADD	SP,14			; reclaim temp buffer
	Invoke	Strlen
	DEC	CX
	SAHF
	return
EndProc CopyComponent,NoCheck

Break <Splice - pseudo mount by string substitution>

;
;   Splice - take a string and substitute a prefix if one exists.  Change
;	ThisCDS to point to physical drive CDS.
;   Inputs:	DS:SI point to string
;		NoSetDir = TRUE => exact matches with splice fail
;   Outputs:	DS:SI points to thisCDS
;		String at DS:SI may be reduced in length by removing prefix
;		and substituting drive letter.
;		CX = 0 If no splice done
;		CX <> 0 otherwise
;		ThisCDS points to proper CDS if spliced, otherwise it is
;		    left alone
;   Registers modified: DS:SI, ES:DI, BX,AX,CX

Procedure   Splice,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	TEST	Splices,-1					;smr;SS Override
	JZ	AllDone
	SAVE	<<WORD PTR ThisCDS>,<WORD PTR ThisCDS+2>>   ; TmpCDS = ThisCDS;smr;SS Override
	SAVE	<DS,SI>
	RESTORE <DI,ES>
	XOR	AX,AX			;   for (i=1; s = GetCDSFromDrv (i); i++)
SpliceScan:
	invoke	GetCDSFromDrv
	JC	SpliceDone
	INC	AL
	TEST	[SI.curdir_flags],curdir_splice
	JZ	SpliceScan		;	if ( Spliced (i) ) {
	SAVE	<DI>
	CALL	PathPref		;	    if (!PathPref (s, d))
	JZ	SpliceFound		;
SpliceSkip:
	RESTORE <DI>
	JMP	SpliceScan		;		continue;
SpliceFound:
	CMP	BYTE PTR ES:[DI],0	;	    if (*s || NoSetDir) {
	JNZ	SpliceDo
	TEST	NoSetDir,-1					;smr;SS Override
	JNZ	SpliceSkip
SpliceDo:
	MOV	SI,DI			;		p = src + strlen (p);
	SAVE	<ES>
	RESTORE <DS,DI>
	CALL	TextFromDrive1		;		src = TextFromDrive1(src,i);
	MOV	AX,Curr_Dir_End 				;smr;SS Override
	OR	AX,AX
	JS	NoPoke
	ADD	AX,DI			;		curdirend += src-p;
	SUB	AX,SI
	MOV	Curr_Dir_End,AX 				;smr;SS Override
NoPoke:
	CMP	BYTE PTR [SI],0 	;		if (*p)
	JNZ	SpliceCopy		;		    *src++ = '\\';
	MOV	AL,"\"
	STOSB
SpliceCopy:				;		strcpy (src, p);
	invoke	FStrCpy
	ADD	SP,4			; throw away saved stuff
	OR	CL,1			; signal splice done.
	JMP	SHORT DoSet		;		return;
SpliceDone:				;		}
	ASSUME	DS:NOTHING		;   ThisCDS = TmpCDS;
	RESTORE <<WORD PTR ThisCDS+2>,<WORD PTR ThisCDS>>	;smr;SS Override
AllDone:
	XOR	CX,CX
DoSet:
	LDS	SI,ThisCDS		;
	return

EndProc Splice, NoCheck

Break <$NameTrans - partially process a name>

;
;   $NameTrans - allow users to see what names get mapped to.  This call
;   performs only string substitution and canonicalization, not splicing.  Due
;   to Transpath playing games with devices, we need to insure that the output
;   has drive letter and :  in it.
;
;   Inputs:	DS:SI - source string for translation
;		ES:DI - pointer to buffer
;   Outputs:
;	Carry Clear
;		Buffer at ES:DI is filled in with data
;		ES:DI point byte after nul byte at end of dest string in buffer
;	Carry Set
;		AX = error_path_not_found
;   Registers modified: all

Procedure   $NameTrans,Near
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<DS,SI,ES,DI,CX>

; M027 - Start
;
; Sattrib must be set up with default values here. Otherwise, the value from
; a previous DOS call is used for attrib and DevName thinks it is not a 
; device if the old call set the volume attribute bit. Note that devname in
; dir2.asm gets ultimately called by Transpath. See also M026. Also save
; and restore CX.
;

	mov	ch,attr_hidden+attr_system+attr_directory
	invoke	SetAttrib

; M027 - End

	MOV	DI,OFFSET DOSDATA:OpenBuf
	CALL	TransPath		; to translation (everything)
	RESTORE <CX,DI,ES,SI,DS>
	JNC	TransOK
	transfer    SYS_Ret_Err
TransOK:
	MOV	SI,OFFSET DOSDATA:OpenBuf
	Context DS
GotText:
	Invoke	FStrCpy
	Transfer    SYS_Ret_OK
EndProc $NameTrans

Break	<DriveFromText - return drive number from a text string>

;
;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
;   pointer.
;
;   Inputs:	DS:SI point to a text string
;   Outputs:	AL has drive number
;		DS:SI advanced
;   Registers modified: AX,SI.

Procedure   DriveFromText,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	XOR	AL,AL			;	drive = 0;
	CMP	BYTE PTR [SI],0 	;	if (*s &&
	retz
	CMP	BYTE PTR [SI+1],':'	;	    s[1] == ':') {
	retnz
 IFDEF  DBCS				;AN000;
;--------------------- Start of DBCS 2/18/KK
	push	ax		       ;AN000;
	mov	al,[si] 	       ;AN000;
	call	TestKanj	       ;AN000;
	pop	ax		       ;AN000;
	retnz			       ;AN000;
;--------------------- End of DBCS 2/18/KK
 ENDIF				       ;AN000;
	LODSW				;	    drive = (*s | 020) - 'a'+1;
	OR	AL,020h
	SUB	AL,'a'-1		;	    s += 2;
	retnz
	MOV	AL,-1			; nuke AL...
	return				;	    }
EndProc DriveFromText

Break	<TextFromDrive - convert a drive number to a text string>

;
;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
;   trailing :. TextFromDrive1 takes a 1-based number.
;
;   Inputs:	AL has 0-based drive number
;   Outputs:	ES:DI advanced
;   Registers modified: AX

Procedure TextFromDrive,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	INC	AL
	Entry	TextFromDrive1
	ADD	AL,'A'-1		;   *d++ = drive-1+'A';
	MOV	AH,":"			;   strcat (d, ":");
	STOSW
	return
EndProc TextFromDrive

Break	<PathPref - see if one path is a prefix of another>

;
;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
;   other.  Remember that only at a pathchar break are we allowed to have a
;   prefix: A:\ and A:\FOO
;
;   Inputs:	DS:SI potential prefix
;		ES:DI string
;   Outputs:	Zero set => prefix found
;		    DI/SI advanced past matching part
;		Zero reset => no prefix, DS/SI garbage
;   Registers modified: CX

Procedure   PathPref,NEAR
	Invoke	DStrLen 		; get length
	DEC	CX			; do not include nul byte
 IFDEF  DBCS				;AN000;
;----------------------- Start of DBCS 2/13/KK
	SAVE	<AX>			;AN000;; save char register
CmpLp:					;AN000;
	MOV	AL,[SI] 		;AN000;
	call	TestKanj		;AN000;
	jz	NotKanj9		;AN000;
	CMPSW				;AN000;
	JNZ	Prefix			;AN000;
	DEC	CX			;AN000;
	LOOP	CmpLp			;AN000;
	JMP	SHORT NotSep		;AN000;
NotKanj9:				;AN000;
	CMPSB				;AN000;
	JNZ	Prefix			;AN000;
	LOOP	CmpLp			;AN000;
;----------------------- End of DBCS 2/13/KK
 ELSE					;AN000;
	REPZ	CMPSB			; compare
	retnz				; if NZ then return NZ
	SAVE	<AX>			; save char register
 ENDIF					;AN000;
	MOV	AL,[SI-1]		; get last byte to match
	call	PathChrCmp		; is it a path char (Root!)
	JZ	Prefix			; yes, match root (I hope)
NotSep: 				; 2/13/KK
	MOV	AL,ES:[DI]		; get next char to match
	CALL	PathSepGotCh		; was it a pathchar?
Prefix:
	RESTORE <AX>		; get back original
	return
EndProc PathPref

Break	<ScanPathChar - see if there is a path character in a string>

;
;     ScanPathChar - search through the string (pointed to by DS:SI) for
;     a path separator.
;
;     Input:	DS:SI target string (null terminated)
;     Output:	Zero set => path separator encountered in string
;		Zero clear => null encountered
;     Registers modified: SI

Procedure     ScanPathChar,NEAR
	LODSB				; fetch a character
 IFDEF  DBCS				;AN000;
	call	TestKanj		;AN000;; 2/13/KK
	jz	NotKanjr		;AN000;; 2/13/KK
	LODSB				;AN000;; 2/13/KK
	OR	AL,AL			;AN000;; 2/13/KK  3/31/removed
	JNZ	ScanPathChar		;AN000;; 2/13/KK  3/31/removed
	INC	AL			;AN000;; 2/13/KK
	return				;AN000;; 2/13/KK
					;AN000;
NotKanjr:				;AN000;; 2/13/KK
 ENDIF					;AN000;
	call	PathSepGotCh
	JNZ	ScanPathChar		; not \, / or NUL => go back for more
	call	PathChrCmp		; path separator?
	return
EndProc       ScanPathChar

DOSCODE ends
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\handle.asm ===
TITLE   HANDLE - Handle-related system calls
        NAME    HANDLE

;**     Handle related system calls for MSDOS 2.X.  Only top-level system calls
;       are present.    I/O specs are defined in DISPATCH.  The system calls are:
;
;       $Close     written
;       $Commit    written                DOS 3.3  F.C. 6/4/86
;       $ExtHandle written                DOS 3.3  F.C. 6/4/86
;       $Read      written
;       Align_Buffer              DOS 4.00
;       $Write     written
;       $LSeek     written
;       $FileTimes written
;       $Dup       written
;       $Dup2      written
;
;       Revision history:
;
;       sudeepb 13-Mar-1991 Ported For NT DOSEm

        .xlist
        .xcref
        include version.inc
        include dosseg.inc
        include dossym.inc
        include devsym.inc
        include sf.inc
        include mult.inc
        include pdb.inc
        include filemode.inc
        include syscall.inc
        include bugtyp.inc
        include dossvc.inc
        include vint.inc
        .cref
        .list


DOSDATA Segment

        extrn   ThisSFT:dword           ; pointer to SFT entry
        extrn   DMAAdd:dword            ; old-style DMA address
        extrn   EXTERR_LOCUS:byte       ; Extended Error Locus
        extrn   FailErr:byte            ; failed error flag
        extrn   User_ID:word            ; current effective user_id
        extrn   JShare:dword            ; jump table
        extrn   CurrentPDB:word         ; current process data block
        extrn   EXTOPEN_ON:byte         ; flag for extended open
        extrn   THISCDS:dword
        extrn   DUMMYCDS:byte
        extrn   SAVE_ES:word            ; saved ES
        extrn   SAVE_DI:word            ; saved DI
        extrn   SAVE_DS:word            ; saved DS
        extrn   SAVE_SI:word            ; saved SI
        extrn   SAVE_CX:word            ; saved CX

;   Flag to indicate WIN386 presence
;
        extrn   IsWin386:byte

DOSDATA ENDS

DOSCODE SEGMENT
        ASSUME  SS:DOSDATA,CS:DOSCODE

        EXTRN   DOS_Read:NEAR
        EXTRN   DOS_Write:NEAR
        EXTRN   pJfnFromHandle:near
        EXTRN   SFFromHandle:near


        BREAK <$Close - return a handle to the system>


;**     $Close - Close a file Handle
;
;       BUGBUG - close gets called a LOT with invalid handles - sizzle that
;               path
;
;       Assembler usage:
;           MOV     BX, handle
;           MOV     AH, Close
;           INT     int_command
;
;       ENTRY   (bx) = handle
;       EXIT    <normal INT21 return convention>
;       USES    all

Procedure   $Close,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA

;       Grab the SFT pointer from the JFN.

        call    SFFromHandle            ; get system file entry
        DLJC    CloseError              ; error return
        context DS                      ; For DOS_CLOSE
        MOV     WORD PTR [ThisSFT],DI   ; save offset of pointer
        MOV     WORD PTR [ThisSFT+2],ES ; save segment value

; ES:DI point to SFT
;
; We now examine the user's JFN entry; If the file was a 70-mode file (network
; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
; If the file was not a net FCB, we free the JFN too.

;       CMP     ES:[DI].sf_ref_count,1  ; will the SFT become free?
;       JZ      FreeJFN                 ; yes, free JFN anyway.
;       MOV     AL,BYTE PTR ES:[DI].sf_mode
;       AND     AL,sharing_mask
;       CMP     AL,sharing_net_fcb
;       JZ      PostFree                ; 70-mode and big ref count => free it

; The JFN must be freed.  Get the pointer to it and replace the contents with
; -1.

FreeJFN:
        call    pJFNFromHandle          ;   d = pJFN (handle);
        MOV     BYTE PTR ES:[DI],0FFh   ; release the JFN
PostFree:

; ThisSFT is correctly set, we have DS = DOSDATA.  Looks OK for a DOS_CLOSE!
        LES     DI,[THISSFT]
        call    Free_SFT
        test    es:[di.sf_flags],devid_device
        jnz     short devclose

        cmp     ax,1
        jne     CloseOK
        test    es:[di.sf_flags],sf_nt_seek
        mov     cx,0ffffh
        mov     dx,0ffffh
        jz      short close_no_seek
        mov     dx,word ptr es:[di.sf_position]
        mov     cx,word ptr es:[di.sf_position+2]       ; cx:dx is position
close_no_seek:
        push    bp
        mov     bp,word ptr es:[di.sf_NTHandle]
        mov     ax,word ptr es:[di.sf_NTHandle+2]
        HRDSVC  SVC_DEMCLOSE
        pop     bp
        mov     word ptr es:[di.sf_ref_count],0
        jc      CloseError
        jmp     CloseOK

CloseError:
        ASSUME  DS:NOTHING
        transfer    Sys_Ret_Err

CloseOK:
        MOV     AH,close                ; MZ Bogus multiplan fix
        transfer    Sys_Ret_OK

devclose:
        push    ax
        invoke  DEV_Close_SFT
        pop     ax
        cmp     ax,1
        jne     CloseOK
        mov     word ptr es:[di.sf_ref_count],0
        jmp     CloseOK

EndProc $Close

Procedure   FREE_SFT,NEAR
        DOSAssume   <DS>,"Free_SFT"

; sudeepb 22-Dec-1992 removed a pair of costly pushf/popf with lahf/sahf

        push    bx
        lahf
        push    ax
        MOV     AX,ES:[DI.sf_ref_count]
        DEC     AX
        JNZ     SetCount
        DEC     AX
SetCount:
        XCHG    AX,ES:[DI.sf_ref_count]
        mov     bx,ax
        pop     ax
        sahf
        mov     ax,bx
        pop     bx
        return

EndProc Free_SFT

        BREAK <$Commit - commit the file>

;**     $Commit - Commit a File
;
;       $Commit "commits" a file to disk - all of it's buffers are
;       flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
;       the directory entry, etc., so this commit is pretty useless.  check
;       and fix this!! jgl
;
;       Assembler usage:
;           MOV     BX, handle
;           MOV     AH, Commit
;           INT     int_command
;
;       ENTRY   (bx) = handle
;       EXIT    none
;       USES    all

Procedure   $Commit,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA

;       Grab the SFT pointer from the JFN.

        call    SFFromHandle            ; get system file entry
        DLJC    CommitError              ; error return
        context DS                      ; For DOS_CLOSE
        MOV     WORD PTR [ThisSFT],DI   ; save offset of pointer
        MOV     WORD PTR [ThisSFT+2],ES ; save segment value

; ES:DI point to SFT
        TEST    WORD PTR ES:[DI.sf_flags], devid_device + devid_file_clean
        jne     CommitOk
        MOV     BP, WORD PTR ES:[DI.sf_NTHandle]
        MOV     AX, WORD PTR ES:[DI.sf_NTHandle + 2]
        SVC     SVC_DEMCOMMIT
        jc      CommitError

CommitOk:
        mov     AH, Commit
        transfer    SYS_RET_OK

CommitError:
        ASSUME  DS:NOTHING
        transfer    SYS_RET_ERR

EndProc $Commit


        BREAK <$ExtHandle - extend handle count>

;**     $ExtHandle - Extend Handle Count
;
;       Assembler usage:
;           MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
;           MOV     AX, 6700H                    reserved to mark SFT
;           INT     int_command                  busy )
;
;       ENTRY   (bx) = new number of handles
;       EXIT    'C' clear if OK
;               'C' set iff err
;                 (ax) = error code
;                        AX = error_not_enough_memory
;                             error_too_many_open_files
;       USES    all

Procedure   $ExtHandle,NEAR

        ASSUME  CS:DOSCODE,SS:DOSDATA

        XOR     BP,BP                   ; 0: enlarge   1: shrink  2:psp
        CMP     BX,FilPerProc
        JAE     exth2                   ; Don't set less than FilPerProcno
        MOV     BX,FilPerProc

exth2:  MOV     ES,CurrentPDB           ; get user process data block;smr;SS Override
        MOV     CX,ES:PDB_JFN_Length    ; get number of handle allowed
        CMP     BX,CX                   ; the requested == current
        JE      ok_done                 ; yes and exit
        JA      larger                  ; go allocate new table

;       We're going to shrink the # of handles available

        MOV     BP,1                    ; shrink
        MOV     DS,WORD PTR ES:[PDB_JFN_Pointer+2] ;
        MOV     SI,BX                   ;
        SUB     CX,BX                   ; get difference

;       BUGBUG - code a SCASB here, should be a bit smaller
chck_handles:
        CMP     BYTE PTR DS:[SI],-1     ; scan through handles to ensure close
        JNZ     too_many_files          ; status
        INC     SI
        LOOP    chck_handles
        CMP     BX,FilPerProc           ; = 20
        JA      larger                  ; no

        MOV     BP,2                    ; psp
        MOV     DI,PDB_JFN_Table        ; es:di -> jfn table in psp
        PUSH    BX
        JMP     short movhandl

larger:
        CMP     BX,-1                   ; 65535 is not allowed
        JZ      invalid_func
        CLC
        PUSH    BX                      ; save requested number
        ADD     BX,0FH                  ; adjust to paragraph boundary
        MOV     CL,4
        RCR     BX,CL                   ; DOS 4.00 fix                          ;AC000;
        AND     BX,1FFFH                ; clear most 3 bits

        PUSH    BP
        invoke  $ALLOC                  ; allocate memory
        POP     BP
        JC      no_memory               ; not enough meory

        MOV     ES,AX                   ; es:di points to new table memory
        XOR     DI,DI
movhandl:
        MOV     DS,[CurrentPDB]         ; get user PDB address  ;smr;SS Override

        test    BP,3                    ; enlarge ?
        JZ      enlarge                 ; yes
        POP     CX                      ; cx = the amount you shrink
        PUSH    CX
        JMP     short copy_hand

;       Done.  'C' clear

ok_done:transfer    Sys_Ret_OK

too_many_files:
        MOV     AL,error_too_many_open_files
        transfer    Sys_Ret_Err


enlarge:
        MOV     CX,DS:[PDB_JFN_Length]    ; get number of old handles
copy_hand:
        MOV     DX,CX
        LDS     SI,DS:[PDB_JFN_Pointer]   ; get old table pointer
ASSUME DS:NOTHING
        REP     MOVSB                   ; copy infomation to new table

        POP     CX                      ; get new number of handles
        PUSH    CX                      ; save it again
        SUB     CX,DX                   ; get the difference
        MOV     AL,-1                   ; set availability to handles
        REP     STOSB

        MOV     DS,[CurrentPDB]         ; get user process data block;smr;SS Override
        CMP     WORD PTR DS:[PDB_JFN_Pointer],0  ; check if original table pointer
        JNZ     update_info             ; yes, go update PDB entries
        PUSH    BP
        PUSH    DS                      ; save old table segment
        PUSH    ES                      ; save new table segment
        MOV     ES,WORD PTR DS:[PDB_JFN_Pointer+2] ; get old table segment
        invoke  $DEALLOC                ; deallocate old table meomory
        POP     ES                      ; restore new table segment
        POP     DS                      ; restore old table segment
        POP     BP

update_info:
        test    BP,2                    ; psp?
        JZ      non_psp                 ; no
        MOV     WORD PTR DS:[PDB_JFN_Pointer],PDB_JFN_Table   ; restore
        JMP     short final
non_psp:
        MOV     WORD PTR DS:[PDB_JFN_Pointer],0  ; new table pointer offset always 0
final:
        MOV     WORD PTR DS:[PDB_JFN_Pointer+2],ES  ; update table pointer segment
        POP     DS:[PDB_JFN_Length]      ; restore new number of handles
        transfer   Sys_Ret_Ok
no_memory:
        POP     BX                      ; clean stack
        MOV     AL,error_not_enough_memory
        transfer    Sys_Ret_Err
invalid_func:
        MOV     AL,error_invalid_function
        transfer    Sys_Ret_Err

EndProc $ExtHandle

        BREAK <$READ - Read from a file handle>

;**     $Read - Read from a File Handle
;
;   Assembler usage:
;
;       LDS     DX, buf
;       MOV     CX, count
;       MOV     BX, handle
;       MOV     AH, Read
;       INT     int_command
;         AX has number of bytes read
;
;       ENTRY   (bx) = file handle
;               (cx) = byte count
;               (ds:dx) = buffer address
;       EXIT    Through system call return so that to user:
;                 'C' clear if OK
;                   (ax) = bytes read
;                 'C' set if error
;                   (ax) = error code

procedure   $READ,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        fmt TypSysCall,LevArgs,<" Handle $x Cnt $x Buf $x:$x\n">,<BX,CX,DS,DX>

        MOV     SI,OFFSET DOSCODE:DOS_Read
ReadDo: call    pJFNFromHandle
        JC      ReadError
        MOV     AL,ES:[DI]
        invoke  SFFromHandle
        jc      readError               ; retc
        JMP     short ReadSetup         ; no errors do the operation

;       Have an error.  'C' set

ReadError:
        transfer    SYS_RET_ERR         ; go to error traps

ReadSetup:
        MOV     WORD PTR [ThisSFT],DI   ; save offset of pointer;smr;SS Override
        MOV     WORD PTR [ThisSFT+2],ES ; save segment value    ;smr;SS Override
;; Extended Open
        TESTB   ES:[DI.sf_mode],INT_24_ERROR  ;need i24
        JZ      needi24                       ;yes
        OR      [EXTOPEN_ON],EXT_OPEN_I24_OFF ;set it off;smr;SS Override
needi24:                                      ;


        SAVE    <<WORD PTR [DMAAdd]>, <WORD PTR [DMAAdd+2]>>;smr;SS Override

        ;
        ; Align the users buffer and adjust the byte count
        ; ensuring that it will fit in the segment
        ;

        CALL    Align_Buffer

        mov     ax, cx                     ; byte count
        add     ax, dx                     ; + buff offset must be < 64K
        jnc     rdsOK
        mov     ax, word ptr [DMAAdd]      ; if more than 64K
        neg     ax                            ; use whats left
        jnz     rdsNoDec
        dec     ax
rdsNoDec:

        mov     cx, ax                        ; can do this much
        or      cx, cx
        jnz     rdsOK
        jmp     READ_ERR                      ; user gave offset of ffff
rdsOK:

        test    es:[di.sf_flags],devid_device
        jz      cont_file
        jmp     devread
cont_file:
        push    bp
        push    bx
        mov     ax, si
        mov     si,word ptr es:[di.sf_position]
        mov     bx,word ptr es:[di.sf_position+2]    ; bx:si is the current position

        cmp     ax, offset DOSCODE:DOS_Write
        mov     bp,word ptr es:[di.sf_NTHandle]
        mov     ax,word ptr es:[di.sf_NTHandle+2]
        je      short dowrite
do_read:
        call    FastOrSlow
        jc      do_slowr
        test    es:[di.sf_flags],sf_nt_seek ;set ZF for emulation
        SVC     SVC_DEMFASTREAD
        jnc     short dor2
do_slowr:
        test    es:[di.sf_flags],sf_nt_seek ;set ZF for emulation
        HRDSVC  SVC_DEMREAD
        jnc     dor2
        jmp     do_err
dor2:
        add     word ptr es:[di.sf_position],ax
        adc     word ptr es:[di.sf_position+2],0
        xchg    ax, cx                      ;cx = bytes read, ax=bytes to read
        or      cx, cx
        jne     dow25
        test    es:[di.sf_flags], sf_nt_pipe_in   ;read 0 bytes on pipe?
        je      dow25
;; the file is for piping. guard for EOF
        mov     cx, ax                      ;restore bytesto read
        jmp     pipe_wait_data_eof

dowrite:
        push    cx
        call    FastOrSlow
        jc      do_sloww
        test    es:[di.sf_flags],sf_nt_seek ;set ZF for emulation
        SVC     SVC_DEMFASTWRITE
        jnc     short do_w1
do_sloww:
        test    es:[di.sf_flags],sf_nt_seek ;set ZF for emulation
        HRDSVC  SVC_DEMWRITE
do_w1:
        pop     cx
        jnc     dow0
        jmp     short do_err
dow0:
        jcxz    wr_special
        mov     cx,ax
        add     word ptr es:[di.sf_position],ax
        adc     word ptr es:[di.sf_position+2],0
        mov     ax,word ptr es:[di.sf_position]
        mov     bx,word ptr es:[di.sf_position+2]
        push    ax
        push    bx
        sub     ax,word ptr es:[di.sf_size]
        sbb     bx,word ptr es:[di.sf_size+2]
        pop     bx
        pop     ax
        jb      dow25
        mov     word ptr es:[di.sf_size],ax
        mov     word ptr es:[di.sf_size+2],bx
dow25:
        and     word ptr es:[di.sf_flags],NOT sf_nt_seek
dow3:
        pop     bx
        pop     bp

READ_OK:
        RESTORE <<WORD PTR [DMAAdd+2]>, <WORD PTR [DMAAdd]>>
        MOV     AX,CX                   ; get correct return in correct reg
        transfer    sys_ret_ok          ; successful return

do_err:
        pop     bx
        pop     bp

READ_ERR:
        RESTORE <<WORD PTR [DMAAdd+2]>, <WORD PTR [DMAAdd]>>
        jmp     READERROR

wr_special:
        mov     bx,word ptr es:[di.sf_position]
        mov     word ptr es:[di.sf_size],bx
        mov     bx,word ptr es:[di.sf_position+2]
        mov     word ptr es:[di.sf_size+2],bx
        jmp     short dow3

;; we got nothing, try to make sure it is a real EOF.
pipe_wait_data_eof:
        mov     bp,word ptr es:[di.sf_NTHandle]     ;set up NT handle again
        mov     ax,word ptr es:[di.sf_NTHandle+2]
        SVC     SVC_DEMPIPEFILEDATAEOF              ;probe for new data or EOF
        jz      pipe_wait_data_eof                  ;not eof, no new data, wait
        jnc     pipe_read_new_data                  ;new data, not eof, read it
;; EOF encounter, mask off sf_nt_pipe_in so we will treat it as an ordinary file
        and     word ptr es:[di.sf_flags], NOT(sf_nt_pipe_in)
        mov     word ptr es:[di.sf_size], bp
        mov     word ptr es:[di.sf_size + 2], ax    ;update the file size
pipe_read_new_data:
        mov     bp,word ptr es:[di.sf_NTHandle]     ;NT file handle
        mov     ax,word ptr es:[di.sf_NTHandle+2]
        mov     si,word ptr es:[di.sf_position]
        mov     bx,word ptr es:[di.sf_position+2]   ; bx:si is the current position
        jmp     do_read                             ;read it again

;; Extended Open
devread:
        context DS                      ; go for DOS addressability
        CALL    SI                      ; indirect call to operation
        jnc     READ_OK
        jmp     short READ_ERR
EndProc $READ


Procedure FastOrSlow,near
        test    es:[di.sf_flags],sf_pipe
        jnz     fos_slow
        push    ds
        push    ax
        mov     ax,40h
        mov     ds,ax
        test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK
        pop     ax
        pop     ds
        jz      fos_fast
fos_slow:
        stc
fos_fast:
        ret
Endproc   FastOrSlow

;
;   Input: DS:DX points to user's buffer addr
;   Function: rearrange segment and offset for READ/WRITE buffer
;   Output: [DMAADD] set
;
;

procedure   Align_Buffer,NEAR           ;AN000;
        ASSUME  CS:DOSCODE,SS:DOSDATA  ;AN000;
        SAVE    <BX, CX>                ; don't stomp on count and handle
        MOV     BX,DX                   ; copy offset
        MOV     CL,4                    ; bits to shift bytes->para
        SHR     BX,CL                   ; get number of paragraphs
        MOV     AX,DS                   ; get original segment
        ADD     AX,BX                   ; get new segment
        MOV     DS,AX                   ; in seg register
        AND     DX,0Fh                  ; normalize offset
        MOV     WORD PTR [DMAAdd],DX    ; use user DX as offset ;smr;SS Override
        MOV     WORD PTR [DMAAdd+2],DS  ; use user DS as segment for DMA;smr;SS Override
        RESTORE <CX, BX>                ; get count and handle back
        return                          ;AN000;
EndProc Align_Buffer                    ;AN000;

BREAK <$WRITE - write to a file handle>

;
;   Assembler usage:
;           LDS     DX, buf
;           MOV     CX, count
;           MOV     BX, handle
;           MOV     AH, Write
;           INT     int_command
;         AX has number of bytes written
;   Errors:
;           AX = write_invalid_handle
;              = write_access_denied
;
;   Returns in register AX

procedure   $WRITE,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        fmt TypSysCall,LevArgs,<" Handle $x Cnt $x Buf $x:$x\n">,<BX,CX,DS,DX>
        MOV     SI,OFFSET DOSCODE:DOS_Write
        JMP     ReadDo
EndProc $Write

BREAK <$LSEEK - move r/w pointer>

;
;   Assembler usage:
;           MOV     DX, offsetlow
;           MOV     CX, offsethigh
;           MOV     BX, handle
;           MOV     AL, method
;           MOV     AH, LSeek
;           INT     int_command
;         DX:AX has the new location of the pointer
;   Error returns:
;           AX = error_invalid_handle
;              = error_invalid_function
;   Returns in registers DX:AX

procedure   $LSEEK,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        call    SFFromHandle            ; get system file entry
        jnc     CHKOWN_OK
LSeekError:
        JNC     CHKOWN_OK               ;AN002;
        JMP     ReadError               ;AN002; error return

CHKOWN_OK:

        test    es:[di.sf_flags],devid_device
        jz      lseekcheckpipe
        jmp     devseek
lseekcheckpipe:
        CMP     AL,2                    ; is the seek value correct?
        ja      lseekfile_error
        test    es:[di.sf_flags], sf_nt_pipe_in;seek in pipe?
        je      lseekDisp               ;no, regular stuff
        jmp     lseekpipe               ;yes, do pipe speical
lseekfile_error:
        MOV     EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus  ;smr;SS Override
        error   error_invalid_function  ; invalid method

LSeekDisp:
        CMP     AL,1                    ; best way to dispatch; check middle
        JB      LSeekStore              ; just store CX:DX
        JA      LSeekEOF                ; seek from end of file
        ADD     DX,WORD PTR ES:[DI.SF_Position]
        ADC     CX,WORD PTR ES:[DI.SF_Position+2]
LSeekStore:
        MOV     AX,CX                   ; AX:DX
        XCHG    AX,DX                   ; DX:AX is the correct value
LSeekSetpos:
        push    WORD PTR ES:[DI.SF_Position+2]
        MOV     WORD PTR ES:[DI.SF_Position+2],DX
        push    WORD PTR ES:[DI.SF_Position]
        MOV     WORD PTR ES:[DI.SF_Position],AX

        pop     bx
        cmp     ax,bx
        pop     bx
        jne     io_with_seek
        cmp     dx,bx
        jne     io_with_seek
seek_ret:
        invoke  Get_user_stack
        MOV     DS:[SI.User_DX],DX      ; return DX:AX
        transfer    SYS_RET_OK          ; successful return

LSeekEOF:
        mov     bl,al
        push    bp
        mov     bp,word ptr es:[di.sf_NTHandle]
        mov     ax,word ptr es:[di.sf_NTHandle+2]   ; AX:BP is 32bit handle
        push    dx                                  ; Save loword of offset
        HRDSVC  SVC_DEMCHGFILEPTR                   ; Result comes back in DX:AX
        pop     bx                                  ; CX:BX is the offset desired
        pop     bp
        jnc     lseekeof1
        jmp     ReadError
lseekeof1:
        MOV     WORD PTR ES:[DI.SF_Position+2],DX   ; Update pointer
        MOV     WORD PTR ES:[DI.SF_Position],AX
        MOV     WORD PTR ES:[DI.SF_Size+2],DX       ; Size may change
        MOV     WORD PTR ES:[DI.SF_Size],AX
        sub     WORD PTR ES:[DI.SF_Size],bx         ; Get the size from
        sbb     WORD PTR ES:[DI.SF_Size+2],cx       ; current pointer and
                                                    ; given offset.
        and     word ptr es:[di.sf_flags], NOT sf_nt_seek ; No seek needed.
        JMP     LSeekOK

io_with_seek:
        or      word ptr es:[di.sf_flags],sf_nt_seek
        jmp     short seek_ret

ifdef not_needed_any_more
do_pipe:
        mov     bl,al
        push    bp
        mov     bp,word ptr es:[di.sf_NTHandle]
        mov     ax,word ptr es:[di.sf_NTHandle+2]
        HRDSVC  SVC_DEMCHGFILEPTR
        pop     bp
        jnc     LseekOK
        JMP     ReadError
endif

devseek:
        xor     ax,ax
        mov     dx,ax
LseekOK:
        invoke  Get_user_stack
        MOV     DS:[SI.User_DX],DX      ; return DX:AX
        transfer    SYS_RET_OK          ; successful return

lseekpipe:
        push    ax
        push    cx
        push    dx
        cmp     al, 2                   ;seek from EOF?
        je      lseekpipe_wait_eof      ;yes, must wait for EOF
        cmp     al, 1                   ;seek from current position?
        jne     lseekpipe_00            ;no, must seek from the head
;;lseek from current position.
;;if current position + offset > file size, wait for EOF
        add     dx, word ptr es:[di.sf_position]        ; new absolute position
        adc     cx, word ptr es:[di.sf_position + 2]
lseekpipe_00:
;;lseek from the beginning of the file
;;if the new position is beyond file size, wait for EOF
;;
        cmp     cx, word ptr es:[di.sf_size + 2]   ;make sure the new position
        ja      lseekpipe_wait_eof        ;is within the current file size
        cmp     dx, word ptr es:[di.sf_size]
        ja      lseekpipe_wait_eof
        mov     ax, cx                    ; return (DX:AX) as the new position
        xchg    dx, ax
        mov     word ptr es:[di.sf_position], ax     ;; update new position to SFT
        mov     word ptr es:[di.sf_position + 2], dx
        add     sp, 6                   ;throw away saved registers
        jmp     short lseekOK

lseekpipe_wait_eof:
        mov     bp,word ptr es:[di.sf_NTHandle]
        mov     ax,word ptr es:[di.sf_NTHandle+2]   ; AX:BP is 32bit handle
        SVC     SVC_DEMPIPEFILEEOF
        jnc     lseekpipe_wait_eof                  ;not eof, wait
        mov     word ptr es:[di.sf_size], bp        ;file size
        mov     word ptr es:[di.sf_size + 2], ax
        and     word ptr es:[di.sf_flags], NOT(sf_nt_pipe_in);becomes an ordinary file
        pop     dx
        pop     cx
        pop     ax
        jmp     lseekDisp

EndProc $LSeek

BREAK <FileTimes - modify write times on a handle>


;----------------------------------------------------------------------------
;   Assembler usage:
;           MOV AH, FileTimes (57H)
;           MOV AL, func
;           MOV BX, handle
;       ; if AL = 1 then then next two are mandatory
;           MOV CX, time
;           MOV DX, date
;           INT 21h
;       ; if AL = 0 then CX/DX has the last write time/date
;       ; for the handle.
;
;       AL=02            get extended attributes
;          BX=handle
;          CX=size of buffer (0, return max size )
;          DS:SI query list (si=-1, selects all EA)
;          ES:DI buffer to hold EA list
;
;       AL=03            get EA name list
;          BX=handle
;          CX=size of buffer (0, return max size )
;          ES:DI buffer to hold name list
;
;       AL=04            set extended attributes
;          BX=handle
;          ES:DI buffer of EA list
;
;
;       Extended to support win95 apis, see demlfn.c in dos/dem
;
;   Error returns:
;           AX = error_invalid_function
;              = error_invalid_handle
;----------------------------------------------------------------------------

procedure   $File_Times,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA



ifdef old_rubbish

;
; This code is not needed anymore
;
;
        cmp     al, 2                   ; correct subfunction ?
        jae     inval_func

        call    SFFromHandle            ; get sft
        jnc     cont_ft
        jmp     LSeekError              ; bad handle
cont_ft:
        test    es:[di.sf_flags],devid_device

        jz      yst_contin              ; (YST)
        cmp     al, 1                   ; (YST)
        jz      ret_ok                  ; (YST)
        mov     al, 2                   ; (YST)

yst_contin:
        push    ax                          ;save ax for success case
        push    bp
        mov     bp, word ptr es:[di.sf_NTHandle]
        mov     bl,al
        mov     ax, word ptr es:[di.sf_NTHandle+2]
        HRDSVC  SVC_DEMFILETIMES
        pop     bp
        jnc     short timesok
        add     sp,2                         ;ax=return code
        transfer Sys_Ret_Err

timesok:
        pop     ax                           ;restore caller's ax
        cmp     bl, 1               ; (YST)
        jz      ret_ok              ; (YST)

        invoke  Get_User_Stack
        mov     [si].user_CX, cx
        mov     [si].user_DX, dx
ret_ok:
        transfer SYS_RET_OK

inval_func:
        mov     ExtErr_Locus,errLoc_Unk ; Extended Error Locus  ;SS Override
        error   error_invalid_function  ; give bad return
endif

        ;
        ; Everything is done in dem
        ;

        HRDSVC  SVC_DEMFILETIMES
        jc      FileTimesError
        transfer SYS_RET_OK
FileTimesError:
        transfer SYS_RET_ERR


EndProc $File_Times

BREAK <$DUP - duplicate a jfn>
;
;   Assembler usage:
;           MOV     BX, fh
;           MOV     AH, Dup
;           INT     int_command
;         AX has the returned handle
;   Errors:
;           AX = dup_invalid_handle
;              = dup_too_many_open_files

Procedure   $DUP,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        MOV     AX,BX                   ; save away old handle in AX
        invoke  JFNFree                 ; free handle? into ES:DI, new in BX
DupErrorCheck:
        JC      DupErr                  ; nope, bye
        SAVE    <ES,DI>                 ; save away JFN
        RESTORE <SI,DS>                 ; into convenient place DS:SI
        XCHG    AX,BX                   ; get back old handle
        call    SFFromHandle            ; get sft in ES:DI
        JC      DupErr                  ; errors go home
        invoke  DOS_Dup_Direct
        call    pJFNFromHandle          ; get pointer
        MOV     BL,ES:[DI]              ; get SFT number
        MOV     DS:[SI],BL              ; stuff in new SFT
        transfer    SYS_RET_OK          ; and go home
DupErr: transfer    SYS_RET_ERR

EndProc $Dup

BREAK <$DUP2 - force a dup on a particular jfn>
;
;   Assembler usage:
;           MOV     BX, fh
;           MOV     CX, newfh
;           MOV     AH, Dup2
;           INT     int_command
;   Error returns:
;           AX = error_invalid_handle

Procedure   $Dup2,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        SAVE    <BX,CX>                 ; save source
        MOV     BX,CX                   ; get one to close
        invoke  $Close                  ; close destination handle
        RESTORE <BX,AX>         ; old in AX, new in BX
        call    pJFNFromHandle          ; get pointer
        JMP     DupErrorCheck           ; check error and do dup
EndProc $Dup2

Break   <CheckOwner - verify ownership of handles from server>

;
;   CheckOwner - Due to the ability of the server to close file handles for a
;   process without the process knowing it (delete/rename of open files, for
;   example), it is possible for the redirector to issue a call to a handle
;   that it soes not rightfully own.  We check here to make sure that the
;   issuing process is the owner of the SFT.  At the same time, we do a
;   SFFromHandle to really make sure that the SFT is good.
;
;       ENTRY   BX has the handle
;               User_ID is the current user
;       EXIT    Carry Clear => ES:DI points to SFT
;               Carry Set => AX has error code
;       USES    none

ifdef 0
Procedure   CheckOwner,NEAR
; Procedue not needed
        ASSUME  CS:DOSCODE,SS:DOSDATA
        invoke  SFFromHandle
        jc      ret_label       ; retc
        push    ax

;SR;
;SR; WIN386 patch - Do not check for USER_ID for using handles since these
;SR; are shared across multiple VMs in win386.
;SR;
        test    [IsWin386],1
        jz      no_win386               ;win386 is not present
        xor     ax,ax                   ;set the zero flag
        jmp     short skip_win386

no_win386:

        mov     ax,user_id                                      ;smr;SS Override
        cmp     ax,es:[di].sf_UID

skip_win386:

        pop     ax
        retz
        mov     al,error_invalid_handle
        stc

ret_label:
        return
EndProc CheckOwner
endif

DOSCODE ENDS
        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\macro.asm ===
TITLE   MACRO - Pathname and macro related internal routines
        NAME    MACRO

;**     MACRO.ASM
;
;       $AssignOper
;       InitCDS
;       $UserOper
;       GetVisDrv
;       GetThisDrv
;       GetCDSFromDrv
;
;       Modification History
;
;       sudeepb 11-Mar-1991 Ported for NT DOSEm.
;

        .xlist
        .xcref
        include version.inc
        include dosseg.inc
        INCLUDE DOSSYM.INC
        INCLUDE DEVSYM.INC
        include mult.inc
	include curdir.inc
        include cmdsvc.inc
        include dossvc.inc
ifdef NEC_98
        include dpb.inc
endif   ;NEC_98
        .cref
        .list

ifdef NEC_98
Installed = TRUE
endif   ;NEC_98
        I_need  ThisCDS,DWORD           ; pointer to CDS used
        I_need  CDSAddr,DWORD           ; pointer to CDS table
        I_need  CDSCount,BYTE           ; number of CDS entries
	I_need	SCS_ToSync,BYTE		; Flag which tells to validate CDSs
        I_need  CurDrv,BYTE             ; current macro assignment (old
                                        ; current drive)
        I_need  NUMIO,BYTE              ; Number of physical drives
        I_need  fSharing,BYTE           ; TRUE => no redirection allowed
        I_need  DummyCDS,80h            ; buffer for dummy cds
ifdef JAPAN
	I_need	NetCDS,curdirLen_Jpn	; buffer for Net cds
else
	I_need	NetCDS,curdirLen	; buffer for Net cds
endif
        I_need  DIFFNAM,BYTE            ; flag for MyName being set
        I_need  MYNAME,16               ; machine name
        I_need  MYNUM,WORD              ; machine number
        I_need  EXTERR_LOCUS,BYTE       ; Extended Error Locus
        I_need  DrvErr,BYTE             ; drive error
ifdef NEC_98
        I_need  DPBHEAD,DWORD           ; beginning of DPB chain
endif   ;NEC_98


DOSCODE SEGMENT
        ASSUME  SS:DOSDATA,CS:DOSCODE

BREAK <$AssignOper -- Set up a Macro>

; Inputs:
;       AL = 00 get assign mode                     (ReturnMode)
;       AL = 01 set assign mode                     (SetMode)
;       AL = 02 get attach list entry               (GetAsgList)
;       AL = 03 Define Macro (attch start)
;           BL = Macro type
;              = 0 alias
;              = 1 file/device
;              = 2 drive
;              = 3 Char device -> network
;              = 4 File device -> network
;           DS:SI -> ASCIZ source name
;           ES:DI -> ASCIZ destination name
;       AL = 04 Cancel Macro
;           DS:SI -> ASCIZ source name
;       AL = 05 Modified get attach list entry
;       AL = 06 Get ifsfunc item
;       AL = 07 set in_use of a drive's CDS
;            DL = drive number, 0=default  0=A,,
;       AL = 08 reset in_use of a drive's CDS
;            DL = drive number, 0=A, 1=B,,,
; Function:
;       Do macro stuff
; Returns:
;       Std Xenix style error return

procedure   $AssignOper,NEAR

        CMP     AL,7                          ; set in_use ?            ;AN000;
        JNZ     chk08                         ; no                      ;AN000;
srinuse:                                                                ;AN000;
        PUSH    AX                            ; save al                 ;AN000;
        MOV     AL,DL                         ; AL= drive id            ;AN000;
        CALL    GetCDSFromDrv                 ; ds:si -> cds            ;AN000;
        POP     AX                            ;                         ;AN000;
        JC      baddrv                        ; bad drive               ;AN000;
;
; RLF 09/10/91
; No curdir_devptr - therefore no point checking it?
;
;        CMP     WORD PTR [SI.curdir_devptr],0 ; dpb ptr =0 ?            ;AN000;
;        JZ      baddrv                        ;     no                  ;AN000;
;
; RLF 09/10/91
;
        CMP     AL,7                          ; set ?                   ;AN000;
        JNZ     resetdrv                      ; no                      ;AN000;
        OR      [SI.curdir_flags],curdir_inuse; set in_use              ;AN000;
        JMP     SHORT okdone                  ;                         ;AN000;
resetdrv:                                                               ;AN000;
        AND     [SI.curdir_flags],NOT curdir_inuse; reset in_use                ;AN000;
        JMP     SHORT okdone                    ;                       ;AN000;
baddrv:                                                                 ;AN000;
        MOV     AX,error_invalid_drive        ; error                   ;AN000;
        JMP     SHORT ASS_ERR                 ;                         ;AN000;
chk08:                                                                  ;AN000;
        CMP     AL,8                          ; reset inuse ?           ;AN000;
        JZ      srinuse                       ; yes                     ;AN000;

        IF      NOT INSTALLED
        transfer NET_ASSOPER
        ELSE
        PUSH    AX
        MOV     AX,(multnet SHL 8) OR 30
        INT     2FH
        POP     BX                      ; Don't zap error code in AX
        JC      ASS_ERR
okdone:
        transfer SYS_RET_OK

ASS_ERR:
        transfer SYS_RET_ERR
        ENDIF

EndProc $AssignOper

ifdef NEC_98
Break <FIND_DPB - Find a DPB from a drive number>

;**     FIND_DPB - Find a DPB from a Drive #
;
;       ENTRY   AL has drive number A = 0
;       EXIT    'C' set
;                   No DPB for this drive number
;               'C' clear
;                   DS:SI points to DPB for drive
;       USES    SI, DS, Flags

Procedure FIND_DPB,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA

        LDS     SI,DPBHEAD              ;smr;SS Override
fdpb5:  CMP     SI,-1
        JZ      fdpb10
        CMP     AL,[SI].dpb_drive
        jz      ret_label               ; Carry clear (retz)
        LDS     SI,[SI].dpb_next_dpb
        JMP     fdpb5

fdpb10: STC

ret_label:
        return

EndProc FIND_DPB
endif   ;NEC_98
        Break <InitCDS - set up an empty CDS>


;**     InitCDS - Setup an Empty CDS
;
;       ENTRY   ThisCDS points to CDS
;               AL has uppercase drive letter
;       EXIT    ThisCDS is now empty
;               (ES:DI) = CDS
;               'C' set if no DPB associated with drive
;       USES    AH,ES,DI, Flags

Procedure InitCDS,NEAR
        DOSASSUME <SS>,"InitCDS"
        ASSUME  CS:DOSCODE

        SAVE    <ax>                    ; save (AL) for caller
        LES     DI,THISCDS              ; (es:di) = CDS address
        MOV     ES:[DI].curdir_flags,0  ; "free" CDS

        ; On NT we allow any valid drive letter for network drives
        ; CMP     NUMIO,AL                ; smr;SS Override
        ; JC      icdsx                   ; Drive does not map a physical drive
        cmp     al, 25 + "A"
        ja      icdsErr

        MOV     AH,':'
        MOV     WORD PTR ES:[DI.curdir_text],AX         ; set "x:"
        MOV     WORD PTR ES:[DI.curdir_text+2],"\"      ; NUL terminate
        .errnz  CURDIR_INUSE-4000h
        OR      byte ptr ES:[DI].curdir_flags+1,curdir_inuse SHR 8
        mov     al,2
        MOV     ES:[DI].curdir_END,ax
icdsx:  RESTORE <ax>
        return

icdsErr:
        stc
        jmp short icdsx

EndProc InitCDS

Break <$UserOper - get/set current user ID (for net)>

;
;   $UserOper - retrieve or initiate a user id string.  MSDOS will only
;       maintain this string and do no verifications.
;
;   Inputs:     AL has function type (0-get 1-set 2-printer-set 3-printer-get
;                                     4-printer-set-flags,5-printer-get-flags)
;               DS:DX is user string pointer (calls 1,2)
;               ES:DI is user buffer (call 3)
;               BX is assign index (calls 2,3,4,5)
;               CX is user number (call 1)
;               DX is flag word (call 4)
;   Outputs:    If AL = 0 then the current user string is written to DS:DX
;                       and user CX is set to the user number
;               If AL = 3 then CX bytes have been put at input ES:DI
;               If AL = 5 then DX is flag word
;
;   NOTES for NT: sudeepb 01-Mar-1993
;               We ignore setting of the computer name although we succeed.
;               Functions realted to printer info are handled the same way
;               as DOS i.e. by an int2f, but redir does'nt do anything about
;               it as remote printing is'nt handled by redir. I dont
;               know what could potentially be broken because of this.


Procedure   $UserOper,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        PUSH    AX
        SUB     AL,1                    ; quick dispatch on 0,1
        POP     AX
        JB      UserGet                 ; return to user the string
        JZ      UserSet                 ; set the current user
        CMP     AL,5                    ; test for 2,3,4 or 5
        JBE     UserPrint               ; yep
        MOV     EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus  ;smr;SS Override
        error   error_Invalid_Function  ; not 0,1,2,3

UserGet:
        SVC     SVC_DEMGETCOMPUTERNAME  ; DS:DX is the user buffer
        invoke  get_user_stack
        MOV     [SI.User_CX],CX         ; Set number return
UserBye:
        transfer    sys_ret_ok          ; no errors here

UserSet:
ASSUME  DS:NOTHING
; Transfer DS:DX to MYNAME
; CX to MYNUM
        MOV     [MYNUM],CX              ;smr;SS Override
if 0
        MOV     SI,DX                   ; user space has source
        Context ES
        MOV     DI,OFFSET DOSDATA:MyName   ; point dest to user string
        INC     [DiffNam]                 ; signal change       ;smr;SS Override
        JMP     UserMove
else
        transfer    sys_ret_ok          ; On NT we only take MyNum
endif

UserPrint:
        ASSUME  ES:NOTHING
IF NOT Installed
        transfer PRINTER_GETSET_STRING
ELSE
        PUSH    AX
        MOV     AX,(multNET SHL 8) OR 31
        INT     2FH
        POP     DX                      ; Clean stack
        JNC     OKPA
        transfer SYS_RET_ERR

OKPA:
        transfer SYS_RET_OK
ENDIF


EndProc $UserOper

Break   <GetVisDrv - return visible drive>

;
;   GetVisDrv - correctly map non-spliced inuse drives
;
;   Inputs:     AL has drive identifier (0=default)
;   Outputs:    Carry Set - invalid drive/macro
;               Carry Clear - AL has physical drive (0=A)
;                   ThisCDS points to CDS
;   Registers modified: AL

Procedure   GetVisDrv,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        CALL    GetThisDrv              ; get inuse drive
        retc
        SAVE    <DS,SI>
        LDS     SI,ThisCDS                                      ;smr;SS Override
        TEST    [SI].curdir_flags,curdir_splice
        RESTORE <SI,DS>
        retz                            ; if not spliced, return OK
        MOV     [DrvErr],error_invalid_drive ;IFS.                              ;AN000;smr;SS Override
        STC                             ; signal error
        return
EndProc GetVisDrv

Break <Getthisdrv - map a drive designator (0=def, 1=A...)>

;
;   GetThisDrv - look through a set of macros and return the current drive and
;       macro pointer
;
;   Inputs:     AL has drive identifier (1=A, 0=default)
;   Outputs:
;               Carry Set - invalid drive/macro
;               Carry Clear - AL has physical drive (0=A)
;                  ThisCDS points to macro
;   Registers modified: AL

Procedure   GetThisDrv,NEAR
        ASSUME  CS:DOSCODE,SS:DOSDATA
        OR      AL,AL                   ; are we using default drive?
        JNZ     gtd10                   ; no, go get the CDS pointers
        MOV     AL,[CurDrv]             ; get the current drive
        INC     ax                      ; Counteract next instruction
gtd10:  DEC     ax                      ; 0 = A
        SAVE    <DS,SI>                 ; save world
        mov     [EXTERR_LOCUS],errLOC_Disk                      ;smr;SS Override
        TEST    fSharing,-1             ; Logical or Physical?  ;smr;SS Override
        JZ      gtd20                   ; Logical
        SAVE    <AX,ES,DI>
        MOV     WORD PTR ThisCDS,OFFSET DOSDATA:DummyCDS        ;smr;SS Override
        MOV     WORD PTR ThisCDS+2,SS   ;       ThisCDS = &DummyCDS;smr;
        ADD     AL,'A'
        CALL    InitCDS                 ;       InitCDS(c);
        TEST    ES:[DI.curdir_flags],curdir_inuse       ; Clears carry
        RESTORE <DI,ES,AX>
        JZ      gtd30                   ; Not a physical drive.
        JMP     SHORT gtdx              ; carry clear

gtd20:  invoke  GetCDSFromDrv
        JC      gtd30                   ; Unassigned CDS -> return error already set
        TEST    [SI.curdir_flags],curdir_inuse  ; Clears Carry
        JNZ     gtdx                            ; carry clear
gtd30:  MOV     AL,error_invalid_drive  ; invalid FAT drive
        MOV     [DrvErr],AL             ; save this for IOCTL
        mov     [EXTERR_LOCUS],errLOC_UNK
        STC
gtdx:   RESTORE <SI,DS>         ; restore world
        return

EndProc GetThisDrv

Break <GetCDSFromDrv - convert a drive number to a CDS pointer>

;
;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
;       pointer, returning an error if the drive number is greater than the
;       number of CDS's
;
;   Inputs:     AL is physical unit # A=0...
;   Outputs:    Carry Set if Bad Drive
;               Carry Clear
;                   DS:SI -> CDS
;                   [THISCDS] = DS:SI
;   Registers modified: DS,SI

Procedure   GetCDSFromDrv,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

; Sudeepb 20-Dec-1991 ; Added for redirected drives
; We always sync the redirected drives. Local drives are sync
; as per the curdir_tosync flag and SCS_toSync.

	cmp	[SCS_ToSync],0
	je	no_sync

	SAVE	<BX,CX>
	LDS	SI,[CDSAddr]		; get pointer to table	;smr;SS Override
	mov	cl,[CDSCount]
	xor	ch,ch
sync_loop:
	or	word ptr ds:[si.CURDIR_FLAGS],CURDIR_tosync
ifdef JAPAN
	MOV	BX,SIZE CurDir_list_jpn
else
	MOV	BX,SIZE CurDir_list
endif
	ADD	SI,bx
	loop	sync_loop
	RESTORE <CX,BX>
        mov     [SCS_ToSync],0
        mov     si,OFFSET DOSDATA:NetCDS
        push    ss
        pop     ds
        or      word ptr ds:[si.CURDIR_FLAGS],CURDIR_tosync OR CURDIR_NT_FIX
no_sync:
        CMP     AL,[CDSCount]           ; is this a valid designator;smr;SS Override
	JB	GetCDS			; yes, go get the macro


	cmp	al,25
	ja	gcds_err

        mov     si,OFFSET DOSDATA:NetCDS
	.errnz	CURDIR_TEXT
	push	ss
        pop     ds

        push    ax
        CMDSVC  SVC_CMDGETCURDIR        ; ds:si is buffer to get current dir

net_in_sync:
	pop	ax
	jc	gcds_err

	MOV	[si.curdir_END],2
        mov     [si.CURDIR_FLAGS], CURDIR_inuse OR CURDIR_NT_FIX
	jmp	gcds_comm

gcds_err:
        STC                             ; signal error
	return				; bye

GetCDS:
        SAVE    <BX,AX>
        LDS     SI,[CDSAddr]            ; get pointer to table  ;smr;SS Override
ifdef JAPAN
        MOV     BL,SIZE CurDir_list_jpn ; size in convenient spot
else
        MOV     BL,SIZE CurDir_list     ; size in convenient spot
endif
        MUL     BL                      ; get net offset
        ADD     SI,AX                   ; convert to true pointer
	RESTORE <AX,BX>
	test	word ptr ds:[si.CURDIR_FLAGS],CURDIR_tosync
	jz	gcds_comm
	push	ax
	CMDSVC	SVC_CMDGETCURDIR	; ds:si is buffer to get current dir
					; al = drive
	pop	ax
	jc	gcds_err
	and	word ptr ds:[si.CURDIR_FLAGS],NOT CURDIR_tosync
gcds_comm:
        MOV     WORD PTR [ThisCDS],SI   ; store convenient offset;smr;SS Override
	MOV	WORD PTR [ThisCDS+2],DS ; store convenient segment;smr;SS Override
CDSX:
        CLC                             ; no error
        return                          ; bye!
EndProc GetCDSFromDrv

DOSCODE ends
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\lock.asm ===
TITLE	LOCK ROUTINES - Routines for file locking
	NAME	LOCK

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	LOCK.ASM - File Locking Routines
;
;	LOCK_CHECK
;	LOCK_VIOLATION
;	$LockOper
;
;	Revision history:
;	  A000	 version 4.00	Jan. 1988
;	  SudeepB  07-Aug-1992 Ported for NT

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include lock.inc
	include mult.inc
	include sf.inc
	include dossvc.inc
ifdef NEC_98
	include dpb.inc
endif   ;NEC_98
	.cref
	.list

AsmVars <IBM, Installed>

Installed = TRUE

	i_need	THISSFT,DWORD
	i_need	THISDPB,DWORD
	i_need	EXTERR,WORD
	i_need	ALLOWED,BYTE
	i_need	RetryCount,WORD
	I_need	fShare,BYTE
	I_Need	EXTERR_LOCUS,BYTE	; Extended Error Locus
	i_need	JShare,DWORD
	i_need	Lock_Buffer,DWORD	; DOS 4.00
	i_need	Temp_Var,WORD		; DOS 4.00


DOSCODE SEGMENT

	allow_getdseg

	ASSUME	SS:DOSDATA,CS:DOSCODE

BREAK <$LockOper - Lock Calls>

;
;   Assembler usage:
;	    MOV     BX, Handle	       (DOS 3.3)
;	    MOV     CX, OffsetHigh
;	    MOV     DX, OffsetLow
;	    MOV     SI, LengthHigh
;	    MOV     DI, LengthLow
;	    MOV     AH, LockOper
;	    MOV     AL, Request
;	    INT     21h
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_lock_violation
;
;   Assembler usage:
;	    MOV     AX, 5C??	       (DOS 4.00)
;
;				    0? lock all
;				    8? lock write
;				    ?2 lock multiple
;				    ?3 unlock multiple
;				    ?4 lock/read
;				    ?5 write/unlock
;				    ?6 add (lseek EOF/lock/write/unlock)
;	    MOV     BX, Handle
;	    MOV     CX, count or size
;	    LDS     DX, buffer
;	    INT     21h
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_lock_violation

	procedure   $LockOper,NEAR
	CMP	AL,1
	JA	lock_bad_func

	PUSH	DI			       ; Save LengthLow
	invoke	SFFromHandle		       ; ES:DI -> SFT
	JNC	lock_do 		       ; have valid handle
	POP	DI			       ; Clean stack
	error	error_invalid_handle
lock_bad_func:
	MOV	EXTERR_LOCUS,errLoc_Unk        ; Extended Error Locus;smr;SS Override
	error	error_invalid_function

lock_do:
	mov	bp,word ptr es:[di.sf_NTHandle]
	mov	bx,word ptr es:[di.sf_NTHandle+2]
	pop	di

	HRDSVC	SVC_DEMLOCKOPER 	       ; BX:BP = NT handle
					       ; cx:dx = offset
					       ; si:di = length
					       ; al    = lock/unlock
	JNC	Lock_OK
	transfer SYS_RET_ERR
Lock_OK:
	MOV	AX,[Temp_VAR]		       ;AN000;;MS. AX= number of bytes;smr;SS Override
	transfer SYS_Ret_OK

EndProc $LockOper

ifdef NEC_98
; Inputs:
;	Outputs of SETUP
;	[USER_ID] Set
;	[PROC_ID] Set
; Function:
;	Check for lock violations on local I/O
;	Retries are attempted with sleeps in between
; Outputs:
;    Carry clear
;	Operation is OK
;    Carry set
;	A lock violation detected
; Outputs of SETUP preserved

procedure   LOCK_CHECK,NEAR
	DOSAssume   <DS>,"Lock_Check"

	MOV	BX,RetryCount		; Number retries
LockRetry:
	SAVE	<BX,AX> 		; save regs
if installed
	call	JShare + 8 * 4
else
	Call	chk_block					;PBUGBUG
endif
	RESTORE <AX,BX> 	; restrore regs
	jnc	ret_label	; There are no locks (retnc)
	Invoke	Idle		; wait a while
	DEC	BX		; remember a retry
	JNZ	LockRetry	; more retries left...
	STC

ret_label:
	return
EndProc LOCK_CHECK

; Inputs:
;	[THISDPB] set
;	[READOP] indicates whether error on read or write
; Function:
;	Handle Lock violation on compatibility (FCB) mode SFTs
; Outputs:
;	Carry set if user says FAIL, causes error_lock_violation
;	Carry clear if user wants a retry
;
; DS, ES, DI, CX preserved, others destroyed

procedure   LOCK_VIOLATION,NEAR
	DOSAssume   <DS>,"Lock_Violation"

	PUSH	DS
	PUSH	ES
	PUSH	DI
	PUSH	CX
	MOV	AX,error_lock_violation
	MOV	[ALLOWED],allowed_FAIL + allowed_RETRY
	LES	BP,[THISDPB]
	MOV	DI,1				; Fake some registers
	MOV	CX,DI
	MOV	DX,ES:[BP.dpb_first_sector]
	invoke	HARDERR
	POP	CX
	POP	DI
	POP	ES
	POP	DS
	CMP	AL,1
	retz			; 1 = retry, carry clear
	STC
	return

EndProc LOCK_VIOLATION

IF  INSTALLED

;	do a retz to return error

Procedure   CheckShare,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	push	ds					;smr;
	getdseg	<ds>			; ds -> dosdata
	CMP     fShare,0
	pop	ds					;smr;
	ASSUME	DS:NOTHING				;smr;
	return
EndProc CheckShare

ENDIF

endif   ;NEC_98

DOSCODE	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\kstrin.asm ===
;	SCCSID = @(#)strin.asm	1.2 85/04/18
;
;	Revision history:
;	   A000  version 4.00   Jan. 1988
;
Break

; Inputs:
;	DS:DX Point to an input buffer
; Function:
;	Fill buffer from console input until CR
; Returns:
;	None

	procedure   $STD_CON_STRING_INPUT,NEAR	 ;System call 10
ASSUME	DS:NOTHING,ES:NOTHING

	MOV	AX,SS
	MOV	ES,AX
	MOV	SI,DX
	XOR	CH,CH
	LODSW

;hkn; use ss override
	mov	ss:Temp_Var,si	 ;AN000;   ; 3/31/KK
;
; AL is the buffer length
; AH is the template length
;
	OR	AL,AL
	retz			;Buffer is 0 length!!?
	MOV	BL,AH		;Init template counter
	MOV	BH,CH		;Init template counter
 ;
 ; BL is the number of bytes in the template
 ;
	CMP	AL,BL
	JBE	NOEDIT		;If length of buffer inconsistent with contents
	CMP	BYTE PTR [BX+SI],c_CR
	JZ	EDITON		;If CR correctly placed EDIT is OK
;
; The number of chars in the template is >= the number of chars in buffer or
; there is no CR at the end of the template.  This is an inconsistant state
; of affairs.  Pretend that the template was empty:
;
NOEDIT:
	MOV	BL,CH		;Reset buffer
EDITON:
	MOV	DL,AL
	DEC	DX		;DL is # of bytes we can put in the buffer
;
; Top level.  We begin to read a line in.
;
NEWLIN:

;hkn; SS override
	MOV	AL,[CARPOS]
	MOV	[STARTPOS],AL	;Remember position in raw buffer
	PUSH	SI

;hkn; INBUF is in DOSDATA
	MOV	DI,OFFSET DOSDATA:INBUF	;Build the new line here

;hkn; SS override
	MOV	[INSMODE],CH	;Insert mode off
	MOV	BH,CH		;No chars from template yet
	MOV	DH,CH		;No chars to new line yet
	call	IntCNE0 	;AN000; Get first char			 2/17/KK
	jz	SavCh		;AN000; if ZF set then interim character 2/17/KK
	CMP	AL,c_LF 	;Linefeed
	JNZ	GOTCH		;Filter out LF so < works
;
; This is the main loop of reading in a character and processing it.
;
;   BH is the index of the next byte in the template
;   BL is the length of the template
;   DH is the number of bytes in the buffer
;   DL is the length of the buffer
;
entry	GETCH
	call	IntCNE0 	;AN000;; 2/17/KK
	jz	SavCh		;AN000;; if ZF set then interim character 2/17/KK
GOTCH:
;
; ^F ignored in case BIOS did not flush the input queue.
;
	CMP	AL,"F"-"@"
	JZ	GETCH
;
; If the leading char is the function-key lead byte
;

;hkn; ESCCHAR is in TABLE seg (DOSCODE)
	CMP	AL,[ESCCHAR]
	JNZ	ARM03		;AN000;; 2/17/KK
	Jmp	ESCC		;AN000;; 2/17/KK
ARM03:				;AN000;; 2/17/KK
;
; Rubout and ^H are both destructive backspaces.
;
	CMP	AL,c_DEL
	JZ	BACKSPJ0	;AN000; 2/17/KK
	CMP	AL,c_BS
	JNZ	ARM04		;AN000;; 2/17/KK
BACKSPJ0:			;AN000;; 2/17/KK
	Jmp	BACKSPJ 	;AN000;; 2/17/KK
ARM04:				;AN000;; 2/17/KK
;
; ^W deletes backward once and then backs up until a letter is before the
; cursor
;
	CMP	AL,"W" - "@"
; The removal of the comment characters before the jump statement will
; cause ^W to backup a word.
;***	JZ	WordDel
ifdef	JAPAN				    ; MSKK01 07/14/89
	jnz	NotWordDel
	jmp	WordDel
NotWordDel:
else
	NOP
	NOP
endif
	CMP	AL,"U" - "@"
; The removal of the comment characters before the jump statement will
; cause ^U to clear a line.
;***	JZ	LineDel
ifdef	JAPAN				    ; MSKK01 07/14/89
	jnz	NotLineDel
	jmp	LineDel
NotLineDel:
else
	NOP
	NOP
endif

;
; CR terminates the line.
;
	CMP	AL,c_CR
	JNZ	ARM01		;AN000;; 2/17/KK
	Jmp	ENDLIN		;AN000;; 2/17/KK
ARM01:				;AN000;; 2/17/KK
;
; LF goes to a new line and keeps on reading.
;
	CMP	AL,c_LF
	JNZ	ARM00		;AN000;; 2/17/KK
	Jmp	PHYCRLF 	;AN000;; 2/17/KK
ARM00:				;AN000;; 2/17/KK
;
; ^X (or ESC) deletes the line and starts over
;


;hkn; CANCHAR is in TABLE seg (DOSCODE), so CS override
	CMP	AL,[CANCHAR]
	JNZ	SAVCH		;AN000;; 2/13/KK
	JMP	KILNEW		;AN000;; 2/13/KK
InterLoop:			;AN000;; 2/17/KK
	call	IntCNE0 	;AN000;; Get another interim character 2/17/KK
;
; Otherwise, we save the input character.
;
SAVCH:
	pushf			;AN000; 2/17/KK
	CMP	DH,DL
	JAE	BUFFUL			; buffer is full.
;----------------------------- Start of DBCS 2/13/KK

	invoke	TESTKANJ		;AN000;
	JZ	ISNORM			;AN000;
	INC	DH			;AN000;
	CMP	DH,DL			;AN000;
	JB	GOTROOM 		;AN000;
	DEC	DH			;AN000;; No room for second byte
	call	IntCNE0 		;AN000;; Get second byte
	JMP	SHORT BUFFUL		;AN000;
					;AN000;
GOTROOM:				;AN000;
	STOSB				;AN000;; Store first byte
	popf				;AN000;
	call	outchax 		;AN000;
	call	IntCNE0 		;AN000;; Get second byte
	pushf				;AN000;
	STOSB				;AN000;; Store second byte
	INC	DH			;AN000;
	popf				;AN000;
	call	outchax 		;AN000;
	jnz	ContIn1 		;AN000;; interim character?
	call	InterCheck		;AN000;
	call	InterCheck		;AN000;
	jmp	short InterLoop 	;AN000;; not interim skip another check

ISNORM:
;----------------------------- End of DBCS 2/13/KK
	STOSB				;AN000;
	INC	DH			;AN000;; increment count in buffer.
	popf				;AN000;; 2/17/KK
	invoke	BUFOUTx 		;AN000;; Print control chars nicely 2/17/KK
	jnz	ContIn1 		;AN000;; 2/17/KK
	call	InterCheck		;AN000;; 2/17/KK
	jmp	short InterLoop 	;AN000;; 2/17/KK
CONTIN1:				;AN000;; 2/13/KK
;;;CONTIN:				;AN000;; 2/13/KK

;hkn; SS override
	CMP	BYTE PTR [INSMODE],0
	JNZ	GETCH0			; insertmode => don't advance template
	CMP	BH,BL
	JAE	GETCH0			; no more characters in template
	INC	SI			; Skip to next char in template
	INC	BH			; remember position in template

	PUSH	AX			;
	MOV	AL,BYTE PTR [SI-1]	;AN000;;		    2/13/KK
	invoke	TESTKANJ		;AN000;;		    2/13/KK
	POP	AX			;AN000;;		    2/13/KK
	JZ	GETCH0			;AN000;; Wasn't a dual byte 2/13/KK
	INC	SI			;AN000;; Was a dual byte,   2/13/KK
	INC	BH			;AN000;;     skip one more  2/13/KK
GETCH0: 				;AN000;; 2/17/KK
	JMP	GETCH			;AN000;; 2/17/KK

IFDEF	JAPAN
BACKSPJ: JMP	BACKSP
ELSE
BACKSPJ: JMP	SHORT BACKSP
ENDIF

BUFFUL:
	popf				;AN000;; 2/17/KK
	MOV	AL,7			;AN000;; Bell to signal full buffer
	invoke	OUTT
	JMP	GETCH
;						2/17/KK
;	Reduce character count, reduce pointer	2/17/KK
;						2/17/KK
InterCheck:				;AN000;;       2/17/KK
	dec	dh			;AN000;; adjust count	       2/17/KK
	dec	di			;AN000;; adjust buffer pointer 2/17/KK
	ret				;AN000;;		       2/17/KK

ESCC:
	transfer    OEMFunctionKey	; let the OEM's handle the key dispatch

ENDLIN:
	STOSB				; Put the CR in the buffer
	invoke	OUTT			; Echo it
	POP	DI			; Get start of user buffer
	MOV	[DI-1],DH		; Tell user how many bytes
	INC	DH			; DH is length including CR
COPYNEW:
	SAVE	<DS,ES>
	RESTORE <DS,ES>		; XCHG ES,DS

;hkn; INBUF is in DOSDATA
	MOV	SI,OFFSET DOSDATA:INBUF
	MOV	CL,DH			; set up count
	REP	MOVSB			; Copy final line to user buffer
	return
;
; Output a CRLF to the user screen and do NOT store it into the buffer
;
PHYCRLF:
	invoke	CRLF
	JMP	GETCH

;
; Delete the previous line
;
LineDel:
	OR	DH,DH
	JNZ	bridge00	;AN000;; 2/13/KK
	JMP	GetCh		;AN000;; 2/13/KK
bridge00:			;AN000;; 2/13/KK
	Call	BackSpace
	JMP	LineDel

;
; delete the previous word.
;
WordDel:
WordLoop:
	Call	BackSpace		; backspace the one spot
	OR	DH,DH
	JZ	GetChJ
	MOV	AL,ES:[DI-1]
	cmp	al,'0'
	jb	GetChj
	cmp	al,'9'
	jbe	WordLoop
	OR	AL,20h
	CMP	AL,'a'
	JB	GetChJ
	CMP	AL,'z'
	JBE	WordLoop
GetChJ:
	JMP	GetCh
;
; The user wants to throw away what he's typed in and wants to start over.  We
; print the backslash and then go to the next line and tab to the correct spot
; to begin the buffered input.
;
	entry	KILNEW
	MOV	AL,"\"
	invoke	OUTT		;Print the CANCEL indicator
	POP	SI		;Remember start of edit buffer
PUTNEW:
	invoke	CRLF		;Go to next line on screen

;hkn; SS override
	MOV	AL,[STARTPOS]
	invoke	TAB		;Tab over
	JMP	NEWLIN		;Start over again


;
; Destructively back up one character position
;
entry	BackSp
	Call	BackSpace
	JMP	GetCh

BackSpace:
	OR	DH,DH
	JZ	OLDBAK		;No chars in line, do nothing to line
	CALL	BACKUP		;Do the backup
	MOV	AL,ES:[DI]	;Get the deleted char
	invoke	TESTKANJ	;AN000;2/13/KK
	JNZ	OLDBAK		;AN000; Was a dual byte, done  2/13/KK
	CMP	AL," "
	JAE	OLDBAK		;Was a normal char
	CMP	AL,c_HT
	JZ	BAKTAB		;Was a tab, fix up users display
ifdef	JAPAN			; MSKK02 07/14/89

;	^U and ^T backspace 2 characters in KANJI VERSION

else
;; 9/27/86 fix for ctrl-U backspace
	CMP	AL,"U"-"@"      ; ctrl-U is a section symbol not ^U
	JZ	OLDBAK
	CMP	AL,"T"-"@"      ; ctrl-T is a paragraphs symbol not ^T
	JZ	OLDBAK
;; 9/27/86 fix for ctrl-U backspace
endif
	CALL	BACKMES 	;Was a control char, zap the '^'
OLDBAK:

;hkn; SS override
	CMP	BYTE PTR [INSMODE],0
	retnz			;In insert mode, done
	OR	BH,BH
	retz			;Not advanced in template, stay where we are
	DEC	BH		;Go back in template
	DEC	SI
;-------------------------- Start of DBCS 2/13/KK
	OR	BH,BH		;AN000;
	retz			;AN000;; If we deleted one char and it was the only
				;AN000;;  one, could not have dual byte
;;;;	POP	AX		;AN000;; Get start of template
;;;;	PUSH	AX		;AN000;; Put it back on stack

;hkn; SS override
	mov	ax,ss:Temp_Var	;AN000;; 3/31/KK
	XCHG	AX,SI		;AN000;
LOOKDUAL:			;AN000;
	CMP	SI,AX		;AN000;
	JAE	ATLOC		;AN000;
	PUSH	AX		;AN000;
	MOV	AL,BYTE PTR [SI];AN000;
	invoke	TESTKANJ	;AN000;
	POP	AX		;AN000;
	JZ	ONEINC		;AN000;
	INC	SI		;AN000;
ONEINC: 			;AN000;
	INC	SI		;AN000;
	JMP	SHORT LOOKDUAL	;AN000;
				;AN000;
ATLOC:				;AN000;
	retz			;AN000;; Correctly pointing to start of single byte
	DEC	AX		;AN000;; Go back one more to correctly point at start
	DEC	BH		;AN000;        ; of dual byte
	MOV	SI,AX		;AN000;
	return			;AN000;
;-------------------------- End of DBCS 2/13/KK

BAKTAB:
	PUSH	DI
	DEC	DI		;Back up one char
	STD			;Go backward
	MOV	CL,DH		;Number of chars currently in line
	MOV	AL," "
	PUSH	BX
	MOV	BL,7		;Max
	JCXZ	FIGTAB		;At start, do nothing
FNDPOS:
	SCASB			;Look back
	JNA	CHKCNT
	CMP	BYTE PTR ES:[DI+1],9
	JZ	HAVTAB		;Found a tab
	DEC	BL		;Back one char if non tab control char
CHKCNT:
	LOOP	FNDPOS
FIGTAB:

;hkn; SS override
	SUB	BL,[STARTPOS]
HAVTAB:
	SUB	BL,DH
	ADD	CL,BL
	AND	CL,7		;CX has correct number to erase
	CLD			;Back to normal
	POP	BX
	POP	DI
	JZ	OLDBAK		;Nothing to erase
TABBAK:
	invoke	BACKMES
	LOOP	TABBAK		;Erase correct number of chars
	JMP	SHORT OLDBAK

BACKUP:
	DEC	DH		;Back up in line
	DEC	DI
;-------------------------Start of DBCS 2/13/KK
	OR	DH,DH			;AN000;
	JZ	BACKMES 		;AN000;; If deleted one and got only, no dual
	MOV	AX,DI			;AN000;

;hkn; INBUF is in DOSDATA
	MOV	DI,OFFSET DOSDATA:INBUF;AN000;
LOOKDUAL2:				;AN000;
	CMP	DI,AX			;AN000;
	JAE	ATLOC2			;AN000;
	PUSH	AX			;AN000;
	MOV	AL,BYTE PTR ES:[DI]	;AN000;
	invoke	TESTKANJ		;AN000;
	POP	AX			;AN000;
	JZ	ONEINC2 		;AN000;
	INC	DI			;AN000;
ONEINC2:				;AN000;
	INC	DI			;AN000;
	JMP	SHORT LOOKDUAL2 	;AN000;
					;AN000;
ATLOC2: 				;AN000;
	JE	BACKMES 		;AN000;; Correctly deleted single byte
	DEC	AX			;AN000; Go back one more to correctly delete dual byte
	DEC	DH			;AN000;
	MOV	DI,AX			;AN000;
	CALL	BACKMES 		;AN000;
;---------------------------End of DBCS 2/13/KK
BACKMES:
	MOV	AL,c_BS 	;Backspace
	invoke	OUTT
	MOV	AL," "          ;Erase
	invoke	OUTT
	MOV	AL,c_BS 	;Backspace
	JMP	OUTT		;Done

;User really wants an ESC character in his line
	entry	TwoEsc

;hkn; ESCCHAR is in DOSCODE so CS override
	MOV	AL,[ESCCHAR]
	JMP	SAVCH

;Copy the rest of the template
	entry	COPYLIN
	MOV	CL,BL		;Total size of template
	SUB	CL,BH		;Minus position in template, is number to move
	JMP	SHORT COPYEACH

	entry	CopyStr
	invoke	FINDOLD 	;Find the char
	JMP	SHORT COPYEACH	;Copy up to it

;Copy one char from template to line
	entry	COPYONE
	MOV	CX,1			;AN000;;	       2/13/KK
	MOV	AL,[SI] 		;AN000;; get char      2/13/KK
	invoke	TestKanj		;AN000;; is it kanji?  2/13/KK
	JZ	CopyEach		;AN000;; no, go do copy2/13/KK
	INC	CX			;AN000;; do 2 byte copy2/13/KK

;Copy CX chars from template to line
COPYEACH:

;hkn; SS override
	MOV	BYTE PTR [INSMODE],0	;All copies turn off insert mode
	CMP	DH,DL
	JZ	GETCH2			;At end of line, can't do anything
	CMP	BH,BL
	JZ	GETCH2			;At end of template, can't do anything
	LODSB
	STOSB
;----------------------------- Start of DBCS 2/13/KK
	INC	BH			;AN000;; Ahead in template
	INC	DH			;AN000;; Ahead in line
	CALL	TestKanj		;AN000;; 2 byte character?
	JZ	CopyLoop		;AN000;; no, go copy next
	CMP	DH,DL			;AN000;; over boundary?
	JNZ	CopyBoth		;AN000;; no, move both
	DEC	BH			;AN000;; yes, backup template
	DEC	DH			;AN000;; back up line
	DEC	SI			;AN000;; patch (from Dohhaku)
	DEC	DI			;AN000;; remember to backup after previous move
	JMP	GetCh			;AN000;; go get next char
					;AN000;
CopyBoth:				;AN000;
	invoke	BUFOUT			;AN000;; output the first byte
	LODSB				;AN000;; get the second
	STOSB				;AN000;; move the second
	INC	BH			;AN000;; bump template
	INC	DH			;AN000;; bump line
	DEC	CX			;AN000;; dump byte count
CopyLoop:				;AN000;
	invoke	BUFOUT			;AN000;
	LOOP	COPYEACH		;AN000;
;;;;;	invoke	BUFOUT
;;;;;	INC	BH			;Ahead in template
;;;;;	INC	DH			;Ahead in line
;;;;;	LOOP	COPYEACH
;----------------------------- End of DBCS 2/13/KK
GETCH2:
	JMP	GETCH

;Skip one char in template
	entry	SKIPONE
	CMP	BH,BL
	JZ	GETCH2			;At end of template
	INC	BH			;Ahead in template
	INC	SI
	PUSH	AX			;AN000;; 2/13/KK
	MOV	AL,BYTE PTR [SI-1]	;AN000;; 2/13/KK
	invoke	TESTKANJ		;AN000;; 2/13/KK
	POP	AX			;AN000;; 2/13/KK
	JZ	GETCH2			;AN000;; 2/13/KK
	INC	BH			;AN000;; 2/13/KK
	INC	SI			;AN000;; 2/13/KK
	JMP	GETCH

	entry	SKIPSTR
	invoke	FINDOLD 		;Find out how far to go
	ADD	SI,CX			;Go there
	ADD	BH,CL
	JMP	GETCH

;Get the next user char, and look ahead in template for a match
;CX indicates how many chars to skip to get there on output
;NOTE: WARNING: If the operation cannot be done, the return
;	address is popped off and a jump to GETCH is taken.
;	Make sure nothing extra on stack when this routine
;	is called!!! (no PUSHes before calling it).

;hkn; LOOKSIZ has been moved to DATA seg (ms_data.asm)
;hkn; TABLE	SEGMENT 			;AN000;; 2/17/KK
;hkn; Public	KISTR001S,KISTR001E		;AN000;; 2/17/KK
;hkn; KISTR001S	label	byte		;AN000;; 2/17/KK
;hkn; LOOKSIZ DB	0			;AN000;; 0 if byte, NZ if word	2/17/KK
;hkn; KISTR001E	label	byte		;AN000;; 2/17/KK
;hkn; TABLE	ENDS				;AN000;; 2/17/KK

extrn	LOOKSIZ	: byte

FINDOLD:

;hkn; SS override
	MOV	[LOOKSIZ],0		;AN000;; Initialize to byte    2/13/KK
	call	IntCNE1 		;AN000;;		       2/17/KK

;hkn; ESCCHAR is in DOSCODE so CS override
	CMP	AL,[ESCCHAR]		;AN000;; did he type a function key?
;;;;;	JNZ	FindSetup		;AN000;; no, set up for scan   2/13/KK
	JNZ	TryKanj 		;AN000;; no, continue testing  2/13/KK
	call	IntCNE1 		;AN000;;		       2/17/KK
	JMP	NotFnd			       ; go try again
;;;;;;;FindSetup:			;AN000;; 2/13/KK
TryKanj:				;AN000;; 2/13/KK
	invoke	TESTKANJ		;AN000;; 2/13/KK
	JZ	GOTLSIZ 		;AN000;; 2/13/KK

;hkn; SS override
	INC	[LOOKSIZ]		;AN000;; Gonna look for a word	2/13/KK
	PUSH	AX			;AN000;; Save first byte	2/13/KK
	call	IntCNE1 		;AN000;;		       2/17/KK
	POP	CX			;AN000;; 2/13/KK
	MOV	AH,AL			;AN000;; 2/13/KK
	MOV	AL,CL			;AN000;; AX is dual byte sequence to look for
	XOR	CX,CX			;AN000;; Re-zero CH	2/13/KK
GOTLSIZ:
	MOV	CL,BL
	SUB	CL,BH		;CX is number of chars to end of template
	JZ	NOTFND		;At end of template
	DEC	CX		;Cannot point past end, limit search
	JZ	NOTFND		;If only one char in template, forget it
	PUSH	AX			;AN000;; 2/13/KK
	MOV	AL,BYTE PTR [SI]	;AN000;; 2/13/KK
	invoke	TESTKANJ		;AN000;; 2/13/KK
	POP	AX			;AN000;; 2/13/KK
	JZ	NOTDUAL5		;AN000;; 2/13/KK
	DEC	CX			;AN000;; And one more besides	2/13/KK
	JZ	NOTFND			;AN000;; If only one char in template, forget it
NOTDUAL5:				;AN000;; 2/13/KK
	PUSH	ES
	PUSH	DS
	POP	ES
	PUSH	DI
	MOV	DI,SI		;Template to ES:DI
;;;;	INC	DI		  2/13/KK
;;;;	REPNE	SCASB		;Look  2/13/KK
;--------------------- Start of DBCS 2/13/KK
	PUSH	AX			;AN000;
	MOV	AL,BYTE PTR ES:[DI]	;AN000;
	invoke	TESTKANJ		;AN000;
	POP	AX			;AN000;
	JZ	ONEINC5 		;AN000;
	INC	DI			;AN000;; We will skip at least something
ONEINC5:				;AN000;
	INC	DI			;AN000;

;hkn; SS override
	CMP	[LOOKSIZ],0		;AN000;
	JNZ	LOOKWORD		;AN000;
LOOKBYTE:				;AN000;
	PUSH	AX			;AN000;
	MOV	AL,BYTE PTR ES:[DI]	;AN000;
	invoke	TESTKANJ		;AN000;
	POP	AX			;AN000;
	JZ	TESTITB 		;AN000;
	INC	DI			;AN000;
	INC	DI			;AN000;
	DEC	CX			;AN000;
	LOOP	LOOKBYTE		;AN000;
	JMP	SHORT ATNOTFND		;AN000;
					;AN000;
TESTITB:				;AN000;
	DEC	CX			;AN000;
	CMP	AL,ES:[DI]		;AN000;
	JZ	ATSPOT			;AN000;
	INC	DI			;AN000;
	INC	CX			;AN000;; Counter next instruction
	LOOP	LOOKBYTE		;AN000;
ATNOTFND:				;AN000;
	XOR	AL,AL			;AN000;
	INC	AL			;AN000;; Set NZ
ATSPOT: 			; 2/13/K;AN000;K
;--------------------- End of DBCS 2/13/KK
	POP	DI
	POP	ES
	JNZ	NOTFND		;Didn't find the char
	NOT	CL		;Turn how far to go into how far we went
	ADD	CL,BL		;Add size of template
	SUB	CL,BH		;Subtract current pos, result distance to skip
	return

NOTFND:
	POP	BP		;Chuck return address
	JMP	GETCH
;------------------------- Start of DBCS 2/13/KK
LOOKWORD:			       ;AN000;
	PUSH	AX		       ;AN000;
	MOV	AL,BYTE PTR ES:[DI]    ;AN000;
	invoke	TESTKANJ	       ;AN000;
	POP	AX		       ;AN000;
	JNZ	TESTITW 	       ;AN000;
	INC	DI		       ;AN000;
	LOOP	LOOKWORD	       ;AN000;
	JMP	SHORT ATNOTFND	       ;AN000;
				       ;AN000;
TESTITW:			       ;AN000;
	DEC	CX		       ;AN000;
	CMP	AX,ES:[DI]	       ;AN000;
	JZ	ATSPOT		       ;AN000;
	INC	DI		       ;AN000;
	INC	DI		       ;AN000;
	LOOP	LOOKWORD	       ;AN000; ; Performs second DEC of CX
	JMP	SHORT ATNOTFND	       ;AN000;
;------------------------- End of DBCS 2/13/KK

entry	REEDIT
	MOV	AL,"@"          ;Output re-edit character
	invoke	OUTT
	POP	DI
	PUSH	DI
	PUSH	ES
	PUSH	DS
	invoke	COPYNEW 	;Copy current line into template
	POP	DS
	POP	ES
	POP	SI
	MOV	BL,DH		;Size of line is new size template
	JMP	PUTNEW		;Start over again

	entry	EXITINS
	entry	ENTERINS

;hkn; SS override
	NOT	BYTE PTR [INSMODE]
	JMP	GETCH

;Put a real live ^Z in the buffer (embedded)
	entry	CTRLZ
	MOV	AL,"Z"-"@"
	JMP	SAVCH

;Output a CRLF
	entry	CRLF
	MOV	AL,c_CR
	invoke	OUTT
	MOV	AL,c_LF
	JMP	OUTT

EndProc $STD_CON_STRING_INPUT

;-------------- Start of DBCS 2/17/KK
PUBLIC	IntCNE0 			;AN000;
procedure	IntCNE0,near		;AN000;

;hkn SS override for InterCon
	push	word ptr [InterCon]	;AN000;
	mov	[InterCon],01		;AN000;
get_com:				;AN000;
	invoke	INTER_CON_INPUT_NO_ECHO ;AN000;; get a byte character
	pop	word ptr [InterCon]	;AN000;
	ret				;AN000;
IntCNE0 endp				;AN000;
					;AN000;
procedure	IntCNE1,near		;AN000;
	push	word ptr [InterCon]	;AN000;
	mov	[InterCon],00		;AN000;
	jmp	short get_com		;AN000;
IntCNE1 endp				;AN000;
					;AN000;
	procedure	outchax,near	;AN000;

;hkn; SS override for SaveCurFlag
	pushf				;AN000;
	mov	[SaveCurFlg],0		;AN000;
	jnz	sj1			;AN000;
	mov	[SaveCurFlg],1		;AN000;
sj1:					;AN000;
	CALL	OUTCHA			;AN000;
	mov	[SaveCurFlg],0		;AN000;
	popf				;AN000;
	ret				;AN000;
outchax endp				;AN000;
					;AN000;
	procedure	bufoutx,near	;AN000;
	pushf				;AN000;
	mov	[SaveCurFlg],0		;AN000;
	jnz	sj2			;AN000;
	mov	[SaveCurFlg],1		;AN000;
sj2:					;AN000;
	invoke	BUFOUT			;AN000;
	mov	[SaveCurFlg],0		;AN000;
	popf				;AN000;
	ret				;AN000;
bufoutx endp				;AN000;
;-------------- End of DBCS 2/17/KK

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\misc.asm ===
TITLE MISC - Miscellanious routines for MS-DOS
	NAME  MISC

;**	Miscellaneous system calls most of which are CAVEAT
;
;	$SLEAZEFUNC
;	$SLEAZEFUNCDL
;	$GET_INDOS_FLAG
;	$GET_IN_VARS
;	$GET_DEFAULT_DPB
;	$GET_DPB
;	$DISK_RESET
;	$SETDPB
;	$Dup_PDB
;	$CREATE_PROCESS_DATA_BLOCK
;	SETMEM
;	FETCHI_CHECK
;	$GSetMediaID
;
;	Revision  history:
;
;	sudeepb 14-Mar-1991 Ported for NT DOSEm

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include mult.inc
	include pdb.inc
	include dpb.inc
	include bpb.inc
	include vector.inc
	include sf.inc
	include filemode.inc
	include mi.inc
	include curdir.inc
	include bugtyp.inc
	include dossvc.inc
	.cref
	.list

	i_need	LASTBUFFER,DWORD
	i_need	INDOS,BYTE
	i_need	SYSINITVAR,BYTE
	i_need	CurrentPDB,WORD
	i_need	CreatePDB,BYTE
	i_need	FATBYTE,BYTE
	i_need	THISCDS,DWORD
	i_need	THISSFT,DWORD
	i_need	HIGH_SECTOR,WORD		 ;AN000; high word of sector #
	i_need	DOS34_FLAG,WORD 		 ;AN000;
	i_need	SC_STATUS,WORD			 ; M041
	I_need	JFN,WORD
	I_need	SFN,WORD

	EXTRN	CURDRV		:BYTE

DosData SEGMENT WORD PUBLIC 'DATA'
	allow_getdseg
	EXTRN	SCS_TSR 	:BYTE
        EXTRN   SCS_CMDPROMPT   :BYTE
        EXTRN   SCS_DOSONLY     :BYTE
	EXTRN	FAKE_NTDPB	:BYTE
	EXTRN	SCS_FDACCESS	:WORD
DosData ENDS

DOSCODE	SEGMENT

	EXTRN	pJfnFromHandle:near
	EXTRN	SFFromHandle:near
	EXTRN	SFNFree:near
	EXTRN	JFNFree:near

	allow_getdseg


	ASSUME	SS:DOSDATA,CS:DOSCODE

ENTRYPOINTSEG	EQU	0CH
MAXDIF		EQU	0FFFH
SAVEXIT 	EQU	10
WRAPOFFSET	EQU	0FEF0h


	BREAK	<SleazeFunc -- get a pointer to media byte>
;
;----------------------------------------------------------------------------
;
;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
;
;	Return Stuff sort of like old get fat call
;
;	ENTRY	none
;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
;			GOD help anyone who tries to do ANYTHING except
;			READ this ONE byte.
;		DX = Total Number of allocation units on disk
;		CX = Sector size
;		AL = Sectors per allocation unit
;		   = -1 if bad drive specified
;	USES	all
;
;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
;
;	Identical to $SLEAZEFUNC except (dl) = drive
;
;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
;			GOD help anyone who tries to do ANYTHING except
;			READ this ONE byte.
;		DX = Total Number of allocation units on disk
;		CX = Sector size
;		AL = Sectors per allocation unit
;		   = -1 if bad drive specified
;	USES	all
;
;----------------------------------------------------------------------------
;


procedure   $SLEAZEFUNC,NEAR

	MOV	DL,0

entry	$SLEAZEFUNCDL
	context DS

	MOV	AL,DL
	invoke	GETTHISDRV		; Get CDS structure
SET_AL_RET:
;	MOV	AL,error_invalid_drive	; Assume error				;AC000;
	JC	BADSLDRIVE
ifdef NEC_98
;------------------10/01/93 NEC for MAOIX--------------------------------------
BIOSCODE	equ	0060h		; BIOS code segment
LPTABLE 	equ	006ch		; Points to Lptable

	push	ax
	push	bx
	push	ds
	mov	bx,BIOSCODE
	mov	ds,bx
	mov	bx,LPTABLE
	xlat				; Get DA/UA in AL
	mov	ah,01h			; Dummy verify command
	pop	ds
	pop	bx
	int	1bh			; Dummy ROM call
	pop	ax
endif   ;NEC_98
	HRDSVC	SVC_DEMGETDRIVEFREESPACE
	JC	SET_AL_RET		; User FAILed to I 24
	mov	[FATBYTE],al
sl05:
; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
; CALL AGAIN

;; save the sectors per cluster returned from 32bits
;; this is done because get_user_stack will destroy si
	mov	ax, si

;hkn;	FATBYTE is in DATA seg (DOADATA)
	MOV	DI,OFFSET DOSDATA:FATBYTE
	invoke	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_CX],CX
	MOV	[SI.user_DX],DX
	MOV	[SI.user_BX],DI
	MOV	[SI.user_AX],AX

;hkn; Use SS as pointer to DOSDATA
	mov	[si.user_DS],SS
;	MOV     [SI.user_DS],CS         ; stash correct pointer

	return
BADSLDRIVE:
	transfer    FCB_Ret_ERR


EndProc $SleazeFunc

	BREAK <$Get_INDOS_Flag -- Return location of DOS critical-section flag>

;
;----------------------------------------------------------------------------
;
;**	$Get_INDOS_Flag - Return location of DOS Crit Section Flag
;
;	Returns location of DOS status for interrupt routines
;									   ;
;	ENTRY	none
;	EXIT	(es:bx) = flag location
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $GET_INDOS_FLAG,NEAR

	invoke	get_user_stack

;hkn;	INDOS is in DATA seg (DOSDATA)
	MOV     [SI.user_BX],OFFSET DOSDATA:INDOS

	MOV	[SI.user_ES],SS
	return

EndProc $GET_INDOS_FLAG


	BREAK <$Get_IN_VARS -- Return a pointer to DOS variables>

;
;----------------------------------------------------------------------------
;
;**	$Get_IN_Vars - Return Pointer to DOS Variables
;
;	Return a pointer to interesting DOS variables This call is version
;	dependent and is subject to change without notice in future versions.
;	Use at risk.
;
;	ENTRY	none
;	EXIT	(es:bx) = address of SYSINITVAR
;	uses	ALL
;
;----------------------------------------------------------------------------
;

procedure   $GET_IN_VARS,NEAR

	invoke	get_user_stack
    ASSUME DS:nothing
;hkn;	SYSINITVAR is in CONST seg (DOSDATA)
	MOV     [SI.user_BX],OFFSET DOSDATA:SYSINITVAR

	MOV	[SI.user_ES],SS
	return
EndProc $GET_IN_VARS


BREAK <$Get_Default_DPB,$Get_DPB -- Return pointer to DPB>

;
;----------------------------------------------------------------------------
;
;**	$Get_Default_DPB - Return a pointer to the Default DPB
;
;	Return pointer to drive parameter table for default drive
;
;	ENTRY	none
;	EXIT	(ds:bx) = DPB address
;	USES	all
;
;**	$Get_DPB - Return a pointer to a specified DPB
;
;	Return pointer to a specified drive parameter table
;
;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
;	EXIT	(al) = 0 iff ok
;		  (ds:bx) = DPB address
;		(al) = -1 if bad drive
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $GET_DEFAULT_DPB,NEAR
	MOV	DL,0

	entry	$GET_DPB

	context DS

	MOV	AL,DL
	invoke	GETTHISDRV		; Get CDS structure
	JNC	gd01			; no valid drive
	JMP	ISNODRV 		; no valid drive
gd01:
	LES	DI,[THISCDS]		; check for net CDS
	TESTB	ES:[DI.curdir_flags],curdir_isnet
	JNZ	ISNODRV 		; No DPB to point at on NET stuff
	mov	di, offset DOSDATA:FAKE_NTDPB
	HRDSVC	SVC_DEMGETDPB

	JC	ISNODRV 		; User FAILed to I 24, only error we
	invoke	get_user_stack
ASSUME	DS:NOTHING
	MOV	[SI.user_BX],DI
	MOV	[SI.user_DS],SS
	XOR	AL,AL
	return

ISNODRV:
	MOV	AL,-1
	return

EndProc $GET_Default_dpb


	BREAK <$Disk_Reset -- Flush out all dirty buffers>

;
;----------------------------------------------------------------------------
;
;**	$Disk_Reset - Flush out Dirty Buffers
;
;	$DiskReset flushes and invalidates all buffers.  BUGBUG - do
;		we really invalidate?  SHould we?  THis screws non-removable
;		caching.  Maybe CHKDSK relies upon it, though....
;
;	ENTRY	none
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

procedure   $DISK_RESET,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	cmp	word ptr ss:[SCS_FDACCESS],0
	je	res_ret

	HRDSVC	SVC_DEMDISKRESET

res_ret:
	clc
	return

EndProc $DISK_RESET

	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>

;
;----------------------------------------------------------------------------
;
;**	$SetDPB - Create a DPB
;
;	SetDPB Creates a valid DPB from a user-specified BPB
;
;	ENTRY	eS:BP Points to DPB
;		DS:SI Points to BPB
;
;	NT DOSEM is using this function for its sleazy purposes.
;	Most of these defined ordinals are for SCS purposes.
;	If BP ==0 && SI == 0 implies MVDM sleaz functions
;	with function number in AL. Increment max_sleaze_func below
;	when adding more sub-functions.
;
;	    AL = 0 => Allocate SCS console
;	      Entry
;		BX:CX is the 32bit NT handle
;		DX:DI = file size
;	      Exit
;		CY clear means success => AX = JFN
;		CY set means error
;
;	    AL = 1 => Free SCS console
;	      Entry
;		BX = JFN
;	      Exit
;		CY clear means success
;		CY set means trouble
;
;	    AL = 2 => Query TSR presence bit
;	      Entry
;		None
;	      Exit
;		CY clear means no TSR is present
;		CY set means TSR is present
;               TSR bit is reset always after this call
;           AL = 3 => Query standard handles
;              Entry
;               BX = handle (0-stdin, 1-stdout, 2-stderr)
;              Exit
;               Success - Carry clear (NT handle in BX:CX)
;		Failure - Carry set (fails if std handle is local device).
;           AL = 4 => NTCMDPROMPT command was set in config.nt
;	       Entry
;		None
;	       Exit
;		None
;
;           AL = 5 => Query NTCMDPROMPT state
;	       Entry
;		None
;	       Exit
;               al = 1 means NTCMDPROMPT bit was present in config.nt
;               al = 0 means NTCMDPROMPT bit was not present in config.nt
;           AL = 6 => DOSONLY command was set in config.nt
;	       Entry
;		None
;	       Exit
;		None
;
;           AL = 7 => Query DOSONLY state
;	       Entry
;		None
;	       Exit
;               al = 1 means DOSONLY bit was present in config.nt
;               al = 0 means DOSONLY bit was not present in config.nt
;
;	EXIT	DPB setup
;	USES	ALL but BP, DS, ES
;
;----------------------------------------------------------------------------
;
word3	dw	3		; M008 -- word value for divides
max_sleaze_scs  equ  7          ; MAXIMUM scs SLEAZE functions

procedure   $SETDPB,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	or	bp,bp
	jz	check_more
	jmp	real_setdpb
check_more:
	or	si,si
	jz	some_more
	jmp	real_setdpb
some_more:
	cmp	al,max_sleaze_scs
	jbe	check_done
	jmp	setdpb
check_done:

	or	al,al
        jz      alloc_con           ; al =0
	dec	al
        jz      free_con            ; al =1
        dec     al
	jz	q_tsr		    ; al =2
	dec	al
	jnz	do_prmpt
	jmp	query_con	    ; al =3
do_prmpt:
	dec	al
	jnz	q_prmpt
        mov     byte ptr ss:[scs_cmdprompt],1
	jmp	ok_ret
q_prmpt:
        dec     al
        jnz     dosonly
        mov     al, byte ptr ss:[scs_cmdprompt]
        jmp     ok_ret

dosonly:
        dec     al
        jnz     q_dosonly
        mov     byte ptr ss:[scs_dosonly],1
        jmp     ok_ret
q_dosonly:
        mov     al, byte ptr ss:[scs_dosonly]
        jmp     ok_ret

q_tsr:
	cmp	byte ptr ss:[SCS_TSR],0
	mov	byte ptr [SCS_TSR],0
	jz	q_ret
	jmp	setdpb
q_ret:
	jmp	ok_ret

	; free scs console
free_con:
	call	SFFromHandle		; get system file entry in es:di
        jnc     fc_10
        jmp     setdpb
fc_10:
	test	es:[di.sf_flags],sf_scs_console
        jnz     fc_15
        jmp     setdpb
fc_15:
	MOV	ES:[DI.sf_ref_count],0	; free sft
	call	pJFNFromHandle		; es:di = pJFN (handle);
        jnc     fc_20
        jmp     setdpb
fc_20:
	MOV	BYTE PTR ES:[DI],0FFh	; release the JFN
	jmp	ok_ret

alloc_con:
	push	bx
	push	cx
	push	dx			; save file size
	push	di
	call	SFNFree 		; get a free sfn
        JNC     ac_5                    ; oops, no free sft's
        JMP     alloc_err               ; oops, no free sft's
ac_5:
	MOV	SFN,BX			; save the SFN for later
	MOV	WORD PTR ThisSFT,DI	; save the SF offset
	MOV	WORD PTR ThisSFT+2,ES	; save the SF segment
	invoke	JFNFree 		; get a free jfn
	JC	alloc_err		; No need to free SFT; DOS is robust enough for this
	MOV	JFN,BX			; save the jfn itself
	MOV	BX,SFN
	MOV	ES:[DI],BL		; assign the JFN
	mov	di,WORD PTR ThisSFT
	MOV	es,WORD PTR ThisSFT+2
	mov	es:[di.sf_ref_count],1
	MOV	BYTE PTR ES:[DI.sf_mode],0
	MOV	BYTE PTR ES:[DI.sf_attr],0
        mov     word ptr ES:[DI.SF_Position],0
        mov     word ptr ES:[DI.SF_Position+2],0
	pop	word ptr ES:[DI.SF_Size]
	pop	word ptr ES:[DI.SF_Size + 2]
	mov	word ptr ES:[DI.SF_flags], sf_scs_console
	cmp	JFN, 0			;STDIN?
	jne	ac_6
	or	word ptr ES:[DI.sf_flags], sf_nt_pipe_in    ;special case for
ac_6:
	pop	cx
	pop	bx
	mov	word ptr es:[di.sf_NTHandle],cx
	mov	word ptr es:[di.sf_NTHandle+2],bx
	mov	ax,JFN
	MOV	SFN,-1			; clear out sfn pointer	;smr;SS Override
ok_ret:
        transfer    Sys_Ret_OK          ; bye with no errors

alloc_err:
	pop	di
	pop	dx
	pop	cx
	pop	bx
setdpb:
	error	error_invalid_function

query_con:
	call	SFFromHandle		; get system file entry in es:di
        jnc     qc_10
        jmp     setdpb
qc_10:
        test    es:[di.sf_flags],devid_device
        jnz     setdpb
        mov     cx,word ptr es:[di.sf_NTHandle]
        mov     bx,word ptr es:[di.sf_NTHandle+2]    ; bx:cx is NT handle
	invoke	Get_user_stack
        MOV     DS:[SI.User_CX],CX
        MOV     DS:[SI.User_BX],BX
	jmp	short ok_ret
EndProc $SETDPB

real_setdpb:
	MOV	DI,BP
	ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
	LODSW
	STOSW				; dpb_sector_size
	CMP	BYTE PTR [SI.BPB_NUMBEROFFATS-2],0     ; FAT file system drive		;AN000;
	JNZ	yesfat			      ; yes				;AN000;
	MOV	BYTE PTR ES:[DI.dpb_FAT_count-4],0
	JMP	short setend			      ; NO				;AN000;
yesfat:
	MOV	DX,AX
	LODSB
	DEC	AL
	STOSB				; dpb_cluster_mask
	INC	AL
	XOR	AH,AH
LOG2LOOP:
	test	AL,1
	JNZ	SAVLOG
	INC	AH
	SHR	AL,1
	JMP	SHORT LOG2LOOP
SAVLOG:
	MOV	AL,AH
	STOSB				; dpb_cluster_shift
	MOV	BL,AL
	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
	LODSB
	STOSB				; dpb_FAT_count Number of FATs
;	OR	AL,AL			; NONFAT ?				;AN000;
;	JZ	setend			; yes, don't do anything                ;AN000;
	MOV	BH,AL
	LODSW
	STOSW				; dpb_root_entries Number of directory entries
	MOV	CL,5
	SHR	DX,CL			; Directory entries per sector
	DEC	AX
	ADD	AX,DX			; Cause Round Up
	MOV	CX,DX
	XOR	DX,DX
	DIV	CX
	MOV	CX,AX			; Number of directory sectors
	INC	DI
	INC	DI			; Skip dpb_first_sector
	MOVSW				; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
	LODSB
	MOV	ES:[BP.dpb_media],AL	; Media byte
	LODSW				; Number of sectors in a FAT
	STOSW				;AC000;;>32mb dpb_FAT_size
	MOV	DL,BH			;AN000;;>32mb
	XOR	DH,DH			;AN000;;>32mb
	MUL	DX			;AC000;;>32mb Space occupied by all FATs
	ADD	AX,ES:[BP.dpb_first_FAT]
	STOSW				; dpb_dir_sector
	ADD	AX,CX			; Add number of directory sectors
	MOV	ES:[BP.dpb_first_sector],AX

	MOV	CL,BL		       ;F.C. >32mb				;AN000;
	CMP	WORD PTR ES:[BP.DSKSIZ],0	;F.C. >32mb			;AN000;
	JNZ	normal_dpb	       ;F.C. >32mb				;AN000;
	XOR	CH,CH		       ;F.C. >32mb				;AN000;
	MOV	BX,WORD PTR [SI+BPB_BigTotalSectors-BPB_SectorsPerTrack]	;AN000;
	MOV	DX,WORD PTR [SI+BPB_BigTotalSectors-BPB_SectorsPerTrack+2]	;AN000;
	SUB	BX,AX		       ;AN000;;F.C. >32mb
	SBB	DX,0		       ;AN000;;F.C. >32mb
	OR	CX,CX		       ;AN000;;F.C. >32mb
	JZ	norot		       ;AN000;;F.C. >32mb
rott:				       ;AN000;;F.C. >32mb
	CLC			       ;AN000;;F.C. >32mb
	RCR	DX,1		       ;AN000;;F.C. >32mb
	RCR	BX,1		       ;AN000;;F.C. >32mb
	LOOP	rott		       ;AN000;;F.C. >32mb
norot:				       ;AN000;
	MOV	AX,BX		       ;AN000;;F.C. >32mb
	JMP	short setend		;AN000;;F.C. >32mb
normal_dpb:
	SUB	AX,ES:[BP.DSKSIZ]
	NEG	AX			; Sectors in data area
;;	MOV	CL,BL			; dpb_cluster_shift
	SHR	AX,CL			; Div by sectors/cluster
setend:

;	M008 - CAS
;
	INC	AX			; +2 (reserved), -1 (count -> max)
;
;	There has been a bug in our fatsize calculation for so long
;	  that we can't correct it now without causing some user to
;	  experience data loss.  There are even cases where allowing
;	  the number of clusters to exceed the fats is the optimal
;	  case -- where adding 2 more fat sectors would make the
;	  data field smaller so that there's nothing to use the extra
;	  fat sectors for.
;
;	Note that this bug had very minor known symptoms.  CHKDSK would
;	  still report that there was a cluster left when the disk was
;	  actually full.  Very graceful failure for a corrupt system
;	  configuration.  There may be worse cases that were never
;	  properly traced back to this bug.  The problem cases only
;	  occurred when partition sizes were very near FAT sector
;	  rounding boundaries, which were rare cases.
;
;	Also, it's possible that some third-party partition program might
;	  create a partition that had a less-than-perfect FAT calculation
;	  scheme.  In this hypothetical case, the number of allocation
;	  clusters which don't actually have FAT entries to represent
;	  them might be larger and might create a more catastrophic
;	  failure.  So we'll provide the safeguard of limiting the
;	  max_cluster to the amount that will fit in the FATs.
;
;	ax = maximum legal cluster, ES:BP -> dpb

;	make sure the number of fat sectors is actually enough to
;	  hold that many clusters.  otherwise, back the number of
;	  clusters down

	mov	bx,ax			; remember calculated # clusters
	mov	ax,ES:[BP.dpb_fat_size]
	mul	ES:[BP.dpb_sector_size]	; how big is the FAT?
	cmp	bx,4096-10		; test for 12 vs. 16 bit fat
	jb	setend_fat12
	shr	dx,1
	rcr	ax,1			; find number of entries
	cmp	ax,4096-10+1		; would this truncation move us
;					;  into 12-bit fatland?
	jb	setend_faterr		; then go ahead and let the
;					;  inconsistency pass through
;					;  rather than lose data by
;					;  correcting the fat type
	jmp	short setend_fat16

setend_fat12:
	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
	adc	dx,dx
	div	cs:word ptr word3

setend_fat16:
	dec	ax			; limit at 1
	cmp	ax,bx			; is fat big enough?
	jbe	setend_fat		; use max value that'll fit

setend_faterr:
	mov	ax,bx			; use calculated value

setend_fat:

;	now ax = maximum legal cluster

;	end M008

	MOV	ES:[BP.dpb_max_cluster],AX
	MOV	ES:[BP.dpb_next_free],0 ; Init so first ALLOC starts at
					; begining of FAT
	MOV	ES:[BP.dpb_free_cnt],-1 ; current count is invalid.
	return


BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>

;
;----------------------------------------------------------------------------
;
;**	$Dup_PDB
;
; Inputs:   DX is new segment address of process
;	    SI is end of new allocation block
;
;----------------------------------------------------------------------------
;

procedure   $Dup_PDB,NEAR
	ASSUME	SS:NOTHING

;hkn;	CreatePDB would have a CS override. This is not valid.
;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.

	getdseg	<ds>			; ds -> dosdata

	MOV	CreatePDB,0FFH		; indicate a new process
	MOV	DS,CurrentPDB
	PUSH	SI
	JMP	SHORT	CreateCopy
EndProc $Dup_PDB

;
;----------------------------------------------------------------------------
;
; Inputs:
;	DX = Segment number of new base
; Function:
;	Set up program base and copy term and ^C from int area
; Returns:
;	None
; Called at DOS init
;
;----------------------------------------------------------------------------
;

procedure   $CREATE_PROCESS_DATA_BLOCK,NEAR
	ASSUME	SS:NOTHING

	CALL	get_user_stack
	MOV	DS,[SI.user_CS]
	PUSH	DS:[PDB_Block_len]
CreateCopy:
	MOV	ES,DX

	XOR	SI,SI			; copy entire PDB
	MOV	DI,SI
	MOV	CX,80H
	REP	MOVSW
; DOS 3.3 7/9/86


	MOV	CX,FilPerProc		; copy handles in case of
	MOV	DI,PDB_JFN_Table	; Set Handle Count has been issued
	PUSH	DS
	LDS	SI,DS:[PDB_JFN_Pointer]
	REP	MOVSB
	POP	DS

; DOS 3.3 7/9/86

		;hkn;CreatePDB would have a CS override. This is not valid.
		;hkn;Must set up ds in order to acess CreatePDB. Also SS is 
		;hkn;has been assumed to be NOTHING. It may not have DOSDATA.

	getdseg	<ds>			; ds -> dosdata

	cmp	CreatePDB,0		; Shall we create a process?
	JZ	Create_PDB_cont 	; nope, old style call
;
; Here we set up for a new process...
;

;hkn;	PUSH    CS                      ; Called at DOSINIT time, NO SS
;hkn;	POP     DS

;hkn;	must set up DS to DOSDATA

	getdseg	<ds>			; ds -> dosdata

	DOSAssume   <DS>,"Create PDB"
	XOR	BX,BX			; dup all jfns
	MOV	CX,FilPerProc		; only 20 of them

Create_dup_jfn:
	PUSH	ES			; save new PDB
	invoke	SFFromHandle		; get sf pointer
	MOV	AL,-1			; unassigned JFN
	JC	CreateStash		; file was not really open
	TESTB	ES:[DI].sf_flags,sf_no_inherit
	JNZ	CreateStash		; if no-inherit bit is set, skip dup.
;
; We do not inherit network file handles.
;
	MOV	AH,BYTE PTR ES:[DI].sf_mode
	AND	AH,sharing_mask
	CMP	AH,sharing_net_fcb
	jz	CreateStash
;
; The handle we have found is duplicatable (and inheritable).  Perform
; duplication operation.
;
	MOV	WORD PTR [THISSFT],DI
	MOV	WORD PTR [THISSFT+2],ES
	invoke	DOS_DUP 		; signal duplication
;
; get the old sfn for copy
;
	invoke	pJFNFromHandle		; ES:DI is jfn
	MOV	AL,ES:[DI]		; get sfn
;
; Take AL (old sfn or -1) and stash it into the new position
;
CreateStash:
	POP	ES
	MOV	ES:[BX].PDB_JFN_Table,AL; copy into new place!
	INC	BX			; next jfn...
	LOOP	create_dup_jfn

	MOV	BX,CurrentPDB		; get current process
	MOV	ES:[PDB_Parent_PID],BX	; stash in child
	MOV	[CurrentPDB],ES
	ASSUME	DS:NOTHING
	MOV	DS,BX
;
; end of new process create
;
Create_PDB_cont:

;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily
	push	ds
	getdseg	<ds>			; ds -> dosdata

	MOV     BYTE PTR [CreatePDB],0h ; reset flag
	pop	ds

	POP	AX

	entry	SETMEM
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
;---------------------------------------------------------------------------
; Inputs:
;	AX = Size of memory in paragraphs
;	DX = Segment
; Function:
;	Completely prepares a program base at the
;	specified segment.
; Called at DOS init
; Outputs:
;	DS = DX
;	ES = DX
;	[0] has INT int_abort
;	[2] = First unavailable segment
;	[5] to [9] form a long call to the entry point
;	[10] to [13] have exit address (from int_terminate)
;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
;	[18] to [21] have fatal error address (from int_fatal_abort)
; DX,BP unchanged. All other registers destroyed.
;---------------------------------------------------------------------------

	XOR	CX,CX
	MOV	DS,CX
	MOV	ES,DX
	MOV	SI,addr_int_terminate
	MOV	DI,SAVEXIT
	MOV	CX,6
	REP	MOVSW
	MOV	ES:[2],AX
	SUB	AX,DX
	CMP	AX,MAXDIF
	JBE	HAVDIF
	MOV	AX,MAXDIF
HAVDIF:
	SUB	AX,10H			; Allow for 100h byte "stack"
	MOV	BX,ENTRYPOINTSEG	;	in .COM files
	SUB	BX,AX
	MOV	CL,4
	SHL	AX,CL
	MOV	DS,DX

	;
	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
	; making this equvalnce valid for this particular case. If however
	; there is less than 64K remaining the address in BX:AX will not 
	; be the same as above. We will then stuff 0:c0 , the call 5 address
	; into the PSP.
	;
	; Therefore for the case where there is less than 64K remaining in 
	; the system old CPM Apps that look at PSP:6 to determine memory
	; requirements will not work. Call 5, however will continue to work
	; for all cases.
	;

	MOV	WORD PTR DS:[PDB_CPM_Call+1],AX
	MOV	WORD PTR DS:[PDB_CPM_Call+3],BX

	cmp	ax, WRAPOFFSET		; Q: does the system have >= 64k of
					;    memory left
	je	addr_ok			; Y: the above calculated address is
					;    OK
					; N: 


	MOV	WORD PTR DS:[PDB_CPM_Call+1],0c0h
	MOV	WORD PTR DS:[PDB_CPM_Call+3],0

addr_ok:

	MOV	DS:[PDB_Exit_Call],(int_abort SHL 8) + mi_INT
	MOV	BYTE PTR DS:[PDB_CPM_Call],mi_Long_CALL
	MOV	WORD PTR DS:[PDB_Call_System],(int_command SHL 8) + mi_INT
	MOV	BYTE PTR DS:[PDB_Call_System+2],mi_Long_RET
	MOV	WORD PTR DS:[PDB_JFN_Pointer],PDB_JFN_Table
	MOV	WORD PTR DS:[PDB_JFN_Pointer+2],DS
	MOV	WORD PTR DS:[PDB_JFN_Length],FilPerProc
;
; The server runs several PDB's without creating them VIA EXEC.  We need to
; enumerate all PDB's at CPS time in order to find all references to a
; particular SFT.  We perform this by requiring that the server link together
; for us all sub-PDB's that he creates.  The requirement for us, now, is to
; initialize this pointer.
;
	MOV	word ptr DS:[PDB_Next_PDB],-1
	MOV	word ptr DS:[PDB_Next_PDB+2],-1

			; Set the real version number in the PSP - 5.00
	mov	ES:[PDB_Version],(MINOR_VERSION SHL 8)+MAJOR_VERSION

	return

EndProc $CREATE_PROCESS_DATA_BLOCK


BREAK <$GSetMediaID -- get set media ID>
;---------------------------------------------------------------------------
; Inputs:
;	BL= drive number as defined in IOCTL (a=1;b=2..etc)
;	AL= 0 get media ID
;	    1 set media ID
;	DS:DX= buffer containing information
;		DW  0  info level (set on input)
;		DD  ?  serial #
;		DB  11 dup(?)  volume id
;		DB   8 dup(?)  file system type
; Function:
;	Get or set media ID
; Returns:
;	carry clear, DS:DX is filled
;	carry set, error
;---------------------------------------------------------------------------

procedure   $GSetMediaID,NEAR ;AN000;

	or	bl,bl
	jnz	misvc
	push	ds
	context DS
	mov	bl,CurDrv	      ; bl = drive (0=a;1=b ..etc)
	pop	DS
	inc	bl
misvc:
	dec	bl		      ; bl = drive (0=a;1=b ..etc)
	HRDSVC	SVC_DEMGSETMEDIAID
	return

EndProc $GSetMediaID		      ;AN000;

DOSCODE	ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\mscode.asm ===
TITLE   MISC DOS ROUTINES - Int 25 and 26 handlers and other
        NAME    IBMCODE

;**     MSCODE.ASM - System Call Dispatch Code
;
;       Revision History
;       ================
;       Sudeepb 14-Mar-1991 Ported for NT DOSEm


        .xlist
        .xcref
        include version.inc
        include mssw.asm
        .cref
        .list

;**     MSCODE.ASM -- MSDOS code
;

        .xlist
        .xcref
        include version.inc
        include dossym.inc
        include devsym.inc
        include dosseg.inc
        include fastopen.inc
        include fastxxxx.inc
        include mult.inc
        include vector.inc
        include curdir.inc
        include mi.inc

        include win386.inc      ;Win386 constants
        include syscall.inc     ;M018
        include dossvc.inc      ;M018
        include bop.inc
ifdef NEC_98
        include dpb.inc
endif

        .cref
        .list

AsmVars <Debug>

    I_need  InDos,BYTE                  ; TRUE => we are in dos, no interrupt
    I_need  OpenBuf,128                 ; temp name buffer
    I_need  ExtErr,WORD                 ; extended error code
    I_need  AbsRdWr_SS,WORD             ; stack segment from user M013
    I_need  AbsRdWr_SP,WORD             ; stack pointer from user M013
    I_need  DskStack,BYTE               ; stack segment inside DOS
    I_need  ThisCDS,DWORD               ; Currently referenced CDS pointer
    I_need  ThisDPB,DWORD               ; Currently referenced DPB pointer
    I_need  Err_Table_21                ; allowed return map table for errors
    I_need  FailErr,BYTE                ; TRUE => system call is being failed
    I_need  ExtErr_Action,BYTE          ; recommended action
    I_need  ExtErr_Class,BYTE           ; error classification
    I_need  ExtErr_Locus,BYTE           ; error location
    I_need  User_In_AX,WORD             ; initial input user AX
    I_need  HIGH_SECTOR,WORD            ; >32mb
    I_need  AbsDskErr,WORD              ; >32mb
    I_need  FastOpenFlg,BYTE            ;


    I_need  CURSC_DRIVE,BYTE            ;
    I_need  TEMPSEG,WORD                ; hkn; used to store ds temporarily
;
;These needed for code to flush buffers when doing absolute writes(int 26h)
;added by SR - 3/25/89
;
    I_need  FIRST_BUFF_ADDR,WORD        ;DOS 4.0
    I_need  SC_CACHE_COUNT,WORD         ;DOS 4.0
    I_need  SC_DRIVE,BYTE               ;DOS 4.0

;
; SR;
; Needed for WIN386 support
;
        I_need  IsWin386,byte           ; flag indicating Win386 presence
        I_need  Win386_Info,byte        ; DOS instance table for Win386

;
; M001; New table for WIN386 giving offsets of some DOS vars
;
        I_need  Win386_DOSVars          ; Table of DOS offsets ; M001
        I_need  Redir_Patch             ; Crit section flag    ; M002

;
; Win386 2.xx instance table
;
        I_need  OldInstanceJunk

        I_need  BootDrive,byte          ; M018
        I_need  VxDpath, byte           ; M018


        I_need  TEMP_VAR,WORD           ; M039
        I_need  TEMP_VAR2,WORD          ; M039

        I_need  CurrentPDB,WORD         ; M044
        I_need  WinoldPatch1,BYTE       ; M044
        I_need  WinoldPatch2,BYTE       ; M044

        I_need  UmbSave1,BYTE           ; M062
        I_need  UmbSave2,BYTE           ; M062
        I_need  UmbSaveFlag,BYTE        ; M062

        I_need  umb_head,WORD

        I_need  Dos_Flag,BYTE           ; M066

ifndef NEC_98
;
; Include bios data segment declaration. Used for accessing DOS data segment 
; at 70:3 & bios int 2F entry point at 70:5
;

BData   segment at 70H                  ; M023
else    ;NEC_98
;
; Include bios data segment declaration. Used for accessing DOS data segment
; at 60:23 & bios int 2F entry point at 60:25
;

BData   segment at 60H
endif   ;NEC_98
                        
        extrn   bios_i2f:far            ; M023

BData   ends                            ; M023


DOSCODE SEGMENT
        ASSUME  CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

        extrn FOO:WORD                  ; return address for dos 2f dispatch
        extrn DTAB:WORD                 ; dos 2f dispatch table
        extrn I21_Map_E_Tab:BYTE        ; mapping extended error table

        extrn   NoVxDErrMsg:BYTE        ; no VxD error message ;M018
        extrn   VXDMESLEN:ABS           ; length of above message ;M018
IFDEF JAPAN
        extrn   NoVxDErrMsg2:BYTE       ; no VxD error message ;M018
        extrn   VXDMESLEN2:ABS          ; length of above message ;M018
ENDIF

        extrn DosDseg:word


BREAK <NullDev -- Driver for null device>


BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>

Public MSC001S,MSC001E
MSC001S label byte
        IF      IBM
; Codes returned by BIOS
ERRIN:
        DB      2                       ; NO RESPONSE
        DB      6                       ; SEEK FAILURE
        DB      12                      ; GENERAL ERROR
        DB      4                       ; BAD CRC
        DB      8                       ; SECTOR NOT FOUND
        DB      0                       ; WRITE ATTEMPT ON WRITE-PROTECT DISK
ERROUT:
; DISK ERRORS RETURNED FROM INT 25 and 26
        DB      80H                     ; NO RESPONSE
        DB      40H                     ; Seek failure
        DB      2                       ; Address Mark not found
        DB      10H                     ; BAD CRC
        DB      4                       ; SECTOR NOT FOUND
        DB      3                       ; WRITE ATTEMPT TO WRITE-PROTECT DISK

NUMERR  EQU     $-ERROUT
        ENDIF
MSC001E label byte

;---330------------------------------------------------------------------------
;
; Procedure Name : ABSDRD
;
; Interrupt 25 handler.  Performs absolute disk read.
; Inputs:       AL - 0-based drive number
;               DS:BX point to destination buffer
;               CX number of logical sectors to read
;               DX starting  logical sector number (0-based)
; Outputs:      Original flags still on stack
;               Carry set
;                   AH error from BIOS
;                   AL same as low byte of DI from INT 24
;
;---------------------------------------------------------------------------

procedure   ABSDRD,FAR
        ASSUME  CS:DOSCODE,SS:NOTHING

        invoke  DOCLI

;       set up ds to point to DOSDATA

        push    ax                      ; preserve AX value
        mov     ax, ds                  ; store DS value in AX
        getdseg <ds>
        mov     [TEMPSEG], ax           ; store DS value in TEMPSEG
        pop     ax                      ; restore AX value

        ;
        ; M072:
        ; We shall save es on the user stack here. We need to use ES in
        ; order to access the DOSDATA variables AbsRdWr_SS/SP at exit
        ; time in order to restore the user stack.
        ;

        push    es                      ; M072

        MOV     [AbsRdWr_SS],SS         ; M013
        MOV     [AbsRdWr_SP],SP         ; M013

        PUSH    CS
        POP     SS

;
;       set up ss to point to DOSDATA
;
; NOTE!  Due to an obscure bug in the 80286, you cannot use the ROMDOS
; version of the getdseg macro with the SS register!  An interrupt will
; sneak through.

ifndef ROMDOS
        getdseg <ss>                            ; cli in entry of routine
else
        mov     ds, cs:[BioDataSeg]
        assume  ds:bdata

        mov     ss, ds:[DosDataSg]
        assume  ss:DOSDATA

endif ; ROMDOS

        MOV     SP,OFFSET DOSDATA:DSKSTACK

                                        ; SS override
        mov     ds, [TEMPSEG]           ; restore DS value
        assume  ds:nothing

                                        ; use macro
        Save_World                      ;>32mb save all regs

        PUSH    ES
;;;     CALL    AbsSetup
;;;     JC      ILEAVE
                                        ;M022 conditional removed here 
       
        INC     INDOS                   ;for decrement error InDos flag bug 89559 whistler

        ;
        ; Here is a gross temporary fix to get around a serious design flaw in
        ;  the secondary cache.  The secondary cache does not check for media
        ;  changed (it should).  Hence, you can change disks, do an absolute
        ;  read, and get data from the previous disk.  To get around this,
        ;  we just won't use the secondary cache for absolute disk reads.
        ;                                                      -mw 8/5/88

;;      EnterCrit   critDisk
;;      MOV     [CURSC_DRIVE],-1        ; invalidate SC ;AN000;
;;      LeaveCrit   critDisk
;;;;;;  invoke  DSKREAD

        SVC     SVC_DEMABSDRD
;M039
;;      jnz      ERR_LEAVE               ;Jump if read unsuccessful.
        jc      ERR_LEAVE
;;       mov     cx,di
        mov     WORD PTR [TEMP_VAR2],ds
        mov     WORD PTR [TEMP_VAR],bx

;       CX = # of contiguous sectors read.  (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
;       The Buffer Queue must now be scanned: the contents of any dirty
;       buffers must be "read" into the transfer memory block, so that the
;       transfer memory reflects the most recent data.
;;;;
;;;;     invoke  DskRdBufScan           ;This trashes DS, but don't care.
        jmp     short ILEAVE
;M039

TLEAVE:
;       JZ      ILEAVE
        jnc     ILEAVE
ERR_LEAVE:                              ;M039
        IF      IBM
        PUSH    ES
        PUSH    CS
        POP     ES
        XOR     AH,AH                   ; Nul error code
        MOV     CX,NUMERR               ; Number of possible error conditions

                                        ; ERRIN is defined in DOSCODE
        MOV     DI,OFFSET DOSCODE:ERRIN ; Point to error conditions

        REPNE   SCASB
        JNZ     LEAVECODE               ; Not found
        MOV     AH,ES:[DI+NUMERR-1]     ; Get translation
LEAVECODE:
        POP     ES
        ENDIF
                                        ; SS override
        MOV     AbsDskErr,AX            ;>32mb save error
        STC
ILEAVE:
        POP     ES
                                        ;use macro
        Restore_World

        invoke  DOCLI

        MOV     AX,AbsDskErr            ;>32mb restore error;AN000;

; SS override for INDOS, AbsRdWr_sp & AbsRdWr_ss        ; M013
        DEC     INDOS

        push    ss                      ; M072 - Start
        pop     es                      ; es - dosdata
        mov     ss, es:[AbsRdWr_ss]     ; M013
        mov     sp, es:[AbsRdWr_sp]     ; M013

;;      mov     sp, [AbsRdWr_sp]        ; M013
;;      mov     ss, [AbsRdWr_ss]        ; M013
        assume  ss:nothing

        pop     es                      ; Note es was saved on user
                                        ; stack at entry
                                        ; M072 - End

        invoke DOSTI
        RET                             ; This must not be a RETURN

EndProc ABSDRD
;--------------------------------------------------------------------------
;
; Procedure Name : ABSDWRT
;
; Interrupt 26 handler.  Performs absolute disk write.
; Inputs:       AL - 0-based drive number
;               DS:BX point to source buffer
;               CX number of logical sectors to write
;               DX starting  logical sector number (0-based)
; Outputs:      Original flags still on stack
;               Carry set
;                   AH error from BIOS
;                   AL same as low byte of DI from INT 24
;
; 10-Aug-1992 Jonle , ALWAYS returns ERROR_I24_BAD_UNIT as we
;                     don't support direct disk access
;
;---------------------------------------------------------------------------

procedure   ABSDWRT,FAR
        ASSUME  SS:NOTHING

        invoke  DOCLI

;       set up ds to point to DOSDATA

        push    ax
        mov     ax, ds
        getdseg <ds>
        mov     [TEMPSEG], ax
        pop     ax


        ; M072:
        ; We shall save es on the user stack here. We need to use ES in
        ; order to access the DOSDATA variables AbsRdWr_SS/SP at exit
        ; time in order to restore the user stack.
        ;

        push    es                      ; M072

        MOV     [AbsRdWr_SS],SS         ; M013
        MOV     [AbsRdWr_SP],SP         ; M013

        PUSH    CS
        POP     SS

        ;
        ; set up ss to point to DOSDATA
        ;
        ; NOTE!  Due to an obscure bug in the 80286, you cannot use the
        ; ROMDOS version of the getdseg macro with the SS register!
        ; An interrupt will sneak through.
        ;

ifndef ROMDOS
        getdseg <ss>                            ; cli in entry of routine
else
        mov     ds, cs:[BioDa165taSeg]
        assume  ds:bdata

        mov     ss, ds:[DosDataSg]
        ASSUME  SS:DOSDATA

endif ; ROMDOS

        MOV     SP,OFFSET DOSDATA:DSKSTACK
        ; we are now switched to DOS's disk stack

        mov     ds, [TEMPSEG]           ; restore user's ds
        assume  ds:nothing
                                        ; use macro
        Save_World                      ;>32mb save all regs            ;AN000;
        PUSH    ES
;;;     CALL    AbsSetup
;;;     JC      ILEAVE
        
        INC     INDOS

;;;     EnterCrit   critDisk

                                        ; SS override
;;;     MOV     [CURSC_DRIVE],-1        ; invalidate SC                 ;AN000;
;;;     CALL    Fastxxx_Purge           ; purge fatopen                 ;AN000;
;;;     LeaveCrit   critDisk

;M039
;       DS:BX = transfer address (source data address).
;       CX = # of contiguous sectors to write. (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;       [CURSC_DRIVE] = -1 (invalid drive).
;
;       Free any buffered sectors which are in Extent; they are being over-
;       written.  Note that all the above registers are preserved for
;       DSKWRITE.

;;;;;    push    ds
;;;;;    invoke  DskWrtBufPurge          ;This trashes DS.
;;;;;    pop     ds
;M039

;;;;;   invoke  DSKWRITE
        SVC     SVC_DEMABSDWRT
        JMP     TLEAVE

EndProc ABSDWRT

;----------------------------------------------------------------------------
;
; Procedure Name : GETBP
;
; Inputs:
;       AL = Logical unit number (A = 0)
; Function:
;       Find Drive Parameter Block
; Outputs:
;       ES:BP points to DPB
;       [THISDPB] = ES:BP
;       Carry set if unit number bad or unit is a NET device.
;               Later case sets extended error error_I24_not_supported
; No other registers altered
;
;----------------------------------------------------------------------------

if 0
Procedure GETBP,NEAR
        DOSAssume   <DS>,"GetBP"

        PUSH    AX
        ADD     AL,1                    ; No increment; need carry flag
        JC      SkipGet
        invoke  GetThisDrv
        JNC     SkipGet                 ;PM. good drive                 ;AN000;
        XOR     AH,AH                   ;DCR. ax= error code            ;AN000;
        CMP     AX,error_not_dos_disk   ;DCR. is unknown media ?                ;AN000;
        JZ      SkipGet                 ;DCR. yes, let it go            ;AN000;
        STC                             ;DCR.                           ;AN000;
        MOV     ExtErr,AX               ;PM. invalid drive or Non DOS drive     ;AN000;
        mov     AbsDskErr, 201h
SkipGet:
        POP     AX
        retc
        LES     BP,[THISCDS]
        TEST    ES:[BP.curdir_flags],curdir_isnet   ; Clears carry
        JZ      GETBP_CDS
        MOV     ExtErr,error_not_supported
        STC
        return

GETBP_CDS:
        LES     BP,ES:[BP.curdir_devptr]

entry   GOTDPB
        DOSAssume   <DS>,"GotDPB"

;       Load THISDPB from ES:BP

        MOV     WORD PTR [THISDPB],BP
        MOV     WORD PTR [THISDPB+2],ES
        return
EndProc GetBP
endif

BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>

ASSUME  SS:DOSDATA
;----------------------------------------------------------------------------
;
; Procedure Name : SYS_RETURN
;
; These are the general system call exit mechanisms.  All internal system
; calls will transfer (jump) to one of these at the end.  Their sole purpose
; is to set the user's flags and set his AX register for return.
;
;---------------------------------------------------------------------------

procedure   SYS_RETURN,NEAR
entry   SYS_RET_OK
        invoke  get_user_stack
        AND     [SI.user_F],NOT f_Carry ; turn off user's carry flag
        JMP     SHORT DO_RET            ; carry is now clear

entry   SYS_RET_ERR
        XOR     AH,AH                   ; hack to allow for smaller error rets
        invoke  ETAB_LK                 ; Make sure code is OK, EXTERR gets set
        CALL    ErrorMap
entry   From_GetSet
        invoke  get_user_stack
        OR      [SI.user_F],f_Carry     ; signal carry to user
        STC                             ; also, signal internal error
DO_RET:
        MOV     [SI.user_AX],AX         ; Really only sets AH
        return

        entry   FCB_RET_OK
        entry   NO_OP                   ; obsolete system calls dispatch to here
        XOR     AL,AL
        return

        entry   FCB_RET_ERR
        XOR     AH,AH
        mov     exterr,AX
        CALL    ErrorMap
        MOV     AL,-1
        return

        entry   errorMap
        PUSH    SI

                                        ; ERR_TABLE_21 is now in DOSDATA
        MOV     SI,OFFSET DOSDATA:ERR_TABLE_21

                                        ; SS override for FAILERR and EXTERR
        CMP     [FAILERR],0             ; Check for SPECIAL case.
        JZ      EXTENDED_NORMAL         ; All is OK.
        MOV     [EXTERR],error_FAIL_I24 ; Ooops, this is the REAL reason
EXTENDED_NORMAL:
        invoke  CAL_LK                  ; Set CLASS,ACTION,LOCUS for EXTERR
        POP     SI
        return

EndProc SYS_RETURN

;---------------------------------------------------------------------------
;
; Procedure Name : CAL_LK
;
; Inputs:
;       SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
;               (DS NEED not be DOSDATA)
;       [EXTERR] is set with error
; Function:
;       Look up and set CLASS ACTION and LOCUS values for GetExtendedError
; Outputs:
;       [EXTERR_CLASS] set
;       [EXTERR_ACTION] set
;       [EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
; Destroys SI, FLAGS
;
;--------------------------------------------------------------------------

procedure   CAL_LK,NEAR

        PUSH    DS
        PUSH    AX
        PUSH    BX

;M048   Context DS              ; DS:SI -> Table
;
; Since this function can be called thru int 2f we shall not assume that SS
; is DOSDATA

        getdseg <ds>            ; M048: DS:SI -> Table

        MOV     BX,[EXTERR]     ; Get error in BL
TABLK1:
        LODSB

        CMP     AL,0FFH
        JZ      GOT_VALS        ; End of table
        CMP     AL,BL
        JZ      GOT_VALS        ; Got entry
        ADD     SI,3            ; Next table entry
        JMP     TABLK1

GOT_VALS:
        LODSW                   ; AL is CLASS, AH is ACTION

        CMP     AH,0FFH
        JZ      NO_SET_ACT
        MOV     [EXTERR_ACTION],AH     ; Set ACTION
NO_SET_ACT:
        CMP     AL,0FFH
        JZ      NO_SET_CLS
        MOV     [EXTERR_CLASS],AL      ; Set CLASS
NO_SET_CLS:
        LODSB                   ; Get LOCUS

        CMP     AL,0FFH
        JZ      NO_SET_LOC
        MOV     [EXTERR_LOCUS],AL
NO_SET_LOC:
        POP     BX
        POP     AX
        POP     DS
        return
EndProc CAL_LK

;----------------------------------------------------------------------------
;
; Procedure Name : ETAB_LK
;
; Inputs:
;       AX is error code
;       [USER_IN_AX] has AH value of system call involved
; Function:
;       Make sure error code is appropriate to this call.
; Outputs:
;       AX MAY be mapped error code
;       [EXTERR] = Input AX
; Destroys ONLY AX and FLAGS
;
;---------------------------------------------------------------------------

procedure   ETAB_LK,NEAR

        PUSH    DS
        PUSH    SI
        PUSH    CX
        PUSH    BX

        Context DS                      ; SS is DOSDATA
        MOV     [EXTERR],AX             ; Set EXTERR with "real" error

                                        ; I21_MAP_E_TAB is now in DOSCODE
        MOV     SI,OFFSET DOSCODE:I21_MAP_E_TAB
        MOV     BH,AL                   ; Real code to BH
        MOV     BL,BYTE PTR [USER_IN_AX + 1]    ; Sys call to BL
TABLK2:
;hkn;   LODSW
        LODS    word ptr cs:[si]

        CMP     AL,0FFH                 ; End of table?
        JZ      NOT_IN_TABLE            ; Yes
        CMP     AL,BL                   ; Found call?
        JZ      GOT_CALL                ; Yes
        XCHG    AH,AL                   ; Count to AL
        XOR     AH,AH                   ; Make word for add
        ADD     SI,AX                   ; Next table entry
        JMP     TABLK2

NOT_IN_TABLE:
        MOV     AL,BH                   ; Restore original code
        JMP     SHORT NO_MAP

GOT_CALL:
        MOV     CL,AH
        XOR     CH,CH                   ; Count of valid err codes to CX
CHECK_CODE:
;hkn;   LODSB
        LODS    byte ptr cs:[si]

        CMP     AL,BH                   ; Code OK?
        JZ      NO_MAP                  ; Yes
        LOOP    CHECK_CODE
NO_MAP:
        XOR     AH,AH                   ; AX is now valid code
        POP     BX
        POP     CX
        POP     SI
        POP     DS
        return

EndProc ETAB_LK

BREAK <DOS 2F Handler and default NET 2F handler>

IF installed
;----------------------------------------------------------------------------
;
; Procedure Name : SetBad
;
; SetBad sets up info for bad functions
;
;--------------------------------------------------------------------------

Procedure   SetBad,NEAR
        ASSUME  CS:DOSCODE,SS:NOTHING
        MOV     AX,error_invalid_function       ; ALL NET REQUESTS get inv func

;       set up ds to point to DOSDATA

        push    ds
        getdseg <ds>

        MOV     ExtErr_LOCUS,errLoc_UNK

        pop     ds                      ;hkn; restore ds
        assume  ds:nothing

        STC
        ret
EndProc SetBad

;--------------------------------------------------------------------------
;
; Procedure Name : BadCall
;
; BadCall is the initial routine for bad function calls
;
;--------------------------------------------------------------------------

procedure   BadCall,FAR
        call    SetBad
        ret
EndProc BadCall

;--------------------------------------------------------------------------
;
; OKCall always sets carry to off.
;
;-----------------------------------------------------------------------

Procedure   OKCall,FAR

        ASSUME  CS:DOSCODE,SS:NOTHING
        CLC
        ret

EndProc OKCall

;---------------------------------------------------------------------------
;
; Procedure Name : INT2F
;
; INT 2F handler works as follows:
;   PUSH    AX
;   MOV     AX,multiplex:function
;   INT     2F
;   POP     ...
; The handler itself needs to make the AX available for the various routines.
;
;----------------------------------------------------------------------------

PUBLIC  Int2F
INT2F   PROC    FAR

INT2FNT:
        ASSUME  CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
        invoke  DOSTI
        CMP     AH,multNET
        JNZ     INT2FSHR
TestInstall:
        OR      AL,AL
        JZ      Leave2F
BadFunc:
        CALL    SetBad
        entry   Leave2F
        RET     2                       ; long return + clear flags off stack

INT2FSHR:
        ; Sudeepb 07-Aug-1992; As we dont have a true share.exe we
        ; are putting its int2f support here.

        CMP     AH,multSHARE            ; is this a share request
        JNZ     INT2FNLS                ; no, check next
        or      al,al
        jnz     BadFunc
        mov     al,0ffh                 ; Indicate share is loaded
        jmp     short Leave2f

INT2FNLS:
        CMP     AH,NLSFUNC              ; is this a DOS 3.3 NLSFUNC request
        JZ      TestInstall             ; yes check for installation

INT2FDOS:
        ASSUME  CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
        CMP     AH,multDOS
        JNZ     check_win               ;check if win386 broadcast
        jmp     DispatchDOS

check_win:
        cmp     ah,multWIN386           ; Is this a broadcast from Win386?
        je      Win386_Msg

        ;
        ; M044
        ; Check if the callout is from Winoldap indicating swapping out or in 
        ; of Windows. If so, do special action of going and saving last para
        ; of the Windows memory arena which Winoldap does not save due to a 
        ; bug
        ;

        cmp     ah,WINOLDAP             ; from Winoldap?
        jne     next_i2f                ; no, chain on
        jmp     Winold_swap             ; yes, do desired action

next_i2f:
        jmp     bios_i2f


;       IRET                            ; This assume that we are at the head
                                        ; of the list
INT2F   ENDP

;
; We have received a message from Win386.  There are three possible
; messages we could get from Win386:
;
; Init          - for this, we set the IsWin386 flag and return a pointer
;                 to the Win386 startup info structure.
; Exit          - for this, we clear the IsWin386 flag.
; DOSMGR query  - for this, we need to indicate that instance data
;                 has already been handled.  this is indicated by setting
;                 CX to a non-zero value.
;

Win386_Msg:

        push    ds

        getdseg <DS>                    ; ds is DOSDATA

        ;
        ; For WIN386 2.xx instance data
        ;

        cmp     al,03                   ;win386 2.xx instance data call?
        lje     OldWin386Init           ;yes, return instance data

        cmp     al, Win386_Exit         ; is it an exit call?
        lje     Win386_Leaving
        cmp     al, Win386_Devcall      ; is it call from DOSMGR?
        lje     Win386_Query
        cmp     al, Win386_Init         ; is it an init call?
        ljne    win_nexti2f             ; no, return

Win386_Starting:
        test    dx, 1                   ; is this really win386?
        jz      @f                      ; YES! go and handle it
        jmp     win_nexti2f             ; NO!  It's win 286 dos extender! M002
@@:

        ;
        ; M018 -- start of block changes
        ; The VxD needs to be loaded only for Win 3.0. If version is greater 
        ; than 030ah, we skip the VxD presence check
        ;

;M067 -- Begin changes
; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
;run, it tries to unnecesarily load the VxD even though it is not needed.
;So, we null out the VxD ptr before the check.
;
        mov     word ptr Win386_Info.SIS_Virt_Dev_File_Ptr, 0
        mov     word ptr Win386_Info.SIS_Virt_Dev_File_Ptr+2, 0
;
;M067 -- End changes
;

ifdef JAPAN
        cmp     di,0300h                ; version >= 300 i.e 3.10 ;M037
else
        cmp     di,030ah                ; version >= 30a i.e 3.10 ;M037
endif
        ljae    noVxD31                 ; yes, VxD not needed    ;M037


        push    ax
        push    bx
        push    cx
        push    dx
        push    si
        push    di                      ; save regs !!dont change order!!

        mov     bx, [umb_head]          ; M062 - Start
        cmp     bx, 0ffffh              ; Q: have umbs been initialized
        je      Vxd31                   ; N: continue
                                        ; Y: save arena associated with 
                                        ;    umb_head

        mov     [UmbSaveFlag], 1        ; indicate that we're saving 
                                        ; umb_arena
        push    ds
        push    es

        mov     ax, ds
        mov     es, ax                  ; es - > dosdata

        mov     ds, bx
        xor     si, si                  ; ds:si -> umb_head

        cld

        mov     di, offset dosdata:UmbSave1
        mov     cx, 0bh
rep     movsb

        mov     di, offset dosdata:UmbSave2
        mov     cx, 05h
rep     movsb   

        pop     es
        pop     ds                      ; M062 - End

Vxd31:
        test    Dos_Flag, SUPPRESS_WINA20       ; M066
        jz      Dont_Supress                    ; M066
        pop     di                              ; M066
        pop     si                              ; M066
        pop     dx                              ; M066
        pop     cx                              ; M066
        pop     bx                              ; M066
        pop     ax                              ; M066
        jmp     short NoVxd31                   ; M066

        ;
        ; We check here if the VxD is available in the root of the boot drive. 
        ; We do an extended open to suppress any error messages
        ;
Dont_Supress:
        mov     al,BootDrive
        add     al,'A' - 1              ; get drive letter
        mov     byte ptr VxDpath,al     ; path is root of bootdrive
        mov     ah,EXTOPEN              ; extended open
        mov     al,0                    ; no extended attributes
        mov     bx,2080h                ; read access, compatibility mode
                                        ; no inherit, suppress crit err
        mov     cx,7                    ; hidden,system,read-only attr
        mov     dx,1                    ; fail if file does not exist
        mov     si,offset DOSDATA:VxDpath       
                                        ; path of VxD file
        mov     di,0ffffh               ; no extended attributes

        int     21h                     ; do extended open
        pop     di
        pop     si
        pop     dx
        pop     cx
        jnc     VxDthere                ; we found the VxD, go ahead

        ;
        ; We could not find the VxD. Cannot let windows load. Return cx != 0 
        ; to indicate error to Windows after displaying message to user that 
        ; VxD needs to be present to run Windows in enhanced mode.
        ;

        push    dx
        push    ds
        push    si
        mov     si,offset DOSCODE:NoVxDErrMsg
        push    cs
        pop     ds
        mov     cx,VXDMESLEN            ;
ifdef JAPAN
        push    ax
        push    bx
        mov     ax,4f01h                ; get code page
        xor     bx,bx
        int     2fh
        cmp     bx,932
        pop     bx
        pop     ax
        jz      @f                      ; if DBCS code page
        mov     si,offset DOSCODE:NoVxDErrMsg2
        mov     cx,VXDMESLEN2
@@:
endif
        mov     ah,02                   ; write char to console
        cld
vxdlp:
        lodsb
        xchg    dl,al                   ; get char in dl
        int     21h
        loop    vxdlp

        pop     si
        pop     ds
        pop     dx
        pop     bx
        pop     ax                      ;all registers restored
        inc     cx                      ;cx != 0 to indicate error
        jmp     win_nexti2f             ;chain on

VxDthere:
        mov     bx,ax
        mov     ah,CLOSE
        int     21h                     ;close the file

        ;
        ; Update the VxD ptr in the instance data structure with path to VxD
        ;
        mov     bx,offset DOSDATA:Win386_Info
        mov     word ptr [bx].SIS_Virt_Dev_File_Ptr, offset DOSDATA:VxDpath
        mov     word ptr [bx].SIS_Virt_Dev_File_Ptr+2, ds       ;

        pop     bx
        pop     ax
NoVxD31:
        
        ;
        ; M018; End of block changes
        ;

        or      ds:IsWIN386,1           ; Indicate WIN386 present
        or      ds:redir_patch,1        ; Enable critical sections; M002

        ; M002;
        ; Save the previous es:bx (instance data ptr) into our instance table
        ;

        push    dx                      ; M002
        mov     dx,bx                   ; M002
                                        ; point ES:BX to Win386_Info ; M002
        mov     bx, offset dosdata:Win386_Info 
        mov     word ptr [bx+2],dx      ; M002
        mov     word ptr [bx+4],es      ; M002
        pop     dx                      ; M002
        push    ds                      ; M002
        pop     es                      ; M002
        jmp     win_nexti2f             ; M002

Win386_Leaving:
        test    dx, 1                   ; is this really win386?
        ljnz    win_nexti2f             ; NO!  It's win 286 dos extender! M002

                                        ; M062 - Start
        cmp     ds:[UmbSaveFlag], 1     ; Q: was umb_arena saved at win start
                                        ;    up.
        jne     noumb                   ; N: not saved 
        mov     ds:[UmbSaveFlag], 0     ; Y: clear UmbSaveFlag and restore 
                                        ;    previously saved umb_head
        push    ax
        push    es
        push    cx
        push    si
        push    di

        mov     ax, [umb_head]  
        mov     es, ax
        xor     di, di                  ; es:di -> umb_head

        cld

        mov     si, offset dosdata:UmbSave1
        mov     cx, 0bh
rep     movsb
        mov     si, offset dosdata:UmbSave2
        mov     cx, 05h
rep     movsb

        pop     di
        pop     si
        pop     cx
        pop     es
        pop     ax
noumb:                                  ; M062 - End
        
        and     ds:[IsWIN386],0         ; Win386 is gone
        and     ds:redir_patch,0        ; Disable critical sections ; M002
        jmp     short win_nexti2f

Win386_Query:
        cmp     bx, Win386_DOSMGR       ; is this from DOSMGR?
        jne     win_nexti2f             ; no, ignore it & chain to next
        or      cx, cx                  ; is it an instance query?
        jne     dosmgr_func             ; no, some DOSMGR query
        inc     cx                      ; indicate that data is instanced

;
; M001; We were previously returning a null ptr in es:bx. This will not work.
; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
; M001;  
; M001; OFFSETS  STRUC
; M001;         Major_version   db      ?
; M001;         Minor_version   db      ?
; M001;         SaveDS          dw      ?
; M001;         SaveBX          dw      ?
; M001;         Indos           dw      ?
; M001;         User_id         dw      ?
; M001;         CritPatch       dw      ?
; M001; OFFSETS  ENDS
; M001; 
; M001; User_Id is the only variable really important for proper functioning  
; M001; of Win386. The other variables are used at init time to patch stuff
; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
; M001; pass this table because Win386 depends on this table to get the 
; M001; User_Id offset.
; M001; 
        mov     bx,offset Win386_DOSVars; M001 
        push    ds                      ; M001
        pop     es                      ; es:bx points at offset table ; M001
        jmp     short PopIret           ; M001

        ;
        ; Code to return Win386 2.xx instance table
        ;
OldWin386Init:
        pop     ax                      ; discard ds pushed on stack
        mov     si,offset dosdata:OldInstanceJunk 
                                        ; ds:si = instance table
        mov     ax, 5248h               ; indicate instance data present
        jmp     next_i2f


dosmgr_func:
        dec     cx
        jz      win386_patch            ; call to patch DOS
        dec     cx
        jz      PopIret                 ; remove DOS patches, ignore
        dec     cx
        jz      win386_size             ; get size of DOS data structures
        dec     cx
        jz      win386_inst             ; instance more data
        dec     cx
        jnz     PopIret                 ; no functions above this

        ;
        ; Get DOS device driver size -- es:di points at device driver header
        ; In DOS 4.x, the para before the device header contains an arena 
        ; header for the driver.
        ;
        mov     ax,es                   ; ax = device header segment

        ;
        ; We check to see if we have a memory arena for this device driver. 
        ; The way to do this would be to look at the previous para to see if
        ; it has a 'D' marking it as an arena and also see if the owner-field 
        ; in the arena is the same as the device header segment. These two 
        ; checks together should take care of all cases
        ;

        dec     ax                      ; get arena header
        push    es
        mov     es,ax                   ; arena header for device driver

        cmp     byte ptr es:[di],'D'    ; is it a device arena?
        jnz     cantsize                ; no, cant size this driver
        inc     ax                      ; get back device header segment
        cmp     es:[di+1],ax            ; owner field pointing at driver?
        jnz     cantsize                ; no, not a proper arena

        mov     ax,es:[di+3]            ; get arena size in paras
        pop     es

        ;
        ; We have to multiply by 16 to get the number of bytes in (bx:cx)
        ; Speed is not critical and so we choose the shortest method 
        ; -- use "mul"
        ;
        mov     bx,16
        mul     bx
        mov     cx,ax
        mov     bx,dx
        jmp     short win386_done       ; return with device driver size
cantsize:
        pop     es
        xor     ax,ax
        xor     dx,dx                   ; ask DOSMGR to use its methods
        jmp     short PopIret           ; return

win386_patch:

        ;
        ; dx contains bits marking the patches to be applied. We return 
        ; the field with all bits set to indicate that all patches have been
        ; done
        ;

        mov     bx,dx                   ; move patch bitfield to bx
        jmp     short win386_done       ; done, return

win386_size:

        ;
        ;Return the size of DOS data structures -- currently only CDS size
        ;

        test    dx,1                    ; check for CDS size bit
        jz      PopIret                 ; no, unknown structure -- return

ifdef JAPAN
        mov     cx,size CURDIR_LIST_JPN ; cx = CDS size
else
        mov     cx,size CURDIR_LIST     ; cx = CDS size
endif
        jmp     short win386_done       ; return with the size

win386_inst:

        ;
        ; WIN386 check to see if DOS has identified the CDS,SFT and device 
        ; chain as instance data. Currently, we let the WIN386 DOSMGR handle
        ; this by returning a status of not previously instanced. The basic 
        ; structure of these things have not changed and so the current 
        ; DOSMGR code should be able to work it out
        ;
        xor     dx,dx                   ; make sure dx has a not done value
        jmp     short PopIret           ; skip done indication

win386_done:

        mov     ax,WIN_OP_DONE          ;
        mov     dx,DOSMGR_OP_DONE       ;
PopIret:
        pop     ds
        assume  ds:nothing
        iret                            ; return back up the chain

win_nexti2f:
        pop     ds
        assume  ds:nothing
        jmp     next_i2f                ; go to BIOS i2f handler

;
;End WIN386 support
;

;M044; Start of changes
; Winoldap has a bug in that its calculations for the Windows memory image
; to save is off by 1 para. This para can happen to be a Windows arena if the
; DOS top of memory happens to be at an odd boundary (as is the case when
; UMBs are present). This is because Windows builds its arenas only at even
; para boundaries. This arena now gets trashed when Windows is swapped back
; in leading to a crash. Winoldap issues callouts when it swaps WIndows out
; and back in. We sit on these callouts. On the Windows swapout, we save the
; last para of the Windows memory block and then restore this para on the
; Windows swapin callout. 
;

getwinlast      proc    near
        assume  ds:DOSDATA

        mov     si,CurrentPDB
        dec     si
        mov     es,si
        add     si,es:[3]
        ret
getwinlast      endp

winold_swap:
        push    ds
        push    es
        push    si
        push    di
        push    cx
        getdseg <ds>                    ;ds = DOSDATA

        cmp     al,01                   ;swap Windows out call
        jne     swapin                  ;no, check if Swap in call
        call    getwinlast
        push    ds
        pop     es
        mov     ds,si                   ;ds = memory arena of Windows
        assume  ds:nothing
        xor     si,si
        mov     di,offset DOSDATA:WinoldPatch1
        mov     cx,8
        cld
        push    cx
        rep     movsb                   ;save first 8 bytes
        pop     cx
        mov     di,offset DOSDATA:WinoldPatch2
        rep     movsb                   ;save next 8 bytes
        jmp     short winold_done
swapin:
        cmp     al,02                   ;swap Windows in call?
        jne     winold_done             ;no, something else, pass it on
        assume  ds:DOSDATA
        call    getwinlast
        mov     es,si
        xor     di,di
        mov     si,offset DOSDATA:WinoldPatch1
        mov     cx,8
        cld
        push    cx
        rep     movsb                   ;restore first 8 bytes
        pop     cx
        mov     si,offset DOSDATA:WinoldPatch2
        rep     movsb                   ;restore next 8 bytes
winold_done:
        pop     cx
        pop     di
        pop     si
        pop     es
        pop     ds
        assume  ds:nothing
        jmp     next_i2f                ;chain on

;
;M044; End of changes
;


DispatchDOS:
        PUSH    FOO                     ; push return address
        PUSH    DTab                    ; push table address
        PUSH    AX                      ; push index
        PUSH    BP
        MOV     BP,SP
; stack looks like:
;   0   BP
;   2   DISPATCH
;   4   TABLE
;   6   RETURN
;   8   LONG-RETURN
;   c   FLAGS
;   e   AX

        MOV     AX,[BP+0Eh]             ; get AX value
        POP     BP
        Invoke  TableDispatch
        JMP     BadFunc                 ; return indicates invalid function

Procedure   INT2F_etcetera,NEAR
        entry   DosGetGroup

;SR; Cannot use CS now
;
;       PUSH    CS
;       POP     DS

        getdseg <ds>
        return

        entry   DOSInstall
        MOV     AL,0FFh
        return
EndProc INT2F_etcetera

ENDIF

;---------------------------------------------------------------------------
;
; Procedure Name : RW32_CONVERT
;
;Input: same as ABSDRD and ABSDWRT
;        ES:BP -> DPB
;Functions: convert 32bit absolute RW input parms to 16bit input parms
;Output: carry set when CX=-1 and drive is less then 32mb
;        carry clear, parms ok
;
;---------------------------------------------------------------------------

ifdef NEC_98
Procedure   RW32_CONVERT,NEAR
        ASSUME  CS:DOSCODE,SS:NOTHING
        CMP     CX,-1                        ;>32mb  new format ?               ;AN000;
        JZ      new32format                  ;>32mb  yes                        ;AN000;
        PUSH    AX                           ;>32mb  save ax                    ;AN000;
        PUSH    DX                           ;>32mb  save dx                    ;AN000;
        MOV     AX,ES:[BP.dpb_max_cluster]   ;>32mb  get max cluster #          ;AN000;
        MOV     DL,ES:[BP.dpb_cluster_mask]  ;>32mb                             ;AN000;
        CMP     DL,0FEH                      ;>32mb  removable ?                ;AN000;
        JZ      letold                       ;>32mb  yes                        ;AN000;
        INC     DL                           ;>32mb                             ;AN000;
        XOR     DH,DH                        ;>32mb  dx = sector/cluster        ;AN000;
        MUL     DX                           ;>32mb  dx:ax= max sector #        ;AN000;
        OR      DX,DX                        ;>32mb  > 32mb ?                   ;AN000;
letold:
        POP     DX                           ;>32mb  retore dx                  ;AN000;
        POP     AX                           ;>32mb  restore ax                 ;AN000;
        JZ      old_style                    ;>32mb  no                         ;AN000;

        push    ds
        getdseg <ds>
        mov     AbsDskErr, 207h              ;>32mb  bad address mark
        pop     ds

        STC                                  ;>32mb                             ;AN000;
        return                               ;>32mb                             ;AN000;
new32format:

        assume  ds:nothing
        MOV     DX,WORD PTR [BX.SECTOR_RBA+2];>32mb                             ;AN000;

        push    ds                           ; set up ds to DOSDATA
        getdseg <ds>

        MOV     [HIGH_SECTOR],DX             ;>32mb                             ;AN000;

        pop     ds
        assume  ds:nothing

        MOV     DX,WORD PTR [BX.SECTOR_RBA]  ;>32mb                             ;AN000;
        MOV     CX,[BX.ABS_RW_COUNT]         ;>32mb                             ;AN000;
        LDS     BX,[BX.BUFFER_ADDR]          ;>32mb                             ;AN000;
old_style:                                   ;>32mb                             ;AN000;
        CLC                                  ;>32mb                             ;AN000;
        return                               ;>32mb                             ;AN000;
EndProc RW32_CONVERT
endif   ;NEC_98

;---------------------------------------------------------------------------
;
; Procedure Name : Fastxxx_Purge
;
; Input: None
; Functions: Purge Fastopen/ Cache Buffers
; Output: None
;
;------------------------------------------------------------------------

ifdef 0
Procedure   Fastxxx_Purge,NEAR
        ASSUME  CS:DOSCODE,SS:NOTHING
        PUSH    AX                            ; save regs.                      ;AN000;
        PUSH    SI                                                              ;AN000;
        PUSH    DX                                                              ;AN000;

topen:

        push    ds                            ; set up ds to DOSDATA
        getdseg <ds>

        TEST    FastOpenflg,Fast_yes          ; fastopen installed ?            ;AN000;

        pop     ds
        assume  ds:nothing

        JZ      nofast                        ; no                              ;AN000;
        MOV     AH,FastOpen_ID                ;                                 AN000;
dofast:
        MOV     AL,FONC_purge                 ; purge                           ;AN000;
        MOV     DL,ES:[BP.dpb_drive]          ; set up drive number             ;AN000;
        invoke  Fast_Dispatch                 ; call fastopen/seek              ;AN000;
nofast:
        POP     DX                                                              ;AN000;
        POP     SI                            ; restore regs                    ;AN000;
        POP     AX                            ;                                 ;AN000;

        return                                ; exit                            ;AN000;

EndProc Fastxxx_Purge
endif

DOSCODE ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\msctrlc.asm ===
;**	MSCTRLC.ASM - ^C and error handler for MSDOS
;
;   Revision History:
;	Sudeepb 14-Mar-1991 Ported for NT DOSEm
;
	.xlist
	.xcref
	include version.inc
	include mssw.asm
	.cref
	.list

	TITLE	Control C detection, Hard error and EXIT routines
	NAME	IBMCTRLC


;**	Low level routines for detecting special characters on CON input,
;	the ^C exit/int code, the Hard error INT 24 code, the
;	process termination code, and the INT 0 divide overflow handler.
;
;	FATAL
;	FATAL1
;	reset_environment
;	DSKSTATCHK
;	SPOOLINT
;	STATCHK
;	CNTCHAND
;	DIVOV
;	CHARHARD
;	HardErr
;
;	Revision history:
;
;	    AN000	version 4.0   Jan 1988
;	    A002	PTM    -- dir >lpt3 hangs
;	    A003	PTM 3957- fake version for IBMCAHE.COM

	.xlist
	include dosseg.inc
	.xcref
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include pdb.inc
	include exe.inc
	include sf.inc
	include vector.inc
	include filemode.inc
	include mi.inc
	include syscall.inc
	include bugtyp.inc
	include dossvc.inc
        include vint.inc
ifdef NEC_98
	include dpb.inc
endif   ;NEC_98
	.cref
	.list

	I_need	SFN,WORD
	I_NEED	pJFN,DWORD
	i_need	DevIOBuf,BYTE
	i_need	DidCTRLC,BYTE
	i_need	INDOS,BYTE
	i_need	DSKSTCOM,BYTE
	i_need	DSKSTCALL,BYTE
	i_need	DSKSTST,WORD
        i_need  THISSFT,DWORD
        i_need  VIRTUAL_OPEN
	i_need	BCON,DWORD
	i_need	DSKCHRET,BYTE
	i_need	DSKSTCNT,WORD
	i_need	IDLEINT,BYTE
	i_need	CONSWAP,BYTE
	i_need	user_SS,WORD
	i_need	user_SP,WORD
	i_need	User_In_AX,WORD
	i_need	ERRORMODE,BYTE
	i_need	ConC_spsave,WORD
	i_need	Exit_type,BYTE
	i_need	PFLAG,BYTE
	i_need	ExitHold,DWORD
	i_need	WPErr,BYTE
	i_need	ReadOp,BYTE
	i_need	CONTSTK,WORD
	i_need	Exit_Code,WORD
	i_need	CurrentPDB,WORD
	i_need	DIVMES,BYTE
	i_need	ALLOWED,BYTE
	i_need	FAILERR,BYTE
	i_need	EXTERR,WORD
	i_need	ERR_TABLE_24,BYTE
	I_need	ErrMap24,BYTE
	I_need	ErrMap24End,BYTE
	I_need	fAborting,BYTE
	I_need	AUXStack,BYTE
	I_need	SCAN_FLAG,BYTE
	I_need	EXTOPEN_ON,BYTE 	      ;AN000; DOS 4.0
	I_need	InterCon,BYTE		      ;AN000; DOS 4.0
	I_need	DOS34_FLAG,WORD 	      ;AN000; DOS 4.0
	I_need	Special_Version,WORD	      ;AN007; DOS 4.0
	I_need	vheVDM,BYTE
	I_need	vheDev,BYTE
	I_need	TEMPSEG, WORD
	I_need	DosHasHMA,byte			; M021
ifdef JAPAN
	i_need	DIVMES2,BYTE
endif


DOSDATA	SEGMENT
	extrn	LowInt23:near
	extrn	LowInt24:near
	extrn	LowInt28:near
DOSDATA	ENDS



DOSCODE SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	extrn	DivMesLen:WORD
ifdef JAPAN
	extrn	DivMesLen2:WORD
endif

	allow_getdseg


		public	LowInt23Addr		
LowInt23Addr	LABEL	DWORD
	DW	offset DOSDATA:LowInt23, 0

		public	LowInt24Addr
LowInt24Addr	LABEL	DWORD
	DW	offset DOSDATA:LowInt24, 0

		public	LowInt28Addr
LowInt28Addr	LABEL	DWORD
	DW	offset DOSDATA:LowInt28, 0



Break	<Checks for ^C in CON I/O>

;---------------------------------------------------------------------------
;
; Procedure Name : DSKSTATCHK
;
; Check for ^C if only one level in
;
;---------------------------------------------------------------------------

procedure   DSKSTATCHK,NEAR	

	CMP	BYTE PTR InDos,1	; SS override
	retnz				; Do NOTHING
	DOSAssume   <SS>,"DskStatChk"
	PUSH	CX
	PUSH	ES
	PUSH	BX
	PUSH	DS
	PUSH	SI

	MOV	BX, SS			; SS is DOSDATA. ES:BX must be set up
	MOV	ES, BX			; for deviocall2
	assume	es:nothing		
	MOV	DS, BX
	MOV	BYTE PTR DskStCom,DEVRDND
	MOV	BYTE PTR DskStCall,DRDNDHL
	MOV	DskStSt,0
 IFDEF  DBCS				;AN000;
	MOV	AL, InterCon		;AN000; get type of status read 2/13/KK
	MOV	BYTE PTR DskChRet,AL	;AN000; load interim flag into packet
 ENDIF					;AN000;

					; DSKSTCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DSKSTCALL
	LDS	SI,BCon
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2
	TESTB	DSKSTST,STBUI		; SS override
	JZ	GotCh			; No characters available
	XOR	AL,AL			; Set zero
RET36:
	POP	SI
	POP	DS
	POP	BX
	POP	ES
	POP	CX
	return

GotCh:

	MOV	AL,BYTE PTR DskChRet	; SS override
DSK1:
	CMP	AL,"C"-"@"
	JNZ	RET36

					; SS used for next 5 instructions 
	MOV	BYTE PTR DskStCom,DEVRD
	MOV	BYTE PTR DskStCall,DRDWRHL
	MOV	BYTE PTR DskChRet,CL
	MOV	DskStSt,0
	MOV	DskStCnt,1
	invoke	DEVIOCALL2		; Eat the ^C
	POP	SI
	POP	DS
	POP	BX			; Clean stack
	POP	ES
	POP	CX
	JMP	CNTCHAND

NOSTOP:
	CMP	AL,"P"-"@"
	JNZ	check_next

				    	; SS override
	CMP	BYTE PTR Scan_Flag,0	; ALT_Q ?
	JZ	INCHKJ			; no
	return
check_next:
	IF	NOT TOGLPRN
	CMP	AL,"N"-"@"
	JZ	INCHKJ
	ENDIF

	CMP	AL,"C"-"@"
	JZ	INCHKJ
check_end:
	return

INCHKJ:
	JMP	INCHK

EndProc DSKSTATCHK

;----------------------------------------------------------------------------
;
; Procedure Name : SpoolInt
;
; SpoolInt - signal processes that the DOS is truly idle.  We are allowed to
; do this ONLY if we are working on a 1-12 system call AND if we are not in
; the middle of an INT 24.
;
;----------------------------------------------------------------------------

procedure   SPOOLINT,NEAR
        PUSH    ax
        lahf
        push    ax
	cmp	IdleInt,0		; SS override for IdleInt & ErrorMode
	je	POPFRet
	cmp	ErrorMode,0
	jnz	POPFRet
	
	;
	; Note that we are going to allow an external program to issue system 
	; calls at this time.  We MUST preserve IdleInt across this.
	;

	PUSH	WORD PTR IdleInt

	cmp	[DosHasHMA], 0		; Q: is dos running in HMA (M021)
	jne	do_low_int28		; Y: the int must be done from low mem
	INT	int_spooler		; N: Execute user int 28 handler
	jmp	short spool_ret_addr

do_low_int28:
	call	dword ptr LowInt28Addr

spool_ret_addr:

	POP	WORD PTR IdleInt
POPFRET:
        pop     ax
        sahf
        pop     ax
	return
EndProc SPOOLINT


;----------------------------------------------------------------------------
;
; Procedure Name : STATCHK
;
;----------------------------------------------------------------------------

	procedure   STATCHK,NEAR

	invoke	DSKSTATCHK		; Allows ^C to be detected under
					; input redirection
	PUSH	BX
	XOR	BX,BX
	invoke	GET_IO_SFT
	POP	BX
	retc
	MOV	AH,1
	invoke	IOFUNC
	JZ	SPOOLINT
	CMP	AL,"S"-"@"
	JNZ	NOSTOP

					; SS override
	CMP	BYTE PTR Scan_Flag,0	; AN000; ALT_R ?
	JNZ	check_end		; AN000; yes
	XOR	AH,AH
	invoke	IOFUNC			; Eat Cntrl-S
	JMP	SHORT PAUSOSTRT
PRINTOFF:
PRINTON:

	NOT	BYTE PTR PFlag		; SS override
	PUSH	BX
	MOV	BX,4
	invoke	GET_IO_SFT
	POP	BX
	retc
	PUSH	ES
	PUSH	DI
	PUSH	DS
	POP	ES
	MOV	DI,SI			; ES:DI -> SFT
	TESTB	ES:[DI].SF_FLAGS,sf_net_spool
	JZ	NORM_PR 		; Not redirected, echo is OK
	Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> ; See if allowed
	JNC	NORM_PR 		; Echo is OK

					; SS override
	MOV	BYTE PTR PFlag,0	; If not allowed, disable echo
	Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
	JMP	SHORT RETP6

NORM_PR:
	CMP	BYTE PTR PFlag,0	; SS override
	JNZ	PRNOPN
	invoke	DEV_CLOSE_SFT
	JMP	SHORT RETP6

PRNOPN:
	invoke	DEV_OPEN_SFT
RETP6:
	POP	DI
	POP	ES
	return

PAUSOLP:
	CALL	SPOOLINT
PAUSOSTRT:
	MOV	AH,1
	invoke	IOFUNC
	JZ	PAUSOLP
INCHK:
	PUSH	BX
	XOR	BX,BX
	invoke	GET_IO_SFT
	POP	BX
	retc
	XOR	AH,AH
	invoke	IOFUNC
	CMP	AL,"P"-"@"

	;;;;;  7/14/86	ALT_Q key fix

	JZ	PRINTON			; no! must be CTRL_P

NOPRINT:

	;;;;;  7/14/86	ALT_Q key fix

	IF	NOT TOGLPRN
	CMP	AL,"N"-"@"
	JZ	PRINTOFF
	ENDIF
	CMP	AL,"C"-"@"
	retnz
EndProc STATCHK

;	!! NOTE: FALL THROUGH !!

;---------------------------------------------------------------------------
;
; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
;
; "^C" and CR/LF is printed.  Then the user registers are restored and the
; user CTRL-C handler is executed.  At this point the top of the stack has 1)
; the interrupt return address should the user CTRL-C handler wish to allow
; processing to continue; 2) the original interrupt return address to the code
; that performed the function call in the first place.	If the user CTRL-C
; handler wishes to continue, it must leave all registers unchanged and RET
; (not IRET) with carry CLEAR.	If carry is SET then an terminate system call
; is simulated.
;
;---------------------------------------------------------------------------

procedure   CNTCHAND,NEAR

					; SS override
					; AN002; from RAWOUT
	TESTB	Dos34_Flag,CTRL_BREAK_FLAG  
	JNZ	around_deadlock 	; AN002;
	MOV	AL,3			; Display "^C"
	invoke	BUFOUT
	invoke	CRLF
around_deadlock:			;AN002;
	Context DS			; SS is DOSDATA
	CMP	BYTE PTR ConSwap,0
	JZ	NOSWAP
	invoke	SWAPBACK
NOSWAP:
        call    DOCLI                   ; Prepare to play with stack
	MOV	SS,User_SS		; User stack now restored
ASSUME	SS:NOTHING
	MOV	SP,User_SP

					; use macro for restore_world
	restore_world			; User registers now restored

	;
	; CS was used to address these variables. We have to use DOSDATA 
	;
	push	ds
	getdseg	<ds>			; ds -> dosdata

	MOV	BYTE PTR InDos,0	; Go to known state
	MOV	BYTE PTR ErrorMode,0
	MOV	ConC_Spsave,SP		; save his SP


	; User SP has changed because of push. Adjust for it

	add	ConC_Spsave,2		

	cmp	[DosHasHMA], 0		; Q: is dos running in HMA (M021)
 	pop	ds	;restore ds
	assume	ds:NOTHING

	jne	do_low_int23		; Y: the int must be done from low mem
	CLC				
	INT	int_ctrl_c		; N: Execute user Ctrl-C handler
	jmp	short ctrlc_ret_addr

do_low_int23:
	clc
	call	dword ptr LowInt23Addr

ctrlc_ret_addr:


;
; The user has returned to us.	The circumstances we allow are:
;
;   IRET	We retry the operation by redispatching the system call
;   CLC/RETF	POP the stack and retry
;   ... 	Exit the current process with ^C exit
;
; User's may RETURN to us and leave interrupts on.  Turn 'em off just to be
; sure
;
        call    DOCLI

	;
	; We have to use DOSDATA for these variables. Previously CS was used 
	;

	push	ax
	mov	ax, ds
	getdseg	<ds>			; ds -> dosdata

	mov	TempSeg, ax
	pop	ax

	MOV	User_In_AX,ax		; save the AX
	PUSHF				; and the flags (maybe new call)
	POP	AX

	;
	; See if the input stack is identical to the output stack
	;

	CMP	SP,ConC_Spsave
	JNZ	ctrlc_try_new		; current SP not the same as saved SP

	;
	; Repeat the operation by redispatching the system call.
	;

ctrlc_repeat:
	MOV	AX,User_In_AX		; ds still points to dosdata 

					
	mov	ds, TempSeg		; restore ds and original sp 
	assume	ds:NOTHING

	transfer    COMMAND

	;
	; The current SP is NOT the same as the input SP.  Presume that he 
	; RETF'd leaving some flags on the stack and examine the input
	;

ctrlc_try_new:
	ADD	SP,2			; pop those flags
	TESTB	AX,f_carry		; did he return with carry?
	JZ	Ctrlc_Repeat		; no carry set, just retry

					
	assume	ds:DOSDATA		;restore ds 
	mov	ds, TempSeg
	assume	ds:NOTHING

	;
	; Well...  time to abort the user.  Signal a ^C exit and use the EXIT 
	; system call..
	;

ctrlc_abort:
	MOV	AX,(EXIT SHL 8) + 0

	push	ds
	getdseg	<ds>			; ds -> dosdata
	
	MOV	DidCTRLC,-1

	pop	ds
	assume	ds:NOTHING

	transfer    COMMAND		; give up by faking $EXIT

EndProc CNTCHAND

Break	<DIVISION OVERFLOW INTERRUPT>
;----------------------------------------------------------------------------
;
; Procedure Name : DIVOV
;
; Default handler for division overflow trap
;
;----------------------------------------------------------------------------

procedure   DIVOV,NEAR
	ASSUME	SS:NOTHING

					; DIVMES is in DOSCODE
	MOV	SI,OFFSET DOSCODE:DIVMES
	MOV	BX,DivMesLen

					; Point SS to dosdata 
ifdef JAPAN
	push	ax
	push	bx
	mov	ax,4f01h		; get code page
	xor	bx,bx
	int	2fh
	cmp	bx,932
	pop	bx
	pop	ax
	jz	@f			; if DBCS code page
	mov	si,offset DOSCODE:DIVMES2
	mov	bx,DivMesLen2
@@:
endif

	getdseg	<ss>			; we are in an ISR flag is CLI

					; AUXSTACK is in DOSDATA
					; Enough stack for interrupts
	MOV	SP,OFFSET DOSDATA:AUXSTACK 
	CALL	OutMes
	JMP	ctrlc_abort		; Use Ctrl-C abort on divide overflow
EndProc DIVOV

;---------------------------------------------------------------------------
;
; Procedure Name : OutMes
;
;
; OutMes: perform message output
; Inputs:   SS:SI points to message
;	    BX has message length
; Outputs:  message to BCON
;
;Actually, cs:si points to the message now. The segment address is filled in
;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
;NB. This procedure is called only from DIVOV. -SR
;
;---------------------------------------------------------------------------

procedure   OutMes,NEAR

	Context ES			; get ES addressability
	Context DS			; get DS addressability

	MOV	BYTE PTR DskStCom,DevWrt
	MOV	BYTE PTR DskStCall,DRdWrHL
	MOV	DskStSt,0
	MOV	DskStCnt,BX

					; DSKSTCALL is in DOSDATA
	MOV	BX,OFFSET DOSDATA:DskStCall
	MOV	WORD PTR [DskChRet+1],SI; transfer address (need an EQU)


					; CS is used for string, fill in 
					; segment address 
	MOV	WORD PTR [DskChRet+3],CS

	LDS	SI,BCon

ASSUME	DS:NOTHING
	invoke	DEVIOCALL2
					; ES still points to DOSDATA. ES is
					; not destroyed by deviocall2. So use
					; ES override.

					; DEVIOBUF is in DOSDATA
	MOV	WORD PTR ES:[DskChRet+1],OFFSET DOSDATA:DevIOBuf
	MOV	ES:[DskStCnt],1
	return
EndProc OutMes

Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
;---------------------------------------------------------------------------
;
; Procedure Name : CHARHARD
;
;
; Character device error handler
; Same function as HARDERR
;
;---------------------------------------------------------------------------

procedure   CHARHARD,NEAR
	ASSUME	SS:DOSDATA

		   			; M024 - start
	cmp	byte ptr [ErrorMode], 0	; Q: are we in the middle of int 24
	jne	@f			; Y: allow fail

	OR	AH, allowed_RETRY	; assume ctrl p

	test	byte ptr [PFLAG], -1	; Q: has ctrl p been pressed
	jnz	ctrlp			; Y: 
@@:					; M024 - end

	OR	AH,allowed_FAIL + allowed_IGNORE + allowed_RETRY

ctrlp:					; M024

					; SS override for Allowed and EXITHOLD
	MOV	Allowed,AH
	MOV	WORD PTR EXITHOLD+2,ES
	MOV	WORD PTR EXITHOLD,BP
	PUSH	SI
	AND	DI,STECODE
	MOV	BP,DS			; Device pointer is BP:SI
	CALL	FATALC
	POP	SI
	return
EndProc CHARHARD


procedure   TestHrdErr,NEAR
               ; SS override
thr_strt:
        cmp     DOSDATA:[vheVDM.vhe_fbInt24], 0
        stc
	jnz	thr_herr
	ret

thr_herr:
        mov     al, DOSDATA:[vheVDM.vhe_HrdErrCode]
        push    ax
        mov     Allowed, allowed_FAIL + allowed_RETRY
	invoke	HardErr
	cmp	al,1
	je	thr_retry
        pop     ax
        add     ax,19               ; convert to normal error codes
        stc
	ret
thr_retry:
	pop	ax
	SVC	SVC_DEMRETRY
	jc	short thr_strt
	ret

EndProc TestHrdErr


;---------------------------------------------------------------------------
;
; Procedure Name : HardErr
;
; Hard disk error handler. Entry conditions:
;	DS:BX = Original disk transfer address
;	DX = Original logical sector number
;	CX = Number of sectors to go (first one gave the error)
;	AX = Hardware error code
;	DI = Original sector transfer count	
;	ES:BP = Base of drive parameters
;	[READOP] = 0 for read, 1 for write
;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
; Output:
;	[FAILERR] will be set if user responded FAIL
;
;--------------------------------------------------------------------------

procedure   HardErr,NEAR



	XCHG	AX,DI			; Error code in DI, count in AX
	AND	DI,STECODE		; And off status bits
	xor	AH,AH			; DISK IO error

	OR	AH,Allowed		; Set the allowed_ bits
	entry	FATAL
        mov     al, DOSDATA:[vheVDM.vhe_bDriveNum] ; Get drive number

        ;
        ; NTVDM file reads\writes to network drives also come in here
        ;       if remote drive set to char device type for apps sanity
        ;
        mov     DOSDATA:[vheDev.sdevatt], 0h
        cmp     al, -1
        jne     not_remote
        or      ah, 80h
        or      DOSDATA:[vheDev.sdevatt], 8000h
not_remote:

        entry   FATAL1
	MOV	WORD PTR EXITHOLD+2,ES
	MOV	WORD PTR EXITHOLD,BP	; The only things we preserve
        mov     si, offset DOSDATA:vheDev
        mov     bp, ss                  ; BP:SI points to the fake device

	;
	; DI has the INT-24-style extended error.  We now map the error code 
	; for this into the normalized get extended error set by using the 
	; ErrMap24 table as a translate table.  Note that we translate ONLY 
	; the device returned codes and leave all others beyond the look up 
	; table alone.
	;

FATALC:
	call	SET_I24_EXTENDED_ERROR
	CMP	DI,error_I24_gen_failure
	JBE	GOT_RIGHT_CODE		; Error codes above gen_failure get
	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
                                        ;  Only come via GetExtendedError




;**
;
; Entry point used by REDIRector on Network I 24 errors.
;
;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
;
; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
;     EXITHOLD set for restore of ES:BP.
;

	entry	NET_I24_ENTRY

GOT_RIGHT_CODE:

					; SS override
	CMP	BYTE PTR ErrorMode,0	; No INT 24s if already INT 24
	JZ	NoSetFail
	MOV	AL,3
IF	DEBUG
	JMP	FailRet
ELSE
	JMP	short FailRet
ENDIF
NoSetFail:

					; SS override
	MOV	CONTSTK,SP
	Context ES
	fmt TypINT24,LevLog,<"INT 24: AX = $x DI = $x\n">,<AX,DI>

	;
	; Wango!!!  We may need to free some user state info...  In 
	; particular, we may have locked down a JFN for a user and he may 
	; NEVER return to us. Thus,we need to free it here and then 
	; reallocate it when we come back.
	;

					; SS override for SFN and pJFN
	CMP	SFN,-1
	JZ	NoFree
	SAVE	<DS,SI>
	LDS	SI,pJFN
	MOV	BYTE PTR [SI],0FFH
	RESTORE <SI,DS>
NoFree:
        call    DOCLI                   ; Prepare to play with stack

					; SS override for ERRORMODE, INDOS, 
					; DOS34_FLAG, EXTOPEN_ON
	INC	BYTE PTR ErrorMode	; Flag INT 24 in progress
	DEC	BYTE PTR InDos		; INT 24 handler might not return

ifdef NEC_98
	;; Extended Open hooks

					; AN000;IFS.I24 error disabled	      ;AN000;
	TESTB	EXTOPEN_ON,EXT_OPEN_I24_OFF 
	JZ	i24yes			; AN000;IFS.no			      ;AN000;
faili24:				; AN000;
	MOV	AL,3			; AN000;IFS.fake fail		      ;AN000;
	JMP	short passi24 		; AN000;IFS.exit			      ;AN000;
i24yes: 				; AN000;

	;; Extended Open hooks

endif   ;NEC_98
	MOV	SS,User_SS
ASSUME	SS:NOTHING
	MOV	SP,ES:User_SP		; User stack pointer restored

	cmp	[DosHasHMA], 0		; Q: is dos running in HMA (M021)
	jne	do_low_int24		; Y: the int must be done from low mem
	INT	int_fatal_abort 	; Fatal error interrupt vector, 
					; must preserve ES
	jmp	short criterr_ret_addr

do_low_int24:
	call	dword ptr LowInt24Addr

criterr_ret_addr:
	MOV	ES:User_SP,SP		; restore our stack
	MOV	ES:User_SS,SS
	MOV	BP,ES
	MOV	SS,BP
ASSUME	SS:DOSDATA
passi24:				; AN000;

					; SS override for nect 3 instructions.
	MOV	SP,CONTSTK
	INC	BYTE PTR InDos		; Back in the DOS
	MOV	BYTE PTR ErrorMode,0	; Back from INT 24
        call    DOSTI
	fmt TypINT24,LevLog,<"INT 24: User reply = $x\n">,<AX>
FAILRET:
					
	LES	BP,EXITHOLD		; SS override
ASSUME	ES:NOTHING

	;
	; Triage the user's reply.
        ;
        CMP     AL,1
	JB	CheckIgnore		; 0 => ignore
	JZ	CheckRetry		; 1 => retry
	CMP	AL,3			; 3 => fail
	JNZ	DoAbort 		; 2, invalid => abort

	;
	; The reply was fail.  See if we are allowed to fail.
	;

					; SS override for ALLOWED, EXTOPEN_ON, 
					; ALLOWED, FAILERR, WpErr, SFN, pJFN
	TESTB	Allowed,allowed_FAIL	; Can we?
	JZ	DoAbort 		; No, do abort
DoFail:
	MOV	AL,3			; just in case...
					; AN000;EO. I24 error disabled
	TESTB	EXTOPEN_ON,EXT_OPEN_I24_OFF 
	JNZ	cleanup 		; AN000;EO. no
	INC	FAILERR			; Tell everybody
CleanUp:
	MOV	WpErr,-1
	CMP	SFN,-1
	retz
	SAVE	<DS,SI,AX>
	MOV	AX,SFN
	LDS	SI,pJFN
	MOV	[SI],AL
	RESTORE <AX,SI,DS>
	return

	;
	; The reply was IGNORE.  See if we are allowed to ignore.
	;

CheckIgnore:
	TESTB	Allowed,allowed_IGNORE 	; Can we?
	JZ	DoFail			; No, do fail
	JMP	CleanUp

	;	
	; The reply was RETRY.	See if we are allowed to retry.
	;

CheckRetry:
	TESTB	Allowed,allowed_RETRY 	; Can we?
	JZ	DoFail			; No, do fail
	JMP	CleanUp

	;
	; The reply was ABORT.
	;

DoAbort:
	Context DS
	CMP	BYTE PTR ConSwap,0
	JZ	NOSWAP2
	invoke	SWAPBACK
NOSWAP2:

	;	
	; See if we are to truly abort.  If we are in the process of aborting, 
	; turn this abort into a fail.
	;

	cmp	fAborting,0
	JNZ	DoFail

	;
	; Set return code
	;

	MOV	BYTE PTR [exit_Type],Exit_hard_error
	XOR	AL,AL

	;
	; we are truly aborting the process.  Go restore information from 
	; the PDB as necessary.
	;

	Transfer    exit_inner
;**
;
; reset_environment checks the DS value against the CurrentPDB.  If they are
; different, then an old-style return is performed.  If they are the same,
; then we release jfns and restore to parent.  We still use the PDB at DS:0 as
; the source of the terminate addresses.
;
; Some subtlety:  We are about to issue a bunch of calls that *may* generate
; INT 24s.  We *cannot* allow the user to restart the abort process; we may
; end up aborting the wrong process or turn a terminate/stay/resident into a
; normal abort and leave interrupt handlers around.  What we do is to set a
; flag that will indicate that if any abort code is seen, we just continue the
; operation.  In essence, we dis-allow the abort response.
;
; output:   none.
;
	entry	reset_environment
	ASSUME	DS:NOTHING,ES:NOTHING

;***	invoke	Reset_Version		; AN007;MS. reset version number
        PUSH    DS                      ; save PDB of process


; NTVDM - we don't do any crit\sect stuff
; 04-Aug-1992 Jonle
;
;        ;
;        ; There are no critical sections in force.  Although we may enter
;        ; here with critical sections locked down, they are no longer
;        ; relevant. We may safely free all allocated resources.
;        ;
;
;       MOV     AH,82h
;       INT     int_IBM

					; SS override
	MOV	fAborting,-1		; signal abort in progress

					; DOS 4.00 doesn't need it
	CallInstall NetResetEnvironment, multNet, 34  
					; Allow REDIR to clear some stuff
					; On process exit.
	MOV	AL,int_Terminate
	invoke	$Get_interrupt_vector	; and who to go to

	POP	CX			; get ThisPDB

	SAVE	<ES,BX> 		; save return address

	MOV	BX,[CurrentPDB] 	; get currentPDB
	MOV	DS,BX
	MOV	AX,DS:[PDB_Parent_PID]	; get parentPDB

	;
	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
	; is not Exit_keep_process
	;
	
	CMP	AX,BX
	JZ	reset_return		; parentPDB = CurrentPDB
	CMP	BX,CX
	JNZ	reset_return		; CurrentPDB <> ThisPDB
	PUSH	AX			; save parent

					; SS override
	CMP	BYTE PTR [exit_type],Exit_keep_process
	JZ	reset_to_parent 	; keeping this process

	;
	; We are truly removing a process.  Free all allocation blocks 
	; belonging to this PDB
	;

	; Call DEM to close the search handles for this PDB
	SVC	SVC_PDBTERMINATE	; BX is the PDB


	invoke	arena_free_process

	;
	; Kill off remainder of this process.  Close file handles and signal 
	; to relevant network folks that this process is dead.  Remember that 
	; CurrentPDB is STILL the current process!
	;

	invoke	DOS_ABORT

reset_to_parent:
					; SS override
	POP	[CurrentPDB]		; set up process as parent

reset_return:				; come here for normal return

	Context	DS			; DS is used to refer to DOSDATA  

	MOV	AL,-1

	;
	; make sure that everything is clean In this case ignore any errors, 
	; we cannot "FAIL" the abort, the program being aborted is dead.
	;

;	EnterCrit   critDisk
;	invoke	FLUSHBUF
;	LeaveCrit   critDisk

	;
	; Decrement open ref. count if we had done a virtual open earlier.
	;

	invoke	CHECK_VIRT_OPEN
        call    DOCLI
	MOV	BYTE PTR InDos,0	; Go to known state
	MOV	BYTE PTR [WPERR],-1	; Forget about WP error
	MOV	fAborting,0		; let aborts occur
	POP	WORD PTR ExitHold
	POP	WORD PTR ExitHold+2

	;
	; Snake into multitasking... Get stack from CurrentPDB person
	;

	MOV	DS,[CurrentPDB]
	ASSUME	DS:NOTHING
	MOV	SS,WORD PTR DS:[PDB_user_stack+2]
	MOV	SP,WORD PTR DS:[PDB_user_stack]

	ASSUME	SS:NOTHING
	restore_world			; use macro

	ASSUME	ES:NOTHING


	push	ax			; set up ds, but save ds in TEMPSEG 
	mov	ax, ds			; and not on stack.
	getdseg <ds>			; ds ->dosdata
	mov	TempSeg, ax
	pop	ax
					; set up ds to DOSDATA
	MOV	User_SP,AX

	POP	AX			; take off CS:IP of interrupt...
	POP	AX
	POP	AX

; M011 : BEGIN

;	MOV	AX,0F202h		; STI

	LAHF
	XCHG	AH, AL
	AND	AL, 02
	MOV	AH, 0F2h

; M011 : END

	PUSH	AX

 
	PUSH	WORD PTR [EXITHOLD+2]
	PUSH	WORD PTR [EXITHOLD]

	MOV	AX,User_SP

	mov	ds,TempSeg		; restore ds
	assume	ds:NOTHING

        jmp     DOIRET                  ; Long return back to user terminate address
EndProc HardErr,NoCheck

Procedure DOCLI,near
        FCLI
        ret
EndProc DOCLI

Procedure DOSTI,near
        FSTI
        ret
EndProc DOSTI

        public DOIRET
DOIRET:
        FIRET

;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_VIRT_OPEN
;
; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
; flag [VIRTUAL_OPEN].
; No registers affected (including flags).
; On input, [THISSFT] points to current SFT.
;
;---------------------------------------------------------------------------

Procedure CHECK_VIRT_OPEN,NEAR
	DOSAssume   <DS>,"Check_Virt_Open"

        PUSH    AX
        lahf                    ; preserve flags
        CMP     [VIRTUAL_OPEN],0
        JZ      ALL_CLOSED
        mov     [VIRTUAL_OPEN],0        ; reset flag
	SAVE	<ES,DI>
        LES     DI,[THISSFT]
        INVOKE  DEV_CLOSE_SFT
	RESTORE <DI,ES>

ALL_CLOSED:
        sahf                    ; restore flags
        POP     AX
        return

EndProc CHECK_VIRT_OPEN

;---------------------------------------------------------------------------
;
; Procedure Name : SET_I24_EXTENDED_ERROR
;
; This routine handles extended error codes.
; Input : DI = error code from device
; Output: All EXTERR fields are set
;
;--------------------------------------------------------------------------

Procedure SET_I24_EXTENDED_ERROR,NEAR
	PUSH	AX

					; ErrMap24End is in DOSDATA
	MOV	AX,OFFSET DOSDATA:ErrMap24End
	SUB	AX,OFFSET DOSDATA:ErrMap24

					; Change to dosdata to access 
					; ErrMap24 and EXTERR -SR
	push	ds
	getdseg <ds>			; ds ->dosdata

	;
	; AX is the index of the first unavailable error.  Do not translate 
	; if greater or equal to AX.
	;

	CMP	DI,AX
	MOV	AX,DI
	JAE	NoTrans

	MOV	AL,ErrMap24[DI]
	XOR	AH,AH
NoTrans:

	MOV	[EXTERR],AX
	pop	ds
	assume	ds:nothing
	POP	AX

	;
	; Now Extended error is set correctly.	Translate it to get correct 
	; error locus class and recommended action.
	;

	PUSH	SI

					; ERR_TABLE_24 is in DOSCODE 
	MOV	SI,OFFSET DOSDATA:ERR_TABLE_24
	invoke	CAL_LK			; Set other extended error fields
	POP	SI
	ret
EndProc SET_I24_EXTENDED_ERROR


;--------------------------------------------------------------------------
;
; Proc. name : dos_high
;
; ENTRY: CS = current doscode segment
; 
; EXIT: if CS >=F000 (DOS is in HMA)
;	   CY stc
;	else	     (DOS is LOW)
;	   NC clc	
;
; USED: nothing
;
;-------------------------------------------------------------------------
;
;public	dos_high
;dos_high	proc	near
;
;	push	ax
;	mov	ax, cs
;	cmp	ax, 0f000h		; Q: is current cs >= f000
;	pop	ax
;	cmc				; clc if dos is low
;					; stc if dos is high 
;	ret
;
;dos_high	endp
;

DOSCODE	ENDS
    END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\misc2.asm ===
TITLE MISC2 - Miscellanious routines for MS-DOS
	NAME  MISC2

;**	MISC2.ASM - Miscellaneous useful routines
;
;	StrCpy
;	StrCmp
;	StrLen
;	DStrLen
;	Idle
;	TableDispatch
;	FastInit			  ; DOS 4.0
;	FastRet			  ; DOS 4.0
;	NLS_OPEN			  ; DOS 4.0
;	NLS_LSEEK			  ; DOS 4.0
;	Fake_User_Stack		  ; DOS 4.0
;	GetDevList			  ; DOS 4.0
;	NLS_IOCTL			  ; DOS 4.0
;	NLS_GETEXT			  ; DOS 4.0
;	MSG_RETRIEVAL		  ; DOS 4.0
;	Fake_Version		  ; DOS 4.0
;
;	Revision history:
;
;	   Created: ARR 30 March 1983
;
;	   A000   version 4.0	Jan. 1988
;	   A001   DCR 486 - Share installation for >32mb drives
;	   A006   DCR 503 - fake version number for IBMCACHE
;	   DOS 5.00 Moved fake version to caller's PSP
	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include sysvar.inc
	include sf.inc
	include curdir.inc
	include fastxxxx.inc
	include bugtyp.inc
	.cref
	.list

	i_need	THISCDS,DWORD
	I_Need	RetryLoop,WORD
	I_need	fSharing,BYTE		; TRUE => server-issued call
	I_need	FastTable,BYTE		;AN000;
	I_need	FastFlg,BYTE		;AN000;
	I_need	User_SP_2F,WORD 	;AN000;
	I_need	User_SP,WORD		;AN000;
	I_need	User_SS,WORD		;AN000;
	I_need	SysInitTable,BYTE	;AN000;
	I_need	EXTERR,WORD		;AN000;
	I_need	MSG_EXTERROR,DWORD	;AN000;
	I_need	fshare,byte		;AN001;
	I_need	Special_version,WORD	;AN006;

DOSCODE	SEGMENT

	allow_getdseg

	ASSUME	SS:DOSDATA,CS:DOSCODE



Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
;----------------------------------------------------------------------------
;
;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
;		Strings of different lengths don't match.
;   Inputs:	DS:SI - pointer to source string  ES:DI - pointer to dest string
;   Outputs:	Z if strings same, NZ if different
;   Registers modified: NONE
;----------------------------------------------------------------------------

Procedure   StrCmp,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<SI,DI,AX>
Cmplp:
	LODSB
 IFDEF  DBCS				;AN000;
	invoke	testkanj		;AN000;; 2/13/KK
	jz	notkanj1		;AN000;; 2/13/KK
	dec	si			;AN000;; Do source again 2/13/KK
	cmpsb				;AN000;; First byte	 2/13/KK
	JNZ	PopRet			;AN000;; Strings dif	 2/13/KK
	cmpsb				;AN000;; Second byte of kanji char 2/13/KK
	JNZ	PopRet			;AN000;; Strings dif	 2/13/KK
	mov	al,byte ptr [SI-1]	;AN000;; Need last byte in AL  2/13/KK
	jmp	short Tend		;AN000;
notkanj1:				;AN000;; 2/13/KK
 ENDIF					;AN000;
	invoke	UCase			; convert to upper case
	Invoke	PathChrCmp		; convert / to \
	MOV	AH,AL
	MOV	AL,ES:[DI]
	INC	DI
	invoke	UCase			; convert to upper case
	Invoke	PathChrCmp		; convert / to \
	CMP	AH,AL
	JNZ	PopRet			; Strings dif
Tend:
	OR	AL,AL
	JNZ	Cmplp			; More string
PopRet:
	RESTORE <AX,DI,SI>
	return
EndProc StrCmp

Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
;----------------------------------------------------------------------------
;
;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI.  no modification of
;	characters.
;
;   Inputs:	DS:SI - pointer to source string
;		ES:DI - pointer to destination string
;   Outputs:	ES:DI point byte after nul byte at end of dest string
;		DS:SI point byte after nul byte at end of source string
;   Registers modified: SI,DI
;----------------------------------------------------------------------------

Procedure   StrCpy,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<AX>
CPYLoop:
	LODSB
 IFDEF  DBCS			;AN000;
	invoke	testkanj	;AN000;; 2/13/KK
	jz	notkanj2	;AN000;; 2/13/KK
	STOSB			;AN000;; 2/13/KK
	LODSB			;AN000;; 2/13/KK
	STOSB			;AN000;; 2/13/KK
	jmp	short CPYLoop	;AN000;; 3/31/KK

notkanj2:			;AN000;; 2/13/KK
 ENDIF				;AN000;
	invoke	UCase			; convert to upper case
	Invoke	PathChrCmp		; convert / to \
	STOSB
Tend2:
	OR	AL,AL
	JNZ	CPYLoop
	RESTORE <AX>
	return
EndProc StrCpy

;----------------------------------------------------------------------------
; Procedure Name : FStrCpy
;----------------------------------------------------------------------------

Procedure   FStrCpy,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<AX>
FCPYLoop:
	LODSB
	STOSB
	OR	AL,AL
	JNZ	FCPYLoop
	RESTORE <AX>
	return
EndProc FStrCpy

	Break <StrLen - compute length of string ES:DI>

;**	StrLen - Compute Length of String
;
;	StrLen computes the length of a string, including the trailing 00
;
;	ENTRY	(es:di) = address of string
;	EXIT	(cx) = size of string
;	USES	cx, flags

Procedure   StrLen,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	SAVE	<di, ax>
	MOV	CX,-1
	XOR	AL,AL
	REPNE	SCASB
	NOT	CX
	RESTORE <ax, di>
	return

EndProc StrLen


;**	DStrLen - Compute Length of String
;
;	ENTRY	(ds:si) = address of string
;	EXIT	(cx) = size of string, including trailing NUL
;	USES	cx, flags

Procedure   DStrLen,NEAR	; BUGBUG - this guy is a pig, who uses him?
	CALL	XCHGP
	CALL	StrLen
	CALL	XCHGP
	return
EndProc DStrLen


	Break	<XCHGP - exchange source and destination pointers>

;**	XCHGP - Exchange Pointers
;
;	XCHGP exchanges (DS:SI) and (ES:DI)
;
;	ENTRY	none
;	EXIT	pairs exchanged
;	USES	SI, DI, DS, ES

Procedure XCHGP,NEAR

	SAVE	<DS,ES>
	RESTORE	<DS,ES>
	XCHG	SI,DI
	return

EndProc XCHGP


Break	<Idle - wait for a specified amount of time>
;----------------------------------------------------------------------------
;
;   Idle - when retrying an operation due to a lock/sharing violation, we spin
;   until RetryLoop is exhausted.
;
;   Inputs:	RetryLoop is the number of times we spin
;   Outputs:	Wait
;   Registers modified: none
;----------------------------------------------------------------------------
Procedure   Idle,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; SS override
	cmp	fSharing,0
	retnz
	SAVE	<CX>

;hkn; SS override
	MOV	CX,RetryLoop
	JCXZ	Idle3
Idle1:	PUSH	CX
	XOR	CX,CX
Idle2:	LOOP	Idle2
	POP	CX
	LOOP	Idle1
Idle3:	RESTORE <CX>
	return
EndProc Idle

Break	<TableDispatch - dispatch to a table>
;----------------------------------------------------------------------------
;
;   TableDispatch - given a table and an index, jmp to the approptiate
;   routine.  Preserve all input registers to the routine.
;
;   Inputs:	Push	return address
;		Push	Table address
;		Push	index (byte)
;   Outputs:	appropriate routine gets jumped to.
;		return indicates invalid index
;   Registers modified: none.
;----------------------------------------------------------------------------
TableFrame  STRUC
OldBP	DW  ?
OldRet	DW  ?
Index	DB  ?
Pad	DB  ?
Tab	DW  ?
NewRet	DW  ?
TableFrame  ENDS

procedure   TableDispatch,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	PUSH	BP
	MOV	BP,SP
	PUSH	BX			; save BX
	MOV	BX,[BP.Tab]		; get pointer to table
	MOV	BL,CS:[BX]		; maximum index
	CMP	[BP.Index],BL		; table error?
	JAE	TableError		; yes
	MOV	BL,[BP.Index]		; get desired table index
	XOR	BH,BH			; convert to word
	SHL	BX,1			; convert to word pointer
	INC	BX			; point past first length byte
	ADD	BX,[BP.Tab]		; get real offset
	MOV	BX,CS:[BX]		; get contents of table entry
	MOV	[BP.Tab],BX		; put table entry into return address
	POP	BX			; restore BX
	POP	BP			; restore BP
	ADD	SP,4			; clean off Index and our return addr
	return				; do operation
TableError:
	POP	BX			; restore BX
	POP	BP			; restore BP
	RET	6			; clean off Index, Table and RetAddr
EndProc TableDispatch

Break	<TestNet - determine if a CDS is for the network>
;----------------------------------------------------------------------------
;
;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
;	network CDS.  This will handle NULL cds also.
;
;   Inputs:	ThisCDS points to CDS or NULL
;   Outputs:	ES:DI = ThisCDS
;		carry Set => network
;		carry Clear => local
;   Registers modified: none.
;----------------------------------------------------------------------------

Procedure   TestNet,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	getdseg	<es>			; es -> dosdata
	LES	DI,ThisCDS
	assume	es:NOTHING

	CMP	DI,-1
	JZ	CMCRet			; UNC? carry is clear
	TESTB	ES:[DI].curdir_flags,curdir_isnet
	JNZ	CMCret			; jump has carry clear
	return				; carry is clear
CMCRet: CMC
	return

EndProc TestNet

Break	<IsSFTNet - see if an sft is for the network>
;----------------------------------------------------------------------------
;
;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
;	network file.
;
;   Inputs:	ES:DI point to SFT
;   Outputs:	Zero set if not network sft
;		zero reset otherwise
;		Carry CLEAR!!!
;   Registers modified: none.
;----------------------------------------------------------------------------

Procedure   IsSFTNet,NEAR

	ASSUME	CS:DOSCODE,SS:NOTHING
	TESTB	ES:[DI].sf_flags,sf_isnet
	return

EndProc IsSFTNet

Break	<FastInit - Initialize FastTable entries >
;----------------------------------------------------------------------------
;   DOS 4.00   2/9/87
;   FastInit  - initialize the FASTXXX routine entry
;		  in the FastTable
;
;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
;		DS:SI = address of FASTXXX routine entry
;		   SI = -1 for query only
;   Outputs:	Carry flag clear, if success
;		Carry flag set,   if failure
;
;
;----------------------------------------------------------------------------

Procedure   FastInit,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

;hkn; set up es to dosdataseg.

	push	es
	getdseg	<es>			; es -> dosdata

;hkn; FastTable is in DOSDATA
	MOV	DI,OFFSET DOSDATA:FastTable + 2 ;AN000;FO. points to fastxxx entry
	DEC	BX				;AN000;FO.;; decrement index
	MOV	DX,BX				;AN000;FO.;; save bx
	SHL	BX,1				;AN000;FO.;; times 4 , each entry is DWORD
	SHL	BX,1				;AN000;FO.
	ADD	DI,BX				;AN000;FO. index to the entry
	MOV	AX,WORD PTR ES:[DI+2]		;AN000;FO. get entry segment
fcheck: 					;AN000;
	MOV	CX,CS				;AN000;FO.;; get DOS segment
	CMP	AX,CX				;AN000;FO.;; first time installed ?
	JZ	ok_install			;AN000;FO.;; yes
	OR	AX,AX				;AN000;FO.;
	JZ	ok_install			;AN000;FO.;
	STC					;AN000;FO.;; already installed !
	JMP	SHORT FSret			;AN000;FO. set carry
ok_install:					;AN000;
	CMP	SI,-1				;AN000;FO.; Query only ?
	JZ	FSret				;AN000;FO.; yes
	MOV	CX,DS				;AN000;FO.; get FASTXXX entry segment
	MOV	WORD PTR ES:[DI+2],CX		;AN000;FO.; initialize routine entry
	MOV	WORD PTR ES:[DI],SI		;AN000;FO.; initialize routine offset

;hkn; FastFlg moved to DOSDATA
	MOV	DI,OFFSET DOSDATA:FastFlg	;AN000;FO.; get addr of FASTXXX flags
	ADD	DI,DX				;AN000;FO.; index to a FASTXXX flag
	OR	byte ptr ES:[DI],Fast_yes	;AN000;FO.; indicate installed

FSret:						;AN000;
	pop	es
	return					;AN000;FO.
EndProc FastInit				;AN000;FO.

	Break	<FastRet - initial routine in FastOpenTable >

;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   FastRet	- indicate FASTXXXX  not in memory
;
;   Inputs:	None
;   Outputs:	AX = -1 and carry flag set
;
;   Registers modified: none.
;----------------------------------------------------------------------------

Procedure   FastRet,FAR
	STC
	sbb	ax,ax		; (ax) = -1, 'C' set
	RET
EndProc FastRet

Break	<NLS_OPEN - do $open for NLSFUNC   >
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   NLS_OPEN	- call $OPEN for NLSFUNC
;
;   Inputs:	Same input as $OPEN except CL = mode
;   Outputs:	same output as $OPEN
;
;----------------------------------------------------------------------------

;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!

Procedure   NLS_OPEN,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
;	MOV	[CPSWFLAG],0
;	PUSH	BX		 ; save current state

	MOV	AL,CL		 ; set up correct interface for $OPEN
	invoke	$OPEN

 ;	POP	BX		 ; restore current state
 ;	MOV	[CPSWFLAG],BL
	RET
EndProc NLS_OPEN

Break	<NLS_LSEEK - do $LSEEK for NLSFUNC   >
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   NLS_LSEEK	- call $LSEEK for NLSFUNC
;
;   Inputs:	BP = open mode
;   Outputs:	same output as $LSEEK
;
;----------------------------------------------------------------------------

Procedure   NLS_LSEEK,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	PUSH	ss:[user_SP]	 ; save user stack
	PUSH	ss:[user_SS]
	CALL	Fake_User_Stack
	MOV	AX,BP	     ; set up correct interface for $LSEEK
	invoke	$LSEEK
	POP	ss:[user_SS]	 ; restore user stack
	POP	ss:[user_SP]
	RET
EndProc NLS_LSEEK


Break	<Fake_User_Stack - save user stack >

;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   Fake_User_Stack - save user stack pointer
;
;----------------------------------------------------------------------------

Procedure   Fake_User_Stack,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	MOV	AX,ss:[User_SP_2F] 	      ; replace with INT 2F stack
	MOV	ss:[user_SP],AX

;hkn;	MOV	AX,CS

	mov	ax, ss
	MOV	ss:[user_SS],AX		      ; DOSGROUP

	RET
EndProc Fake_User_Stack

;
Break	<GetDevList - get device header list pointer>

;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   GetDevList - get device header list pointer
;
;   Output: AX:BX points to the device header list
;----------------------------------------------------------------------------

Procedure   GetDevList,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	MOV	SI,OFFSET DOSDATA:SysInitTable

;hkn; set up ds to point to DOSDATA
	getdseg	<ds>			; ds -> dosdata

	LDS	SI,[SI.SYSI_InitVars]

	MOV	AX,WORD PTR DS:[SI.SYSI_DEV]
	MOV	BX,WORD PTR DS:[SI.SYSI_DEV+2]

	RET
EndProc GetDevList

Break	<NLS_IOCTL - do $IOCTL for NLSFUNC   >
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   NLS_IOCTL	- call $IOCTL for NLSFUNC
;
;   Inputs:	BP = function code 0CH
;   Outputs:	same output as generic $IOCTL
;
;----------------------------------------------------------------------------

Procedure   NLS_IOCTL,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	PUSH	ss:[user_SP]	 ; save user stack
	PUSH	ss:[user_SS]
	CALL	Fake_User_Stack
	MOV	AX,BP	     ; set up correct interface for $LSEEK
	invoke	$IOCTL
	POP	ss:[user_SS]	 ; restore user stack
	POP	ss:[user_SP]
	RET
EndProc NLS_IOCTL

Break	<NLS_GETEXT- get extended error for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   NLS_GETEXT	-
;
;   Inputs:	none
;   Outputs:	AX = extended error
;
;----------------------------------------------------------------------------

Procedure   NLS_GETEXT,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	MOV	AX,SS:[EXTERR]	 ; return extended error
	RET

EndProc NLS_GETEXT

Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>
;----------------------------------------------------------------------------
;   DOS 4.00
;
;   Inputs:	DL=0 get extended error message addr
;		  =1 set extended error message addr
;		  =2 get parser error message addr
;		  =3 set parser error message addr
;		  =4 get critical error message addr
;		  =5 set critical error message addr
;		  =6 get file system error message addr
;		  =7 set file system error message addr
;		  =8 get address for code reduction
;		  =9 set address for code reduction
;   Function:	get/set message address
;   Outputs:	ES:DI points to addr when get
;----------------------------------------------------------------------------

Procedure   MSG_RETRIEVAL,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING


;;	NOTE:  This function lives in command.com resident code now.
;;	If the int 2F ever gets this far, we'll return registers
;;	unchanged, which produces the same result as before, if
;;	command.com wasn't present (and therefore no messages available).
;;
;;	I didn't point the entry in the 2F table to No_Op because
;;	No_Op zeroes AL.
;;
;;;hkn; set up ds to point to DOSDATA
;;	push	ds
;;	getdseg	<ds>			; ds -> dosdata
;;
;;	PUSH	AX		    ;AN000;;MS. save regs
;;	PUSH	SI		    ;AN000;;MS. save regs
;;	MOV	AX,DX		    ;AN000;;MS.
;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
;;	test	AL,1		    ;AN000;;MS. get ?
;;	JZ	toget		    ;AN000;;MS. yes
;;	DEC	AL		    ;AN000;;MS.
;;toget:				    ;AN000;
;;	SHL	AL,1		    ;AN000;;MS. times 2
;;	XOR	AH,AH		    ;AN000;;MS.
;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
;;	test	DL,1		    ;AN000;;MS. get ?
;;	JZ	getget			     ;AN000;;MS. yes
;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
;;getget: 				     ;AN000;
;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
;;MSGret: 				     ;AN000;
;;	POP	SI			     ;AN000;;MS.
;;	POP	AX			     ;AN000;;MS.
;;
;;	pop	ds
	return				     ;AN000;;MS. exit

EndProc MSG_RETRIEVAL			     ;AN000;


;***Break	<Fake_version - set/reset version flag>
;***;----------------------------------------------------------------------------
;***;
;***;   Inputs:	DL=0 current version number
;***;		  <>0  special version number
;***;   Function:	set special version number
;***;   Outputs:	version number is changed
;***;
;***;----------------------------------------------------------------------------
;***
;***Procedure   Fake_version,NEAR
;***	ASSUME	CS:DOSCODE,SS:NOTHING
;***
;***;hkn; set up ds to point to DOSDATA
;***	push	ds
;***	getdseg	<ds>			; ds -> dosdata
;***	MOV	[Special_version],DX   ;AN006;MS.
;***	pop	ds
;***	return			       ;AN006;;MS. exit
;***
;***EndProc Fake_version		       ;AN006;;MS.


DOSCODE	ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\msconst.asm ===
;**	MSCONST.ASM
;
;	Revision history
;	    AN000  version 4.00  Jan. 1988
;	    AN007  fake version check for IBMCACHE.COM
;
;	    M000   added save_ax, umb_head and start_arena for umb support
;		   7/9/90
;	    M003   added umbflag for link/unlink UMB support. 7/18/90
;	    M004   added PAS32_FLAG for MS PASCAL 3.2 comaptibility support
;	  	   7/30/90
;	    M014   added CL0FATENTRY. see pack/unpack in fat.asm for usage.
;		   8/28/90
;	    M044   bug #3869. Added WinoldPatch1, save area for the first
;		   8 0f 16 bytes to be saved.
;
;	    M063   added variable allocmsave for temporarily saving
;		   allocmethod in msproc.asm.
;
;	    M068   support for copy protected apps. Added ChkCopyProt,
;		   A20OFF_PSP and changed A20OFF_FLAG to A20OFF_COUNT
;

include mshead.asm

DOSCODE	SEGMENT
	Extrn	LeaveDOS:NEAR
	Extrn	BadCall:FAR, OKCall:FAR

	PUBLIC	BugTyp,BugLev
if DEBUG
	DB	"BUG "                  ; THIS FIELD MUST BE EVEN # OF BYTES
BugTyp	DW	TypSyscall
BugLev	DW	LevLog
else
BugTyp	label	word
BugLev	label	word
endif

include bugtyp.inc			; put this after BUGTYP definition

DOSCODE	ENDS

Break <Initialized data and data used at DOS initialization>

;
; We need to identify the parts of the data area that are relevant to tasks
; and those that are relevant to the system as a whole.  Under 3.0, the system
; data will be gathered with the system code.  The process data under 2.x will
; be available for swapping and under 3.0 it will be allocated per-process.
;
; The data that is system data will be identified by [SYSTEM] in the comments
; describing that data item.
;

	AsmVars <Debug, Redirector, ShareF>

DOSDATA	SEGMENT

	ORG	0

;hkn; add 4 bytes to get correct offsets since jmp has been removed in START

	db	4 dup (?)	

	EVEN
;
; WANGO!!!  The following word is used by SHARE and REDIR to determin data
; area compatability.  This location must be incremented EACH TIME the data
; area here gets mucked with.
;
; Also, do NOT change this position relative to DOSDATA:0.
;
Public MSCT001S,MSCT001E
MSCT001S	LABEL 	BYTE
	I_am	DataVersion,WORD,<1>	;AC000; [SYSTEM] version number for DOS DATA

;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has
;hkn; been removed to DOSCODE above

;M044
; First part of save area for saving last para of Window memory
;
public WinoldPatch1
WinoldPatch1	db	8 dup (?)		;M044

	I_am	MYNUM,WORD,<0>		; [SYSTEM] A number that goes with MYNAME
	I_am	FCBLRU,WORD,<0> 	; [SYSTEM] LRU count for FCB cache
	I_am	OpenLRU,WORD,<0>	; [SYSTEM] LRU count for FCB cache opens
; NOTE: We include the decl of OEM_HANDLER in IBM DOS even though it is not used.
;	This allows the REDIRector to work on either IBM or MS-DOS.
	PUBLIC	OEM_HANDLER
OEM_HANDLER	DD	-1		; [SYSTEM] Pointer to OEM handler code
;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
;;			way that we leave DOS???? - jgl
	I_am	LeaveAddr,WORD,<<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
	I_am	RetryCount,WORD,<3>	; [SYSTEM] Share retries
	I_am	RetryLoop,WORD,<1>	; [SYSTEM] Share retries
	I_am	LastBuffer,DWORD,<-1,-1>; [SYSTEM] Buffer queue recency pointer
	I_am	CONTPOS,WORD		; [SYSTEM] location in buffer of next read
	I_am	arena_head,WORD 	; [SYSTEM] Segment # of first arena in memory
; The following block of data is used by SYSINIT.  Do not change the order or
; size of this block
	PUBLIC	SYSINITVAR		; [SYSTEM]
SYSINITVAR  LABEL   WORD		; [SYSTEM]
	I_am	DPBHEAD,DWORD		; [SYSTEM] Pointer to head of DPB-FAT list
	I_am	sft_addr,DWORD,<<OFFSET DOSDATA:sfTabl>,?> ; [SYSTEM] Pointer to first SFT table
	I_am	BCLOCK,DWORD		; [SYSTEM] The CLOCK device
	I_am	BCON,DWORD		; [SYSTEM] Console device entry points
	I_am	MAXSEC,WORD,<128>	; [SYSTEM] Maximum allowed sector size
	I_am	BUFFHEAD,DWORD		; [SYSTEM] Pointer to head of buffer queue
	I_am	CDSADDR,DWORD		; [SYSTEM] Pointer to curdir structure table
	I_am	sftFCB,DWORD		; [SYSTEM] pointer to FCB cache table
	I_am	KeepCount,WORD		; [SYSTEM] count of FCB opens to keep
	I_am	NUMIO,BYTE		; [SYSTEM] Number of disk tables
	I_am	CDSCOUNT,BYTE		; [SYSTEM] Number of CDS structures in above
; A fake header for the NUL device
	I_am	NULDEV,DWORD		; [SYSTEM] Link to rest of device list
	DW	DEVTYP OR ISNULL	; [SYSTEM] Null device attributes
	dw	offset dosdata:SNULDEV	; [SYSTEM] Strategy entry point
	dw	offset dosdata:INULDEV	; [SYSTEM] Interrupt entry point
	DB	"NUL     "              ; [SYSTEM] Name of null device
	I_am	Splices,BYTE,<0>	; [SYSTEM] TRUE => splices being done
	I_am	Special_Entries,WORD,<0>; [SYSTEM] address of specail entries	;AN000;
	I_am	UU_IFS_DOS_CALL,DWORD	; [SYSTEM] entry for IFS DOS service	;AN000;

;***	I_am	UU_IFS_HEADER,DWORD	; [SYSTEM] IFS header chain		;AN000;

	I_am	ChkCopyProt, WORD	; M068
	I_am	A20OFF_PSP, WORD	; M068

	I_am	BUFFERS_PARM1,WORD,<0>	; [SYSTEM] value of BUFFERS= ,m 	;AN000;
	I_am	BUFFERS_PARM2,WORD,<0>	; [SYSTEM] value of BUFFERS= ,n 	;AN000;
	I_am	BOOTDRIVE,BYTE		; [SYSTEM] the boot drive		;AN000;
	I_am	DDMOVE,BYTE,<0> 	; [SYSTEM] 1 if we need DWORD move	;AN000;
	I_am	EXT_MEM_SIZE,WORD,<0>	; [SYSTEM] extended memory size 	;AN000;

	PUBLIC	HASHINITVAR		; [SYSTEM]				;AN000;
HASHINITVAR  LABEL   WORD		; [SYSTEM]				;AN000;
;
; Replaced by next two declarations
;
;	I_am	UU_BUF_HASH_PTR,DWORD		; [SYSTEM] buffer Hash table
						;          addr
;	I_am	UU_BUF_HASH_COUNT,WORD,<1> 	; [SYSTEM] number of Hash
						;          entries

	I_am	BufferQueue,DWORD		; [SYSTEM] Head of the buffer
						;  	   Queue
	I_am	DirtyBufferCount,WORD,<0> 	; [SYSTEM] Count of Dirty
						;          buffers in the Que
						; BUGBUG ---- change to byte

	I_am	SC_CACHE_PTR,DWORD		; [SYSTEM] secondary cache
						;	   pointer
	I_am	SC_CACHE_COUNT,WORD,<0> 	; [SYSTEM] secondary cache
						;	   count
	I_am	BuffInHMA,byte,<0>		; Flag to indicate that buffs
						;  are in HMA
	I_am	LoMemBuff,dword			; Ptr to intermediate buffer
						;  in Low mem when buffs
						;  are in HMA

;
; All variables which have UU_ as prefix can be reused for other
; purposes and can be renamed. All these variables were used for
; EMS support of Buffer Manager. Now they are useless for Buffer
; manager ---- MOHANS
;

	I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>
						; holds the first page above
						; 640K
;**	I_am	UU_BUF_EMS_NPA640,WORD,<0>	; holds the number of pages
						; above 640K		

	I_am	CL0FATENTRY, WORD,<-1>		; M014:	Holds the data that
						; is used in pack/unpack rts.
						; in fat.asm if cluster 0
						; is specified.

						; SR;
	I_am	IoStatFail,BYTE,<0>		; IoStatFail has been added to
						; record a fail on an I24
						; issued from IOFUNC on a
						; status call.

;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; [SYSTEM] EMS mode			;AN000;
;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; [SYSTEM] buffer EMS handle		;AN000;
;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; [SYSTEM] EMS page frame #	;AN000;
;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; [SYSTEM] EMS seg count		;AN000;
;***	I_am	UU_BUF_EMS_PFRAME,WORD		; [SYSTEM] EMS page frame seg address	;AN000;
;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; [SYSTEM] reserved			;AN000;

;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the
						; state of the 	buffers page.
						; This one byte is retained to
						; keep the size of this data
						; block the same.

	I_am	ALLOCMSAVE,BYTE,<0>		; M063: temp var. used to
						; M063: save alloc method in
						; M063: msproc.asm

	I_am	A20OFF_COUNT,BYTE,<0>		; M068: indiactes the # of
						; M068: int 21 calls for
						; M068: which A20 is off
						

	I_am 	DOS_FLAG,BYTE,<0>		; see DOSSYM.INC for Bit
						; definitions

	I_am	UNPACK_OFFSET,WORD,<0>		; saves pointer to the start
						; of unpack code in exepatch.
						; asm.

	I_am	UMBFLAG,BYTE,<0> 		; M003: bit 0 indicates the
						; M003: link state of the UMBs
						; M003: whether linked or not
						; M003: to the DOS arena chain


	I_am	SAVE_AX,WORD,<0>		; M000: temp varibale to store ax
						; M000: in msproc.asm

	I_am	UMB_HEAD,WORD,<-1>		; M000: this is initialized to
						; M000: the first umb arena by
						; M000: BIOS sysinit.

	I_am	START_ARENA,WORD,<1>		; M000: this is the first arena
						; M000: from which DOS will
						; M000: start its scan for alloc.

        .errnz  ($ - SYSINITVAR) - 6ah  ; kernel31 depends on this
        dw      OFFSET DOSDATA:DosWowDataStart

; End of SYSINITVar block

;
; Sharer jump table
;
PUBLIC	JShare
	EVEN
JShare	LABEL	DWORD
	DW	OFFSET DOSCODE:BadCall, 0
	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU

MSCT001E	LABEL	BYTE
DOSDATA	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\msdata.asm ===
;
; DATA Segment for DOS.
;

.xlist
.xcref
include version.inc
include mssw.asm
include dosseg.inc
include dossym.inc
INCLUDE sf.inc
INCLUDE curdir.inc
INCLUDE arena.inc
INCLUDE vector.inc
INCLUDE devsym.inc
INCLUDE pdb.inc
INCLUDE find.inc
INCLUDE mi.inc
include doscntry.inc
include fastopen.inc
include xmm.inc
.cref
.list

TITLE   IBMDATA - DATA segment for DOS
NAME    IBMDATA

installed = TRUE

include vint.inc
include msbdata.inc
include msconst.asm	; This includes mshead.asm whihc has DOS entry point
include const2.asm
include ms_data.asm
include dostab.asm
include lmstub.asm
include	wpatch.inc	; BUGBUG sudeepb 06-Mar-1991 Do we need this?
include bop.inc

	END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\msdisp.asm ===
PAGE ,132
; ==========================================================================
;
;	TITLE	MS DOS DISPATCHER - System call dispatch code
;	NAME	DISP
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;	System call dispatch code
;	System call entry points and dispatcher
;
; Revision History:
; Sudeepb 14-Mar-1991 Ported for NT DOSEm


.XLIST
.XCREF

INCLUDE version.inc
INCLUDE mssw.asm
INCLUDE dossym.inc
INCLUDE	devsym.inc			; M042
INCLUDE dosseg.inc
INCLUDE pdb.inc
INCLUDE vector.inc
INCLUDE syscall.inc
INCLUDE mi.inc
INCLUDE bugtyp.inc

include dossvc.inc
include bop.inc
include vint.inc
include dbgsvc.inc

.CREF
.LIST


AsmVars <Debug>

; ==========================================================================
; ==========================================================================

DosData SEGMENT

	EXTRN	AuxStack	:BYTE
	EXTRN	BootDrive	:BYTE
	EXTRN	ConSwap 	:BYTE
	EXTRN	CntCFlag	:BYTE
	EXTRN	CpswFlag	:BYTE
	EXTRN	CpswSave	:BYTE

;**RMFHFE**	EXTRN	Disk_Full	:BYTE

	EXTRN	DskStack	:BYTE
	EXTRN	ErrorMode	:BYTE
	EXTRN	ExtOpen_On	:BYTE
	EXTRN	Exterr_Locus	:BYTE
	EXTRN	FailErr 	:BYTE
	EXTRN	fSharing	:BYTE
	EXTRN	IdleInt 	:BYTE
	EXTRN	InDos		:BYTE
	EXTRN	IoStack 	:BYTE
	EXTRN	InterCon	:BYTE
	EXTRN	IsWin386	:BYTE
	EXTRN	NoSetDir	:BYTE
	EXTRN	Printer_Flag	:BYTE
	EXTRN	WpErr		:BYTE

	EXTRN	CurrentPDB	:WORD

	EXTRN	Dispatch	:WORD

	EXTRN	Dos34_Flag	:WORD
	EXTRN	Nsp		:WORD
	EXTRN	Nss		:WORD
	EXTRN	Proc_ID 	:WORD
	EXTRN	Restore_Tmp	:WORD
	EXTRN	SaveDS		:WORD
	EXTRN	SaveBX		:WORD
	EXTRN	User_In_AX	:WORD
	EXTRN	User_ID 	:WORD
	EXTRN	User_SP 	:WORD
	EXTRN	User_SS 	:WORD

	EXTRN	disa20_iret	:WORD
	EXTRN	A20OFF_COUNT	:BYTE		; M004
	extrn	DosHasHMA	:byte		; M021
	EXTRN	DOS_FLAG	:byte		; M068
	EXTRN	A20OFF_PSP	:word		; M068
ifdef NTVDMDBG
	EXTRN	SCS_ISDEBUG	:byte
endif

IF	NOT IBM
EXTRN	OEM_HANDLER:DWORD
ENDIF

DosData ENDS

; ==========================================================================
; ==========================================================================


; ==========================================================================
; ==========================================================================

DosCode SEGMENT

	allow_getdseg

	EXTRN	MaxCall 	:ABS
	EXTRN	MaxCom		:ABS

IF      DEBUG
	INCLUDE scnam.inc
ENDIF

	ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

;M007 - New version of this routine
; ==========================================================================
;
; $Set_CTRL_C_Trapping
;
; Function:
;	Enable disable ^C checking in dispatcher
;
; Inputs:
;		AL = 0 read ^C status
;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
;		AL = 2 Set ^C status to contents of DL.	Output is old state.
;		AL = 5 get DOS boot drive
;		AL = 6 Get version number
;			RETURNS:
;				BH = Minor version number
;				BL = Major version number
;				DL = DOS internal revision
;				DH = DOS type flags
;					Bit 3 	- DOS in ROM
;					Bit 4 	- DOS in HMA
;					Bit 0-2, 5-7 - Reserved
; Outputs:
;		If AL = 0 then DL = 0/1 for ^C off/on
;
; History:
;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
; ==========================================================================
	PUBLIC $Set_Ctrl_C_Trapping
$Set_Ctrl_C_Trapping PROC NEAR
	ASSUME	SS:NOTHING

	cmp	AL, 6			; Is this a valid subfunction?
	jbe	scct_1			; If yes continue processing

	mov	AL, 0ffh		; Else set AL to -1 and

        jmp     iret_com

scct_1:
	push	DS

	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	
	push	AX			; DL only register that can change
	push	SI

	mov	SI, OFFSET CntCFlag	; DS:SI --> Ctrl C Status byte
	xor	AH, AH			; Clear high byte of AX
	or	AX, AX			; Check for subfunction 0
	jnz	scct_2			; If not 0 jmp to next check

	mov	DL, [SI]		; Else move current ctrl C status
	jmp	SHORT scct_9s		; into DL and jmp to exit

scct_2:
	dec	AX			; Now dec AX and see if it was 1
	jnz	scct_3			; If not 0 it wasn't 1 so do next chk

	and	DL, 1			; Else mask off bit 0 of DL and
	mov	[SI], DL		; save it as new Ctrl C status
	jmp	SHORT scct_9s		; Jmp to exit

scct_3:
	dec	AX			; Dec AX again to see if it was 2
	jnz	scct_4			; If not 0 wasn't 2 so go to next chk

	and	DL, 1			; Else mask off bit 0 of DL and
	xchg	[SI], DL		; Exchange DL with old status byte
	jmp	SHORT scct_9s		; Jump to exit (returning old status)

scct_4:
	cmp	AX,3 			; Test for 5 after it was dec twice
	jne	scct_5			; If not equal then not get boot drv
	mov	DL, BootDrive		; Else return boot drive in DL
	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)

scct_5:
	cmp	AX,4 			; Test for 6 after it was dec twice
	jne	scct_9s			; If not equal then not get version
	
	mov	BX,(Minor_Version_NT SHL 8) + Major_Version
	mov	DL, DOSREVNM

	xor	dh, dh			; assume vanilla DOS
	cmp	[DosHasHMA], 0		; is DOS in HMA?  (M021)
	je	@F
	or	DH, DOSINHMA
@@:

ifdef ROMDOS
	or	DH, DOSINROM
endif ; ROMDOS

scct_9s:
	pop	SI
	pop	AX
	pop	DS

scct_9f:
        jmp     iret_com

;M007 end

SetCtrlShortEntry:			; This allows a conditional entry
					; from main dispatch code
	jmp	SHORT $Set_Ctrl_C_Trapping

$Set_Ctrl_C_Trapping ENDP

; ==========================================================================
;									   ;
; The following two routines are dispatched to directly with ints disabled
; immediately after the int 21h entry.	no DIS state is set.
;
; $Set_current_PDB takes BX and sets it to be the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
; ==========================================================================

	PUBLIC	$Set_Current_PDB
$Set_Current_PDB PROC NEAR
	ASSUME	SS:NOTHING

	push	DS
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	CurrentPDB,BX		; Set new PSP segment from caller's BX
	pop	DS
        jmp     iret_com

EndProc $Set_Current_PDB

; ==========================================================================
;
; $get_current_PDB returns in BX the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
; ==========================================================================

	PUBLIC $Get_Current_PDB
$Get_Current_PDB PROC NEAR
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	push	DS
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	BX,CurrentPDB		; Return current PSP segment in BX
	pop	DS
        jmp     iret_com

$Get_Current_PDB ENDP

; ==========================================================================
;
; Sets the Printer Flag to whatever is in AL.
; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
;
; ==========================================================================

	PUBLIC $Set_Printer_Flag
$Set_Printer_Flag PROC NEAR
	ASSUME	SS:NOTHING

	push	ds
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	Printer_Flag,AL 	; Set printer flag from caller's AL
	pop	ds
        jmp     iret_com

$Set_Printer_Flag ENDP

; ==========================================================================
;
; The Quit entry point is where all INT 20h's come from.  These are old- style
; exit system calls.  The CS of the caller indicates which Process is dying.
; The error code is presumed to be 0.  We simulate an ABORT system call.
;
; ==========================================================================

	PUBLIC	System_Call
System_Call PROC NEAR

	PUBLIC Quit
Quit:						; entry	QUIT
	xor	AH,AH
	jmp	SHORT SavRegs

	; The system call in AH is out of the range that we know how
	; to handle. We arbitrarily set the contents of AL to 0 and
	; IRET. Note that we CANNOT set the carry flag to indicate an
	; error as this may break some programs compatability.

BadCall:
	xor	AL,AL

	PUBLIC Irett
Irett:
        jmp     iret_com
ifdef NEC_98
        ; NEC NT Final 93/12/11 M.ANZAI
	PUBLIC Irett2
Irett2:
	iret
endif   ;NEC_98

	; An alternative method of entering the system is to perform a
	; CALL 5 in the program segment prefix with the contents of CL
	; indicating what system call the user would like. A subset of
	; the possible system calls is allowed here only the
	; CPM-compatible calls may get dispatched.


	PUBLIC Call_Entry		; entry   Call_Entry
Call_Entry:				; System call entry point and dispatcher
	push	DS
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	pop	SaveDs			; Save original DS

	pop	AX			; IP from the long call at 5
	pop	AX			; Segment from the long call at 5
	pop	User_SP 		; IP from the CALL 5

					; Re-order the stack to simulate an
					; interrupt 21.
	pushf				; Start re-ordering the stack
        invoke  DOCLI
	push	AX			; Save segment
	push	User_SP 		; Stack now ordered as if INT used

	push	SaveDS
	pop	DS

	ASSUME	DS:NOTHING

	cmp	CL,MaxCall		; Max old style CPM call number

	ja	BadCall 		

	mov	AH,CL
	jmp	SHORT SavRegs

	; This is the normal INT 21 entry point. We first perform a
	; quick test to see if we need to perform expensive DOS-entry
	; functions. Certain system calls are done without interrupts
	; being enabled.


	entry	COMMAND 		; Interrupt call entry point (int 21h)

ifdef NEC_98
	DB	90H,90h,90h
	JMP @F
JMP_RTN0:
	JMP	SetCtrlShortEntry
JMP_RTN1:
	JMP	$Set_Printer_Flag	; If equal jmp directly to function
JMP_RTN2:
	JMP	$Get_Current_PDB	; Yes, jmp directly to function
JMP_RTN3:
	JMP	$Set_Current_PDB	; Yes, jmp directly to function
@@:
endif   ;NEC_98
IF	NOT IBM

	cmp	AH,SET_OEM_HANDLER
	jb	@F

	jmp	$Set_Oem_Handler

@@:

ENDIF
        invoke  DOCLI

	cmp	AH,MaxCom		; Max int 21h function call number
	ja	BadCall

	; The following set of calls are issued by the server at
	; *arbitrary* times and, therefore, must be executed on
	; the user's entry stack and executed with interrupts off.

SAVREGS:

ifdef NTVDMDBG
        ; *spagetti*
        ; WE want to send register info to ntdvm right here
        ; but can't do it here 'cause jmps in this block
        ; become out of range

        jmp short DOSDispCall1
DOSDispCall0:
endif

        cmp     AH,SET_CTRL_C_TRAPPING  ; Check Minimum special case #
        jb	     SaveAllRegs		; Not special case so continue
ifndef NEC_98
        jnz     sch01
        jmp     SetCtrlShortEntry
sch01:
	cmp	AH,SET_PRINTER_FLAG	; Check Max case number
	ja	SaveAllRegs		; Not special case so continue
	jz	$Set_Printer_Flag	; If equal jmp directly to function
	cmp	AH,GET_CURRENT_PDB	; Is this a Get PSP call (51h)?
            jnz     gcp01                   ; Yes, jmp directly to function
            jmp     $Get_Current_PDB        ; Yes, jmp directly to function
gcp01:
	cmp	AH,GETCURRENTPSP	; Is this a Get PSP call (62h)?
	jnz	ddc0			; Yes, jmp directly to function
	jmp	$GET_CURRENT_PDB	; Yes, jmp directly to function
ddc0:
	cmp	AH,SET_CURRENT_PDB	; Is this a Set PSP call (50h) ?
	jnz	cmndI			; Yes, jmp directly to function
	jmp	$Set_Current_PDB	; Yes, jmp directly to function
cmndI:

else    ;NEC_98
;            jz      SetCtrlShortEntry
	jz	JMP_RTN0
	cmp	AH,SET_PRINTER_FLAG	; Check Max case number
	ja	SaveAllRegs		; Not special case so continue
;            jz      $Set_Printer_Flag       ; If equal jmp directly to function
	jz	JMP_RTN1
	cmp	AH,GET_CURRENT_PDB	; Is this a Get PSP call (51h)?
;	jz	$Get_Current_PDB	; Yes, jmp directly to function
	jz	JMP_RTN2
	cmp	AH,GETCURRENTPSP	; Is this a Get PSP call (62h)?
;	jz	$GET_CURRENT_PDB	; Yes, jmp directly to function
	jz	JMP_RTN2
	cmp	AH,SET_CURRENT_PDB	; Is this a Set PSP call (50h) ?
ifndef ROMDOS
;	jz	$Set_Current_PDB	; Yes, jmp directly to function
	jz	JMP_RTN3
else
	; jump out of range by *two* bytes!
	jnz	@f
;	jmp	$Set_Current_PDB
	JMP	JMP_RTN3
@@:
endif

endif   ;NEC_98



ifdef NTVDMDBG
        ; put scnam[ah] on the 16 bit stack for demDOSDispCall
        jmp SaveAllRegs

DOSDispCall1:
	push	ds
	getdseg <DS>
        test    [SCS_ISDEBUG],ISDBG_SHOWSVC ;special trace flag on?
	pop	ds
	je	DOSDispCall0
        SVC     SVC_DEMDOSDISPCALL
        jmp     short DOSDispCall0
endif



SaveAllRegs:
        push    ES
	push	DS
	push	BP
	push	DI
	push	SI
	push	DX
	push	CX
	push	BX
        push    AX


	mov	AX,DS
	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	SaveDS, AX		; save caller's DS
	mov	SaveBX,BX


	; M043
	; Note: Nsp and Nss have to be unconditionally initialized here
	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
	; this!!!
	;

	mov	AX,User_SP		; Provide one level of reentrancy for
	mov	Nsp,AX			; int 24 recallability.
	mov	AX,User_SS
	mov	Nss,AX

	xor	AX,AX
	mov	fSharing,AL		; allow redirection

	test	IsWIN386,1		; WIN386 patch. Do not update USER_ID
	jnz	@F			; if win386 present
	mov	User_Id,AX
@@:
	inc	InDos			; Flag that we're in the DOS

	mov	User_SP,SP		; Save user's stack
	mov	User_SS,SS

	mov	AX,CurrentPDB
	mov	Proc_Id,AX
	mov	DS,AX
	pop	AX
	push	AX

	ASSUME	DS:NOTHING
	mov	WORD PTR DS:PDB_User_stack,SP	; for later returns (possibly
	mov	WORD PTR DS:PDB_User_stack+2,SS ; from EXEC)

	getdseg	<ss>			; ss -> dosdat,  already flag is CLI

	PUBLIC	Redisp
Redisp: 				; Entry REDISP

	mov	SP,OFFSET DosData:AuxStack ; Enough stack for interrupts
        invoke  DOSTI                      ; stack is in our space now...


	IFDEF  DBCS				
		mov	BH, BYTE PTR DS:PDB_InterCon	; Get interim mode
		mov	SS:InterCon, BH        		
	ENDIF

	mov	BX,SS
	mov	DS,BX

	xchg	BX,AX

	xor	AX,AX

;**RMFHFE**	mov	Disk_Full,AL		; No disk full

	mov	ExtOpen_On,AL		; Clear extended open flag

;;	mov	Dos34_Flag,AX		; Clear common flag
	and	DOS34_Flag, EXEC_AWARE_REDIR
					; M042: clear all bits except bit 11

	mov	ConSwap,AL		; random clean up of possibly mis-set flags
	mov	BYTE PTR NoSetDir,AL	; set directories on search
	mov	BYTE PTR FailErr,AL	; FAIL not in progress

	inc	AX 			; AL = 1
	mov	IdleInt,AL		; presume that we can issue INT 28

	xchg	AX,BX			; Restore AX and BX = 1

	mov	BL,AH
	shl	BX,1			; 2 bytes per call in table

	cld
		; Since the DOS maintains mucho state information across system
		; calls, we must be very careful about which stack we use.
		; First, all abort operations must be on the disk stack. This
		; is due to the fact that we may be hitting the disk (close
		; operations, flushing) and may need to report an INT 24.

	or	AH,AH
	jz	DskROut 		; ABORT

		; Second, PRINT and PSPRINT and the server issue
		; GetExtendedError calls at INT 28 and INT 24 time.
		; This call MUST, therefore, use the AUXSTACK.

	cmp	AH,GetExtendedError
	jz	DISPCALL

		; Old 1-12 system calls may be either on the IOSTACK (normal
		; operation) or on the AUXSTACK (at INT 24 time).

	cmp	AH,12
	ja	DskROut
	cmp	ErrorMode,0		; Are we in an INT 24?
	jnz	DispCall		; Stay on AUXSTACK if INT 24.
	mov	SP,OFFSET DosData:IoStack
	jmp	SHORT DispCall

		; We are on a system call that is classified as "the rest".
		; We place ourselves onto the DSKSTACK and away we go.	We
		; know at this point:
		;
		; o  An INT 24 cannot be in progress.  Therefore we reset
		;    ErrorMode and WpErr
		; o  That there can be no critical sections in effect. We
		;    signal the server to remove all the resources.

DskROut:
	mov	User_In_AX,AX		; Remember what user is doing
	mov	ExtErr_Locus,ErrLoc_Unk ; Default
	mov	ErrorMode,0		; Cannot make non 1-12 calls in
	mov	WpErr,-1		; error mode, so good place to make


; NTVDM - we don't do any critical section stuff
; 04-Aug-1992 Jonle
;
;        push    AX                      ; Release all resource information
;        mov     AH,82h
;        int     Int_IBM
;        pop     AX
;

		; Since we are going to be running on the DSKStack and since
		; INT 28 people will use the DSKStack, we must turn OFF the
		; generation of INT 28's.

	mov	IdleInt,0
	mov	SP,OFFSET DosData:DskStack
	test	CntCFlag,-1
	jz	DispCall		; Extra ^C checking is disabled
	push	AX
	invoke	DskStatChk
	pop	AX

DispCall:
	mov	BX,CS:Dispatch[BX]
	xchg	BX,SaveBX
	mov	DS,SaveDS

    ASSUME  DS:NOTHING

	if	DEBUG
		call	PrintCall		; debug print system call
	endif

	call	SS:SaveBX

	;
	; M068
	;
	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
	; here. Please see under M003, M009 and M068 tags in dossym.inc
	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
	; return to LeaveDos and hence will not clear this bit. This is
	; because this bit is used to indicate to the next int 21 call that
	; the previous int 21 was an exec.
	;
	; So do not add any code between the call above and the label
	; LeaveDOS if it needs to be executed even for ax=4b05
	;

	and	[DOS_FLAG], NOT EXECA20OFF


	PUBLIC	LeaveDos		; Exit from a system call.
LeaveDos:

	ASSUME	SS:NOTHING		; User routines may misbehave
        invoke  DOCLI

	if	DEBUG
		call	PrintRet
	endif

	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg

					; M004, M068
  	cmp	[A20OFF_COUNT], 0	; M068: Q: is count 0
        je      la2                     ; M068: N: dec count and turn a20 off
        jmp     disa20                  ; M068: N: dec count and turn a20 off
la2:

LeaveA20On:
	dec	InDos
	mov	SS,User_SS
	mov	SP,User_SP
	mov	BP,SP
	mov	BYTE PTR [BP.User_AX],AL
	mov	AX,Nsp
	mov	User_SP,AX
	mov	AX,Nss
	mov	User_SS,AX

	pop	AX
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS
        pop     ES

ifdef NTVDMDBG
	push	ds
	getdseg <DS>
        test    [SCS_ISDEBUG],ISDBG_SHOWSVC ;special trace flag on?
	pop	ds
	je	no_dbg_msg
	SVC	SVC_DEMDOSDISPRET
no_dbg_msg:
endif
iret_com:
        transfer  DOIRET

disa20:	   				; M068 - Start
	mov	bx, [A20OFF_PSP]	; bx = PSP for which a20 to be off'd
	cmp	bx, [CurrentPDB]	; Q: do the PSP's match
        je      la3                     ; N: don't clear bit and don't turn
        jmp     LeaveA20On              ; N: don't clear bit and don't turn
la3:
					;    a20 off
					; Y: turn a20 off and dec a20off_count
	dec	[A20OFF_COUNT]		; M068 - End

					; Start - M004
	push	ds			; segment of stub
	mov	bx, offset disa20_iret	; offset in stub
	push	bx
	retf	  			; go to stub
					; End - M004

	

System_Call ENDP

; ==========================================================================
;
; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
; the stack prior to giving the user control
;
; ==========================================================================

procedure Restore_User_World,NEAR
	ASSUME	SS:NOTHING

	getdseg	<es>			; es -> dosdata

	pop	restore_tmp
	pop	AX
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS

	jmp	Restore_Tmp

EndProc restore_User_world

; ==========================================================================
;
; Save_World saves complete registers on the stack
;
; ==========================================================================

procedure Save_User_World ,NEAR
	ASSUME	SS:NOTHING

	getdseg	<es>			; es -> dosdata

	pop	restore_tmp

	push	DS
	push	BP
	push	DI
	push	SI
	push	DX
	push	CX
	push	BX
	push	AX

	push	restore_tmp

;	cli				; M045 - start
;	xchg	BP, SP
;	mov	ES, [BP+18]
;	assume	ES:NOTHING
;	xchg	SP,BP
;	sti

	push	BP		
	mov	BP, SP
	mov	ES, [BP+20]		; es was pushed before call
	assume	ES:NOTHING
	pop	BP			; M045 - end

	ret

EndProc save_user_world

; ==========================================================================
;
; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
;
; ==========================================================================

procedure Get_User_Stack,NEAR

	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	lds	SI,DWORD PTR User_SP
	return

EndProc Get_User_Stack

; ==========================================================================
;
; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
; Inputs:
;	User registers, User Stack, INTS disabled
;	If CALL F8, DS:DX is new handler address
; Function:
;	Process OEM INT 21 extensions
; Outputs:
;	Jumps to OEM_HANDLER if appropriate
;
; ==========================================================================
IF	NOT IBM

$Set_Oem_Handler:
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING


	push	es
	getdseg	<es>			; es -> dosdata

	jne	Do_Oem_Func		; If above F8 try to jump to handler
	mov	WORD PTR Oem_Handler,DX ; Set Handler
	mov	WORD PTR Oem_Handler+2,DS

	pop	ES
        jmp     iret_com                ; Quick return, Have altered no registers


DO_OEM_FUNC:
	cmp	WORD PTR Oem_Handler,-1
	jnz	Oem_Jmp

	pop	ES
	jmp	BadCall 		; Handler not initialized

OEM_JMP:
ifndef NEC_98
	push	ES
	pop	DS
	pop	ES

	ASSUME	DS:DosData

	jmp	Oem_Handler

else    ;NEC_98
;----- NEC NT DOS5.0A 93/04/23 -----
	extrn	JMP_Oem_Handler:far

	push	ax
	push	es
	mov	ax,offset DosData:JMP_Oem_Handler
	push	ax
	retf				; jmp back to data segment (emsmnt.asm)
endif   ;NEC_98
ENDIF



; ==========================================================================
;
;	PrintCall - Debug Printout of System Call
;
;	If system call printout is turned on, print
;
;	S:<name> ax bx cx dx si di bp ds es
;
;	ENTRY	registers as from user program
;	EXIT	none
;	USES	flags
;
; ==========================================================================

IF DEBUG

	ASSUME	DS:nothing,ES:nothing,SS:DOSDATA
	DPUBLIC PrintCall
PrintCall PROC	Near

	test	BugTyp,TypSyscall
	retz
					; Going to print it out.
					; Lookup the name string
	SAVE	<BX>
	sub	BX,BX
	mov	BL,AH
	add	BX,BX
	mov	BX,scptrs[BX]		; (cs:bx) = address of name string
	FMT	TypSyscall, LevLog, <"S:$S">,<cs, bx>
	RESTORE <BX>
	FMT	TypSyscall, LevLog, <"  a-d=$x $x $x $x">,<AX,BX,CX,DX>
	FMT	TypSyscall, LevLog, <" sd=$x $x de=$x $x\n">,<si,di,ds,es>
prcalx: ret

PrintCall ENDP

; ==========================================================================
;
;	PrintRet - Debug Printout of System Call Return
;
;	If system call printout is turned on, print
;
;	"  OK: ax bx cx dx si di"   -or-
;	"  ERROR:  ax bx cx dx si di"
;
;	ENTRY	registers as from user program
;	EXIT	none
;	USES	none
; ==========================================================================

	DPUBLIC PrintRet

	ASSUME	DS:nothing,ES:nothing,SS:nothing
PrintRet PROC	NEAR
	pushf

	getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg

	test	BugTyp,TypSyscall
	LJZ	pretx

	SAVE	<ds, si>		; Am to print return code
	call	Get_User_Stack

	ASSUME DS:nothing

	test	[SI.user_F],f_Carry	; signal carry to user
	jnz	pret2			; have error
	FMT	TypSyscall, LevLog, <"  OK: ">
	jmp	SHORT Pret4

Pret2:	FMT	TypSyscall, LevLog, <"  ERROR: ">

Pret4:	FMT	TypSyscall, LevLog, <" $x $x $x">,<User_AX[si],User_BX[si],User_CX[si]>
	FMT	TypSyscall, LevLog, <" $x $x $x\n">,<User_DX[si],User_SI[si],User_DI[si]>
	RESTORE <SI, DS>
Pretx:	popf
	ret

PRINTRET ENDP

endif


; ==========================================================================

DOSCODE    ENDS

; ==========================================================================

	END

; ==========================================================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\msdosme.asm ===
;**	Standard device IO for MSDOS (first 12 function calls)
;


	.xlist
	.xcref
	include version.inc
        include mssw.asm
	include dosseg.inc
	.cref
	.list

	TITLE	IBMDOSMES - DOS OEM dependancies
	NAME	IBMDOSMES

include dosmes.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\msioctl.asm ===
;	SCCSID = @(#)IBMIOCTL.INC	1.1 85/04/10
IBM	EQU	0FFFFH		;TRUE

INCLUDE IOCTL.INC
	SCCSID = @(#)IBMIOCTL.INC	1.1 85/04/10
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\origin.asm ===
;-------------------------------------------------------------------------
;
; This is the first file to be linked in the DOS. It contains the appropriate
; offset to which the DOS is to be ORG'd. 
;
; See ..\inc\origin.inc for description
;
;---------------------------------------------------------------------------
 	
include version.inc
include dosseg.inc
include dossym.inc
include origin.inc

DOSCODE SEGMENT

	dw	PARASTART	; for stripz utility

	org	PARASTART

	
DOSCODE ENDS

	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\msinit.asm ===
;**     msinit.asm -- ms-dos initialization code
;
;       an000 version 4.0 jan. 1988
;       an007 ptm 3957 - fake version for ibmcache.com
;       an008 ptm 4070 - fake version for ms windows
;
;
;
;
;
;       Revision History
;       ================
;
;       M019    SR      08/30/90        Changed number of instance items for
;                               Win 3.1 UMB support.
;
;       M020 : Fix for Rational bug for details see exepatch.asm
;
;       M023    SR      09/7/90 Initialize exepatch & Rational patch
;                               ptrs here. Previous init in lmstub.asm
;                               causes extrn problems when msdata is
;                               linked in by other utilities e.g.Share
;
;       M068 - support for copy protected apps.
;
;       sudeepb 06-Mar-1991  Ported for DOSEm
;

        .xlist
        .xcref
        include version.inc
        include dossym.inc
        include mssw.asm
        include dosseg.inc
        include sf.inc
        include curdir.inc
        include arena.inc
        include vector.inc
        include devsym.inc
        include pdb.inc
        include find.inc
        include mi.inc
        include xmm.inc
        include dossvc.inc
        include cmdsvc.inc
        include dbgsvc.inc
        include dpb.inc
        installed = true


        include sysvar.inc
        include doscntry.inc
        include fastopen.inc
        include bugtyp.inc
        include cputype.inc                     ; M020

        include win386.inc                      ;Win386 constants
        include doswow.inc

        .cref
        .list




ifndef NEC_98
BData   segment at 70h
else    ;NEC_98
BData   segment at 60h
endif   ;NEC_98

        extrn   DosDataSg:word          ; using this to access the data seg


BData   ends

;
; This macro gets the DOS data segment value and puts it in the specified
; segment register.  This is the init segment version of GetDseg in dosmac
;

InitGetdseg     macro   r

        mov     r, cs:[DosDseg]
        assume  r:dosdata
endm




DOSDATA SEGMENT
	extrn	SCS_Is_Dos_Binary:byte
	extrn	SCS_FDACCESS:word
        extrn   DosWowDataStart:dword
        extrn   vheVDM:byte
        extrn   SCS_COMSPEC:byte
        extrn   EXTERR_LOCUS:byte
        extrn   dmaadd:dword            ; current dma address
        extrn   DPBHead:dword           ; long pointer to dpb chain(NT:always -1)
        extrn   sft_addr:dword          ; pointer to open file list
        extrn   numio:byte              ; number of physical drives
ifdef NEC_98
        extrn   buffhead:dword          ; pointer to buffer chain
endif   ;NEC_98
        extrn   endmem:word             ; first unavailable address in memory
        extrn   currentpdb:word         ; current process id
        extrn   createpdb:byte          ; true => create a new pdb
        extrn   arena_head:word         ; paragraph address of head of arena
        extrn   sftabl:byte             ; internal file table
        extrn   sysinitvar:byte         ; label for internal structures
        extrn   nuldev:dword            ; long pointer to device chain
        extrn   bcon:dword              ; pointer to console device
        extrn   bclock:dword            ; pointer to clock device
        extrn   callunit:byte           ; unit field in dd packet
        extrn   callbpb:dword           ; returned bpb from dd
        extrn   maxsec:word
        extrn   dskchret:byte
        extrn   devcall:byte
        extrn   jshare:dword
        extrn   country_cdpg:byte        ; country info table, dos 3.3
        extrn   sysinittable:byte        ; sys init table for sysinit
        extrn   fastopentable:byte       ; table for fastopen
        extrn   special_entries:word     ; address of special entries ;an007;
        extrn   hashinitvar:word         ; hash table variables       ;an000;
        extrn   packet_temp:word         ; used for initial hash table;an000;


        extrn   user_ss:word
        extrn   user_sp:word

        extrn   msdat001e:byte          ; end of dosdata segment
        extrn   msct001s:byte           ; start of dosdata segment

        extrn   XMMcontrol:dword        ; entry into BIOS xmm driver
        extrn   dosinttable:dword       ; int vec table for DOS

        extrn   dskstack:byte
        extrn   temp_dosloc:word        ; stores the temp. location of DOS seg

; WIN386 instance table variables

        extrn   Win386_Info:byte, Instance_Table:word

;Win386 2.xx instance table

        extrn   OldInstanceJunk: word


        extrn   i0patch:word
        extrn   i20patch:word
        extrn   i21patch:word
        extrn   i25patch:word
        extrn   i26patch:word
        extrn   i27patch:word
        extrn   i2fpatch:word
        extrn   cpmpatch:word
        extrn   BiosDataPtr:dword       ;ptr to BIOS data exchange block
        extrn   DosHasHMA:byte          ; M021
        extrn   RationalPatchPtr:word   ; M020
        extrn   fixexepatch:word
        extrn   ChkCopyProt:word        ; M068
        extrn   SCS_ISDEBUG:byte

DOSDATA ENDS


DOSCODE SEGMENT

        extrn   irett:near
        extrn   int2f:near
        extrn   call_entry:near
        extrn   quit:near
        extrn   command:near
        extrn   absdrd:near
        extrn   absdwrt:near
        extrn   divov:near
        extrn   stay_resident:near

        extrn   lirett:near
        extrn   lint2f:near
        extrn   lcall_entry:near
        extrn   lquit:near
        extrn   lcommand:near
        extrn   labsdrd:near
        extrn   labsdwrt:near
        extrn   ldivov:near
        extrn   lstay_resident:near

        extrn   $startcode:word
        extrn   header:byte


        extrn   exepatch:near           ; Routine in exepatch.asm
        extrn   exepatch_start:byte     ; in exepatch.asm
        extrn   RationalPatch:near      ; M020
        extrn   RetExePatch:near        ; M023
        extrn   IsCopyProt:near         ; M068

        extrn   LowInt23Addr:dword
        extrn   LowInt24Addr:dword
        extrn   LowInt28Addr:dword

        extrn   dosdseg:word            ; used by InitGetDseg macro
ifdef NEC_98
        extrn   irett2:near             ;NEC add
        extrn   lirett2:near            ;NEC add
endif   ;NEC_98


        public  sysbuf

sysbuf  label   word

        ASSUME  cs:doscode,ds:nothing,es:nothing,ss:nothing


; temp iret instruction

initiret:
        IRET

; pointer to the BIOS data segment that will be available just to the
; initialization code

ifndef NEC_98
InitBioDataSeg  dw      70H
else    ;NEC_98
InitBioDataSeg  dw      60H
endif   ;NEC_98


; Convert AX from a number of bytes to a number of paragraphs (round up).
ParaRound       proc    near
        add     ax, 15
        rcr     ax, 1
        shr     ax, 1
        shr     ax, 1
        shr     ax, 1
        ret
ParaRound       endp


;
; MAIN ENTRY FOR DOS INITIALIZATION
;

        ENTRY   DosInit

        invoke  DOCLI
        cld

; save parameters from BIOS

        push    dx                      ; dx = memory size
        push    si                      ; ds:si = device list
        push    ds                      ; es:di = BiosComBlock
        push    di
        mov     bx,es                   ;bx:di = ptr to BiosComBlock


; First, move the DOS data segment to its final location in low memory
;
; BUGBUG sudeepb 06-Mar-1991: Rather than using cs:[memstrt] below as
; the source address use [memstrt>>4]:0. Allows bigger data segment.

        mov     ax, offset memstrt      ; get offset of end of init code

        add     ax, 15                  ; round to nearest paragraph
        and     ax, not 15              ; boudary

        mov     si, ax                  ; si = offset of DOSDATA in current
                                        ; code segment
        mov     ax, cs
        mov     ds, ax                  ; ds = current code segment
                                        ; DS:SI now points to dosdata

        mov     es, cs:[InitBioDataSeg] ; First access to DosDataSg in
                                        ;  BData segment. Cannot use
                                        ;  getdseg macro here!!!
        assume  es:BData
        mov     es, es:[DosDataSg]      ; Get free location in low memory
        assume  es:nothing
        xor     di, di                  ; ES:DI now points to RAM data

        mov     cx, offset MSDAT001e    ; get end of dosdata = size of dosdata
        rep     movsb                   ; move data to final location


        pop     di                      ;restore ptr to BiosComBlock
        pop     ds                      ; restore parms from BIOS
        pop     si
        pop     dx

        push    es
        push    ds
        pop     es                      ; es:si -> device chain
        pop     ds                      ; ds points to dosdata

        assume  ds:dosdata

        push    es
        mov     es, bx
        mov     al, byte ptr es:[di+1]  ; DemInfoFlag from BiosComBlock
        mov     [SCS_ISDEBUG],al
        pop     es

        SVC     SVC_DEMGETDRIVES
        mov     [numio],al

ifdef NEC_98
ifdef NTVDMDBG
        SVC     SVC_ISDEBUG
        mov     [SCS_ISDEBUG],al
endif
endif   ;NEC_98
        test    [SCS_ISDEBUG],ISDBG_DEBUGGEE
        je      @f
        SAVEREG <ax,bx,cx,dx,di,es>
        mov     bx, cs                  ; current base of DOS
        xor     cx, cx
        mov     dx, offset memstrt      ; get offset of end of code
        add     dx, offset MSDAT001e    ; add in length of data segment
        adc     cx, 0                   ; cx:dx now size

        mov     di, 2                   ; Hardcoded segment number
        mov     es, es:[DosDataSg]      ; Get location of dos data

        mov     ax, SYMOP_MOVE SHL 8 + ID_NTDOS
        SVC     SVC_DEMSYSTEMSYMBOLOP

        RESTOREREG <es,di,dx,cx,bx,ax>
@@:

        push    dx
        mov     ax, offset DOSDATA:DMAADD
        mov     dx, offset DOSDATA:CurrentPDB

; RLF 10/16/92
; Need to set EXTERR info from 32-bit side when reading named pipes. The reason
; for this is a 'hack' fix to the real 16-bit redir which needs to indicate more
; data received to 16-bit apps. The way they do this is to reset the extended
; error information for a successful read, and set it to more data error if the
; app's buffer is not large enough for all the available data

        push    cx                      ; for good measure
        mov     cx,offset dosdata:EXTERR_LOCUS
        push    si
        mov     si,offset dosdata:DosWowDataStart ; ds:si ->DosWowData
        SVC     SVC_DEMSETDTALOCATION   ; ds:ax is the address of DMAADD
                                        ; ds:dx is CurrentPDB
                                        ; ds:cx is EXTERR_LOCUS
        pop     si
	;pop	 cx

        mov     dx, offset dosdata:vheVDM

        push    bx
        mov     bx, offset dosdata:nuldev

        SVC     SVC_DEMSETHARDERRORINFO ; ds:dx is VHE
                                        ; ds:bx is device chain


        mov     dx, offset dosdata:SCS_COMSPEC
	mov	bx, offset dosdata:SCS_Is_Dos_Binary
	mov	cx, offset dosdata:SCS_FDACCESS

	CMDSVC	SVC_CMDSETINFO		; ds:dx is pointer to SCSINFO structure
					; DS:BX is pointer to SCS_Is_Dos_Binary
					; DS:CX is pointer to SCS_FDACCESS
        pop     bx
	pop	cx
        pop     dx

;We get a ptr to the BIOS exchange data block. This has been setup right
;now so that the EXEC call knows when SysInit is present to do the special
;lie table handling for device drivers. This can be expanded later on to
;establish a communication block from the BIOS to the DOS.
;

        mov     word ptr BiosDataPtr,di ;save ptr to BiosComBlock
        mov     word ptr BiosDataPtr+2,bx


        mov     [dosdseg], ds           ; set pointer to dosdata in code seg

        ;
        ; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata
        ;

        mov     word ptr [LowInt23Addr+2], ds   ; set pointers in code seg
        mov     word ptr [LowInt24Addr+2], ds
        mov     word ptr [LowInt28Addr+2], ds


        mov     [endmem],dx
        mov     [user_sp],sp
        mov     [user_ss],ss

        mov     ax,ds                   ; set up ss:sp to dosdata:dskstack
        mov     ss,ax
        assume  ss:dosdata

        mov     sp,offset dosdata:dskstack

;M023
; Init patch ptrs to default values
;
        mov     FixExePatch, offset DOSCODE:RetExePatch         ; M023
        mov     [RationalPatchPtr], offset DOSCODE:RetExePatch  ; M023
        mov     [ChkCopyProt], offset DOSCODE:RetExePatch       ; M068

        ; Set up the variable temp_dosloc to point to the dos code segment

        mov     ax, cs                  ; ax = current segment of DOS code

        ; ax now holds segment of DOS code
        mov     [temp_dosloc], ax       ; store temp location of DOS


        mov     word ptr [nuldev+2],es  ; nuldev -> points to device chain
        mov     word ptr [nuldev],si

; There are some locations in the Win386 instance data structures
; which need to be set up with the DOS data segment.  First, initialize
; the segment part of the instance table pointer in the SIS.

        mov     word ptr [Win386_Info + SIS_Instance_Data_Ptr + 2], ds

; Now initialize the segment part of the pointer to the data in each
; instance table entry.

        push    si                      ; preserve pointer to device chain
ifndef NEC_98
        mov     cx, 7                   ; There are 7 entries in the instance table
                                        ; M019
else    ;NEC_98
        mov     cx, 8           ; There are 8 entries in the instance table
endif   ;NEC_98
        mov     si, (offset dosdata:Instance_Table) + 2 ; point si to segment field
Instance_init_loop:
        mov     word ptr ds:[si], ds    ; set offset in instance entry
        add     si, (size Win386_IIS)   ; move on to next entry
        loop    Instance_init_loop


;Initialize the WIN386 2.xx instance table with the DOS data segment value

        mov     cx, 5           ; There are five entries in the instance table
        mov     si, (offset dosdata:OldInstanceJunk) + 6
                                ; point si to segment field
OldInstance_init_loop:
        mov     word ptr ds:[si], ds    ; set offset in instance entry
        add     si, 6           ; move on to next entry
        loop    OldInstance_init_loop
        pop     si                      ; restore pointer to device chain
;
;End of WIN386 2.xx compatibility bullshit

        push    es
        pop     ds
        assume  ds:nothing              ; ds:si points to console device


        ; need crit vector inited to use deviocall
        push    ds                      ; preserve segment of device chain
        xor     ax,ax
        mov     ds,ax                   ; point DS to int vector table
        mov     ax,offset initiret
        mov     word ptr ds:[addr_int_ibm],ax
        mov     ax,cs
        mov     word ptr ds:[addr_int_ibm+2],ax
        pop     ds                      ; restore segment of device chain

        call    charinit                ; initialize console driver
        push    si                      ; save pointer to header

        push    ss                      ; move pointer to dos data...
        pop     es                      ; ...into ES
        assume  es:dosdata

        ;initialize sft for file 0 (CON)

        mov     di,offset dosdata:sftabl + sftable
        mov     ax,3
        stosw                           ; refcount
        dec     al
        .errnz  sf_mode-(sf_ref_count+2)
        stosw                           ; access rd/wr, compatibility
        xor     al,al
        .errnz  sf_attr-(sf_mode+2)
        stosb                           ; attribute
        mov     al,devid_device_eof or devid_device or iscin or iscout
        .errnz  sf_flags-(sf_attr+1)
        stosw                           ; flags
        mov     ax,si
        .errnz  sf_devptr-(sf_flags+2)
        stosw                           ; device pointer in devptr
        mov     ax,ds
        stosw
        xor     ax,ax
        .errnz  sf_time-(sf_devptr+4)
        stosw                           ; time
        .errnz  sf_date-(sf_time+2)
        stosw                           ; date
        dec     ax
        .errnz  sf_size-(sf_date+2)
        stosw                           ; size
        stosw
        inc     ax
        .errnz  sf_position-(sf_size+4)
        stosw                           ; position
        stosw
        pop     si                      ; get back pointer to header

                                        ; mark device as CON I/O
        or      byte ptr [si.sdevatt],iscin or iscout
        mov     word ptr [bcon],si
        mov     word ptr [bcon+2],ds

        ; initialize each device until the clock device is found

char_init_loop:
        lds     si,dword ptr [si]       ; aux device
        call    charinit
        test    byte ptr [si.sdevatt],isclock
        jz      char_init_loop

        mov     word ptr [bclock],si    ; bclock -> clock device
        mov     word ptr [bclock+2],ds

        mov     bp,offset MSDAT001e     ; bp = pointer to free mem
        mov     word ptr DPBHead, bp
        mov     word ptr DPBHead + 2,es

perdrv:
        lds     si,SDEVNEXT [si]        ; next device
        cmp     si,-1                   ; Q: any more devices
        je      continit                ;  N: goto continit
        call    charinit                ;  Y: initialize the device
        jmp     short perdrv            ; Scan device list more


continit:

        SVC     SVC_DEMGETDPBLIST

        cmp     bp,offset MSDAT001e
        jne     dpblistok

        mov     word ptr DPBHead, -1    ; no dpbs
        mov     word ptr DPBHead + 2, -1

dpblistok:

        push    ss
        pop     ds

        assume  ds:dosdata

        mov     ax,bp
        call    ParaRound               ; round up to segment

        mov     dx,ds                   ; dx = dosdata segment
        add     dx,ax                   ; dx = ds+ax first free segment
        mov     bx,0fh
        mov     cx,[endmem]


                                        ; set seg inpacketto dosdata
        mov     word ptr [dskchret+3],ds


; Patch in the segments of the interrupt vectors with current code segment.
; Also patch in the segment of the pointers in the dosdata area.
;
; Note:  Formerly, temp_dosloc was initialized to -1 until after these
; calls were done.  The procedure patch_misc_segments is called multiple
; times, and relies on temp_dosloc being initialized to -1 as a flag
; for the first invocation.  Thus, we must set it to -1 for this call.


        push    dx                      ; preserve first free segment
        mov     ax, [temp_dosloc]       ; ax = segment to patch in
        mov     es, ax                  ; es = segment of DOS
        mov     [temp_dosloc], -1       ; -1 means first call to patch_misc_segments

        call    patch_vec_segments      ; uses AX as doscode segment
        call    patch_misc_segments     ; patch in segments for sharer and
                                        ; other tables with seg in ES.
        mov     [temp_dosloc], es       ; put back segment of dos code

        pop     dx                      ; restore first free segment


;
; We shall now proceed to set the offsets of the interrupt vectors handled
; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
; HIMEM the offsets also will be patched to their appropriate values in the
; low_mem_stub by seg_reinit.
;

        xor     ax,ax
        mov     ds,ax
        mov     es,ax
assume  ds:nothing,es:nothing

        ; set the segment of int 24 vector that was
        ; left out by patch_vec_segments above.

        mov     di, 4 * int_fatal_abort
        mov     ax, [temp_dosloc]
        mov     [di+2], ax
        mov     di,intbase+2

        ; set default divide trap offset

        mov     word ptr ds:[0],offset doscode:divov

        ; set vectors 20-28 and 2a-3f to point to iret.

        mov     di,intbase
        mov     ax,offset doscode:irett
        mov     cx,9                    ; set 9 offsets (skip 2 between each)
                                        ;   sets offsets for ints 20h-28h
iset1:
        stosw
        add     di,2
        loop    iset1

        add     di,4                    ; skip vector 29h

        mov     cx,6                    ; set 6 offsets (skip 2 between each)
                                        ;   sets offsets for ints 2ah-2fh
iset2:
        stosw
        add     di,2
        loop    iset2

; 30h & 31H is the CPM call entry point whose segment address is set up by
; patch_vec_segments above. So skip it.

        add     di,8                    ; skip vector 30h & 31h


ifndef NEC_98
        mov     cx,14                   ; set 14 offsets (skip 2 between each)
                                        ;   sets offsets for ints 32h-3fh
else    ;NEC_98
                                        ; for AP(Power Graph,e.t.c)
        stosw                           ; set offset for int 32h
        add     di,2
        
        push    ax                      ; set offset for int33h
        mov     ax,offset doscode:irett2        ; mouse driver
        stosw
        add     di,2
        pop     ax

        mov     cx,12                   ; set 12 offsets (skip 2 between each)
                                        ;   sets offsets for ints 34h-3fh

endif   ;NEC_98
iset3:
        stosw
        add     di,2
        loop    iset3


if installed
        ; set the offset of int2f handler
        mov     word ptr ds:[02fh * 4],offset doscode:int2f
        ; set segment to doscode as we we have to do int 2f to check for XMS
        mov     ax, [temp_dosloc]       ; get segment of doscode
        mov     word ptr ds:[(02fh * 4) + 2], ax
endif

        ; set up entry point call at vectors 30-31h. Note the segment of the
        ; long jump will be patched in by  seg_reinit

        mov     byte ptr ds:[entrypoint],mi_long_jmp
        mov     word ptr ds:[entrypoint+1],offset doscode:call_entry


        mov     word ptr ds:[addr_int_abort],offset doscode:quit
        mov     word ptr ds:[addr_int_command],offset doscode:command
        mov     word ptr ds:[addr_int_terminate],100h
        mov     word ptr ds:[addr_int_terminate+2],dx
        mov     word ptr ds:[addr_int_disk_read],offset doscode:absdrd
        mov     word ptr ds:[addr_int_disk_write],offset doscode:absdwrt
        mov     word ptr ds:[addr_int_keep_process],offset doscode:stay_resident

        push    ss
        pop     ds
        push    ss
        pop     es
assume  ds:dosdata,es:dosdata

        push    dx                      ; remember address of arena

        inc     dx                      ; leave room for arena header
        mov     [currentpdb], dx        ; set current pdb

        xor     di, di                  ; point es:di at end of memory
        mov     es, dx                  ; ...where psp will be
        assume  es:nothing
        xor     ax, ax
        mov     cx, 80h                 ; psp is 128 words
        rep     stosw                   ; zero out psp area
        mov     ax,[endmem]

        invoke  setmem                  ; build psp at dx; ax is memory size

        ; ds, es now point to PSP

        assume  ds:nothing,es:nothing

        push    ss
        pop     ds
        assume  ds:dosdata

        mov     di,pdb_jfn_table        ; es:di -> pdb_jfn_table in psp
        xor     ax,ax
        stosw
        stosb                           ; 0,1 and 2 are con device
        mov     al,0ffh
        mov     cx,filperproc - 3
        rep     stosb                   ; rest are unused

        push    ss
        pop     es
        assume  es:dosdata
                                        ; must be set to print messages
        mov     word ptr [sft_addr+2],ds


; after this point the char device functions for con will work for
; printing messages

        if      (not ibm) or (debug)
        mov     si,offset doscode:header
outmes:
        lods    cs:byte ptr [si]
        cmp     al,"$"
        jz      outdone
        invoke  outt
        jmp     short outmes
outdone:
        push    ss                      ; out stomps on segments
        pop     ds
        push    ss
        pop     es
        endif

if      DEBUG
        mov     ax,11100011b
        sub     dx,dx
        int     14h                     ; init serial port, 9600 baud
endif
        fmt TypSysCall,LevLog,<"Start Boot - CS=$x\n">,<CS>

        ; at this point es is dosdata

        ; Fill in the segment addresses of sysinitvar and country_cdpg
        ; in sysinittable (ms_data.asm)

        mov     si,offset dosdata:sysinittable
        mov     word ptr es:[si.sysi_country_tab + 2],es
        mov     word ptr es:[si.sysi_initvars + 2],es

ifdef NEC_98
        ; buffhead -> dosdata:hashinitvar 

        mov     word ptr es:[buffhead+2],es     ; BUGBUG - unused, remove this
        mov     si,offset dosdata:hashinitvar   ; and all other references
        mov     word ptr es:[buffhead],si

endif   ;NEC_98
        pop     dx                      ; restore address of arena

        mov     word ptr [dmaadd+2],dx

        mov     es:[arena_head],dx
        mov     ds, dx
        assume  ds:nothing

        mov     ds:[arena_signature],arena_signature_end
        mov     ds:[arena_owner],arena_owner_system
        mov     ax, [endmem]
        sub     ax, dx
        dec     ax
        mov     ds:[arena_size],ax

        ; point to sft 0

        mov     di,offset dosdata:sftabl + sftable
        mov     ax,3
        stosw                           ; adjust refcount

        ; es:di is shared data area i.e., es:di -> dosdata:sysinttable

        mov     di,offset dosdata:sysinittable

        inc     dx                      ; advance dx from arena to psp
        mov     ds, dx                  ; point ds to psp

        if      not installed
        invoke  netwinit
        endif

                                        ; pass the address os seg_reinit
                                        ; in dx
        mov     dx, offset seg_reinit
        mov     cx, offset doscode:exepatch_start
        sub     cx, offset $startcode   ; cx = (doscode - exepatch) - dosinit
        mov     ax, offset doscode:sysbuf
        sub     ax, offset $startcode   ; ax=size of doscode - dosinit


        mov     sp,[user_sp]            ; use ss override for next 2
        mov     ss,[user_ss]
        assume  ss:nothing

        retf

;
; END OF DOSINIT
;
;--------------------------------------------------------------------------



        assume  ds:nothing,es:nothing,ss:dosdata
charinit:
        ; ds:si points to device header
        mov     [devcall.reqlen],dinithl
        mov     [devcall.requnit],0
        mov     [devcall.reqfunc],devinit
        mov     [devcall.reqstat],0
        push    es
        push    bx
        push    ax
        mov     bx,offset dosdata:devcall
        push    ss
        pop     es
        invoke  deviocall2
        pop     ax
        pop     bx
        pop     es
        ret



;-----------------------------------------------------------------------------
;
;       check_XMM: routine to check presence of XMM driver
;
;       Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
;
;       USED:   none
;
;-----------------------------------------------------------------------------

check_XMM proc  near
;
; determine whether or not an XMM driver is installed
;
        push    ax
        mov     ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
        int     2Fh
        cmp     al,80h                  ; Q: installed
        jne     short cXMM_no_driver    ;   N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
        push    bx
        push    dx
        push    ds
        push    es
        mov     ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
        int     2Fh

        InitGetdseg     <ds>

        mov     word ptr [XMMcontrol], bx
        mov     word ptr [XMMcontrol+2],es

cXMMexit:
        clc
        pop     es
        pop     ds
        pop     dx
        pop     bx
        pop     ax
        ret                             ; done
;
; set carry if XMM driver not present
;
cXMM_no_driver:
        stc
        pop     ax
        ret

check_XMM       endp



;---------------------------------------------------------------------------
;
; Procedure Name : seg_reinit
;
; Inputs         : ES has final dos code location
;                  AX = 0 / 1
;
; Outputs        : Patch in the sharer and other tables with seg in ES
;                  if AX =0
;                     if first entry
;                        patch segment & offset of vectors with stub
;                        and stub with segment in ES
;                     else
;                        patch stub with segment in ES
;
;                  else if AX = 1
;                       patch segment of vectors with segment in ES
;
; NOTE           : This routine can be called at most twice!
;
; Regs Mod.      : es, ax, di, cx, bx
;-----------------------------------------------------------------------------

num_entry       db      0       ; keeps track of the # of times this routine
                                ; has been called. (0 or 1)
seg_reinit      proc    far

        push    ds

        InitGetdseg     <ds>
        assume  ds:DOSDATA
;
;       Symbol file support
;
        cmp     num_entry, 0
        jz      @f
        test    [SCS_ISDEBUG],ISDBG_DEBUGGEE
        je      @f
        SAVEREG <ax,bx,cx,dx,di>
        mov     bx, cs                  ; moving from here
        xor     cx, cx
        mov     dx, offset memstrt      ; get offset of end of code
        mov     di, 1                   ; Hardcoded segment number
        mov     ax, (SYMOP_MOVE + SYMOP_CLEANUP) SHL 8 + ID_NTDOS
        SVC     SVC_DEMSYSTEMSYMBOLOP   ; segment already in es
        RESTOREREG <di,dx,cx,bx,ax>
@@:

        call    patch_misc_segments     ; patch in segments for sharer and
                                        ; other tables with seg in ES.

        cmp     ax, 0
        je      short no_patch
        jmp     patch_vec_seg           ; patch vectors with segment in es

no_patch:

        cmp     num_entry, 0            ; Q: is it the first call to this
        jne     second_entry            ; N: just patch the stub with
                                        ;    segment in ES
                                        ; Y: patch the vectors with stub
        mov     ax, ds
        call    patch_vec_segments      ; patch the segment of vectors
        call    patch_offset            ; patch the offsets of vectors
                                        ; with those in the stub.

second_entry:
        mov     ax, es                  ; patch the stub with segment in es

        mov     di, OFFSET DOSDATA:DOSINTTABLE
        mov     cx, 9
        push    ds
        pop     es                      ; es:di -> DOSINTTABLE

dosinttabloop:
        add     di, 2
        stosw
        loop    dosinttabloop

        cmp     ax, 0f000h              ; Q: is the DOS running in the HMA
        jb      short sr_done           ; N: done
        call    check_XMM               ; Y: set up the XMS entry point
        jc      sr_done                 ; failed to set up XMS do not do
                                        ; A20 toggling in the stub.
        call    patch_in_nops           ; enable the stub to check A20 state

; M021-
        mov     [DosHasHMA], 1          ; set flag telling DOS control of HMA

                                        ; set pointer to the routine that
                                        ; patches buggy exepacked code.
        mov     [fixexepatch], offset DOSCODE:exepatch

                                        ; M068: set pointer to the routine
                                        ; M068: that detects copy protected
                                        ; M068: apps
        mov     [ChkCopyProt], offset DOSCODE:IsCopyProt

; M020 - begin

        get_cpu_type
        cmp     al, 1
        jne     sr_done                 ; we need Rational Patch only
                                        ;  on 286 systems
        mov     [RationalPatchPtr], offset DOSCODE:RationalPatch

; M020 - end

        jmp     short sr_done


patch_vec_seg:                          ; patch vectors with segment in es

        mov     ax, es
        call    patch_vec_segments      ; patch in DOSCODE for the segments
                                        ; NOTE we don't have to patch the
                                        ; offsets as they have been already
                                        ; set to the doscode offsets at
                                        ; DOSINIT.

sr_done:
        mov     num_entry, 1
        pop     ds
        ret

seg_reinit      endp



;----------------------------------------------------------------------------
;
; Procedure Name : patch_vec_segments
;
; Inputs         : ax -> has segment address to patch in
;                  ds -> DOSDATA
;
; Outputs        : Patches in AX as the segment for the following vectors:
;
;                       0,20-28,3a-3f
;
; Regs. Mod.     : DI,CX,DX,AX
;
;----------------------------------------------------------------------------

patch_vec_segments      proc    near

        push    es

        xor     cx,cx
        mov     es,cx
assume  es:nothing

        mov     di,intbase+2            ; di -> segment of int 20 vector

        mov     es:[2],ax               ; segment of default divide trap handler

                                        ; set vectors 20 & 21

        mov     cx, 2
ps_set1:
        stosw
        add     di, 2
        loop    ps_set1

        add     di, 4                   ; skip  int 22h vector

        stosw                           ; set int 23h
        add     di, 6                   ; skip int 24h

                                        ; set vectors 25-28 and 2a-3f

        mov     cx, 4                   ; set 4 segments
ps_set2:
        stosw
        add     di, 2
        loop    ps_set2

        add     di,4                    ; skip int 29h vector (fast con) as it may
                                        ;   already be set.


        mov     cx,6                    ; set 6 segs (skip 2 between each)
                                        ;   set segs for ints 2ah-2fh
ps_set3:
        stosw
        add     di,2
        loop    ps_set3

; 30h & 31H is the CPM call entry point whose segment address is set up by
; below. So skip it.

        add     di,8                    ; skip vector 30h & 31h


        mov     cx,14                   ; set 14 segs (skip 2 between each)
                                        ;   sets segs for ints 32h-3fh
ps_set4:
        stosw
        add     di,2
        loop    ps_set4



; set offset of int2f

if installed
;       mov     word ptr es:[02fh * 4],offset doscode:int2f
endif

        mov     word ptr es:[entrypoint+3],ax

        pop     es
        ret

patch_vec_segments      endp


;---------------------------------------------------------------------------
;
; Procedure Name : patch_misc_segments
;
; Inputs         : es = segment to patch in
;                  ds = dosdata
;
; outputs        : patches in the sharer and other tables in the dos
;                  with right dos code segment in es
;
; Regs Mod       : DI,SI,CX
;
;---------------------------------------------------------------------------
patch_misc_segments     proc    near

        push    bx
        push    es
        push    ax

        mov     ax, es                  ; ax - > DOS segment

        push    ds
        pop     es                      ; es -> DOSDATA


;
; initialize the jump table for the sharer...
;
        mov     di,offset dosdata:jshare
        mov     bx, [temp_dosloc]       ; bx = location to which the share
                                        ; table was patched during the first
                                        ; call to this routine
        mov     cx,15
jumptabloop:
        add     di,2                    ; skip offset
        cmp     bx, -1                  ; Q: is this called for the 1st time
        je      share_patch             ;  Y: patch in sharer table
                                        ;  N:
        cmp     bx, es:[di]             ; Q: has share been installed
        jne     no_share_patch          ;  Y: don't patch in sharer table

share_patch:
        stosw                           ; drop in segment

no_share_patch:
        loop    jumptabloop

                                        ; BUGBUG patching the country info
                                        ; with dosdata can be done inline
                                        ; in .dosinit.
                                        ; for dos 3.3 country info
                                        ; table address
        mov     si,offset dosdata:country_cdpg

                                        ; initialize double word
                                        ; pointers with dosdata in ds
        mov     word ptr [si.ccucase_ptr + 2],ds
        mov     word ptr [si.ccfileucase_ptr + 2],ds
        mov     word ptr [si.ccfilechar_ptr + 2],ds
        mov     word ptr [si.cccollate_ptr + 2],ds
        mov     word ptr [si.ccmono_ptr + 2],ds
        mov     word ptr [si.ccdbcs_ptr + 2],ds

                                        ; fastopen routines are in doscode
                                        ; so patch with doscode seg in ax

        mov     si,offset dosdata:fastopentable

        cmp     [temp_dosloc], -1       ; Q: first time
        je      fast_patch              ; Y: patch segment
        mov     cx, [temp_dosloc]
                                        ; Q: has fastopen patched in it's
                                        ;    segment
        cmp     cx, word ptr [si.fastopen_name_caching + 2]
        jne     no_fast_patch           ; Y: don't patch in doscode seg

fast_patch:
        mov     word ptr [si.fastopen_name_caching + 2],ax
no_fast_patch:

;
;       put the final dosdata segment in the following pointers
;
        mov     si,offset dosdata:DosWowDataStart
        mov     word ptr [si.DWD_lpCDSCount + 2],ds
        mov     word ptr [si.DWD_lpCDSFixedTable + 2],ds
        mov     word ptr [si.DWD_lpCDSBuffer + 2],ds
        mov     word ptr [si.DWD_lpCurDrv + 2],ds
        mov     word ptr [si.DWD_lpCurPDB + 2],ds
        mov     word ptr [si.DWD_lpDrvErr + 2],ds
        mov     word ptr [si.DWD_lpExterrLocus + 2],ds
        mov     word ptr [si.DWD_lpSCS_ToSync + 2],ds
        mov     word ptr [si.DWD_lpSftAddr + 2],ds
        mov     word ptr [si.DWD_lpExterr + 2], ds
        mov     word ptr [si.DWD_lpExterrActionClass + 2], ds
;
;       inform dem of new locations
;
;
        SVC     SVC_SETDOSVARLOCATION

        pop     ax
        pop     es
        pop     bx

        ret

patch_misc_segments     endp

;--------------------------------------------------------------------------
;
; Procedure Name : patch_offset
;
; Inputs         : NONE
;
; Outputs        : Patches in the offsets in the low_mem_stub for vectors
;                  0,20-28,3a-3f, and 30,31
;
;
; Regs. Mod      : AX,DI,CX
;--------------------------------------------------------------------------
patch_offset    proc    near

        push    es              ; preserve es

        xor     ax,ax
        mov     es,ax
assume  ds:nothing,es:nothing

                                ; set default divide trap address
        mov     word ptr es:[0],offset dosdata:ldivov

        mov     di,intbase      ; di-> offset of int 20 handler
        mov     ax,offset dosdata:lirett

                                ; set vectors 20 & 21 to point to iret.
        mov     cx,2            ; set 2 offsets (skip 2 between each)

po_iset1:
        stosw
        add     di, 2
        loop    po_iset1

        add     di, 4           ; skip vector 22h

        stosw                   ; set offset of 23h
        add     di, 6           ; skip 24h

                                ; set vectors 25-28 and 2a-3f to iret.
        mov     cx,4            ; set 4 offsets (skip 2 between each)
                                ;   sets offsets for ints 25h-28h
po_iset2:
        stosw
        add     di,2
        loop    po_iset2

        add     di,4            ; skip vector 29h


        mov     cx,6            ; set 6 offsets (skip 2 between each)
                                ;   sets offsets for ints 2ah-2fh
po_iset3:
        stosw
        add     di,2
        loop    po_iset3

; 30h & 31H is the CPM call entry point whose offset address is set up by
; below. So skip it.

        add     di,8            ; skip vector 30h & 31h


ifndef NEC_98
        mov     cx,14           ; set 14 offsets (skip 2 between each)
                                ;   sets offsets for ints 32h-3fh
else    ;NEC_98
                                        ; for AP(Power Graph,e.t.c)
        stosw                           ; set offset for int 32h
        add     di,2
        
        push    ax                      ; set offset for int33h
        mov     ax,offset dosdata:lirett2       ; mouse driver
        stosw
        add     di,2
        pop     ax

        mov     cx,12                   ; set 12 offsets (skip 2 between each)
                                        ;   sets offsets for ints 34h-3fh
endif   ;NEC_98
po_iset4:
        stosw
        add     di,2
        loop    po_iset4


if installed
        mov     word ptr es:[02fh * 4],offset dosdata:lint2f
endif


; set up entry point call at vectors 30-31h
        mov     byte ptr es:[entrypoint],mi_long_jmp
        mov     word ptr es:[entrypoint+1],offset dosdata:lcall_entry


        mov     word ptr es:[addr_int_abort],offset dosdata:lquit
        mov     word ptr es:[addr_int_command],offset dosdata:lcommand
        mov     word ptr es:[addr_int_disk_read],offset dosdata:labsdrd
        mov     word ptr es:[addr_int_disk_write],offset dosdata:labsdwrt
        mov     word ptr es:[addr_int_keep_process],offset dosdata:lstay_resident

        pop     es              ; restore es
        ret

patch_offset    endp

;--------------------------------------------------------------------------
;
;       Procedure Name  :       patch_in_nops
;
;       Entry           :       ES -> DOSDATA
;
;       Regs Mod        :       cx, di
;
;       Description:
;               This routine patches in 2 nops at the offsets specifed in
;       patch_table. This basically enables the low mem stub to start
;       making XMS calls.
;
;--------------------------------------------------------------------------

patch_table     label   byte
        dw      offset dosdata:i0patch
        dw      offset dosdata:i20patch
        dw      offset dosdata:i21patch
        dw      offset dosdata:i25patch
        dw      offset dosdata:i26patch
        dw      offset dosdata:i27patch
        dw      offset dosdata:i2fpatch
        dw      offset dosdata:cpmpatch
patch_table_size        equ     ($ - patch_table) / 2

patch_in_nops   proc    near

        push    ax
        push    si
        mov     si, offset patch_table
        mov     ax, 09090h
        mov     cx, patch_table_size

pin_loop:
        mov     di, cs:[si]
        stosw
        add     si, 2
        loop    pin_loop
        pop     si
        pop     ax
        ret

patch_in_nops   endp


public msini002s,msini002e
msini002s label byte

;M060;;the following entries don't expect version 4.0
;M060;  ;the entry format: name_length, name, expected version
;M060;  ;dw     ?
;M060;  ;db     "SPECIAL ENTRIES TABLE",0     ;an007  tiltle
;M060;
;M060;  PUBLIC  LIE_TABLE_OFFSET
;M060;  LIE_TABLE_OFFSET EQU $
;M060;
;M060;  version_fake_table:                     ; starting address for special
;M060;  db      10,"WIN200.BIN"         ,3,40   ; windows 2.x
;M060;  db      10,"WIN100.BIN"         ,3,40   ; win 1.x
;M060;  db      11,"WINWORD.EXE"        ,4,10   ; winword 1.0
;M060;  db      9, "EXCEL.EXE"          ,4,10   ; excel 2.x
;M060;  db      11,"HITACHI.SYS"        ,4,00   ; CDROMS
;M060;  db      10,"MSCDEX.EXE"         ,4,00   ; CDROMS
;M060;  db      10,"REDIR4.EXE"         ,4,00   ; Banyan networks
;M060;  db      7, "NET.EXE"            ,4,00   ; 3+ Open
;M060;  db      7, "NET.COM"            ,3,30   ; IBM PCLP
;M060;  db      12,"NETWKSTA.EXE"       ,4,00   ; 3+ Open
;M060;  db      12,"DXMA0MOD.SYS"       ,3,30   ; Token ring
;M060;  db      7, "BAN.EXE"            ,4,00   ; Banyan
;M060;  db      7, "BAN.COM"            ,4,00   ; Banyan
;M060;  db      11,"MSREDIR.EXE"        ,4,00   ; LanMan
;M060;  db      9, "METRO.EXE"          ,3,31   ; Lotus Metro
;M060;  db      12,"IBMCACHE.SYS"       ,3,40   ; IBM CHACHE Program
;M060;  db      11,"REDIR40.EXE"        ,4,00   ; IBM PCLP 1.3/4 redirector
;M060;  db      6, "DD.EXE"             ,4,01   ; Laplink III software
;M060;  db      6, "DD.BIN"             ,4,01   ; Laplink III software
;M060;  db      7, "LL3.EXE"            ,4,01   ; Laplink III software
;M060;  db      9, "REDIR.EXE"          ,4,00   ; DOS 4 redir
;M060;  db      9, "SYQ55.SYS"          ,4,00   ; Removable SCSII drive from Syquest
;M060;  db      12,"SSTDRIVE.SYS"       ,4,00   ; Columbia SCSI driver
;M060;  db      8, "ZDRV.SYS"           ,4,01   ; Unisys CD-ROM B#4734
;M060;  db      8, "ZFMT.SYS"           ,4,01   ; Unisys CD-ROM B#4734
;M060;
;M060;  db      (512 - ($ - version_fake_table)) dup (0)
;M060;
;M060;  PUBLIC  LIE_TABLE_LEN
;M060;  LIE_TABLE_LEN EQU ($ - LIE_TABLE_OFFSET)

        public  memstrt

memstrt label   word

msini002e label byte


doscode ends


 DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
 DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
 DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
 DPUBLIC <notmax,  patch_offset, perdrv>
 DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
 DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
 DPUBLIC <sr_done, version_fake_table, xxx>

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\msproc.asm ===
;
; EXEC system call for DOS
;
; =========================================================================

.cref
.list

	TITLE	MSPROC - process maintenance
	NAME	MSPROC
	PAGE	,132

;$WAIT
;$EXEC
;$Keep_process
;Stay_resident
;$EXIT
;$ABORT
;abort_inner
;
;Modification history:
; Sudeepb 11-Mar-1991 Ported for NT DOSEm

.XLIST
.XCREF

INCLUDE version.inc
INCLUDE dosseg.inc
INCLUDE DOSSYM.INC
INCLUDE DEVSYM.INC
INCLUDE exe.inc
INCLUDE sf.inc
INCLUDE curdir.inc
INCLUDE syscall.inc
INCLUDE arena.inc
INCLUDE pdb.inc
INCLUDE vector.inc
INCLUDE cmdsvc.inc
include dossvc.inc
include bop.inc
include vint.inc
include dbgsvc.inc



.CREF
.LIST

public	retexepatch

; =========================================================================

DosData SEGMENT WORD PUBLIC 'DATA'

	EXTRN	CreatePDB	:BYTE
	EXTRN	DidCtrlC	:BYTE
	EXTRN	Exit_type	:BYTE
	EXTRN	ExtErr_Locus	:BYTE	; Extended Error Locus
	EXTRN	InDos		:BYTE

	EXTRN	OpenBuf		:BYTE
;	EXTRN	OpenBuf		:128

	EXTRN	CurrentPDB	:WORD
	EXTRN	Exit_code	:WORD

	EXTRN	DmaAdd		:DWORD


		; the following includes & i_needs are for exec.asm
		; which is included in this source

		; **** Fake_count to commented out
		
	EXTRN	Fake_Count	:BYTE	; Fake version count

	EXTRN	Special_Entries :WORD	; Address of special entries
	EXTRN	Special_Version :WORD	; Special version number
	EXTRN	Temp_Var2	:WORD	; File type from $open

		; following i_needs are becuse of moving these vars from
		; exec.asm to ../inc/ms_data.asm

	EXTRN	exec_init_SP	:WORD
	EXTRN	exec_init_SS	:WORD
	EXTRN	exec_init_IP	:WORD
	EXTRN	exec_init_CS	:WORD


	EXTRN	exec_signature	:WORD	; Must contain 4D5A  (yay zibo!)
	EXTRN	exec_len_mod_512:WORD	; Low 9 bits of length
	EXTRN	exec_pages	:WORD	; Number of 512b pages in file
	EXTRN	exec_rle_count	:WORD	; Count of reloc entries
	EXTRN	exec_par_dir	:WORD	; Number of paragraphs before image
	EXTRN	exec_min_BSS	:WORD	; Minimum number of para of BSS
	EXTRN	exec_max_BSS	:WORD	; Max number of para of BSS
	EXTRN	exec_SS 	:WORD	; Stack of image
	EXTRN	exec_SP 	:WORD	; SP of image
	EXTRN	exec_chksum	:WORD	; Checksum  of file (ignored)
	EXTRN	exec_IP 	:WORD	; IP of entry
	EXTRN	exec_CS 	:WORD	; CS of entry
	EXTRN	exec_rle_table	:WORD	; Byte offset of reloc table
	EXTRN	Exec_NE_Offset	:WORD

	EXTRN	DOS_FLAG	:BYTE	; flag to indicate to redir that open
					; came from exec.


	EXTRN   AllocMethod	:BYTE   ; how to alloc first(best)last
	EXTRN	SAVE_AX		:WORD	; temp to save ax
	EXTRN	AllocMsave	:BYTE	; M063: temp to save AllocMethod

	EXTRN	UU_IFS_DOS_CALL	:DWORD	; M060 Ptr to version table

	EXTRN	A20OFF_PSP	:WORD	; M068
	EXTRN	A20OFF_COUNT	:BYTE	; M068

; =========================================================================

	EXTRN	Disa20_Xfer	:WORD

	allow_getdseg

	EXTRN	DriverLoad	:BYTE
	EXTRN	BiosDataPtr	:DWORD
	extrn	DosHasHMA	:byte		; M021
	extrn	fixexepatch	:word
	extrn	ChkCopyProt	:word 		; M068
	extrn	LeaveDos	:word		; M068
	extrn	SCS_TSR 	:byte
	extrn	SCS_Is_Dos_Binary:byte
        EXTRN   SCS_CMDPROMPT   :byte
        EXTRN   SCS_DOSONLY     :byte

	EXTRN	SCS_ISDEBUG	:byte

DosData ENDS

; =========================================================================

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


	EXTRN	ExecReady:near
	EXTRN	UCase:near			; M050


SAVEXIT 	EQU	10

	BREAK	<$WAIT - return previous process error code>

; =========================================================================
;	$WAIT - Return previous process error code.
;
;	Assembler usage:
;
;	    MOV     AH, WaitProcess
;	    INT     int_command
;
;	ENTRY	none
;	EXIT	(ax) = exit code
;	USES	all
; =========================================================================

	ASSUME	DS:NOTHING,ES:NOTHING

PROCEDURE $Wait ,NEAR

	xor	AX,AX
	xchg	AX,exit_code
	transfer Sys_Ret_OK

ENDPROC $Wait


; =========================================================================
;BREAK <$exec - load/go a program>
;	EXEC.ASM - EXEC System Call
;
;
; Assembler usage:
;	    lds     DX, Name
;	    les     BX, Blk
;	    mov     AH, Exec
;	    mov     AL, FUNC
;	    int     INT_COMMAND
;
;	AL  Function
;	--  --------
;	 0  Load and execute the program.
;	 1  Load, create  the  program	header	but  do  not
;	    begin execution.
;	 3  Load overlay. No header created.
;
;	    AL = 0 -> load/execute program
;
;	    +---------------------------+
;	    | WORD segment address of	|
;	    | environment.		|
;	    +---------------------------+
;	    | DWORD pointer to ASCIZ	|
;	    | command line at 80h	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 5Ch	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 6Ch	|
;	    +---------------------------+
;
;	    AL = 1 -> load program
;
;	    +---------------------------+
;	    | WORD segment address of	|
;	    | environment.		|
;	    +---------------------------+
;	    | DWORD pointer to ASCIZ	|
;	    | command line at 80h	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 5Ch	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 6Ch	|
;	    +---------------------------+
;	    | DWORD returned value of	|
;	    | CS:IP			|
;	    +---------------------------+
;	    | DWORD returned value of	|
;	    | SS:IP			|
;	    +---------------------------+
;
;	    AL = 3 -> load overlay
;
;	    +---------------------------+
;	    | WORD segment address where|
;	    | file will be loaded.	|
;	    +---------------------------+
;	    | WORD relocation factor to |
;	    | be applied to the image.	|
;	    +---------------------------+
;
; Returns:
;	    AX = error_invalid_function
;	       = error_bad_format
;	       = error_bad_environment
;	       = error_not_enough_memory
;	       = error_file_not_found
; =========================================================================
;
;   Revision history:
;
;	 A000	version 4.00  Jan. 1988
;
; =========================================================================

	EXTRN	Exec_Header_Len :ABS
	EXTRN	Exec_Header_Len_NE:ABS

Exec_Internal_Buffer		EQU	OpenBuf
ifdef JAPAN
Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLEN_Jpn)
else
Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLEN)
endif

; =========================================================================

;IF1		; warning message on buffers
;%out	Please make sure that the following are contiguous and of the
;%out	following sizes:
;%out
;%out	OpenBuf     128
;%out	RenBuf	    128
;%out	SearchBuf    53
;%out	DummyCDS    CurDirLen
;ENDIF

; =========================================================================

ifdef NEC_98
        EXTRN   EMS_MNT         :NEAR
endif   ;NEC_98

; =========================================================================
;
; =========================================================================

procedure	$Exec,NEAR

	PUBLIC EXEC001S
EXEC001S:

	LocalVar    Exec_Blk		,DWORD
	LocalVar    Exec_Func		,BYTE
	LocalVar    Exec_Load_High	,BYTE
	LocalVar    Exec_FH		,WORD
	LocalVar    Exec_Rel_Fac	,WORD
	LocalVar    Exec_Res_Len_Para	,WORD
	LocalVar    Exec_Environ	,WORD
	LocalVar    Exec_Size		,WORD
	LocalVar    Exec_Load_Block	,WORD
	LocalVar    Exec_DMA		,WORD
	LocalVar    ExecNameLen 	,WORD
	LocalVar    ExecName		,DWORD

	LocalVar    Exec_DMA_Save	,WORD
	LocalVar    Exec_NoStack	,BYTE
	LocalVar    ExecFlag		,BYTE
	LocalVar    ExecWord		,WORD
;;
;;williamh change BEGIN
; 0 if we are not loading a COM file as overlay
; 1 if we are loading a COM file as overlay
	LocalVar    Exec_ComOverlay	,BYTE
;; williamh change END

	LocalVar    Exec_Res_Len	,DWORD


	; ==================================================================
	; validate function
	; ==================================================================

	PUBLIC	EXEC001E
EXEC001E:

		      	
	;
	; M068 - Start
	;
	; Reset the A20OFF_COUNT to 0. This is done as there is a
	; possibility that the count may not be decremented all the way to
	; 0. A typical case is if the program for which we intended to keep
	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21
	; calls), exits pre-maturely due to error conditions.
	;


        mov     [A20OFF_COUNT], 0

	;
	; If al=5 (ExecReady) we'll change the return address on the stack	
	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
	;
	cmp	al, 5			; Q: is this ExecReady call
	jne	@f			; N: continue
					; Y: change ret addr. to LeaveDos.
	pop	cx			; Note CX is not input to ExecReady
	mov	cx, offset DOSCODE:LeaveDos
	push	cx
@@:
	;
	; M068 - End
	;

	Enter

;;williamh change BEGIN
	mov	Exec_ComOverlay, 0
;;williamh changed END

	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
					; M030
	jna	exec_check_2

Exec_Bad_Fun:
	mov	ExtErr_Locus,ErrLoc_Unk ; Extended Error Locus	;smr;SS Override
	mov	al,Error_Invalid_Function

Exec_Ret_Err:
	Leave
	transfer    SYS_RET_ERR
ExecReadyJ:
	call	ExecReady		; M028
	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028

Exec_Check_2:
	cmp	AL,2
	jz	Exec_Bad_Fun

	cmp	al, 4			; 2 & 4 are not allowed
	je	Exec_Bad_Fun

	cmp	al, 5			; M028 ; M030
	je	ExecReadyJ		; M028

	mov	Exec_Func,AL

	or	al,al
	jne	scs1
	xchg	al, SS:[SCS_Is_Dos_Binary] ; get and reset the flag
;; if we already know the binary type(from command.com and GetNextCommand
;; just execute it
	or	al, al
	jne	scs1

	mov	ExecFlag, 1		;check new header
	call	get_binary_type 	;get the binary type
	jc	Exec_ret_err		;file read error ?
	cmp	al, 0ffh		;type unknown?
        jnz     exec_got_binary_type

; sudeepb ; This code support NTCMDPROMPT and DOSONLY commands of config.nt

        cmp     byte ptr ss:[SCS_CMDPROMPT],1
        jz      go_checkbin               ; means cmd prompt supported
        cmp     byte ptr ss:[SCS_DOSONLY],0
        jz      go_checkbin
        jmp     short scs1                ; means on command.com prompt we are
                                          ; suppose to disallow 32bit binaries

go_checkbin:
;; unknown bindary type found, ask NTVDM for help.
;;

	CMDSVC	SVC_CMDCHECKBINARY	; Check if the binary is 32bit

	; 32 bit binary handling added for SCS.
	; SVC_DEMCHECKBINARY will return updated ds:dx to point to
	; %COMSPEC% . ds:dx will be pointing to a scratch buffer
	; the address of which was passed to 32bit side at the time
	; of DOS initialization. SVC handler will also add /z switch to
	; command tail. If command tail does'nt have enough space to allow
	; adding /z, it will return error_not_enough_memory.

	;lds	SI,[SI.exec0_com_line]	; command line
	;mov	al,byte ptr ds:[si]
	;cmp	al,125			; 3 chars for /z<space>
	;pop	ax
	;jbe	scs1
	;mov	ax,error_not_enough_memory
	;jmp	Exec_Ret_Err

	jc	Exec_Ret_Err

scs1:
	mov	ExecFlag, 0			;don't check new header
	call	get_binary_type 		;get binary again
	jc	Exec_ret_err
exec_got_binary_type:
	mov	ExecFlag, al			;binary type
	mov	Exec_BlkL,BX		; stash args
	mov	Exec_BlkH,ES
	mov	Exec_Load_high,0
	mov	execNameL,DX		; set up length of exec name
	mov	execNameH,DS
	mov	SI,DX			; move pointer to convenient place
	invoke	DStrLen
	mov	ExecNameLen,CX		; save length

	mov	al, [AllocMethod]	; M063: save alloc method in
	mov	[AllocMsave], al	; M063: AllocMsave

Exec_Check_Environ:
	mov	Exec_Load_Block,0
	mov	Exec_Environ,0
					; overlays... no environment
	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jnz	Exec_Save_Start

	lds	SI,Exec_Blk		; get block
	mov	AX,[SI].Exec1_Environ	; address of environ
	or	AX,AX
	jnz	exec_scan_env

	mov	DS,CurrentPDB		;smr;SS Override
	mov	AX,DS:[PDB_environ]

;---------------------------------------------BUG 92 4/30/90-----------------
;
; Exec_environ is being correctly initialized after the environment has been
; allocated and copied form the parent's env. It must not be initialized here.
; Because if the call to $alloc below fails Exec_dealloc will deallocate the
; parent's environment.
;	mov	Exec_Environ,AX
;
;----------------------------------------------------------------------------

	or	AX,AX
	jz	Exec_Save_Start

Exec_Scan_Env:
	mov	ES,AX
	xor	DI,DI
	mov	CX,8000h		; at most 32k of environment ;M040
	xor	AL,AL

Exec_Get_Environ_Len:
	repnz	scasb			; find that nul byte
	jnz	BadEnv

	dec	CX			; Dec CX for the next nul byte test
	js	BadEnv			; gone beyond the end of the environment

	scasb				; is there another nul byte?
	jnz	Exec_Get_Environ_Len	; no, scan some more

	push	DI
	lea	BX,[DI+0Fh+2]
	add	BX,ExecNameLen		; BX <- length of environment
					; remember argv[0] length
					; round up and remember argc
	mov	CL,4
	shr	BX,CL			; number of paragraphs needed
	push	ES
	invoke	$Alloc			; can we get the space?
	pop	DS
	pop	CX
	jnc	Exec_Save_Environ

	jmp	SHORT Exec_No_Mem	; nope... cry and sob

Exec_Save_Environ:
	mov	ES,AX
	mov	Exec_Environ,AX 	; save him for a rainy day
	xor	SI,SI
	mov	DI,SI
	rep	movsb			; copy the environment
	mov	AX,1
	stosw
	lds	SI,ExecName
	mov	CX,ExecNameLen
	rep	movsb

Exec_Save_Start:
	Context DS
	cmp	ExecFlag, 0
	je	Exec_exe_file
	jmp	Exec_Com_File
Exec_exe_file:
	test	Exec_Max_BSS,-1 	; indicate load high?
	jnz	Exec_Check_Size

	mov	Exec_Load_High,-1
Exec_Check_Size:
	mov	AX,Exec_Pages		; get 512-byte pages	;rms;NSS
	mov	CL,5			; convert to paragraphs
	shl	AX,CL
	sub	AX,Exec_Par_Dir 	; AX = size in paragraphs;rms;NSS
	mov	Exec_Res_Len_Para,AX

		; Do we need to allocate memory?
		; Yes if function is not load-overlay

	test	BYTE PTR exec_func,exec_func_overlay
	jz	exec_allocate		; allocation of space

		; get load address from block

	les	DI,Exec_Blk
	mov	AX,ES:[DI].Exec3_Load_Addr
	mov	exec_dma,AX
	mov	AX,ES:[DI].Exec3_Reloc_Fac
	mov	Exec_Rel_Fac,AX

	jmp	Exec_Find_Res		; M000


BadEnv:
	mov	AL,ERROR_BAD_ENVIRONMENT
	jmp	Exec_Bomb

Exec_No_Mem:
	mov	AL,Error_Not_Enough_Memory
	jmp	SHORT Exec_Bomb

Exec_Bad_File:
	mov	AL,Error_Bad_Format

Exec_Bomb:
	ASSUME	DS:NOTHING,ES:NOTHING

	mov	BX,Exec_fh
	call	Exec_Dealloc
	LeaveCrit   CritMem
	save	<AX,BP>
	invoke	$CLOSE
	restore <BP,AX>
	jmp	Exec_Ret_Err


Exec_Chk_Mem:
		     			; M063 - Start
	mov	al, [AllocMethod]	; save current alloc method in ax
	mov	bl, [AllocMsave]
	mov	[AllocMethod], bl	; restore original allocmethod
	test	bl, HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
	jnz	Exec_No_Mem		; Y: no space in UMBs. Quit
					; N: continue

	test	al, HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	jz	Exec_No_Mem		; N: no memory
	mov	ax, [save_ax]		; Y: restore ax and
	jmp	short Exec_Norm_Alloc	;    Try again
					; M063 - End
	
Exec_Allocate:
	DOSAssume   <DS>,"exec_allocate"


		; M005 - START
		; If there is no STACK segment for this exe file and if this
		; not an overlay and the resident size is less than 64K -
		; 256 bytes we shall add 256bytes bytes to the programs
		; resident memory requirement and set Exec_SP to this value.

	mov	Exec_NoStack,0
	cmp	Exec_SS, 0		; Q: is there a stack seg
	jne	@f			; Y: continue normal processing
	cmp	Exec_SP, 0		; Q: is there a stack ptr
	jne	@f			; Y: continue normal processing

	inc	Exec_NoStack
	cmp	ax, 01000h-10h		; Q: is this >= 64K-256 bytes
	jae	@f			; Y: don't set Exec_SP

	add	ax, 010h		; add 10h paras to mem requirement
@@:

		; M005 - END

					; M000 - start
	test	byte ptr [AllocMethod], HIGH_FIRST
					; Q: is the alloc strat high_first
	jz	Exec_Norm_Alloc		; N: normal allocate
					; Y: set high_only bit
	or	byte ptr [AllocMethod], HIGH_ONLY
					; M000 - end

Exec_Norm_Alloc:

	mov	[save_ax], ax		; M000: save ax for possible 2nd
					; M000: attempt at allocating memory
;	push	ax			; M000

	mov	BX,0ffffh		; see how much room in arena
	push	DS
	invoke	$Alloc			; should have carry set and BX has max
	pop	DS

	mov	ax, [save_ax]		; M000
;	pop	AX			; M000

	add	AX,10h			; room for header
	cmp	BX,11h			; enough room for a header

	jb	Exec_Chk_Mem		; M000
;	jb	Exec_No_Mem		; M000


	cmp	AX,BX			; is there enough for bare image?

	ja	Exec_Chk_Mem		; M000
;	ja	Exec_No_Mem		; M000

	test	Exec_Load_High,-1	; if load high, use max
	jnz	Exec_BX_Max		; use max

	add	AX,Exec_Min_BSS 	; go for min allocation;rms;NSS

	jc	Exec_Chk_Mem		; M000
;	jc	Exec_No_Mem		; M000: oops! carry

	cmp	AX,BX			; enough space?

	ja	Exec_Chk_Mem		; M000: nope...	
;	ja	Exec_No_Mem		; M000: nope...


	sub	AX,Exec_Min_BSS 	; rms;NSS
	add	AX,Exec_Max_BSS 	; go for the MAX
	jc	Exec_BX_Max

	cmp	AX,BX
	jbe	Exec_Got_Block

Exec_BX_Max:
	mov	AX,BX

Exec_Got_Block:
	push	DS
	mov	BX,AX
	mov	exec_size,BX
	invoke	$Alloc			; get the space
	pop	DS

	ljc	exec_chk_mem		; M000

	mov	cl, [AllocMsave]	; M063:
	mov	[AllocMethod], cl	; M063: restore allocmethod


;M029; Begin changes
; This code does special handling for programs with no stack segment. If so,
;check if the current block is larger than 64K. If so, we do not modify
;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
;case Exec_SS is not changed.
;
	cmp	Exec_NoStack,0
	je	@f

	cmp	bx,1000h		; Q: >= 64K memory block
	jae	@f			; Y: Exec_SP = 0

;
;Make Exec_SP point at the top of the memory block
;
	mov	cl,4
	shl	bx,cl			; get byte offset
	sub	bx,100h			; take care of PSP
	mov	Exec_SP,bx		; Exec_SP = top of block
@@:
;
;M029; end changes
;

	mov	exec_load_block,AX
	add	AX,10h
	test	exec_load_high,-1
	jz	exec_use_ax		; use ax for load info

	add	AX,exec_size		; go to end
	sub	AX,exec_res_len_para	; drop off header
	sub	AX,10h			; drop off pdb

Exec_Use_AX:
	mov	Exec_Rel_Fac,AX 	; new segment
	mov	Exec_Dma,AX		; beginning of dma

		; Determine the location in the file of the beginning of
		; the resident

Exec_Find_Res:



	; Save info needed for bopping to debugger
	;	Exec_Res_Len contains len of image in bytes

	test	ss:[SCS_ISDEBUG],ISDBG_DEBUGGEE
	je	e_nodbg0

	mov	ax, Exec_Res_Len_Para
	mov	bx, ax
	mov	cl, 4
	shl	ax, cl
	mov	Exec_Res_LenL, ax
	mov	cl, 12
	shr	bx, cl
	mov	Exec_Res_LenH, bx
e_nodbg0:




	mov	DX, exec_dma
	mov	exec_dma_save, DX

	mov	DX,Exec_Par_Dir
	push	DX
	mov	CL,4
	shl	DX,CL			; low word of location
	pop	AX
	mov	CL,12
	shr	AX,CL			; high word of location
	mov	CX,AX			; CX <- high

		; Read in the resident image (first, seek to it)

	mov	BX,Exec_FH
	push	DS
	xor	AL,AL
	invoke	$Lseek			; Seek to resident
	pop	DS
	jnc	exec_big_read

	jmp	exec_bomb

Exec_Big_Read:				; Read resident into memory
	mov	BX,Exec_Res_Len_Para
	cmp	BX,1000h		; Too many bytes to read?
	jb	Exec_Read_OK

	mov	BX,0fe0h		; Max in one chunk FE00 bytes

Exec_Read_OK:
	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
	push	BX
	mov	CL,4
	shl	BX,CL			; Get count in bytes from paras
	mov	CX,BX			; Count in correct register
	push	DS
	mov	DS,Exec_DMA		; Set up read buffer

	ASSUME	DS:NOTHING

	xor	DX,DX
	push	CX			; Save our count
	call	ExecRead
	pop	CX			; Get old count to verify
	pop	DS
	jc	Exec_Bad_FileJ

	DOSAssume   <DS>,"exec_read_ok"

	cmp	CX,AX			; Did we read enough?
	pop	BX			; Get paragraph count back
	jz	ExecCheckEnd		; and do reloc if no more to read

		; The read did not match the request. If we are off by 512
		; bytes or more then the header lied and we have an error.

	sub	CX,AX
	cmp	CX,512
ifdef DBCS
	ja	Exec_Bad_FileJ
else ; !DBCS
	jae	Exec_Bad_FileJ
endif ; !DBCS

		; We've read in CX bytes... bump DTA location

ExecCheckEnd:
	add	Exec_DMA,BX		; Bump dma address
	test	Exec_Res_Len_Para,-1
	jnz	Exec_Big_Read
	
	; The image has now been read in. We must perform relocation
	; to the current location.

exec_do_reloc:
	mov	CX,Exec_Rel_Fac
	mov	AX,Exec_SS		; get initial SS ;rms;NSS
	add	AX,CX			; and relocate him
	mov	Exec_Init_SS,AX 	; rms;NSS

	mov	AX,Exec_SP		; initial SP ;rms;NSS
	mov	Exec_Init_SP,AX 	; rms;NSS



	les	AX,DWORD PTR exec_IP	; rms;NSS
	mov	Exec_Init_IP,AX 	; rms;NSS
	mov	AX,ES			; rms;NSS
	add	AX,CX			; relocated...
	mov	Exec_Init_CS,AX 	; rms;NSS

	xor	CX,CX
	mov	DX,Exec_RLE_Table	; rms;NSS
	mov	BX,Exec_FH
	push	DS
	xor	AX,AX
	invoke	$Lseek
	pop	DS

	jnc	Exec_Get_Entries

exec_bad_filej:
	jmp	Exec_Bad_File

exec_get_entries:
	mov	DX,Exec_RLE_Count	; Number of entries left ;rms;NSS

exec_read_reloc:
	ASSUME	DS:NOTHING

	push	DX
	mov	DX,OFFSET DOSDATA:Exec_Internal_Buffer
	mov	CX,((EXEC_INTERNAL_BUFFER_SIZE)/4)*4
	push	DS
	call	ExecRead
	pop	ES
	pop	DX
	jc	Exec_Bad_FileJ

	mov	CX,(EXEC_INTERNAL_BUFFER_SIZE)/4
					; Pointer to byte location in header
	mov	DI,OFFSET DOSDATA:exec_internal_buffer
	mov	SI,Exec_Rel_Fac 	; Relocate a single address

exec_reloc_one:
	or	DX,DX			; Any more entries?
	je	Exec_Set_PDBJ

exec_get_addr:
	lds	BX,DWORD PTR ES:[DI]	; Get ra/sa of entry
	mov	AX,DS			; Relocate address of item

;;;;;;	add	AX,SI
	add	AX, exec_dma_save

	mov	DS,AX
	add	[BX],SI
	add	DI,4
	dec	DX
	loop	Exec_Reloc_One		; End of internal buffer?

		; We've exhausted a single buffer's worth. Read in the next
		; piece of the relocation table.

	push	ES
	pop	DS
	jmp	Exec_Read_Reloc

Exec_Set_PDBJ:

		;
		; We now determine if this is a buggy exe packed file and if
		; so we patch in the right code. Note that fixexepatch will
		; point to a ret if dos loads low. The load segment as
		; determined above will be in exec_dma_save
		;

	push	es
	push	ax			; M030
	push	cx			; M030
	mov	es, exec_dma_save
	mov	ax, exec_init_CS	; M030
	mov	cx, exec_init_IP	; M030
	call	word ptr [fixexepatch]
	pop	cx			; M030
	pop	ax			; M030
	pop	es

	jmp	Exec_Set_PDB

Exec_No_Memj:
	jmp	Exec_No_Mem

		; we have a .COM file.	First, determine if we are merely
		; loading an overlay.

Exec_Com_File:
	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jz	Exec_Alloc_Com_File
	lds	SI,Exec_Blk		; get arg block
	lodsw				; get load address
	mov	Exec_DMA,AX
;;williamh change BEGIN
;; this instruction is commentted out because it doesn't work under
;; NT(we may have invalid address space within(Exec_DMA:0 + Exec_DMA:0xffff)
;;
;;;;;;	mov	AX,0ffffh
;; figure out the bare image size
	mov	bx, Exec_FH		;the file handle
	xor	cx, cx
	mov	dx, cx
	mov	ax, 2
	invoke	$Lseek			;move file to the end
	mov	Exec_ComOverlay, 1	;we are loading COM file as an overlay
;;williamh change END
	jmp	SHORT Exec_Read_Block	; read it all!


			
Exec_Chk_Com_Mem:			
		     			; M063 - Start
	mov	al, [AllocMethod]	; save current alloc method in ax
	mov	bl, [AllocMsave]
	mov	[AllocMethod], bl	; restore original allocmethod
	test	bl, HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
	jnz	Exec_No_Memj		; Y: no space in UMBs. Quit
					; N: continue

	test	al, HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	jz	Exec_No_Memj		; N: no memory

	mov	ax, exec_load_block	; M047: ax = block we just allocated	
	xor	bx, bx			; M047: bx => free arena
	call	ChangeOwner		; M047: free this block

	jmp	short Exec_Norm_Com_Alloc
					; M063 - End
	
		; We must allocate the max possible size block (ick!)
		; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
		; size of block.

Exec_Alloc_Com_File:
					; M000 -start
	test	byte ptr [AllocMethod], HIGH_FIRST
					; Q: is the alloc strat high_first
	jz	Exec_Norm_Com_Alloc	; N: normal allocate
					; Y: set high_only bit
	or	byte ptr [AllocMethod], HIGH_ONLY
					; M000 - end


Exec_Norm_Com_Alloc:			; M000

	mov	BX,0FFFFh
	invoke	$Alloc			; largest piece available as error
	or	BX,BX

	jz	Exec_Chk_Com_Mem	; M000
;	jz	Exec_No_Memj		; M000

	mov	Exec_Size,BX		; save size of allocation block
	push	BX
	invoke	$ALLOC			; largest piece available as error
	pop	BX			; get size of block...
	mov	Exec_Load_Block,AX
	add	AX,10h			; increment for header
	mov	Exec_DMA,AX
	xor	AX,AX			; presume 64K read...
	cmp	BX,1000h		; 64k or more in block?
	jae	Exec_Read_Com		; yes, read only 64k

	mov	AX,BX			; convert size to bytes
	mov	CL,4
	shl	AX,CL
	cmp	AX,100h 		; enough memory for PSP?

	jbe	Exec_Chk_Com_Mem	; M000: jump if not
;	jbe	Exec_No_Memj		; M000: jump if not

					; M047: size of the block is < 64K
	sub	ax, 100h		; M047: reserve 256 bytes for stack

Exec_Read_Com:
	sub	AX,100h 		; remember size of psp

Exec_Read_Block:
	push	AX			; save number to read
	mov	BX,Exec_FH		; of com file
	xor	CX,CX			; but seek to 0:0
	mov	DX,CX
	xor	AX,AX			; seek relative to beginning
	invoke	$Lseek			; back to beginning of file
	pop	CX			; number to read
	mov	DS,Exec_DMA
	xor	DX,DX
	push	CX
	call	ExecRead
	pop	SI			; get number of bytes to read
	jnc	OkRead

	jmp	Exec_Bad_File

OkRead:
;; williamh change BEGIN
	cmp	Exec_ComOverlay, 0
	jne	OkLoad
;; williamh change END

	cmp	AX,SI			; did we read them all?

	ljz	Exec_Chk_Com_Mem	; M00: exactly the wrong number...no
;	ljz	Exec_No_Memj		; M00: exactly the wrong number...

;;williamh change BEGIN
OkLoad:
;;williamh change END

	test	ss:[SCS_ISDEBUG],ISDBG_DEBUGGEE
	je	e_nodbg1


	; Save info needed for bopping to debugger
	;	Exec_Res_Len contains len of image
	;	Exec_Rel_Fac contains start addr\reloc factor
	;
	push	ax
	mov	Exec_Res_LenL, ax
	mov	Exec_Res_LenH, 0
	mov	ax, Exec_DMA
	mov	Exec_Rel_Fac, ax
	pop	ax
e_nodbg1:

	mov	bl, [AllocMsave]	; M063
	mov	[AllocMethod], bl	; M063: restore allocmethod

	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jnz	Exec_Set_PDB		; no starto, chumo!

	mov	AX,Exec_DMA
	sub	AX,10h
	mov	Exec_Init_CS,AX
	mov	Exec_Init_IP,100h	; initial IP is 100

		; SI is AT MOST FF00h.	Add FE to account for PSP - word
		; of 0 on stack.

	add	SI,0feh 		; make room for stack

	cmp	si, 0fffeh		; M047: Q: was there >= 64K available
	je	Exec_St_Ok		; M047: Y: stack is fine
	add	si, 100h		; M047: N: add the xtra 100h for stack

Exec_St_Ok:
	mov	Exec_Init_SP,SI 	; max value for read is also SP!;smr;SS Override
	mov	Exec_Init_SS,AX 				;smr;SS Override
	mov	DS,AX
	mov	WORD PTR [SI],0 	; 0 for return

	;
	; M068
	;
	; We now determine if this is a Copy Protected App. If so the
	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a
	; a ret if DOS is loaded low. Also DS contains the load segment.

	call	word ptr [ChkCopyProt]

Exec_Set_PDB:
	mov	BX,Exec_FH		; we are finished with the file.
	call	Exec_Dealloc
	push	BP
	invoke	$Close			; release the jfn
	pop	BP
	call	Exec_Alloc

	test	ss:[SCS_ISDEBUG],ISDBG_DEBUGGEE
	je	e_nodbg2
	SAVEREG <ax,bx,dx,di>
	; bop to debugger for all ExeTypes to signal LOAD symbols
	; BX	 - Start Address or relocation factor
	; DX:AX  - Size of exe resident image
	; ES:DI  - Name of exe image
        cmp     ExecFlag, 0
        je      Exec_sym_exe_file
        mov     bx, WORD PTR Exec_Load_Block
        jmp     Exec_sym
Exec_sym_exe_file:
	mov	bx, WORD PTR Exec_Rel_Fac
Exec_sym:
	mov	dx, Exec_Res_LenH
	mov	ax, Exec_Res_LenL
	les	di, ExecName

	SVC	SVC_DEMLOADDOSAPPSYM
	RESTOREREG <di,dx,bx,ax>
e_nodbg2:

	test	BYTE PTR Exec_Func,EXEC_FUNC_OVERLAY
	jz	Exec_Build_Header

	call	Scan_Execname
	call	Scan_Special_Entries

;SR;
;The current lie strategy uses the PSP to store the lie version. However,
;device drivers are loaded as overlays and have no PSP. To handle them, we
;use the Sysinit flag provided by the BIOS as part of a structure pointed at
;by BiosDataPtr. If this flag is set, the overlay call has been issued from
;Sysinit and therefore must be a device driver load. We then get the lie
;version for this driver and put it into the Sysinit PSP. When the driver
;issues the version check, it gets the lie version until the next overlay
;call is issued.
;
	cmp	DriverLoad,0		;was Sysinit processing done?
	je	norm_ovl		;yes, no special handling
	push	si
	push	es
	les	si,BiosDataPtr		;get ptr to BIOS data block
	cmp	byte ptr es:[si],0		;in Sysinit?
	je	sysinit_done		;no, Sysinit is finished

	mov	es,CurrentPDB		;es = current PSP (Sysinit PSP)
	push	Special_Version
	pop	es:PDB_Version		;store lie version in Sysinit PSP
	jmp	short setver_done
sysinit_done:
	mov	DriverLoad,0		;Sysinit done,special handling off
setver_done:
	pop	es
	pop	si
norm_ovl:

	leave
	transfer    Sys_Ret_OK		; overlay load -> done

Exec_Build_Header:

	mov	DX,Exec_Load_Block
					; assign the space to the process
	mov	SI,Arena_Owner		; pointer to owner field
	mov	AX,Exec_Environ 	; get environ pointer
	or	AX,AX
	jz	No_Owner		; no environment

	dec	AX			; point to header
	mov	DS,AX
	mov	[SI],DX 		; assign ownership

No_Owner:
	mov	AX,Exec_Load_Block	; get load block pointer
	dec	AX
	mov	DS,AX			; point to header
	mov	[SI],DX 		; assign ownership

	push	DS			;AN000;MS. make ES=DS
	pop	ES			;AN000;MS.
	mov	DI,Arena_Name		;AN000;MS. ES:DI points to destination
	call	Scan_Execname		;AN007;MS. parse execname
					;	   ds:si->name, cx=name length
	push	CX			;AN007;;MS. save for fake version
	push	SI			;AN007;;MS. save for fake version

MoveName:				;AN000;
	lodsb				;AN000;;MS. get char
	cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
	jz	Mem_Done		;AN000;;MS. no, move to header
					;AN000;
	stosb				;AN000;;MS. move char
					; MSKK bug fix - limit length copied
	cmp	di,16			; end of memory arena block?
	jae	mem_done		; jump if so

	loop	movename		;AN000;;MS. continue
Mem_Done:				;AN000;
	xor	AL,AL			;AN000;;MS. make ASCIIZ
	cmp	DI,SIZE ARENA		;AN000;MS. if not all filled
	jae	Fill8			;AN000;MS.

	stosb				;AN000;MS.

Fill8:					;AN000;
	pop	SI			;AN007;MS. ds:si -> file name
	pop	CX			;AN007;MS.

	call	Scan_Special_Entries	;AN007;MS.

	push	DX
	mov	SI,exec_size
	add	SI,DX
        push    ax
        mov     ax,1
        call    set_exec_bit
        pop     ax
	Invoke	$Dup_PDB		; ES is now PDB
        push    ax
        xor     ax,ax
        call    set_exec_bit
        pop     ax
	pop	DX

	push	exec_environ
	pop	ES:[PDB_environ]
					; *** Added for DOS 5.00
					; version number in PSP
 	push	[Special_Version]	; Set the DOS version number to
	pop	ES:[PDB_Version]	; to be used for this application

					; set up proper command line stuff
	lds	SI,Exec_Blk		; get the block
	push	DS			; save its location
	push	SI
	lds	SI,[SI.EXEC0_5C_FCB]	; get the 5c fcb

		; DS points to user space 5C FCB

	mov	CX,12			; copy drive, name and ext
	push	CX
	mov	DI,5Ch
	mov	BL,[SI]
	rep	movsb

		; DI = 5Ch + 12 = 5Ch + 0Ch = 68h

	xor	AX,AX			; zero extent, etc for CPM
	stosw
	stosw

		; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch

	pop	CX
	pop	SI			; get block
	pop	DS
	push	DS			; save (again)
	push	SI
	lds	SI,[SI.exec0_6C_FCB]	; get 6C FCB

		; DS points to user space 6C FCB

	mov	BH,[SI] 		; do same as above
	rep	movsb
	stosw
	stosw
	pop	SI			; get block (last time)
	pop	DS
	lds	SI,[SI.exec0_com_line]	; command line

		; DS points to user space 80 command line

	or	CL,80h
	mov	DI,CX
	rep	movsb			; Wham!

		; Process BX into default AX (validity of drive specs on args).
		; We no longer care about DS:SI.

	dec	CL			; get 0FFh in CL
	mov	AL,BH
	xor	BH,BH
	invoke	GetVisDrv
	jnc	Exec_BL

	mov	BH,CL

Exec_BL:
	mov	AL,BL
	xor	BL,BL
	invoke	GetVisDrv
	jnc	exec_Set_Return

	mov	BL,CL

Exec_Set_Return:
	invoke	get_user_stack		; get his return address
	push	[SI.user_CS]		; take out the CS and IP
	push	[SI.user_IP]
	push	[SI.user_CS]		; take out the CS and IP
	push	[SI.user_IP]
	pop	WORD PTR ES:[PDB_Exit]
	pop	WORD PTR ES:[PDB_Exit+2]
	xor	AX,AX
	mov	DS,AX
					; save them where we can get them
					; later when the child exits.
	pop	DS:[ADDR_INT_TERMINATE]
	pop	DS:[ADDR_INT_TERMINATE+2]
	mov	WORD PTR DMAADD,80h	; SS Override
	mov	DS,CurrentPDB		; SS Override
	mov	WORD PTR DMAADD+2,DS	; SS Override
	test	BYTE PTR exec_func,exec_func_no_execute
	jz	exec_go

	lds	SI,DWORD PTR Exec_Init_SP ; get stack SS Override
	les	DI,Exec_Blk		; and block for return
	mov	ES:[DI].EXEC1_SS,DS	; return SS

	dec	SI			; 'push' default AX
	dec	SI
	mov	[SI],BX 		; save default AX reg
	mov	ES:[DI].Exec1_SP,SI	; return 'SP'

	lds	AX,DWORD PTR Exec_Init_IP ; SS Override
	mov	ES:[DI].Exec1_CS,DS	; initial entry stuff

	mov	ES:[DI].Exec1_IP,AX
	leave
	transfer Sys_Ret_OK

exec_go:
ifdef NEC_98
        call    EMS_MNT                 ; restore page frame status
endif   ;NEC_98
	lds	SI,DWORD PTR Exec_Init_IP   ; get entry point SS Override
	les	DI,DWORD PTR Exec_Init_SP   ; new stack SS Override
	mov	AX,ES

	cmp	[DosHasHMA], 0		; Q: is dos in HMA (M021)
	je	Xfer_To_User		; N: transfer control to user

	push	ds			; Y: control must go to low mem stub	
	getdseg	<ds>			;    where we disable a20 and Xfer
					;    control to user

	or	[DOS_FLAG], EXECA20OFF	; M068:
					; M004: Set bit to signal int 21
					; ah = 25 & ah= 49. See dossym.inc
					; under TAG M003 & M009 for
					; explanation
	mov	[A20OFF_PSP], dx	; M068: set the PSP for which A20 is
					; M068: going to be turned OFF.

	mov	ax, ds			; ax = segment of low mem stub
	pop	ds
	assume	ds:nothing

	push	ax			; ret far into the low mem stub
	mov	ax, OFFSET Disa20_Xfer
	push	ax
	mov	AX,ES			; restore ax
	retf

Xfer_To_User:



		; DS:SI points to entry point
		; AX:DI points to initial stack
		; DX has PDB pointer
                ; BX has initial AX value

        SVC     SVC_DEMENTRYDOSAPP


        invoke  DOCLI
	mov	BYTE PTR InDos,0	; SS Override

	ASSUME	SS:NOTHING

	mov	SS,AX			; set up user's stack
	mov	SP,DI			; and SP
        STI                             ; took out DOSTI as SP may be bad

	push	DS			; fake long call to entry
	push	SI
	mov	ES,DX			; set up proper seg registers
	mov	DS,DX
	mov	AX,BX			; set up proper AX

	retf

EndProc $Exec

; =========================================================================
;
; =========================================================================

Procedure   ExecRead,NEAR
	CALL	exec_dealloc
	MOV	bx,exec_fh
	PUSH	BP
	invoke	$READ
	POP	BP
	CALL	exec_alloc
	return
EndProc ExecRead

; =========================================================================
;
; =========================================================================

procedure   exec_dealloc,near

	push	    BX
	.errnz	    arena_owner_system
	sub	    BX,BX		; (bx) = ARENA_OWNER_SYSTEM
	EnterCrit   CritMEM
	call	    ChangeOwners
	pop	    BX
	return

EndProc exec_dealloc

; =========================================================================
;
; =========================================================================

procedure   exec_alloc,near
	ASSUME	SS:DOSDATA

	push	    BX
	mov	    BX,CurrentPDB	; SS Override
	call	    ChangeOwners
	LeaveCrit   CritMEM
	pop	    BX
	return

EndProc exec_alloc

; =========================================================================
;
; =========================================================================

PROCEDURE   ChangeOwners,NEAR

	push	AX
        lahf
	push	AX
	mov	AX,exec_environ
	call	ChangeOwner
	mov	AX,exec_load_block
	call	ChangeOwner
        pop     AX
        sahf
        pop     ax
	return

ENDPROC ChangeOwners

; =========================================================================
;
; =========================================================================

PROCEDURE   ChangeOwner,NEAR

	or	AX,AX			; is area allocated?
	retz				; no, do nothing
	dec	AX
	push	DS
	mov	DS,AX
	mov	DS:[ARENA_OWNER],BX
	pop	DS
	return

EndProc ChangeOwner

; =========================================================================
;
; =========================================================================

Procedure	Scan_Execname,near
	ASSUME	SS:DosData

	lds	SI,ExecName		; DS:SI points to name
Entry	Scan_Execname1			; M028
Save_Begin:				;
	mov	CX,SI			; CX= starting addr
Scan0:					;
	lodsb				; get char

IFDEF	DBCS		 		; MSKK01 07/14/89
	invoke	TESTKANJ		; Is Character lead byte of DBCS?
	jz	@F			; jump if not
	lodsb				; skip over DBCS character
	jmp	short scan0		; do scan again
@@:
ENDIF

	cmp	AL,':'			; is ':' , may be A:name
	jz	save_begin		; yes, save si
	cmp	AL,'\'                  ; is '\', may be A:\name
	jz	save_begin		; yes, save si
	cmp	AL,0			; is end of name
	jnz	scan0			; no, continue scanning
	sub	SI,CX			; get name's length
	xchg	SI,CX			; cx= length, si= starting addr

	return

EndProc Scan_Execname

; =========================================================================
;
; =========================================================================

Procedure    Scan_Special_Entries,near
	assume	SS:DOSDATA

	dec	CX			; cx= name length
;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
					;reset to current version
	mov    [Special_Version],(Minor_Version SHL 8) + Major_Version
;***	call	Reset_Version

;M060	push	SS
;M060	pop	ES

	les	DI,SS:UU_IFS_DOS_CALL	;M060; ES:DI --> Table in SETVER.SYS
	mov	AX,ES			;M060; First do a NULL ptr check to
	or	AX,DI			;M060; be sure the table exists
	jz	End_List		;M060; If ZR then no table

GetEntries:
	mov	AL,ES:[DI]		; end of list
	or	AL,AL
	jz	End_List		; yes

	mov	[Temp_Var2],DI		; save di
	cmp	AL,CL			; same length ?
	jnz	SkipOne 		; no

	inc	DI			; es:di -> special name
	push	CX			; save length and name addr
	push	SI

;
; M050 - BEGIN
;
	push	ax			; save len
sse_next_char:
	lodsb
IFDEF	DBCS                ; MSKK01 09/29/93
        invoke   TESTKANJ       ; Is Character lead byte of DBCS?
        jz ucase_it             ; jump if not
        scasb                   ; put into user's buffer
        lodsb                   ; skip over DBCS character
        jne     Not_Matched
        dec     cx

        jmp short skip_ucase    ; skip upcase
ucase_it:
ENDIF
	call	UCase
IFDEF   DBCS
skip_ucase:
ENDIF
	scasb
	jne	Not_Matched
	loop	sse_next_char
	
;
;	repz	cmpsb			; same name ?
;
;	jnz	Not_Matched		; no
;
	pop	ax			; take len off the stack
;
; M050 - END
;
	mov	AX,ES:[DI]		; get special version
	mov	[Special_Version],AX	; save it

;***	mov	AL,ES:[DI+2]		; get fake count
;***	mov	[Fake_Count],AL 	; save it

	pop	SI
	pop	CX
	jmp	SHORT end_list

Not_Matched:
	pop	ax			; get len from stack ; M050
	pop	SI			; restore si,cx
	pop	CX

SkipOne:
	mov	DI,[Temp_Var2]		; restore old di use SS Override
	xor	AH,AH			; position to next entry
	add	DI,AX

	add	DI,3			; DI -> next entry length
;***	add	DI,4			; DI -> next entry length

	jmp	Getentries

End_List:
	return

EndProc Scan_Special_Entries

; =========================================================================
;
; =========================================================================
;
;Procedure    Reset_Version,near
;	assume	SS:DOSDATA
;
;	cmp    [Fake_Count],0ffh
;	jnz    @F
;	mov    [Special_Version],0	;reset to current version
;@@:
;	return
;
;EndProc Reset_Version,near

PAGE
; =========================================================================
;SUBTTL Terminate and stay resident handler
;
; Input:    DX is  an  offset  from  CurrentPDB  at which to
;	    truncate the current block.
;
; output:   The current block is truncated (expanded) to be [DX+15]/16
;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
;	    and restoring the vectors.
;
; =========================================================================
PROCEDURE $Keep_process ,NEAR
	ASSUME DS:NOTHING,ES:NOTHING,SS:DosData

	push	AX			; keep exit code around
	mov	BYTE PTR Exit_type,EXIT_KEEP_PROCESS
	mov	BYTE PTR SCS_TSR,1
	mov	ES,CurrentPDB
	cmp	DX,6h			; keep enough space around for system
	jae	Keep_shrink		; info

	mov	DX,6h

Keep_Shrink:
	mov	BX,DX
	push	BX
	push	ES
	invoke	$SETBLOCK		; ignore return codes.
	pop	DS
	pop	BX
	jc	keep_done		; failed on modification

	mov	AX,DS
	add	AX,BX
	mov	DS:PDB_block_len,AX	;PBUGBUG

Keep_Done:
	pop	AX
	jmp	SHORT exit_inner	; and let abort take care of the rest

EndProc $Keep_process

; =========================================================================
;
; =========================================================================

PROCEDURE Stay_Resident,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	mov	AX,(Keep_process SHL 8) + 0 ; Lower part is return code;PBUGBUG
	add	DX,15
	rcr	DX,1
	mov	CL,3
	shr	DX,CL

	transfer    COMMAND

ENDPROC Stay_resident


PAGE
; =========================================================================
;SUBTTL $EXIT - return to parent process
;   Assembler usage:
;	    MOV     AL, code
;	    MOV     AH, Exit
;	    INT     int_command
;   Error return:
;	    None.
;
; =========================================================================

PROCEDURE   $Exit ,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING,SS:DosData

	xor	AH,AH
	xchg	AH,BYTE PTR DidCtrlC
	or	AH,AH
	mov	BYTE PTR Exit_Type,EXIT_TERMINATE
	jz	exit_inner
	mov	BYTE PTR Exit_type,exit_ctrl_c

	entry	Exit_inner

	invoke	get_user_stack		;PBUGBUG

	ASSUME DS:NOTHING

	push	CurrentPDB
	pop	[SI.User_CS]		;PBUGBUG
	jmp	SHORT Abort_Inner

EndProc $EXIT

BREAK <$ABORT -- Terminate a process>
; =========================================================================
; Inputs:
;	user_CS:00 must point to valid program header block
; Function:
;	Restore terminate and Cntrl-C addresses, flush buffers and transfer to
;	the terminate address
; Returns:
;	TO THE TERMINATE ADDRESS
; =========================================================================

PROCEDURE   $Abort ,NEAR
	ASSUME	DS:NOTHING,ES:NOTHING	;PBUGBUG

	xor	AL,AL
	mov	exit_type,exit_abort

		; abort_inner must have AL set as the exit code! The exit type
		; is retrieved from exit_type. Also, the PDB at user_CS needs
		; to be correct as the one that is terminating.

	PUBLIC	Abort_Inner
Abort_Inner:

	mov	AH,Exit_Type
	mov	Exit_Code,AX

	test	ss:[SCS_ISDEBUG],ISDBG_DEBUGGEE
	je	Abt_EndBopFree

	test	ah, EXIT_KEEP_PROCESS ; no unload, tsr staying in memory
	jnz	Abt_EndBopFree

	; go to end of env (double NULL)
	; get address of exe image name
	mov	es, CurrentPDB
        mov     ax, es:PDB_environ
        or      ax, ax
        jz      Abt_EndBopFree          ; krnl386 sets PDB_environ to NULL
        mov     es, ax                  ; for WOW tasks, it's already notified debugger
	xor	di, di
	xor	al, al
	mov	cx, 8000h		; at most 32k of environment
	cld

Abt_SearchName:
	repnz	scasb			; look for null byte
	jnz	Abt_EndBopFree		; end not found, give up
	dec	cx			; Dec CX for the next nul byte test
	jz	Abt_EndBopFree		; end not found, give up
	scasb				; is there another nul byte?
	jnz	Abt_SearchName		; no, scan some more

        mov     ax, word ptr es:[di]    ; word after double-null must be 0x1
        dec     ax                      ; s/b zero now
        jnz     Abt_EndBopFree

        ; adv di past 0x1
	dec	cx
	jcxz	Abt_EndBopFree
	inc	di
	dec	cx
	jcxz	Abt_EndBopFree
	inc	di

	; es:di points to FullyQualiedFileName of this exe image
	; Bop to debugger, to notify Free Symbols
	SVC	SVC_DEMFREEDOSAPPSYM

Abt_EndBopFree:

	invoke	Get_User_Stack

	ASSUME DS:NOTHING

	mov	DS,[SI.User_CS]	; set up old interrupts ;PBUGBUG
	xor	AX,AX
	mov	ES,AX
	mov	SI,SavExit
	mov	DI,Addr_Int_Terminate
	movsw
	movsw
	movsw
	movsw
	movsw
	movsw
	transfer reset_environment

ENDPROC $ABORT

;==========================================================================
;
; fixexepatch will poin to this is DOS loads low.
;
;=========================================================================
retexepatch	proc	near
	
	ret

retexepatch     endp

set_exec_bit proc
        push    ds
        or      ax,ax
        mov     ax,40h
        mov     ds,ax
        jz      seb_clear
        lock    or  word ptr ds:[FIXED_NTVDMSTATE_REL40],  EXEC_BIT_MASK
        jmp     short seb_done
seb_clear:
        lock    and word ptr ds:[FIXED_NTVDMSTATE_REL40], NOT EXEC_BIT_MASK
seb_done:
        pop     ds
        ret
set_exec_bit endp

;===========================================================================
;determine the given binary type
;   input: ds:dx = lpszExecName
;	      ExecFlag = 1 if new header checking is necessary
;	      ExecFlag = 0 if new header checking is not necessary
;   output: CY -> file opening/reading error, (AL) has error code
;	    else
;		(AL) = 0 if .exe file, Exec_Fh contains the file handle
;		(AL) = 1 if .com file, Exec_Fh contains the file handle
;		(AL) = 0ffh if unknown
;
;   modified: AX, CX
;
;   note: use the caller's local var frame(addressed by BP)
;===========================================================================
get_binary_type proc

ExecSignature_NE	equ	"EN"	    ;; signature for win16 or os/2 bound
ExecSignature_PE	equ	"EP"	    ;; nt image
ExecSignature_LE	equ	"EL"	    ;; os/2

	push	ds
	push	es
	push	bx
	push	dx
	xor	AL,AL			; open for reading
	push	BP

	or	[DOS_FLAG], EXECOPEN	; this flag is set to indicate to
					; the redir that this open call is
					; due to an exec.
	invoke	$OPEN			; is the file there?

; sudeepb 22-Dec-1992 removed a costly pair of pushf/popf
	push	ax
	lahf
	and	[DOS_FLAG], not EXECOPEN; reset flag
	sahf
	pop	ax

	pop	BP
	jc	GBT_jmp_exit		;can not find the file

	mov	Exec_Fh,AX		;save the file handle
	mov	BX,AX
	xor	AL,AL
	invoke	$Ioctl
	jc	GBT_Bomb

	test	DL,DEVID_ISDEV
	jz	GBT_check_header

	mov	AL,ERROR_FILE_NOT_FOUND
	jmp	GBT_bomb

GBT_Bad_File:
	mov	AL,Error_Bad_Format
GBT_Bomb:
	push	BP
	invoke	$CLOSE
	pop	bp
	stc
GBT_jmp_exit:
	jmp	GBT_exit

GBT_check_header:
	Context DS
	mov	CX,Exec_Header_Len	; old header size
	cmp	ExecFlag, 0
	je	GBT_read_header
	mov	cx, Exec_Header_Len_NE
GBT_read_header:
	mov	DX,OFFSET DosData:Exec_Signature
	push	ES
	push	DS
	push	BP
	invoke	$READ
	pop	bp
	pop	DS
	pop	ES
	jc	GBT_Bad_File

	or	AX,AX
	jz	GBT_Bad_File
	cmp	AX,EXEC_HEADER_LEN	; at least the size should be this size
	jl	GBT_com_file		; if no, it is a .com file

	mov	CX,Exec_Signature	; get the singnature from the file
	cmp	CX,Exe_Valid_Signature	;
	jz	GBT_check_new_header	; assume com file if no signature

	cmp	CX,exe_valid_Old_Signature  ; ???????????????????
	jne	GBT_com_file		; assume com file if no signature

GBT_check_new_header:
	cmp	ExecFlag, 0
	je	GBT_exe_file
	cmp	ax, Exec_header_len_NE	;if we don't read in what we expect,
	jne	GBT_exe_file		; it is an ordinary dos exe
	mov	cx, Exec_NE_offset	;get the offset to the new header
	jcxz	GBT_exe_file		;if no new header at all, it is a dos exe
	mov	dx, cx
	xor	cx, cx
	xor	ax, ax
	push	ds
	push	bp
	invoke	$lseek			;move file pointer
	pop	bp
	pop	ds
	mov	bx, Exec_Fh
	lea	dx, ExecWord	;read the first two bytes from new header
	mov	cx, 2
	push	BP
	push	ds
	call	$READ
	pop	ds
	pop	bp
	jc	GBT_exe_file
	cmp	ax, 2
	jne	GBT_exe_file
	mov	ax, ExecWord
	cmp	ax, ExecSignature_NE	;win16, os/2 bound ?
	je	GBT_unknown
	cmp	ax, ExecSignature_PE	;nt?
	je	GBT_unknown
	cmp	ax, ExecSignature_LE	;os/2?
	je	GBT_unknown

GBT_exe_file:
	mov	al, 0
	clc
	jmp	short GBT_Exit


GBT_com_file:
	mov	al, 1
	clc
	jmp	short GBT_exit

GBT_unknown:
	push	bp
	call	$CLOSE
	pop	bp
	mov	al, 0ffh
	clc
GBT_Exit:
	pop	dx
	pop	bx
	pop	es
	pop	ds
	ret

get_binary_type endp
; =========================================================================

DOSCODE	ENDS

; =========================================================================

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\parse.asm ===
TITLE PARSE - Parsing system calls for MS-DOS
	NAME  PARSE


; System calls for parsing command lines
;
;   $PARSE_FILE_DESCRIPTOR
;
;   Modification history:
;
;       Created: ARR 30 March 1983
;               EE PathParse 10 Sept 1983
;

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	.cref
	.list


DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE

BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
;---------------------------------------------------------------------------
; Inputs:
;       DS:SI Points to a command line
;       ES:DI Points to an empty FCB
;       Bit 0 of AL = 1 At most one leading separator scanned off
;                   = 0 Parse stops if separator encountered
;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
;                   = 0  "    "    "     "         "      "  - put 0 in FCB
;       Bit 2 of AL = 1 If filename field blank - leave FCB
;                   = 0  "       "      "       - put blanks in FCB
;       Bit 3 of AL = 1 If extension field blank - leave FCB
;                   = 0  "       "      "        - put blanks in FCB
; Function:
;       Parse command line into FCB
; Returns:
;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
;       DS:SI points to first character after filename
;---------------------------------------------------------------------------

	procedure   $PARSE_FILE_DESCRIPTOR,NEAR
ASSUME  DS:NOTHING,ES:NOTHING

	invoke  MAKEFCB
	PUSH    SI
	invoke  get_user_stack
	POP     [SI.user_SI]
	return
EndProc $PARSE_FILE_DESCRIPTOR


DOSCODE    ENDS
    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\mssw.asm ===
;	SCCSID = @(#)ibmsw.asm	1.1 85/04/10


IBM		EQU	ibmver
WANG		EQU	FALSE

; Set this switch to cause DOS to move itself to the end of memory
HIGHMEM EQU	FALSE

; Turn on switch below to allow testing disk code with DEBUG. It sets
; up a different stack for disk I/O (functions > 11) than that used for
; character I/O which effectively makes the DOS re-entrant.

	IF	IBM
ESCCH	EQU	0			; character to begin escape seq.
CANCEL	EQU	27			;Cancel with escape
TOGLPRN EQU	TRUE			;One key toggles printer echo
ZEROEXT EQU	TRUE
	ELSE
ESCCH	EQU	1BH
CANCEL	EQU	"X"-"@" 		;Cancel with Ctrl-X
TOGLPRN EQU	FALSE			;Separate keys for printer echo on
					;and off
ZEROEXT EQU	TRUE
	ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\mstable.asm ===
;       SCCSID = @(#)ibmtable.asm       1.1 85/04/10
;
; Table Segment for DOS
;

.xlist
.xcref
include version.inc
include mssw.asm
.cref
.list

TITLE   IBMTABLE - Table segment for DOS
NAME    IBMTABLE

;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1991
;       All Rights Reserved.
;

; ==========================================================================



;**     MS_TABLE.ASM
;
;       Revision history:
;         A000   version 4.0  Jan. 1988
;         A001   DCR 486 - Share installation for >32mb drives
;         A006   DCR 503 - fake version for IBMCACHE
;         A008   PTM 4070 - fake version for MS WINDOWS
;         M006   Fake Version call no longer supported. 8/6/90

        .xlist
        .xcref
        include version.inc
        include dosseg.inc
        include fastopen.inc
        include dossym.inc
        include syscall.inc
        .cref
        .list

        AsmVars <Debug, Redirector, ShareF>

DOSCODE SEGMENT

TableZero   LABEL   BYTE

        PUBLIC  MSVERS
PUBLIC MSTAB001s,MSTAB001e
MSTAB001S       label byte

MSVERS  EQU     THIS WORD               ; MS-DOS version in hex for $GET_VERSION
MSMAJOR DB      MAJOR_VERSION
MSMINOR DB      MINOR_VERSION

;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
;        I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
;        I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]

;
; This is the error code mapping table for INT 21 errors.  This table defines
; those error codes which are "allowed" for each system call.  If the error
; code ABOUT to be returned is not "allowed" for the call, the correct action
; is to return the "real" error via Extended error, and one of the allowed
; errors on the actual call.
;
; The table is organized as follows:
;
;    Each entry in the table is of variable size, but the first
;       two bytes are always:
;
;       Call#,Cnt of bytes following this byte
;
; EXAMPLE:
;       Call 61 (OPEN)
;
;       DB      61,5,12,3,2,4,5
;
;       61 is the AH INT 21 call value for OPEN.
;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
;       Next five bytes are those error codes which are "allowed" on OPEN.
;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
;       this case 5).  The last value will be the one returned on the call if
;       the "real" error is not one of the allowed ones.
;
; There are a number of calls (for instance all of the FCB calls) for which
;   there is NO entry.  This means that NO error codes are returned on this
;   call, so set up an Extended error and leave the current error code alone.
;
; The table is terminated by a call value of 0FFh

PUBLIC  I21_MAP_E_TAB
I21_MAP_E_TAB   LABEL   BYTE
    DB  International,2,error_invalid_function,error_file_not_found
    DB  MKDir,3,error_path_not_found,error_file_not_found,error_access_denied
    DB  RMDir,4,error_current_directory,error_path_not_found
    DB          error_file_not_found,error_access_denied
    DB  CHDir,2,error_file_not_found,error_path_not_found
    DB  Creat,4,error_path_not_found,error_file_not_found
    DB          error_too_many_open_files
    DB          error_access_denied
    DB  Open,6,error_path_not_found,error_file_not_found,error_invalid_access
    DB          error_too_many_open_files
    DB          error_not_dos_disk,error_access_denied
    DB  Close,1,error_invalid_handle
    DB  Read,2,error_invalid_handle,error_access_denied
    DB  Write,2,error_invalid_handle,error_access_denied
    DB  Unlink,3,error_path_not_found,error_file_not_found,error_access_denied
    DB  LSeek,2,error_invalid_handle,error_invalid_function
    DB  CHMod,4,error_path_not_found,error_file_not_found,error_invalid_function
    DB          error_access_denied
    DB  IOCtl,5,error_invalid_drive,error_invalid_data,error_invalid_function
    DB          error_invalid_handle,error_access_denied
    DB  XDup,2,error_invalid_handle,error_too_many_open_files
    DB  XDup2,2,error_invalid_handle,error_too_many_open_files
    DB  Current_Dir,2,error_not_DOS_disk,error_invalid_drive
    DB  Alloc,2,error_arena_trashed,error_not_enough_memory
    DB  Dealloc,2,error_arena_trashed,error_invalid_block
    DB  Setblock,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
    DB  Exec,8,error_path_not_found,error_invalid_function,error_file_not_found
    DB          error_too_many_open_files,error_bad_format,error_bad_environment
    DB          error_not_enough_memory,error_access_denied
    DB  Find_First,3,error_path_not_found,error_file_not_found,error_no_more_files
    DB  Find_Next,1,error_no_more_files
    DB  Rename,5,error_not_same_device,error_path_not_found,error_file_not_found
    DB          error_current_directory,error_access_denied
    DB  File_Times,4,error_invalid_handle,error_not_enough_memory
    DB               error_invalid_data,error_invalid_function
    DB  AllocOper,1,error_invalid_function
    DB  CreateTempFile,4,error_path_not_found,error_file_not_found
    DB          error_too_many_open_files,error_access_denied
    DB  CreateNewFile,5,error_file_exists,error_path_not_found
    DB          error_file_not_found,error_too_many_open_files,error_access_denied
;   DB  LockOper,4,error_invalid_handle,error_invalid_function
;   DB   error_sharing_buffer_exceeded,error_lock_violation
    DB  GetExtCntry,2,error_invalid_function,error_file_not_found       ;DOS 3.3
    DB  GetSetCdPg,2,error_invalid_function,error_file_not_found        ;DOS 3.3
    DB  Commit,1,error_invalid_handle                                   ;DOS 3.3
    DB  ExtHandle,3,error_too_many_open_files,error_not_enough_memory
    DB              error_invalid_function
    DB  ExtOpen,10
    DB    error_path_not_found,error_file_not_found,error_invalid_access
    DB          error_too_many_open_files,error_file_exists,error_not_enough_memory
    DB          error_not_dos_disk,error_invalid_data
    DB              error_invalid_function,error_access_denied
    DB  GetSetMediaID,4,error_invalid_drive,error_invalid_data
    DB          error_invalid_function,error_access_denied
    DB  0FFh


        PUBLIC  DISPATCH

;MAXCALL        EQU      VAL1
;MAXCOM         EQU      VAL2

; Standard Functions
DISPATCH    LABEL WORD
        short_addr  $ABORT                          ;  0      0
        short_addr  $STD_CON_INPUT                  ;  1      1
        short_addr  $STD_CON_OUTPUT                 ;  2      2
        short_addr  $STD_AUX_INPUT                  ;  3      3
        short_addr  $STD_AUX_OUTPUT                 ;  4      4
        short_addr  $STD_PRINTER_OUTPUT             ;  5      5
        short_addr  $RAW_CON_IO                     ;  6      6
        short_addr  $RAW_CON_INPUT                  ;  7      7
        short_addr  $STD_CON_INPUT_NO_ECHO          ;  8      8
        short_addr  $STD_CON_STRING_OUTPUT          ;  9      9
        short_addr  $STD_CON_STRING_INPUT           ; 10      A
        short_addr  $STD_CON_INPUT_STATUS           ; 11      B
        short_addr  $STD_CON_INPUT_FLUSH            ; 12      C
        short_addr  $DISK_RESET                     ; 13      D
        short_addr  $SET_DEFAULT_DRIVE              ; 14      E
        short_addr  $FCB_OPEN                       ; 15      F
        short_addr  $FCB_CLOSE                      ; 16     10
        short_addr  $DIR_SEARCH_FIRST               ; 17     11
        short_addr  $DIR_SEARCH_NEXT                ; 18     12
        short_addr  $FCB_DELETE                     ; 19     13
        short_addr  $FCB_SEQ_READ                   ; 20     14
        short_addr  $FCB_SEQ_WRITE                  ; 21     15
        short_addr  $FCB_CREATE                     ; 22     16
        short_addr  $FCB_RENAME                     ; 23     17
        short_addr  NO_OP                           ; 24     18
        short_addr  $GET_DEFAULT_DRIVE              ; 25     19
        short_addr  $SET_DMA                        ; 26     1A

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $SLEAZEFUNC                     ; 27     1B
        short_addr  $SLEAZEFUNCDL                   ; 28     1C
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

        short_addr  NO_OP                           ; 29     1D
        short_addr  NO_OP                           ; 30     1E
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $GET_DEFAULT_DPB                ; 31     1F
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  NO_OP                           ; 32     20
        short_addr  $FCB_RANDOM_READ                ; 33     21
        short_addr  $FCB_RANDOM_WRITE               ; 34     22
        short_addr  $GET_FCB_FILE_LENGTH            ; 35     23
        short_addr  $GET_FCB_POSITION               ; 36     24


VAL1    =       ($-DISPATCH)/2 - 1

        PUBLIC  MAXCALL
MaxCall = VAL1

; Extended Functions
        short_addr  $SET_INTERRUPT_VECTOR           ; 37     25
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $CREATE_PROCESS_DATA_BLOCK      ; 38     26
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $FCB_RANDOM_READ_BLOCK          ; 39     27
        short_addr  $FCB_RANDOM_WRITE_BLOCK         ; 40     28
        short_addr  $PARSE_FILE_DESCRIPTOR          ; 41     29
        short_addr  $GET_DATE                       ; 42     2A
        short_addr  $SET_DATE                       ; 43     2B
        short_addr  $GET_TIME                       ; 44     2C
        short_addr  $SET_TIME                       ; 45     2D
        short_addr  $SET_VERIFY_ON_WRITE            ; 46     2E

; Extended functionality group
        short_addr  $GET_DMA                        ; 47     2F
        short_addr  $GET_VERSION                    ; 48     30
        short_addr  $Keep_Process                   ; 49     31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $GET_DPB                        ; 50     32
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $SET_CTRL_C_TRAPPING            ; 51     33
        short_addr  $GET_INDOS_FLAG                 ; 52     34
        short_addr  $GET_INTERRUPT_VECTOR           ; 53     35
        short_addr  $GET_DRIVE_FREESPACE            ; 54     36
        short_addr  $CHAR_OPER                      ; 55     37
        short_addr  $INTERNATIONAL                  ; 56     38
; XENIX CALLS
;   Directory Group
        short_addr  $MKDIR                          ; 57     39
        short_addr  $RMDIR                          ; 58     3A
        short_addr  $CHDIR                          ; 59     3B
;   File Group
        short_addr  $CREAT                          ; 60     3C
        short_addr  $OPEN                           ; 61     3D
        short_addr  $CLOSE                          ; 62     3E
        short_addr  $READ                           ; 63     3F
        short_addr  $WRITE                          ; 64     40
        short_addr  $UNLINK                         ; 65     41
        short_addr  $LSEEK                          ; 66     42
        short_addr  $CHMOD                          ; 67     43
        short_addr  $IOCTL                          ; 68     44
        short_addr  $DUP                            ; 69     45
        short_addr  $DUP2                           ; 70     46
        short_addr  $CURRENT_DIR                    ; 71     47
;    Memory Group
        short_addr  $ALLOC                          ; 72     48
        short_addr  $DEALLOC                        ; 73     49
        short_addr  $SETBLOCK                       ; 74     4A
;    Process Group
        short_addr  $EXEC                           ; 75     4B
        short_addr  $EXIT                           ; 76     4C
        short_addr  $WAIT                           ; 77     4D
        short_addr  $FIND_FIRST                     ; 78     4E
;   Special Group
        short_addr  $FIND_NEXT                      ; 79     4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $SET_CURRENT_PDB                ; 80     50
        short_addr  $GET_CURRENT_PDB                ; 81     51
        short_addr  $GET_IN_VARS                    ; 82     52
        short_addr  $SETDPB                         ; 83     53
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $GET_VERIFY_ON_WRITE            ; 84     54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $DUP_PDB                        ; 85     55
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $RENAME                         ; 86     56
        short_addr  $FILE_TIMES                     ; 87     57
        short_addr  $AllocOper                      ; 88     58
; Network extention system calls
        short_addr  $GetExtendedError               ; 89     59
        short_addr  $CreateTempFile                 ; 90     5A
        short_addr  $CreateNewFile                  ; 91     5B
        short_addr  $LockOper                       ; 92     5C
        short_addr  $ServerCall                     ; 93     5D
        short_addr  $UserOper                       ; 94     5E
        short_addr  $AssignOper                     ; 95     5F
        short_addr  $NameTrans                      ; 96     60
        short_addr  NO_OP                           ; 97     61
        short_addr  $Get_Current_PDB                ; 98     62
; the next call is reserved for hangool sys call
        short_addr  $ECS_Call                       ; 99     63
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  $Set_Printer_Flag               ; 100    64
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $GetExtCntry                    ; 101    65
        short_addr  $GetSetCdPg                     ; 102    66
        short_addr  $ExtHandle                      ; 103    67
        short_addr  $Commit                         ; 104    68
        short_addr  $GSetMediaID                    ; 105    69   ;AN000;
        short_addr  $Commit                         ; 106    6A   ;AN000;
        short_addr  NO_OP                           ; 107    6B
                                                    ; IFS_IOCTL no longer
                                                    ; supported
        short_addr  $Extended_Open                  ; 108    6C   ;AN000;

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
ifdef ROMEXEC
        short_addr  $ROM_FIND_FIRST                 ; 109    6D
        short_addr  $ROM_FIND_NEXT                  ; 110    6E
else
        short_addr  NO_OP                           ; 109    6d
        short_addr  NO_OP                           ; 110    6e

endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

        short_addr  NO_OP                           ; 111    6f
        short_addr  NO_OP                           ; 112    70
        short_addr  $LongFileNameAPI                ; 113    71


VAL2    =       ($-DISPATCH)/2 - 1

        PUBLIC  MAXCOM
MaxCom  =       VAL2

        If      Installed

PUBLIC FOO
FOO     LABEL WORD
        Short_addr  Leave2F
DTab    DW  OFFSET  DOSCODE:DOSTable
        PUBLIC FOO,DTAB

; BUGBUG sudeepb 15-Mar-1991 All the NO_OP below are to be scrutinized

DOSTable    LABEL   WORD
        DB      (DOSTableEnd-DOSTable-1)/2
        Short_addr  DOSInstall          ;   0 install check
        Short_addr  NO_OP               ;   1   DOS_CLOSE
        Short_addr  RECSET              ;   2   RECSET
        Short_addr  DOSGetGroup         ;   3   Get DOSGROUP
        Short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
        Short_addr  OUTT                ;   5   OUT
        Short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
        Short_addr  NO_OP               ;   7   PLACEBUF
        Short_addr  FREE_SFT            ;   8   FREE_SFT
        Short_addr  NO_OP               ;   9   BUFWRITE
        Short_addr  NO_OP               ;        10  SHARE_VIOLATION
        Short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
        Short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
        Short_addr  NO_OP               ;   13  DATE16
        Short_addr  idle                ;   14      empty slot
        Short_addr  NO_OP               ;   15  SCANPLACE
        Short_addr  idle                ;   16      empty slot
        Short_addr  StrCpy              ;   17  StrCpy
        Short_addr  StrLen              ;   18  StrLen
        Short_addr  Ucase               ;   19  Ucase
        Short_addr  NO_OP               ;   20  POINTCOMP
        Short_addr  NO_OP               ;   21  CHECKFLUSH
        Short_addr  SFFromSFN           ;   22  SFFromSFN
        Short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
        Short_addr  Get_User_Stack      ;   24  Get_User_Stack
        Short_addr  GetThisDrv          ;   25  GetThisDrv
        Short_addr  DriveFromText       ;   26  DriveFromText
        Short_addr  NO_OP               ;   27  SETYEAR
        Short_addr  NO_OP               ;   28  DSUM
        Short_addr  NO_OP               ;   29  DSLIDE
        Short_addr  StrCmp              ;   30  StrCmp
        Short_addr  InitCDS             ;   31  initcds
        Short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
        Short_addr  $NameTrans          ;   33  $NameTrans
        Short_addr  CAL_LK              ;   34  CAL_LK
        Short_addr  DEVNAME             ;   35  DEVNAME
        Short_addr  Idle                ;   36  Idle
        Short_addr  DStrLen             ;   37  DStrLen
        Short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
        Short_addr  $CLOSE              ;   39  $CLOSE        DOS 3.3
        Short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
        Short_addr  $READ               ;   41  $READ         DOS 3.3
        Short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
        Short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
        Short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
        Short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
        Short_addr  MSG_RETRIEVAL       ;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;

        Short_addr  NO_OP               ;   M006: 47  no longer supported
;***       Short_addr  Fake_Version     ;   47  Fake_Version  DOS 4.0  ;AN006;

DOSTableEnd LABEL   BYTE

        ENDIF

; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
;       module. The reason is so that the data alignments are the same in
;       IBM-DOS and MS-DOS up through header.


        PUBLIC  HEADER
Header  LABEL   BYTE
        IF      DEBUG
        DB      13,10,"Debugging DOS version "
        DB      MAJOR_VERSION + "0"
        DB      "."
        DB      (MINOR_VERSION / 10) + "0"
        DB      (MINOR_VERSION MOD 10) + "0"
        ENDIF

        IF      NOT IBM
ifndef NEC_98
        DB      13,10,"MS-DOS version "
else    ;NEC_98
        DB      "$",10,"MS-DOS version "
endif   ;NEC_98
        DB      MAJOR_VERSION + "0"
        DB      "."
        DB      (MINOR_VERSION / 10) + "0"
        DB      (MINOR_VERSION MOD 10) + "0"

        IF      HIGHMEM
        DB      "H"
        ENDIF

        DB      13,10, "Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
        ENDIF

IF DEBUG
        DB      13,10,"$"
ENDIF

MSTAB001E       label byte

include copyrigh.inc


DOSCODE   ENDS

; ==========================================================================

        END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\open.asm ===
TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
	NAME	DOS_OPEN

;**	OPEN.ASM - File Open
;
;	Low level routines for openning a file from a file spec.
;	Also misc routines for sharing errors
;
;	DOS_Open
;	Check_Access_AX
;	SHARE_ERROR
;	SET_SFT_MODE
;	Code_Page_Mismatched_Error		   ; DOS 4.00
;
;	Revision history:
;
;	    Created: ARR 30 March 1983
;	    A000	version 4.00   Jan. 1988
;
;	M034 - The value in save_bx must be pushed on to the stack for
; 	       remote extended opens and not save_cx.
;
;	M035 - if open made from exec then we must set the appropriate bits
;	       on the stack before calling off to the redir.
;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
;	       to handle open from exec. In this case set the appropriate bit
;	       else do not.
	

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include fastopen.inc
	include fastxxxx.inc
	include sf.inc
	include mult.inc
	include filemode.inc
	include curdir.inc

	.cref
	.list

Installed = TRUE

	i_need	NoSetDir,BYTE
	i_need	THISSFT,DWORD
	i_need	THISCDS,DWORD
	i_need	CURBUF,DWORD
	i_need	CurrentPDB,WORD
	i_need	CURR_DIR_END,WORD
	I_need	RetryCount,WORD
	I_need	Open_Access,BYTE
	I_need	fSharing,BYTE
	i_need	JShare,DWORD
	I_need	FastOpenFlg,byte
	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
	I_need	SAVE_BX,WORD			  ;M034
	i_need	DEVPT,DWORD

	I_need	DOS_FLAG,BYTE
	I_need	DOS34_FLAG,WORD			  ;M042



DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

Break	<DOS_Open - internal file access>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_Open
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[THISSFT] Points to SFT to fill in if file found
;		(sf_mode field set so that FCB may be detected)
;	[SATTRIB] Is attribute of search, determines what files can be found
;	AX is Access and Sharing mode
;	  High NIBBLE of AL (Sharing Mode)
;		sharing_compat	   file is opened in compatibility mode
;		sharing_deny_none  file is opened Multi reader, Multi writer
;		sharing_deny_read  file is opened Only reader, Multi writer
;		sharing_deny_write file is opened Multi reader, Only writer
;		sharing_deny_both  file is opened Only reader, Only writer
;	  Low NIBBLE of AL (Access Mode)
;		open_for_read	file is opened for reading
;		open_for_write	file is opened for writing
;		open_for_both	file is opened for both reading and writing.
;
;	  For FCB SFTs AL should = sharing_compat + open_for_both
;		(not checked)
; Function:
;	Try to open the specified file
; Outputs:
;	sf_ref_count is NOT altered
;	CARRY CLEAR
;	    THISSFT filled in.
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_invalid_access
;			Bad sharing mode or bad access mode or bad combination
;		error_access_denied
;			Attempt to open read only file for writting, or
;			open a directory
;		error_sharing_violation
;			The sharing mode was correct but not allowed
;			generates an INT 24 on compatibility mode SFTs
; DS preserved, others destroyed
;----------------------------------------------------------------------------

procedure   DOS_Open,NEAR

	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 

	DOSAssume   <DS>,"DOS_Open"

	MOV	[NoSetDir],0
	CALL	Check_Access_AX
	retc
	LES	DI,[THISSFT]
	XOR	AH,AH

	; sleaze! move only access/sharing mode in.  Leave sf_isFCB unchanged

	MOV	BYTE PTR ES:[DI.sf_mode],AL ; For moment do this on FCBs too

LOCAL_OPEN:
        ; sudeepb - we rely on the fact that DEVPT is pointing to the right
        ; device header as set by TransPath in $open.

        push    ds
	lds	si,dword ptr [DEVPT]
	mov	word ptr es:[di.sf_devptr],si
	mov	word ptr es:[di.sf_devptr+2],ds
        mov     bl,byte ptr ds:[si.sdevatt]
        or      bl,0c0H
        and     bl,not 020h
        OR      bl,devid_file_clean
        mov     byte ptr es:[di.sf_flags],bl
	pop	ds
	MOV	AX,[CurrentPDB]
	MOV	ES:[DI.sf_PID],AX
	xor	ax,ax
	mov	byte ptr es:[di.sf_attr],al
	mov	word ptr es:[di.sf_size],ax
	mov	word ptr es:[di.sf_size+2],ax
	mov	word ptr es:[di.sf_time],ax
	mov	word ptr es:[di.sf_date],ax
	mov	word ptr es:[di.sf_position],ax
	mov	word ptr es:[di.sf_position+2],ax
	invoke	DEV_OPEN_SFT
	return

EndProc DOS_Open,NoCheck

procedure   DOS_Open_Checks,NEAR

	DOSAssume   <DS>,"DOS_Open"

	MOV	[NoSetDir],0
	CALL	Check_Access_AX
	JC	ret_label		    ; retc
	LES	DI,[THISSFT]
	XOR	AH,AH

	; sleaze! move only access/sharing mode in.  Leave sf_isFCB unchanged

	MOV	BYTE PTR ES:[DI.sf_mode],AL ; For moment do this on FCBs too
	CLC
ret_label:
	return				    ;FT.				;AN000;
EndProc DOS_Open_Checks,NoCheck

;---------------------------------------------------------------------------
; DOS_Create, DOS_CreateNEW
;
; These are dummy procedures and no body calls them. They are just used
; to make life easy in $open to dispatch to right SVC.
;

PROCEDURE DOS_CREATE_NEW,NEAR
    ret
ENDPROC DOS_CREATE_NEW

PROCEDURE DOS_CREATE,NEAR
    ret
ENDPROC DOS_CREATE

;----------------------------------------------------------------------------
; Procedure Name : SET_SFT_MODE
;
; Finish SFT initialization for new reference.	Set the correct mode.
;
;   Inputs:
;	ThisSFT points to SFT
;
;   Outputs:
;	Carry clear
;   Registers modified: AX.
;---------------------------------------------------------------------------

;hkn; called from create. DS already set up to DOSDATA.

PROCEDURE Set_SFT_Mode,NEAR

	DOSAssume   <DS>,"Set_SFT_Mode"
	LES	DI,ThisSFT
	invoke	DEV_OPEN_SFT
	TEST	ES:[DI.sf_mode],sf_isfcb; Clears carry
	JZ	Clear_FastOpen		; sf_mode correct (retz)
	MOV	AX,[CurrentPDB]
	MOV	ES:[DI.sf_PID],AX	; For FCB sf_PID=PDB

Clear_FastOpen:
	return			       ;;;;; DOS 3.3

ENDPROC Set_SFT_MODE

;----------------------------------------------------------------------------
;
; Procedure Name : SHARE_ERROR
;
; Called on sharing violations. ES:DI points to SFT. AX has error code
; If SFT is FCB or compatibility mode gens INT 24 error.
; Returns carry set AX=error_sharing_violation if user says ignore (can't
; really ignore).  Carry clear
; if user wants a retry. ES, DI, DS preserved
;---------------------------------------------------------------------------

procedure SHARE_ERROR,NEAR
	DOSAssume   <DS>,"Share_Error"
; BUGBUG sudeep 15-Mar-1991 Sharing errors to be handled

	ifdef NTDOS
	TEST	ES:[DI.sf_mode],sf_isfcb
	JNZ	HARD_ERR
	MOV	CL,BYTE PTR ES:[DI.sf_mode]
	AND	CL,sharing_mask
	CMP	CL,sharing_compat
	JNE	NO_HARD_ERR
HARD_ERR:
	invoke	SHARE_VIOLATION
	retnc				; User wants retry
NO_HARD_ERR:
	MOV	AX,error_sharing_violation
	STC
	return
else
	int 3
	return
endif

EndProc SHARE_ERROR

;----------------------------------------------------------------------------
;
; Procedure Name : DO_SHARE_CHECK
;
; Input: THISDPB, WFP_Start, THISSFT set
; Functions: check file sharing mode is valid
; Output: carry set, error
;	  carry clear, share ok
;----------------------------------------------------------------------------

procedure DO_SHARE_CHECK,NEAR
	DOSAssume   <DS>,"DO_SHARE__CHECK"
; BUGBUG sudeep 15-Mar-1991 Sharing errors to be handled
ifdef NTDOS
OPN_RETRY:
	MOV	CX,RetryCount		; Get # tries to do
OpenShareRetry:
	SAVE	<CX>			; Save number left to do
	invoke	SHARE_CHECK		; Final Check
	RESTORE <CX>		; CX = # left
	JNC	Share_Ok2		; No problem with access
	Invoke	Idle
	LOOP	OpenShareRetry		; One more retry used up
OpenShareFail:
	LES	DI,[ThisSft]
	invoke	SHARE_ERROR
	JNC	OPN_RETRY		; User wants more retry
Share_Ok2:
	return
else
	int 3
	return
endif

EndProc DO_SHARE_CHECK

;-----------------------------------------------------------------------------
;
; Procedure Name : Check_Access
;
; Inputs:
;	AX is mode
;	  High NIBBLE of AL (Sharing Mode)
;		sharing_compat	   file is opened in compatibility mode
;		sharing_deny_none  file is opened Multi reader, Multi writer
;		sharing_deny_read  file is opened Only reader, Multi writer
;		sharing_deny_write file is opened Multi reader, Only writer
;		sharing_deny_both  file is opened Only reader, Only writer
;	  Low NIBBLE of AL (Access Mode)
;		open_for_read	file is opened for reading
;		open_for_write	file is opened for writing
;		open_for_both	file is opened for both reading and writing.
; Function:
;	Check this access mode for correctness
; Outputs:
;	[open_access] = AL input
;	Carry Clear
;		Mode is correct
;		AX unchanged
;	Carry Set
;		Mode is bad
;		AX = error_invalid_access
; No other registers effected
;----------------------------------------------------------------------------

procedure Check_Access_AX
	DOSAssume   <DS>,"Check_Access"

	MOV	Open_Access,AL
	PUSH	BX

;	If sharing, then test for special sharing mode for FCBs

	MOV	BL,AL
	AND	BL,sharing_mask
	CMP	fSharing,-1
	JNZ	CheckShareMode		; not through server call, must be ok
	CMP	BL,sharing_NET_FCB
	JZ	CheckAccessMode 	; yes, we have an FCB
CheckShareMode:
	CMP	BL,40h			; is this a good sharing mode?
	JA	Make_Bad_Access
CheckAccessMode:
	MOV	BL,AL
	AND	BL,access_mask
	CMP	BL,2
	JA	Make_Bad_Access
	POP	BX
	CLC
	return

make_bad_access:
	MOV	AX,error_invalid_access
	POP	BX
	STC
	return

EndProc Check_Access_AX


DOSCODE	ENDS
	END



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\search.asm ===
TITLE	SEARCH - Directory scan system calls
	NAME	SEARCH

;**	Search.asm
;
;	Directory search system calls.	These will be passed direct text of the
;	pathname from the user.  They will need to be passed through the macro
;	expander prior to being sent through the low-level stuff.  I/O specs are
;	defined in DISPATCH.	The system calls are:
;
;
;	$Dir_Search_First	  written
;	$Dir_Search_Next	  written
;	$Find_First	  written
;	$Find_Next		  written
;	PackName		  written
;
;	Modification history:
;
;	  Created: ARR 4 April 1983


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	INCLUDE fastopen.inc
	INCLUDE fastxxxx.inc
	include dossvc.inc
	.cref
	.list


	i_need	SEARCHBUF,53
	i_need	SATTRIB,BYTE
	I_Need	OpenBuf,128
	I_need	DMAAdd,DWORD
	I_need	THISFCB,DWORD
	I_need	CurDrv,BYTE
	I_need	EXTFCB,BYTE
	I_need	Fastopenflg,BYTE
	I_need	DOS34_FLAG,WORD
	I_Need	WFP_Start,WORD

DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	EXTRN	TransFCB:NEAR
	EXTRN	TransPathSet:NEAR

;----------------------------------------------------------------------------
; Procedure Name : $DIR_SEARCH_FIRST
;
; Inputs:
;	DS:DX Points to unopenned FCB
; Function:
;	Directory is searched for first matching entry and the directory
;	entry is loaded at the disk transfer address
; Returns:
;	AL = -1 if no entries matched, otherwise 0
;----------------------------------------------------------------------------

procedure $DIR_SEARCH_FIRST,NEAR
	ASSUME CS:DOSCODE,SS:DOSDATA
	MOV	WORD PTR THISFCB,DX
	MOV	WORD PTR THISFCB+2,DS
	MOV	SI,DX
	CMP	BYTE PTR [SI],0FFH
	JNZ	NORMFCB4
	ADD	SI,7			; Point to drive select byte
NORMFCB4:
	SAVE	<[SI]>			; Save original drive byte for later

	Context ES			; get es to address DOSGroup

	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer
	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
	JNC	SearchIt		; no error, go and look
	RESTORE <BX>			; Clean stack

	transfer FCB_Ret_Err		; error code in AX

SearchIt:

	Context DS			; get ready for search
	push	DS
	pop	ds
	mov	al,[EXTFCB]
	mov	dl,[SAttrib]
	mov	si, OFFSET DOSDATA:SEARCHBUF	; Return all the info here
	mov	di, OFFSET DOSDATA:OpenBuf	; Full path
	HRDSVC	SVC_DEMFINDFIRSTFCB
	JNC	SearchSet		; no error, transfer info
	RESTORE <BX>			; Clean stack

	transfer FCB_Ret_Err		; Error Code is in AX

; The search was successful (or the search-next).  We store the information
; into the user's FCB for continuation.

SearchSet:

	MOV	SI,OFFSET DOSDATA:SEARCHBUF
	LES	DI,THISFCB		; point to the FCB
	TEST	EXTFCB,0FFH		;
	JZ	NORMFCB1
	ADD	DI,7			; Point past the extension
NORMFCB1:
	RESTORE <BX>			; Get original drive byte
	OR	BL,BL
	JNZ	SearchDrv
	MOV	BL,CurDrv
	INC	BL
SearchDrv:
	INC	SI
;	LODSB				; Get correct search contin drive byte
;	XCHG	AL,BL			; Search byte to BL, user byte to AL
	INC	DI
;	STOSB				; Store the correct "user" drive byte
					;  at the start of the search info
;	MOV	CX,20/2
;	REP	MOVSW			; Rest of search cont info, SI -> entry
	add	di,20
	add	si,20
	mov	al,bl
;	XCHG	AL,BL			; User drive byte back to BL, search
					;   byte to AL
	STOSB				; Search contin drive byte at end of
					;   contin info
; Sudeepb : This "dec si" is a hack to overcome the problem
; dword alignment in DEm DLL of SRCHBUF.
	dec	si
	LES	DI,DMAAdd
	TEST	EXTFCB,0FFH
	JZ	NORMFCB2
	MOV	AL,0FFH
	STOSB
	INC	AL
	MOV	CX,5
	REP	STOSB
	MOV	AL,SATTRIB
	STOSB
NORMFCB2:
	MOV	AL,BL			; User Drive byte
	STOSB
 IFDEF  DBCS									;AN000;
	MOVSW				; 2/13/KK				;AN000;
	CMP	BYTE PTR ES:[DI-2],5	; 2/13/KK				;AN000;
	JNZ	NOTKTRAN		; 2/13/KK				;AN000;
	MOV	BYTE PTR ES:[DI-2],0E5H ; 2/13/KK				;AN000;
NOTKTRAN:				; 2/13/KK				;AN000;
	MOV	CX,15			; 2/13/KK				;AN000;
 ELSE										;AN000;
	MOV	CX,16			; 32 / 2 words of dir entry		;AN000;
 ENDIF										;AN000;
	REP	MOVSW
	transfer FCB_Ret_OK

EndProc $DIR_SEARCH_FIRST, NoCheck

;----------------------------------------------------------------------------
;
; Procedure Name : $DIR_SEARCH_NEXT
;
; Inputs:
;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
; Function:
;	Directory is searched for the next matching entry and the directory
;	entry is loaded at the disk transfer address
; Returns:
;	AL = -1 if no entries matched, otherwise 0
;----------------------------------------------------------------------------

procedure $DIR_SEARCH_NEXT,NEAR

	ASSUME	CS:DOSCODE,SS:DOSDATA

	MOV	WORD PTR THISFCB,DX
	MOV	WORD PTR THISFCB+2,DS
	MOV	SATTRIB,0
	MOV	EXTFCB,0

	Context ES

	MOV	DI,OFFSET DOSDATA:SEARCHBUF

	MOV	SI,DX
	CMP	BYTE PTR [SI],0FFH
	JNZ	NORMFCB6
	ADD	SI,6
	LODSB

	MOV	SATTRIB,AL
	DEC	EXTFCB
NORMFCB6:
	LODSB				; Get original user drive byte
	SAVE	<AX>			; Put it on stack
	MOV	AL,[SI+20]		; Get correct search contin drive byte
	STOSB				; Put in correct place
	MOV	CX,20/2
	REP	MOVSW			; Transfer in rest of search contin info

	Context DS

	mov	al,[EXTFCB]
	mov	dl,[SAttrib]
	mov	si, OFFSET DOSDATA:SEARCHBUF	; Return all the info here
	HRDSVC	SVC_DEMFINDNEXTFCB	; Find next match
	JC	SearchNoMore
	JMP	SearchSet		; Ok set return

SearchNoMore:
	LES	DI,THISFCB
	TEST	EXTFCB,0FFH
	JZ	NORMFCB8
	ADD	DI,7			; Point past the extension
NORMFCB8:
	RESTORE <BX>			; Get original drive byte
	MOV	ES:[DI],BL		; Store the correct "user" drive byte
					;  at the right spot
	transfer FCB_Ret_Err		; Error code in ax

EndProc $DIR_SEARCH_NEXT

;---------------------------------------------------------------------------
;
;   Procedure Name : $FIND_FIRST
; 
;   Assembler usage:
;	    MOV AH, FindFirst
;	    LDS DX, name
;	    MOV CX, attr
;	    INT 21h
;	; DMA address has datablock
;
;   Error Returns:
;	    AX = error_path_not_found
;	       = error_no_more_files
;---------------------------------------------------------------------------

procedure $FIND_FIRST,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA
	SAVE	<CX>
	MOV	SI,DX			; get name in appropriate place

	MOV	SATTRIB,CL		; Search attribute to correct loc

	MOV	DI,OFFSET DOSDATA:OpenBuf  ; appropriate buffer

	call	TransPathSet		; convert the path
	RESTORE <CX>
	JNC	Find_it 		; no error, go and look
FindError:

	error	error_path_not_found	; error and map into one.
Find_it:

	Context DS
	mov	dx,wfp_start
	HRDSVC	SVC_DEMFINDFIRST
	JNC	FindSet 		; no error, transfer info
	transfer Sys_Ret_Err
FindSet:
; BUGBUG Sudeepb 15-sept-91 This xor ax,ax is done for the PageMaker 4.0
; which trusts ax value more than carry even for success cases.
	xor	ax,ax
	transfer    Sys_Ret_OK		; bye with no errors
EndProc $FIND_FIRST


;---------------------------------------------------------------------------
;
;   Procedure Name : $FIND_NEXT
;
;   Assembler usage:
;	; dma points at area returned by find_first
;	    MOV AH, findnext
;	    INT 21h
;	; next entry is at dma
;
;   Error Returns:
;	    AX = error_no_more_files
;---------------------------------------------------------------------------

procedure $FIND_NEXT,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	HRDSVC	SVC_DEMFINDNEXT
	jnc	fnok
	transfer Sys_Ret_Err
fnok:
; BUGBUG 13-Jun-1992 Jonle  This xor ax,ax is done for list.com,
; sidekick which trusts ax value more than carry even for success cases.
	xor	ax,ax
        transfer    Sys_Ret_OK          ; bye with no errors

EndProc $FIND_NEXT

	Break	<PackName - convert file names from FCB to ASCIZ>


;**	PackName - Convert name to ASCIZ format.
;
;	PackName transfers a file name from DS:SI to ES:DI and converts it to
;	the ASCIZ format.
;
;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
;		(ES:DI) = destination area (13 bytes)
;	EXIT	(ds:SI) and (es:DI) advancedn
;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)

Procedure PackName,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;	Move over 8 characters to cover the name component, then trim it's
;	trailing blanks.

	MOV	CX,8			; Pack the name
	REP	MOVSB			; Move all of it
main_kill_tail:
	CMP	BYTE PTR ES:[DI-1]," "
	JNZ	find_check_dot
	DEC	DI			; Back up over trailing space
	INC	CX
	CMP	CX,8
	JB	main_kill_tail
find_check_dot:
	CMP	WORD PTR [SI],(" " SHL 8) OR " "
	JNZ	got_ext 		; Some chars in extension
	CMP	BYTE PTR [SI+2]," "
	JZ	find_done		; No extension
got_ext:
	MOV	AL,"."
	STOSB
	MOV	CX,3
	REP	MOVSB
ext_kill_tail:
	CMP	BYTE PTR ES:[DI-1]," "
	JNZ	find_done
	DEC	DI			; Back up over trailing space
	JMP	ext_kill_tail
find_done:
	XOR	AX,AX
	STOSB				; NUL terminate
	return
EndProc PackName


DOSCODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\segcheck.asm ===
TITLE	SegCheck - internal consistency check
	NAME	SegCheck

	.xlist
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include sf.inc
	include int2a.inc
ifdef NEC_98
	include dpb.inc
endif   ;NEC_98
	.list


AsmVars <NET, DEBUG>

DOSCODE SEGMENT
    ASSUME  CS:DOSCODE

if	DEBUG
	allow_getdseg


	BREAK	<SegCheck - validate segments in MSDOS>


zfmt    MACRO   fmts,args
local   a,b
	PUSH    AX
	PUSH    BP
	MOV     BP,SP
If (not sharef) and (not redirector)
DOSDATA	 segment
a	 db	 fmts,0
DOSDATA	 ends
	MOV	AX,OFFSET DOSDATA:a
else
	jmp     short b
a       db      fmts,0
if sharef
b:      mov     ax,offset share:a
else
b:      mov     ax,offset netwrk:a
endif
endif
	PUSH    AX
cargs = 2
IRP item,<args>
IFIDN   <AX>,<item>
	MOV     AX,[BP+2]
ELSE
	MOV     AX,item
ENDIF
	PUSH    AX
cargs = cargs + 2
ENDM
	invoke  PFMT
	ADD     SP,Cargs
	POP     BP
	POP     AX
ENDM


;**	SegCheck - assure that segments are correctly set up
;
;	calling sequence:
;		call Segcheck
;		jmp	short l1
;		DB	flags
;		DB	asciz error message string
;	   l1:
;
;	flag values:	04 - check ES
;			02 - check DS
;			01 - check SS
;
;	ENTRY	As above
;	EXIT	returns if OK, prints and traps if error
;	USES	none

Procedure   SegCheck,NEAR
	ASSUME	SS:NOTHING
	SAVE	<BP>
	MOV     BP,SP                   ; set up addressing
	PUSHF				; Following code depends upon this order
	SAVE	<AX,BX,CX,DX,DS>	;    "       "	   "      "    "
	GETDSEG DS
	mov	dx,ds			; (dx) = DOSDATA segment
	mov	bx,2[bp]		; (bx) = return address
	mov	al,cs:2[bx]		; (al) = flag byte
	add	bx,3
	TEST	AL,1
	JZ	schk5			; don't check SS
	mov	cx,ss
	cmp	cx,dx
	je	schk5			; OK
	zfmt	<"Assumed SS invalid $S\n">,<cs,bX>
	TRAP

schk5:	test	al,2			; see if DS to be checked
	jz	schk10			; don't check DS
	mov	cx,-12[bp]
	cmp	cx,dx
	je	schk10			; no problem
	zfmt	<"Assumed DS invalid $S\n">,<cs,bX>
	TRAP

schk10:	test	al,4			; see if ES to be checked
	jz	schk15			; don't check ES
	mov	cx,es
	cmp	cx,dx
	je	schk15			; no problem
	zfmt	<"Assumed ES invalid $S\n">,<cs,bX>
	TRAP

schk15: RESTORE <DS,DX,CX,BX,AX>
	POPF
	RESTORE <BP>
	ret

EndProc SegCheck


I_need  DPBHead,DWORD
I_need	BufferQueue,DWORD
I_need  sftFCB,DWORD
I_need  AuxStack,BYTE
I_need  IOStack,BYTE
I_need  renbuf,byte
I_need  CurrentPDB,WORD
I_need  User_In_AX,WORD

extrn   ECritDisk:NEAR

CritNOP label   byte
	RET

AstFrame    STRUC
Astbp       dw  ?
Astip       dw  ?
Astmes      dw  ?
Astarg      dd  ?
AstFrame    ENDS

ifdef NEC_98

;**	DPBCheck - Validate A DPB Pointer
;
;	DPBCheck checks to see if a supplied pointer points to a DPB
;	as it's supposed to.
;
;	ENTRY
;	EXIT	returns if OK, message and trap if error
;	USES	none

Procedure   DPBCheck,NEAR
	assume	SS:nothing
	SAVE	<BP>
	MOV     BP,SP
	PUSHF
	SAVE	<AX,BX,DS,SI,ES,DI>
	GETDSEG DS
	LES     DI,DPBHead
	LDS     SI,[BP].Astarg
    ASSUME DS:nothing
DPBLoop:CMP     DI,-1
	JZ      DPBNotFound
	invoke  PointComp
	JZ      DPBRet
	LES     DI,ES:[DI.dpb_next_dpb]
	JMP     DPBLoop

DPBNotFound:
	MOV     AX,[BP].Astmes
	zfmt	<"DPB assertion failed: $x:$x $s\n">,<ds,si,AX>
	TRAP
	JMP	$			; hang here

DPBRet: RESTORE <DI,ES,SI,DS,BX,AX> ;	Done:
	POPF
	RESTORE <BP>
	RET     6

EndProc DPBCheck


;**	SFTCheck - Validate an SFT Pointer
;
;	SFTCheck verifies that a pointer points to an SFT
;
;	ENTRY	BUGBUG
;	EXIT	returns if no error, traps w/message if error
;	USES	none

Procedure   SFTCheck,NEAR
	assume	SS:nothing

	SAVE	<BP>
	MOV     BP,SP
	PUSHF
	SAVE	<AX,BX,DS,SI,ES,DI>
	LDS     SI,[BP].Astarg
	XOR     BX,BX                   ;   i = 0;
SFTLoop:
	SAVE	<BX>
	invoke  SFFromSFN               ;   while ((d=SF(i)) != NULL)
	RESTORE <BX>
	JC      Sft1
	invoke  PointComp
	JZ      DPBRet                  ;               goto Done;
SFTNext:INC     BX                      ;           else
	JMP     SFTLoop                 ;               i++;


SFT1:	GETDSEG DS
	LES	DI,sftFCB
   ASSUME DS:nothing
	MOV     BX,ES:[DI.sfCount]
	LEA     DI,[DI.sfTable]
sft2:	invoke	PointComp
	JZ	    DPBRet
	ADD     DI,SIZE sf_entry
	DEC     BX
	JNZ     SFT2

;	The SFT is not in the allocated tables.  See if it is one of the static
;	areas.

	GETDSEG ES
	MOV	DI,OFFSET DOSDATA:AUXSTACK - SIZE SF_ENTRY
	Invoke  PointComp
	JZ      DPBRet
	MOV	DI,OFFSET DOSDATA:RenBuf
	Invoke  PointComp
	LJZ	DPBRet


	MOV     AX,[BP].Astmes
	zfmt	<"SFT assertion failed: $x:$x $s\n">,<ds,si,AX>
	TRAP
	JMP	$			; hang here

EndProc SFTCheck,NoCheck


;**	BUFCheck - Validate a BUF Pointer
;
;	BUFCheck makes sure that a supposed BUF pointer is valid.
;
;	ENTRY	BUGBUG
;	EXIT	returns if OK, traps if error
;	USES	none

Procedure   BUFCheck,NEAR
	assume	SS:nothing
	SAVE	<BP>
	MOV     BP,SP
	PUSHF
	SAVE	<AX,BX,DS,SI,ES,DI>

;	CheckDisk - make sure that we are in the disk critical section...

	GETDSEG DS
	MOV     AL,BYTE PTR ECritDisk
	CMP     AL,CritNOP
	JZ      CheckDone
ifdef	NEVER		; BUGBUG - turn this back on sometime?
	MOV     AX,CurrentPDB

	CMP     SectPDB + 2 * critDisk,AX
	MOV     AX,[BP].astmes
	JZ      CheckRef
	zfmt    <"$p: $x $s critDisk owned by $x\n">,<User_In_AX,AX,SectPDB+2*critDisk>
CheckRef:
	CMP     SectRef + 2 * critDisk,0
	JNZ     CheckDone
	zfmt    <"$p: $x $s critDisk ref count is 0\n">,<User_In_AX,AX>
ENDIF
CheckDone:

	LES	DI,BufferQueue
	LDS     SI,[BP].Astarg
  ASSUME DS:nothing
BUFLoop:CMP     DI,-1
	JZ	BufNotFound
	invoke  PointComp
	LJZ	DPBRet
	mov	di,es:buf_next[di]
	JMP     BUFLoop

BufNotFound:
	MOV     AX,[BP].Astmes
	zfmt	<"BUF assertion failed: $x:$x $s\n">,<ds,si,AX>
	TRAP
	JMP	$			; hang here

 DPUBLIC <DPBLoop, DPBNotFound, DPBRet>
 DPUBLIC <SFTLoop, SFTNext, SFT1, sft2, BUFLoop, BufNotFound>
 DPUBLIC <schk5, schk10, schk15>

EndProc BUFCheck,NoCheck

endif   ;NEC_98
ENDIF

DOSCODE	ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\path.asm ===
TITLE	PATH - Directory related system calls
	NAME	PATH

;**	Directory related system calls.  These will be passed direct text of the
;	pathname from the user.  They will need to be passed through the macro
;	expander prior to being sent through the low-level stuff.  I/O specs are
;	defined in DISPATCH.	The system calls are:
;
;	$CURRENT_DIR  Written
;	$RMDIR	  Written
;	$CHDIR	  Written
;	$MKDIR	  Written
;
;
;	Modification history:
;
;	    Created: ARR 4 April 1983
;		 MZ 10 May 1983     CurrentDir implemented
;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
;				    current directory.
;		 MZ 19 Jan 1983     some applications rely on success

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include curdir.inc
	include filemode.inc
	include mult.inc
	include dossvc.inc
	.cref
	.list

	I_Need	ThisCDS,DWORD		; pointer to Current CDS
	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
	I_Need	OpenBuf,128		; temp spot for translated name
	I_need	fSplice,BYTE		; TRUE => do splice
	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
	I_Need	cMeta,BYTE
	I_Need	DrvErr,BYTE							;AN000;
                I_Need  CURDRV,BYTE

DOSCODE	SEGMENT

	allow_getdseg
	
	ASSUME	SS:DOSDATA,CS:DOSCODE


BREAK <$CURRENT_DIR - dump the current directory into user space>
;---------------------------------------------------------------------------
;   Procedure Name : $CURRENT_DIR
;
;   Assembler usage:
;		LDS	SI,area
;		MOV	DL,drive
;		INT	21h
;	    ; DS:SI is a pointer to 64 byte area that contains drive
;	    ; current directory.
;   Error returns:
;	    AX = error_invalid_drive
;
;---------------------------------------------------------------------------

procedure $CURRENT_DIR,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING
	EnterCrit   critDisk
	MOV	AL,DL			; get drive number (0=def, 1=A)
	Invoke	GetVisDrv		; grab it
        JNC     CurrentValidate         ; no error -> go and validate dir

CurdirErr:
	LeaveCrit   critDisk

;hkn; 	Set up DS to access DrvErr
	push	ds
	getdseg	<ds>			; ds -> dosdata

	MOV	AL,[DrvErr]		;IFS.					;AN000;

	pop	ds
	assume	ds:nothing

        transfer SYS_RET_ERR            ;IFS. make noise                        ;AN000;

CurrentValidate:
	SAVE	<DS,SI> 		; save destination

;hkn; 	Set up DS to access ThisCDS
	getdseg	<ds>			; ds -> dosdata

	LDS	SI,ThisCDS

        assume  ds:nothing

; Dont validate FIXED drives which include FIXED DISK. NETWORK DRIVES and
; CDROM. This is compaitable with DOS5. Sudeepb 23-Dec-1993

        test    WORD PTR DS:[SI.CURDIR_FLAGS],CURDIR_NT_FIX
        jnz     noquery
        HRDSVC  SVC_DEMQUERYCURRENTDIR
noquery:

        RESTORE <DI,ES>         ; get real destination
	JC	CurdirErr
	ADD	SI,curdir_text
	ADD	SI,[SI.curdir_END]
	CMP	BYTE PTR [SI],'\'       ; root or subdirs present?
	JNZ	CurrentCopy
	INC	SI
CurrentCopy:
;	Invoke	FStrCpy
;; 10/29/86 E5 char
	PUSH	AX
	LODSB			      ; get char
	OR	AL,AL
	JZ	FOK
	CMP	AL,05
	JZ	FCHANGE
	JMP	short FFF
FCPYNEXT:
	LODSB			      ; get char
FFF:
	CMP	AL,'\'                ; beginning of directory
ifdef DBCS
        JNZ     GGG
else
	JNZ	FOK		      ; no

	invoke	UCase
endif

	STOSB			      ; put into user's buffer
	LODSB			      ; 1st char of dir is 05?
	CMP	AL,05H
ifdef DBCS
	JNZ	GGG		      ; no
else
	JNZ	FOK		      ; no
endif
FCHANGE:
	MOV	AL,0E5H 	      ; make it E5
ifdef DBCS
	JMP  	FSKIP
GGG:
        invoke  TESTKANJ              ; Is Character lead byte of DBCS?
        jz      FOK                   ; jump if not
        stosb                         ; put into user's buffer
        lodsb                         ; skip over DBCS character
        jmp     short FSKIP           ; skip upcase
endif
FOK:
	invoke	UCase

ifdef DBCS
FSKIP:
endif
	STOSB			      ; put into user's buffer
	OR	AL,AL		      ; final char
	JNZ	FCPYNEXT	      ; no
	POP	AX

;; 10/29/86 E5 char
	xor	AL,AL			; MZ 19 Jan 84
	LeaveCrit   critDisk
	transfer    Sys_Ret_OK		; no more, bye!

EndProc $Current_Dir


BREAK <$ChDir -- Change current directory on a drive>
;----------------------------------------------------------------------------
;
; $ChDir - Top-level change directory system call.  This call is responsible
; for setting up the CDS for the specified drive appropriately.  There are
; several cases to consider:
;
;   o	Local, simple CDS.  In this case, we take the input path and convert
;	it into a WFP.	We verify the existance of this directory and then
;	copy the WFP into the CDS and set up the ID field to point to the
;	directory cluster.
;   o	Net CDS.  We form the path from the root (including network prefix)
;	and verify its existance (via DOS_Chdir).  If successful, we copy the
;	WFP back into the CDS.
;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
;	call TransPath, we will get the PHYSICAL CDS that the path refers to
;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
;	good for the validation but not for currency.  We call TransPathNoSet
;	to process the path but to return the logical CDS and the logical
;	path.  We then copy the logical path into the logical CDS.
;
; Inputs:
;	DS:DX Points to asciz name
; Returns:
;	STD XENIX Return
;	AX = chdir_path_not_found if error
;----------------------------------------------------------------------------

procedure $CHDIR,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; OpenBuf is in DOSDATA
	MOV	DI,OFFSET DOSDATA:OpenBuf  ; spot for translated name
	MOV	SI,DX			; get source
	Invoke	TransPath		; go munge the path and get real CDS
	JNC	ChDirCrack		; no errors, try path
ChDirErrP:
	MOV	AL,error_path_not_found
ChdirErr:
	transfer    SYS_Ret_Err 	; oops!

ChDirCrack:

	Assume	DS:DOSDATA

	CMP	cMeta,-1		; No meta chars allowed.
	JNZ	ChDirErrP
	or	ax,ax
	jz	ChDirErrp		; Device name
;
; We cannot do a ChDir (yet) on a raw CDS.  This is treated as a path not
; found.
;
	LES	DI,ThisCDS
	CMP	DI,-1			;   if (ThisCDS == NULL)
	JZ	ChDirErrP		;	error ();
	TEST	ES:[DI].curdir_flags,curdir_splice
	JZ	GotCDS
;
; The CDS was joined.  Let's go back and grab the logical CDS.
;
	SAVE	<ES,DI,CX>		; save CDS and cluster...
	Invoke	Get_User_Stack		; get original text
	ASSUME	DS:NOTHING
	MOV	DI,[SI.User_DX]
	MOV	DS,[SI.User_DS]

;hkn; OpenBuf is in DOSDATA
	MOV	SI,OFFSET DOSDATA:OpenBuf  ; spot for translated name

	XCHG	SI,DI
	XOR	AL,AL			; do no splicing
	SAVE	<DI>
	Invoke	TransPathNoSet		; Munge path
	RESTORE <SI>
;hkn;	Assume	DS:DOSGroup

	Assume	DS:DOSDATA
;
; There should NEVER be an error here.
;
IF FALSE
	JNC SKipErr
	fmt <>,<>,<"$p: Internal CHDIR error\n">
SkipErr:
ENDIF
	LES	DI,ThisCDS		; get new CDS
;	MOV	ES:[DI].curdir_ID,-1	; no valid cluster here...
	RESTORE <CX,DI,ES>
;
; ES:DI point to the physical CDS, CX is the ID (local only)
;
GotCDS:
;
; wfp_start points to the text.  See if it is long enough
;

   ; This call is necessary no more -- dem does it

   ;     CALL    Check_PathLen           ;PTM.                                   ;AN000;
   ;     JA      ChDirErrP

; even if this call fails -- we still can do a successful change dir
; win95 does not really care if you do a chdir on a long directory
; if you try to get a current dir after that -- you get err 0x0f
; (which is ERROR_INVALID_DRIVE)!!! 

   
        Context <DS>

        mov     al, [curdrv]
        mov     dx,wfp_start
        mov     si,dx
        les     di,ThisCDS
        HRDSVC  SVC_DEMSETCURRENTDIR
        jc      ChDirErrP
        XOR     AL,AL
        transfer    Sys_Ret_OK
EndProc $CHDIR

BREAK <$MkDir - Make a directory entry>
;---------------------------------------------------------------------------
;
; Procedure Name : $MkDir
; Inputs:
;	DS:DX Points to asciz name
; Function:
;	Make a new directory
; Returns:
;	STD XENIX Return
;	AX = mkdir_path_not_found if path bad
;	AX = mkdir_access_denied  If
;		Directory cannot be created
;		Node already exists
;		Device name given
;		Disk or directory(root) full
;---------------------------------------------------------------------------

procedure $MKDIR,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	MOV	DI,OFFSET DOSDATA:OpenBuf  ; spot for translated name

	MOV	SI,DX			; get source
	Invoke	TransPath		; go munge the path
	JNC	MkDirCrack		; no errors, try path
MkErrP:
	MOV	AL,error_Path_Not_Found    ; oops!
MkErr:
        stc
        transfer Sys_Ret_Err
MkDirCrack:

;hkn; SS override
	CMP	cMeta,-1
	JNZ	MkErrP
	or	ax,ax
	jz	MkErrP			; No device allowed

	CALL	Check_PathLen		;PTM.  check path len > 67 ?		;AN000;
	JBE	pathok			;PTM.					;AN000;
	MOV	AL,error_Access_Denied	;PTM. ops!
	transfer Sys_Ret_Err		;PTM.
pathok:
	Context <DS>
	mov	dx,wfp_start
	xor	bx,bx
	xor	si,si
	HRDSVC	SVC_DEMCREATEDIR
	ASSUME	ES:NOTHING
        JC      MkErrCheck                   ; no errors
IFDEF JAPAN
	; ntraid:mskkbug#3165,3174: Cannot make directory	10/31/93 yasuho
	; MKDIR system call was return to NC if function is successful.
	; But, some japanese application (e.g. install program) was
	; checked AX register for how to error function call.
	xor	ax, ax			; success. return code = 0
ENDIF
        transfer Sys_Ret_OK


        ; NTVDM - 14-Jan-1994 Jonle
        ; Both RmDir and MkDir use this common error code remapping
        ; of error_not_ready to error_path_not_found.
        ;
        ; The Ntvdm version of TransPath does not verify that
        ; the drive\path actually exists. The error is supposed to be
        ; error_path_not_found, but will become error_access_denied
        ; because error_not_ready is not a valid error code for MkDir\RmDir
MkErrCheck:
        cmp     al, error_not_ready
        jz      MkErrP
ifdef JAPAN
        ; kksuzuka:#3833 for oasys/win2.3
        cmp     al, 0b7h                ; ERROR_ALREADY_EXISTS from dem
        jnz     MkNotExist
        mov     al, error_access_denied
MkNotExist:
endif ; JAPAN
        jmp     short MkErr

EndProc $MKDIR


BREAK <$RmDir -- Remove a directory>
;---------------------------------------------------------------------------
;
; Procedure Name : $RmDir
;
; Inputs:
;	DS:DX Points to asciz name
; Function:
;	Delete directory if empty
; Returns:
;	STD XENIX Return
;	AX = error_path_not_found If path bad
;	AX = error_access_denied If
;		Directory not empty
;		Path not directory
;		Root directory specified
;		Directory malformed (. and .. not first two entries)
;		User tries to delete a current directory
;	AX = error_current_directory
;----------------------------------------------------------------------------

procedure $RMDIR,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

	push	dx			; Save ptr to name
	push	ds
	mov	si,dx			; Load ptr into si

;hkn; OpenBuf is in DOSDATA
	mov	di,offset DOSDATA:OpenBuf   ; di = ptr to buf for trans name
	push	di
	Invoke	TransPathNoSet		; Translate the name
	pop	di			; di = ptr to buf for trans name
	jnc	rmlset			; If transpath succeeded, continue
rmle:
	pop	ds
	pop	dx			; Restore the	 name
	error	error_path_not_found	; Otherwise, return an error

rmlset:

;hkn; SS override
	CMP	cMeta,-1		;   if (cMeta >= 0)
	Jnz	rmerr			;	return (-1);
	or	ax,ax
	jz	rmle			; cannot delete a device
	pop	ds
	pop	dx
	push	es
	pop	ds
	mov	dx,wfp_start		; ds:dx is the path
        HRDSVC  SVC_DEMDELETEDIR
        jc      MkErrCheck
        transfer Sys_Ret_OK
rmerr:
	pop	ds
	pop	dx			; Restore the	 name
	error	error_current_directory ;  error

EndProc $RMDIR


;----------------------------------------------------------------------------
;
; Procedure Name : Check_PathLen
;
; Inputs:
;	nothing
; Function:
;	check if final path length greater than 67
; Returns:
;	Above flag set if > 67
;---------------------------------------------------------------------------

procedure Check_PathLen,NEAR
	ASSUME	CS:DOSCODE,SS:DOSDATA

;hkn; SS override
	MOV	SI,Wfp_Start
  entry Check_PathLen2

;hkn; SS is DOSDATA
	Context <DS>

	SAVE	<CX>
	invoke	DStrLen
	CMP	CX,DirStrLen
	RESTORE <CX>
	ret

EndProc Check_PathLen
DOSCODE ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\util.asm ===
TITLE	UTIL - Handle utilities
	NAME	UTIL

;**	Handle related utilities for MSDOS 2.X.
;
;	pJFNFromHandle	written
;	SFFromHandle	written
;	SFFromSFN	written
;	JFNFree 	written
;	SFNFree 	written
;
;	Modification history:
;
;	    Created: MZ 1 April 1983

	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include pdb.inc
	include sf.inc
	include bugtyp.inc
	.cref
	.list


	I_need  CurrentPDB,WORD         ; current process data block location
	I_need  SFT_Addr,DWORD          ; pointer to beginning of table
	I_Need  PROC_ID,WORD            ; current process ID
	I_Need  USER_ID,WORD            ; current user ID


DOSCODE SEGMENT
	ASSUME  SS:DOSDATA,CS:DOSCODE

	allow_getdseg

	BREAK	<pJFNFromHandle - return pointer to JFN table entry>


;**	pJFNFromHandle - Translate Handle to Pointer to JFN
;
;	pJFNFromHandle takes a file handle and turns that into a pointer to
;	the JFN entry (i.e., to a byte holding the internal file handle #)
;
;	NOTE:
;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
;	  at DOSINIT time with SS NOT DOSGROUP
;
;	ENTRY	(bx) = handle
;	EXIT	'C' clear if ok
;		  (es:di) = address of JFN value
;		'C' set if error
;		  (ax) = error code
;	USES	AX, DI, ES, Flags

procedure   pJFNFromHandle,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	getdseg	<es>			; es -> dosdata
	MOV	ES,CurrentPDB		; get user process data block
    ASSUME ES:NOTHING

	CMP	BX,ES:PDB_JFN_Length	; is handle greater than allocated
	JB	pjfn10			; no, get offset
	fmt     TypAccess,LevSFN,<"$p: Illegal JFN %x\n">,<BX>
	MOV     AL,error_invalid_handle ; appropriate error
ReturnCarry:
	STC                             ; signal error
	return                          ; go back

pjfn10: LES	DI,ES:PDB_JFN_Pointer	; get pointer to beginning of table
	ADD	DI,BX			; add in offset, clear 'C'
	return

EndProc pJFNFromHandle


BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
;---------------------------------------------------------------------------
;
; Procedure Name : SFFromHandle
;
; SFFromHandle - Given a handle, get JFN and then index into SF table
;
;   Input:      BX has handle
;   Output:     Carry Set
;                   AX has error code
;               Carry Reset
;                   ES:DI has pointer to SF entry
;   Registers modified: If error, AX,ES, else ES:DI
; NOTE:
;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
;       at DOSINIT time with SS NOT DOSGROUP
;
;----------------------------------------------------------------------------

procedure   SFFromHandle,NEAR
	ASSUME	CS:DOSCODE,SS:NOTHING

	CALL    pJFNFromHandle          ; get jfn pointer
	retc                            ; return if error
	CMP     BYTE PTR ES:[DI],-1     ; unused handle
	JNZ     GetSF                   ; nope, take out SF
	fmt     TypAccess,LevSFN,<"$p: Illegal SFN $x:$x\n">,<ES,DI>
	MOV     AL,error_invalid_handle ; appropriate error
	jump    ReturnCarry             ; signal it
GetSF:
	SAVE	<BX>			; save handle
	MOV     BL,BYTE PTR ES:[DI]     ; get SFN
	XOR     BH,BH                   ; ignore upper half
	CALL    SFFromSFN               ; get real sf spot
	RESTORE <BX>			; restore
	return                          ; say goodbye
EndProc SFFromHandle

BREAK <SFFromSFN - index into SF table for SFN>


;**	SFFromSFN - Get an SF Table entry from an SFN
;
;	SFFromSfn uses an SFN to index an entry into the SF table.  This
;	is more than just a simple index instruction because the SF table
;	can be made up of multiple pieces chained together.  We follow the
;	chain to the right piece and then do the index operation.
;
;   NOTE:
;	This routine is called from SFFromHandle which is called
;       at DOSINIT time with SS NOT DOSGROUP
;
;	ENTRY	BX has SF index
;	EXIT	'C' clear if OK
;		  ES:DI points to SF entry
;		'C' set if index too large
;	USES	BX, DI, ES

procedure   SFFromSFN,NEAR
	ASSUME	SS:NOTHING

	getdseg	<es>			; address DOSDATA
	LES	DI,SFT_Addr		; (es:di) = start of SFT table
    ASSUME ES:NOTHING

sfsfn5:	CMP	BX,ES:[DI].SFCount	; is handle in this table?
	JB	sfsfn7			; yes, go grab it
	SUB     BX,ES:[DI].SFCount
	LES     DI,ES:[DI].SFLink       ; get next table segment
	CMP     DI,-1                   ; end of tables?
	JNZ	sfsfn5			; no, try again
	STC
	ret				; return with error, not found

sfsfn7: SAVE	<AX>
	MOV     AX,SIZE SF_Entry        ; put it in a nice place
	MUL	BL			; (ax) = offset into this SF block
	ADD	DI,AX			; add base of SF block
	RESTORE <AX>
	ADD	DI,SFTable		; offset into structure, 'C' cleared
	return				; return with 'C' clear

EndProc SFFromSFN

	BREAK <JFNFree - return a jfn pointer if one is free>

;**	JFNFree - Find a Free JFN Slot
;
;
;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
;
;	ENTRY	(ss) = DOSDATA
;	EXIT	'C' clear if OK
;		  (bx) = new handle
;		  (es:di) = pointer to JFN slot
;		'C' set if error
;		  (al) = error code
;	USES	bx, di, es, flags

procedure   JFNFree,NEAR
	DOSASSUME <ss>,"JFNFree"

	XOR	BX,BX			; (bx) = initial JFN to try
jfnf1:	CALL	pJFNFromHandle		; get the appropriate handle
	JC	jfnf5			; no more handles
	CMP     BYTE PTR ES:[DI],-1     ; free?
	je	jfnfx			; yes, carry is clear
	INC     BX                      ; no, next handle
	JMP	jfnf1			; and try again

;	Error.	'C' set

jfnf5:	MOV	AL,error_too_many_open_files

jfnfx:	return				; bye

EndProc JFNFree

	BREAK <SFNFree - Allocate a free SFN>


;**	SFNFree - Allocate a Free SFN/SFT
;
;	SFNFree scans through the sf table looking for a free entry
;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
;
;	The problem is that we want to mark the SFT busy so that other threads
;	can't allocate the SFT before we're finished marking it up.  However,
;	we can't just mark it busy because we may get blown out of our open
;	by INT24 and leave the thing orphaned.	To solve this we mark it
;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
;	an SFT with this value we look to see if it belongs to this user
;	and process.  If it does belong to us then it must be an orphan
;	and we reclaim it.
;
;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
;		over and over, but we could at least set a high water mark...
;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
;		even though this is not a frequently called routine - jgl
;
;	ENTRY	(ss) = DOSDATA
;	EXIT	'C' clear if no error
;		  (bx) = SFN
;		  (es:di) = pointer to SFT
;		  es:[di].SFT_REF_COUNT = -1
;		'C' set if error
;		  (al) = error code
;	USES	bx, di, se, Flags

Procedure SFNFree,NEAR
	DOSASSUME <SS>,"SFNFree"

	SAVE	<ax>
	xor	bx,bx			; (bx) = SFN to consider
sfnf5:	SAVE	<bx>
	call	SFFromSFN		; get the potential handle
	RESTORE <bx>
	DLJC	sfnf95			; no more free SFNs
	cmp	es:[DI.sf_Ref_Count],0	; free?
	je	sfnf20			; yep, got one
	cmp	es:[DI.sf_ref_count],sf_busy
	je	sfnf10			; special busy mark
sfnf7:	inc	bx			; try the next one
	jmp	sfnf5

;	The SFT has the special "busy" mark; if it belongs to us then
;	it was abandoned during a earlier call and we can use it.
;
;	(bx)	= SFN
;	(es:di) = pointer to SFT
;	(TOS)	= caller's (ax)

sfnf10:
	mov	ax,Proc_ID
	cmp	es:[DI].SF_PID,ax
	jnz	sfnf7			; can't use this one, try the next

;	We have an SFT to allocate
;
;	(bx)	= SFN
;	(es:di) = pointer to SFT
;	(TOS)	= caller's (ax)

sfnf20:
	mov	es:[DI.sf_ref_count],sf_busy	; make sure that this is allocated
	mov	ax,Proc_ID
	mov	es:[DI].SF_PID,ax
	RESTORE <ax>
	clc
	return				; return with no error


;**	Error - no more free SFNs
;
;	'C' set
;	(TOS) = saved ax

sfnf95: pop	ax
	mov	al,error_too_many_open_files
	ret					; return with 'C' and error

EndProc SFNFree
DOSCODE ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\scnam.inc ===
SCnm_0	DB	"Abort",0
SCnm_1	DB	"Std_Con_Input",0
SCnm_2	DB	"Std_Con_Output",0
SCnm_3	DB	"Std_Aux_Input",0
SCnm_4	DB	"Std_Aux_Output",0
SCnm_5	DB	"Std_Printer_Output",0
SCnm_6	DB	"Raw_Con_IO",0
SCnm_7	DB	"Raw_Con_Input",0
SCnm_8	DB	"Std_Con_Input_No_Echo",0
SCnm_9	DB	"Std_Con_String_Output",0
SCnm_10	DB	"Std_Con_String_Input",0
SCnm_11	DB	"Std_Con_Input_Status",0
SCnm_12	DB	"Std_Con_Input_Flush",0
SCnm_13	DB	"Disk_Reset",0
SCnm_14	DB	"Set_Default_Drive",0
SCnm_15	DB	"FCB_Open",0
SCnm_16	DB	"FCB_Close",0
SCnm_17	DB	"Dir_Search_First",0
SCnm_18	DB	"Dir_Search_Next",0
SCnm_19	DB	"FCB_Delete",0
SCnm_20	DB	"FCB_Seq_Read",0
SCnm_21	DB	"FCB_Seq_Write",0
SCnm_22	DB	"FCB_Create",0
SCnm_23	DB	"FCB_Rename",0
SCnm_24 DB	"===24===",0
SCnm_25	DB	"Get_Default_Drive",0
SCnm_26	DB	"Set_DMA",0
SCnm_27	DB	"===27===",0
SCnm_28	DB	"===28===",0
SCnm_29	DB	"===29===",0
SCnm_30	DB	"===30===",0
SCnm_31	DB	"Get_Default_DPB",0
SCnm_32	DB	"===32===",0
SCnm_33	DB	"FCB_Random_Read",0
SCnm_34	DB	"FCB_Random_Write",0
SCnm_35	DB	"Get_FCB_File_Length",0
SCnm_36	DB	"Get_FCB_Position",0
SCnm_37	DB	"Set_Interrupt_Vector",0
SCnm_38	DB	"Create_Process_Data_Block",0
SCnm_39	DB	"FCB_Random_Read_Block",0
SCnm_40	DB	"FCB_Random_Write_Block",0
SCnm_41	DB	"Parse_File_Descriptor",0
SCnm_42	DB	"Get_Date",0
SCnm_43	DB	"Set_Date",0
SCnm_44	DB	"Get_Time",0
SCnm_45	DB	"Set_Time",0
SCnm_46	DB	"Set_Verify_On_Write",0
SCnm_47	DB	"Get_DMA",0
SCnm_48	DB	"Get_Version",0
SCnm_49	DB	"Keep_Process",0
SCnm_50	DB	"Get_DPB",0
SCnm_51	DB	"Set_CTRL_C_Trapping",0
SCnm_52	DB	"Get_InDOS_Flag",0
SCnm_53	DB	"Get_Interrupt_Vector",0
SCnm_54	DB	"Get_Drive_Freespace",0
SCnm_55	DB	"Char_Oper",0
SCnm_56	DB	"International",0
SCnm_57	DB	"MKDir",0
SCnm_58	DB	"RMDir",0
SCnm_59	DB	"CHDir",0
SCnm_60	DB	"Creat",0
SCnm_61	DB	"Open",0
SCnm_62	DB	"Close",0
SCnm_63	DB	"Read",0
SCnm_64	DB	"Write",0
SCnm_65	DB	"Unlink",0
SCnm_66	DB	"LSeek",0
SCnm_67	DB	"CHMod",0
SCnm_68	DB	"IOCtl",0
SCnm_69	DB	"XDup",0
SCnm_70	DB	"XDup2",0
SCnm_71	DB	"Current_Dir",0
SCnm_72	DB	"Alloc",0
SCnm_73	DB	"Dealloc",0
SCnm_74	DB	"Setblock",0
SCnm_75	DB	"Exec",0
SCnm_76	DB	"Exit",0
SCnm_77	DB	"WaitProcess",0
SCnm_78	DB	"Find_First",0
SCnm_79	DB	"Find_Next",0
SCnm_80	DB	"Set_Current_PDB",0
SCnm_81	DB	"Get_Current_PDB",0
SCnm_82	DB	"Get_In_Vars",0
SCnm_83	DB	"SetDPB",0
SCnm_84	DB	"Get_Verify_On_Write",0
SCnm_85	DB	"Dup_PDB",0
SCnm_86	DB	"Rename",0
SCnm_87	DB	"File_Times",0
SCnm_88	DB	"AllocOper",0
SCnm_89	DB	"GetExtendedError",0
SCnm_90	DB	"CreateTempFile",0
SCnm_91	DB	"CreateNewFile",0
SCnm_92	DB	"LockOper",0
SCnm_93	DB	"ServerCall",0
SCnm_94	DB	"UserOper",0
SCnm_95	DB	"AssignOper",0
SCnm_96	DB	"xNameTrans",0
SCnm_97	DB	"PathParse",0
SCnm_98	DB	"GetCurrentPSP",0
SCnm_99	DB	"ECS_CALL",0
SCnm_100 DB	"Set_Printer_Flag",0
SCnm_101 DB	"GetExtCntry",0
SCnm_102 DB	"GetSetCdPg",0
SCnm_103 DB	"ExtHandle",0
SCnm_104 DB	"Commit",0
SCnm_105 DB	"GetSetMediaID",0
SCnm_106 DB	"===106===",0
SCnm_107 DB	"IFS_IOCTL",0
SCnm_108 DB	"ExtOpen",0


scptrs	DW	offset DOSCODE:SCnm_0
	DW	offset DOSCODE:SCnm_1
	DW	offset DOSCODE:SCnm_2
	DW	offset DOSCODE:SCnm_3
	DW	offset DOSCODE:SCnm_4
	DW	offset DOSCODE:SCnm_5
	DW	offset DOSCODE:SCnm_6
	DW	offset DOSCODE:SCnm_7
	DW	offset DOSCODE:SCnm_8
	DW	offset DOSCODE:SCnm_9
	DW	offset DOSCODE:SCnm_10
	DW	offset DOSCODE:SCnm_11
	DW	offset DOSCODE:SCnm_12
	DW	offset DOSCODE:SCnm_13
	DW	offset DOSCODE:SCnm_14
	DW	offset DOSCODE:SCnm_15
	DW	offset DOSCODE:SCnm_16
	DW	offset DOSCODE:SCnm_17
	DW	offset DOSCODE:SCnm_18
	DW	offset DOSCODE:SCnm_19
	DW	offset DOSCODE:SCnm_20
	DW	offset DOSCODE:SCnm_21
	DW	offset DOSCODE:SCnm_22
	DW	offset DOSCODE:SCnm_23
	DW	offset DOSCODE:SCnm_24
	DW	offset DOSCODE:SCnm_25
	DW	offset DOSCODE:SCnm_26
	DW	offset DOSCODE:SCnm_27
	DW	offset DOSCODE:SCnm_28
	DW	offset DOSCODE:SCnm_29
	DW	offset DOSCODE:SCnm_30
	DW	offset DOSCODE:SCnm_31
	DW	offset DOSCODE:SCnm_32
	DW	offset DOSCODE:SCnm_33
	DW	offset DOSCODE:SCnm_34
	DW	offset DOSCODE:SCnm_35
	DW	offset DOSCODE:SCnm_36
	DW	offset DOSCODE:SCnm_37
	DW	offset DOSCODE:SCnm_38
	DW	offset DOSCODE:SCnm_39
	DW	offset DOSCODE:SCnm_40
	DW	offset DOSCODE:SCnm_41
	DW	offset DOSCODE:SCnm_42
	DW	offset DOSCODE:SCnm_43
	DW	offset DOSCODE:SCnm_44
	DW	offset DOSCODE:SCnm_45
	DW	offset DOSCODE:SCnm_46
	DW	offset DOSCODE:SCnm_47
	DW	offset DOSCODE:SCnm_48
	DW	offset DOSCODE:SCnm_49
	DW	offset DOSCODE:SCnm_50
	DW	offset DOSCODE:SCnm_51
	DW	offset DOSCODE:SCnm_52
	DW	offset DOSCODE:SCnm_53
	DW	offset DOSCODE:SCnm_54
	DW	offset DOSCODE:SCnm_55
	DW	offset DOSCODE:SCnm_56
	DW	offset DOSCODE:SCnm_57
	DW	offset DOSCODE:SCnm_58
	DW	offset DOSCODE:SCnm_59
	DW	offset DOSCODE:SCnm_60
	DW	offset DOSCODE:SCnm_61
	DW	offset DOSCODE:SCnm_62
	DW	offset DOSCODE:SCnm_63
	DW	offset DOSCODE:SCnm_64
	DW	offset DOSCODE:SCnm_65
	DW	offset DOSCODE:SCnm_66
	DW	offset DOSCODE:SCnm_67
	DW	offset DOSCODE:SCnm_68
	DW	offset DOSCODE:SCnm_69
	DW	offset DOSCODE:SCnm_70
	DW	offset DOSCODE:SCnm_71
	DW	offset DOSCODE:SCnm_72
	DW	offset DOSCODE:SCnm_73
	DW	offset DOSCODE:SCnm_74
	DW	offset DOSCODE:SCnm_75
	DW	offset DOSCODE:SCnm_76
	DW	offset DOSCODE:SCnm_77
	DW	offset DOSCODE:SCnm_78
	DW	offset DOSCODE:SCnm_79
	DW	offset DOSCODE:SCnm_80
	DW	offset DOSCODE:SCnm_81
	DW	offset DOSCODE:SCnm_82
	DW	offset DOSCODE:SCnm_83
	DW	offset DOSCODE:SCnm_84
	DW	offset DOSCODE:SCnm_85
	DW	offset DOSCODE:SCnm_86
	DW	offset DOSCODE:SCnm_87
	DW	offset DOSCODE:SCnm_88
	DW	offset DOSCODE:SCnm_89
	DW	offset DOSCODE:SCnm_90
	DW	offset DOSCODE:SCnm_91
	DW	offset DOSCODE:SCnm_92
	DW	offset DOSCODE:SCnm_93
	DW	offset DOSCODE:SCnm_94
	DW	offset DOSCODE:SCnm_95
	DW	offset DOSCODE:SCnm_96
	DW	offset DOSCODE:SCnm_97
	DW	offset DOSCODE:SCnm_98
	DW	offset DOSCODE:SCnm_99
	DW	offset DOSCODE:SCnm_100
	DW	offset DOSCODE:SCnm_101
	DW	offset DOSCODE:SCnm_102
	DW	offset DOSCODE:SCnm_103
	DW	offset DOSCODE:SCnm_104
	DW	offset DOSCODE:SCnm_105
	DW	offset DOSCODE:SCnm_106
	DW	offset DOSCODE:SCnm_107
	DW	offset DOSCODE:SCnm_108
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\time.asm ===
TITLE	TIME - time and date functions
	NAME	TIME

;**	TIME.ASM - System Calls and low level routines for DATE and TIME
;
;	$GET_DATE
;	$SET_DATE
;	$GET_TIME
;	$SET_TIME
;
;	Modification history:
;
;	Sudeepb 12-Mar-1991 Ported For NT DOSEm


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	include dossym.inc
	include devsym.inc
	include dossvc.inc
	.cref
	.list

ifdef NEC_98
    i_need  DAY,BYTE
    i_need  MONTH,BYTE
    i_need  YEAR,WORD
    i_need  WEEKDAY,BYTE
    i_need  TIMEBUF,6
    i_need  BCLOCK,DWORD
    i_need  DAYCNT,WORD
    i_need  YRTAB,8
    i_need  MONTAB,12
    i_need  DATE_FLAG,WORD

    FOURYEARS = 3*365 + 366
endif   ;NEC_98


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE

	allow_getdseg


	BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>

;**	$GET_DATE - Get Current Date
;
;	ENTRY	none
;	EXIT	(cx:dx) = current date
;	USES	all

procedure   $GET_DATE,NEAR

	Context DS
	SVC	SVC_DEMQUERYDATE
	invoke	get_user_stack		;Get pointer to user registers
    ASSUME DS:NOTHING
	MOV	[SI.user_DX],DX 	;DH=month, DL=day
	MOV	[SI.user_CX],CX 	;CX=year

	return

EndProc $GET_DATE




;**	$SET_DATE - Set Current Date
;
;	ENTRY	(cx:dx) = current date
;	EXIT	(al) = -1 iff bad date
;		(al) = 0 if ok
;	USES	all

procedure   $SET_DATE,NEAR	;System call 43

	SVC	SVC_DEMSETDATE
	ret

EndProc $SET_DATE


ifdef FASTINT1A
;**     FastInt1a - same parameters as int 1ah bios fn
;                 - calls direct avoiding int instruction
;

FastInt1a proc near

          push    es
          push    bx

          mov     bx, ax               ; stash ax
          xor     ax, ax               ; use es to addr IVT
          mov     es, ax
          lahf                         ; set up fake flags
          or      al, 2                ; set interrupt bit
          xchg    ah, al

          push    ax
          mov     ax, bx               ; restore ax
          call    dword ptr es:[1ah*4]

          pop     bx
          pop     es
          return

FastInt1a endp
endif

TTTicks proc near

        ret
TTTicks endp


;**     $GET_TIME - Get Current Time
;
;	ENTRY	none
;	EXIT	(cx:dx) = current time
;	USES	all

procedure   $GET_TIME,NEAR	; System call 44

ifndef NEC_98
        xor  ax,ax              ; int1a fn 0
ifdef FASTINT1A
        call FastInt1a
else
        int  1ah
endif


; we now need to convert the time in tick to the time in 100th of
; seconds.  the relation between tick and seconds is:
;
;		 65536 seconds
;	       ----------------
;		1,193,180 tick
;
; to get to 100th of second we need to multiply by 100. the equation is:
;
;	ticks from clock  * 65536 * 100
;      ---------------------------------  = time in 100th of seconds
;		1,193,180
;
; fortunately this fromula simplifies to:
;
;	ticks from clock * 5 * 65,536
;      --------------------------------- = time in 100th of seconds
;		59,659
;
; the calculation is done by first multipling tick by 5. next we divide by
; 59,659.  in this division we multiply by 65,536 by shifting the dividend
; my 16 bits to the left.
;
; start with ticks in cx:dx
; multiply by 5

	mov	ax,cx
	mov	bx,dx
	shl	dx,1
	rcl	cx,1		;times 2
	shl	dx,1
	rcl	cx,1		;times 4
	add	dx,bx
	adc	ax,cx		;times 5
	xchg	ax,dx		
	

; now have ticks * 5 in dx:ax
; we now need to multiply by 65,536 and divide by 59659 d.

	mov	cx,59659	; get divisor
	div	cx
				; dx now has remainder
				; ax has high word of final quotient
	mov	bx,ax		; put high work if safe place
	xor	ax,ax		; this is the multiply by 65536
	div	cx		; bx:ax now has time in 100th of seconds


;rounding based on the remainder may be added here
;the result in bx:ax is time in 1/100 second.

	mov	dx,bx
	mov	cx,200		;extract 1/100's

;division by 200 is necessary to ensure no overflow--max result
;is number of seconds in a day/2 = 43200.

	div	cx
	cmp	dl,100		;remainder over 100?
	jb	noadj
	sub	dl,100		;keep 1/100's less than 100
noadj:
	cmc			;if we subtracted 100, carry is now set
	mov	bl,dl		;save 1/100's

;to compensate for dividing by 200 instead of 100, we now multiply
;by two, shifting a one in if the remainder had exceeded 100.

	rcl	ax,1
	mov	dl,0
	rcl	dx,1
	mov	cx,60		;divide out seconds
	div	cx
	mov	bh,dl		;save the seconds
	div	cl		;break into hours and minutes
	xchg	al,ah

;time is now in ax:bx (hours, minutes, seconds, 1/100 sec)

        Context DS
	invoke	get_user_stack		;Get pointer to user registers
        MOV     [SI.user_DX],BX
        MOV     [SI.user_CX],AX
	XOR	AL,AL
RET26:	return

else    ;NEC_98
;hkn; 	ss is DOSDATA
	Context DS
	CALL	READTIME
	invoke	get_user_stack		;Get pointer to user registers
	MOV	[SI.user_DX],DX
	MOV	[SI.user_CX],CX
	XOR	AL,AL
RET26:	return

endif   ;NEC_98
EndProc $GET_TIME



;**	$SET_TIME - Set Current Time
;
;	ENTRY	(cx:dx) = time
;	EXIT	(al) = 0 if 0k
;		(al) = -1 if invalid
;	USES	ALL

procedure   $SET_TIME,NEAR      ;System call 45

        ; verify time is valid
        mov     al, -1                   ;Flag in case of error
        cmp     ch, 24                   ;Check hours
        jae     RET26
        cmp     cl, 60                   ;Check minutes
        jae     RET26
        cmp     dh, 60                   ;Check seconds
        jae     RET26
        cmp     dl, 100                  ;Check 1/100's
        jae     RET26

ifndef NEC_98
        ; On Nt the cmos is actually system time
        ; Since dos apps rarely know what is real time
        ; we do not set the cmos clock\system time like dos 5.0

        ; convert time to 100th of secs
        mov     al,60
        mul     ch              ;hours to minutes
        mov     ch,0
        add     ax,cx           ;total minutes
        mov     cx,6000         ;60*100
        mov     bx,dx           ;get out of the way of the multiply
        mul     cx              ;convert to 1/100 sec
        mov     cx,ax
        mov     al,100
        mul     bh              ;convert seconds to 1/100 sec
        add     cx,ax           ;combine seconds with hours and min.
        adc     dx,0            ;ripple carry
        mov     bh,0
        add     cx,bx           ;combine 1/100 sec
        adc     dx,0            ;dx:cx is time in 1/100 sec

        ;convert 100th of secs to ticks
        xchg    ax,dx
        xchg    ax,cx           ;now time is in cx:ax
        mov     bx,59659
        mul     bx              ;multiply low half
        xchg    dx,cx
        xchg    ax,dx           ;cx->ax, ax->dx, dx->cx
        mul     bx              ;multiply high half
        add     ax,cx           ;combine overlapping products
        adc     dx,0
        xchg    ax,dx           ;ax:dx=time*59659
        mov     bx,5
        div     bl              ;divide high half by 5
        mov     cl,al
        mov     ch,0
        mov     al,ah           ;remainder of divide-by-5
        cbw
        xchg    ax,dx           ;use it to extend low half
        div     bx              ;divde low half by 5
        mov     dx,ax           ;cx:dx is now number of ticks in time


        ; set the bios tic count
        mov     ah, 1            ; set bios tick count
ifdef FASTINT1A
        call FastInt1a
else
        int  1ah
endif

        xor  al,al
        clc
        return
else    ;NEC_98
	PUSH	CX
	PUSH	DX

;hkn; 	ss is DOSDATA
	Context DS

;hkn;	TIMEBUF	is now in DOSDATA
	MOV	BX,OFFSET DOSDATA:TIMEBUF

	MOV	CX,6
	XOR	DX,DX
	MOV	AX,DX
	PUSH	BX
	invoke	SETREAD

;hkn;	DOSAssume   CS,<ES>,"TIME/SetRead"
;hkn;	DS can still be used to access BCLOCK

	PUSH	DS
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Get correct day count
	POP	DS
	DOSAssume   <DS>,"Set_Time"
	POP	BX
	invoke	SETWRITE
	POP	WORD PTR [TIMEBUF+4]
	POP	WORD PTR [TIMEBUF+2]
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Set the time
	XOR	AL,AL
	return
endif   ;NEC_98

EndProc $SET_TIME

ifdef NEC_98
SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
PAGE
;--------------------------------------------------------------------------
;
; Procedure Name : DATE16
;
; Date16 returns the current date in AX, current time in DX
;   AX - YYYYYYYMMMMDDDDD  years months days
;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
;
; DS = DOSGROUP on output
;
;--------------------------------------------------------------------------
procedure   DATE16,NEAR

;M048	Context DS		
;
; Since this function can be called thru int 2f we shall not assume that SS
; is DOSDATA

	getdseg	<ds>			; M048

	PUSH	CX
	PUSH	ES
	CALL	READTIME
	POP	ES
	SHL	CL,1			;Minutes to left part of byte
	SHL	CL,1
	SHL	CX,1			;Push hours and minutes to left end
	SHL	CX,1
	SHL	CX,1
	SHR	DH,1			;Count every two seconds
	OR	CL,DH			;Combine seconds with hours and minutes
	MOV	DX,CX

;	WARNING!  MONTH and YEAR must be adjacently allocated

	MOV	AX,WORD PTR [MONTH]	;Fetch month and year
	MOV	CL,4
	SHL	AL,CL			;Push month to left to make room for day
	SHL	AX,1
	POP	CX
	OR	AL,[DAY]
	return

EndProc DATE16

;----------------------------------------------------------------------------
;
; Procedure : READTIME
;
;Gets time in CX:DX. Figures new date if it has changed.
;Uses AX, CX, DX.
;
;----------------------------------------------------------------------------

procedure   READTIME,NEAR
	DOSAssume   <DS>,"ReadTime"

	MOV	[DATE_FLAG],0		; reset date flag for CPMIO
	PUSH	SI
	PUSH	BX

;hkn;	TIMEBUF is in DOSDATA
	MOV	BX,OFFSET DOSDATA:TIMEBUF

	MOV	CX,6
	XOR	DX,DX
	MOV	AX,DX
	invoke	SETREAD
	PUSH	DS
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Get correct date and time
	POP	DS
	DOSAssume   <DS>,"ReadTime2"
	POP	BX
	POP	SI
	MOV	AX,WORD PTR [TIMEBUF]
	MOV	CX,WORD PTR [TIMEBUF+2]
	MOV	DX,WORD PTR [TIMEBUF+4]
	CMP	AX,[DAYCNT]		;See if day count is the same
	retz
	CMP	AX,FOURYEARS*30 	;Number of days in 120 years
	JAE	RET22			;Ignore if too large
	MOV	[DAYCNT],AX
	PUSH	SI
	PUSH	CX
	PUSH	DX			;Save time
	XOR	DX,DX
	MOV	CX,FOURYEARS		;Number of days in 4 years
	DIV	CX			;Compute number of 4-year units
	SHL	AX,1
	SHL	AX,1
	SHL	AX,1			;Multiply by 8 (no. of half-years)
	MOV	CX,AX			;<240 implies AH=0

;hkn;	YRTAB is in DOSDATA
	MOV     SI,OFFSET DOSDATA:YRTAB;Table of days in each year

	CALL	DSLIDE			;Find out which of four years we're in
	SHR	CX,1			;Convert half-years to whole years
	JNC	SK			;Extra half-year?
	ADD	DX,200
SK:
	CALL	SETYEAR
	MOV	CL,1			;At least at first month in year

;hkn;	MONTAB is in DOSDATA
	MOV     SI,OFFSET DOSDATA:MONTAB   ;Table of days in each month

	CALL	DSLIDE			;Find out which month we're in
	MOV	[MONTH],CL
	INC	DX			;Remainder is day of month (start with one)
	MOV	[DAY],DL
	CALL	WKDAY			;Set day of week
	POP	DX
	POP	CX
	POP	SI
RET22:	return
EndProc READTIME

;----------------------------------------------------------------------------
; Procedure : DSLIDE
;----------------------------------------------------------------------------

	procedure   DSLIDE,NEAR
	MOV	AH,0
DSLIDE1:
	LODSB				;Get count of days
	CMP	DX,AX			;See if it will fit
	retc				;If not, done
	SUB	DX,AX
	INC	CX			;Count one more month/year
	JMP	SHORT DSLIDE1
EndProc DSLIDE

;----------------------------------------------------------------------------
;
; Procedure : SETYEAR
;
; Set year with value in CX. Adjust length of February for this year.
;
; NOTE: This can also be called thru int 2f. If this is called then it will
;       set DS to DOSDATA. Since the only guy calling this should be the DOS
;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
;	preserve DS as CHKYR is also called as a routine.
;
;----------------------------------------------------------------------------

procedure   SETYEAR,NEAR

	GETDSEG DS

	MOV	BYTE PTR [YEAR],CL
CHKYR:
	TEST	CL,3			;Check for leap year
	MOV	AL,28
	JNZ	SAVFEB			;28 days if no leap year
	INC	AL			;Add leap day
SAVFEB:
	MOV	[MONTAB+1],AL		;Store for February
RET23:	return

EndProc SETYEAR

;---------------------------------------------------------------------------
;
; Procedure Name : DODATE
;
;---------------------------------------------------------------------------

procedure   DODATE,NEAR

	DOSAssume   <DS>,"DoDate"
	CALL	CHKYR			;Set Feb. up for new year
	MOV	AL,DH

;hkn;	MONTAB is in DOSDATA
	MOV     BX,OFFSET DOSDATA:MONTAB-1

	XLAT				;Look up days in month
	CMP	AL,DL
	MOV	AL,-1			;Restore error flag, just in case
	retc				;Error if too many days
	CALL	SETYEAR
;
; WARNING!  DAY and MONTH must be adjacently allocated
;
	MOV	WORD PTR [DAY],DX	;Set both day and month
	SHR	CX,1
	SHR	CX,1
	MOV	AX,FOURYEARS
	MOV	BX,DX
	MUL	CX
	MOV	CL,BYTE PTR [YEAR]
	AND	CL,3

;hkn;	YRTAB is in DOSDATA
	MOV	SI,OFFSET DOSDATA:YRTAB
	MOV	DX,AX
	SHL	CX,1			;Two entries per year, so double count
	CALL	DSUM			;Add up the days in each year
	MOV	CL,BH			;Month of year

;hkn;	MONTAB is in DOSDATA
	MOV	SI,OFFSET DOSDATA:MONTAB
	DEC	CX			;Account for months starting with one
	CALL	DSUM			;Add up days in each month
	MOV	CL,BL			;Day of month
	DEC	CX			;Account for days starting with one
	ADD	DX,CX			;Add in to day total
	XCHG	AX,DX			;Get day count in AX
	MOV	[DAYCNT],AX
	PUSH	SI
	PUSH	BX
	PUSH	AX

;hkn;	TIMEBUF is in DOSDATA
	MOV	BX,OFFSET DOSDATA:TIMEBUF

	MOV	CX,6
	XOR	DX,DX
	MOV	AX,DX
	PUSH	BX
	invoke	SETREAD

;hkn;	DOSAssume   CS,<ES>,"DoDate/SetRead"
;hkn;	DS is still valid and can be used to access BCLOCK

	PUSH	DS
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Get correct date and time
	POP	DS
	POP	BX
	DOSAssume   <DS>,"DoDate2"
	invoke	SETWRITE
	POP	WORD PTR [TIMEBUF]
	PUSH	DS
	LDS	SI,[BCLOCK]
ASSUME	DS:NOTHING
	invoke	DEVIOCALL2		;Set the date
	POP	DS
	DOSAssume   <DS>,"DoDate3"
	POP	BX
	POP	SI
WKDAY:
	MOV	AX,[DAYCNT]
	XOR	DX,DX
	MOV	CX,7
	INC	AX
	INC	AX			;First day was Tuesday
	DIV	CX			;Compute day of week
	MOV	[WEEKDAY],DL
	XOR	AL,AL			;Flag OK
Ret25:	return

EndProc DODATE



;**	DSUM - Compute the sum of a string of bytes
;
;	ENTRY	(cx) = byte count
;		(ds:si) = byte address
;		(dx) = sum register, initialized by caller
;	EXIT	(dx) updated
;	USES	ax, cx, dx, si, flags

procedure   DSUM,NEAR

	MOV	AH,0
	JCXZ	dsum9

dsum1:	LODSB
	ADD	DX,AX
	LOOP	DSUM1
dsum9:	return

EndProc DSUM
endif   ;NEC_98

DOSCODE      ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\srvcall.asm ===
TITLE SRVCALL - Server DOS call
	NAME  SRVCALL

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	SRVCALL.ASM - Server DOS call functions
;
;
;	$ServerCall
;
;	Modification history:
;
;	    Created: ARR 08 August 1983
;	    SudeepB 07-Aug-1992 Ported For NT DOS


	.xlist
	.xcref
	include version.inc
	include dosseg.inc
	INCLUDE DOSSYM.INC
	INCLUDE DEVSYM.INC
	include mult.inc
	include sf.inc
	.cref
	.list

AsmVars <Installed>

include dpl.asm

Installed = TRUE

	i_need	USER_ID,WORD
	i_need	PROC_ID,WORD
	i_need	SaveBX,WORD
	i_need	SaveDS,WORD
	i_need	SWAP_START,BYTE
	i_need	SWAP_ALWAYS,BYTE
	i_need	SWAP_END,BYTE
	I_Need	ThisSFT,DWORD
	I_need	fSharing,BYTE
	i_need	OpenBuf,128
	I_Need	ExtErr,WORD
	I_Need	ExtErr_Action,BYTE
	I_Need	ExtErrPt,DWORD
	I_Need	EXTERR_LOCUS,BYTE	; Extended Error Locus
	i_need	JShare,DWORD
;SR;
; Win386 presence flag
;
	I_need	IsWin386,byte


DOSCODE	SEGMENT
	ASSUME	SS:DOSDATA,CS:DOSCODE


BREAK <ServerCall -- Server DOS call>

;hkn; TABLE	SEGMENT
Public SRVC001S,SRVC001E
SRVC001S label byte

ServerTab	DW	DOSCODE:Server_Disp
SERVERLEAVE	DW	DOSCODE:ServerReturn
SERVER_DISP	DB	(SERVER_DISP_END-SERVER_DISP-1)/2
		DW	OFFSET DOSCODE:SRV_CALL		; 0
		DW	OFFSET DOSCODE:SC_NO_OP		; 1
		DW	OFFSET DOSCODE:SC_NO_OP 	; 2
		DW	OFFSET DOSCODE:SC_NO_OP 	; 3
		DW	OFFSET DOSCODE:SC_NO_OP 	; 4
		DW	OFFSET DOSCODE:SC_ERROR 	; 5
		DW	OFFSET DOSCODE:GET_DOS_DATA	; 6
		DW	OFFSET DOSCODE:SPOOL_OPER	; 7
		DW	OFFSET DOSCODE:SPOOL_OPER	; 8
		DW	OFFSET DOSCODE:SPOOL_OPER	; 9
		DW	OFFSET DOSCODE:$setExtendedError   ; 10
SERVER_DISP_END LABEL	BYTE

SRVC001E label byte

;hkn; TABLE	ENDS

;----------------------------------------------------------------------------
;
; Procedure Name : $ServerCall
;
; Inputs:
;	DS:DX -> DPL  (except calls 7,8,9)
; Function:
;	AL=0	Server DOS call
;	AL=1	Commit All files
;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
;	AL=3	Close all files for DPL_UID
;	AL=4	Close all files for DPL_UID/PID_PID
;	AL=5	Get open file list entry
;		    IN: BX File Index
;			CX User Index
;		    OUT:ES:DI -> Name
;			BX = UID
;		    CX = # locked blocks held by this UID
;	AL=6	Get DOS data area
;		    OUT: DS:SI -> Start
;			CX size in bytes of swap if indos
;			DX size in bytes of swap always
;	AL=7	Get truncate flag
;	AL=8	Set truncate flag
;	AL=9	Close all spool files
;	AL=10	SetExtendedError
;
;----------------------------------------------------------------------------

procedure   $ServerCall,NEAR
	CMP	AL,7
	JB	SET_STUFF
	CMP	AL,9
	JBE	NO_SET_ID		; No DPL on calls 7,8,9
SET_STUFF:
	MOV	SI,DX			; Point to DPL with DS:SI
	MOV	BX,[SI.DPL_UID]

;SR;
; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
; of USER_ID
;
	test	[IsWin386],1
	jnz	skip_win386

;hkn; SS override for user_id and proc_id
	MOV	[USER_ID],BX		; Set UID

skip_win386:

	MOV	BX,[SI.DPL_PID]
	MOV	[PROC_ID],BX		; Set process ID
NO_SET_ID:
	PUSH	SERVERLEAVE		; push return address
	PUSH	ServerTab		; push table address
	PUSH	AX
	Invoke	TableDispatch

;hkn; SS override
	MOV	EXTERR_LOCUS,errLoc_Unk ; Extended Error Locus
	error	error_invalid_function
ServerReturn:
	return


SC_NO_OP:
ASSUME	DS:NOTHING,ES:NOTHING
	transfer    Sys_Ret_OK

SC_ERROR:
	transfer SYS_RET_ERR

SRV_CALL:
ASSUME	DS:NOTHING,ES:NOTHING
	POP	AX			; get rid of call to $srvcall
	SAVE	<DS,SI>
	invoke	GET_USER_STACK
	RESTORE <DI,ES>
;
; DS:SI point to stack
; ES:DI point to DPL
;
	invoke	XCHGP
;
; DS:SI point to DPL
; ES:DI point to stack
;
; We now copy the registers from DPL to save stack
;
	SAVE	<SI>
	MOV	CX,6
	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
	INC	DI
	INC	DI			; Skip user_BP
	MOVSW				; DS
	MOVSW				; ES
	RESTORE <SI>		; DS:SI -> DPL
	MOV	AX,[SI.DPL_AX]
	MOV	BX,[SI.DPL_BX]
	MOV	CX,[SI.DPL_CX]
	MOV	DX,[SI.DPL_DX]
	MOV	DI,[SI.DPL_DI]
	MOV	ES,[SI.DPL_ES]
	PUSH	[SI.DPL_SI]
	MOV	DS,[SI.DPL_DS]
	POP	SI

;hkn; SS override for next 3
	MOV	[SaveDS],DS
	MOV	[SaveBX],BX
        ;MOV     fSharing,-1             ; set no redirect flag
	transfer REDISP

GET_DOS_DATA:
	ASSUME	DS:NOTHING,ES:NOTHING
	Context ES
	MOV     DI,OFFSET DOSDATA:SWAP_START
	MOV     CX,OFFSET DOSDATA:SWAP_END
	MOV     DX,OFFSET DOSDATA:Swap_Always
	SUB     CX,DI
	SUB     DX,DI
	SHR     CX,1                    ; div by 2, remainder in carry
	ADC     CX,0                    ; div by 2 + round up
	SHL     CX,1                    ; round up to 2 boundary.
	invoke  GET_USER_STACK
	MOV     [SI.user_DS],ES
	MOV     [SI.user_SI],DI
	MOV     [SI.user_DX],DX
	MOV	[SI.user_CX],CX
	transfer    SYS_RET_OK

SPOOL_OPER:
ASSUME	DS:NOTHING,ES:NOTHING
	CallInstall NETSpoolOper,multNet,37,AX,BX
	JC	func_err2
	transfer SYS_RET_OK
func_err2:
	transfer SYS_RET_ERR

Break	<$SetExtendedError - set extended error for later retrieval>
;--------------------------------------------------------------------------
;
; Procedure Name : $SetExtendedError
;
; $SetExtendedError takes extended error information and loads it up for the
; next extended error call.  This is used by interrupt-level proccessors to
; mask their actions.
;
;   Inputs: DS:SI points to DPL which contains all registers
;   Outputs: none
;
;---------------------------------------------------------------------------

$SetExtendedError:

;hkn; SS override for all variables used

	ASSUME	DS:NOTHING,ES:NOTHING
	MOV	AX,[SI].dpl_AX
	MOV	[EXTERR],AX
	MOV	AX,[SI].dpL_di
	MOV	WORD PTR ExtErrPt,AX
	MOV	AX,[SI].dpL_ES
	MOV	WORD PTR ExtErrPt+2,AX
	MOV	AX,[SI].dpL_BX
	MOV	WORD PTR [EXTERR_ACTION],AX
	MOV	AX,[SI].dpL_CX
	MOV	[EXTERR_LOCUS],AH
	return
EndProc $ServerCall, NoCheck

DOSCODE	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC" LANGID=804      
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC" LANGID=804     
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98" LANGID=411
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN" LANGID=404      
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN" LANGID=411      
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)   

msdos.skl : ..\usa\msdos.skl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\doskrnl\dos\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA" LANGID=412      
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\assert.h ===
/***
*assert.h - define the assert macro
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the assert(exp) macro.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef _ASSERT_DEFINED

#ifndef NDEBUG

static char _assertstring[] = "Assertion failed: %s, file %s, line %d\n";

#define assert(exp) { \
    if (!(exp)) { \
        fprintf(stderr, _assertstring, #exp, __FILE__, __LINE__); \
        fflush(stderr); \
        abort(); \
        } \
    }

#else

#define assert(exp)

#endif /* NDEBUG */

#define _ASSERT_DEFINED

#endif /* _ASSERT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   the MS C V2.03 compatible console and port I/O routines.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

/* function prototypes */

char * _CDECL cgets(char *);
int _CDECL cprintf(char *, ...);
int _CDECL cputs(char *);
int _CDECL cscanf(char *, ...);
int _CDECL getch(void);
int _CDECL getche(void);
int _CDECL inp(unsigned int);
unsigned _CDECL inpw(unsigned int);
int _CDECL kbhit(void);
int _CDECL outp(unsigned int, int);
unsigned _CDECL outpw(unsigned int, unsigned int);
int _CDECL putch(int);
int _CDECL ungetch(int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\bios.inc ===
; BIOS Interface Macros	- Version 1.0 -	for Microsoft Macro Assembler 5.0
; (C) Copyright	Microsoft Corporation, 1987.

.XCREF
.XLIST
IF1
; 0Fh
@GetMode	MACRO
		mov	ah,0Fh
		int	10h
		ENDM
; 00h
@SetMode	MACRO	mode
		mov	al,mode
		xor	ah,ah
		int	10h
		ENDM
; 0Bh
@SetColor	MACRO	color
		sub	bh,bh
		mov	bl,color
		mov	ah,0Bh
		int	10h
		ENDM
; 0Bh
@SetPalet	MACRO	color
		mov	bh,1
		mov	bl,color
		mov	ah,0Bh
		int	10h
		ENDM
; 05h
@SetPage	MACRO	page
		mov	al,page
		mov	ah,05h
		int	10h
		ENDM
; 03h
@GetCur		MACRO	page
		IFNB	<page>
		mov	bh,page
		ELSE
		xor	bh,bh
		ENDIF
		mov	ah,03h
		int	10h
		ENDM
; 02h
@SetCurPos	MACRO	column,row,page
		IFNB	<column>
		mov	dl,column
		ENDIF
		IFNB	<row>
		mov	dh,row
		ENDIF
		IFNB	<page>
		mov	bh,page
		ELSE
		xor	bh,bh
		ENDIF
		mov	ah,02h
		int	10h
		ENDM
; 01h
@SetCurSz	MACRO	first,last
		mov	ch,first
		mov	cl,last
		mov	ah,01h
		int	10h
		ENDM
; 08h
@GetChAtr	MACRO	page
		IFNB	<page>
		mov	bh,page
		ELSE
		sub	bh,bh
		ENDIF
		mov	ah,08h
		int	10h
		ENDM
; 09h
@PutChAtr	MACRO	char,atrib,page,repeat
		IFNB	<char>
		mov	al,char
		ENDIF
		IFNB	<atrib>
		mov	bl,atrib
		ENDIF
		IFNB	<page>
		mov	bh,page
		ELSE
		xor	bh,bh
		ENDIF
		IFNB	<repeat>
		mov	cx,repeat
		ELSE
		mov	cx,1
		ENDIF
		mov	ah,09h
		int	10h
		ENDM
; 0Ah
@PutCh		MACRO	char,atrib,page,repeat
		IFNB	<char>
		mov	al,char
		ENDIF
		IFNB	<atrib>
		mov	bl,atrib
		ENDIF
		IFNB	<page>
		mov	bh,page
		ELSE
		xor	bh,bh
		ENDIF
		IFNB	<repeat>
		mov	cx,repeat
		ELSE
		mov	cx,1
		ENDIF
		mov	ah,0Ah
		int	10h
		ENDM
; 06h and 07h
@Scroll		MACRO	distance,atrib,upcol,uprow,downcol,downrow
		IFDEF	upcol
		mov	cl,upcol
		ENDIF
		IFDEF	uprow
		mov	ch,uprow
		ENDIF
		IFDEF	upcol
		mov	dl,upcol
		ENDIF
		IFDEF	updownrow
		mov	dh,downrow
		ENDIF
		IFDEF	atrib
		mov	bh,atrib
		ELSE
		mov	bh,07h
		ENDIF
		IF	distance LE 0
		mov	ax,0600h + (-(distance)	AND 0FFh)
		ELSE
		mov	ax,0700h + (distance AND 0FFh)
		ENDIF
		int	10h
		ENDM
; 08h, 06h, and	02h
@Cls		MACRO
		@GetChAtr
		mov	bl,bh
		mov	bh,ah
		sub	cx,cx
		mov	dx,184Fh
		mov	ax,0600h
		int	10h
		mov	bh,bl
		sub	dx,dx
		mov	ah,02h
		int	10h
		ENDM
ENDIF
.CREF
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\copyrigh.h ===
//M000 - Updated copyright message
char	*copyright1 =  "MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp ";
char	*copyright2 =  "Licensed Material - Property of Microsoft ";
char   *copyright3 =  "All rights reserved ";

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines macros for character classification/conversion.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char _NEAR _CDECL _ctype[];

/* set bit masks for the possible character types */

#define _UPPER        0x1       /* upper case letter */
#define _LOWER        0x2       /* lower case letter */
#define _DIGIT        0x4       /* digit[0-9] */
#define _SPACE        0x8       /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT       0x10       /* punctuation character */
#define _CONTROL     0x20       /* control character */
#define _BLANK       0x40       /* space char */
#define _HEX         0x80       /* hexadecimal digit */

/* the character classification macro definitions */

#define isalpha(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER) )
#define isupper(c)      ( (_ctype+1)[c] & _UPPER )
#define islower(c)      ( (_ctype+1)[c] & _LOWER )
#define isdigit(c)      ( (_ctype+1)[c] & _DIGIT )
#define isxdigit(c)     ( (_ctype+1)[c] & _HEX )
#define isspace(c)      ( (_ctype+1)[c] & _SPACE )
#define ispunct(c)      ( (_ctype+1)[c] & _PUNCT )
#define isalnum(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(c)      ( (_ctype+1)[c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(c)      ( (_ctype+1)[c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(c)      ( (_ctype+1)[c] & _CONTROL )

#define toupper(c)      ( (islower(c)) ? _toupper(c) : (c) )
#define tolower(c)      ( (isupper(c)) ? _tolower(c) : (c) )

#define _tolower(c)     ( (c)-'A'+'a' )
#define _toupper(c)     ( (c)-'a'+'A' )

#define isascii(c)      ( (unsigned)(c) < 0x80 )
#define toascii(c)      ( (c) & 0x7f )

/* MS C version 2.0 extended ctype macros */

#define iscsymf(c)      (isalpha(c) || ((c) == '_'))
#define iscsym(c)       (isalnum(c) || ((c) == '_'))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the library
*   functions related to directory handling and creation.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

/* function prototypes */

int _CDECL chdir(char *);
char * _CDECL getcwd(char *, int);
int _CDECL mkdir(char *);
int _CDECL rmdir(char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*   Copyright (c) 1987-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file declares the constants, structures, and functions
*   used for accessing and using various BIOS interfaces.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else   /* extensions not enabled */
    #define _CDECL
#endif  /* NO_EXT_KEYS */

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT       0   /* init serial port */
#define _COM_SEND       1   /* send character */
#define _COM_RECEIVE    2   /* receive character */
#define _COM_STATUS     3   /* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7       2   /* 7 bits characters */
#define _COM_CHR8       3   /* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1      0   /* 1 stop bit */
#define _COM_STOP2      4   /* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY   0   /* no parity */
#define _COM_ODDPARITY  8   /* odd parity */
#define _COM_EVENPARITY 24  /* even parity */

/*  baud rate initializers */

#define _COM_110        0       /* 110 baud */
#define _COM_150        32      /* 150 baud */
#define _COM_300        64      /* 300 baud */
#define _COM_600        96      /* 600 baud */
#define _COM_1200       128     /* 1200 baud */
#define _COM_2400       160     /* 2400 baud */
#define _COM_4800       192     /* 4800 baud */
#define _COM_9600       224     /* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET     0   /* reset disk controller */
#define _DISK_STATUS    1   /* get disk status */
#define _DISK_READ      2   /* read disk sectors */
#define _DISK_WRITE     3   /* write disk sectors */
#define _DISK_VERIFY    4   /* verify disk sectors */
#define _DISK_FORMAT    5   /* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef NO_EXT_KEYS     /* extensions must be enabled */

#ifndef _DISKINFO_T_DEFINED

struct diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void far *buffer;
    };

#define _DISKINFO_T_DEFINED

#endif

#endif /* NO_EXT_KEYS */


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ        0   /* read next character from keyboard */
#define _KEYBRD_READY       1   /* check for keystroke */
#define _KEYBRD_SHIFTSTATUS 2   /* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE  0   /* write character to printer */
#define _PRINTER_INIT   1   /* intialize printer */
#define _PRINTER_STATUS 2   /* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK  0   /* get current clock count */
#define _TIME_SETCLOCK  1   /* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif /* _REGS_DEFINED */


/* function prototypes */

unsigned _CDECL _bios_equiplist(void);
unsigned _CDECL _bios_keybrd(unsigned);
unsigned _CDECL _bios_memsize(void);
unsigned _CDECL _bios_printer(unsigned, unsigned, unsigned);
unsigned _CDECL _bios_serialcom(unsigned, unsigned, unsigned);
unsigned _CDECL _bios_timeofday(unsigned, long *);
int _CDECL int86(int, union REGS *, union REGS *);
int _CDECL int86x(int, union REGS *, union REGS *, struct SREGS *);

#ifndef NO_EXT_KEYS     /* extensions must be enabled */

unsigned _CDECL _bios_disk(unsigned, struct diskinfo_t *);

#endif /* NO_EXT_KEYS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the system-wide error numbers (set by
*   system calls).  Conforms to the XENIX standard.  Extended
*   for compatibility with Uniforum standard.
*   [System V]
*
*******************************************************************************/

#define  EZERO      0
#define  EPERM      1
#define  ENOENT     2
#define  ESRCH      3
#define  EINTR      4
#define  EIO        5
#define  ENXIO      6
#define  E2BIG      7
#define  ENOEXEC    8
#define  EBADF      9
#define  ECHILD    10
#define  EAGAIN    11
#define  ENOMEM    12
#define  EACCES    13
#define  EFAULT    14
#define  ENOTBLK   15
#define  EBUSY     16
#define  EEXIST    17
#define  EXDEV     18
#define  ENODEV    19
#define  ENOTDIR   20
#define  EISDIR    21
#define  EINVAL    22
#define  ENFILE    23
#define  EMFILE    24
#define  ENOTTY    25
#define  ETXTBSY   26
#define  EFBIG     27
#define  ENOSPC    28
#define  ESPIPE    29
#define  EROFS     30
#define  EMLINK    31
#define  EPIPE     32
#define  EDOM      33
#define  ERANGE    34
#define  EUCLEAN   35
#define  EDEADLOCK 36
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines constants for the file control options used
*   by the open() function.
*   [System V]
*
*******************************************************************************/

#define O_RDONLY    0x0000  /* open for reading only */
#define O_WRONLY    0x0001  /* open for writing only */
#define O_RDWR      0x0002  /* open for reading and writing */
#define O_APPEND    0x0008  /* writes done at eof */

#define O_CREAT     0x0100  /* create and open file */
#define O_TRUNC     0x0200  /* open and truncate */
#define O_EXCL      0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define O_TEXT      0x4000  /* file mode is text (translated) */
#define O_BINARY    0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define O_RAW   O_BINARY

/* Open handle inherit bit */

#define O_NOINHERIT 0x0080      /* child process doesn't inherit file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\dos.inc ===
; DOS Interface Macros - Version 1.0 - for Microsoft Macro Assembler 5.0
; (C) Copyright Microsoft Corporation, 1987, 1988.

.XCREF
.XLIST
IF1
; Internal
__LdAdr MACRO reg, adr
    IF (.TYPE (adr)) AND 00010000b     ;; Register
        mov     reg, adr
    ELSEIF (.TYPE (adr)) AND 00000100b ;; Constant
        mov     reg, adr
    ELSEIF TYPE (adr) EQ 1             ;; Bytes
        mov    reg, OFFSET adr
    ELSEIF TYPE (adr) EQ 2             ;; Near pointer
        mov    reg, adr
    ELSEIF TYPE (adr) EQ 4             ;; Far pointer
        lds    reg, adr
    ELSE
        .ERR
        %OUT Illegal argument
    ENDIF
ENDM

; Internal
__LdSeg MACRO dest, src
    IFIDNI <src>, <es>                 ;; Segment register
        mov     ax, src
        mov     dest, ax
    ELSEIFIDNI <src>, <ss>
        mov     ax, src
        mov     dest, ax
    ELSEIFIDNI <src>, <ds>
        mov     ax, src
        mov     dest, ax
    ELSEIFIDNI <src>, <ds>
        mov     ax, src
        mov     dest, ax
    ELSEIF (.TYPE (src)) AND 00000100b ;; Constant
        mov     ax, src
        mov     dest, ax
    ELSE                               ;; Memory or general register 
        mov     dest, src
    ENDIF
ENDM

; 01h, 07h, 08h, 0Ch
@GetKey MACRO echo, cc, clear
    LOCAL   funct, disp
    IFDIF   <echo>, <0>
        IFDIF   <cc>, <0>
            funct   = 01h
        ELSE
            funct   = 07h
            disp    = 02h
        ENDIF
    ELSE
        IFDIF   <cc>, <0>
            funct   = 08h
        ELSE
            funct   = 07h
        ENDIF
    ENDIF
    IFB     <clear>
        mov     ah, funct
    ELSE
        IFIDN   <clear>, <0>
            mov     ah, funct
        ELSE
            mov     ah, 0Ch
            mov     al, funct
        ENDIF
    ENDIF
    int     21h
    IFDEF   disp
        mov     dl, al
        mov     ah, disp
        int     21h
    ENDIF
ENDM

; 0Ah
@GetStr MACRO ofset, terminator, limit, segmnt
    __LdAdr dx, <ofset>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 0Ah
    mov     si, dx
    IFNB    <limit>
        mov     BYTE PTR [si], limit
    ENDIF
    int     21h
    inc     si
    mov     bl, [si]
    sub     bh, bh
    inc     si
    IFNB    <terminator>
        mov     BYTE PTR [bx+si], terminator
    ENDIF
ENDM

; 02h
@DispCh MACRO ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10
    mov     ah, 02h
    IRP     char, <ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10>
        IFB     <char>
            EXITM
        ENDIF
        mov     dl, char
        int     21h
    ENDM
ENDM

; 05h
@PrtCh MACRO ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10
    mov     ah, 05h
    IRP     char, <ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10>
        IFB     <char>
            EXITM
        ENDIF
        mov     dl, char
        int     21h
    ENDM
ENDM

; 09h
@DispStr MACRO ofset, segmnt
    __LdAdr dx, <ofset>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 9
    int     21h
ENDM

; 3Fh
@Read MACRO ofset, bytes, handle, segmnt
    IFNB    <handle>
        mov     bx, handle
    ELSE
        sub     bx, bx
    ENDIF
    mov     cx, bytes
    __LdAdr dx, <ofset>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 3Fh
    int     21h
ENDM

; 40h
@Write MACRO ofset, bytes, handle, segmnt
    IFNB    <handle>
        mov     bx, handle
    ELSE
        mov     bx, 1
    ENDIF
    mov     cx, bytes
    __LdAdr dx, <ofset>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 40h
    int     21h
ENDM

; 3Ch
@MakFil MACRO path, atrib, segmnt, kind
    IFB     <atrib>
        sub     cx, cx
    ELSE
        mov     cx, atrib
    ENDIF
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    IFIDNI  <kind>, <tmp>
        mov     ah, 5Ah
    ELSEIFIDNI <kind>, <new>
        mov    ah, 5Bh
    ELSE
        mov    ah, 3Ch
    ENDIF
    int     21h
ENDM

; 3Dh
@OpenFil MACRO path, access, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ax, 3D00h + (access AND 0FFh)
    int     21h
ENDM

; 3Eh
@ClosFil MACRO handle
    mov     bx, handle
    mov     ah, 3Eh
    int     21h
ENDM

; 41h
@DelFil MACRO path, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 41h
    int     21h
ENDM

; 56h
@MoveFil MACRO old, new, segold, segnew
    __LdAdr dx, <old>
    __LdAdr di, <new>
    IFNB    <segold>
        __LdSeg ds, <segold>
    ENDIF
    IFNB    <segnew>
        __LdSeg es, <segnew>
    ENDIF
    mov     ah, 56h
    int     21h
ENDM

; 4Eh
@GetFirst MACRO path, atrib, segmnt
    IFNB    <atrib>
        mov     cx, atrib
    ELSE
        sub     cx, cx
    ENDIF
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 4Eh
    int     21h
ENDM

; 4Fh
@GetNext MACRO
    mov     ah, 4Fh
    int     21h
ENDM

; 2Fh
@GetDTA MACRO
    mov     ah, 2Fh
    int     21h
ENDM

; 1Ah
@SetDTA MACRO buffer, segmnt
    __LdAdr dx, <buffer>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 1Ah
    int     21h
ENDM

; Internal
__LdDub MACRO dub
    IF   TYPE (dub) EQ 2
        sub  cx, cx
        mov  dx, dub
    ELSEIF TYPE (dub) EQ 4
        mov  cx, dub[2]
        mov  dx, dub[0]
    ELSEIF TYPE (dub) EQ 0
        sub     cx, cx
        mov     dx, dub
    ELSE
        .ERR
        %OUT Illegal argument
    ENDIF
ENDM

; 42h
@GetFilSz MACRO handle
    mov     bx, handle
    sub     cx, cx
    sub     dx, dx
    mov     ax, 4202h
    int     21h
    push    dx
    push    ax
    sub     dx, dx
    mov     ax, 4200h
    int     21h
    pop     ax
    pop     dx
ENDM

; 42h
@MovePtrAbs MACRO handle, distance
    IFNB    <distance>
        __LdDub <distance>
    ENDIF
    mov     bx, handle
    mov     ax, 4200h
    int     21h
ENDM

; 42h
@MovePtrRel MACRO handle, distance
    IFNB    <distance>
        __LdDub <distance>
    ENDIF
    mov     bx, handle
    mov     ax, 4201h
    int     21h
ENDM

; 39h
@MkDir MACRO path, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 39h
    int     21h
ENDM

; 3Ah
@RmDir MACRO path, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 3Ah
    int     21h
ENDM

; 3Bh
@ChDir MACRO path, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 3Bh
    int     21h
ENDM

; 47h
@GetDir MACRO buffer, drive, segmnt
    IFNB    <drive>
        mov     dl, drive
    ELSE
        sub     dl, dl
    ENDIF
    __LdAdr si, <buffer>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 47h
    int     21h
ENDM

; 19h
@GetDrv MACRO
    mov     ah, 19h
    int     21h
ENDM

; 0Eh
@SetDrv MACRO drive
    mov     dl, drive
    mov     ah, 0Eh
    int     21h
ENDM

; 36h
@ChkDrv MACRO drive
    IFNB    <drive>
        mov     dl, drive
    ELSE
        sub     dl, dl
    ENDIF
    mov     ah, 36h
    int     21h
ENDM

; 4Ch
@Exit MACRO return
    IFB     <return>
        mov     ah, 4Ch
    ELSE
        mov     ax, 4C00h + (return AND 0FFh)
    ENDIF
    int     21h
ENDM

; 4Bh
@Exec MACRO path, parms, segpath, segparms, overlay
    __LdAdr dx, <path>
    __LdAdr bx, <parms>
    IFNB    <segpath>
        __LdSeg ds, <segpath>
    ENDIF
    IFNB    <segparms>
        __LdSeg es, <segparms>
    ENDIF
    IFB     <overlay>
        mov     ax, 4B00h
    ELSE
        mov     ax, 4B03h
    ENDIF
    int     21h
ENDM

; 4Dh
@GetRet MACRO
    mov     ah, 4Dh
    int     21h
ENDM

; 31h
@TSR MACRO paragraphs, return
    mov     dx, paragraphs
    IFB     <return>
        mov     ah, 31h
    ELSE
        mov     ax, 3100h + (return AND 0FFh)
    ENDIF
    int     21h
ENDM

; 49h
@FreeBlok MACRO segmnt
    IFNB    <segmnt>
        __LdSeg es, <segmnt>
    ENDIF
    mov     ah, 49h
    int     21h
ENDM

; 48h
@GetBlok MACRO graphs
    LOCAL   tryit
    mov     bx, graphs
    tryit:  mov     ah, 48h
    int     21h
    jc      tryit
ENDM

; 4Ah
@ModBlok MACRO graphs, segmnt
    IFNB    <segmnt>
        __LdSeg es, <segmnt>
    ENDIF
    mov     bx, graphs
    mov     ah, 4Ah
    int     21h
ENDM

; 2Ah
@GetDate MACRO
    mov     ah, 2Ah
    int     21h
ENDM

; 2Bh
@SetDate MACRO month, day, year
    mov     cx, year
    mov     dh, month
    mov     dl, day
    mov     ah, 2Bh
    int     21h
ENDM

; 2Ch
@GetTime MACRO
    mov     ah, 2Ch
    int     21h
ENDM

; 2Dh
@SetTime MACRO hour, minutes, seconds, hundredths
    mov     ch, hour
    mov     cl, minutes
    mov     dh, seconds
    mov     dl, hundredths
    mov     ah, 2Dh
    int     21h
ENDM

; 30h
@GetVer MACRO
    mov     ah, 30h
    int     21h
ENDM

; 35h
@GetInt MACRO   interrupt
    mov     ax, 3500h + (interrupt AND 0FFh)
    int     21h
ENDM

; 25h
@SetInt MACRO interrupt, vector, segmnt
    IF      TYPE (vector) GE 0FFFEh
        mov     dx, OFFSET vector
        mov     ax, SEG vector
        mov     ds, ax
    ELSE
        __LdAdr dx, <vector>
        IFNB    <segmnt>
            __LdSeg ds, <segmnt>
        ENDIF
    ENDIF
    mov     ax, 2500h + (interrupt AND 0FFh)
    int     21h
ENDM

ENDIF ; Pass 1
.CREF
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\float.h ===
/***
*float.h - constants for floating point values
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains defines for a number of implementation dependent
*   values which are commonly used by sophisticated numerical (floating
*   point) programs.
*   [ANSI]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  -307                    /* min decimal exponent
#define DBL_MIN_EXP     -1021                   /* min binary exponent */
#define DBL_RADIX       2                       /* exponent radix */
#define DBL_ROUNDS      0                       /* addition rounding: chops */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07         /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38         /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38         /* min positive value */
#define FLT_MIN_10_EXP  -37                     /* min decimal exponent */
#define FLT_MIN_EXP     -125                    /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      0                       /* addition rounding: chops */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min deimal exponent
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define LDBL_RADIX      DBL_RADIX               /* exponent radix */
#define LDBL_ROUNDS     DBL_ROUNDS              /* addition rounding: chops */


/*
 *  8087/80287 math control information
 */


/* User Control Word Mask and bit definitions.
 * These definitions match the 8087/80287
 */

#define     MCW_EM          0x003f      /* interrupt Exception Masks */
#define     EM_INVALID      0x0001      /*   invalid */
#define     EM_DENORMAL     0x0002      /*   denormal */
#define     EM_ZERODIVIDE   0x0004      /*   zero divide */
#define     EM_OVERFLOW     0x0008      /*   overflow */
#define     EM_UNDERFLOW    0x0010      /*   underflow */
#define     EM_INEXACT      0x0020      /*   inexact (precision) */

#define     MCW_IC          0x1000      /* Infinity Control */
#define     IC_AFFINE       0x1000      /*   affine */
#define     IC_PROJECTIVE   0x0000      /*   projective */

#define     MCW_RC          0x0c00      /* Rounding Control */
#define     RC_CHOP         0x0c00      /*   chop */
#define     RC_UP           0x0800      /*   up */
#define     RC_DOWN         0x0400      /*   down */
#define     RC_NEAR         0x0000      /*   near */

#define     MCW_PC          0x0300      /* Precision Control */
#define     PC_24           0x0000      /*    24 bits */
#define     PC_53           0x0200      /*    53 bits */
#define     PC_64           0x0300      /*    64 bits */


/* initial Control Word value */

#define CW_DEFAULT ( IC_AFFINE + RC_NEAR + PC_64 + EM_DENORMAL + EM_UNDERFLOW + EM_INEXACT )


/* user Status Word bit definitions */

#define SW_INVALID          0x0001      /*   invalid */
#define SW_DENORMAL         0x0002      /*   denormal */
#define SW_ZERODIVIDE       0x0004      /*   zero divide */
#define SW_OVERFLOW         0x0008      /*   overflow */
#define SW_UNDERFLOW        0x0010      /*   underflow */
#define SW_INEXACT          0x0020      /*   inexact (precision) */


/* invalid subconditions (SW_INVALID also set) */

#define SW_UNEMULATED       0x0040      /* unemulated instruction */
#define SW_SQRTNEG          0x0080      /* square root of a neg number */
#define SW_STACKOVERFLOW    0x0200      /* FP stack overflow */
#define SW_STACKUNDERFLOW   0x0400      /* FP stack underflow */


/*  Floating point error signals and return codes */

#define FPE_INVALID         0x81
#define FPE_DENORMAL        0x82
#define FPE_ZERODIVIDE      0x83
#define FPE_OVERFLOW        0x84
#define FPE_UNDERFLOW       0x85
#define FPE_INEXACT         0x86

#define FPE_UNEMULATED      0x87
#define FPE_SQRTNEG         0x88
#define FPE_STACKOVERFLOW   0x8a
#define FPE_STACKUNDERFLOW  0x8b

#define FPE_EXPLICITGEN     0x8c    /* raise( SIGFPE ); */

/* function prototypes */

unsigned int _CDECL _clear87(void);
unsigned int _CDECL _control87(unsigned int,unsigned int);
void _CDECL _fpreset(void);
unsigned int _CDECL _status87(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\graph.h ===
/***
*graph.h - declare constants and functions for graphics library
*
*   Copyright (c) 1987-1988, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file declares the graphics library functions and
*   the manifest constants that are used with them.
*
*******************************************************************************/

/* user-visible declarations for Quick-C Graphics Library */

#ifndef _GRAPH_T_DEFINED

/* structure for _getvideoconfig() as visible to user */
struct videoconfig {
        short numxpixels;       /* number of pixels on X axis */
        short numypixels;       /* number of pixels on Y axis */
        short numtextcols;      /* number of text columns available */
        short numtextrows;      /* number of text rows available */
        short numcolors;        /* number of actual colors */
        short bitsperpixel;     /* number of bits per pixel */
        short numvideopages;    /* number of available video pages */
        short mode;             /* current video mode */
        short adapter;          /* active display adapter */
        short monitor;          /* active display monitor */
        short memory;           /* adapter video memory in K bytes */
};

/* return value of _setlogorg(), etc. */
struct xycoord {
        short xcoord;
        short ycoord;
};

/* structure for text position */
struct rccoord {
        short row;
        short col;
};

#define _GRAPH_T_DEFINED

#endif


/* SETUP AND CONFIGURATION */

short far cdecl _setvideomode(short);

/* arguments to _setvideomode() */
#define _DEFAULTMODE    -1      /* restore screen to original mode */
#define _TEXTBW40       0       /* 40 x 25 text, 16 grey */
#define _TEXTC40        1       /* 40 x 25 text, 16/8 color */
#define _TEXTBW80       2       /* 80 x 25 text, 16 grey */
#define _TEXTC80        3       /* 80 x 25 text, 16/8 color */
#define _MRES4COLOR     4       /* 320 x 200, 4 color */
#define _MRESNOCOLOR    5       /* 320 x 200, 4 grey */
#define _HRESBW         6       /* 640 x 200, BW */
#define _TEXTMONO       7       /* 80 x 25 text, BW */
#define _HERCMONO       8       /* 720 x 348, BW for HGC */
#define _MRES16COLOR    13      /* 320 x 200, 16 color */
#define _HRES16COLOR    14      /* 640 x 200, 16 color */
#define _ERESNOCOLOR    15      /* 640 x 350, BW */
#define _ERESCOLOR      16      /* 640 x 350, 4 or 16 color */
#define _VRES2COLOR     17      /* 640 x 480, BW */
#define _VRES16COLOR    18      /* 640 x 480, 16 color */
#define _MRES256COLOR   19      /* 320 x 200, 256 color */

short far cdecl _setactivepage(short);
short far cdecl _setvisualpage(short);

/* videoconfig adapter values */
/* these manifest constants can be used to determine the type of monitor in */
/* use, using either simple comparisons or the bitwise-AND operator (&) */
#define _MDPA       0x0001      /* Monochrome Display Adapter (MDPA) */
#define _CGA        0x0002      /* Color Graphics Adapter     (CGA)  */
#define _EGA        0x0004      /* Enhanced Graphics Adapter  (EGA)  */
#define _VGA        0x0008      /* Video Graphics Array       (VGA)  */
#define _MCGA       0x0010      /* MultiColor Graphics Array  (MCGA) */
#define _HGC        0x0020      /* Hercules Graphics Card     (HGC)  */

/* videoconfig monitor values */
/* these manifest constants can be used to determine the type of the active */
/* adapter, using either simple comparisons or the bitwise-AND operator (&) */
#define _MONO       0x0001      /* Monochrome */
#define _COLOR      0x0002      /* Color (or Enhanced emulating color) */
#define _ENHCOLOR   0x0004      /* Enhanced Color */
#define _ANALOG     0x0018      /* Analog */

struct videoconfig far * far cdecl _getvideoconfig(struct videoconfig far *);


/* COORDINATE SYSTEMS */

struct xycoord far cdecl _setlogorg(short, short);
struct xycoord far cdecl _getlogcoord(short, short);
struct xycoord far cdecl _getphyscoord(short, short);

void far cdecl _setcliprgn(short, short, short, short);
void far cdecl _setviewport(short, short, short, short);


/* OUTPUT ROUTINES */

/* control parameters for Rectangle, Ellipse and Pie */
#define _GBORDER        2       /* draw outline only */
#define _GFILLINTERIOR  3       /* fill using current fill mask */

#define _GCLEARSCREEN 0
#define _GVIEWPORT    1
#define _GWINDOW      2

void far cdecl _clearscreen(short);

struct xycoord far cdecl _moveto(short, short);
struct xycoord far cdecl _getcurrentposition(void);

short far cdecl _lineto(short, short);
short far cdecl _rectangle(short, short, short, short, short);
short far cdecl _ellipse(short, short, short, short, short);
short far cdecl _arc(short, short, short, short, short, short, short, short);
short far cdecl _pie(short, short, short, short, short, short, short, short, short);

short far cdecl _setpixel(short, short);
short far cdecl _getpixel(short, short);
short far cdecl _floodfill(short, short, short);


/* PEN COLOR, LINE STYLE, FILL PATTERN */

short far cdecl _setcolor(short);
short far cdecl _getcolor(void);

void far cdecl _setlinestyle(unsigned short);
unsigned short far cdecl _getlinestyle(void);

void far cdecl _setfillmask(unsigned char far *);
unsigned char far * far cdecl _getfillmask(unsigned char far *);

/* COLOR SELECTION */

long far cdecl _setbkcolor(long);
long far cdecl _getbkcolor(void);

long far cdecl _remappalette(short, long);
short far cdecl _remapallpalette(long far *);
short far cdecl _selectpalette(short);


/* TEXT */
#define _GCURSOROFF 0
#define _GCURSORON  1

#define _GWRAPOFF   0
#define _GWRAPON    1

void far cdecl _settextwindow(short, short, short, short);
void far cdecl _outtext(char far *);
short far cdecl _wrapon(short);
short far cdecl _displaycursor(short);

struct rccoord far cdecl _settextposition(short, short);
struct rccoord far cdecl _gettextposition(void);

short far cdecl _settextcolor(short);
short far cdecl _gettextcolor(void);


/* SCREEN IMAGES */

void far cdecl _getimage(short, short, short, short, char far *);
void far cdecl _putimage(short, short, char far *, short);
long far cdecl _imagesize(short, short, short, short);

/* "action verbs" for _putimage() */
#define _GPSET          3
#define _GPRESET        2
#define _GAND           1
#define _GOR            0
#define _GXOR           4

/* universal color values: */
#define _BLACK          0x000000L
#define _BLUE           0x2a0000L
#define _GREEN          0x002a00L
#define _CYAN           0x2a2a00L
#define _RED            0x00002aL
#define _MAGENTA        0x2a002aL
#define _BROWN          0x00152aL
#define _WHITE          0x2a2a2aL
#define _GRAY           0x151515L
#define _LIGHTBLUE      0x3F1515L
#define _LIGHTGREEN     0x153f15L
#define _LIGHTCYAN      0x3f3f15L
#define _LIGHTRED       0x15153fL
#define _LIGHTMAGENTA   0x3f153fL
#define _LIGHTYELLOW    0x153f3fL
#define _BRIGHTWHITE    0x3f3f3fL

/* mono mode F color values: */
#define _MODEFOFF       0L
#define _MODEFOFFTOON   1L
#define _MODEFOFFTOHI   2L
#define _MODEFONTOOFF   3L
#define _MODEFON        4L
#define _MODEFONTOHI    5L
#define _MODEFHITOOFF   6L
#define _MODEFHITOON    7L
#define _MODEFHI        8L

/* mono mode 7 color values: */
#define _MODE7OFF       0L
#define _MODE7ON        1L
#define _MODE7HI        2L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the structs and unions used for the direct DOS interface
*   routines; includes macros to access the segment and offset
*   values of far pointers, so that they may be used by the routines; and
*   provides function prototypes for direct DOS interface functions.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };


/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };


/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };


/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED

struct DOSERROR {
    int exterror;
    char class;
    char action;
    char locus;
    };

#define _DOSERROR_DEFINED

#endif


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED

struct find_t {
    char reserved[21];
    char attrib;
    unsigned wr_time;
    unsigned wr_date;
    long size;
    char name[13];
    };

#define _FIND_T_DEFINED

#endif


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED

struct dosdate_t {
    unsigned char day;          /* 1-31 */
    unsigned char month;        /* 1-12 */
    unsigned int year;          /* 1980-2099 */
    unsigned char dayofweek;    /* 0-6, 0=Sunday */
    };

struct dostime_t {
    unsigned char hour;     /* 0-23 */
    unsigned char minute;   /* 0-59 */
    unsigned char second;   /* 0-59 */
    unsigned char hsecond;  /* 0-99 */
    };

#define _DATETIME_T_DEFINED

#endif


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct diskfree_t {
    unsigned total_clusters;
    unsigned avail_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
    };

#define _DISKFREE_T_DEFINED

#endif


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE     0   /* Ignore the error */
#define _HARDERR_RETRY      1   /* Retry the operation */
#define _HARDERR_ABORT      2   /* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL       3   /* Fail the system call in progress */
                                /* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_VOLID        0x08    /* Volume ID file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* macros to break MS C "far" pointers into their segment and offset
 * components
 */

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))


/* external variable declarations */

extern unsigned int _NEAR _CDECL _osversion;


/* function prototypes */

int _CDECL bdos(int, unsigned int, unsigned int);
void _CDECL _disable(void);
unsigned _CDECL _dos_allocmem(unsigned, unsigned *);
unsigned _CDECL _dos_close(int);
unsigned _CDECL _dos_creat(char *, unsigned, int *);
unsigned _CDECL _dos_creatnew(char *, unsigned, int *);
unsigned _CDECL _dos_findfirst(char *, unsigned, struct find_t *);
unsigned _CDECL _dos_findnext(struct find_t *);
unsigned _CDECL _dos_freemem(unsigned);
void _CDECL _dos_getdate(struct dosdate_t *);
void _CDECL _dos_getdrive(unsigned *);
unsigned _CDECL _dos_getdiskfree(unsigned, struct diskfree_t *);
unsigned _CDECL _dos_getfileattr(char *, unsigned *);
unsigned _CDECL _dos_getftime(int, unsigned *, unsigned *);
void _CDECL _dos_gettime(struct dostime_t *);
void _CDECL _dos_keep(unsigned, unsigned);
unsigned _CDECL _dos_open(char *, unsigned, int *);
unsigned _CDECL _dos_setblock(unsigned, unsigned, unsigned *);
unsigned _CDECL _dos_setdate(struct dosdate_t *);
void _CDECL _dos_setdrive(unsigned, unsigned *);
unsigned _CDECL _dos_setfileattr(char *, unsigned);
unsigned _CDECL _dos_setftime(int, unsigned, unsigned);
unsigned _CDECL _dos_settime(struct dostime_t *);
int _CDECL dosexterr(struct DOSERROR *);
void _CDECL _enable(void);
void _CDECL _hardresume(int);
void _CDECL _hardretn(int);
int _CDECL intdos(union REGS *, union REGS *);
int _CDECL intdosx(union REGS *, union REGS *, struct SREGS *);
int _CDECL int86(int, union REGS *, union REGS *);
int _CDECL int86x(int, union REGS *, union REGS *, struct SREGS *);
void _CDECL segread(struct SREGS *);


#ifndef NO_EXT_KEYS /* extensions enabled */
void _CDECL _chain_intr(void (_CDECL interrupt far *)());
void (_CDECL interrupt far * _CDECL _dos_getvect(unsigned))();
unsigned _CDECL _dos_read(int, void far *, unsigned, unsigned *);
void _CDECL _dos_setvect(unsigned, void (_CDECL interrupt far *)());
unsigned _CDECL _dos_write(int, void far *, unsigned, unsigned *);
void _CDECL _harderr(void (far *)());
#endif /* NO_EXT_KEYS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\limits.h ===
/***
*limits.h - implementation dependent values
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   contains defines for a number of implementation dependent values
*   which are commonly used in C programs.
*   [ANSI]
*
*******************************************************************************/

#ifndef _CHAR_UNSIGNED
#define CHAR_MAX         127            /* maximum char value */
#define CHAR_MIN        -127            /* mimimum char value */
#else
#define CHAR_MAX         255
#define CHAR_MIN         0
#endif
#define SCHAR_MAX        127            /* maximum signed char value */
#define SCHAR_MIN       -127            /* minimum signed char value */
#define UCHAR_MAX        255            /* maximum unsigned char value */
#define CHAR_BIT         8              /* number of bits in a char */
#define USHRT_MAX        0xffff         /* maximum unsigned short value */
#define SHRT_MAX         32767          /* maximum (signed) short value */
#define SHRT_MIN        -32767          /* minimum (signed) short value */
#define UINT_MAX         0xffff         /* maximum unsigned int value */
#define ULONG_MAX        0xffffffff     /* maximum unsigned long value */
#define INT_MAX          32767          /* maximum (signed) int value */
#define INT_MIN         -32767          /* minimum (signed) int value */
#define LONG_MAX         2147483647     /* maximum (signed) long value */
#define LONG_MIN        -2147483647     /* minimum (signed) long value */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the
*   buffer (memory) manipulation routines.
*   [System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* function prototypes */

void * _CDECL memccpy(void *, void *, int, unsigned int);
void * _CDECL memchr(const void *, int, size_t);
int _CDECL memcmp(const void *, const void *, size_t);
void * _CDECL memcpy(void *, const void *, size_t);
int _CDECL memicmp(void *, void *, unsigned int);
void * _CDECL memset(void *, int, size_t);
void _CDECL movedata(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for memory allocation functions;
*   also defines manifest constants and types used by the heap routines.
*   [System V]
*
*******************************************************************************/


#define _HEAPEMPTY      -1
#define _HEAPOK         -2
#define _HEAPBADBEGIN   -3
#define _HEAPBADNODE    -4
#define _HEAPEND        -5
#define _HEAPBADPTR     -6
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#if (!defined(NO_EXT_KEYS))

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
    int far * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

#else   /* NO_EXT_KEYS */
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))

#ifndef _HEAPINFO_DEFINED

typedef struct _heapinfo {
    int * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;

#define _HEAPINFO_DEFINED
#endif

#endif  /* M_I86CM || M_I86LM || M_I86HM */

#endif  /* NO_EXT_KEYS */


#if (defined(M_I86SM) || defined(M_I86MM))
#define _heapchk  _nheapchk
#define _heapset  _nheapset
#define _heapwalk _nheapwalk
#endif
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define _heapchk  _fheapchk
#define _heapset  _fheapset
#define _heapwalk _fheapwalk
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* external variable declarations */
extern unsigned int _NEAR _CDECL _amblksiz;

/* function prototypes */

void * _CDECL alloca(size_t);
void * _CDECL calloc(size_t, size_t);
void * _CDECL _expand(void *, size_t);
int _CDECL _fheapchk(void);
int _CDECL _fheapset(unsigned int);
unsigned int _CDECL _freect(size_t);
void _CDECL free(void *);
void * _CDECL malloc(size_t);
size_t _CDECL _memavl(void);
size_t _CDECL _memmax(void);
size_t _CDECL _msize(void *);
int _CDECL _nheapchk(void);
int _CDECL _nheapset(unsigned int);
void * _CDECL realloc(void *, size_t);
void * _CDECL sbrk(int);
size_t _CDECL stackavail(void);


#ifndef NO_EXT_KEYS /* extensions enabled */

void cdecl _ffree(void far *);
void far * cdecl _fmalloc(size_t);
size_t cdecl _fmsize(void far *);
#ifndef _QC
void huge * cdecl halloc(long, size_t);
void cdecl hfree(void huge *);
#endif
void cdecl _nfree(void near *);
void near * cdecl _nmalloc(size_t);
size_t cdecl _nmsize(void near *);
int cdecl _nheapwalk(struct _heapinfo *);
int cdecl _fheapwalk(struct _heapinfo *);

#else
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))

int _nheapwalk(struct _heapinfo *);
int _fheapwalk(struct _heapinfo *);

#endif  /* M_I86CM || M_I86LM || M_I86HM */

#endif /* NO_EXT_KEYS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\math.h ===
/***
*math.h - definitions and declarations for math library
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains constant definitions and external subroutine
*   declarations for the math subroutine library.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL   cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* definition of exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct exception {
    int type;           /* exception type - see below */
    char *name;   /* name of function where error occured */
    double arg1;        /* first argument to function */
    double arg2;        /* second argument (if any) to function */
    double retval;      /* value to be returned by function */
    } ;
#define _EXCEPTION_DEFINED
#endif


/* definition of a complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct complex {
    double x,y;     /* real and imaginary parts */
    } ;
#define _COMPLEX_DEFINED
#endif


/* Constant definitions for the exception type passed in the exception struct
 */

#define DOMAIN      1   /* argument domain error */
#define SING        2   /* argument singularity */
#define OVERFLOW    3   /* overflow range error */
#define UNDERFLOW   4   /* underflow range error */
#define TLOSS       5   /* total loss of precision */
#define PLOSS       6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* definitions of HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */

extern double HUGE;
#define HUGE_VAL HUGE



/* function prototypes */

int    _CDECL abs(int);
double _CDECL acos(double);
double _CDECL asin(double);
double _CDECL atan(double);
double _CDECL atan2(double, double);
double _CDECL atof(const char *);
double _CDECL cabs(struct complex);
double _CDECL ceil(double);
double _CDECL cos(double);
double _CDECL cosh(double);
int    _CDECL dieeetomsbin(double *, double *);
int    _CDECL dmsbintoieee(double *, double *);
double _CDECL exp(double);
double _CDECL fabs(double);
int    _CDECL fieeetomsbin(float *, float *);
double _CDECL floor(double);
double _CDECL fmod(double, double);
int    _CDECL fmsbintoieee(float *, float *);
double _CDECL frexp(double, int *);
double _CDECL hypot(double, double);
double _CDECL j0(double);
double _CDECL j1(double);
double _CDECL jn(int, double);
long   _CDECL labs(long);
double _CDECL ldexp(double, int);
double _CDECL log(double);
double _CDECL log10(double);
int    _CDECL matherr(struct exception *);
double _CDECL modf(double, double *);
double _CDECL pow(double, double);
double _CDECL sin(double);
double _CDECL sinh(double);
double _CDECL sqrt(double);
double _CDECL tan(double);
double _CDECL tanh(double);
double _CDECL y0(double);
double _CDECL y1(double);
double _CDECL yn(int, double);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the low-level
*   file handling and I/O functions.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

/* function prototypes */

int _CDECL access(char *, int);
int _CDECL chmod(char *, int);
int _CDECL chsize(int, long);
int _CDECL close(int);
int _CDECL creat(char *, int);
int _CDECL dup(int);
int _CDECL dup2(int, int);
int _CDECL eof(int);
long _CDECL filelength(int);
int _CDECL isatty(int);
int _CDECL locking(int, int, long);
long _CDECL lseek(int, long, int);
char * _CDECL mktemp(char *);
int _CDECL open(char *, int, ...);
int _CDECL read(int, char *, unsigned int);
int _CDECL remove(const char *);
int _CDECL rename(const char *, const char *);
int _CDECL setmode(int, int);
int _CDECL sopen(char *, int, int, ...);
long _CDECL tell(int);
int _CDECL umask(int);
int _CDECL unlink(const char *);
int _CDECL write(int, char *, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the machine-dependent buffer used by
*   setjmp/longjmp to save and restore the program state, and
*   declarations for those routines.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* define the buffer type for holding the state information */

#define _JBLEN  9  /* bp, di, si, sp, ret addr, ds */

#ifndef _JMP_BUF_DEFINED
typedef  int  jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* function prototypes */

int _CDECL setjmp(jmp_buf);
void _CDECL longjmp(jmp_buf, int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\mixed.inc ===
; High-Level-Language Interface Macros - Version 2.0
;   for Microsoft Macro Assembler 5.10
; (C) Copyright Microsoft Corporation, 1987.

;   Syntax                   Purpose
;   ------                   -------
;
;   setModel                 Sets model from text equate
;
;   hProc  <name [NEAR|FAR]> [,<USES reglist>] [,arg[:type] [,arg[:type]]]...
;                            Starts a procedure with optional stack arguments
;
;   hLocal var[:type] [,var[:type]]...
;                            Defines local stack variables
;
;   hRet                     Returns from the current procedure
;
;   hEndp                    Ends the current procedure
;
;   ifFP  statement          Assembles statement if far data
;
;   FPoperand                Conditionally provides ES override for data
;
;   pLes  register,address   Conditionally loads data through ES
;
;   pLds  register,address   Conditionally loads data through DS

;if1

; Translate command-line arguments


; Initialize procName

    procName equ <foo>

; Set model passed from command line

setModel macro mod

    ifdef cLang
      .model mod, C
      lang  EQU   <C>
    elseifdef BASIC
      .model mod, Basic
    elseifdef FORTRAN
      .model mod, FORTRAN
    elseifdef Pascal
      .model mod, Pascal
    endif

; FP - supply far pointer ES overide as needed - must be inside for setModel

    if @DataSize
      FP equ <es:>
    else
      FP equ <>
    endif

endm

; FP - supply far pointer ES overide as needed - must be outside for .MODEL

ifdef @DataSize
    if @DataSize
      FP equ <es:>
    else
      FP equ <>
    endif
endif

; Declare high level routine and parameters

hProc macro funName, a,b,c,d,e,f,g,h,i,j
;    LOCAL argstr

    ii instr <funName>,< >
    if ii
      procName subStr <funName>,1,ii
      nearFar subStr <funName>,ii
    else
      procName equ <funName>
      nearFar equ <>
    endif

    argstr equ <a>
    irp arg,<b,c,d,e,f,g,h,i,j>
      ifnb <arg>
	argstr catstr argstr,<, arg>
      else
        exitm
      endif
    endm
defineProc %nearFar, %argstr
endm

defineProc Macro size,args
procName proc size args
endm

; Declare local stack variables

hLocal macro a,b,c,d,e,f,g,h,i,j
;    LOCAL argstr
    argstr EQU <a>
    irp arg,<b,c,d,e,f,g,h,i,j>
      ifnb <arg>
	argstr catstr argstr,<, arg>
      else
        exitm
      endif
    endm
defineLocal %argstr
endm

defineLocal macro args
    &local args
endm

; Generate high level return

hRet macro
    ret
endm

; End a high level procedure

hEndp macro
    procName endp
endm

; Execute instruction if far data

ifFP macro a,b,c,d,e,f,g,h,i,j

    if @DataSize
       a b c d e f g h i j
    endif
endm

; Load 16/32 bit pointers into [ES:] reg

pLes macro reg, address

    if @DataSize

        les reg,address
    else
        mov reg,address

    endif
endm

;Load 16/32 bit pointers into [DS:] reg

pLds macro reg, address

    if @DataSize

        lds reg,address
    else
        mov reg,address

    endif
endm

;endif ; Pass 1 only
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the declarations for the sorting and
*   searching routines.
*   [System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* function prototypes */

char * _CDECL lsearch(char *, char *, unsigned int *, unsigned int, int (_CDECL *)(void *, void *));
char * _CDECL lfind(char *, char *, unsigned int *, unsigned int, int (_CDECL *)(void *, void *));
void * _CDECL bsearch(const void *, const void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
void _CDECL qsort(void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the file sharing modes for sopen().
*
*******************************************************************************/

#define SH_COMPAT   0x00    /* compatibility mode */
#define SH_DENYRW   0x10    /* deny read/write mode */
#define SH_DENYWR   0x20    /* deny write mode */
#define SH_DENYRD   0x30    /* deny read mode */
#define SH_DENYNO   0x40    /* deny none mode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the modeflag values for spawnxx calls.  Only
*   P_WAIT and P_OVERLAY are currently implemented on DOS 2 & 3.
*   P_NOWAIT is also enabled on DOS 4.  Also contains the function
*   argument declarations for all process control related routines.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* modeflag values for spawnxx routines */

extern int _NEAR _CDECL _p_overlay;

#define P_WAIT      0
#define P_NOWAIT    1
#define P_OVERLAY   _p_overlay
#define OLD_P_OVERLAY  2
#define P_NOWAITO   3


/* Action Codes used with Cwait() */

#define WAIT_CHILD 0
#define WAIT_GRANDCHILD 1


/* function prototypes */

void _CDECL abort(void);
int _CDECL cwait(int *, int, int);
int _CDECL execl(char *, char *, ...);
int _CDECL execle(char *, char *, ...);
int _CDECL execlp(char *, char *, ...);
int _CDECL execlpe(char *, char *, ...);
int _CDECL execv(char *, char * *);
int _CDECL execve(char *, char * *, char * *);
int _CDECL execvp(char *, char * *);
int _CDECL execvpe(char *, char * *, char * *);
void _CDECL exit(int);
void _CDECL _exit(int);
int _CDECL getpid(void);
int _CDECL spawnl(int, char *, char *, ...);
int _CDECL spawnle(int, char *, char *, ...);
int _CDECL spawnlp(int, char *, char *, ...);
int _CDECL spawnlpe(int, char *, char *, ...);
int _CDECL spawnv(int, char *, char * *);
int _CDECL spawnve(int, char *, char * *, char * *);
int _CDECL spawnvp(int, char *, char * *);
int _CDECL spawnvpe(int, char *, char * *, char * *);
int _CDECL system(const char *);
int _CDECL wait(int *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines ANSI-style macros for accessing arguments
*   of functions which take a variable number of arguments.
*   [ANSI]
*
*******************************************************************************/

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_start(ap,v) ap = (va_list)&v + sizeof(v)
#define va_arg(ap,t) ((t *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\signal.h ===
/***
*signal.h - defines signal values and routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the signal values and declares the signal functions.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif


#define NSIG 23     /* maximum signal number + 1 */

/* signal types */
/* SIGINT, SIGFPE, SIGILL, SIGSEGV, and SIGABRT are recognized on DOS 3.x */

#define SIGINT      2   /* interrupt - corresponds to DOS 3.x int 23H */
#define SIGILL      4   /* illegal instruction - invalid function image */
#define SIGFPE      8   /* floating point exception */
#define SIGSEGV     11  /* segment violation */
#define SIGTERM     15  /* Software termination signal from kill */
#define SIGUSR1     16  /* User defined signal 1 */
#define SIGUSR2     17  /* User defined signal 2 */
#define SIGUSR3     20  /* User defined signal 3 */
#define SIGBREAK    21  /* Ctrl-Break sequence */
#define SIGABRT     22  /* abnormal termination triggered by abort call */


/* signal action codes */
/* SIG_DFL and SIG_IGN are recognized on DOS 3.x */

#define SIG_DFL (void (*)())0 /* default signal action */
#define SIG_IGN (void (*)())1 /* ignore */
#define SIG_SGE (void (*)())3 /* signal gets error */
#define SIG_ACK (void (*)())4 /* error if handler not setup */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (*)())-1    /* signal error value */


/* function prototypes */

void (_CDECL * _CDECL signal(int, void (_CDECL *)()))();
int _CDECL raise(int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains definitions and declarations for some commonly
*   used constants, types, and variables.
*   [ANSI]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* define NULL pointer value */

#if (defined(M_I86SM) || defined(M_I86MM))
#define  NULL    0
#elif (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define  NULL    0L
#endif


/* declare reference to errno */

extern int _NEAR _CDECL errno;


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the level 2 I/O ("standard I/O") routines.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* buffered I/O macros */

#define  BUFSIZ  512
#define  _NFILE  20
#define  EOF     (-1)

#ifndef _FILE_DEFINED
#define  FILE    struct _iobuf
#define _FILE_DEFINED
#endif

/* P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of P_tmpdir
 *      + 1 (in case P_tmpdir does not end in "\\")
 *      + 6 (for the temp number string)
 *      + 1 (for the null terminator)
 */

#define  P_tmpdir "\\"
#define  L_tmpnam sizeof(P_tmpdir)+8

#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define  SYS_OPEN 20
#define  TMP_MAX  32767


/* define NULL pointer value */

#if (defined(M_I86SM) || defined(M_I86MM))
#define  NULL    0
#elif (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define  NULL    0L
#endif


/* define file control block */

#ifndef _IOB_DEFINED
extern FILE {
    char *_ptr;
    int   _cnt;
    char *_base;
    char  _flag;
    char  _file;
    } _NEAR _CDECL _iob[];
#define _IOB_DEFINED
#endif

#define  fpos_t  long   /* file position variable */

#define  stdin  (&_iob[0])
#define  stdout (&_iob[1])
#define  stderr (&_iob[2])
#define  stdaux (&_iob[3])
#define  stdprn (&_iob[4])

#define  _IOREAD    0x01
#define  _IOWRT     0x02

#define  _IOFBF     0x0
#define  _IOLBF     0x40
#define  _IONBF     0x04

#define  _IOMYBUF   0x08
#define  _IOEOF     0x10
#define  _IOERR     0x20
#define  _IOSTRG    0x40
#define  _IORW      0x80

#define getc(f)         (--(f)->_cnt >= 0 ? 0xff & *(f)->_ptr++ : _filbuf(f))
#define putc(c,f)       (--(f)->_cnt >= 0 ? 0xff & (*(f)->_ptr++ = (char)(c)) \
                        :  _flsbuf((c),(f)))
#define getchar()       getc(stdin)
#define putchar(c)      putc((c),stdout)

#define feof(f)         ((f)->_flag & _IOEOF)
#define ferror(f)       ((f)->_flag & _IOERR)
#define fileno(f)       ((f)->_file)


/* function prototypes */

int _CDECL _filbuf(FILE *);
int _CDECL _flsbuf(int, FILE *);
void _CDECL clearerr(FILE *);
int _CDECL fclose(FILE *);
int _CDECL fcloseall(void);
FILE * _CDECL fdopen(int, char *);
int _CDECL fflush(FILE *);
int _CDECL fgetc(FILE *);
int _CDECL fgetchar(void);
int _CDECL fgetpos(FILE *, fpos_t *);
char * _CDECL fgets(char *, int, FILE *);
int _CDECL flushall(void);
FILE * _CDECL fopen(const char *, const char *);
int _CDECL fprintf(FILE *, const char *, ...);
int _CDECL fputc(int, FILE *);
int _CDECL fputchar(int);
int _CDECL fputs(const char *, FILE *);
size_t _CDECL fread(void *, size_t, size_t, FILE *);
FILE * _CDECL freopen(const char *, const char *, FILE *);
int _CDECL fscanf(FILE *, const char *, ...);
int _CDECL fsetpos(FILE *, const fpos_t *);
int _CDECL fseek(FILE *, long, int);
long _CDECL ftell(FILE *);
size_t _CDECL fwrite(const void *, size_t, size_t, FILE *);
char * _CDECL gets(char *);
int _CDECL getw(FILE *);
void _CDECL perror(const char *);
int _CDECL printf(const char *, ...);
int _CDECL puts(const char *);
int _CDECL putw(int, FILE *);
int _CDECL remove(const char *);
int _CDECL rename(const char *, const char *);
void _CDECL rewind(FILE *);
int _CDECL rmtmp(void);
int _CDECL scanf(const char *, ...);
void _CDECL setbuf(FILE *, char *);
int _CDECL setvbuf(FILE *, char *, int, size_t);
int _CDECL sprintf(char *, const char *, ...);
int _CDECL sscanf(const char *, const char *, ...);
char * _CDECL tempnam(char *, char *);
FILE * _CDECL tmpfile(void);
char * _CDECL tmpnam(char *);
int _CDECL ungetc(int, FILE *);
int _CDECL unlink(const char *);
int _CDECL vfprintf(FILE *, const char *, va_list);
int _CDECL vprintf(const char *, va_list);
int _CDECL vsprintf(char *, const char *, va_list);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines XENIX style macros for accessing arguments of a
*   function which takes a variable number of arguments.
*   [System V]
*
*******************************************************************************/

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ((t *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\version.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */

/* --------------------------------------------------------------------------
   *	Use the switch below to produce the standard Microsoft version	    *
   *	or the IBM version of the operating system   			    *
   *									    *
   *									    *
   *	Use the switches below to produce the standard Microsoft version    *
   *	or the IBMversion of the operating system			    *
   *									    *
   *	The below chart will indicate how to set the switches to build	    *
   *	the various versions						     *
   *									    *
   *			      IBMVER	      IBMCOPYRIGHT		    *
   *	  --------------------------------------------------------	    *
   *	   IBM Version	 |     TRUE		 TRUE			    *
   *	  --------------------------------------------------------	    *
   *	   MS Version	 |     FALSE		 FALSE			    *
   *	  --------------------------------------------------------	    *
   *	   Clone Version |     TRUE		 FALSE			    *
   -------------------------------------------------------------------------- */

#define IBMVER	     1
#define IBMCOPYRIGHT 0

#ifndef MSVER
#define MSVER	     1-IBMVER	     /* MSVER = NOT IBMVER	    */
#endif
#define IBM	     IBMVER

/*
*****************************************************************************

		<<< Followings are the DBCS relating Definition >>>


	To build DBCS version, Define DBCS by using CL option via
	Dos environment.

	ex.		set CL=-DDBCS



	To build Country/Region depend version, Define JAPAN, KOREA or TAIWAN
	by using CL option via Dos environment.

	ex.		set CL=-DJAPAN
			set CL=-DKOREA
			set CL=-DTAIWAN

*****************************************************************************
*/

#define BUGFIX	   1


/* #define IBMJAPVER	0   */		/* If TRUE define DBCS also */
#define IBMJAPAN   0



/* -------------------- Set DBCS Blank constant ------------------- */

#ifndef DBCS
#define DB_SPACE 0x2020
#define DB_SP_HI 0x20
#define DB_SP_LO 0x20
#else
	#ifdef JAPAN
	#define DB_SPACE 0x8140
	#define DB_SP_HI 0x81
	#define DB_SP_LO 0x40
	#endif

	#ifdef TAIWAN
	#define DB_SPACE 0x8130
	#define DB_SP_HI 0x81
	#define DB_SP_LO 0x30
	#endif

	#ifdef KOREA
	#define DB_SPACE 0xA1A1
	#define DB_SP_HI 0xA1
	#define DB_SP_LO 0xA1
	#endif
#endif

#ifndef altvect 		    /* avoid jerking off vector.inc	*/
#define ALTVECT    0		    /* Switch to build ALTVECT version	*/
#endif


#if BUGFIX
#pragma message( "BUGFIX switch ON" )
#endif

#ifdef DBCS
#pragma message( "DBCS version build switch ON" )

	#ifdef JAPAN
	#pragma message( "JAPAN version build switch ON" )
	#endif

	#ifdef TAIWAN
	#pragma message( "TAIWAN version build switch ON" )
	#endif

	#ifdef KOREA
	#pragma message( "KOREA version build switch ON" )
	#endif
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the string
*   manipulation functions.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* function prototypes */

void * _CDECL memccpy(void *, void *, int, unsigned int);
void * _CDECL memchr(const void *, int, size_t);
int _CDECL memcmp(const void *, const void *, size_t);
int _CDECL memicmp(void *, void *, unsigned int);
void * _CDECL memcpy(void *, const void *, size_t);
void * _CDECL memmove(void *, const void *, size_t);
void * _CDECL memset(void *, int, size_t);
void _CDECL movedata(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

char * _CDECL strcat(char *, const char *);
char * _CDECL strchr(const char *, int);
int _CDECL strcmp(const char *, const char *);
int _CDECL strcmpi(const char *, const char *);
int _CDECL stricmp(const char *, const char *);
char * _CDECL strcpy(char *, const char *);
size_t _CDECL strcspn(const char *, const char *);
char * _CDECL strdup(const char *);
char * _CDECL _strerror(char *);
char * _CDECL strerror(int);
size_t _CDECL strlen(const char *);
char * _CDECL strlwr(char *);
char * _CDECL strncat(char *, const char *, size_t);
int _CDECL strncmp(const char *, const char *, size_t);
int _CDECL strnicmp(const char *, const char *, size_t);
char * _CDECL strncpy(char *, const char *, size_t);
char * _CDECL strnset(char *, int, size_t);
char * _CDECL strpbrk(const char *, const char *);
char * _CDECL strrchr(const char *, int);
char * _CDECL strrev(char *);
char * _CDECL strset(char *, int);
size_t _CDECL strspn(const char *, const char *);
char * _CDECL strstr(const char *, const char *);
char * _CDECL strtok(char *, const char *);
char * _CDECL strupr(char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\versionc.h ===
/*
 *                      Microsoft Confidential
 *                      Copyright (C) Microsoft Corporation 1991
 *                      All Rights Reserved.
 */


#define  EXPECTED_VERSION_MAJOR     5	    /* DOS Major Version 4 */
#define  EXPECTED_VERSION_MINOR     00	    /* DOS Minor Version 00 */

       /********************************************/
       /*Each C program should: 		   */
       /*					   */
       /* if ((EXPECTED_VERSION_MAJOR != _osmajor) */
       /*   | (EXPECTED_VERSION_MINOR != _osminor))*/
       /*  exit(incorrect_dos_version); 	   */
       /*					   */
       /********************************************/


/* DOS location bits, for use with GetVersion call */

#define DOSHMA			    0x10	/* DOS running in HMA */
#define DOSROM			    0x08	/* DOS running in ROM */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\arena.inc ===
BREAK <Memory arena structure>

;
;	Revision History:
;
;	M001 - added equates for UMB allocation
;	M002 - added equate for LINK/UNLINK state of UMBs
;	M026 - STRAT_MASK should be HF_MASK AND HO_MASK

;**	Arena Header
;

arena	STRUC
arena_signature     DB	?		; 4D for valid item, 5A for last item
arena_owner	    DW	?		; owner of arena item
arena_size	    DW	?		; size in paragraphs of item
arena_reserved	    DB	3 DUP(?)	; reserved
arena_name	    DB	8 DUP(?)	; owner file name
arena	ENDS

;
; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
; and arena_owner_system are all equal to zero and are contained in DI.  Change
; them and change ALLOC.ASM.
;
; I think I have all of these covered via .errnz - JGL


arena_owner_system	EQU 0		; free block indication

arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
arena_signature_end	EQU 5Ah 	; valid signature, last block in arena


FIRST_FIT	EQU	00000000B
BEST_FIT	EQU	00000001B
LAST_FIT	EQU	00000010B

LOW_FIRST	EQU	00000000B	; M001
HIGH_FIRST	EQU	10000000B	; M001
HIGH_ONLY	EQU	01000000B	; M001

LINKSTATE	EQU	00000001B	; M002

HF_MASK		EQU	NOT HIGH_FIRST	; M001
HO_MASK		EQU	NOT HIGH_ONLY	; M001

STRAT_MASK	EQU	HF_MASK AND HO_MASK	; M001;
						; M026: used to mask of bits
						; M026: 6 & 7 of AllocMethod



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   commonly used library functions which either don't fit somewhere
*   else, or, like toupper/tolower, can't be declared in the normal
*   place (ctype.h in the case of toupper/tolower) for other reasons.
*   [ANSI]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* definition of the return type for the onexit() function */

#ifndef _ONEXIT_T_DEFINED
typedef int (_CDECL * _CDECL onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long quot;
    long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH      144      /* max. length of full pathname */
#define _MAX_DRIVE   3      /* max. length of drive component */
#define _MAX_DIR       130      /* max. length of path component */
#define _MAX_FNAME   9      /* max. length of file name component */
#define _MAX_EXT     5      /* max. length of extension component */

/* external variable declarations */

extern int _NEAR _CDECL errno;              /* XENIX style error number */
extern int _NEAR _CDECL _doserrno;          /* MS-DOS system error value */
extern char * _NEAR _CDECL sys_errlist[];   /* perror error message table */
extern int _NEAR _CDECL sys_nerr;           /* # of entries in sys_errlist table */

extern char ** _NEAR _CDECL environ;        /* pointer to environment table */

extern unsigned int _NEAR _CDECL _psp;      /* Program Segment Prefix */

extern int _NEAR _CDECL _fmode;             /* default file translation mode */

/* DOS major/minor version numbers */

extern unsigned char _NEAR _CDECL _osmajor;
extern unsigned char _NEAR _CDECL _osminor;

#define DOS_MODE    0   /* Real Address Mode */
#define OS2_MODE    1   /* Protected Address Mode */

extern unsigned char _NEAR _CDECL _osmode;


/* function prototypes */

double _CDECL atof(const char *);
double _CDECL strtod(const char *, char * *);
ldiv_t _CDECL ldiv(long, long);

void   _CDECL abort(void);
int    _CDECL abs(int);
int    _CDECL atexit(void (_CDECL *)(void));
int    _CDECL atoi(const char *);
long   _CDECL atol(const char *);
void * _CDECL bsearch(const void *, const void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
void * _CDECL calloc(size_t, size_t);
div_t  _CDECL div(int, int);
char * _CDECL ecvt(double, int, int *, int *);
void   _CDECL exit(int);
void   _CDECL _exit(int);
char * _CDECL fcvt(double, int, int *, int *);
void   _CDECL free(void *);
char * _CDECL gcvt(double, int, char *);
char * _CDECL getenv(const char *);
char * _CDECL itoa(int, char *, int);
long   _CDECL labs(long);
unsigned long _CDECL _lrotl(unsigned long, int);
unsigned long _CDECL _lrotr(unsigned long, int);
char * _CDECL ltoa(long, char *, int);
void   _CDECL _makepath(char *, char *, char *, char *, char *);
void * _CDECL malloc(size_t);
onexit_t _CDECL onexit(onexit_t);
void   _CDECL perror(const char *);
int    _CDECL putenv(char *);
void   _CDECL qsort(void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
unsigned int _CDECL _rotl(unsigned int, int);
unsigned int _CDECL _rotr(unsigned int, int);
int    _CDECL rand(void);
void * _CDECL realloc(void *, size_t);
void   _CDECL _searchenv(char *, char *, char *);
void   _CDECL _splitpath(char *, char *, char *, char *, char *);
void   _CDECL srand(unsigned int);
long   _CDECL strtol(const char *, char * *, int);
unsigned long _CDECL strtoul(const char *, char * *, int);
void   _CDECL swab(char *, char *, int);
int    _CDECL system(const char *);
char * _CDECL ultoa(unsigned long, char *, int);

#ifndef tolower         /* tolower has been undefined - use function */
int _CDECL tolower(int);
#endif  /* tolower */

#ifndef toupper         /* toupper has been undefined - use function */
int    _CDECL toupper(int);
#endif  /* toupper */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\h\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file has declarations of time routines and defines
*   the structure returned by the localtime and gmtime routines and
*   used by asctime.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* define the implementation defined time type */

#ifndef _TIME_T_DEFINED
typedef long time_t;            /* time value */
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
    int tm_sec;         /* seconds after the minute - [0,59] */
    int tm_min;         /* minutes after the hour - [0,59] */
    int tm_hour;        /* hours since midnight - [0,23] */
    int tm_mday;        /* day of the month - [1,31] */
    int tm_mon;         /* months since January - [0,11] */
    int tm_year;        /* years since 1900 */
    int tm_wday;        /* days since Sunday - [0,6] */
    int tm_yday;        /* days since January 1 - [0,365] */
    int tm_isdst;       /* daylight savings time flag */
    };
#define _TM_DEFINED
#endif

#define CLK_TCK 1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

extern int _NEAR _CDECL daylight;     /* non-zero if daylight savings time is used */
extern long _NEAR _CDECL timezone;    /* difference in seconds between GMT and local time */
extern char * _NEAR _CDECL tzname[2]; /* standard/daylight savings time zone names */


/* function prototypes */

char * _CDECL asctime(const struct tm *);
char * _CDECL ctime(const time_t *);
clock_t _CDECL clock(void);
double _CDECL difftime(time_t, time_t);
struct tm * _CDECL gmtime(const time_t *);
struct tm * _CDECL localtime(const time_t *);
time_t _CDECL mktime(struct tm *);
char * _CDECL _strdate(char *);
char * _CDECL _strtime(char *);
time_t _CDECL time(time_t *);
void _CDECL tzset(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\bdsize.inc ===
ifndef NEC_98
BIODATASIZ EQU 00300H
BIOCODESIZ EQU 00450H
DOSDATASIZ EQU 01436H
else    ;NEC_98
BIODATASIZ EQU 04400H
BIOCODESIZ EQU 06400H
DOSDATASIZ EQU 01454H
endif   ;NEC_98

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\bugtyp.inc ===
;**	BUGTYP.INC - Debugging types and levels for MSDOS
;


TypAccess   EQU     0001h
    LevSFN	EQU	0000h
    LevBUSY	EQU	0001h

TypShare    EQU     0002h
    LevShEntry	EQU	0000h
    LevMFTSrch	EQU	0001h

TypSect     EQU     0004h
    LevEnter	EQU	0000h
    LevLeave	EQU	0001h
    LevReq	EQU	0002h

TypSMB	    EQU     0008h
    LevSMBin	EQU	0000h
    LevSMBout	EQU	0001h
    LevParm	EQU	0002h
    LevASCIZ	EQU	0003h
    LevSDB	EQU	0004h
    LevVarlen	EQU	0005h

TypNCB	    EQU     0010h
    LevNCBin	EQU	0000h
    LevNCBout	EQU	0001h

TypSeg	    EQU     0020h
    LevAll	EQU	0000h

TypSyscall  EQU     0040h
    LevLog	EQU	0000h
    LevArgs	EQU	0001h
    LevErr	EQU	0002h

TypInt24    EQU     0080h
    LevLog	EQU	0000h

TypProlog   EQU     0100h
    LevLog	EQU	0000h

TypInt	    EQU     0200h
    LevLog	equ	0000h

typFCB	    equ     0400h
    LevLog	equ	0000h
    LevCheck	equ	0001h


ifndef BugLev

    DOSCODE	SEGMENT
	EXTRN	BugLev:word
	EXTRN	BugTyp:word
    DOSCODE	ENDS

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\buffer.inc ===
BREAK <Disk I/O Buffer Header>


;**	BUFFER.INC
;
;	Field definition for I/O buffer information

BUFFINFO	STRUC
buf_next	DW	?		; Pointer to next buffer in list
buf_prev	DW	?		; Pointer to prev buffer in list
buf_ID		DB	?		; Drive of buffer (bit 7 = 0)
					; SFT table index (bit 7 = 1)
					; = FFH if buffer free
buf_flags	DB	?		; Bit 7 = 1 if Remote file buffer
					;	= 0 if Local device buffer
					; Bit 6 = 1 if buffer dirty
					; Bit 5 = Reserved
					; Bit 4 = Search bit (bit 7 = 1)
					; Bit 3 = 1 if buffer is DATA
					; Bit 2 = 1 if buffer is DIR
					; Bit 1 = 1 if buffer is FAT
					; Bit 0 = Reserved
buf_sector	DD	?		; Sector number of buffer (bit 7 = 0)
; The next two items are often refed as a word (bit 7 = 0)
buf_wrtcnt	DB	?		; For FAT sectors, # times sector written out
buf_wrtcntinc	DW	?		; "   "     "   , # sectors between each write
buf_DPB 	DD	?		; Pointer to drive parameters
buf_fill	DW	?		; How full buffer is (bit 7 = 1)
buf_reserved	DB	?		; make DWORD boundary for 386
BUFFINFO	ENDS

buf_offset	EQU	DWORD PTR buf_sector
					;For bit 7 = 1, this is the byte
					;offset of the start of the buffer in
					;the file pointed to by buf_ID.  Thus
					;the buffer starts at location
					;buf_offset in the file and contains
					;buf_fill bytes.

BUFINSIZ	EQU	SIZE BUFFINFO
					; Size of structure in bytes

buf_Free	EQU	0FFh		; buf_id of free buffer

;Flag byte masks
buf_isnet	EQU	10000000B
buf_dirty	EQU	01000000B
;***
buf_visit	EQU	00100000B
;***
buf_snbuf	EQU	00010000B

buf_isDATA	EQU	00001000B
buf_isDIR	EQU	00000100B
buf_isFAT	EQU	00000010B
buf_type_0	EQU	11110001B	; AND sets type to "none"

buf_NetID	EQU	BUFINSIZ

;
; Buffer Hash Entry Structure
;
;BUFFER_HASH_ENTRY	STRUC		; DOS 4.00
;EMS_PAGE_NUM	DW	-1		; logical page number for EMS handle
;BUFFER_BUCKET	DD	 ?		; pointer to buffers
;DIRTY_COUNT	DB	 0		; number of dirty buffers
;BUFFER_RESERVED DB	 0		; reserved
;BUFFER_HASH_ENTRY	ENDS
;
;MaxBuffinBucket EQU	15		; Max number of buffers per bucket
;MaxBucketinPage EQU	 2		; Max number of buckets per 16kb page
;
;
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\bpb.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;

;**	BIOS PARAMETER BLOCK DEFINITION
;
;	The BPB contains information about the disk structure.  It dates
;	back to the earliest FAT systems and so FAT information is
;	intermingled with physical driver information.
;
;	A boot sector contains a BPB for its device; for other disks
;	the driver creates a BPB.  DOS keeps copies of some of this
;	information in the DPB.
;
;	The BDS structure contains a BPB within it.
;



A_BPB			STRUC
BPB_BYTESPERSECTOR	DW	?
BPB_SECTORSPERCLUSTER	DB	?
BPB_RESERVEDSECTORS	DW	?
BPB_NUMBEROFFATS	DB	?
BPB_ROOTENTRIES 	DW	?
BPB_TOTALSECTORS	DW	?
BPB_MEDIADESCRIPTOR	DB	?
BPB_SECTORSPERFAT	DW	?
BPB_SECTORSPERTRACK	DW	?
BPB_HEADS		DW	?
BPB_HIDDENSECTORS	DW	?
			DW	?
BPB_BIGTOTALSECTORS	DW	?
			DW	?
			DB	6 DUP(?)	; NOTE:  many times these
;						; 	 6 bytes are omitted
;						;	 when BPB manipulations
;						;	 are performed!
A_BPB			ENDS
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\copyrigh.inc ===
;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
;M031 - changed copyright to 1991

	DB	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
	DB	"Licensed Material - Property of Microsoft "
        DB      "All rights reserved "

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\const2.asm ===
;	SCCSID = @(#)const2.asm 1.4 85/07/24


Break <Initialized data and data used at DOS initialization>

;
; We need to identify the parts of the data area that are relevant to tasks
; and those that are relevant to the system as a whole.  Under 3.0, the system
; data will be gathered with the system code.  The process data under 2.x will
; be available for swapping and under 3.0 it will be allocated per-process.
;
; The data that is system data will be identified by [SYSTEM] in the comments
; describing that data item.
;

include dossvc.inc

; On NT SFT Size is smaller than DOS so we have to pad some space to maintain
; the offsets in data segmeents. Below FILLSPACE is pad. 59 is the size of
; DOS5.0 sft entry.

FILLSPACE   equ  (sf_default_number * (59 - (SIZE sf_entry)))

	AsmVars <Debug, Redirector, ShareF>

DOSDATA	SEGMENT WORD PUBLIC 'DATA'

;
; Table of routines for assignable devices
;
; MSDOS allows assignment if the following standard devices:
;   stdin  (usually CON input)
;   stdout (usually CON output)
;   auxin  (usually AUX input)
;   auxout (usually AUX output)
;   stdlpt (usually PRN output)
;
; SPECIAL NOTE:
;   Status of a file is a strange idea.  We choose to handle it in this
;   manner:  If we're not at end-of-file, then we always say that we have a
;   character.	Otherwise, we return ^Z as the character and set the ZERO
;   flag.  In this manner we can support program written under the old DOS
;   (they use ^Z as EOF on devices) and programs written under the new DOS
;   (they use the ZERO flag as EOF).

; Default SFTs for boot up

Public CONST001S,CONST001E
CONST001s	label byte
	PUBLIC	sftabl
sftabl	LABEL	DWORD			; [SYSTEM] file table
	DW	-1			; [SYSTEM] link to next table
	DW	-1			; [SYSTEM] link seg to next table
	DW	sf_default_number	; [SYSTEM] Number of entries in table
	DB	sf_default_number DUP ( (SIZE sf_entry) DUP (0)); [SYSTEM]

	DB	FILLSPACE DUP (0)	; PAD to maintain correct offsets

; the next two variables relate to the position of the logical stdout/stdin
; cursor.  They are only meaningful when stdin/stdout are assigned to the
; console.
	I_am	CARPOS,BYTE		; [SYSTEM] cursor position in stdin
	I_am	STARTPOS,BYTE		; [SYSTEM] position of cursor at beginning of buffered input call
	I_am	INBUF,128		; [SYSTEM] general device input buffer
	I_am	CONBUF,131		; [SYSTEM] The rest of INBUF and console buffer

	I_am	PFLAG,BYTE		; [SYSTEM] printer echoing flag
	I_am	VERFLG,BYTE		; [SYSTEM] Initialize with verify off
	I_am	CharCo,BYTE,<00000011B> ; [SYSTEM] Allows statchks every 4 chars...
	I_am	chSwitch,BYTE,<'/'>	; UNUSED - obsolete datum, can be reused
	I_am	AllocMethod,BYTE	; [SYSTEM] how to alloc first(best)last
	I_am	fShare,BYTE,<0> 	; [SYSTEM] TRUE => sharing installed
	I_am	DIFFNAM,BYTE,<1>	; [SYSTEM] Indicates when MYNAME has
					;	     changed
	I_am	MYNAME,16,<32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32>
					; [SYSTEM] My network name


;
; The following table is a list of addresses that the sharer patches to be
; PUSH AX to enable the critical sections
;
PUBLIC	CritPatch
CritPatch LABEL WORD
IRP sect,<critDisk,critDevice>
IF (NOT REDIRECTOR) AND (NOT SHAREF)
;
;SR; Change code patch address to a variable in data segment
;
        dw OFFSET DOSDATA: redir_patch
        dw OFFSET DOSDATA: redir_patch

;hkn	Short_Addr  E&sect
;hkn	Short_Addr  L&sect

ELSE
	DW	0
	DW	0
ENDIF
ENDM
	DW	0

;
; WARNING!!!  PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
; Also, IBM server 1.0 requires this also.
;
	EVEN			; Force swap area to start on word boundry
PUBLIC	SWAP_START
SWAP_START	LABEL BYTE
	I_am	ErrorMode,BYTE		; Flag for INT 24 processing
	I_am	INDOS,BYTE,<0>		; DOS status for interrupt processing
	I_am	WPErr,BYTE,<-1> 	; Write protect error flag
	I_am	EXTERR_LOCUS,BYTE	; Extended Error Locus
	I_am	EXTERR,WORD,<0> 	; Extended Error code

;WARNING Following two bytes Accessed as word in $GetExtendedError
	I_am	EXTERR_ACTION,BYTE	; Extended Error Action
	I_am	EXTERR_CLASS,BYTE	; Extended Error Class
; end warning

	I_am	EXTERRPT,DWORD		; Extended Error pointer
	I_am	DMAADD,DWORD,<80h,?>	; User's disk transfer address (disp/seg)
	I_am	CurrentPDB,WORD 	; Current process identifier
	I_am	ConC_spsave,WORD	; saved SP before ^C
	I_am	exit_code,WORD		; exit code of last proc.
	I_am	CURDRV,BYTE		; Default drive (init A)
	I_am	CNTCFLAG,BYTE,<0>	; ^C check in dispatch disabled
					; F.C. 2/17/86
	I_am	CPSWFLAG,BYTE,<0>	; Code Page Switching Flag  DOS 4.00
	I_am	CPSWSAVE,BYTE,<0>	; copy of above in case of ABORT
	EVEN
 PUBLIC Swap_Always
 Swap_Always	LABEL	BYTE
	I_am	USER_IN_AX,WORD 	; User INPUT AX value (used for
					;   extended error type stuff.	NOTE:
					;   does not have Correct value on
					;   1-12, OEM, Get/Set CurrentPDB,
					;   GetExtendedError system calls
	I_am	PROC_ID,WORD,<0>	; PID for sharing (0 = local)
	I_am	USER_ID,WORD,<0>	; Machine for sharing (0 = local)
	I_am	FirstArena,WORD 	; first free block found
	I_am	BestArena,WORD		; best free block found
	I_am	LastArena,WORD		; last free block found
	I_am	EndMem,WORD		; End of memory used in DOSINIT
	I_am	LASTENT,WORD		; Last entry for directory search

	I_am	FAILERR,BYTE,<0>	; NZ if user did FAIL on I 24
	I_am	ALLOWED,BYTE,<0>	; Allowed I 24 answers (see allowed_)
	I_am	NoSetDir,BYTE		; true -> do not set directory
	I_am	DidCTRLC,BYTE		; true -> we did a ^C exit
	I_am	SpaceFlag,BYTE		; true -> embedded spaces are allowed in FCB
; Warning!  The following items are accessed as a WORD in TIME.ASM
	EVEN
	I_am	DAY,BYTE,<0>		; Day of month
	I_am	MONTH,BYTE,<0>		; Month of year
	I_am	YEAR,WORD,<0>		; Year (with century)
	I_am	DAYCNT,WORD,<-1>	; Day count from beginning of year
	I_am	WEEKDAY,BYTE,<0>	; Day of week
; end warning
	I_am	CONSWAP,BYTE		; TRUE => console was swapped during device read
	I_am	IDLEINT,BYTE,<1>	; TRUE => idle int is allowed
	I_am	fAborting,BYTE,<0>	; TRUE => abort in progress

; Combination of all device call parameters
	PUBLIC	DEVCALL 		;
DEVCALL SRHEAD	<>			; basic header for disk packet
	PUBLIC	CALLUNIT
CALLUNIT    LABEL   BYTE		; unit number for disk
CALLFLSH    LABEL   WORD		;
	I_am	CALLMED,BYTE		; media byte
CALLBR	    LABEL   DWORD		;
	PUBLIC	CALLXAD 		;
CALLXAD     LABEL   DWORD		;
	I_am	CALLRBYT,BYTE		;
	PUBLIC	CALLVIDM		;
CALLVIDM    LABEL   DWORD		;
	DB	3 DUP(?)		;
	PUBLIC CallBPB			;
CALLBPB     LABEL   DWORD		;
	I_am	CALLSCNT,WORD		;
	PUBLIC	CALLSSEC
CALLSSEC    LABEL    WORD		;
	    DW	    ?			;
	I_am	CALLVIDRW,DWORD 	;
					;
	I_am	CALLNEWSC,DWORD 	; starting sector for >32mb
	I_am	CALLDEVAD,DWORD 	; stash for device entry point
					;
; Same as above for I/O calls		;
					;
	PUBLIC	IOCall			;
IOCALL	SRHEAD	<>			;
IOFLSH	LABEL	WORD			;
	PUBLIC	IORCHR			;
IORCHR	LABEL	BYTE			;
	I_am	IOMED,BYTE		;
	I_am	IOXAD,DWORD		;
	I_am	IOSCNT,WORD		;
	I_am	IOSSEC,WORD		;
; Call struct for DSKSTATCHK		;
	I_am	DSKSTCALL,2,<DRDNDHL,0> ;
	I_am	DSKSTCOM,1,<DEVRDND>	;
	I_am	DSKSTST,WORD		;
	DB	8 DUP (0)		;
	I_am	DSKCHRET,BYTE		;

;hkn; short_addr has been changed to provide offset in DOSCODE.
;hkn; deviobuf is in DATA seg (DOSDATA)
;hkn        short_addr  DEVIOBUF            ;
	
	DW	offset DOSDATA:DEVIOBUF

	DW	?			; DOS segment set at Init
	I_AM	DSKSTCNT,WORD,<1>	;
	DW	0			;

	I_am	CreatePDB,BYTE		; flag for creating a process
	PUBLIC	Lock_Buffer		;
Lock_Buffer LABEL    DWORD		;MS. DOS Lock Buffer for Ext Lock
	    DD	    ?			;MS. position
	    DD	    ?			;MS. length
CONST001e	label byte


    PUBLIC  vheDev
vheDev	SYSDEV	<-1,0,0,0,>

;hkn; the foll. was moved from dosmes.asm.

	EVEN				; needed to maintain offsets

    PUBLIC  UserNum, OEMNum
    Public DMES001S,DMES001E
DMES001S Label byte
USERNUM DW	?			; 24 bit user number
	DB	?
IF	IBM
	IF	IBMCOPYRIGHT
	OEMNUM	DB	0			; 8 bit OEM number
	ELSE
	OEMNUM	DB	0FFH			; 8 bit OEM number
	ENDIF
ELSE
OEMNUM	DB	0FFH
ENDIF


DMES001E label byte


DOSDATA	ENDS



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\chkcpu.inc ===
chkcpu	macro

	jmp	begn
	msg	db	13,10,"This copy of MS-DOS will run only on an 8086",13,10
		db	"or 8088 CPU based computer. This computer is not ",13,10
		db 	"based on an 8086 or 8088 CPU. ",13,10
		db	13,10,"Insert a copy of the appropriate MS-DOS system disk ",13,10
		db	"and press any key to re-boot.",13,10,0

begn:
;------GET_CPU_TYPE------------------------------------------------------------May, 88 by M.Williamson
;  Returns: AX = 0 if 8086 or 8088
;              = 1 if 80286
;              = 2 if 80386
;
	pushf
	push	bx			; preserve bx
	xor	bx, bx			; init bx to zero

	xor	ax,ax			; 0000 into AX
	push	ax			; put it on the stack...
	popf				; ...then shove it into the flags
	pushf				; get it back out of the flags...
	pop	ax			; ...and into ax
	and	ax,0F000h		; mask off high four bits
	cmp	ax,0F000h		; was it all 1's?
	je	scpu_8086		; aye; it's an 8086 or 8088

	mov	ax,0F000h		; now try to set the high four bits..
	push	ax
	popf
	pushf
	pop	ax			; ...and see what happens
	and	ax,0F000h		; any high bits set ?
	jz	scpu_286			; nay; it's an 80286

scpu_386:				; bx starts as zero
	inc	bx			; inc twice if 386
scpu_286:				; just inc once if 286
	inc	bx
scpu_8086:				; don't inc at all if 086
	mov	ax, bx			; put CPU type value in ax
	pop	bx			; restore original bx
	popf

	cmp	ax, 0000
	je	cpu_ok
	push	cs
	pop	ds
	mov	si, offset msg
prnt:	lodsb
	or	al, al
	jz	prnt_done
	mov	ah, 14
	mov	bx, 7
	int	10h
	jmp	prnt

prnt_done:
	xor	ah, ah
	int	16h
	
	int	19h
cpu_ok:
	endm

	 


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\cputype.inc ===
; Note: this must be a macro, and not a subroutine in the BIOS since
; 	it is called from both CODE and SYSINITSEG.
;
;------GET_CPU_TYPE------------------------------------------------------------May, 88 by M.Williamson
;  Returns: AX = 0 if 8086 or 8088
;              = 1 if 80286
;              = 2 if 80386
;
;  sudeepb 24-Mar-1993 Modified for NT such that on x86 we return 386
;                      and on non-x86 we do the old style macro.
;                      Using original macro on X86 is pretty costly
;                      because of trapping instructions.

ifndef NEC_98
include vint.inc
else    ;NEC_98
endif   ;NEC_98

Get_CPU_Type    macro
ifndef NEC_98
        local nonx86,getout
        push    ds
        mov     ax,40h
        mov     ds,ax
        lahf
        test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK
        pop     ds
        sahf
        jnz     nonx86
        mov     ax,2
        jmp     short getout
nonx86:
else    ;NEC_98
endif   ;NEC_98
	pushf
	push	bx			; preserve bx
	xor	bx, bx			; init bx to zero

	xor	ax,ax			; 0000 into AX
	push	ax			; put it on the stack...
	popf				; ...then shove it into the flags
	pushf				; get it back out of the flags...
	pop	ax			; ...and into ax
	and	ax,0F000h		; mask off high four bits
	cmp	ax,0F000h		; was it all 1's?
	je	cpu_8086		; aye; it's an 8086 or 8088

	mov	ax,0F000h		; now try to set the high four bits..
	push	ax
	popf
	pushf
	pop	ax			; ...and see what happens
	and	ax,0F000h		; any high bits set ?
	jz	cpu_286			; nay; it's an 80286

cpu_386:				; bx starts as zero
	inc	bx			; inc twice if 386
cpu_286:				; just inc once if 286
	inc	bx
cpu_8086:				; don't inc at all if 086
	mov	ax, bx			; put CPU type value in ax
	pop	bx			; restore original bx
        popf
getout:
	endm

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\dirent.inc ===
;**	Break <Directory entry>

;	NOTE:  These offsets are also used in the DTA for
;	extended FCB SearchFirst/Next.  DIR_NAME lines up
;	with the FCB filename field, and the rest of the
;	DIR_ENTRY fields follow.  -DavidOls

;**	DIRENT.INC - FAT Directory Entry Definition
;
;	+---------------------------+
;	|  (12 BYTE) filename/ext   |	    0	    0
;	+---------------------------+
;	|     (BYTE) attributes     |	    11	    B
;	+---------------------------+
;	|    (10 BYTE) reserved     |	    12	    C
;	+---------------------------+
;	| (WORD) time of last write |	    22	    16
;	+---------------------------+
;	| (WORD) date of last write |	    24	    18
;	+---------------------------+
;	|   (WORD) First cluster    |	    26	    1A
;	+---------------------------+
;	|     (DWORD) file size     |	    28	    1C
;	+---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;			    = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;

DIR_ENTRY   STRUC
DIR_NAME    db	    11 DUP (?)	; file name
DIR_ATTR    db	    ?		; attribute bits
DIR_CODEPG  dw	    ?		; code page DOS 4.00
DIR_EXTCLUSTER dw	?		; extended attribute starting cluster
DIR_ATTR2   db	    ?		; reserved
DIR_PAD     db	    5  DUP (?)	; reserved for expansion
DIR_TIME    dw	    ?		; time of last write
DIR_DATE    dw	    ?		; date of last write
DIR_FIRST   dw	    ?		; first allocation unit of file
DIR_SIZE_L  dw	    ?		; low 16 bits of file size
DIR_SIZE_H  dw	    ?		; high 16 bits of file size

;	    Caution:  An extended FCB SearchFirst/Next on a network
;	    drive under Novell Netware 286 or 386 returns the time/date
;	    in the SIZE fields for subdirectory files.  Ordinarily,
;	    this field is zero for subdirectory files.

DIR_ENTRY   ENDS

ATTR_READ_ONLY	equ	 1h
ATTR_HIDDEN	equ	 2h
ATTR_SYSTEM	equ	 4h
ATTR_VOLUME_ID	equ	 8h
ATTR_DIRECTORY	equ	10h
ATTR_ARCHIVE	equ	20h
ATTR_DEVICE	equ	40h	; This is a VERY special bit.
				;   NO directory entry on a disk EVER
				;   has this bit set. It is set non-zero
				;   when a device is found by GETPATH

ATTR_ALL	equ	attr_hidden+attr_system+attr_directory
				; OR of hard attributes for FINDENTRY

ATTR_IGNORE	equ	attr_read_only+attr_archive+attr_device
				; ignore this(ese) attribute(s) during
				; search first/next

ATTR_CHANGEABLE equ	attr_read_only+attr_hidden+attr_system+attr_archive
				; changeable via CHMOD


DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\devsym.inc ===
;**	DevSym.inc - Device Symbols
;
; 	Revision History: 
;
;	M018 - defined bit 11 of DOS34_FLAG. See M041 in dos.tag for 
;	       explanation.
;


;	THE DEVICE TABLE LIST HAS THE FORM:

SYSDEV	       STRUC
SDEVNEXT       DD    ?		    ;POINTER TO NEXT DEVICE HEADER
SDEVATT        DW    ?		    ;ATTRIBUTES OF THE DEVICE
SDEVSTRAT      DW    ?		    ;STRATEGY ENTRY POINT
SDEVINT        DW    ?		    ;INTERRUPT ENTRY POINT
SDEVNAME       DB    '        '	    ;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
SYSDEV	       ENDS

;
; ATTRIBUTE BIT MASKS
;
; CHARACTER DEVICES:
;
; BIT 15 -> MUST BE 1
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED - Must be 0 to support current versions of Mace Utilities
;      7 -> SUPPORTS DEVICE QUERY
;      6 -> UNUSED
;      5 -> UNUSED
;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
;      3 -> 1 IF DEVICE IS CLOCK DEVICE
;      2 -> 1 IF DEVICE IS NULL DEVICE
;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
;      0 -> 1 IF DEVICE IS CONSOLE INPUT
;
; BLOCK DEVICES:
;
; BIT 15 -> MUST BE 0
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
;	    THE SAME PLACE.
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED - Must be 0 to support current versionso of Mace Utilities
;      7 -> SUPPORTS DEVICE QUERY
;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
;      5 -> UNUSED
;      4 -> UNUSED
;      3 -> UNUSED
;      2 -> UNUSED
;      1 -> UNUSED
;      0 -> UNUSED
;

DEVTYP	       EQU   8000H	    ; BIT 15 - 1  IF CHAR, 0 IF BLOCK
CHARDEV        EQU   8000H
DEVIOCTL       EQU   4000H	    ; BIT 14 - CONTROL MODE BIT
ISFATBYDEV     EQU   2000H	    ; BIT 13 - DEVICE USES FAT ID BYTES,
				    ;  COMP MEDIA.
OUTTILBUSY     EQU   2000H	    ; OUTPUT UNTIL BUSY IS ENABLED
ISNET	       EQU   1000H	    ; BIT 12 - 1 IF A NET DEVICE, 0 IF
				    ;  NOT.  CURRENTLY BLOCK ONLY.
DEVOPCL        EQU   0800H	    ; BIT 11 - 1 IF THIS DEVICE HAS
				    ;  OPEN,CLOSE AND REMOVABLE MEDIA
				    ;  ENTRY POINTS, 0 IF NOT

EXTENTBIT      EQU   0400H	    ; BIT 10 - CURRENTLY 0 ON ALL DEVS
				    ;  THIS BIT IS RESERVED FOR FUTURE USE
				    ;  TO EXTEND THE DEVICE HEADER BEYOND
				    ;  ITS CURRENT FORM.

; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
;    MACHINES (FORMAT,CHKDSK,RECOVER,..).

; M017 IOQUERY	       EQU   0100H	    ;Bit 8 - Supports generic IOCtl query
IOQUERY	       EQU   080H	    ;Bit 7 - Supports generic IOCtl query M017


DEV320	       EQU   0040H	    ;BIT 6 - FOR BLOCK DEVICES, THIS
				    ;DEVICE SUPPORTS SET/GET MAP OF
				    ;LOGICAL DRIVES, AND SUPPORTS
				    ;GENERIC IOCTL CALLS.
				    ;FOR CHARACTER DEVICES, THIS
				    ;DEVICE SUPPORTS GENERIC IOCTL.
				    ;THIS IS A DOS 3.2 DEVICE DRIVER.
ISSPEC	       EQU   0010H	    ;BIT 4 - THIS DEVICE IS SPECIAL
ISCLOCK        EQU   0008H	    ;BIT 3 - THIS DEVICE IS THE CLOCK DEVICE.
ISNULL	       EQU   0004H	    ;BIT 2 - THIS DEVICE IS THE NULL DEVICE.
ISCOUT	       EQU   0002H	    ;BIT 1 - THIS DEVICE IS THE CONSOLE OUTPUT.
ISCIN	       EQU   0001H	    ;BIT 0 - THIS DEVICE IS THE CONSOLE INPUT.
EXTDRVR        EQU   0002H	    ;BIT 1 - BLOCK DEVICE EXTNDED DRIVER



;STATIC REQUEST HEADER
SRHEAD	       STRUC
REQLEN	       DB    ?		    ;LENGTH IN BYTES OF REQUEST BLOCK
REQUNIT        DB    ?		    ;DEVICE UNIT NUMBER
REQFUNC        DB    ?		    ;TYPE OF REQUEST
REQSTAT        DW    ?		    ;STATUS WORD
	       DB    8 DUP(?)	    ;RESERVED FOR QUEUE LINKS
SRHEAD	       ENDS

;STATUS WORD MASKS
STERR	       EQU   8000H	    ;BIT 15 - ERROR
STBUI	       EQU   0200H	    ;BIT 9 - BUISY
STDON	       EQU   0100H	    ;BIT 8 - DONE
STECODE        EQU   00FFH	    ;ERROR CODE
;						  2/12/KK
; Interim  character identifier 		  2/12/KK
Ddkey		EQU	0000010000000000B	; 2/12/KK

;FUNCTION CODES
DINITHL        EQU   26 	    ;SIZE OF INIT HEADER
DMEDHL	       EQU   15 	    ;SIZE OF MEDIA CHECK HEADER
DBPBHL	       EQU   22 	    ;SIZE OF GET BPB HEADER
DRDWRHL        EQU   22 	    ;SIZE OF RD/WR HEADER
DRDNDHL        EQU   14 	    ;SIZE OF NON DESTRUCTIVE READ HEADER
DSTATHL        EQU   13 	    ;SIZE OF STATUS HEADER
DFLSHL	       EQU   15 	    ;SIZE OF FLUSH HEADER

DEVINIT        EQU   0		    ;INITIALIZATION
DEVMDCH        EQU   1		    ;MEDIA CHECK
DEVBPB	       EQU   2		    ;GET BPB
DEVRDIOCTL     EQU   3		    ;IOCTL READ
DEVRD	       EQU   4		    ;READ
DEVRDND        EQU   5		    ;NON DESTRUCTIVE READ NO WAIT (CHARACTER DEVS)
DEVIST	       EQU   6		    ;INPUT STATUS
DEVIFL	       EQU   7		    ;INPUT FLUSH
DEVWRT	       EQU   8		    ;WRITE
DEVWRTV        EQU   9		    ;WRITE WITH VERIFY
DEVOST	       EQU   10 	    ;OUTPUT STATUS
DEVOFL	       EQU   11 	    ;OUTPUT FLUSH
DEVWRIOCTL     EQU   12 	    ;IOCTL WRITE
DEVOPN	       EQU   13 	    ;DEVICE OPEN
DEVCLS	       EQU   14 	    ;DEVICE CLOSE
DOPCLHL        EQU   13 	    ;SIZE OF OPEN/CLOSE HEADER
DEVRMD	       EQU   15 	    ;REMOVABLE MEDIA
REMHL	       EQU   13 	    ;SIZE OF REMOVABLE MEDIA HEADER
GENIOCTL       EQU   19

; THE NEXT THREE ARE USED IN DOS 4.0
;		     20
;		     21
;		     22

DEVGETOWN      EQU   23 	    ;GET DEVICE OWNER
DEVSETOWN      EQU   24 	    ;SET DEVICE OWNER
IOCTL_QUERY    EQU   25		    ;Query generic ioctl support

OWNHL	       EQU   13 	    ;SIZE OF DEVICE OWNER HEADER

DEVOUT	       EQU   16 	    ; OUTPUT UNTIL BUSY.

DEVOUTL        EQU   DEVWRT	    ; LENGTH OF OUTPUT UNTIL BUSY

; ADDED FOR DOS 5.00
;


; GENERIC IOCTL REQUEST STRUCTURE
;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
;
IOCTL_REQ      STRUC
	       DB    (SIZE SRHEAD) DUP(?)
				    ; GENERIC IOCTL ADDITION.
MAJORFUNCTION  DB    ?		    ;FUNCTION CODE
MINORFUNCTION  DB    ?		    ;FUNCTION CATEGORY
REG_SI	       DW    ?
REG_DI	       DW    ?
GENERICIOCTL_PACKET DD ?	    ; POINTER TO DATA BUFFER
IOCTL_REQ      ENDS

;	DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
GEN_IOCTL_WRT_TRK   EQU   40H
GEN_IOCTL_RD_TRK    EQU   60H
GEN_IOCTL_FN_TST    EQU   20H	    ; USED TO DIFF. BET READS AND WRTS

;; 32-bit absolute read/write input list structure

ABS_32RW	 STRUC
SECTOR_RBA	 DD	 ?	    ; relative block address
ABS_RW_COUNT	 DW	 ?	    ; number of sectors to be transferred
BUFFER_ADDR	 DD	 ?	    ; data addrress
ABS_32RW	 ENDS

;; media ID info

MEDIA_ID_INFO	 STRUC
MEDIA_level	 DW	 0	    ; info level
MEDIA_Serial	 DD	 0	    ; serial #
MEDIA_Label	 DB	 11 dup (' ') ;volume label
MEDIA_System	 DB	 8  dup (' ') ;system type
MEDIA_ID_INFO	 ENDS

;; equates for DOS34_FLAG
;
; BUGBUG: why are bits 0,1,3 and 4 not defined.
;

FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
					    ;M018: that knows how to handle 
					    ;M018: open for exec

NO_FROM_DISK_RESET    EQU   NOT FROM_DISK_RESET	;not from disk reset
NO_Force_I24_Fail     EQU   NOT Force_I24_Fail	;not form IFS CALL BACK
NO_Disable_EOF_I24    EQU   NOT Disable_EOF_I24

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\doscntry.inc ===
;
;Equates for COUNTRY INFORMATION.
SetCountryInfo		EQU	1	;country info
SetUcase		EQU	2	;uppercase table
SetLcase		EQU	3	;lowercase table (Reserved)
SetUcaseFile		EQU	4	;uppercase file spec table
SetFileList		EQU	5	;valid file character list
SetCollate		EQU	6	;collating sequence
SetDBCS 		EQU	7	;double byte character set
SetALL			EQU	-1	;all the entries


;DOS country and code page information table structure.
;Internally, DOS gives a pointer to this table.
;IBMBIO, MODE and NLSFUNC modules communicate with DOS through
;this structure.
DOS_country_cdpg_info struc
ccInfo_reserved 	db	8 dup (?) ;reserved for internal use
ccPath_CountrySys	db	64 dup (0);path and filename for country info
ccSysCodePage		dw	0	;system code page id
ccNumber_of_entries	dw	6	; 6 entries
ccSetUcase		db	SetUcase
ccUcase_ptr		dd	?	;pointer to Ucase table

ccSetUcaseFile		db	SetUcaseFile
ccFileUcase_ptr 	dd	?	;pointer to File Ucase table

ccSetFileList		db	SetFileList
ccFileChar_ptr		dd	?	;pointer to File char list table

ccSetCollate		db	SetCollate
ccCollate_ptr		dd	?	;pointer to collate table

ccSetDBCS		db	SetDBCS
ccDBCS_ptr		dd	?	;pointer to DBCS  table

ccSetCountryInfo	db	SetCountryInfo
ccCountryInfoLen	dw	?	;length of country info
ccDosCountry		dw	?	;active country code id
ccDosCodePage		dw	?	;active code page id
ccDFormat		dw	?	;date format
ccCurSymbol		db	"    ",0;5 byte of (currency symbol+0)
cc1000Sep		db	" ",0   ;2 byte of (1000 sep. + 0)
ccDecSep		db	" ",0   ;2 byte of (Decimal sep. + 0)
ccDateSep		db	" ",0   ;2 byte of (date sep. + 0)
ccTimeSep		db	" ",0   ;2 byte of (time sep. + 0)
ccCFormat		db	?	;currency format flags
ccCSigDigits		db	?	;# of digits in currency
ccTFormat		db	?	;time format
ccMono_Ptr		dd	?	;monocase routine entry point
ccListSep		db	" ",0   ;data list separator
ccReserved_area 	dw	5 dup(?);reserved

DOS_country_cdpg_info ends

;Ucase table
CC_UCASE_TAB	struc
ccUcase_leng	       dw	128
ccUcase_data	       db	128 dup (?)
CC_UCASE_TAB	ends

;File Ucase table
CC_FILE_UCASE_TAB	struc
ccFileucase_leng	dw	128
ccFileucase_data	db	128 dup (?)
CC_FILE_UCASE_TAB	ends

;File char list
CC_FILE_CHAR_TAB	struc
ccFilechar_leng 	dw	?
ccFilechar_data 	db	46 dup (?)
CC_FILE_CHAR_TAB	ends

;collate table
CC_COLLATE_TAB	struc
ccCollate_leng		dw	256
ccCollate_data		db	256 dup (?)
CC_COLLATE_TAB	ends

;DBCS table -  for DOS 4.00
CC_DBCS_TAB	struc
ccDBCS_leng	       dw      6
ccDBCS_data	       db      6 dup (?)
CC_DBCS_TAB	ends

;						2/12/KK
; Define subfunctions of ECS_call ( 63H )	2/12/KK
;						2/12/KK
GetLeadBTBL	EQU	0	;		2/12/KK
SetInterimMode	EQU	1	;		2/12/KK
GetInterimMode	EQU	2	;		2/12/KK
				;		2/12/KK
NonInterimMode	EQU	0	;		2/12/KK
InterimMode	EQU	1	;		2/12/KK

OLD_COUNTRY_SIZE    equ     (size DOS_country_cdpg_info - ccDFormat - 10)
NEW_COUNTRY_SIZE    equ     (size DOS_country_cdpg_info - ccDosCountry)

;CAPITALIZATION equates
CAP_ONE_CHAR	    equ      20H
CAP_STRING	    equ      21H
CAP_ASCIIZ	    equ      22H
CHECK_YES_NO	    equ      23H
UPPER_TABLE	    equ      80H

;NLS_YES	     equ      59H
;NLS_yes2	     equ      79H
;NLS_NO 	     equ      4EH
;NLS_no2	     equ      6EH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\cpmfcb.inc ===
;       SCCSID = @(#)cpmfcb.asm 1.1 85/04/10
;       SCCSID = @(#)cpmfcb.asm 1.1 85/04/10
;BREAK <File Control Block definition>

;
; Field definition for FCBs
; The FCB has the following structure:
;
;       +---------------------------+
;       |   Drive indicator(byte)   |
;       +---------------------------+
;       |    Filename (8 chars)     |
;       +---------------------------+
;       |    Extension (3 chars)    |
;       +---------------------------+
;       |   Current Extent(word)    |
;       +---------------------------+
;       |    Record size (word)     |
;       +---------------------------+
;       |    File Size (2 words)    |
;       +---------------------------+
;       |       Date of write       |
;       +---------------------------+
;       |       Time of write       |
;       +---------------------------+
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;       +---------------------------+
;       |   8 bytes reserved        |
;       +---------------------------+
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;       |    next record number     |
;       +---------------------------+
;       |   random record number    |
;       +---------------------------+
;

sys_fcb     STRUC
fcb_drive   DB      ?
fcb_name    DB      8 DUP (?)
fcb_ext     DB      3 DUP (?)
fcb_EXTENT  DW      ?
fcb_RECSIZ  DW      ?                   ; Size of record (user settable)
fcb_FILSIZ  DW      ?                   ; Size of file in bytes; used with the
                                        ; following word
fcb_DRVBP   DW      ?                   ; BP for SEARCH FIRST and SEARCH NEXT
fcb_FDATE   DW      ?                   ; Date of last writing
fcb_FTIME   DW      ?                   ; Time of last writing
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
fcb_reserved DB      8 DUP (?)           ; RESERVED
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
fcb_NR      DB      ?                   ; Next record
fcb_RR      DB      4 DUP (?)           ; Random record
sys_fcb     ENDS

FILDIRENT       = fcb_FILSIZ            ; Used only by SEARCH FIRST and SEARCH
                                        ; NEXT

; FCB's reserve area is interpreted on NT as follows.

fcb_sfn		EQU	BYTE PTR fcb_reserved	    ; SFN
fcb_res_dev	EQU	BYTE PTR fcb_reserved+1     ; 1 if local device
fcb_res_dummy	EQU	BYTE PTR fcb_reserved+2     ; Not using in NT
fcb_res_dummy2	EQU	BYTE PTR fcb_reserved+3	    ; Not using in NT
fcb_res_Sig	EQU	DWORD PTR fcb_reserved+4    ; Using as a check


; fcb_nsl_Sig is a signature to check if the FCB-SFT association is valid.
;
; for a local device this field contains the devptr. sft's field devptr
; is checked against it.
;
; for a file/UNC/pipe etc this field contains an NT handle. sft's NThandle
; field is checked against it.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to HHLs
(C)Copyright 1984, 1988 Microsoft Corporation
$
if1
outif MACRO name,defval,onmsg,offmsg
    ifndef name
	ifb <defval>
	    name=0
	else
	    name=defval
	endif
    endif
    if name
	name=1
	ifnb <onmsg>
	    %out ! onmsg
	endif
    else
	ifnb <offmsg>
	    %out ! offmsg
	endif
    endif
endm

error MACRO msg
bug
%out E r r o r ----- msg
ENDM
%out cMacros Version 1.04
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS= 1
outif memS,0,<Small Model>
else
error <Must have only 1 memory model selected>
endif
endif
sizeC= memM + memL + memH
sizeD= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?WIN,0,<Windows Support>
outif ?PLM,0,<PLM calling convention>
endif
 .XCREF
 .XCREF ?N,?AX,?AH,?AL,?BX,?BH
 .XCREF ?BL,?CX,?CH,?CL,?DX,?DH
 .XCREF ?DL,?SI,?DI,?ES,?DS,?BP
 .XCREF ?SP,?SS,?CS
 .XCREF ?RSL,?CPD,?argl,?argc,?BA
 .XCREF ?ACB,???,?PO
 .XCREF ?PAS,?PC
 .XCREF Uconcat,mPush,mPop
 .XCREF ?RI,?pp,?pp1,?al1
 .XCREF ?aD,?AP,?Atal,?pd,?dd,?dd1,?ex1,?cas
 .XCREF ?pg,?pg1,?aloc,?cs1,?cs2
 .XCREF ?lb1,?lblpu
 .XCREF ?DF,?PLM,?WIN,?IA,?PU,?ADJ
 .CREF
?RSL = 0
?CPD = 0
?ArgL = 0
?ArgC = 0
?BA = 0
?ACB = 0
??? = 0
?PO = 0
?PAS = 0
?PC = 0
?IA = 0
?PU = 0
?ADJ = 0
?lblpu = 0
?N = 0000000000000000B
?AX = 0000000000000011B
?AH = 0000000000000001B
?AL = 0000000000000010B
?BX = 0000000000001100B
?BH = 0000000000000100B
?BL = 0000000000001000B
?CX = 0000000000110000B
?CH = 0000000000010000B
?CL = 0000000000100000B
?DX = 0000000011000000B
?DH = 0000000001000000B
?DL = 0000000010000000B
?SI = 0000000100000000B
?DI = 0000001000000000B
?ES = 0000010000000000B
?DS = 0000100000000000B
?BP = 0001000000000000B
?SP = 0010000000000000B
?SS = 0100000000000000B
?CS = 1000000000000000B
uconcat macro n1,n2,o1,o2,p1,p2
n1&n2 o1&o2 p1&p2
endm
mpush macro rV
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if rV AND ?&&x
push x
endif
endm
endm
mpop macro rV
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if rV AND ?&&x
pop x
endif
endm
endm
SAVE macro rL
?RSL = 0
?RI ?RSL,<rL>
endm
smashes macro n,rL
 .xcref
 .xcref ?SM&n
 .cref
?SM&n = 0
?RI ?SM&n,<rL>
endm
?RI macro n,rL
irp x,<rL>
ifdef ?&&x
n = n or ?&&x
endif
endm
endm
parmB macro nl
?pp <&nL>,<byte>,2,1
endm
parmW macro nl
?pp <&nL>,<word>,2,2
endm
parmD macro nl
ife ?PLM
irp x,<nL>
?pp <&&x>,<DWORD>,0,4
?pp <Off_&&x>,<WORD>,2,2
?pp <Seg_&&x>,<WORD>,2,2
endm
else
irp x,<nL>
?pp <Seg_&&x>,<WORD>,2,2
?pp <Off_&&x>,<WORD>,2,2
?pp <&&x>,<DWORD>,0,4
endm
endif
endm
parmQ macro nl
?pp <&nL>,<QWORD>,8,8
endm
parmT macro nl
?pp <&nL>,<TBYTE>,10,10
endm
if sizeC
parmCP macro nl
parmD <nl>
endm
else
parmCP macro nl
parmW <nl>
endm
endif
if sizeD
parmDP macro nl
parmD <nl>
endm
else
parmDP macro nl
parmW <nl>
endm
endif
?pp macro nL,t,l,s
if ?CPD
 .xcref
ife ?PLM
irp x,<nL>
?pp1 x,<t>,%?PO,%?adj,%(?PO+?adj)
?PO = ?PO + l
 .xcref ?T&&x
?T&&x = s
endm
else
irp x,<nL>
?PO = ?PO + l
?pp1 x,<t>,%?PO,%?adj,%(?PO+?adj)
 .xcref ?T&&x
?T&&x = s
endm
endif
 .cref
else
%out Parm(s) "&nl" declared outside proc def.
endif
endm
?pp1 macro n,t,o,a,b
ife ?PLM
n equ t ptr [bp+b]
else
n equ t ptr [bp+a+?PO-o]
endif
endm
localB macro nL
?aLoc <&nL>,<BYTE ptr>,1,1,0
endm
localW macro nL
?aLoc <&nL>,<WORD PTR>,2,2,1
endm
localD macro nL
irp x,<nL>
?aLoc <Seg_&&x>,<WORD PTR>,2,2,1
?aLoc <Off_&&x>,<WORD PTR>,2,2,1
?aLoc <&&x>,<DWORD PTR>,0,4,1
endm
endm
localQ macro nL
?aLoc <&nL>,<QWORD PTR>,8,8,1
endm
localT macro nL
?aLoc <&nL>,<TBYTE PTR>,10,10,1
endm
if sizeC
localCP macro nL
localD <nL>
endm
else
localCP macro nL
localW <nL>
endm
endif
if sizeD
localDP macro nL
localD <nL>
endm
else
localDP macro nL
localW <nL>
endm
endif
localV macro n,a
?aLoc <&n>,,%(&a),0,1
endm
?aLoc macro nL,t,l,s,a
if ?CPD
 .xcref
??? = ??? + l
if a
??? = ((??? + 1) AND 0FFFEH)
endif
irp x,<nL>
?aL1 x,<t>,%???
 .xcref ?T&&x
?T&&x = s
endm
 .cref
else
%out Locals "&nl" declared outside procedure def.
endif
endm
?aL1 macro n,t,o
if ?IA
n equ t [bp-?IA-o]
else
n equ t [bp-o]
endif
endm
globalB macro n,i,s
?aD <n>,1
?dd n,1,<BYTE>,<DB>,<i>,<s>
endm
globalW macro n,i,s
?aD <n>,2
?dd n,1,<WORD>,<DW>,<i>,<s>
endm
globalD macro n,i,s
?aD <n>,4
?dd n,1,<DWORD>,<DD>,<i>,<s>
endm
globalQ macro n,i,s
?aD <n>,8
?dd n,1,<QWORD>,<DQ>,<i>,<s>
endm
globalT macro n,i,s
?aD <n>,10
?dd n,1,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
globalCP macro n,i,s
globalD n,<i>,<s>
endm
else
globalCP macro n,i,s
globalW n,<i>,<s>
endm
endif
if sizeD
globalDP macro n,i,s
globalD n,<i>,<s>
endm
else
globalDP macro n,i,s
globalW n,<i>,<s>
endm
endif
staticB macro n,i,s
?aD <n>,1
?dd n,0,<BYTE>,<DB>,<i>,<s>
endm
staticW macro n,i,s
?aD <n>,2
?dd n,0,<WORD>,<DW>,<i>,<s>
endm
staticD macro n,i,s
?aD <n>,4
?dd n,0,<DWORD>,<DD>,<i>,<s>
endm
staticQ macro n,i,s
?aD <n>,8
?dd n,0,<QWORD>,<DQ>,<i>,<s>
endm
staticT macro n,i,s
?aD <n>,10
?dd n,0,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sizeD
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
?dd macro n,p,t,d,i,s
ife ?PLM
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
PUBLIC n
endif
ifb <s>
n d i
else
ifb <i>
n d s DUP (?)
else
n d s DUP (i)
endif
endif
endm
externB macro nL
?ex1 <&nL>,1,<BYTE>
endm
externW macro nL
?ex1 <&nL>,2,<WORD>
endm
externD macro nL
?ex1 <&nL>,4,<DWORD>
endm
externQ macro nL
?ex1 <&nL>,8,<QWORD>
endm
externT macro nL
?ex1 <&nL>,10,<TBYTE>
endm
externNP macro nL
?ex1 <&nL>,2,<NEAR>
endm
externFP macro nL
?ex1 <&nL>,4,<FAR>
endm
if sizeC
externP macro nL
?ex1 <&nL>,4,<FAR>
endm
else
externP macro nL
?ex1 <&nL>,2,<NEAR>
endm
endif
if sizeC
externCP macro nL
?ex1 <&nL>,4,<DWORD>
endm
else
externCP macro nL
?ex1 <&nL>,2,<WORD>
endm
endif
if sizeD
externDP macro nL
?ex1 <&nL>,4,<DWORD>
endm
else
externDP macro nL
?ex1 <&nL>,2,<WORD>
endm
endif
?ex1 macro nL,s,d
irp x,<nL>
 .xcref
 .xcref ?T&&x
 .cref
?T&&x = s
ife ?PLM
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
endm
endm
labelB macro nL
?lb1 <&nL>,1,<BYTE>
endm
labelW macro nL
?lb1 <&nL>,2,<WORD>
endm
labelD macro nL
?lb1 <&nL>,4,<DWORD>
endm
labelQ macro nL
?lb1 <&nL>,8,<QWORD>
endm
labelT macro nL
?lb1 <&nL>,10,<TBYTE>
endm
labelNP macro nL
?lb1 <&nL>,2,<NEAR>
endm
labelFP macro nL
?lb1 <&nL>,4,<FAR>
endm
if sizeC
labelP macro nL
?lb1 <&nL>,4,<FAR>
endm
else
labelP macro nL
?lb1 <&nL>,2,<NEAR>
endm
endif
if sizeC
labelCP macro nL
?lb1 <&nL>,4,<DWORD>
endm
else
labelCP macro nL
?lb1 <&nL>,2,<WORD>
endm
endif
if sizeD
labelDP macro nL
?lb1 <&nL>,4,<DWORD>
endm
else
labelDP macro nL
?lb1 <&nL>,2,<WORD>
endm
endif
?lb1 macro nL,s,d
?lblpu = 0
irp x,<nL>
ifidn <x>,<PUBLIC>
?lblpu = 1
else
 .xcref
 .xcref ?T&&x
 .cref
?T&&x = s
ife ?PLM
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
defB macro nL
?aD <&nL>,1
endm
defW macro nL
?aD <&nL>,2
endm
defD macro nL
?aD <&nL>,4
endm
defQ macro nL
?aD <&nL>,8
endm
defT macro nL
?aD <&nL>,10
endm
if sizeC
defCP macro nL
defD <nL>
endm
else
defCP macro nL
defW <nL>
endm
endif
if sizeD
defDP macro nL
defD <nL>
endm
else
defDP macro nL
defW <nL>
endm
endif
?aD macro nL,s
irp x,<nL>
 .xcref
 .xcref ?T&&x
 .cref
?T&&x = s
endm
endm
regPtr macro n,S,O
 .xcref
 .xcref ?T&n,?SR&n,?OR&n
 .cref
?T&n = 0FFFFH
?SR&n = 0
?RI ?SR&n,<&S>
?OR&n = 0
?RI ?OR&n,<&O>
endm
arg macro aL
irp x,<aL>
?argc = ?argc + 1
?Atal <x>,%?argc
endm
endm
?Atal macro n,i
 .xcref
 .xcref ?ALI&i
 .cref
?ALI&i &macro
?AP n
&endm
endm
?AP macro n
?argl = ?argl + 2
ifdef ?T&n
ife ?T&n-1
push word ptr (n)
exitm
endif
ife ?T&n-2
push n
exitm
endif
ife ?T&n-4
push word ptr (n)+2
push word ptr (n)
?argl = ?argl + 2
exitm
endif
ife ?T&n-8
push word ptr (n)+6
push word ptr (n)+4
push word ptr (n)+2
push word ptr (n)
?argl = ?argl + 6
exitm
endif
ife ?T&n-0FFFFH
mpush %(?SR&n),1
mpush %(?OR&n),1
?argl = ?argl + 2
exitm
endif
ife ?T&n
push word ptr (n)
exitm
endif
endif
push n
endm
ife ?PLM
ccall macro n,a,sleaze
ifnb <a>
Arg <a>
endif
ifdef ?SM&n
?RSL = ?RSL AND ?SM&n
endif
mpush %?RSL
?argl = 0
?ACB = ?argc
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
?ACB = ?ACB - 1
endm
ife ?PLM
ifb <sleaze>
call _&n
else
call n
endif
else
call n
endif
if ?argl
add sp,?argl
endif
mpop %?RSL
?RSL = 0
?argc = 0
?argl = 0
endm
else
ccall macro n,a
ifnb <a>
Arg <a>
endif
ifdef ?SM&n
?RSL = ?RSL AND ?SM&n
endif
mpush %?RSL
?argl = 0
?ACB = 1
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
?ACB = ?ACB + 1
endm
ife ?PLM
call _&n
else
call n
endif
mpop %?RSL
?RSL = 0
?argc = 0
?argl = 0
endm
endif
cProc macro n,cl,s
?pd n,<cl>,<s>,4
endm
?pd macro n,c,a,i
if ?CPD
?UTPE
endif
?CPD = 1
??? = 0
?argc = 0
?BA = 0
?PO = 0
?PU = 0
?IA = 0
?adj = i
?PAS = 0
ifnb <a>
?RI ?PAS,<a>
endif
?PC = sizeC
irp x,<c>
ifidn <x>,<FAR>
?PC = 1
endif
ifidn <x>,<NEAR>
?PC = 0
endif
ifidn <x>,<PUBLIC>
?PU = 1
endif
endm
if ?PC
if ?WIN
?IA = 2
endif
?adj = ?adj + 2
endif
ife ?PLM
ife ?PC
n label near
else
n label far
endif
?pg <_&n>,%?PU,%?PC,%?PAS
else
?pg <n>,%?PU,%?PC,%?PAS
endif
endm
?pg macro n,p,c,a
    .xcref
    cBegin &macro g
	.xcref
	?pg1 <n>,c,a,%?PO
	?CPD = 0
	?argc = 0
	?BA = 1
	??? = (???+1) AND 0FFFEH
	if p
	    PUBLIC n
	endif
	ife c
	    n proc NEAR
	else
	    n proc FAR
	endif
	ifidn <g>,<nogen>
	    if ???+?PO+a
		%out <cBegin - possible invalid use of nogen>
	    endif
	else
	    if ?IA
		mov ax,ds
		nop
		inc bp
		push bp
		mov bp,sp
		push ds
		mov ds,ax
	    else
		push bp
		mov bp,sp
	    endif
	    if ???
		sub sp,???
	    endif
	    mPush a,1
	endif
	.cref
	purge cBegin
    &endm
    ?UTPE &macro
	%out Unterminated Procedure Definition: "&n"
    &endm
endm

?pg1 macro n,c,a,o
    .xcref
    cEnd &macro g
	.xcref
	?BA = 0
	ifidn <g>,<nogen>
	    if o+a
		%out <cEnd - possible invalid use of nogen>
	    endif
	else
	    mPop a,1
	    if ?IA
		sub bp,2
		mov sp,bp
		pop ds
		pop bp
		dec bp
	    else
		mov sp,bp
		pop bp
	    endif
	    ife ?PLM
		ret
	    else
		ret o
	    endif
	endif
	n endp
	.cref
	purge cEnd
    &endm
    .cref
endm

assumes macro s,g
local assumed
assumed = 0
ifidn <code>,<g>
?cas <s>
assumed = 1
endif
ifidn <CODE>,<g>
?cas <s>
assumed = 1
endif
ifidn <data>,<g>
assume s&:dgroup
assumed = 1
endif
ifidn <DATA>,<g>
assume s&:dgroup
assumed = 1
endif
ife assumed
assume s&:&g
endif
endm
if sizeC
?cas macro s
assume s&:_TEXT
endm
else
?cas macro s
assume s&:IGROUP
endm
endif
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
ifidn <grp>,<IGROUP>
ife sizeC
addSeg IGROUP,n
endif
else
addSeg grp,n
endif
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <n>,<ln>
endm
if1
ASMpass=1
else
ASMpass=2
endif
addSeg macro grp,seg
ifndef def_&grp
def_&grp= 0
endif
if def_&grp ne ASMpass
add_&grp &macro s
in_&grp <seg>,s
&endm
in_&grp &macro sl,s
ifb <s>
grp group sl
else
add_&grp &macro ns
in_&grp <sl,s>,ns
&endm
endif
&endm
def_&grp=ASMpass
else
add_&grp seg
endif
endm
defGrp macro nam
addSeg nam
endm
?cs1 macro n,ln
begin&ln &macro
?cs2 <n>
n segment
&endm
endm

?cs2 macro n
    sEnd &macro
	n ends
    &endm
endm

sBegin macro ln
    begin&ln
endm

ife ?DF
    createSeg _TEXT,code,byte,public,CODE,IGROUP
    createSeg _DATA,data,word,public,DATA,DGROUP
    if ?WIN
	ife sizeC
	    createSeg _INITTEXT,initcode,byte,public,CODE,IGROUP
	    createSeg _INITDATA,initdata,word,public,DATA,DGROUP
	endif
    endif
    ife sizeC
	defGrp IGROUP
    endif
    defGrp DGROUP
    if sizeC
	codeOFFSET equ OFFSET _TEXT:
    else
	codeOFFSET equ OFFSET IGROUP:
    endif
    dataOFFSET equ OFFSET DGROUP:
endif

errnz macro x
    if2
	if x
	    errnz1 <x>,%(x)
	endif
    endif
endm

errnz1 macro x1,x2
    = *ERRNZ* x1 = x2
endm

errn$ macro l,x
    errnz <OFFSET $ - OFFSET l x>
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\dosmac.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Macro definitions for MSDOS.
;
;       Revision history:
;        	M019 DB 10/26/90 - Added Cmp32 macro.

TRUE    EQU 0FFFFh
FALSE   EQU 0

SUBTTL BREAK a listing into pages and give new subtitles
PAGE
BREAK   MACRO   subtitle
	SUBTTL  subtitle
	PAGE
ENDM
.xcref  break

BREAK   <ASMVAR - handle assembly variables once and for all>

AsmVars Macro   varlist
IRP     var,<varlist>
AsmVar  var
ENDM
ENDM

AsmVar  Macro   var
IFNDEF  var
var = FALSE
ENDIF
ENDM

BREAK <I_NEED: declare a variable external, if necessary, and allocate a size>

;
; declare a variable external and allocate a size
;
AsmVar  InstalledData
I_NEED  MACRO   sym,len
IF NOT InstalledData
	DOSDATA    SEGMENT WORD PUBLIC 'DATA'
    IFIDN   <len>,<WORD>
	EXTRN   &sym:WORD
    ELSE
	IFIDN   <len>,<DWORD>
	EXTRN   &sym:DWORD
	ELSE
	EXTRN   &sym:BYTE
	ENDIF
    ENDIF
	DOSDATA    ENDS
ENDIF
ENDM
	.xcref I_need


; call a procedure that may be external.  The call will be short.

invoke  MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	CALL    name
ENDM
.xcref  invoke

PAGE
;
; jump to a label that may be external.  The jump will be near.
;
transfer    MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	JUMP    name
ENDM
.xcref  transfer

;
; get a short address in a word
;
short_addr  MACRO   name
    IFDIF   <name>,<?>
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	DW  OFFSET DOSCODE:name
    ELSE
	DW  ?
    ENDIF
ENDM
.xcref  short_addr

;
; get a long address in a dword
;
long_addr   MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	DD  name
ENDM
.xcref  long_addr

;
; declare a PROC near or far but PUBLIC nonetheless
;
.xcref ?frame
.xcref ?aframe
.xcref ?stackdepth
.xcref ?initstack
?frame        =   0                     ; initial
?aframe       =   0                     ; initial
?stackdepth   =   0                     ; initial stack size
?initstack    =   0                     ; initial stack size

procedure   MACRO   name,distance
	?frame =    0
	?aframe =   2                   ;; remember the pushed BP
	PUBLIC  name
name    PROC    distance
	ASSUME	DS:nothing,ES:nothing
	?initstack    = ?stackdepth     ;; beginning of procedure
ENDM
.xcref  procedure


; end a procedure and check that stack depth is preserved

EndProc MACRO   name, chk
	IFDIF   <chk>,<NoCheck>       ;; check the stack size
	IF2
	IF ?initstack NE ?stackdepth    ;; is it different?
	%OUT    ***** Possible stack size error in name *****
	ENDIF
	ENDIF
	ENDIF
name    ENDP
ENDM
.xcref  endproc
PAGE
;
; define a data item to be public and of an appropriate size/type
;

I_AM    MACRO   name,size,init
;; declare the object public
	PUBLIC  name
;; declare the type of the object
    IFIDN <size>,<WORD>
name    LABEL WORD
	I_AM_SIZE   =   1
	I_AM_LEN    =   2
    ELSE
	IFIDN <size>,<DWORD>
name    LABEL DWORD
	I_AM_SIZE   =   2
	I_AM_LEN    =   2
	ELSE
	    IFIDN <size>,<BYTE>
name    LABEL BYTE
	I_AM_SIZE   =   1
	I_AM_LEN    =   1
	    ELSE
name    LABEL BYTE
	I_AM_SIZE   =   size
	I_AM_LEN    =   1
	    ENDIF
	ENDIF
    ENDIF
;; if no initialize then allocate blank storage
    IFB <init>
	DB  I_AM_SIZE*I_AM_LEN DUP (?)
    ELSE
IF NOT InstalledData
	IRP itm,<init>
	    IF I_AM_LEN EQ 1
		DB  itm
	    ELSE
		DW  itm
	    ENDIF
	    I_AM_SIZE = I_AM_SIZE - 1
	ENDM
	IF I_AM_SIZE NE 0
	    %out    ***** initialization of name not complete *****
	ENDIF
ELSE
	DB  I_AM_SIZE*I_AM_LEN DUP (?)
ENDIF
    ENDIF
ENDM
.xcref  I_AM
.xcref  I_AM_SIZE
.xcref  I_AM_LEN
I_AM_SIZE   = 0
I_AM_LEN    = 0

PAGE

;
; define an entry in a procedure
;
entry macro name
	PUBLIC  name
name:
endm
.xcref  entry

BREAK <ERROR - store an error code then jump to a label>

error macro code
.xcref
	MOV AL,code
	transfer    SYS_RET_ERR
.cref
ENDM
.xcref  error

BREAK <JUMP - real jump that links up shortwise>
;
; given a label <lbl> either 2 byte jump to another label <lbl>_J
; if it is near enough or 3 byte jump to <lbl>
;

jump    macro lbl
    local a
.xcref

    ifndef lbl&_J                       ;; is this the first invocation
a:      JMP lbl
    ELSE
	IF (lbl&_J GE $) OR ($-lbl&_J GT 126)
a:      JMP lbl                         ;; is the jump too far away?
	ELSE
a:      JMP lbl&_J                      ;; do the short one...
	ENDIF
    ENDIF
    lbl&_j = a
.cref
endm
.xcref  jump

BREAK <RETURN - return from a function>

return  macro x
    local a
.xcref
a:
	RET
ret_l = a
.cref
endm
.xcref  return

BREAK <CONDRET - conditional return>

condret macro   cc,ncc
    local   a
.xcref
.xcref a
.cref
    ifdef   ret_l                       ;; if ret_l is defined
	if (($ - ret_l) le 126) and ($ gt ret_l)
					;;     if ret_l is near enough then
	    a:  j&cc    ret_l           ;;         a: j<CC> to ret_l
	    ret_&cc = a                 ;;         define ret_<CC> to be a:
	    exitm
	endif
    endif
    ifdef   ret_&cc                     ;; if ret_<CC> defined
	if (($ - ret_&cc) le 126) and ($ gt ret_&cc)
					;;     if ret_<CC> is near enough
	    a:  j&cc    ret_&cc         ;;         a: j<CC> to ret_<CC>
	    ret_&cc = a                 ;;         define ret_<CC> to be a:
	    exitm
	endif
    endif
    j&ncc   a                           ;; j<NCC> a:
    return                              ;; return
    a:                                  ;; a:
    ret_&cc = ret_l                     ;; define ret_<CC> to be ret_l
endm
.xcref  condret

BREAK <RETZ - return if zero, links up shortwise if necessary>

retz    macro
    condret z,nz
endm
.xcref  retz

BREAK <RETNZ - return if not zero, links up shortwise if necessary>

retnz   macro
    condret nz,z
endm
.xcref  retnz

BREAK <RETC - return if carry set, links up shortwise if necessary>

retc    macro
    condret c,nc
endm
.xcref  retc

BREAK <RETNC - return if not carry, links up shortwise if necessary>

retnc   macro
    condret nc,c
endm
.xcref  retnc

BREAK <CONTEXT - set the DOS context to a particular register>

context macro   r
	PUSH    SS
	POP     r
	ASSUME  r:DOSDATA
endm
.xcref  context

BREAK <SaveReg - save a set of registers>

SaveReg MACRO	reglist 		;; push those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth + 1
	PUSH    reg
ENDM
ENDM
.xcref  SaveReg

Save	MACRO	arglist		;; push those arguments
IRP arg,<arglist>
	?stackdepth = ?stackdepth + 1
	PUSH	arg
ENDM
ENDM
.xcref	Save

BREAK <RestoreReg - unsave some registers>

RestoreReg  MACRO   reglist		;; pop those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth - 1
	POP     reg
ENDM
ENDM
.xcref  RestoreReg

Restore MACRO	 arglist		;; pop those arguments
IRP arg,<arglist>
	?stackdepth = ?stackdepth - 1
	POP	arg
ENDM
ENDM
.xcref	Restore

BREAK <Critical section macros>

EnterCrit MACRO section
;        Invoke  E&section
ENDM

LeaveCrit MACRO section
;        Invoke  L&section
ENDM

Break   <message - display a message>

AsmVars <ShareF,Cargs,Redirector>

if debug
fmt     MACRO   typ,lev,fmts,args
local   a,b,c
	PUSHF
IFNB <typ>
	TEST    BugTyp,typ
	JZ      c
	CMP     BugLev,lev
	JB      c
ENDIF
	PUSH    AX
	PUSH    BP
	MOV     BP,SP
If (not sharef) and (not redirector)
DOSDATA segment
a       db      fmts,0
DOSDATA	 ends
	MOV	AX,OFFSET DOSDATA:a
else
	jmp     short b
a       db      fmts,0
if sharef
b:      mov     ax,offset share:a
else
b:      mov     ax,offset netwrk:a
endif
endif
	PUSH    AX
cargs = 2
IRP item,<args>
IFIDN   <AX>,<item>
	push	[bp+2]
     ;	MOV	AX,[BP+2]
ELSE
     ;	MOV	AX,item
	push	item
ENDIF
   ;	PUSH	AX
cargs = cargs + 2
ENDM
	invoke  PFMT
	ADD     SP,Cargs
	POP     BP
	POP     AX
c:
	POPF
ENDM
else
fmt macro
endm
endif

Break   <DOSAssume - validate assumes>

AsmVar  Debug,$temp

;**	DOSAssume - Check that a register addresses DOSSEG
;
;	DOSAssume  reglist, message


IF debug
DOSAssume   Macro   reglist,message
local a,b
    $temp   =	0
    IRP r,<reglist>
	IFIDN <r>,<DS>
	    $temp = $temp OR 2
	ELSE
	    IFIDN <r>,<ES>
		$temp = $temp OR 4
	    ELSE
		IFIDN <r>,<SS>
		    $temp = $temp OR 1
		ELSE
		    %out ***** Invalid register reg in DOSAssume *****
		ENDIF
	    ENDIF
	ENDIF
    ENDM
	Invoke  SegCheck
	jmp	short a
	db	$temp
	db	message,0
a:

    IRP r,<reglist>
	ASSUME	r:DOSDATA
    ENDM
ENDM

ELSE

DOSAssume   Macro   reglist,message
IRP r,<reglist>
    ASSUME  r:DOSDATA
ENDM
ENDM
ENDIF

BREAK   <ASSERT - make assertions about registers>

IF DEBUG
Assert  MACRO   kind, objs, message
	LOCAL   a,b
    IFIDN   <kind>,<Z>
	CMP     objs,0
	JZ      a
	fmt <>,<>,<message>
a:
    ELSE
	IFIDN   <kind>,<NZ>
	CMP     objs,0
	JNZ     a
	fmt <>,<>,<message>
a:
	ELSE
    PUSH    AX
	    IRP obj,<objs>
	PUSH    obj
	    ENDM
	    IF SHAREF
    MOV     AX,OFFSET b
	    ELSE
    MOV     AX,OFFSET DOSDATA:b
	    ENDIF
    PUSH    AX
	    IFIDN   <kind>,<ISBUF>
	Invoke  BUFCheck
	    ENDIF
	    IFIDN   <kind>,<ISSFT>
	Invoke  SFTCheck
	    ENDIF
	    IFIDN   <kind>,<ISDPB>
	Invoke  DPBCheck
	    ENDIF
    POP     AX
	    IF SHAREF
    JMP SHORT a
b   DB  Message,0
a:
	    ELSE
DOSDATA	 segment
b   db  Message,0
DOSDATA	 ends
	    ENDIF
	ENDIF
    ENDIF
ENDM
ELSE
Assert  Macro
ENDM
ENDIF

Break   <CallInstall - hook to installable pieces>

CallInstall MACRO   name,mpx,fn,save,restore
IF Installed
    IFNB    <save>
	SaveReg <save>
    ENDIF
	MOV     AX,(mpx SHL 8) + fn
	INT     2Fh
    IFNB    <restore>
	RestoreReg  <restore>
    ENDIF
ELSE
	Invoke  name
ENDIF
ENDM

Break   <Stack frame manipulators>

localvar    macro   name,length
local   a
	ifidn   <length>,<BYTE>
	    ?frame =  ?frame + 1
	    a = ?frame
	    name EQU  BYTE PTR [BP-a]
	else
	    ifidn   <length>,<WORD>
		?frame =  ?frame + 2
		a = ?frame
		name EQU  WORD PTR [BP-a]
	    else
		ifidn   <length>,<DWORD>
		    ?frame =  ?frame + 4
		    a = ?frame
		    name EQU  DWORD PTR [BP-a]
		    name&l EQU  WORD PTR [BP-a]
		    name&h EQU  WORD PTR [BP-a+2]
		else
		    ?frame =  ?frame + length
		    a = ?frame
		    name EQU  BYTE PTR [BP-a]
		endif
	    endif
	endif
endm

enter   macro
	push    bp
	mov     bp,sp
	sub     sp,?frame
endm

leave   macro
	mov     sp,bp
	pop     bp
endm

Argvar  macro   name,length
local   a
	ifidn   <length>,<BYTE>
	    a = ?aframe
	    ?aframe =  ?aframe + 1
	    name EQU  BYTE PTR [BP+a]
	else
	    ifidn   <length>,<WORD>
		a = ?aframe
		?aframe =  ?aframe + 2
		name EQU  WORD PTR [BP+a]
	    else
		ifidn   <length>,<DWORD>
		    a = ?aframe
		    ?aframe =  ?aframe + 4
		    name EQU  DWORD PTR [BP+a]
		    name&l EQU  WORD PTR [BP+a]
		    name&h EQU  WORD PTR [BP+a+2]
		else
		    a = ?aframe
		    ?aframe =  ?aframe + length
		    name EQU  BYTE PTR [BP+a]
		endif
	    endif
	endif
endm


save_world 	macro

	push	es
	invoke	save_user_world

endm

restore_world	macro

	invoke	restore_user_world
	pop	es

endm

;
; This macro gets the DOS data segment value and puts it in the specified
; segment register.  This can only be used in the DOSCODE segment.
;

getdseg	macro 	r

	mov	r, cs:[DosDseg]
	assume	r:dosdata
endm

;
; This macro does the necessary extrns to allow use of the getdseg macro.
;
allow_getdseg macro

ifdef ROMDOS
	extrn	BioDataSeg:word
	bdata	segment at 70H
	extrn	DosDataSg:word
	bdata	ends
else
	extrn	DosDseg:word
endif

endm



BREAK <LJcc - Long Conditional Jumps>

LJE macro l
 LJ JE JNE l
endm

LJNE macro l
 LJ jne JE l
endm

LJZ macro l
 LJE l
endm

LJNZ macro l
 LJNE l
endm

LJC macro l
 LJ jc JNC l
endm

LJNC macro l
 LJ jnc JC l
endm

LJA macro l
 LJ ja JNA l
endm

LJNA macro l
 LJ jna JA l
endm

LJB macro l
 LJ jb JNB l
endm

LJNB macro l
 LJ jnb JB l
endm

LJS macro l
 LJ js JNS l
endm

LJNS macro l
 LJ jns JS l
endm

LJAE macro l
 LJ jae JNAE l
endm

LJBE macro l
 LJ jbe JNBE l
endm

LJL macro l
 LJ jl JNL l
endm

LJG macro l
 LJ jg JNG l
endm

LJLE macro l
 LJ jle JNLE l
endm

DLJE macro l
 DLJ JE JNE l
endm

DLJNE macro l
 DLJ jne JE l
endm

DLJZ macro l
 DLJE l
endm

DLJNZ macro l
 DLJNE l
endm

DLJC macro l
 DLJ jc JNC l
endm

DLJNC macro l
 DLJ jnc JC l
endm

DLJA macro l
 DLJ ja JNA l
endm

DLJNA macro l
 DLJ jna JA l
endm

DLJB macro l
 DLJ jb JNB l
endm

DLJNB macro l
 DLJ jnb JB l
endm

DLJS macro l
 DLJ js JNS l
endm

DLJNS macro l
 DLJ jns JS l
endm

DLJAE macro l
 DLJ jae JNAE l
endm

DLJBE macro l
 DLJ jbe JNBE l
endm

DLJG macro l
 DLJ jg JNG l
endm

DLJL macro l
 DLJ jl JNL l
endm

DLJLE macro l
 DLJ jle JNLE l
endm


;*	LJ - generate long conditional jump
;
;	if target preceeds us and is in range just use a short jump
;	else use a long jump
;
;	LJ <direct jmp>,<skip jmp>,<label>

LJ MACRO dirop,idirop,l
 local a
 IF ((.TYPE l) XOR 20h) AND 0A0h
  idirop a			       ;; not defined or is external
  jmp l
a:
 ELSE				       ;; is local definied
  IF (($-l) LT 124) AND ($ GT l)
   dirop l			      ;; is before and within range
  ELSE
   idirop a			      ;; is out of range or forward (pass 2)
   jmp l
a:
  ENDIF
 ENDIF
ENDM


;*	DLJ - generate debug long conditional jump
;
;	If DEBUG is defined then we generate a long jump, else a short
;	one.
;
;	DLJ <direct jmp>,<skip jmp>,<label>

DLJ MACRO dirop,idirop,l
 local a
 IF DEBUG
  idirop a
  jmp l
a:
 ELSE
  dirop l
 ENDIF
ENDM

.xcref	LJE, LJNE, LJZ, LJNZ, LJC, LJNC, LJA, LJNA
.xcref	LJB, LJNB, LJS, LJNS, LJAE, LJBE, LJG, LJL, LJLE
.xcref	DLJE, DLJNE, DLJZ, DLJNZ, DLJC, DLJNC, DLJA, DLJNA
.xcref	DLJB, DLJNB, DLJS, DLJNS, DLJAE, DLJBE, DLJG, DLJL, DLJLE
.xcref	LJ,DLJ



;**	SHORT offset macro
;
;	expands to SHORT if non debug, to nul if debug.
;
;	this allows us to code
;
;		jmp	SHRT foobar
;
;	and get a long form if debugging is turned on (because the extra
;	debug code puts the target out of range)

if DEBUG
  SHRT	EQU	<>
else
  SHRT	EQU	SHORT
endif


;**	FALLTHRU - Verifies Fallthrough Validity

FALLTHRU MACRO	labl
;	BUGBUG - restore align when we make code segment word aligned
;	align	2		; don't have errnz fail due to alignment
    IF2 			; of following label
	.errnz	labl-$
    ENDIF
	ENDM


;**	INTTEST - Generate an INT 3 for testing

INTTEST MACRO
if DEBUG
	int	3
endif
	ENDM


;**	DPUBLIC - Make a public symbol for debugging

DPUBLIC MACRO	arg
if DEBUG
	public	arg
endif
	ENDM

;*	Debug Traps
;
;	These are removed as the code is exercised

TRAP	macro			; Like INTTEST but is normally left in during
	int	3		; debugging; indicates "should not occur"
	ENDM

TRAPC	macro
	local	l
	jnc	short l
	int	3
l:
	ENDM

TRAPNC	macro
	local	l
	jc	short l
	int	3
l:
	ENDM

TRAPA	macro
	local	l
	jna	short l
	int	3
l:
	ENDM

TRAPNA	macro
	local	l
	ja	short l
	int	3
l:
	ENDM

TRAPZ	macro
	local	l
	jnz	short l
	int	3
l:
	ENDM

TRAPNZ	macro
	local	l
	jz	short l
	int	3
l:
	ENDM



	BREAK	<Structure Field Macros>


;**	Follows - Verify that a field follows another
;
;	FOLLOWS field1, field2 [, size]
;
;	This macro generates an error if "field1" doesn't immeidately
;	follow "field2".  If "size" is specified then an error is generated
;	if Field1 is not of the proper size.

FOLLOWS macro	field1, field2, fldsiz
	.errnz	field1 - size field2 - field2
IFNB	<fldsiz>
	.errnz	size field1 - fldsiz
ENDIF
	ENDM



;**	LAST - Verify that a field is the last field in a structure
;
;	LAST	fieldname, structname
;
;	Generates an error if fieldname is not last in structname.

LAST	macro	fldnam, strunam
	.errnz	size strunam - fldnam - size fldnam
	endm



;**	TESTB - Use Byte form for Word TESTS, when possible
;
;	TESTB is used in place of 16-bit TEST instructions.  It substitutes
;	a smaller 8-bit test when possible.

TESTB	macro	targ,mask,thirdarg
	local	mask2,delta

ifnb <thirdarg>
	.err	mask must be enclosed in brackets
endif

ifidn <targ>,<[bx]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[si]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[di]>		; don't process these operands specially
	test	targ,mask
	exitm
endif
ifidn <targ>,<[BX]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[SI]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[DI]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<SI>
	test	targ,mask
	exitm
endif
ifidn <targ>,<DI>
	test	targ,mask
	exitm
endif
ifidn <targ>,<BP>
	test	targ,mask
	exitm
endif
delta	=	0
mask2	=	mask

    if	mask2 AND 0ff00h
;	have a mask bit in the high half
	if mask2 AND 0ffh
	    test targ,mask
	    exitm
	endif
	mask2 = mask2 SHR 8
	delta = 1
    endif

ifidn <targ>,<AX>
	if delta
	    test targ,mask
	else
	    test AL,mask2
	endif
	exitm
endif
ifidn <targ>,<BX>
	if delta
	  test	BH,mask2
	else
	  test	BL,mask2
	endif
	exitm
endif
ifidn <targ>,<CX>
	if delta
	  test	CH,mask2
	else
	  test	CL,mask2
	endif
	exitm
endif
ifidn <targ>,<DX>
	if delta
	  test	DH,mask2
	else
	  test	DL,mask2
	endif
	exitm
endif
ifidn <targ>,<ax>
	if delta
	    test targ,mask
	else
	    test AL,mask2
	endif
	exitm
endif
ifidn <targ>,<bx>
	if delta
	  test	BH,mask2
	else
	  test	BL,mask2
	endif
	exitm
endif
ifidn <targ>,<cx>
	if delta
	  test	CH,mask2
	else
	  test	CL,mask2
	endif
	exitm
endif
ifidn <targ>,<dx>
	if delta
	  test	DH,mask2
	else
	  test	DL,mask2
	endif
	exitm
endif

	test	byte ptr targ+delta,mask2
	endm


;
; Some old versions of the 80286 have a bug in the chip.  The popf
; instruction will enable interrupts.  Therefore in a section of code with
; interrupts disabled and you need a popf instruction use the 'popff'
; macro instead.
;

POPFF	macro
	jmp	$+3
	iret
	push	cs
	call	$-2
	endm

Break   <Cmp32 - 32-bit compare>
;----------------------------------------------------------------------------
;
; Macro Name : Cmp32
;
; Inputs:
;       msw1 -- 1st operand, most  significant word; MUST BE REGISTER.
;       lsw1 -- 1st operand, least significant word; MUST BE REGISTER.
;       msw2 -- 2nd operand, most  significant word.
;       lsw2 -- 2nd operand, least significant word.
; Function:
;       Compare 2 32-bit operands.  Implemented as a macro.
; Outputs:
;       CF = 1 if 1st operand <  2nd operand
;          = 0 if 1st operand >= 2nd operand
;	ZF = 1 if 1st operand == 2nd operand
;          = 0 if 1st operand <> 2nd operand
;-----------------------------------------------------------------------------
;M019: Created.

Cmp32   MACRO   msw1,lsw1,msw2,lsw2
        LOCAL   cmp32x

        cmp     msw1,msw2
        jne     cmp32x
        cmp     lsw1,lsw2
cmp32x:
	ENDM

Break	<HRDSVC - SVC call where hard error is possible>
;----------------------------------------------------------------------------
;
; Macro Name : HRDSVC
;
; Inputs:
;	iSVC -- SVC index
; Function:
;	Make a DEM SVC. If hard error happens handle it.
; Outputs:
;	CF = 1 if operation failed
;	   = 0 if operation successful
;-----------------------------------------------------------------------------

HRDSVC	MACRO	iSVC
	LOCAL	hs_nerr,hs_fail,hs_retry

	SVC	iSVC
	jnc	hs_nerr

	; Check if hard err to be handled . If no harderr then it
	; will come back without effecting any reg or carry flags.
	; Else it will do an int24. If user chooses retry it
	; will retry the SVC call. On fail or abort it will
	; come back with usual dos style setup.
	; If user chose "Abort" it wont come back

	invoke	TestHrdErr
hs_nerr:
        ENDM

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\dosseg.inc ===
;**	segment ordering for MSDOS
;
;

; There are just two (real) segments, DOSCODE and DOSDATA.
; All the initialization and startup code in in the
; DOSCODE segment.
;


DOSCODE		SEGMENT	BYTE PUBLIC 'CODE'
DOSCODE		ENDS

DUM		SEGMENT	PARA PUBLIC 'DUM'
DUM		ENDS

DOSDATA		SEGMENT	WORD PUBLIC 'DATA'
DOSDATA		ENDS

DOSDATALAST	SEGMENT	WORD PUBLIC 'DATA'
DOSDATALAST	ENDS

DOSGRP		GROUP DOSDATA,DOSDATALAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\dpl.asm ===
;	SCCSID = @(#)dpl.asm	1.1 85/04/10
;	SCCSID = @(#)dpl.asm	1.1 85/04/10
DPL	STRUC
DPL_AX	DW	?	; AX register
DPL_BX	DW	?	; BX register
DPL_CX	DW	?	; CX register
DPL_DX	DW	?	; DX register
DPL_SI	DW	?	; SI register
DPL_DI	DW	?	; DI register
DPL_DS	DW	?	; DS register
DPL_ES	DW	?	; ES register
DPL_reserved DW ?	; Reserved
DPL_UID DW	?	; User (Machine) ID (0 = local macine)
DPL_PID DW	?	; Process ID (0 = local user PID)
DPL	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\dpb.inc ===
BREAK <DPB structure>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	DPB - Drive Parameter Block
;
;	BUGBUG - this isn't authorative - it's my probably incomplete and
;	possibly inaccurate deductions from code study... - jgl
;
;	The DPB is DOS's main structure for describing block devices.
;	It contains info about the "Drive" intermingled with info about
;	the FAT file system which is presumably on the drive.  I don't know
;	how those fields are used if it's not the FAT file system - BUGBUG
;
;	The DPBs are statically allocated and chained off of DPBHead.
;	Users scan this chain looking for a match on DPB_DRIVE.
;	The DPBs are built at init time from info in the SYSDEV structure.


DPB	STRUC

DPB_DRIVE	    DB	?	; Logical drive # assoc with DPB (A=0,B=1,...)
DPB_UNIT	    DB	?	; Driver unit number of DPB
DPB_SECTOR_SIZE     DW	?	; Size of physical sector in bytes
DPB_CLUSTER_MASK    DB	?	; Sectors/cluster - 1
DPB_CLUSTER_SHIFT   DB	?	; Log2 of sectors/cluster
DPB_FIRST_FAT	    DW	?	; Starting record of FATs
DPB_FAT_COUNT	    DB	?	; Number of FATs for this drive
DPB_ROOT_ENTRIES    DW	?	; Number of directory entries
DPB_FIRST_SECTOR    DW	?	; First sector of first cluster
DPB_MAX_CLUSTER     DW	?	; Number of clusters on drive + 1
DPB_FAT_SIZE	    DW	?	; Number of records occupied by FAT
DPB_DIR_SECTOR	    DW	?	; Starting record of directory
DPB_DRIVER_ADDR     DD	?	; Pointer to driver
DPB_MEDIA	    DB	?	; Media byte
DPB_FIRST_ACCESS    DB	?	; This is initialized to -1 to force a media
				;   check the first time this DPB is used
DPB_NEXT_DPB	    DD	?	; Pointer to next Drive parameter block
DPB_NEXT_FREE	    DW	?	; Cluster # of last allocated cluster
DPB_FREE_CNT	    DW	?	; Count of free clusters, -1 if unknown

DPB	ENDS

DPBSIZ	EQU	SIZE DPB	; Size of the structure in bytes

DSKSIZ	=	DPB_max_CLUSTER ; Size of disk (temp used during init only)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\ea.inc ===
;Get/Set Extended Attrbute Equates

;The following equates are for EA types

EAISUNDEF	      equ  00H	     ; undefined
EAISLOGICAL	      equ  01H	     ; logical (0 or 1), 1 byte
EAISBINARY	      equ  02H	     ; binary integer 1, 2, or 4 bytes
EAISASCII	      equ  03H	     ; ASCII , 0 to 128 bytes
EAISDATE	      equ  04H	     ; DOS file date format, 2 bytes
EAISTIME	      equ  05H	     ; DOS file time format, 2 bytes

;The following equates are for EA flags

EASYSTEM	      equ  8000H     ; system defined, bultin
EAREADONLY	      equ  4000H     ; read-only , cannot be changed
EAHIDDEN	      equ  2000H     ; hidden from ATTRIB
EACREATEONLY	      equ  1000H     ; settable only at create time

;The following equates are for EA failure reason code (set by DOS)

EARCSUCCESS	      equ  00H	     ; success
EARCNOTFOUND	      equ  01H	     ; name not found
EARCNOSPACE	      equ  02H	     ; no space to hold name or value
EARCNOTNOW	      equ  03H	     ; name can't be set on this function
EARCNOTEVER	      equ  04H	     ; name can't be set
EARCUNDEF	      equ  05H	     ; name known to IFS but not supported
EARCDEFBAD	      equ  06H	     ; EA definition bad (type,length, etc)
EARCACCESS	      equ  07H	     ; EA access denied
EARCBADVAL	      equ  08H	     ; bad value
EARCDEVERROR	      equ  09H	     ; device error
EARCUNKNOWN	      equ  0FFFFH    ; unknown cause


;The following equates are for EA file type

EAEXISTING	     equ  00H	    ; existing file
EARTL		     equ  02H	    ; right to left
EAEXECUTABLE	     equ  03H	    ; executable program
EAINSTALLABLE	     equ  04H	    ; installable executable program
EAOVERLAY	     equ  05H	    ; program overlay
EADEV_DRIVER	     equ  06H	    ; device driver
EAIFS_DRIVER	     equ  07H	    ; ifs deriver




By_Create	      equ  0000010B	     ; set by Extended Open (create)
BY_XA		      equ  0000100B	     ; set by Get/Set XA by Handle

;Extended Attribute Structure

EA	    STRUC			      ; extended attribute list
EA_TYPE     DB	      ? 		      ; type
EA_FLAGS    DW	      ? 		      ; flags
EA_RC	    DB	      ? 		      ; reason code
EA_NAMELEN  DB	      ? 		      ; name length
EA_VALLEN   DW	      ? 		      ; value length
EA_NAME     DB	      ? 		      ; name
EA	    ENDS


;Query Extended Attribute list

QEA	     STRUC			       ; extended attribute list
QEA_TYPE     DB        ?		       ; type
QEA_FLAGS    DW        ?		       ; flags
QEA_NAMELEN  DB        ?		       ; name length
QEA_NAME     DB        ?		       ; name
QEA	     ENDS


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\dseg.inc ===
;---Revised 8-17-84 FOR KBX	(ADDED ADDITIONAL KEYBOARD FLAG - KB_FLAG_3)
;----------------------------------------
;	 0286 INTERRUPT LOCATIONS (READ):
;----------------------------------------
ABS0	SEGMENT AT 0
STG_LOC0		LABEL	BYTE
	ORG 2*4
NMI_PTR 		LABEL	WORD
	ORG 5*4
INT5_PTR		LABEL	WORD
	ORG 8*4
INT_ADDR		LABEL	WORD
INT_PTR 		LABEL	DWORD
	ORG 10H*4
VIDEO_INT		LABEL	WORD
	ORG 13H*4			; NEW FDISK
ORG_VECTOR		LABEL	DWORD
	ORG 18H*4
BASIC_PTR		LABEL	WORD
	ORG 19H*4
BOOT_VEC		LABEL	DWORD
BOOT_VECTOR		LABEL	DWORD
	ORG 1DH*4
PARM_PTR		LABEL	DWORD	; POINTER TO VIDEO PARMS
	ORG 1EH*4
DISK_POINTER		LABEL	DWORD
	ORG 01FH*4
EXT_PTR 		LABEL	DWORD
	ORG 40H*4			; DISKETTE POINTER
DISK_VECTOR		LABEL	DWORD
       ORG 41H*4
HF_TBL_VEC		LABEL	DWORD
	ORG 46H*4
HF1_TBL_VEC		LABEL	DWORD
	ORG 70H*4
SLAVE_INT_PTR		LABEL	DWORD
RTC_INT_VEC		LABEL	DWORD	; REAL TIME CLOCK INT
	ORG 76H*4			; FIXED DISK INTERRUPT VECTOR
HDISK_INT		LABEL	DWORD
	ORG	400H
DATA_AREA		 LABEL BYTE	;ABSOLUTE LOCATION OF DATA SEGMENT
DATA_WORD		 LABEL WORD
	ORG	0500H
MFG_TEST_RTN		 LABEL	FAR
	ORG	7C00H
BOOT_LOCN		 LABEL	FAR
ABS0	ENDS
PAGE
;------------------------------------------------
; STACK -- USED DURING INITIALIZATION ONLY	:
;------------------------------------------------
STACK	SEGMENT AT 30H
	DW	128 DUP(?)
TOS	LABEL	WORD
STACK	ENDS
;----------------------------------------
;	ROM BIOS DATA AREAS		:
;----------------------------------------
DATA	SEGMENT AT 40H
;DATA_BASE	 LABEL	 BYTE
RS232_BASE	DW	4 DUP(?)	; ADDRESSES OF RS232 ADAPTERS
PRINTER_BASE	DW	4 DUP(?)	; ADDRESSES OF PRINTERS
EQUIP_FLAG	DW	1 DUP(?)	; INSTALLED HARDWARE
MFG_TST 	DB	1 DUP(?)	; INITIALIZATION FLAG
MEMORY_SIZE	DW	1 DUP(?)	; MEMORY SIZE IN K BYTES
MFG_ERR_FLAG	DB	1 DUP(?)	; SCRATCHPAD FOR MANUFACTURING
		DB	1 DUP(?)	; ERROR CODES
PAGE
;----------------------------------------
;	KEYBOARD DATA AREAS		:
;----------------------------------------
KB_FLAG 	DB	1 DUP(?)
KB_FLAG_1	DB	1 DUP(?)	; SECOND BYTE OF KEYBOARD STATUS
ALT_INPUT	DB	1 DUP(?)	; STORAGE FOR ALTERNATE KEYPAD ENTRY
BUFFER_HEAD	DW	1 DUP(?)	; POINTER TO HEAD OF KEYBOARD BUFFER
BUFFER_TAIL	DW	1 DUP(?)	; POINTER TO TAIL OF KEYBOARD BUFFER
KB_BUFFER	DW	16 DUP(?)	; ROOM FOR 15 ENTRIES
KB_BUFFER_END	LABEL	WORD

;------ HEAD = TAIL INDICATES THAT THE BUFFER IS EMPTY

;----------------------------------------
;	DISKETTE DATA AREAS		:
;----------------------------------------
SEEK_STATUS	DB	1 DUP(?)	; DRIVE RECALIBRATION STATUS
					; BIT 3-0 = DRIVE 3-0 NEEDS RECAL
					; BEFORE NEXT SEEK IF BIT IS = 0
MOTOR_STATUS	DB	1 DUP(?)	; MOTOR STATUS
					; BIT 3-0 = DRIVE 3-0 IS CURRENTLY
					;   RUNNING
					; BIT 7 = CURRENT OPERATION IS A WRITE,
					;   REQUIRES DELAY
MOTOR_COUNT	DB	1 DUP(?)	; TIME OUT COUNTER FOR DRIVE TURN OFF
DISKETTE_STATUS DB	1 DUP(?)	; RETURN CODE STATUS BYTE
CMD_BLOCK	LABEL	BYTE
HD_ERROR	LABEL	BYTE
NEC_STATUS	DB	7 DUP(?)	; STATUS BYTES FROM NEC
PAGE
;----------------------------------------
;	VIDEO DISPLAY DATA AREA 	:
;----------------------------------------
CRT_MODE	DB	1 DUP(?)	; CURRENT CRT MODE
CRT_COLS	DW	1 DUP(?)	; NUMBER OF COLUMNS ON SCREEN
CRT_LEN 	DW	1 DUP(?)	; LENGTH OF REGEN IN BYTES
CRT_START	DW	1 DUP(?)	; STARTING ADDRESS IN REGEN BUFFER
CURSOR_POSN	DW	8 DUP(?)	; CURSOR FOR EACH OF UP TO 8 PAGES
CURSOR_MODE	DW	1 DUP(?)	; CURRENT CURSOR MODE SETTING
ACTIVE_PAGE	DB	1 DUP(?)	; CURRENT PAGE BEING DISPLAYED
ADDR_6845	DW	1 DUP(?)	; BASE ADDRESS FOR ACTIVE DISPLAY CARD
CRT_MODE_SET	DB	1 DUP(?)	; CURRENT SETTING OF THE 3X8 REGISTER
CRT_PALLETTE	DB	1 DUP(?)	; CURRENT PALLETTE SETTING COLOR CARD
PAGE
;----------------------------------------
;	POST DATA AREA			:
;----------------------------------------
IO_ROM_INIT	DW	1 DUP(?)	; PNTR TO OPTIONAL I/O ROM INIT ROUTINE
IO_ROM_SEG	DW	1 DUP(?)	; POINTER TO IO ROM SEGMENT
INTR_FLAG	DB	1 DUP(?)	; FLAG TO INDICATE AN INTERRUPT HAPPEND
;----------------------------------------
;	TIMER DATA AREA 		:
;----------------------------------------
TIMER_LOW	DW	1 DUP(?)	; LOW WORD OF TIMER COUNT
TIMER_HIGH	DW	1 DUP(?)	; HIGH WORD OF TIMER COUNT
TIMER_OFL	DB	1 DUP(?)	; TIMER HAS ROLLED OVER SINCE LAST READ
;----------------------------------------
;	SYSTEM DATA AREA		:
;----------------------------------------
BIOS_BREAK	DB	1 DUP(?)	; BIT 7=1 IF BREAK KEY HAS BEEN HIT
RESET_FLAG	DW	1 DUP(?)	; WORD=1234H IF KEYBOARD RESET UNDERWAY
PAGE
;----------------------------------------
;	HARD FILE DATA AREAS		:
;----------------------------------------
DISK_STATUS1	DB	1 DUP(?)
HF_NUM		DB	1 DUP(?)
CONTROL_BYTE	DB	1 DUP(?)
PORT_OFF	DB	1 DUP(?)
;------------------------------------------------------
;	PRINTER AND RS232 TIME-OUT VARIABLES	      :
;------------------------------------------------------
PRINT_TIM_OUT	DB	4 DUP(?)
RS232_TIM_OUT	DB	4 DUP(?)
;----------------------------------------
;	ADDITIONAL KEYBOARD DATA AREA	:
;----------------------------------------
BUFFER_START	DW	1 DUP(?)
BUFFER_END	DW	1 DUP(?)
;---------------------------------------
;	ADDITIONAL FLOPPY DATA	       ;
;---------------------------------------
	ORG	8BH
LASTRATE	DB	1 DUP(?)	; LAST DATA RATE SELECTED
PAGE
;---------------------------------------
;	ADDITIONAL HARD FILE DATA      :
;---------------------------------------
	ORG	8CH
HF_STATUS	DB	1 DUP(?)	; STATUS REGISTER
HF_ERROR	DB	1 DUP(?)	; ERROR REGISTER
HF_INT_FLAG	DB	1 DUP(?)	; HARD FILE INTERRUPT FLAG
HF_CNTRL	DB	1 DUP(?)	; COMBO HARD FILE/FLOPPY CARD BIT 0=1
;----------------------------------------
;	ADDITIONAL DISKETTE AREA       :
;----------------------------------------
	ORG	90H
DSK_STATE	LABEL	BYTE
		DB	1 DUP(?)	; DRIVE 0 MEDIA STATE
		DB	1 DUP(?)	; DRIVE 1 MEDIA STATE
		DB	1 DUP(?)	; DRIVE 0 OPERATION START STATE
		DB	1 DUP(?)	; DRIVE 1 OPERATION START STATE
DSK_TRK 	DB	1 DUP(?)	; DRIVE 0 PRESENT CYLINDER
		DB	1 DUP(?)	; DRIVE 1 PRESENT CYLINDER
		DB	1 DUP(?)	; RESERVED
;----------------------------------------				AEV
;	ADDITIONAL KEYBOARD FLAG FOR KBX:				AEV
;----------------------------------------				AEV
	ORG	96H			;				AEV
KB_FLAG_3	DB	1 DUP(?)	;				AEV
;----------------------------------------
;	ADDITIONAL KEYBOARD LED FLAG	:
;----------------------------------------
	ORG	97H
KB_FLAG_2	DB	1 DUP(?)
PAGE
;----------------------------------------
;	REAL TIME CLOCK DATA AREA	:
;----------------------------------------
	ORG	98H
USER_FLAG	DW	1 DUP(?)	; OFFSET ADDR OF USERS WAIT FLAG
USER_FLAG_SEG	DW	1 DUP(?)	; SEG ADDR OF USER WAIT FLAG
RTC_LOW 	DW	1 DUP(?)	; LOW WORD OF USER WAIT FLAG
RTC_HIGH	DW	1 DUP(?)	; HIGH WORD OF USER WAIT FLAG
RTC_WAIT_FLAG	DB	1 DUP(?)	; WAIT ACTIVE FLAG
DATA	ENDS
;----------------------------------------
;	EXTRA DATA AREA 		:
;----------------------------------------
XXDATA	SEGMENT AT 50H
STATUS_BYTE	DB	1 DUP(?)
XXDATA	ENDS
;----------------------------------------
;	VIDEO DISPLAY BUFFER		:
;----------------------------------------
VIDEO_RAM	SEGMENT AT 0B800H
REGEN	LABEL	BYTE
REGENW	LABEL	WORD
	DB	16384 DUP(?)
VIDEO_RAM	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\dossym.inc ===
;	PAGE 80,132
	.xall

; Revision History:
;	
;	M003	- added A20OFF_FLAG for MS PASCAL 3.2 compatibility support
;		  for DOS5.X running in HMA. 
;
;	M004	- added bit definition SETSSSP for DOS_FLAG for supporting
;		  exe files without stack segment. 
;		  This is no longer needed as we modify SP only. Removing 
;		  this equate. 9/26/90
;
;       M009	- addded comments relating to mace mkeyrate ver 1.0 support 
;		  with DOS in HMA.
;
;	M025	- Added SWITCHES=/W for suppressing mandatory loading
;		  of WINA20.386
;
;	M027	- Support for copy protected apps. Defined bit 2 of DOS_FLAG
;	

TRUE	    EQU 0FFFFh
FALSE	    EQU 0

Installed   = TRUE
IFNDEF	DEBUG
    DEBUG	= FALSE
ENDIF

include dbcs.sw
include dosmac.INC
include VERSIONA.INC
include VERSION.INC


BREAK <Control character definitions>

c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
c_BS	    EQU     08h 		; ^H ASCII backspace
c_CR	    EQU     0Dh 		; ^M ASCII carriage return
c_LF	    EQU     0Ah 		; ^J ASCII linefeed
c_ETB	    EQU     17h 		; ^W ASCII end of transmission
c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
c_ETX	    EQU     03h 		; ^C ASCII end of text
c_HT	    EQU     09h 		; ^I ASCII tab

BREAK <Read This and Weep>

include buffer.INC

BREAK <User stack inside of system call and SysVars>
; Location of user registers relative user stack pointer

user_environ	STRUC
user_AX     DW	    ?			; 00 hex offsets to
user_BX     DW	    ?			; 02	 facilitate debugging
user_CX     DW	    ?			; 04
user_DX     DW	    ?			; 06
user_SI     DW	    ?			; 08
user_DI     DW	    ?			; 0A
user_BP     DW	    ?			; 0C
user_DS     DW	    ?			; 0E
user_ES     DW	    ?			; 10
user_IP     DW	    ?			; 12
user_CS     DW	    ?			; 14
user_F	    DW	    ?			; 16
user_environ	ENDS


	BREAK <Disk map>

;	MSDOS partitions the disk into 4 sections:
;
;  phys sector 0:   +-------------------+
;	|	    | boot/reserved	|
;	|	    +-------------------+
;	|	    |  File allocation	|
;	v	    |	   table(s)	|
;		    |  (multiple copies |
;		    |	  are kept)	|
;		    +-------------------+
;		    |	  Directory	|
;		    +-------------------+
;		    |	  File space	|
;		    +-------------------+
;		    |	Unaddressable	|
;		    |  (to end of disk) |
;		    +-------------------+
;
; All partition boundaries are sector boundaries.  The size of the FAT is
; adjusted to maximize the file space addressable.

include dirent.INC

BREAK <File allocation Table information>
;
; The File Allocation Table uses a 12-bit entry for each allocation unit on
; the disk.  These entries are packed, two for every three bytes.  The contents
; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
; to the base address of the Allocation Table; 3) fetching the 16-bit word
; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
; number zero is used as an end-of-file trap in the OS and is passed to the
; BIOS to help determine disk format.  Entry 1 is reserved for future use.
; The first available allocation unit is assigned entry number two, and even
; though it is the first, is called cluster 2.	Entries greater than 0FF8H
; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
; are unallocated.  Otherwise, the contents of a FAT entry is the number of
; the next cluster in the file.
;
; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
; do because these clusters show as allocated, but are not part of any
; allocation chain and thus will never be allocated to a file.	A particular
; number is selected so that disk checking programs know what to do (ie.  a
; cluster with entry FF7H which is not in a chain is not an error).




;**	Character Type Flags
;
;	These flags are used in a lookup table indexed by the character code.
;	They're used to quickly classify characters when parsing paths.
;	I think that these are only used to parse FCBs - jgl

FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
FDELIM	equ 2		; is a delimiter
FSPCHK	equ 4		; set if character is not a space or equivalent
FFCB	equ 8		; is valid in an FCB


	include error.INC

;** Bit definitions for DOS_FLAG
;
; Bit 0 - this is set when a $open call is made from $exec. This is used in
;	  $open to indicate to the redirector that this open is being made
;	  by an exec call.
;
; Bit 2
;
; M003, M027:
;
; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
; the HMA. By default DOS will turn A20 OFF before Xferring control to the
; user program in the case of an Exec call. The next call to DOS will turn
; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
; In order to support this we will set Bit 2 of this flag in the DOS exec
; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
; is non zero then A20 will be turned OFF before returning to the user. 
; Bit 2 will be unconditionally cleared here.
;
; M009, M027:
;
; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
; program converted to a com file. Therefore if DOS is loaded high and if 
; this program is loaded below 64K it will blurt out "packed file is corrupt".
; This program does an int 21 ah=49h before executing the buggy execpacked
; code. This int21 call turns a20 on and hence the problem. In $dealloc
; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
; is non zero then A20 will be turned OFF before returning to the user. 
; Bit 2 will be unconditionally cleared here.
;
;
;

EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
SUPPRESS_WINA20	EQU	00000010b	; M025
EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\exe.inc ===
BREAK <EXEC and EXE file structures>

;
;----------------------------------------------------------------------------
;
; M00x : 4b04 implementation
;
;----------------------------------------------------------------------------
;

;**	EXE.INC - Definitions for the EXEC command and EXE files
;
; The following get used as arguments to the EXEC system call.	They indicate
; whether or not the program is executed or whether or not a program header
; gets created.

EXEC_FUNC_NO_EXECUTE	EQU 1		; no execute bit
EXEC_FUNC_OVERLAY	EQU 2		; overlay bit

EXEC0		STRUC
EXEC0_ENVIRON	dw	?		; seg addr of environment
EXEC0_COM_LINE	dd	?		; pointer to asciz command line
EXEC0_5C_FCB	dd	?		; default fcb at 5C
EXEC0_6C_FCB	dd	?		; default fcb at 6C
EXEC0		ENDS

EXEC1		STRUC
EXEC1_ENVIRON	dw	?		; seg addr of environment
EXEC1_COM_LINE	dd	?		; pointer to asciz command line
EXEC1_5C_FCB	dd	?		; default fcb at 5C
EXEC1_6C_FCB	dd	?		; default fcb at 6C
EXEC1_SP	dw	?		; stack pointer of program
EXEC1_SS	dw	?		; stack seg register of program
EXEC1_IP	dw	?		; entry point IP
EXEC1_CS	dw	?		; entry point CS
EXEC1		ENDS

EXEC3		STRUC
EXEC3_LOAD_ADDR DW	?		; seg address of load point
EXEC3_RELOC_FAC DW	?		; relocation factor
EXEC3		ENDS


;**	Exit codes (in upper byte) for terminating programs

EXIT_TERMINATE		EQU	0
EXIT_ABORT		EQU	0
EXIT_CTRL_C		EQU	1
EXIT_HARD_ERROR 	EQU	2
EXIT_KEEP_PROCESS	EQU	3



;**	EXE File Header Description
;

EXE_FILE	STRUC

EXE_SIGNATURE	dw  ?			; must contain 4D5A  (yay zibo!)
EXE_LEN_MOD_512 dw  ?			; low 9 bits of length
EXE_PAGES	dw  ?			; number of 512b pages in file
EXE_RLE_COUNT	dw  ?			; count of reloc entries
EXE_PAR_DIR	dw  ?			; number of paragraphs before image
EXE_MIN_BSS	dw  ?			; minimum number of para of BSS
EXE_MAX_BSS	dw  ?			; max number of para of BSS
EXE_SS		dw  ?			; stack of image
EXE_SP		dw  ?			; SP of image
EXE_CHKSUM	dw  ?			; checksum  of file (ignored)
EXE_IP		dw  ?			; IP of entry
EXE_CS		dw  ?			; CS of entry
EXE_RLE_TABLE	dw  ?			; byte offset of reloc table
EXE_IOV 	dw  ?			; overlay number (0 for root)
EXE_SYM_TAB	dd  ?			; offset of symbol table in file

EXE_FILE	ENDS

EXE_VALID_SIGNATURE	EQU 5A4Dh
EXE_VALID_OLD_SIGNATURE EQU 4D5Ah


;**	EXE file symbol info definitions

SYMBOL_ENTRY	STRUC
SYM_VALUE	dd  ?
SYM_TYPE	dw  ?
SYM_LEN 	db  ?
SYM_NAME	db  255 dup (?)
SYMBOL_ENTRY	ENDS


;
; M00x - BEGIN
;
;**	Data structure passed for ExecReady call

ERStruc		STRUC
 ER_Reserved	dw	?		; reserved, should be zero
 ER_Flags	dw	?
 ER_ProgName	dd	?		; ptr to ASCIIZ str of prog name
 ER_PSP		dw	?		; PSP of the program
 ER_StartAddr	dd	?		; Start CS:IP of the program
 ER_ProgSize	dd	?		; Program size including PSP
ERStruc		ENDS

;** bit fields in ER_Flags

ER_EXE		equ	0001h
ER_OVERLAY	equ	0002h

;
; M00x - END
;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\fastxxxx.inc ===
; Fastxxx equates
FastOpen_ID	   equ	   1
FastSeek_ID	   equ	   2
Fast_yes	   equ	   10000000B	 ; fastxxx flag

;Structure definitions
;
Fasttable_Entry  struc			 ; Fastxxx  Entry pointer in DOS
Fast_Entry_Num	    dw	    2		 ; number of entries
FastOpen_Seek	    dd	    ?		 ; fastopen & fastseek entry address
Fasttable_Entry  ends
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\error.inc ===
BREAK	<DOS error codes>

;**	ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX.	If an error occurred then
;    the carry bit will be set and the error code is in AX.	If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action.	The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.


;	2.0 error codes

error_invalid_function		EQU	1
error_file_not_found		EQU	2
error_path_not_found		EQU	3
error_too_many_open_files	EQU	4
error_access_denied		EQU	5
error_invalid_handle		EQU	6
error_arena_trashed		EQU	7
error_not_enough_memory 	EQU	8
error_invalid_block		EQU	9
error_bad_environment		EQU	10
error_bad_format		EQU	11
error_invalid_access		EQU	12
error_invalid_data		EQU	13
;**** reserved			EQU	14	; *****
error_invalid_drive		EQU	15
error_current_directory 	EQU	16
error_not_same_device		EQU	17
error_no_more_files		EQU	18

;	These are the universal int 24 mappings for the old INT 24 set of errors

error_write_protect		EQU	19
error_bad_unit			EQU	20
error_not_ready 		EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_Seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
error_gen_failure		EQU	31

;	the new 3.0 error codes reported through INT 24

error_sharing_violation 	EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
error_FCB_unavailable		EQU	35
error_sharing_buffer_exceeded	EQU	36
error_Code_Page_Mismatched	EQU	37    ; DOS 4.00 			;AN000;
error_handle_EOF		EQU	38    ; DOS 4.00 			;AN000;
error_handle_Disk_Full		EQU	39    ; DOS 4.00 			;AN000;

;	New OEM network-related errors are 50-79

error_not_supported		EQU	50

error_net_access_denied		EQU	65	;M028

;	End of INT 24 reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

;	New 3.0 network related error codes

error_out_of_structures 	EQU	84
error_Already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter 	EQU	87
error_NET_write_fault		EQU	88
error_sys_comp_not_loaded	EQU	90    ; DOS 4.00				;AN000;




	BREAK <Interrupt 24 error codes>

;**	Int24 Error Codes

error_I24_write_protect 	EQU	0
error_I24_bad_unit		EQU	1
error_I24_not_ready		EQU	2
error_I24_bad_command		EQU	3
error_I24_CRC			EQU	4
error_I24_bad_length		EQU	5
error_I24_Seek			EQU	6
error_I24_not_DOS_disk		EQU	7
error_I24_sector_not_found	EQU	8
error_I24_out_of_paper		EQU	9
error_I24_write_fault		EQU	0Ah
error_I24_read_fault		EQU	0Bh
error_I24_gen_failure		EQU	0Ch
; NOTE: Code 0DH is used by MT-DOS.
error_I24_wrong_disk		EQU	0Fh


;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
;
;	NOTE: ABORT is ALWAYS allowed

Allowed_FAIL			EQU	00001000B
Allowed_RETRY			EQU	00010000B
Allowed_IGNORE			EQU	00100000B

I24_operation			EQU	00000001B	;Z if READ,NZ if Write
I24_area			EQU	00000110B	; 00 if DOS
							; 01 if FAT
							; 10 if root DIR
							; 11 if DATA
I24_class			EQU	10000000B	;Z if DISK, NZ if FAT or char


	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>

;**	The GetExtendedError call takes an error code and returns CLASS,
;	ACTION and LOCUS codes to help programs determine the proper action
;	to take for error codes that they don't explicitly understand.


;	Values for error CLASS

errCLASS_OutRes 	EQU	1	; Out of Resource
errCLASS_TempSit	EQU	2	; Temporary Situation
errCLASS_Auth		EQU	3	; Permission problem
errCLASS_Intrn		EQU	4	; Internal System Error
errCLASS_HrdFail	EQU	5	; Hardware Failure
errCLASS_SysFail	EQU	6	; System Failure
errCLASS_Apperr 	EQU	7	; Application Error
errCLASS_NotFnd 	EQU	8	; Not Found
errCLASS_BadFmt 	EQU	9	; Bad Format
errCLASS_Locked 	EQU	10	; Locked
errCLASS_Media		EQU	11	; Media Failure
errCLASS_Already	EQU	12	; Collision with Existing Item
errCLASS_Unk		EQU	13	; Unknown/other

;	Values for error ACTION

errACT_Retry		EQU	1	; Retry
errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
errACT_User		EQU	3	; Ask user to regive info
errACT_Abort		EQU	4	; abort with clean up
errACT_Panic		EQU	5	; abort immediately
errACT_Ignore		EQU	6	; ignore
errACT_IntRet		EQU	7	; Retry after User Intervention

;	Values for error LOCUS

errLOC_Unk		EQU	1	; No appropriate value
errLOC_Disk		EQU	2	; Random Access Mass Storage
errLOC_Net		EQU	3	; Network
errLOC_SerDev		EQU	4	; Serial Device
errLOC_Mem		EQU	5	; Memory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\fastopen.inc ===
;
; EXPORT DATE: 9/11
;Equates for FASTOPEN.

;FASTOPEN NAME CACHING Subfunctions
FONC_Look_up	equ	1
FONC_insert	equ	2
FONC_delete	equ	3
FONC_update	equ	4
FONC_purge	equ	5		;reserved for the future use.
FONC_Rename	equ	6		;AN001

;FASTOPEN EXTENT  CACHING Subfunctions
FSK_Open       equ     11					       ;AN000;
FSK_Close      equ     12					       ;AN000;
FSK_Delete     equ     13					       ;AN000;
FSK_Lookup     equ     14					       ;AN000;
FSK_Insert     equ     15					       ;AN000;
FSK_Trunc      equ     16					       ;AN000;

HeaderSize     equ    8        ; size of file header (8 bytes)	       ;AN000;
ExtendSize     equ    8        ; size of extend (8 bytes)	       ;AN000;
Num_Of_Pages   equ    1        ; number of pages		       ;AN000;
Num_Of_Segs    equ    2        ; number of frame segments	       ;AN000;
Stayresident  equ    04ch     ; terminate and stay resident function code


;Equates used in DOS.
FastOpen_Set	       equ     00000001B
FastOpen_Reset	       equ     11111110B
Lookup_Success	       equ     00000010B
Lookup_Reset	       equ     11111101B
Special_Fill_Set       equ     00000100B
Special_Fill_Reset     equ     11111011B
No_Lookup	       equ     00001000B
Set_For_Search	       equ     00010000B	     ;DCR 167


;============= FastOpen Data Structures =====================

Fastopen_Entry	STRUC			;Fastopen Entry pointer in DOS
Fastopen_Entry_size	dw	4	;size of the following
Fastopen_Name_Caching	dd	?
;Fastopen_FatChain_Caching dd	  ?	;reserved for future use
Fastopen_Entry	ENDS
;


CMPCT_DIR_INFO	STRUC			;compact version of Dir Info.
CDI_file_name	db	11 dup (' ')
CDI_file_attr	db	?
CDI_codepage	dw	?
CDI_extcluster	dw	?
CDI_attr2	db	?
CDI_time	dw	?
CDI_date	dw	?
CDI_cluster	dw	?
CDI_filesize	dd	?
CMPCT_DIR_INFO	ENDS
;

ORIG_DIR_INFO	STRUC
ODI_head	db	17 dup (?)
ODI_skip	db	5  dup (0)	;reserved for DOS. FASTOPEN does not
ODI_tail	db	10 dup (?)	;  use ODI_skip part.
ORIG_DIR_INFO	ENDS
;

ODI_head_leng	equ	17
ODI_skip_leng	equ	5
ODI_tail_leng	equ	10
;

FASTOPEN_EXTENDED_INFO	STRUC
FEI_dirpos	db	0
FEI_dirsec	dd	0
FEI_clusnum	dw	0
FEI_lastent	dw	0		; for search first
FEI_dirstart	dw	0		; for search first
FASTOPEN_EXTENDED_INFO	ENDS
;

NAME_RECORD	STRUC
nLRU_ptr	dw	-1
nMRU_ptr	dw	-1		;reverse of nLRU_ptr
nChild_ptr	dw	-1
nSibling_ptr	dw	-1
nBackward_ptr	dw	-1		;points to preceding node
nCmpct_Dir_Info db	size Cmpct_Dir_Info dup (' ')
nExtended_Info	db	size Fastopen_Extended_Info dup (?)
NAME_RECORD	ENDS
;

DRIVE_CACHE_HEADER	STRUC		;drive cache header
DCH_LRU_ROOT	 dw	 0		;Header of the LRU chain of this drive
DCH_MRU_ROOT	 dw	 0		;offset to the last entry of LRU chain
DCH_Child_ptr	 dw	 -1		;the first child in Name cache seg.
DCH_Sibling_ptr  dw	 -1		;points to the next drive cache header
DCH_Drive_letter db	'C'             ;drive letter
DCH_Num_Entries  dw	 0		;Number of entries in the Name cache.
DCH_Name_Buff	 dw	 0		;pointer to name cahe buffer
DRIVE_CACHE_HEADER	ENDS
;





;======== FAST SEEK FUNCTION  DATA  STRUCTURES =======================

DRIVE_HEADER	STRUC		   ; Drive header structure		;AN000;
Drive_Number	     dw     0	   ; drive number			;AN000;
Extent_Count	     dw     0	   ; reserved for debugging
MRU_Hdr_Ptr	     dw     0	   ; pointer to OPEN Queue
Free_ptr	     dw     0	   ; pointer to FREE buffer		;AN000;
Close_Ptr	     dw     0	   ; pointer to CLOSE Queue	     ;AN000;
Buff_Size	     dw     0	   ; cache buffer size including header ;AN000;
Free_Size	     dw     0	   ; size of Free area in bytes
Next_Drv_Hdr_Ptr     dw     0	   ; pointer to next drive header
DRIVE_HEADER   ENDS



FILE_HEADER	STRUC		   ; File header structure		;AN000;
FH_Phys_Clus_Num     dw     0	   ; starting physcial clustnum of file ;AN000;
FH_Refer_Count	     dw     0	   ; reference count			;AN000;
FH_Next_Extn_Ptr     dw     0	   ; pointer to first extent of the file;AN000;
FH_Next_Hdr_Ptr      dw     0	   ; pointer to next file header	;AN000;
FH_MRU_Extn_Ptr      dw     0	   ; pointer to  MRU extent
		     dw     0
		     dw     0
		     dw     0
FILE_HEADER	ENDS							;AN000;



EXTENT_HEADER	STRUC		   ; extend header structure		;AN000;
EH_Logic_Clus_Num    dw     0	   ; starting logical clus num of extent;AN000;
EH_Phys_Clus_Num     dw     0	   ; starting physical clus numof  extnt;AN000;
EH_Count	     dw     0	   ; range of logical clusnum in the extnt
EH_Next_Extn_Ptr     dw     0	   ; pointer to next extent		;AN000;
EH_Prev_Extn_Ptr     dw     0	   ; pointer to previous extent  ;AN000;
EH_Next_LRU_Ptr      dw     0	   ; pointer to next LRU extent
EH_Prev_LRU_Ptr      dw     0	   ; pointer tp previous LRU extent
		     dw     0
EXTENT_HEADER	ENDS




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\filemode.inc ===
BREAK	<FILEMODE.INC - Misc. File API Values>
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	FILEMODE.INC - Misc. File API Values
;
;	These values are all visable to the client program as part of
;	an API.


;**	Standard I/O file handles
;

STDIN	equ	0
STDOUT	equ	1
STDERR	equ	2
STDAUX	equ	3
STDPRN	equ	4



;**	File Modes

ACCESS_MASK	    equ 0Fh
OPEN_FOR_READ	    equ 00h
OPEN_FOR_WRITE	    equ 01h
OPEN_FOR_BOTH	    equ 02h
EXEC_OPEN	    equ 03h	; access code of 3 indicates that open was 
				; made from exec

SHARING_MASK	    equ 0F0h
SHARING_COMPAT	    equ 000h
SHARING_DENY_BOTH   equ 010h
SHARING_DENY_WRITE  equ 020h
SHARING_DENY_READ   equ 030h
SHARING_DENY_NONE   equ 040h
SHARING_NET_FCB     equ 070h
SHARING_NO_INHERIT  equ 080h



;**	Extended Open Definitions
;

RESERVED_BITS_MASK	equ 0FE00h	; reserved bits for extended open flags
EXISTS_MASK		equ 0Fh 	; "file exists" action field
NOT_EXISTS_MASK 	equ 0F0h


;*	SF_MODE values

AUTO_COMMIT_WRITE	equ 4000h
INT_24_ERROR		equ 2000h


;*	Flags in EXTOPEN_ON

EXT_OPEN_ON		equ 01h
EXT_FILE_NOT_EXISTS	equ 04h
EXT_OPEN_I24_OFF	equ 02h


;*	Flags in EXTOPEN_FLAG

ACTION_OPENED		equ 01h
ACTION_CREATED_OPENED	equ 02h
ACTION_REPLACED_OPENED	equ 03h
EXT_EXISTS_OPEN 	equ 01h
EXT_EXISTS_FAIL 	equ 00h
EXT_NEXISTS_CREATE	equ 10h


;**	Extended Open Structure
;

EXT_OPEN_PARM	   struc
EXT_SET_LIST	    dd ?
EXT_NUM_OF_PARM     dw ?
EXT_OPEN_PARM	   ends


;*	Unused. should be deleted


;   NO_CODE_PAGE_CHECK	equ 0100h
;   IO_MODE_ID		equ 00000010b

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\int2a.inc ===
BREAK	<Int 2A Definitions>

;**	Int 2A functions
;
;	Int 2A is an interface to the network code; it's also overloaded
;		as a critical section handler since critical sections
;		were originally created to support the net.


;**	This table was created by examining the source and may not be
;	complete or completely accurate - JGL
;
;	M010	MD	8/31/90 - Added definition for AH = 5

;	(ah) = 0	installation check
;			   (returns ah !=0 if installed)
;	(ah) = 1	cooked net bios call
;	(ah) = 3	query drive shared
;			   (ds:si) = "n:" asciz string
;	(ah) = 4	net bios
;	       (al) = 0	   cooked net bios call
;	       (al) = 1	   raw net bios call
;	       (al) = 2	   ???
;
;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
;			NCBs available/outstanding. DX returns the number of
;			sessions. Supposedly, this is documented in an old
;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
;			Manager 2.0 Enhanced responds to it. But it should
;			not be used, as it is a hack, only to get Lotus
;			Notes running.
;
;	(ah) = 80h	enter critical section
;	(ah) = 81h	leave critical section
;	(ah) = 82h	free all critical sections (Leave-all)
;	(ah) = 84h	entering idle loop (don't understand how this works)


	Break <Critical sections>


;**	Critical section definitions
;
;	Although DOS is not designed to be reentrant there are some hacks
;	which various programs use to make it so, in a limited fashion.
;	Both WIN386 and some servers block copy a section of the DOS data
;	area so that DOS can be reentered on behalf of another thread/program.
;	DOS's global data structures, such as the memory arena, are not
;	in this area, so critical section indicators are used to protect
;	those areas.  DOS flags a critical section by issuing an INT_IBM
;	(int 2Ah) at each critical section entry and exit.  Some clients
;	(such as WIN386) just don't "context switch" the DOS when one
;	of these is in effect, others, such as the IBM server, go ahead
;	and reenter the DOS and if they get an int 2A to reenter the same
;	critical section they then switch away from that second thread and
;	let the first one finish and exit the section.
;
;	These below are subject to leave-all sections

critDisk    EQU     1			; Disk I/O critical section
critShare   EQU     1			; Sharer I/O critical section
critMem     EQU     1			; memory maintenance critical section
critSFT     EQU     1			; sft table allocation
critDevice  EQU     2			; Device I/O critical section
critNet     EQU     5			; network critical section
critIFS     EQU     6			; ifsfunc critical section

;	These below are not subject to leave-all sections

critASSIGN  EQU     8			; Assign has munged a system call
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\find.inc ===
Break	<find first/next buffer>

;**	Findfirst/FindNext Record
;
;	Client programs see this structure.  Some if it is defined,
;	clients probably use undefined parts too.


FIND_BUF    STRUC

FIND_BUF_DRIVE	    DB	?		; drive of search
FIND_BUF_NAME	    DB	11 DUP (?)	; formatted name
FIND_BUF_SATTR	    DB	?		; attribute of search
FIND_BUF_LASTENT    DW	?		; LastEnt
FIND_BUF_DIRSTART   DW	?		; DirStart
FIND_BUF_NETID	    DB	4 DUP (?)	; Reserved for NET
FIND_BUF_ATTR	    DB	?		; attribute found
FIND_BUF_TIME	    DW	?		; time
FIND_BUF_DATE	    DW	?		; date
FIND_BUF_SIZE_L     DW	?		; low(size)
FIND_BUF_SIZE_H     DW	?		; high(size)
FIND_BUF_PNAME	    DB	13 DUP (?)	; packed name

FIND_BUF    ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\intnat.inc ===
;	SCCSID = @(#)intnat.asm	1.1 85/04/10
BREAK <International data structure format>

;
; Current structure of the data returned by the international call
;
internat_block STRUC
Date_tim_format DW	?		; 0-USA, 1-EUR, 2-JAP
Currency_sym	DB	?		; Currency Symbol 5 bytes
		DB	?
		DB	?
		DB	?
		DB	?
Thous_sep	DB	?		; Thousands separator 2 bytes
		DB	?
Decimal_sep	DB	?		; Decimal separator 2 bytes
		DB	?
Date_sep	DB	?		; Date separator 2 bytes
		DB	?
Time_sep	DB	?		; Decimal separator 2 bytes
		DB	?
Bit_field	DB	?		; Bit values
					;   Bit 0 = 0 if currency symbol first
					;	  = 1 if currency symbol last
					;   Bit 1 = 0 if No space after currency symbol
					;	  = 1 if space after currency symbol
Currency_cents	DB	?		; Number of places after currency dec point
Time_24 	DB	?		; 1 if 24 hour time, 0 if 12 hour time
Map_call	DW	?		; Address of case mapping call (DWORD)
		DW	?		; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
					;  in pieces.
Data_sep	DB	?		; Data list separator character
		DB	?
internat_block ENDS

;
; Max size of the block returned by the INTERNATIONAL call
;
internat_block_max	EQU	32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\ioctl.inc ===
;  %OUT IOCTL.INC...
; THESE ARE ALL THE IMPORTANT STRUCTURES AND EQUATES FOR IOCTL
;==============================================================================
;REVISION HISTORY:
;AN000 - New for DOS Version 4.00 - J.K.
;AC000 - Changed for DOS Version 4.00 - J.K.
;AN00x - PTM number for DOS Version 4.00 - J.K.
;==============================================================================
;AN001; D241 Provide support of Multi-track Format/Verify	   9/23/87 J.K.
;AN002; P1535 Unformatted hard file problem			  10/15/87 J.K.
;AN003; D490 IOCTL subfunction 63h,43h,64h,44h conflicts with OS2  2/26/88 J.K.
;==============================================================================

;*** J.K.
;General Guide -
;Category Code:
; 0... .... DOS Defined
; 1... .... User defined
; .xxx xxxx Code

;Function Code:
; 0... .... Return error if unsupported
; 1... .... Ignore if unsupported
; .0.. .... Intercepted by DOS
; .1.. .... Passed to driver
; ..0. .... Sends data/commands to device
; ..1. .... Quries data/info from device
; ...x .... Subfunction
;
; Note that "Sends/queries" data bit is intended only to regularize the
; function set.  It plays no critical role; some functions may contain both
; command and query elements. The convention is that such commands are
; defined as "sends data".

;*****************************;*
; BLOCK DRIVERS 	      ;*
;*****************************;*

; IOCTL SUB-FUNCTIONS
IOCTL_GET_DEVICE_INFO	EQU	0
IOCTL_SET_DEVICE_INFO	EQU	1
IOCTL_READ_HANDLE	EQU	2
IOCTL_WRITE_HANDLE	EQU	3
IOCTL_READ_DRIVE	EQU	4
IOCTL_WRITE_DRIVE	EQU	5
IOCTL_GET_INPUT_STATUS	EQU	6
IOCTL_GET_OUTPUT_STATUS EQU	7
IOCTL_CHANGEABLE?	EQU	8
IOCTL_DeviceLocOrRem?	EQU	9
IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
IOCTL_SHARING_RETRY	EQU	0Bh   ;11
GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
GENERIC_IOCTL		EQU	0Dh   ;13
IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
IOCTL_QUERY_HANDLE	EQU	10h   ;16
IOCTL_QUERY_BLOCK	EQU	11h   ;17


; GENERIC IOCTL CATEGORY CODES
IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
IOC_TC			EQU	2	; TERMINAL CONTROL
IOC_SC			EQU	3	; SCREEN CONTROL
IOC_KC			EQU	4	; KEYBOARD CONTROL
IOC_PC			EQU	5	; PRINTER CONTROL
IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)

; GENERIC IOCTL SUB-FUNCTIONS
RAWIO			EQU	8

; RAWIO SUB-FUNCTIONS
GET_DEVICE_PARAMETERS	EQU	60H
SET_DEVICE_PARAMETERS	EQU	40H
READ_TRACK		EQU	61H
WRITE_TRACK		EQU	41H
VERIFY_TRACK		EQU	62H
FORMAT_TRACK		EQU	42H
GET_MEDIA_ID		EQU	66h		;AN000;AN003;changed from 63h
SET_MEDIA_ID		EQU	46h		;AN000;AN003;changed from 43h
GET_ACCESS_FLAG 	EQU	67h		;AN002;AN003;Unpublished function.Changed from 64h
SET_ACCESS_FLAG 	EQU	47h		;AN002;AN003;Unpublished function.Changed from 44h
SENSE_MEDIA_TYPE	EQU	68H		;Added for 5.00


; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
BUILD_DEVICE_BPB	EQU	000000001B

; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
INSTALL_FAKE_BPB	EQU	000000001B
ONLY_SET_TRACKLAYOUT	EQU	000000010B
TRACKLAYOUT_IS_GOOD	EQU	000000100B

; SPECIAL FUNCTION FOR FORMAT TRACK
STATUS_FOR_FORMAT		EQU	000000001B
DO_FAST_FORMAT			equ	000000010B	;AN001;
; CODES RETURNED FROM FORMAT STATUS CALL
FORMAT_NO_ROM_SUPPORT		EQU	000000001B
FORMAT_COMB_NOT_SUPPORTED	EQU	000000010B

; DEVICETYPE VALUES
MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
DEV_5INCH		EQU	0
DEV_5INCH96TPI		EQU	1
DEV_3INCH720KB		EQU	2
DEV_8INCHSS		EQU	3
DEV_8INCHDS		EQU	4
DEV_HARDDISK		EQU	5
DEV_OTHER		EQU	7
DEV_3INCH1440KB		EQU	7
DEV_3INCH2880KB		EQU	9

MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
					; CURRENTLY SUPPORT.

A_SECTORTABLE	    STRUC
ST_SECTORNUMBER 	DW	?
ST_SECTORSIZE		DW	?
A_SECTORTABLE	    ENDS

ifndef NEC_98
;A_DEVICEPARAMETERS  STRUC
;DP_SPECIALFUNCTIONS	DB	?
;DP_DEVICETYPE		DB	?
;DP_DEVICEATTRIBUTES	DW	?
;DP_CYLINDERS		DW	?
;DP_MEDIATYPE		DB	?
;DP_BPB			DB	SIZE A_BPB DUP (?)
;DP_TRACKTABLEENTRIES	DW	?
;DP_SECTORTABLE		DB MAX_SECTORS_IN_TRACK * SIZE A_SECTORTABLE DUP (?)
;A_DEVICEPARAMETERS  ENDS
else    ;NEC_98
A_DEVICEPARAMETERS  STRUC
DP_SPECIALFUNCTIONS	DB	?
DP_DEVICETYPE		DB	?
DP_DEVICEATTRIBUTES	DW	?
DP_CYLINDERS		DW	?
DP_MEDIATYPE		DB	?
DP_BPB			DB	SIZE A_BPB DUP (?)
DP_TRACKTABLEENTRIES	DW	?
DP_SECTORTABLE		DB MAX_SECTORS_IN_TRACK * SIZE A_SECTORTABLE DUP (?)
A_DEVICEPARAMETERS  ENDS
endif   ;NEC_98

;A_TRACKREADWRITEPACKET STRUC
;TRWP_SPECIALFUNCTIONS	DB	?
;TRWP_HEAD		DW	?
;TRWP_CYLINDER		DW	?
;TRWP_FIRSTSECTOR	DW	?
;TRWP_SECTORSTOREADWRITE DW	?
;TRWP_TRANSFERADDRESS	DD	?
;A_TRACKREADWRITEPACKET ENDS

;AN001; - FP_TRACKCOUNT is only meaningful when FP_SPECIALFUNCTIONS bit 1 = 1.
A_FORMATPACKET	    STRUC
FP_SPECIALFUNCTIONS	DB	?
FP_HEAD 		DW	?
FP_CYLINDER		DW	?
FP_TRACKCOUNT		DW	1
A_FORMATPACKET	    ENDS

A_VERIFYPACKET	    STRUC
VP_SPECIALFUNCTIONS	DB	?
VP_HEAD 		DW	?
VP_CYLINDER		DW	?
A_VERIFYPACKET	    ENDS

A_MEDIA_ID_INFO     STRUC
MI_LEVEL		DW	0		;J.K. 87 Info. level
MI_SERIAL		DD	?		;J.K. 87 Serial #
MI_LABEL		DB     11 DUP (' ')     ;J.K. 87 volume label
MI_SYSTEM		DB	8 DUP (' ')     ;J.K. 87 File system type
A_MEDIA_ID_INFO     ENDS

A_DISKACCESS_CONTROL	STRUC			;AN002; Unpublished function. Only for Hard file.
DAC_SPECIALFUNCTIONS	DB	0		;AN002; Always 0
DAC_ACCESS_FLAG 	DB	0		;AN002; Non Zero - allow disk I/O to unformatted hard file
A_DISKACCESS_CONTROL	ENDS			;AN002; 0 - Disallow disk I/O to unformatted hard file


A_MEDIA_SENSE	STRUC			; Media sense structure added 5.00
MS_ISDEFAULT		DB	?	; If 1 type returned is drv default
MS_DEVICETYPE		DB	?	; Drive type 
MS_RESERVED1		DB	?	; RESERVED
MS_RESERVED2		DB	?	; RESERVED 
A_MEDIA_SENSE	ENDS

;********************************;*
; CHARACTER DEVICES (PRINTERS)	 ;*
;********************************;*

;RAWIO SUB-FUNCTIONS
GET_RETRY_COUNT 	EQU	65H
SET_RETRY_COUNT 	EQU	45H

A_RETRYCOUNT	    STRUC
RC_COUNT		DW	?
A_RETRYCOUNT	    ENDS

;********************************;*		;J.K. 4/29/86
; CHARACTER DEVICES (SCREEN)	 ;*
;********************************;*		;J.K. 4/29/86
;
;SC_MODE_INFO	 struc
;SC_INFO_LENGTH 	 DW	 9
;SC_MODE		 DB	 0
;SC_COLORS		 DW	 0
;SC_WIDTH		 DW	 0
;SC_LENGTH		 DW	 0
;SC_MODE_INFO	 ends
;
;SC_INFO_PACKET_LENGTH	 EQU	 9		 ;LENGTH OF THE INFO PACKET.

;SUBFUNCTIONS FOR CON$GENIOCTL
;GET_SC_MODE		 EQU	 60h
;SET_SC_MODE		 EQU	 40h
;The following subfunctions are reserved for installable CODE PAGE switch
;console devices. - J.K. 4/29/86
;Get_active_codepage	 equ	 6Ah
;Invoke_active_codepage  equ	 4Ah
;Start_designate_codepage equ	 4Ch
;End_designate_codepage  equ	 4Dh
;Get_list_of_designated_codepage equ 6Bh
;J.K. 4/29/86 *** End of Con$genioctl equates & structures

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\lock.inc ===
;**	LOCK.INC - Definitions for Record Locking
;


;**	LOCK functions
;

LOCK_ALL	    equ    0
UNLOCK_ALL	    equ    1
LOCK_MUL_RANGE	    equ    2
UNLOCK_MUL_RANGE    equ    3
LOCK_READ	    equ    4
WRITE_UNLOCK	    equ    5
LOCK_ADD	    equ    6



;**	Structure for Lock buffer

LockBuf    STRUC

   Lock_position DD    ?	    ; file position for LOCK
   Lock_length	 DD    ?	    ; number of bytes to LOCK

LockBuf    ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\mi.inc ===
;	SCCSID = @(#)mi.asm	1.1 85/04/10
BREAK <Machine instruction, flag definitions and character types>

mi_INT		EQU	0CDh
mi_Long_JMP	EQU	0EAh
mi_Long_CALL	EQU	09Ah
mi_Long_RET	EQU	0CBh
mi_Near_RET	EQU	0C3h

;			xxxxoditszxaxpxc
f_Overflow	EQU	0000100000000000B
f_Direction	EQU	0000010000000000B
f_Interrupt	EQU	0000001000000000B
f_Trace 	EQU	0000000100000000B
f_Sign		EQU	0000000010000000B
f_Zero		EQU	0000000001000000B
f_Aux		EQU	0000000000010000B
f_Parity	EQU	0000000000000100B
f_Carry 	EQU	0000000000000001B
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\keybshar.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1991
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSHAR.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;; ;jwg  ; - Feb 1990 For 4.03.
;; ;AN007; -	       Add Patriot/Sebring determination code for HOT Replug
;;			so that INT 9 handler can alter keyboard Scan Code set.
;; ;M030		Merged IBM (Kermit - JP), KEYBOARD.SYS and KEYB.COM
;;			  versions of this file into one.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SHARED_DATA_STR defines the initial fixed length portion of the
;; Shared Data Area.
;; Tables are loaded beginning at TABLE_AREA in the following order:
;;  State Logic
;;  Common Translate Section
;;  Specific Translate Sections for
;;   each code page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; SPECIAL_FEATURES equates:
TYPEWRITER_CAPS_LK  EQU    8000H	;; typewriter style caps lock
					;;
JR_HOT_KEY_1_2	equ	4000h		;; M030 Merged back for kdfcf.asm
JR_KB		equ	8000h		;; M030 Merged back for kdfcf.asm
					;; Some useful scan codes:
F1_SCAN     EQU   59			;; F1
F2_SCAN     EQU   60			;; F2
					;;
					;;	SYSTEM_FLAG / Hardware equates:
					;;   INT 16h and remote support
EXT_16		EQU	8000H		;; extended INT 16h support is there
EXT_122 	EQU	4000H		;; extended INT 16h for 122 is there
;		EQU	2000H		;;  unused
PC_NET		EQU	1000H		;; flag PC Net is installed
					;;   System type/hardware support flags
PC_81		EQU	0800H		;; flag for Original PC
PC_XT		EQU	0400H		;; code for PC, PC/XT, PORTABLE
PC_LAP		EQU	0200H		;; code for Convertiable (p-12)
PC_PAL		EQU	0080H		;; code for Model 30 (PALACE)
PC_AT		EQU	0040H		;; code for PC-AT  with 8042
PC_386		EQU	0020H		;; code for PS/2's with 8042 (WRANGLER)
PS_8042 	EQU	0010H		;; 8042 is a Patriot/Sebring type array;AN007;jwg
					;;  or system set translate OFF (SCS=01)
SECURITY_ACTIVE	EQU	0008h	; M030	;; Server password mode is active
;				; M030	;;  This bit becomes off from on when
;				; M030	;;  correct password is entered JP9010
					;;
					;; HOT_KEY_FLAG EQUATES:
US_MODE     EQU   0			;;  hot key is active => US
LANG_MODE   EQU   0FFH			;;  hot key is inactive
					;;
					;; -----------------------------------
SHARED_DATA_STR     STRUC		;; SHARED DATA AREA
					;;
OLD_INT_9	    DD	  0		;; saved int 9 vector
OLD_INT_2F	    DD	  0		;; saved int 2F vector
		    dd    0		;; reserved
KEYB_TYPE	    DW	  0		;; type of keyboard
SYSTEM_FLAG	    DW	  0		;; system configuration flags
TABLE_OK	    DB	  0		;; flag to INT 9 that table is built
		    db    5 dup (0)	;; reserved
					;;
					;; Table copy begins here:
ACTIVE_LANGUAGE     DB	  'US'          ;; language code
INVOKED_CP_TABLE    DW	  437		;; ptr to table for invoked code page
INVOKED_KBD_ID	    DW	  0		;; WGR invoked keyboard id.	       ;AN000
ACTIVE_XLAT_PTR     DW	  -1		;; ptr to active Specific Translate Sect
FIRST_XLAT_PTR	    DW	  -1		;; ptr to first Specific Translate Sect
RESIDENT_END	    DW	  0ffffh	;; offset of last byte in resident mem
LOGIC_PTR	    DW	  -1		;; ptr to State Logic
COMMON_XLAT_PTR     DW	  -1		;; ptr to Common Translate Section
SPECIAL_FEATURES    DW	  ?		;; special Features
TABLE_OVERFLOW	    DB	  0		;; overflow flag for table rebuild
HOT_KEY_ON_SCAN     DB	  ?		;; scan codes to use with ALT+CTRL
HOT_KEY_OFF_SCAN    DB	  ?		;;  to turn hot key on and off
		    DB	  4 DUP(0)	;; reserved
TABLE_AREA	    DB	  ?		;; tables loaded here:
					;;  State Logic
					;;  Common Translate Section
					;;  Specific Translate Sections for
					;;   each code page
SHARED_DATA_STR     ENDS		;;
					;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic equates.
;; Contains equates for our NLS Flags and for the State Logic
;; commands.
;; State Logic command macros are defined in KEYBMAC.INC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_LOGIC_STR STRUC			;;
					;;
SL_LOGIC_LEN	DW   ?			;; length of state logic
SL_SPECIAL_FEATURES   DW   ?		;;
SL_LOGIC_CMDS	DB   0			;; state logic commands begin here
					;;
STATE_LOGIC_STR ENDS			;;
					;;
					;;
NUM_BIOS_FLAGS	    EQU   4		;;
NUM_NLS_FLAGS	    EQU   2		;; '+1' below is the EXT_KB_FLAG
NUM_FLAGS	    EQU   NUM_BIOS_FLAGS+NUM_NLS_FLAGS+1
					;;
					;;
EITHER_SHIFT	    EQU   80H		;; EXT_KB_FLAG : our own shift state
EITHER_CTL	    EQU   40H		;;  flags
EITHER_ALT	    EQU   20H		;;
SCAN_MATCH	    EQU   08H		;; set if scan code found in XLATT
					;; or SET_FLAG searches
					;;
					;;
KB_FLAG_ID	    EQU   0		;; Flag ID's as coded in IFF and ANDF
KB_FLAG_1_ID	    EQU   1		;;  commands
KB_FLAG_2_ID	    EQU   2		;;
KB_FLAG_3_ID	    EQU   3		;;
EXT_KB_FLAG_ID	    EQU   4		;;
NLS_FLAG_1_ID	    EQU   5		;;
NLS_FLAG_2_ID	    EQU   6		;;
					;;
COMMAND_BITS	    EQU   0F0H		;; Mask to isolate command code
SUB_CMD_BITS	    EQU   0FH		;; mask to isolate sub command code
NOT_TEST	    EQU   08H		;; NOT bit in IFF, ANDF
COMMAND_SHIFT	    EQU   4		;; shift amount for command code
FLAG_ID_BITS	    EQU   07H		;; mask to isolate flag id in IFF, ANDF
NUM_COMMANDS	    EQU   0CH		;; number of commands
					;;
IFF_COMMAND	    EQU   00H		;;
ANDF_COMMAND	    EQU   10H		;;
ELSEF_COMMAND	    EQU   20H		;;
ENDIFF_COMMAND	    EQU   30H		;;
XLATT_COMMAND	    EQU   40H		;;
OPTION_COMMAND	    EQU   50H		;;
SET_FLAG_COMMAND    EQU   60H		;;
PUT_ERROR_COMMAND   EQU   70H		;;
IFKBD_COMMAND	    EQU   80H		;;
GOTO_COMMAND	    EQU   90H		;;
BEEP_COMMAND	    EQU   0A0H		;;
RESET_NLS_COMMAND   EQU   0B0H		;;
CHECK_CORE_COMMAND  EQU   0C0H		;;
					;;
					;;
EXIT_INT_9_FLAG 	EQU  01H	;; Special forms of GOTO.  These
EXIT_STATE_LOGIC_FLAG	EQU  02H	;;  values are in the right nibble
					;;   of the GOTO command.
					;;
					;; PROCESSING OPTIONS:
EXIT_IF_FOUND	    EQU   80H		;; exit INT 9 if a translation
					;;  match is found
					;;
ANY_KB		     EQU   0FFFFH	;;
XT_KB		     EQU   4000H	;;
AT_KB		     EQU   2000H	;;
G_KB		     EQU   1000H	;;
P_KB		     EQU   0800H	;;
P12_KB		     EQU   0400H	;;
DBCS_OLD_A_KB	     EQU   0080H ; M030	;; JP9009
DBCS_OLD_P_KB	     EQU   0040H ; M030	;; JP9009
DBCS_OLD_G_KB	     EQU   0020H ; M030	;; JP9009
DBCS_OLD_KB	     EQU   00C0H ; M030	;; JP9009
DBCS_KB		     EQU   0020H ; M030	;; JP9009
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table Sections.  Both the Specific and Common
;; Translate Sections are formatted as follows.
;;
;; The Specific Translate Sections are chained together using the
;; XS_NEXT_SECT_PTR field (-1 if last section).
;; Translate Sections contains multiple States.
;; A State contains the translate tables for a single
;; shift state (IE lower case, upper case ....)
;; Each State may contain multiple translate tables.
;;
;; The Translate Section layout is defined using several STRUCs.
;; These STRUCs are allocated in the Shared Data Area as follows:
;;
;;	 XLAT_SECT_STR		  ; header info for the section
;;	    STATE_STR		  ; header for state #1
;;	      XLAT_STR		  ;   first translate tab for state #1
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      XLAT_STR		  ;   second translate tab
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	    STATE_STR		  ; header for state #2
;;	      XLAT_STR
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	   ...
;;
;; A State may contain a "Set_Flag" table instead of translate tables.
;; These tables are used to set the NLS flags instead of generating
;; ASCII codes (for example: to remember dead key states).
;; There can be only on Set_Flag table per state.
;; The Set_Flag table layout is defined in the SET_FLAG_STR STRUC.
;;
;; So some states will contain translate tables (to generate ASCII codes)
;; and some states will contain a Set_Flag table (to record dead key
;; status).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
XLAT_SECT_STR	    STRUC		;;
					;;
XS_NEXT_SECT_PTR       DW    ?		;; Pointer to next Specific Translate
					;;  Section
XS_CP_ID	       DW    ?		;; code page id
XS_FIRST_STATE	       DB    ?		;;
					;;
XLAT_SECT_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State structure.
;; The last State is a null State containing only the
;; XS_STATE_LEN field with a value of 0.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_STR	    STRUC		;;
					;;
XS_STATE_LEN	 DW    ?		;; length of state section
XS_STATE_ID	 DB    ?		;; State ID
XS_KBD_TYPE	 DW    ?		;; Keyboard Type
XS_ERROR_CHAR	 DW    ?		;; Buffer entry for error character
XS_FIRST_TAB	 DB    ?		;;
					;;
STATE_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table structures.
;; There may be many translate tables in a State.  The last
;; table is a null table containing only the XLAT_TAB_SIZE field with
;; a value of 0.
;; The xlate table can be in one of two forms:
;;    Type 1 = Table contains buffer entries only.
;;	       Scan code is used as an index into xlat table
;;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;;	       Table must be searched for matching scan.
;; Type 1 is the default.  Type 2 tables should be identified by setting
;; the TYPE_2_TAB bit in XLAT_OPTIONS.
;; Buffer entries default to 2-bytes per entry.
;; Optionally the table may contain ASCII codes only
;; (1-byte entries).  This is specified by setting the ASCII_ONLY bit
;; in XLAT_OPTIONS.  2-byte buffer entries are coded ASCII,SCAN.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; Translate options:
ASCII_ONLY	    EQU   80H		;; Only ASCII codes listed - use
					;;  incoming scan for buffer entry
TYPE_2_TAB	    EQU   40H		;; search xlat table for matching scan
ZERO_SCAN	    EQU   20H		;; set the scan half of the buffer
					;;  entry to 0
					;;
NULL_ASCII_CODE     EQU   -1		;;
					;;
DEFAULT_TAB_2_ENT_SZ   EQU   3		;;
ASC_ONLY_TAB_2_ENT_SZ  EQU   2		;;
					;;
					;;
XLAT_STR	    STRUC		;;
					;;
XLAT_TAB_SIZE	    DW	  ?		;; Size in bytes of this table -
					;;  includes this field, options etc.
XLAT_OPTIONS	    DB	  ?		;; xlat options
					;; XLAT TABLE IS HERE
XLAT_STR	    ENDS		;;
					;;
XLAT_TYPE_1_STR     STRUC		;; use scan code as index into table
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_SCAN_LO	    DB	  ?		;; Scan code
XLAT_SCAN_HI	    DB	  ?		;;  range
XLAT_1_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_1_STR     ENDS		;;
					;;
XLAT_TYPE_2_STR     STRUC		;; search table for scan
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_NUM	    DB	  ?		;; number of scans
XLAT_SCAN	    DB	  ?		;; Scan code
XLAT_2_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_2_STR     ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set_Flag Tables.
;; State Sections immediately following the LAST_ENTRYs.
;; Dead key definitions.  If the scan matches then
;; set the bit in NLS_FLAGs indicated in DK_MASK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
SF_ENT_SZ     EQU   3			;; size of entry
					;;
SET_FLAG_STR	    STRUC		;;
					;;
SF_NUM		    DB	  0		;; Number of entries
SF_SCAN_CODE	    DB	  0		;; scan code
SF_FLAG_ID	    DB	  0		;; flag id
SF_FLAG_MASK	    DB	  0		;; flag mask
					;;
SET_FLAG_STR	    ENDS		;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\lmstub.asm ===
;===========================================================================
;
; 	TITLE Low Memory Stub for DOS when DOS runs in HMA
;
;
;	Revision History:
;
;	M003 - MS PASCAL 3.2 support. Please see under tag M003 in dossym.inc
;	       7/30/90
;
;	M006 - print A20 Hardware error using int 10.
;
;	M020 - Fix for Rational Bug - see exepatch.asm for details
;
;	M011 - check for wrap rather than do an XMS query
;	       A20 after int 23,24 and 28
;
;	M012 - Rearranged stuff to make Share build with msdata
;
;	M023 - Added variable UmbSave1 for preserving umb_head arena across
;	       win /3 session for win ver < 3.1
;
;
;============================================================================



DOSDATA    SEGMENT WORD PUBLIC 'DATA'
	   assume cs:DOSDATA


;----------------------------------------------------------------------------
;
;	P U B L I C S
;
;----------------------------------------------------------------------------

	PUBLIC	DOSINTTABLE

	public	ldivov
	public	lquit
	public	lcommand
	public	labsdrd
	public	labsdwrt
	public	lStay_resident
	public	lint2f
	public	lcall_entry
	public	lirett
ifdef NEC_98
	PUBLIC	lirett2
endif   ;NEC_98


	public	i0patch
	public	i20patch
	public	i21patch
	public	i25patch
	public	i26patch
	public	i27patch
	public	i2fpatch
	public	cpmpatch



;----------------------------------------------------------------------------
;
; 	D A T A
;
;----------------------------------------------------------------------------

	EVEN
DOSINTTABLE	LABEL	DWORD
	
	DW	OFFSET DOSCODE:DIVOV 		, 0
	DW	OFFSET DOSCODE:QUIT 		, 0
	DW	OFFSET DOSCODE:COMMAND		, 0
	DW	OFFSET DOSCODE:ABSDRD		, 0
	DW	OFFSET DOSCODE:ABSDWRT		, 0
	DW	OFFSET DOSCODE:Stay_resident	, 0
	DW	OFFSET DOSCODE:INT2F		, 0
	DW	OFFSET DOSCODE:CALL_ENTRY	, 0
	DW	OFFSET DOSCODE:IRETT		, 0

	SS_Save	DW	?		; save user's stack segment
	SP_Save	DW	?		; save user's stack offset



;-------------------------------------------------------------------------
;
; LOW MEM STUB:
;
; The low mem stub contains the entry points into DOS for all interrupts
; handled by DOS. This stub is installed if the user specifies that the
; DOS load in HIMEM. Each entry point does this.
;
;
; 	1. if jmp to 8 has been patched out
;	   2. if A20 OFF
;	      3. Enable A20
;	   4. else
;	      5. just go to dos entry
;	   6. endif
;	7. else
;	   8. just go to dos entry
;	9. endif
;
;
;--------------------------------------------------------------------------
	assume	cs:dosdata

;--------------------------------------------------------------------------
;
; DIVIDE BY 0 handler
;
;--------------------------------------------------------------------------

ldivov:
	;
	; The following jump, skipping the XMS calls will be patched to
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i0patch:
	jmp	short divov_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

divov_cont:
	jmp	dword ptr DOSINTTABLE	; jmp to DOS

;------------------------------------------------------------------------
;
; INT 20 Handler
;
; Here we do not have to set up the stack to return here as the abort call
; will return to the address after the int 21 ah=4b call. This would be the
; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
; will be restored then.
;
;-------------------------------------------------------------------------

lquit:
	;
	; The following jump, skipping the XMS calls will be patched to
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i20patch:
	jmp	short quit_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
quit_cont:
	jmp	dword ptr DOSINTTABLE+4	; jump to DOS

;--------------------------------------------------------------------------
;
; INT 21 Handler
;
;--------------------------------------------------------------------------

lcommand:

	;
	; The following jump, skipping the XMS calls will be patched to
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i21patch:
	jmp	short command_cont	

	call	WEnsureA20ON		; we must turn on A20 if OFF


command_cont:
	jmp	dword ptr DOSINTTABLE+8	; jmp to DOS

;------------------------------------------------------------------------
;
; INT 25
;
;----------------------------------------------------------------------------

labsdrd:
	;
	; The following jump, skipping the XMS calls will be patched to
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i25patch:
	jmp	short absdrd_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

absdrd_cont:
	jmp	dword ptr DOSINTTABLE+12; jmp to DOS

;-------------------------------------------------------------------------
;
; INT 26
;
;-----------------------------------------------------------------------

labsdwrt:

	;
	; The following jump, skipping the XMS calls will be patched to
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i26patch:
	jmp	short absdwrt_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

absdwrt_cont:
	jmp	dword ptr DOSINTTABLE+16; jmp to DOS

;------------------------------------------------------------------------
;
; INT 27
;
;-----------------------------------------------------------------------

lStay_resident:

	;
	; The following jump, skipping the XMS calls will be patched to
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i27patch:
	jmp	short sr_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

sr_cont:
	jmp	dword ptr DOSINTTABLE+20; jmp to DOS

;-----------------------------------------------------------------------------
;
; INT 2f
;
;-------------------------------------------------------------------------

lint2f:

	;
	; The following jump, skipping the XMS calls will be patched to
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
i2fpatch:
	jmp	short int2f_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

int2f_cont:
	jmp	dword ptr DOSINTTABLE+24; jmp to DOS

;-----------------------------------------------------------------------------
;
; CPM entry
;
;------------------------------------------------------------------------

lcall_entry:

	;
	; The following jump, skipping the XMS calls will be patched to
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
	;
cpmpatch:
	jmp	short callentry_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	

callentry_cont:
	jmp	dword ptr DOSINTTABLE+28; jmp to DOS


;--------------------------------------------------------------------------

lirett: jmp  DOIRET
ifdef NEC_98
lirett2:	iret
endif   ;NEC_98

;---------------------------------------------------------------------------
;
; LowIntXX:
;
; Interrupts from DOS that pass control to a user program must be done from
; low memory, as the user program may change the state of the A20 line or
; they may require that the A20 line be OFF. The following piece of code is
; far call'd from the following places in DOS:
;
;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
;	2. msctrlc.asm where dos issues an int 24h (critical error)
;	3. msctrlc.asm where dos issues an int 28h (idle int)
;
; The int 23 and int 24 handlers may decide to do a far return instead of an
; IRET ane leave the flags on the stack. Therefore we save the return address
; before doing the ints and then do a far junp back into DOS.
;
;---------------------------------------------------------------------------


public	DosRetAddr23, DosRetAddr24
public	LowInt23, LowInt24, LowInt28

DosRetAddr23	DD	?
DosRetAddr24	DD	?
DosRetAddr28	DD	?

	;
	; Execute int 23h from low memory
	;

LowInt23:
					; save the return address that is on
					; the stack
	pop	word ptr cs:[DosRetAddr23]
	pop	word ptr cs:[DosRetAddr23+2]

	int	23h			; ctrl C
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF

	jmp	dword ptr DosRetAddr23	; jump back to DOS



	;
	; Execute int 24h from low memory
	;

LowInt24:
					; save the return address that is on
					; the stack
	pop	word ptr cs:[DosRetAddr24]
	pop	word ptr cs:[DosRetAddr24+2]

	int	24h			; crit error
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF	

	jmp	dword ptr DosRetAddr24	; jump back to DOS


	;
	; Execute int 23h from low memory
	;

LowInt28:

	int	28h			; idle int
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF	

	retf

;-------------------------------------------------------------------------
;
; int 21 ah=4b (exec) call will jump to the following label before xferring
; control to the exec'd program. We turn of A20 inorder to allow programs
; that have been packed by the faulty exepack utility to unpack correctly.
; This is so because exepac'd programs rely on address wrap.
;
;-------------------------------------------------------------------------

public	disa20_xfer
disa20_xfer:
	call	XMMDisableA20		; disable A20

	;
	; Look at msproc.asm at label exec_go for understanding the following:
	;

	; DS:SI points to entry point
	; AX:DI points to initial stack
	; DX has PDB pointer
	; BX has initial AX value
	SVC	SVC_DEMENTRYDOSAPP

        call    DOCLI
	mov	BYTE PTR InDos,0	; SS Override

	ASSUME	SS:NOTHING

	mov	SS,AX			; set up user's stack
	mov	SP,DI			; and SP
        sti                             ; took out DOSTI as sp may be bad
	push	DS			; fake long call to entry
	push	SI
	mov	ES,DX			; set up proper seg registers
	mov	DS,DX
	mov	AX,BX			; set up proper AX
	retf



;-------------------------------------------------------------------------
;
; M003:
;
; If an int 21 ah=25 call is made immediately after an exec call, DOS will
; come here, turn A20 OFF restore user stack and registers before returning
; to user. This is done in dos\msdisp.asm. This has been done to support
; programs complied with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for
; more info.	
;
; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that
; SS is also DOS stack. It is important that we do the XMS call on DOS's
; stack to avoid additional stack overhead for the user.
;
; -------------------------------------------------------------------------
public	disa20_iret
disa20_iret:

	assume	ds:DOSDATA

	call	XMMDisableA20
	dec	InDos
	mov	SS,User_SS		; restore user stack
	mov	SP,User_SP
	mov	BP,SP
	mov	BYTE PTR [BP.User_AX],AL
	mov	AX,Nsp
	mov	User_SP,AX
	mov	AX,Nss
	mov	User_SS,AX

	pop	AX			; restore user regs
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS
        pop     ES

ifdef NTVDMDBG
	SVC	SVC_DEMDOSDISPRET
endif
        jmp     DOIRET

	assume	ds:NOTHING

;*****************************************************************************
;***	XMMDisableA20 - switch 20th address line			
;									
;	This routine is used to disable the 20th address line in 	
;	the system using XMM calls.					
;									
;	ENTRY	none		;ds = _DATA				
;	EXIT	A20 line disabled					
;	USES	NOTHING					
;									
;*****************************************************************************


XMMDisableA20	proc	near

	push	bx
	push	ax
	mov	ah, XMM_LOCAL_DISABLE_A20
	call	cs:[XMMcontrol]
	pop	ax
	pop	bx
	ret

XMMDisableA20	endp


; The entry point in the BIOS XMS driver is defined here.
public	XMMcontrol
	XMMcontrol	DD	?


;---------------------------------------------------------------------------
;
;***	EnsureA20ON - Ensures that A20 is ON
;									
;	This routine is used to query the A20 state in		 	
;	the system using XMM calls.					
;									
;	ENTRY: none		
;
;	EXIT : A20 will be ON
;		
;									
; 	USES : NONE								
;									
;---------------------------------------------------------------------------


LowMemory   label   dword		; Set equal to 0000:0080
	dw	00080h
	dw	00000h

HighMemory  label   dword
	dw	00090h			; Set equal to FFFF:0090
	dw	0FFFFh

; sudeepb 07-Dec-1992 Created WEnsureA20ON so that costly pushf/popf

; can be avoided in those entry points which dont care for flags


EnsureA20ON     proc    near
	pushf
        call    WEnsureA20ON
        popf
        ret
EnsureA20ON     endp

WEnsureA20ON    proc    near

	push    ds
	push	es
	push	cx
	push	si
	push	di

	lds	si,cs:LowMemory     	; Compare the 4 words at 0000:0080
	les	di,cs:HighMemory    	; with the 4 at FFFF:0090
	mov	cx,4
	cld
	repe    cmpsw

	jz	EA20_OFF

EA20_RET:

	pop	di
	pop	si
	pop	cx
	pop	es
	pop	ds
	ret

EA20_OFF:

	;
	; We are going to do the XMS call on the DOS's AuxStack. NOTE: ints
	; are disabled at this point.
	;

	push	bx
	push	ax

	mov	ax, ss			; save user's stack pointer
	mov	cs:[SS_Save],ax
	mov	cs:[SP_Save],sp
	mov	ax, cs
	mov	ss, ax
	mov	sp, OFFSET DOSDATA:AuxStack
					; ss:sp -> DOSDATA:AuxStack
	
	mov	ah, XMM_LOCAL_ENABLE_A20
	call	cs:[XMMcontrol]
	or	ax, ax
	jz	XMMerror		; AX = 0 fatal error


	mov	ax, cs:[SS_Save]	; restore user stack
	mov	ss, ax
	mov	sp, cs:[SP_Save]

	pop	ax
	pop	bx

	jmp	short EA20_RET


WEnsureA20ON    endp


ifndef NEC_98
XMMerror:				; M006 - Start

	mov	ah, 0fh			; get video mode
	int	10h
	cmp	al, 7			; Q: are we an MDA
	je	XMMcont			; Y: do not change mode
	xor	ah, ah			; set video mode
	mov	al, 02h			; 80 X 25 text
	int	10h
XMMcont:
	mov	ah, 05h			; set display page
	xor	al, al			; page 0
	int	10h
	
	mov	si, offset XMMERRMSG
	push	cs
	pop	ds
	cld				; clear direction flag

XMMprnt:
	lodsb
	cmp	al, '$'			; indicates end of XMMERRMSG
	jz	XMMStall		; function 0eh	
	mov	ah, 14
	mov	bx, 7
	int	10h
	jmp	short XMMprnt
	
XMMStall:
        call    DOSTI                   ; allow the user to warm boot
	jmp	XMMStall		; M006 - End
else    ;NEC_98
	extrn	XMMerr:near

XMMerror:
	jmp	XMMerr			;  can't locate this code in this source
					;   or code will be corrupted by ORG!!!
endif   ;NEC_98



ifdef NEC_98
;
;This has been put in for WIN386 2.XX support. The format of the instance
;table was different for this. Segments will be patched in at init time.
;
public  OldInstanceJunk
OldInstanceJunk	dw	70h	;segment of BIOS
		dw	0	;indicate stacks in SYSINIT area
		dw	6	;5 instance items

		dw	0,offset dosdata:contpos, 2
		dw	0,offset dosdata:bcon, 4
		dw	0,offset dosdata:carpos,106h
		dw	0,offset dosdata:charco, 1
		dw	0,offset dosdata:exec_init_sp, 34               ;M032
		dw	070h,offset BData:altah, 1	 ; altah byte in bios
endif   ;NEC_98



; M021-
;
; DosHasHMA - This flag is set by seg_reinit when the DOS actually
; 	takes control of the HMA.  When running, this word is a reliable
;	indicator that the DOS is actually using HMA.  You can't just use
;	CS, because ROMDOS uses HMA with CS < F000.

public	DosHasHMA
	DosHasHMA		db	0

public	fixexepatch, RationalPatchPtr
	fixexepatch		dw	?		; M012
	RationalPatchPtr 	dw	?		; M012

; End M021


;
; M020 Begin
;
		public	RatBugCode
RatBugCode	proc	far
		push	cx
		mov	cx, word ptr ds:[10h]
		loop	$
		pop	cx
		ret
RatBugCode	endp
;
; M020 End
;

	
public	UmbSave1			; M023
UmbSave1	db	0bh dup (?)	; M023

public	Mark3
	Mark3	label byte

IF2
	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
	.ERR
		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
	ENDIF
ENDIF

;############################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
;
; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
; data variable that is to be added to DOSDATA must go in between Mark3
; COUNTRY_CDPG if it can.
;
; MARK3 SHOULD NOT BE > 122AH
;
; As of 9/6/90, this area is FULL!
;
;############################################################################

	ORG	0122ah

; The following table is used for DOS 3.3
;DOS country and code page information is defined here for DOS 3.3.
;The initial value for ccDosCountry is 1 (USA).
;The initial value for ccDosCodepage is 850.
;
;
		   PUBLIC  UCASE_TAB,FILE_UCASE_TAB,DBCS_TAB
		   PUBLIC  FILE_CHAR_TAB,COLLATE_TAB

PUBLIC	COUNTRY_CDPG

;
; country and code page infomation
;
COUNTRY_CDPG  label  byte

	 db   0,0,0,0,0,0,0,0	      ; reserved words
	 db   '\COUNTRY.SYS',0        ; path name of country.sys
	 db   51 dup (?)
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
  ifdef	  JAPAN
	 dw   932		      ; system code page id (JAPAN)
  endif
  ifdef KOREA
	 dw   949
  endif
  ifdef TAIWAN
	 dw   950
  endif
  ifdef PRC
	 dw   936
  endif
else
	 dw   437		      ; system code page id
endif
; ------------------------------------------------<MSKK01>----------------------
	 dw   6 		      ; number of entries
	 db   SetUcase		      ; Ucase type
	 dw   OFFSET DOSDATA:UCASE_TAB    ;pointer to upper case table
	 dw   0 			   ; segment of poiter
	 db   SetUcaseFile	      ; Ucase file char type
	 dw   OFFSET DOSDATA:FILE_UCASE_TAB	;pointer to file upper case table
	 dw   0 			   ; segment of poiter
	 db   SetFileList	      ; valid file chars type
	 dw   OFFSET DOSDATA:FILE_CHAR_TAB   ;pointer to valid file char tab
	 dw   0 			   ; segment of poiter
	 db   SetCollate	      ; collate type
	 dw   OFFSET DOSDATA:COLLATE_TAB  ;pointer to collate table
	 dw   0 			   ; segment of poiter
	 db   SetDBCS		      ;AN000; DBCS Ev			  2/12/KK
	 dw   OFFSET DOSDATA:DBCS_TAB ;AN000;;pointer to DBCS Ev table   2/12/KK
	 dw   0 		       ;AN000; segment of poiter	 2/12/KK
	 db   SetCountryInfo	      ; country info type
	 dw   NEW_COUNTRY_SIZE	      ; extended country info size
; ------------------------------------------------<MSKK01>----------------------
ifdef	DBCS
  ifdef	  JAPAN
	 dw   81 		      ; <MSKK01> JAPAN country id
	 dw   932		      ; <MSKK01> JAPAN system code page id
	 dw   2 		      ; <MSKK01> date format (YMD)
	 db   '\',0,0,0,0             ; <MSKK01> currency symbol (YEN)
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0                   ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
	 db   0 		      ; <MSKK01> # of digit in currency
	 db   1 		      ; <MSKK01> time format (HR24)
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
  endif
  ifdef	  PRC
	 dw   86		      ; PRC country id
	 dw   936		      ; PRC system code page id
	 dw   0 		      ; date format (MDY)
	 db   '\',0,0,0,0	      ; currency symbol
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0                   ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
	 db   2 		      ; # of digit in currency
	 db   1 		      ; time format (HR24)
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
  endif
  ifdef	  TAIWAN
	 dw   88		      ; TAIWAN country id
	 dw   950		      ; TAIWAN system code page id
	 dw   0 		      ; date format (MDY)
	 db   'N','T','$',0,0	      ; currency symbol
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0                   ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
	 db   2 		      ; # of digit in currency
	 db   1 		      ; time format (HR24)
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
  endif
  ifdef   KOREA
         dw   82                      ; <MSCH> KOREA country id
         dw   949                     ; <MSCH> KOREA system code page id
         dw   2                       ; <MSCH> date format (YMD)
         db   '\',0,0,0,0             ; <MSCH> currency symbol (WON)
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0                   ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
         db   0                       ; <MSCH> # of digit in currency
         db   1                       ; <MSCH> time format (HR24)
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
  endif
else
	 dw   1 		      ; USA country id
	 dw   437		      ; USA system code page id
	 dw   0 		      ; date format
	 db   '$',0,0,0,0             ; currency symbol
	 db   ',',0                   ; thousand separator
	 db   '.',0                   ; decimal separator
	 db   '-',0		      ; date separator
	 db   ':',0                   ; time separator
	 db   0 		      ; currency format flag
	 db   2 		      ; # of digit in currency
	 db   0 		      ; time format
	 dw   OFFSET DOSDATA:MAP_CASE	;mono case routine entry point
	 dw   0 			; segment of entry point
	 db   ',',0                    ; data list separator
	 dw   0,0,0,0,0 	       ; reserved
endif
; ------------------------------------------------<MSKK01>----------------------

ifndef NEC_98
;
;This has been put in for WIN386 2.XX support. The format of the instance
;table was different for this. Segments will be patched in at init time.
;
public  OldInstanceJunk
OldInstanceJunk	dw	70h	;segment of BIOS
		dw	0	;indicate stacks in SYSINIT area
		dw	6	;5 instance items

		dw	0,offset dosdata:contpos, 2
		dw	0,offset dosdata:bcon, 4
		dw	0,offset dosdata:carpos,106h
		dw	0,offset dosdata:charco, 1
		dw	0,offset dosdata:exec_init_sp, 24
		dw	070h,offset BData:altah, 1	 ; altah byte in bios
endif   ;NEC_98





include	msdos.cl2			; XMMERRMSG

    PUBLIC  vheVDM
vheVDM	db  (size vhe_s) dup (0)

    PUBLIC  SCS_COMSPEC
SCS_COMSPEC	db	64 dup (?)	; Buffer for %COMSPEC% /z

    PUBLIC  SCS_CMDTAIL
SCS_CMDTAIL	db	128 dup (?)	; Buffer for Command Tail
IF 2
.errnz SCS_CMDTAIL-SCS_COMSPEC-64
ENDIF

    PUBLIC  SCS_PBLOCK
SCS_PBLOCK	db	14 dup (?)	; Buffer for parameter block
IF 2
.errnz SCS_PBLOCK-SCS_CMDTAIL-128
ENDIF

    PUBLIC  SCS_ToSync			; TRUE after receiving a new command
SCS_ToSync db	0			; from scs.
IF 2
.errnz SCS_ToSync-SCS_PBLOCK-14
ENDIF

    PUBLIC SCS_TSR
SCS_TSR    db	0

    PUBLIC  SCS_Is_Dos_Binary
SCS_Is_Dos_Binary db	    0

    PUBLIC  SCS_CMDPROMPT
SCS_CMDPROMPT  db           0

    PUBLIC  SCS_DOSONLY
SCS_DOSONLY  db           0

    PUBLIC  SCS_FDACCESS
	 EVEN
SCS_FDACCESS	dw	    0

include dpb.inc

    PUBLIC FAKE_NTDPB
FAKE_NTDPB db (size DPB) dup (0)

; This and NetCDS data structures are used by NT DOSEm for redirected drives.
ifdef	  JAPAN
	I_am	NetCDS,curdirLen_JPN	; CDS for redirected drives
else
	I_am	NetCDS,curdirLen	; CDS for redirected drives
endif



;; williamh, moved from dostab.asm because it broke MARK3
;smr; moved from TABLE segment in exec.asm

EXEC_NEWHEADER_OFFSET	    equ     03Ch

	I_am	exec_init_SP,WORD
	I_am	exec_init_SS,WORD
	I_am	exec_init_IP,WORD
	I_am	exec_init_CS,WORD

	I_am	exec_signature,WORD	; must contain 4D5A  (yay zibo!)
	I_am	exec_len_mod_512,WORD	; low 9 bits of length
	I_am	exec_pages,WORD		; number of 512b pages in file
	I_am	exec_rle_count,WORD	; count of reloc entries
	I_am	exec_par_dir,WORD	; number of paragraphs before image
	I_am	exec_min_BSS,WORD	; minimum number of para of BSS
	I_am	exec_max_BSS,WORD	; max number of para of BSS
	I_am	exec_SS,WORD		; stack of image
	I_am	exec_SP,WORD		; SP of image
	I_am	exec_chksum,WORD	; checksum  of file (ignored)
	I_am	exec_IP,WORD		; IP of entry
	I_am	exec_CS,WORD		; CS of entry
	I_am	exec_rle_table,WORD	; byte offset of reloc table

	public	Exec_header_len
Exec_header_len	EQU $-Exec_Signature					;PBUGBUG
	db	(EXEC_NEWHEADER_OFFSET - Exec_header_len) dup(?)

	I_am	exec_NE_offset, WORD
	public Exec_header_len_NE
Exec_header_len_NE  equ EXEC_NEWHEADER_OFFSET + 2
;smr; eom





ifdef NTVDMDBG
    PUBLIC SCS_ISDEBUG
SCS_ISDEBUG db	0
endif

        include doswow.inc
        EVEN
        PUBLIC DosWowDataStart
DosWowDataStart     Label word
        DOSWOWDATA <OFFSET DOSDATA:CDSCOUNT,OFFSET DOSDATA:CDSADDR,     \
                    OFFSET DOSDATA:NetCDS,                              \
                    OFFSET DOSDATA:CURDRV,OFFSET DOSDATA:CurrentPDB,    \
                    OFFSET DOSDATA:DrvErr,OFFSET DOSDATA:EXTERR_LOCUS,  \
                    OFFSET DOSDATA:SCS_ToSync, OFFSET DOSDATA:sfTabl,   \
                    OFFSET DOSDATA:EXTERR, OFFSET DOSDATA:EXTERR_ACTION>

DOCLI:
    FCLI
    ret

DOSTI:
    FSTI
    ret

DOIRET:
    FIRET

DOSDATA	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\msbdata.inc ===
; MSBDATA.INC
;
; This file defines some locations in the BIOS data segment that are
; accessed by code outside the BIOS, e.g. by the DOS and by the ROMDOS
; loader.
;


	ifndef	In_Bios		; if we're actually running in the BIOS,
;				;  then our segment is already open and
;				;  we'll actually generate code

ifndef NEC_98
Bdata	segment at 70h
	assume	cs:Bdata
	org	3		; fixed location in Bios_Data segment
else    ;NEC_98
Bdata	segment at 60h
	assume	cs:Bdata
	org	23h		; fixed location in Bios_Data segment
endif   ;NEC_98
int_2f	=	0		; define dummy so msbdata will assemble

	endif

	public	dosdatasg
DosDataSg dw	0		; Let DOS find it's data segment through here
				; Note: this value is set by the ROMDOS loader
				; to tell where the DOS data and init code
				; has been loaded into RAM


;	dos's int 2f handler will exit via a jump through here.  This is
;	  how the BIOS hooks int2f
	
	public	bios_i2f	; M012
bios_i2f proc	far
;	jmp	int_2f		; assembler won't generate forward
;				;  reference to a far label
	db	0eah
	dd	int_2f		; generate manual far jump
bios_i2f endp

	public	romstartaddr
romstartaddr	dw	0	; The start address for the romfind routines
				; is obtained from here (70:A)

; This is a byte used for special key handling in the resident
; console device driver.  It must be here so that it can be included
; in the WIN386 instance table (in INC\LMSTUB.ASM).

	public	altah

altah		db	0	;special key handling


	ifndef	In_Bios
Bdata	ends
	endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\msdata2.asm ===
;	SCCSID = @(#)ibmdata.asm	1.1 85/04/10
;
; DATA Segment for DOS
;

.xlist
.xcref
include dosseg.inc
include dossym.inc
include version.inc
include mssw.asm
INCLUDE SF.INC
INCLUDE CURDIR.INC
INCLUDE DPB.INC
INCLUDE ARENA.INC
INCLUDE VECTOR.INC
INCLUDE DEVSYM.INC
INCLUDE PDB.INC
INCLUDE FIND.INC
INCLUDE MI.INC
.cref
.list

TITLE   IBMDATA - DATA segment for DOS
NAME    IBMDATA

installed = TRUE

include msdata.asm
include msinit.asm
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\mft.inc ===
BREAK   <MFT Definitions>

;**     MSDOS MFT definitions
;
;   The Master File Table (MFT) associates the cannonicalized pathnames, lock
;   records and SFTs for all files open on this machine.
;
;   The MFT implementation employs a single memory buffer which is used from
;   both ends.  This gives the effect (at least until they run into each
;   other) of two independent buffers.
;
;       MFT buffer
;       ==========
;   The MFT buffer contains MFT name records and free space.  It uses a
;   classic heap architecture:  freed name records are marked free and
;   conglomerated with any adjacent free space.  When one is to create a name
;   entry the free list is searched first-fit.  The list of name and free
;   records is always terminated by a single END record.
;
;       LOCK buffer
;       ===========
;   The lock buffer contains fixed format records containing record locking
;   information.  Since they are fixed format the space is handled as a series
;   of chains:  one for each MFT name record and one for the free list.  No
;   garbage collection is necessary.
;
;       Space allocation
;       ================
;   The MFT is managed as a heap.  Empty blocks are allocated on a first-fit
;   basis.  If there is no single large enough empty block the list is garbage
;   collected.
;
;       MFT name records:
;
;              8     16     8     16     32     16        n
;           |------|-----|-----|------|------|------|---------~~~~~~---------|
;           | FLAG | LEN | SUM | LPTR | SPTR | SERL |     <.asciz string>    |
;           --------------------------------------------------~~~~~~----------
;
;                       FLAG = record type flag
;                       LEN =  total byte length of record.
;                       SUM =  sum of bytes in asciz string.  Used to speed
;                              searches
;                       LPTR=  pointer to first record in lock chain segment
;                              is MFT segment
;                       SPTR= pointer to first sft in sft chain
;                       SERL= serial number
;                       <string> = name string, zero-byte terminated.  There
;                              may be garbage bytes following the 00 byte;
;                              these are counted in the LEN field.
;
;
;       MFT free records
;
;              8      16
;           |------|-----|----~~~~~~~~~~~~~~~~~~~~~~~~~~~---------|
;           | FLAG | LEN |         free                           |
;           ------------------~~~~~~~~~~~~~~~~~~~~~~~~~~~----------
;
;                       FLAG = record type flag
;                       LEN  = total byte length of record.
;
;
;       MFT END records
;
;                  8
;               |------|
;               | FLAG |
;               --------
;
;                       FLAG = record type flag

;**     MFT definitions
;*
;*      NOTE:  the flag and length fields are identical for all record types
;*              (except the END type has no length) This must remain so as
;*              some code depends upon it.
;*
;*      NOTE:  Many routines check for "n-1" of the N flag values and if no
;*              match is found assume the flag value must be the remaining
;*              possibility.  If you add or remove flag values you must check
;*              all references to mft_flag.

MFT_entry       STRUC

mft_flag        DB      ?               ; flag/len field
mft_len         DW      ?
mft_sum         DB      ?               ; string sum word
mft_lptr        DW      ?               ; LCK pointer
mft_sptr        DD      ?               ; sft pointer
mft_serl        DW      ?               ; serial number
mft_name        DB      ?               ; offset to start of name

MFT_entry       ENDS

MFLG_NAM        EQU     1               ; min value for name record
MFLG_FRE        EQU     0               ; free record
MFLG_END        EQU     -1              ; end record

;*      Record Lock Record (RLR):
;
;                  16       32       32       32
;               |-------|--------|--------|--------|
;               | NEXT  |  FBA   |  LBA   |  SPTR  |
;               |       | lo hi  | lo hi  |        |
;               ------------|--------|--------------
;
;                       CHAIN  = pointer to next RLR.  0 if end
;                       FBA    = offset of 1st  byte of locked region
;                       LBA    = offset of last byte of locked region
;                       SPTR   = pointer to SFT lock was issued on

RLR_entry       STRUC

rlr_next        DW      ?               ; chain to next RLR, 0 if end
rlr_fba         DW      ?               ; first byte addr (offset) of reigion
                DW      ?
rlr_lba         DW      ?               ; last byte addr of region
                DW      ?
rlr_sptr        DD      ?               ; SFT pointer
rlr_pid         dw      ?               ; process id of issuer
rlr_type        dw      ?               ; lock type
RLR_entry       ENDS

rlr_lall        equ     00h            ; lock all ops
rlr_lwr         equ     01h            ; lock write ops

;
;   A pictorial diagram for the linkages is as follows:
;
;          +---sptr------+
;          V             |
;        +---+<----------|---sptr------+------------+
;        |SFT+----+      |             |            |
;        +-+-+    |    +-+-+        +--+-+       +--+-+
;          V      +--->|MFT+-lptr->-|LOCK+-next->|LOCK+->0
;        +---+    |    +---+        +----+       +----+
;        |SFT+----+      ^
;        +-+-+           |
;          |             |
;          +-------------+
;
;

;**
;
;   Interesting behavior should be noted:
;
;       The sharer must maintain information on files in three forms:
;
;       local/remote handles.  These are normal handles and behave in no
;           strange manner.  They are identified by SF_mode not having the
;           sfIsFCB flag nor by having the sf_mode = 70.  No problems with
;           locking.  No problems with open.  No problems with close.
;           CloseByName will iterate closes until the mft disappears.
;           CloseUser will iterate closes until no SFT for the particular user
;           appears.  CloseProcess will iterate closes until no SFT for the
;           particular user/process appears.
;
;       local FCBs.  There are no corresponding SFT's for these as the SFTs
;           are cached but will be valid for the particular file.  There is
;           one SFT for each open on a file by a specific process.  These are
;           identified the sfIsFCB flag in the sf_mode field.  When multiple
;           opens occur, we merely find the sf pertinent to the file and
;           process.  Close decrements the ref count.  CloseByName, CloseUser,
;           CloseProcess will iterate closes until no more SFTs exist.
;
;       handles with mode 70.  These represent FCB's open across the network.
;           As such, identical sfts may have been collapsed by the $open code.
;           This results in a reuse of the same SFT.  The $Open code must
;           correctly set the ref-count for the sft to reflect the number of
;           collapses that have occurred.  These are identified by a 70 in the
;           SF_mode field.  There can be no locking on these SFTs.  Open must
;           scan the list of SFTs for the file and increment its ref count
;           appropriately.

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\mstable.asm ===
;	SCCSID = @(#)ibmtable.asm	1.1 85/04/10
;
; Table Segment for DOS
;

.xlist
.xcref
include version.inc
include mssw.asm
.cref
.list

TITLE	IBMTABLE - Table segment for DOS
NAME	IBMTABLE

include ms_table.asm
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\mshead.asm ===
; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
PAGE


; NTDOS.SYS entry point.
;
; Modification History
;
; sudeepb  06-Mar-1991	Ported for DOSEm.

include origin.inc


Break <SEGMENT DECLARATIONS>

; The following are all of the segments used.  They are declared in the order
; that they should be placed in the executable

;
; segment ordering for MSDOS
;

include dosseg.inc

AsmVar	<Installed>


DOSCODE		SEGMENT BYTE PUBLIC 'CODE'

PUBLIC	$STARTCODE
$STARTCODE	LABEL WORD

	ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

; the entry point at initialization time will be to right here.
; A jump will be made to the initialization code, which is at
; the end of the code segment.	Also, a word here (at offset 3)
; contains the offset within the DOSCODE segment of the beginning of the
; DOS code.
;

	Extrn	DOSINIT:NEAR

	JMP	near ptr DOSINIT

; The next word contains the ORG value to which the DOS has been ORGd
; See origin.inc for description.

	dw	PARASTART	; For BIOS to know the ORG value


; Segment address of BIOS data segment in RAM
	PUBLIC	BioDataSeg
ifndef NEC_98
BioDataSeg	dw	70h		;Bios data segment fixed at 70h
else    ;NEC_98
BioDataSeg	dw	60h		;Bios data segment fixed at 60h
endif   ;NEC_98


;
; DosDSeg is a data word in the DOSCODE segment that is loaded with
; the segment address of DOSDATA.  This is purely an optimization, that
; allows getting the DOS data segment without going through the 
; BIOS data segment.  It is used by the "getdseg" macro.
;

		public	DosDSeg
DosDSeg		dw	?

DOSCODE		ENDS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\msgdcl.inc ===
; This Macro was removed from sysmsg.inc. We had to remove this
; macro and put it into it's own include file in order to clear up
; some assembly errors. MS MASM will not allow a public declaration
; during the second pass of the assembler. IBM MASM will allow this.
;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	$M_DECLARE	     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;
$M_DECLARE    macro	numcls	       ;
   $M_DCOUNT = 0		       ;
   REPT  numcls 		       ;
     $M_DCOUNT =  $M_DCOUNT + 1        ;
     $M_DECLARE2  %$M_DCOUNT	       ;
   ENDM 			       ;

  IF COMR
    IFNDEF $M_RT2			;  If Resident table is not in this assembly,
	EXTRN	$M_RT2:BYTE		;     Must be external
    ELSE
	PUBLIC	$M_RT2
    ENDIF				;
  ELSE
    IFNDEF $M_RT			;  If Resident table is not in this assembly,
	EXTRN	$M_RT:BYTE		;     Must be external
    ELSE
	PUBLIC	$M_RT
    ENDIF				;
  ENDIF

  $M_CHECK $M_GET_MSG_ADDRESS	      ;  If this subroutine is not in this assembly,
  $M_CHECK $M_MSGSERV_1 	      ;  If this subroutine is not in this assembly,
  $M_CHECK $M_MSGSERV_2 	      ;  If this subroutine is not in this assembly,

ENDM				       ;
				       ;
$M_DECLARE2   macro   innum	       ;
  IF NOT COMR			       ; IF Not resident COMMAND.COM
    IF NOT COMT 			 ; IF Not transient COMMAND.COM
      IFNDEF  $M_CLS_&innum		 ; IF class is not in this assembly,
	IF	FARmsg			 ;
	  EXTRN   $M_CLS_&innum:FAR	 ;    Must be external
	ELSE				 ;
	  EXTRN   $M_CLS_&innum:NEAR	 ;    Must be external
	ENDIF				 ;
      ELSE				 ; ELSE
	PUBLIC	$M_CLS_&innum		 ;    Label PUBLIC
      ENDIF				 ;
    ELSE				 ; ELSE
      IFDIF  <$M_CLS_&innum>,<$M_CLS_1>  ; IF NOT $M_CLS_1 or
	IFDIF <$M_CLS_&innum>,<$M_CLS_2> ;   IF NOT $M_CLS_2 then
	  IFNDEF  $M_CLS_&innum 	 ;     IF class is not in this assembly,
	    IF	    FARmsg		 ;
	      EXTRN   $M_CLS_&innum:FAR  ;	 Must be external
	    ELSE			 ;
	      EXTRN   $M_CLS_&innum:NEAR ;	 Must be external
	    ENDIF			 ;
	  ELSE				 ;     ELSE
	    PUBLIC  $M_CLS_&innum	 ;	 Label PUBLIC
	  ENDIF 			 ;
	ENDIF				 ;
      ENDIF				 ;
    ENDIF				 ;
  ELSE					 ; ELSE
    IFDIF  <$M_CLS_&innum>,<$M_CLS_1>	 ; IF NOT $M_CLS_1 or
      IFDIF <$M_CLS_&innum>,<$M_CLS_2>	 ;   IF NOT $M_CLS_2 then
	IFNDEF	$M_CLS_&innum		 ;     IF class is not in this assembly,
	  IF	  FARmsg		 ;
	    EXTRN   $M_CLS_&innum:FAR	 ;	 Must be external
	  ELSE				 ;
	    EXTRN   $M_CLS_&innum:NEAR	 ;	 Must be external
	  ENDIF 			 ;
	ELSE				 ;     ELSE
	  PUBLIC  $M_CLS_&innum 	 ;	 Label PUBLIC
	ENDIF				 ;
      ENDIF				 ;
    ENDIF				 ;
  ENDIF 			       ;
ENDM				       ;
				       ;
$M_CHECK      macro   parm	       ;
  IFNDEF  parm			       ; IF class is not in this assembly,
    IF	    FARmsg		       ;
      EXTRN   parm:FAR		       ;    Must be external
    ELSE			       ;
      EXTRN   parm:NEAR 	       ;    Must be external
    ENDIF			       ;
  ELSE
    IF COMR
    ELSE
      PUBLIC parm
    ENDIF
  ENDIF 			       ;
ENDM				       ;
				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;
IF1				       ;
  $M_DECLARE %$M_NUM_CLS	       ;  Declare any class not in this assembly
ENDIF				       ;
				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\msghan.inc ===
IF1			;AN000;
                     ;%OUT INCLUDING MSGHAN.INC...;AN000;
	       ENDIF			;AN000;
;THIS IS A COMMONLY INCLUDED FILE, USED BY (AT LEAST) THE FOLLOWING COMPONENTS:
;TREE, GRAFTABL, DISKCOMP, DISKCOPY, COMP - WRITTEN OR Revised BY E.K.

;		VALUES FOR THE MSG_DESC CONTROL BLOCK
ONE_SUBS       EQU   1		   ;AN000;ONE VARIABLE FIELD IN MESSAGE
TWO_SUBS       EQU   2		   ;AN000;TWO VARIABLE FIELDS IN MESSAGE
THREE_SUBS     EQU   3		   ;AN000;THREE VARIABLE FIELDS IN MESSAGE
CLASS_1        EQU   EXT_ERR_CLASS ;AN000;CLASS 1 (DOS EXTENDED ERRORS)
CLASS_2        EQU   PARSE_ERR_CLASS ;AN000;CLASS 2 (PARSE ERRORS)
CLASS_A        EQU   UTILITY_MSG_CLASS ;AN000;CLASS A TYPE MESSAGE

;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

MSG_DESC	  STRUC 	   ;AN000;
MSG_NUM 	  DW	0	   ;AN000;MESSAGE NUMBER (TO AX)
MSG_HANDLE	  DW	STDOUT	   ;AN000;HANDLE OF OUTPUT DEVICE (TO BX)
MSG_SUBLIST	  DW	0	   ;AN000;POINTER TO SUBLIST (TO SI)
MSG_COUNT	  DW	0	   ;AN000;SUBSTITUTION COUNT (TO CX)
MSG_CLASS	  DW	CLASS_A SHL 8 ;AN000;MESSAGE CLASS (IN HIGH BYTE, TO DH)
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
MSG_DESC	  ENDS		   ;AN000;

;		VALUES FOR THE SUBLIST CONTROL BLOCK
PC_ID_0        EQU   0		   ;AN000;ID OF " - " TRAILER TO MESSAGE
PC_ID_1        EQU   1		   ;AN000;ID OF PERCENT VARIABLE FIELD
PC_ID_2        EQU   2		   ;AN000;ID OF PERCENT VARIABLE FIELD
PC_ID_3        EQU   3		   ;AN000;ID OF PERCENT VARIABLE FIELD
MAX_0	       EQU   0		   ;AN000;MAXIMUM WIDTH OF STRING FIELD (0=NO LIMIT)
MIN_1	       EQU   1		   ;AN000;MINIMUM WIDTH OF STRING FIELD
PAD_BLK        EQU   " "           ;AN000;CHAR FOR PAD FIELD
FILL_OFF       EQU   0		   ;AN000;TO BE REPLACED WITH ACTUAL OFFSET
FILL_SEG       EQU   0		   ;AN000;TO BE REPLACED WITH ACTUAL SEG ID

;THIS SUBLIST CONTROL BLOCK, POINTED TO BY SI WHEN SYSDISPMSG IS CALLED
;FURTHER DESCRIBES THE MESSAGE AND THE VARIABLE FIELDS THE MSG MAY CONTAIN.
;THERE IS ONE OF THESE CONTROL BLOCKS PER VARIABLE FIELD.  ADDITIONAL
;VARIABLE FIELDS ARE DEFINED IN ADDITIONAL "SUBLIST" CONTROL BLOCKS,
;CONSECUTIVE AND CONTIGUOUS WITH THIS ONE.  THE NUMBER OF THESE CONTROL
;BLOCKS IS THE SUBSTITUTION COUNT, PASSED IN CS TO SYSDISPMSG, AS DEFINED
;IN THE ABOVE "MSC_DESC" CONTROL BLOCK.

SUBLIST 	  STRUC 	;AN000;
SUB_SIZE	  DB	11	;AN000;SUBLIST SIZE (POINTER TO NEXT SUBLIST)
SUB_RES 	  DB	0	;AN000;RESERVED
				;NEXT FIELD IS TO BE USED AS A DOUBLE WORD
SUB_VALUE	  DW	0	;AN000;TIME, DATE, OR PTR TO DATA ITEM
SUB_VALUE_SEG	  DW	0	;AN000;SEG ID OF PTR
				;(ABOVE FIELD MUST BE FILLED AT EXECUTION TIME
				; IF THIS IS A .COM FILE)
SUB_ID		  DB	0	;AN000;N OF %N
SUB_FLAGS	  DB	0	;AN000;DATA TYPE FLAGS
SUB_MAX_WIDTH	  DB	MAX_0	;AN000;MAXIMUM FIELD WIDTH (0=UNLIMITED)
SUB_MIN_WIDTH	  DB	0	;AN000;MINIMUM FIELD WIDTH
SUB_PAD_CHAR	  DB	PAD_BLK ;AN000;CHARACTER FOR PAD FIELD
				; CAN BE " ", "0" OR ",".
				; "," CAUSES INSERTION OF THE ACTIVE
				; THOUSANDS SEPARATOR BETWEEN EVERY 3 DIGITS.
SUBLIST 	  ENDS		;AN000;

;		  BITS DEFINED FOR SUB_FLAGS ABOVE
;			FORMAT = A0SSTTTT
;				 ++ + +--- FIELD TYPE
;				 || +--- DATA VARIABLE SIZE
;				 |+--- RESERVED, MUST BE ZERO
;				 +--- ALIGNMENT INDICATOR
SF_BITS     RECORD F_ALIGN:1,F_RES:1=0,F_SIZE:2,F_TYPE:4;AN000;

;		F_ALIGN FIELD, ALIGNMENT INDICATOR
SF_LEFT 	  EQU	0	   ;AN000;LEFT ALIGN
SF_RIGHT	  EQU	1	   ;AN000;RIGHT ALIGN

;		F_RES FIELD, RESERVED, SHOULD BE ZERO

;		F_TYPE FIELD, FIELD TYPE
SF_CHAR 	  EQU	0000B	   ;AN000;TYPE IS CHARACTER
;		F_SIZE FIELD,
SF_CH		  EQU	00B	   ;AN000;SINGLE CHARACTER
SF_ASCIIZ	  EQU	01B	   ;AN000;ASCIIZ STRING

;		F_TYPE FIELD, FIELD TYPE
SF_UN_BD	  EQU	0001B	   ;AN000;UNSIGNED BINARY TO DECIMAL CHARACTER
;		F_SIZE FIELD,
SF_BYTE 	  EQU	01B	   ;AN000;DATA IS BYTE SIZED
SF_WORD 	  EQU	10B	   ;AN000;DATA IS WORD SIZED
SF_DWORD	  EQU	11B	   ;AN000;DATA IS DOUBLE WORD SIZED

;		F_TYPE FIELD, FIELD TYPE
SF_SIN_BD	  EQU	0010B	   ;AN000;SIGNED BINARY TO DECIMAL CHARACTER
;		F_SIZE FIELD,
;SF_BYTE	  EQU	01B	   ;DATA IS BYTE SIZED
;SF_WORD	  EQU	10B	   ;DATA IS WORD SIZED
;SF_DWORD	  EQU	11B	   ;DATA IS DOUBLE WORD SIZED

;		F_TYPE FIELD, FIELD TYPE
SF_UN_BH	  EQU	0011B	   ;AN000;UNSIGNED BINARY TO HEXADECIMAL CHARACTER
;		F_SIZE FIELD,
;SF_BYTE	  EQU	01B	   ;DATA IS BYTE SIZED
;SF_WORD	  EQU	10B	   ;DATA IS WORD SIZED
;SF_DWORD	  EQU	11B	   ;DATA IS DOUBLE WORD SIZED

;		F_TYPE FIELD, FIELD TYPE
SF_DATE 	  EQU	0100B	   ;AN000;DATE TO CHARACTER,
				   ; USING CURRENT COUNTRY FORMAT
				   ;SUB_VALUE HIGH=YEAR
				   ;SUB_VALUE LOW=MMDD
;		F_SIZE FIELD,
SF_MD		  EQU	01B	   ;AN000;MONTH AND DAY ONLY
SF_MDY2 	  EQU	10B	   ;AN000;MONTH,DAY AND YEAR (2 DIGITS)
SF_MDY4 	  EQU	11B	   ;AN000;MONTH,DAY AND YEAR (4 DIGITS)

;		F_TYPE FIELD, FIELD TYPE
SF_TIME_12	  EQU	0101B	   ;AN000;TIME TO CHARACTER, 12 HOUR FORMAT
				   ; USING CURRENT COUNTRY FORMAT
				   ;SUB_VALUE HIGH=HHMM
				   ;SUB_VALUE LOW=SSHH
;		F_SIZE FIELD,
SF_HHMM 	  EQU	00B	   ;AN000;HH:MM (ACTIVE TIME FORMAT)
SF_HHMMSS	  EQU	01B	   ;AN000;HH:MM:SS (ACTIVE TIME FORMAT)
SF_HHMMSSHH	  EQU	10B	   ;AN000;HH:MM:SS:HH

;		F_TYPE FIELD, FIELD TYPE
SF_TIME_24	  EQU	0110B	   ;AN000;TIME TO CHARACTER, 24 HOUR FORMAT
				   ; USING CURRENT COUNTRY FORMAT
				   ;SUB_VALUE HIGH=HHMM
				   ;SUB_VALUE LOW=SSHH
;		F_SIZE FIELD,
;SF_HHMM	  EQU	00B	   ;HH:MM (ACTIVE TIME FORMAT)
;SF_HHMMSS	  EQU	01B	   ;HH:MM:SS (ACTIVE TIME FORMAT)
;SF_HHMMSSHH	  EQU	10B	   ;HH:MM:SS:HH

;		THE NEXT GROUP ARE ALL CLASS "1" MESSAGES

	       PUBLIC MSGNUM_EXTERR;AN000;
MSGNUM_EXTERR  MSG_DESC <,STDERR,,,CLASS_1 SHL 8> ;AN000;ALL EXTENDED DOS ERRORS
				   ;ERROR NUMBER WILL NEED TO BE FILLED IN

;		THE NEXT GROUP ARE ALL CLASS "2" MESSAGES

	       PUBLIC MSGNUM_PARSE ;AN000;SO PARSE DRIVER CAN FIND IT
MSGNUM_PARSE   MSG_DESC <,STDERR,,,CLASS_2 SHL 8> ;AN000;ALL PARSING ERRORS
				   ;ERROR NUMBER WILL NEED TO BE FILLED IN

;		THE NEXT GROUP ARE ALL CLASS "A" MESSAGES
;		THESE ARE THE "CANNED" MESSAGES ALWAYS PRESENT

	       PUBLIC MSGNUM_VER   ;AN000;
MSGNUM_VER     MSG_DESC <1,STDERR> ;AN000;"Incorrect DOS Version"
;end of MSGHAN.INC

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\mshalo.asm ===
;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
;   there is a header that describes a block of rom program.  This header
;   contains information needed to initialize a module and to provide PCDOS
;   with a set of reserved names for execution.
;
;   This header has the following format:
;
;   rom_header	STRUC
;	Signature1  DB	55h
;	Signature2  DB	AAh
;	rom_length  DB	?		; number of 512 byte pieces
;	init_jmp    DB	3 dup (?)
;	name_list   name_struc <>
;   rom_header	ENDS
;
;   name_struc	STRUC
;	name_len    DB	?
;	name_text   DB	? DUP (?)
;	name_jmp    DB	3 DUP (?)
;   name_struc	ENDS
;
;   The name list is a list of names that are reserved by a particular section
;   of a module.  This list of names is terminated by a null name (length
;   is zero).
;
;   Consider now, the PCDOS action when a user enters a command:
;
;	COMMAND.COM has control.
;	o   If location FFFFEh has FDh then
;	o	Start scanning at C0000h, every 800h for a byte 55h followed
;		    by AAh, stop scan if we get above or = F0000H
;	o	When we've found one, compare the name entered by the user
;		    with the one found in the rom.  If we have a match, then
;		    set up the environment for execution and do a long jump
;		    to the near jump after the found name.
;	o	If no more names in the list, then continue scanning the module
;		    for more 55h followed by AAh.
;	o   We get to this point only if there is no matching name in the
;		rom.  We now look on disk for the command.
;
;   This gives us the flexibility to execute any rom cartridge without having
;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
;   want to be invisible to the DOS should not have any names in their lists
;   (i.e. they have a single null name).
;
;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
;   Clearly this version will be available on disk.  How does a user actually
;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
;   EXEC loader will execute the ROM before it even looks at the disk!	Only
;   solution:
;
;   o	Keep things consistent and force the user to have his software named
;	differently from the ROM names (BASIC1, BASIC2, etc).

rom_header  STRUC
    Signature1	DB  ?
    Signature2	DB  ?
    rom_length	DB  ?
    init_jmp	DB  3 dup (?)
    name_list	DB  ?
rom_header  ENDS

name_struc  STRUC
    name_len	DB  ?
    name_text	DB  1 DUP (?)
    name_jmp	DB  3 DUP (?)
name_struc  ENDS

ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;
; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
;
ROM_SCAN:
	PUSH	ES
	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX
	PUSH	BX
;
; check for PC Jr signature in rom
;
	MOV	AX,0F000h
	MOV	ES,AX
	CMP	BYTE PTR ES:[0FFFEh],0FDh
	JZ	SCAN_IT
NO_ROM:
	CLC
ROM_RET:
	POP	BX
	POP	AX
	POP	CX
	POP	DI
	POP	SI
	POP	ES
	RET
SCAN_IT:
;
; start scanning at C000
;
	MOV	AX,0C000h
SCAN_ONE:
	MOV	ES,AX
	XOR	DI,DI
SCAN_MODULE:
;
; check for a valid header
;
	CMP	WORD PTR ES:[DI],0AA55h
	JZ	SCAN_LIST
	ADD	AX,080h
SCAN_END:
	CMP	AX,0F000h
	JB	SCAN_ONE
	JMP	NO_ROM
;
; trundle down list of names
;
SCAN_LIST:
	MOV	BL,ES:[DI].rom_length	; number of 512-byte jobbers
	XOR	BH,BH			; nothing in the high byte
	SHL	BX,1
	SHL	BX,1			; number of paragraphs
	ADD	BX,7Fh
	AND	BX,0FF80h		; round to 2k

	MOV	DI,name_list
SCAN_NAME:
	MOV	CL,ES:[DI]		; length of name
	INC	DI			; point to name
	XOR	CH,CH
	OR	CX,CX			; zero length name
	JNZ	SCAN_TEST		; nope... compare
	ADD	AX,BX			; yep, skip to next block
	JMP	SCAN_END
;
; compare a single name
;
SCAN_TEST:
	MOV	SI,DX
	INC	SI
	REPE	CMPSB			; compare name
	JZ	SCAN_FOUND		; success!
SCAN_NEXT:
	ADD	DI,CX			; failure, next name piece
	ADD	DI,3
	JMP	SCAN_NAME
;
; found a name. save entry location
;
SCAN_FOUND:
	CMP	BYTE PTR DS:[SI],'?'
	JZ	SCAN_SAVE
	CMP	BYTE PTR DS:[SI],' '
	JNZ	SCAN_NEXT
SCAN_SAVE:
	MOV	[rom_cs],ES
	MOV	[ROM_ip],DI
	STC
	JMP	ROM_RET

;
; execute a rom-placed body of code. allocate largest block
;
ROM_EXEC:
	MOV	BX,0FFFFh
	MOV	AH,ALLOC
	INT	int_command
	MOV	AH,ALLOC
	INT	int_command
	PUSH	BX
	PUSH	AX
;
; set terminate addresses
;
	MOV	AX,(set_interrupt_vector SHL 8) + int_terminate
	PUSH	DS
	MOV	DS,[RESSEG]
	ASSUME	DS:RESGROUP
	MOV	DX,OFFSET RESGROUP:EXEC_WAIT
	INT	int_command
	MOV	DX,DS
	MOV	ES,DX
	ASSUME	ES:RESGROUP
	POP	DS
	ASSUME	DS:NOTHING
;
; and create program header and dup all jfn's
;
	POP	DX
	MOV	AH,DUP_PDB
	INT	int_command
;
; set up dma address
;
	MOV	DS,DX
	MOV	DX,080h
	MOV	AH,SET_DMA
	INT	int_command
;
; copy in environment info
;
	MOV	AX,[ENVIRSEG]
	MOV	DS:[PDB_environ],AX
;
; set up correct size of block
;
	POP	BX			; BX has size, DS has segment
	MOV	DX,DS
	ADD	DX,BX
	MOV	DS:[PDB_block_len],DX
;
; change ownership of block
;
	MOV	DX,DS
	DEC	DX
	MOV	DS,DX
	INC	DX
	MOV	DS:[arena_owner],DX
	MOV	DS,DX
;
; set up correct stack
;
	CMP	BX,1000h
	JB	GOT_STACK
	XOR	BX,BX
GOT_STACK:
	MOV	CL,4
	SHL	BX,CL
	MOV	DX,DS
	MOV	SS,DX
	MOV	SP,BX
	XOR	AX,AX
	PUSH	AX
;
; set up initial registers and go to the guy
;
	NOT	AX
	PUSH	[ROM_CS]
	PUSH	[ROM_IP]
	MOV	ES,DX
ASSUME ES:NOTHING
FOOBAR	PROC	FAR
	RET
FOOBAR	ENDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\ms_data.asm ===
;       SCCSID = @(#)msdata.asm 1.8 85/09/12

;
;----------------------------------------------------------------------------
;
; M008 : Renamed callback_ss & callback_sp to AbsRdWr_SS & AbsRdWr_SP
;	 To be used in Absolute Read/Write DISK routines
; M019 DB 10/26/90 - Disk write optimization: removed HIGH_SECTOR_TEMP.
;
;----------------------------------------------------------------------------
;
        AsmVars <Debug, Redirector, ShareF>
 
;
;smr;--- These extrns should be in DOSCODE segment
;
DOSCODE		SEGMENT	BYTE PUBLIC 'CODE'
;hkn;		extrn	ucase_tab:byte
;hkn;		extrn	file_ucase_tab:byte
;hkn;		extrn	file_char_tab:byte
;hkn;		extrn	collate_tab:byte
;hkn;		extrn	dbcs_tab:byte
;hkn;		extrn	map_case:byte

		extrn	DIVOV:near
		extrn	QUIT:near
		extrn	COMMAND:near
		extrn	ABSDRD:near
		extrn	ABSDWRT:near
		extrn	Stay_resident:near
		extrn	INT2F:near
		extrn	CALL_ENTRY:near
		extrn	IRETT:near

DOSCODE		ENDS
;
Break <Uninitialized data overlayed by initialization code>
 
DOSDATA    SEGMENT WORD PUBLIC 'DATA'
; Init code overlaps with data area below
 
;        ORG     0
PUBLIC MSDAT001S,MSDAT001E
MSDAT001S       label byte
 
        I_am    TIMEBUF,6               ; Time read from clock device
        I_am    DEVIOBUF,2              ; Buffer for I/O under file assignment
;
; The following areas are used as temp buffer in EXEC system call
;
        I_am    OPENBUF,128             ; buffer for name operations
        I_am    RenBuf,128              ; buffer for rename destination
; Buffer for search calls
        I_am    SEARCHBUF,53            ; internal search buffer
ifdef	  JAPAN
        I_am    DummyCDS,curdirLen_JPN
else
        I_am    DummyCDS,curdirLen
endif
;
; End of contiguous buffer
;
; Temporary directory entry for use by many routines.  Device directory
; entries (bogus) are built here.
;
        PUBLIC  DevFCB
DEVFCB  LABEL   BYTE                    ; Uses NAME1, NAME2, combined
; WARNING..  do not alter position of NAME1 relative to DEVFCB
; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
; as well as it is the only guy who uses NAME2 and DESTSTART.
        I_am    NAME1,12                ; File name buffer
        I_am    NAME2,13                ;
        I_am    DESTSTART,WORD          ;
        DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
;
; End Temporary directory entry.
;
        I_am    ATTRIB,BYTE             ; storage for file attributes
        I_am    EXTFCB,BYTE             ; TRUE => extended FCB in use
        I_am    SATTRIB,BYTE            ; Storage for search attributes
        I_AM    open_access,BYTE        ; access of open system call
        I_am    FoundDel,BYTE           ; true => file was deleted
        I_am    Found_dev,BYTE          ; true => search found a device
        I_am    fSplice,BYTE            ; true => do a splice in transpath
        I_am    fSharing,BYTE           ; TRUE => no redirection
        I_am    SECCLUSPOS,BYTE         ; Position of first sector within cluster
        I_am    TRANS,BYTE              ;
        I_am    READOP,BYTE             ;
        I_am    THISDRV,BYTE            ;
        I_am    CLUSFAC,BYTE            ;
        I_am    CLUSSPLIT,BYTE          ;
        I_am    INSMODE,BYTE            ; true => insert mode in buffered read
        I_am    cMeta,BYTE              ; count of meta'ed components found
        I_am    VOLID,BYTE              ;
        I_am    exit_type,BYTE          ; type of exit...
 
        EVEN
 
; WARNING - the following two items are accessed as a word
        I_am    CREATING,BYTE           ; true => creating a file
	I_am	DELALL,BYTE		; = 0 iff BUGBUG
					; = DIRFREE iff BUGBUG
        I_am    EXITHOLD,DWORD          ; Temp location for proc terminate
        I_am    user_SP,WORD            ; User SP for system call
        I_am    user_SS,WORD            ; User SS for system call
        I_am    CONTSTK,WORD            ;
        I_am    THISDPB,DWORD           ;
        I_am    CLUSSAVE,WORD           ;
        I_am    CLUSSEC,DWORD           ;>32mb                                  AC0000
        I_am    PREREAD,WORD            ; 0 means preread; 1 means optional
        I_am    FATBYT,WORD             ; Used by ALLOCATE
        I_am    FATBYTE,WORD            ; Used by $SLEAZEFUNC
        I_am    DEVPT,DWORD             ;
        I_am    THISSFT,DWORD           ; Address of user SFT
        I_am    THISCDS,DWORD           ; Address of current CDS
        I_am    THISFCB,DWORD           ; Address of user FCB
        I_am    SFN,WORD,<-1>           ; SystemFileNumber found for accessfile
        I_am    JFN,WORD                ; JobFileNumber found for accessfile
        I_am    PJFN,DWORD              ; PointerJobFileNumber found for accessfile
        I_am    WFP_START,WORD          ;
        I_am    REN_WFP,WORD            ;
        I_am    CURR_DIR_END,WORD       ;
        I_am    NEXTADD,WORD            ;
        I_am    LASTPOS,WORD            ;
        I_am    CLUSNUM,WORD            ;
        I_am    DIRSEC,DWORD            ;>32mb                                  AC0000
        I_am    DIRSTART,WORD           ;
        I_am    SECPOS,DWORD       ;>32mb Position of first sector accessed
        I_am    VALSEC,DWORD       ;>32mb Number of valid (previously written)
                                        ; sectors
        I_am    BYTSECPOS,WORD          ; Position of first byte within sector
        I_am    BYTPOS,4                ; Byte position in file of access
        I_am    BYTCNT1,WORD            ; No. of bytes in first sector
        I_am    BYTCNT2,WORD            ; No. of bytes in last sector
        I_am    SECCNT,WORD             ; No. of whole sectors
        I_am    ENTFREE,WORD            ;
        I_am    ENTLAST,WORD            ;
        I_am    NXTCLUSNUM,WORD         ;
        I_am    GROWCNT,DWORD           ;
        I_am    CURBUF,DWORD            ;
        I_am    CONSft,DWORD            ; SFT of console swapped guy.
        I_am    SaveBX,WORD             ;
        I_am    SaveDS,WORD             ;
        I_am    restore_tmp,WORD        ; return address for restore world
        I_am    NSS,WORD
        I_am    NSP,WORD
        I_am    EXTOPEN_FLAG,WORD,<0>   ;FT. extended open input flag           ;AN000;
        I_am    EXTOPEN_ON,BYTE,<0>     ;FT. extended open conditional flag     ;AN000;
        I_am    EXTOPEN_IO_MODE,WORD,<0>;FT. extende open io mode               ;AN000;
        I_am    SAVE_DI,WORD            ;FT. extende open saved DI              ;AN000;
        I_am    SAVE_ES,WORD            ;FT. extende open saved ES              ;AN000;
        I_am    SAVE_DX,WORD            ;FT. extende open saved DX              ;AN000;
        I_am    SAVE_CX,WORD            ;FT. extende open saved CX              ;AN000;
        I_am    SAVE_BX,WORD            ;FT. extende open saved BX              ;AN000;
        I_am    SAVE_SI,WORD            ;FT. extende open saved SI              ;AN000;
        I_am    SAVE_DS,WORD            ;FT. extende open saved DS              ;AN000;

;	HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
;	we used to just pass 16 bits in a register.  Now High_SECTOR holds
;	the high 16, the low 16 are still in the register.

        I_am    HIGH_SECTOR,WORD,<0>    ;>32mb higher sector #                  ;AN000;

        I_am    UU_HIGH_SECTOR_TEMP,WORD,<0> ;M019: Unused

        I_am    DISK_FULL,BYTE          ;>32mb indicating disk full when 1      ;AN000;
        I_am    TEMP_VAR,WORD           ; temporary variable for everyone       ;AN000;
        I_am    TEMP_VAR2,WORD          ; temporary variable 2 for everyone     ;AN000;
        I_am    DrvErr,BYTE             ; used to save drive error              ;AN000;
        I_am    DOS34_FLAG,WORD,<0>     ; common flag for DOS 3.4               ;AN000;
        I_am    NO_FILTER_PATH,DWORD    ; pointer to orignal path               ;AN000;
        I_am    NO_FILTER_DPATH,DWORD   ; pointer to orignal path of destination;AN000;
; M008
        I_am   AbsRdWr_SS,WORD         ; INT 25/26 user stack segment
        I_am   AbsRdWr_SP,WORD         ; INT 25/26 user stack offset
        I_am   UU_Callback_flag,BYTE,<0>  ; Unused
; M008
 
 
; make those pushes fast!!!
EVEN
StackSize   =   180h                    ; gross but effective
;;;StackSize   =   300h                    ; This is a "trial" change IBM hasn't
;;;                                        ; made up their minds about
 
;
; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
;
 
        PUBLIC  RENAMEDMA,AuxStack,DskStack,IOStack
RENAMEDMA   LABEL   BYTE                ; See DOS_RENAME
 
        DB      StackSize DUP (?)       ;
AuxStack    LABEL   BYTE
 
        DB      StackSize DUP (?)       ;
DskStack    LABEL   BYTE
 
        DB      StackSize DUP (?)       ;
IOStack LABEL   BYTE
 
 
; patch space for Boca folks.
; Say What????!!! This does NOT go into the swappable area!
; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
;       This allows the REDIRector to work on either IBM or MS-DOS.
 
PUBLIC  IBMPATCH
IBMPATCH    label byte
        I_am    PRINTER_FLAG,BYTE,<0>   ; [SYSTEM] status of PRINT utility
        I_am    VOLCHNG_FLAG,BYTE,<0>   ; [SYSTEM] true if volume label created
        I_am    VIRTUAL_OPEN,BYTE,<0>   ; [SYSTEM] non-zero if we opened a virtual file
 
; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
      I_am     FSeek_drive,BYTE         ;AN000; fastseek drive #
      I_am     FSeek_firclus,WORD       ;AN000; fastseek first cluster #
      I_am     FSeek_logclus,WORD       ;AN000; fastseek logical cluster #
      I_am     FSeek_logsave,WORD       ;AN000; fastseek returned log clus #
;      I_am     UU_ACT_PAGE,WORD,<-1>       ;;;;;;; ;BL ; active EMS page                       ;AN000;
      I_am     TEMP_DOSLOC,WORD,<-1>    ;stores the temporary location of dos
					;at SYSINIT time.
 
 
SWAP_END    LABEL   BYTE
PUBLIC  SWAP_END
 
; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
;   BE USED. If the size of the swap data area is ODD, it will be rounded up
;   to include this byte.
        DB      ?
 
;hkn;            DB      (512+80+32-(SWAP_END-ibmpatch)) DUP (?)


DOSDATA    ENDS



DOSDATALAST SEGMENT
	
MSDAT001e       label byte
 
DOSDATALAST ENDS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\oemnum.inc ===
; DOS OEM number assignments.
; This file is for documentation purposes only.  It lists the currently
; assigned OEM numbers, for use with the DOS GetVersion call.
;
; Some numbers are assigned for use with Win/386 device ID numbers, and
; are not true OEM numbers
;
; IBM DOS             (00)
; Compaq DOS          (01)
; MS Packaged Product (02)
; AT&T DOS            (04)
; Zenith DOS          (05)
; HP DOS              (06)
; Olivetti DOS        (23)
; Novell	      (33)	; used for Win/386 device IDs only
; MS Multimedia Systems (34)	;   "    "    "    "	"    "
;   "    "    "    "	(35)	;   "    "    "    "	"    "
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\mult.inc ===
;       SCCSID = @(#)mult.asm   1.2 85/04/12
	Break <Multiplex channels>

; The current set of defined multiplex channels is (* means documented):
;
;   Channel(h)  Issuer          Receiver    Function
;      00       server          PSPRINT     print job control
;     *01       print/apps      PRINT       Queueing of files
;      02       BIOS            REDIR       signal open/close of printers
;
;      05       command         REDIR       obtain text of net int 24 message
;     *06       server/assign   ASSIGN      Install check
;
;      08       external driver IBMBIO      interface to internal routines
;
;      10       sharer/server   Sharer      install check
;      11       DOS/server      Redir       install check/redirection funcs
;      12       sharer/redir    DOS         dos functions and structure maint
;      13       MSNET           MSNET       movement of NCBs
;      13       external driver IBMBIO      Reset_Int_13, allows installation
;                                           of alternative INT_13 drivers after
;                                           boot_up
;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
;      15       APPS            MSCDEX      CD-ROM extensions interface
;      16       WIN386          WIN386      Windows communications
;      17       Clipboard       WINDOWS     Clipboard interface
;     *18       Applications    MS-Manger   Toggle interface to manager
;      19       Shell
;      1A       Ansi.sys
;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
;
;      40h      OS/2
;      41h      Lanman
;      42h      Lanman
;      43h      Himem
;                               AL = 20h    reserved for Mach 20 Himem support
;                               AL = 30h    reserved for Himem external A20 code
;      44h      Dosextender
;      45H      Windows profiler
;      46h      Windows/286 DOS extender
;      47h      Basic Compiler Vn. 7.0
;      48h      Doskey
;      49h      DOS 5.x install 
;      4ah      Multi Purpose
;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
;                multMULTGETHMAPTR      1 - Get available HMA & ptr
;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
;                multMULTTASKSHELL      5 - Shell/switcher API
;		 multMULTRPLTOM		6 - Top Of Memory for RPL support
;      4bh      Task Switcher API
;
;      4ch      APPS            APM             Advanced power management
;      4dh      Kana Kanji Converter, MSKK
;
;      55h	COMMAND.COM
;		 multCOMFIRST		0 - API to determine whether 1st
;					    instance of command.com
;      AB       Unspecified IBM use
;      AC       Graphics
;      AD       NLS (toronto)
;      AE
;      AF       Mode
;      B0       GRAFTABL        GRAFTABL
;
;      D7       Banyan VINES


;MUX 00-3F reserverd for IBM
;MUX 80-BF reserverd for IBM

;MUX 40-7F reserved for Microsoft

;MUX C0-FF users



MultSHARE   EQU     10h                 ; sharer
    ;   1   MFT_enter
    ;   2   MFTClose
    ;   3   MFTclU
    ;   4   MFTCloseP
    ;   5   MFTCloN
    ;   6   set_block
    ;   7   clr_block
    ;   8   chk_block
    ;   9   MFT_get
    ;   10  ShSave
    ;   11  ShChk
    ;   12  ShCol
    ;   13  ShCloseFile

MultNET     EQU     11h                 ; Network support
MultIFS     EQU     11h                 ; Network support
    ;   1   IFS_RMDIR
    ;   2   IFS_SEQ_RMDIR
    ;   3   IFS_MKDIR
    ;   4   IFS_SEQ_MKDIR
    ;   5   IFS_CHDIR
    ;   6   IFS_CLOSE
    ;   7   IFS_COMMIT
    ;   8   IFS_READ
    ;   9   IFS_WRITE
    ;   10  IFS_LOCK
    ;   11  IFS_UNLOCK
    ;   12  IFS_DISK_INFO
    ;   13  IFS_SET_FILE_ATTRIBUTE
    ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
    ;   15  IFS_GET_FILE_INFO
    ;   16  IFS_SEQ_GET_FILE_INFO
    ;   17  IFS_RENAME
    ;   18  IFS_SEQ_RENAME
    ;   19  IFS_DELETE
    ;   20  IFS_SEQ_DELETE
    ;   21  IFS_OPEN
    ;   22  IFS_SEQ_OPEN
    ;   23  IFS_CREATE
    ;   24  IFS_SEQ_CREATE
    ;   25  IFS_SEQ_SEARCH_FIRST
    ;   26  IFS_SEQ_SEARCH_NEXT
    ;   27  IFS_SEARCH_FIRST
    ;   28  IFS_SEARCH_NEXT
    ;   29  IFS_ABORT
    ;   30  IFS_ASSOPER
    ;   31  Printer_SET_STRING
    ;   32  IFSFlushBuf
    ;   33  IFSBufWrite
    ;   34  IFSResetEnvironment
    ;   35  IFSSpoolCheck
    ;   36  IFSSpoolClose
    ;   37  IFSDeviceOper
    ;   38  IFSSpoolEchoCheck
    ;   39      - - -   Unused   - - -
    ;   40      - - -   Unused   - - -
    ;   41      - - -   Unused   - - -
    ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
    ;   43  DEVICE_IOCTL
    ;   44  IFS_UPDATE_CB
    ;   45  IFS_FILE_XATTRIBUTES
    ;   46  IFS_XOPEN
    ;   47  IFS_DEPENDENT_IOCTL

MultDOS     EQU     12h                 ; DOS call back
    ;   1   DOS_CLOSE
    ;   2   RECSET
    ;   3   Get DOSGROUP
    ;   4   PATHCHRCMP
    ;   5   OUT
    ;   6   NET_I24_ENTRY
    ;   7   PLACEBUF
    ;   8   FREE_SFT
    ;   9   BUFWRITE
    ;   10  SHARE_VIOLATION
    ;   11  SHARE_ERROR
    ;   12  SET_SFT_MODE
    ;   13  DATE16
    ;   14  Unused              (was SETVISIT)
    ;   15  SCANPLACE
    ;   16  Unused              (was SKIPVISIT)
    ;   17  StrCpy
    ;   18  StrLen
    ;   19  Ucase
    ;   20  POINTCOMP
    ;   21  CHECKFLUSH
    ;   22  SFFromSFN
    ;   23  GetCDSFromDrv
    ;   24  Get_User_Stack
    ;   25  GetThisDrv
    ;   26  DriveFromText
    ;   27  SETYEAR
    ;   28  DSUM
    ;   29  DSLIDE
    ;   30  StrCmp
    ;   31  initcds
    ;   32  pjfnfromhandle
    ;   33  $NameTrans
    ;   34  CAL_LK
    ;   35  DEVNAME
    ;   36  Idle
    ;   37  DStrLen
    ;   38  NLS_OPEN      DOS 3.3
    ;   39  $CLOSE        DOS 3.3
    ;   40  NLS_LSEEK     DOS 3.3
    ;   41  $READ         DOS 3.3
    ;   42  FastInit      DOS 4.0
    ;   43  NLS_IOCTL     DOS 3.3
    ;   44  GetDevList    DOS 3.3
    ;   45  NLS_GETEXT    DOS 3.3
    ;   46  MSG_RETRIEVAL DOS 4.0
    ;   47  FAKE_VERSION  DOS 4.0
    ;
NLSFUNC     EQU     14h                 ; NLSFUNC CALL , DOS 3.3
    ;   0   NLSInstall
    ;   1   ChgCodePage
    ;   2   GetExtInfo
    ;   3   SetCodePage
    ;   4   GetCntry
    ;

multANSI    EQU     1Ah			; ANSI multiplex number
    ;   0   INSTALL_CHECK		; install check for ANSI
    ;   1   IOCTL_2F			; 2F interface to IOCTL
    ;   2   DA_INFO_2F			; J.K. Information passing to ANSI.

multMULT    	EQU     4ah
 multMULTRPLTOM	EQU	06h

    ;   0   swap disk function for single floppy drive m/cs
    ;       BIOS broadcasts with cx==0, and apps who handle
    ;       swap disk messaging set cx == -1. BIOS sets dl == requested
    ;       drive
    ;
    ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
    ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
    ;       returns pointer in ES:DI
    ;
    ;   3-4 currently used by nobody
    ;	5   Switcher API
    ;   6   Top of Memory for RPL.
    ;		BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
    ;		code present in TOM should respond with a new TOM in DX
    ;		to protect itself from MSLOAD & SYSINIT tromping over it.
    ;		SYSINIT builds an arena with owner type 8 & name 'RPL' to
    ;		protect the RPL code from COMMAND.COM transient protion.
    ;		It is the responsibility of RPL program to release the mem.
    ;   7   Reserved for PROTMAN support.

MultAPM         EQU     4ch
    ;       00h     APM_VER_CHK
    ;       01h     APM_SUS_SYS_REQ
    ;       FFh     APM_SUS_RES_BATT_NOTIFY

;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
;         it calls Multdos 42 to set up an entry routine address
    ;   0   Install status  (reserved)
    ;   1   Lookup
    ;   2   Insert
    ;   3   Delete
    ;   4   Purge           (reserved)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\pcgequ.inc ===
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""          =B
;	       CONDITIONAL ASSEMBLY CONTROLS
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""          =B
WINTHORN	EQU	 1	 ;OS/2 compatible

;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""          =B
;		 VIDEO REGISTER PORT ADDRESS EQUATES				  =B
;										  =B
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""          =B
seq_addr	EQU	0C4H	;Sequencer  Address				  =B
seq_data	EQU	0C5H	;Sequencer  Data				  =B
crtc_addr	EQU	0D4H	;CRT Controller Address (Color) 		  =B
crtc_addr_b	EQU	0B4H	;CRT Controller Address (Mono)			  =B
crtc_data	EQU	0D5H	;CRT Controller Data				  =B
graph_1_pos	EQU	0CCH	;Graphics 1 Position				  =B
graph_2_pos	EQU	0CAH	;Graphics 2 Position				  =B
graph_addr	EQU	0CEH	;Graphics 1 & 2 Address 			  =B
graph_data	EQU	0CFH	;Graphics 1 & 2 Data				  =B
misc_output	EQU	0C2H	;Miscellaneous Output				  =B
misc_read	EQU	0CCH	;Miscellaneous Output Read Port Address 	  =B
in_stat_0	EQU	0C2H	;Input Status Register 0			  =B
input_status_b	EQU	0BAH	;Feature Control (Mono) 			  =B
input_status	EQU	0DAH	;Feature Control (Color)			  =B
attr_read	EQU	0C1H	;Attribute Controller Read Address		  =B
attr_write	EQU	0C0H	;Attribute Controller Write Address		  =B
fctrl_read	EQU	0CAH	;Feature Control Regiester Read Address 	  =B

;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
;	     SEQUENCER ADDRESS REGISTER EQUATES
;
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
s_reset 	EQU	00H	;Reset						  =B
s_clock 	EQU	01H	;Clocking Mode					  =B
s_map		EQU	02H	;Map Mask					  =B
s_cgen		EQU	03H	;Character Map Select				  =B
s_mem		EQU	04H	;Memory Mode					  =B


;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
;	     GRAPHICS ADDRESS REGISTER EQUATES
;
;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
g_set_reset	EQU	00H	;set/reset					  =B
g_enbl_set	EQU	01H	;enable set/reset				  =B
g_clr_comp	EQU	02H	;color compare					  =B
g_data_rot	EQU	03H	;data rotate					  =B
g_read_map	EQU	04H	;read map select				  =B
g_mode		EQU	05H	;mode						  =B
g_misc		EQU	06H	;miscellaneous					  =B
g_color 	EQU	07H	;color don't care                                 =B
g_bit_mask	EQU	08H	;bit mask					  =B

;---------------------------------------------------------------------+
;								      |
;	 Miscellaneous Equates					      |
;								      |
;---------------------------------------------------------------------+

LINELEN        EQU  80			     ; Length of a Graphics Buffer Line
COLPELS        EQU  8			     ; Number of pels per text column
;DEFROFFU	EQU  1			      ; Default Pointer Icon Row Center Offset
;DEFROFFD	EQU  14 		      ; Default Pointer Icon Row Center Offset
;DEFCOFFR	EQU  11 		      ; Default Pointer Icon Column Center Offst
;DEFCOFFL	EQU  4			      ; Default Pointer Icon Column Center Offst
;ICONROWS	EQU  16 		      ; Number of Rows in Pointer Icon
;M_WHITE	EQU  15 		      ;default foreground color (icon)
;M_DAXIS	EQU  11 		      ;default axis mouse pointer

DEFROFFU       EQU  1			     ; Default Pointer Icon Row Center Offset
DEFROFFD       EQU  14			     ; Default Pointer Icon Row Center Offset
DEFCOFFR       EQU  14			     ; Default Pointer Icon Column Center Offst
DEFCOFFL       EQU  2			     ; Default Pointer Icon Column Center Offst
ICONROWS       EQU  20			     ; Number of Rows in Pointer Icon
M_DAXIS        EQU  800 		     ;default axis mouse pointer

ICONCOLS       EQU  16			     ; Number of Columns in Pointer Icon
SHFTMSK        EQU  07H 		     ; Column Shift Count Bit Mask (Hi-Res)
M_BLACK        EQU  0			     ;default background color (icon)
M_WHITE        EQU  15			     ;default foreground color (icon)
VSICONR        EQU  28			     ;# pel rows
VSICONC        EQU  2*8 		     ;# pel columns
MVSICONR       EQU  16			     ;minimun pel rows in sb icon
MHSICONC       EQU  3*8 		     ;minimum pel cols in sb icon

;;
;;  Long Conditional Jump Macros
;;
lja		macro	Farlabel
		local	Nearlabel
		jna	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljae		macro	Farlabel
		local	Nearlabel
		jnae	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljb		macro	Farlabel
		local	Nearlabel
		jnb	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljc		macro	Farlabel
		local	Nearlabel
		jnc	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljbe		macro	Farlabel
		local	Nearlabel
		jnbe	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
lje		macro	Farlabel
		local	Nearlabel
		jne	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljz		macro	Farlabel
		local	Nearlabel
		jnz	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljg		macro	Farlabel
		local	Nearlabel
		jng	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljge		macro	Farlabel
		local	Nearlabel
		jnge	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljl		macro	Farlabel
		local	Nearlabel
		jnl	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljle		macro	Farlabel
		local	Nearlabel
		jnle	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljnc		macro	Farlabel
		local	Nearlabel
		jc	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljne		macro	Farlabel
		local	Nearlabel
		je	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljnz		macro	Farlabel
		local	Nearlabel
		jz	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljno		macro	Farlabel
		local	Nearlabel
		jo	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljo		macro	Farlabel
		local	Nearlabel
		jno	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\parse.asm ===
PAGE				;AN000;
;  $SALUT (4,4,8,41)
;(deleted).XLIST
;(deleted)INCLUDE   STRUC.INC ;AN020;structured macro definitions for .IF,.ELSE etc.
;(deleted).LIST
;
;Revision History
;================
;
; M029	02/15/91 SR	Bug #5699. In SysParse, reinitialize $P_FileSp_Char
;			everytime because this is in the non-checksum region
;			and can get corrupted without the checksum region
;			getting corrupted. Yet another data structure that
;			should have been in the checksum region but isnt.
;


;
; NOTE:   basesw must be set properly to allow the PARSER to access psdata.
;	   - basesw undefined	 means	 CS seg. override for psdata access.
;	   - basesw = 1 	 means	 DS seg. override for psdata access &
;					 DS must point to psdata.
;	   - basesw = 0 	 means	 ES seg. override for psdata access &
;					 ES must point to psdata.
;
;
IFNDEF basesw				;AN022;
   psdata_seg EQU   CS			;AN022;
ELSE					;AN022;
   IF  basesw				;AN022;IF "basesw  EQU  1" specified by caller THEN
       psdata_seg EQU	DS		;AN022;
   ELSE 				;AN022;
       psdata_seg EQU	ES		;AN022;ELSE only other choice is ES (basesw EQU 0)
   ENDIF				;AN022;
ENDIF					;AN022;

ifndef incsw				;AN000; (tm03) Someone doesn't want to include psdata
   incsw equ	 1			;AN000; include psdata.inc (tm03)
endif					;AN000; (tm03)
if incsw				;AN000; If incsw = 1 then (tm03)
   include psdata.inc			;AN000;    include psdata.inc (tm03)
endif					;AN000; endif		  (tm03)
   PAGE 				;AN000;
IF1					;AN000;
;   %OUT INCLUDING COMP=COMMON DSN=PARSE.ASM...;AN000;
ENDIF					;AN000;
;***********************************************************************
; SysParse;
;
;  Function : Parser Entry
;
;  Input: DS:SI -> command line
;	  ES:DI -> parameter block
;	  psdata_seg -> psdata.inc
;	  CX = operand ordinal
;
;	  Note:  ES is the segment containing all the control blocks defined
;		 by the caller, except for the DOS COMMAND line parms, which
;		 is in DS.
;
;  Output: CY = 1   error of caller, means invalid parameter block or
;		    invalid value list. But this parser does NOT implement
;		    this feature. Therefore CY always zero.
;
;	   CY = 0   AX = return code
;		    BL = terminated delimiter code
;		    CX = new operand ordinal
;		    SI = set past scaned operand
;		    DX = selected result buffer
;
; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
;	$P_Chk_Sw_Control, $P_Fill_Result
;
; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
;
;-------- Modification History -----------------------------------------
;
;  4/04/87 : Created by K. K,
;  4/28/87 : $P_Val_YH assemble error (tm01)
;	   : JMP SHORT assemble error (tm02)
;  5/14/87 : Someone doesn't want to include psdata (tm03)
;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
;	     DateSW equ 1)	      (tm04)
;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
;				      (tm05) in PSDATA.INC
;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
;	     value-list block	      (tm07)
;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
;	     switch (keyword) or not. If there is, backup si for next call
;	     (tm08)
;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
;	     /+15 and /+:15 are allowed for user (tm10)
;  6/29/87 : ECS call changes DS register but it causes the address problem
;	     in user's routines. $P_Chk_DBCS (tm11)
;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
;					  (tm12)
;  7/10/87 : Invalid switch/keyword does not work correctly
;					  (tm13)
;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
;					  (tm14)
;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
;					  (tm15)
;  7/24/87 : Negative lower bound on numeric ranges cause trouble

;  7/24/87 : Quoted strings being returned with quotes.

;  7/28/87 : Kerry S (;AN018;)
;	     Non optional value on switch (match flags<>0 and <>1) not flagged
;	     as an error when missing.	Solution: return error 2.  Modules
;	     affected: $P_Chk_SW_Control.

;  7/29/87 : Kerry S (;AN019;)
;	     Now allow the optional bit in match flags for switches.  This
;	     allows the switch to be encountered with a value or without a
;	     value and no error is returned.
;

;  8/28/87 : Ed K, Kerry S (;AN020;)
;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
;	     within a date response, instead of checking just for the one
;	     character defined by the COUNTRY DEPENDENT INFO, check for
;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
;	     slashes in date strings when DateSw (assembler switch) is set.

;  9/1/87  : Kerry S (;AN021)
;	     In PROC $P_String_Comp, when comparing the switch or keyword on
;	     the command line with the string in the control block the
;	     comparing was stopping at a colon (switch) or equal (keyword)
;	     on the command line and assuming a match.	This allowed a shorter
;	     string on the command line than in the synonym list in the control
;	     block.  I put in a test for a null in the control block so the
;	     string in the control block must be the same length as the string
;	     preceeding the colon or equal on the command line.

;  8/28/87 : Kerry S (;AN022;)
;	     All references to data in PSDATA.INC had CS overrides.  This caused
;	     problems for people who included it themselves in a segment other
;	     than CS.  Added switch to allow including PSDATA.INC in any
;	     segment.

;  9/16/87 : Ed K (;AN023;) PTM1040
;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
;	     forced both TIME and DATE to use the delims, "-","/",".".
;	     Created FLag, in $P_time_Format PROC, to request the delim in
;	     BL be used if TIME is being parsed.

;  9/24/87 : Ed K
;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
;	     invocations with their normally expanded code; made comments
;	     out of the STRUC macro invocation statements to maintain readability.

;  9/24/87 : Ed K (;AN024;) PTM1222
;	     When no CONTROL for a keyword found, tried to fill in RESULT
;	     pointed to by non-existant CONTROL.

; 10/15/87 : Ed K (;AN025;) PTM1672
;	     A quoted text string can be framed only by double quote.  Remove
;	     support to frame quoted text string with single quote.
;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
;	     single quote in PROC prologues are left as is for history reasons.

;	     This fixes another bug, not mentioned in p1672, in that two
;	     quote chars within a quoted string is supposed to be reported as
;	     one quote character, but is reported as two quotes.  This changed
;	     two instructions in PROC $P_Quoted_Str.

;	     Also fixed are several JMP that caused a NOP, these changed to
;	     have the SHORT operator to avoid the unneeded NOP.

;	     The code and PSDATA.INC have been aligned for ease of reading.

; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
;	     psdata buffer should have psdata_seg.

; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
;	     positional missing.

; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
;	     as a line delimiter, should use carriage return.
;	     Define switch: LFEOLSW, if on, accept LF as end of line char.

; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".

; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
;	     endless loop since SI is returned still pointing to start
;	     of that parm.

; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
;	     Vector to returned string has CS instead of Psdata_Seg, but
;	     when tried to fix it on previous version, changed similar
;	     but wrong place.

; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
;	     delimiters between hours, minutes, seconds for time. And period
;	     and comma are valid delimiters between seconds and 100th second.

; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
;	     in a filespec, then flag an error.

; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
;	     indexed off of the psdata_seg equate instead of the DS register.
;	     Using this method, DS can point to the segment of PSP or to psdata
;  -->	     local parser data. Why were some references to local data changed
;	     to do this before, but not all ?????

; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.

; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
;
; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.

; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error

; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
;	     separator in TIME before hundredths field.
;
; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
;			strings as keywords.
;
;***********************************************************************
IF FarSW				;AN000;(Check if need far return)
SysParse proc far			;AN000;
ELSE					;AN000;
SysParse proc near			;AN000;
ENDIF					;AN000;(of FarSW)
;	$SALUT	(4,9,17,41)
	mov	psdata_seg:$P_Flags,0	;AC034; Clear all internal flags
IF	TimeSw				;AN039; FOR TIME ONLY
	MOV    PSDATA_SEG:$P_ORIG_ORD,CX ;AN039; ORIGINAL ORDINAL FROM CX
	MOV    PSDATA_SEG:$P_ORIG_STACK,SP ;AN039; ORIGINAL VALUE OF STACK FROM SP
	MOV    PSDATA_SEG:$P_ORIG_SI,SI ;AN039; ORIGINAL START PARSE POINTER FROM SI
$P_REDO_TIME:				;AN039; try to parse time again
ENDIF					;AN039; FOR TIME ONLY
	cld				      ;AN000; confirm forward direction
	mov	psdata_seg:$P_ordinal,cx      ;AC034; save operand ordinal
	mov	psdata_seg:$P_RC,$P_No_Error  ;AC034; Assume no error
	mov	psdata_seg:$P_Found_SYNONYM,0 ;AC034; initalize synonym pointer

	mov	word ptr psdata_seg:$P_DX,0   ;AC034; (tm15)

;M029 -- Begin changes
; The table of special chars $P_FileSp_Char should be initialized on every
;entry to SysParse. This is in the non-checksum region and any program that
;corrupts this table but does not corrupt the checksum region will leave
;command.com parsing in an inconsistent state.
; NB: The special characters string has been hardcoded here. If any change
;is made to it in psdata.inc, a corresponding change needs to be made here.
;
IF FileSW + DrvSW

	mov	word ptr psdata_seg:$P_FileSp_Char, ']['
	mov	word ptr psdata_seg:$P_FileSp_Char+2, '<|'
	mov	word ptr psdata_seg:$P_FileSp_Char+4, '+>'
	mov 	word ptr psdata_seg:$P_FileSp_Char+6, ';='

ENDIF
;
;M029 -- End of changes
;

IF KeySW				;AN029;
;IN CASE THE USER PUT OPTIONAL WHITESPACE CHARS AROUND THE "=" USED IN
;KEYWORD DEFINITIONS, SCAN THE COMMAND LINE AND COMPRESS OUT ANY WHITESPACES
;NEXT TO "=" BEFORE STARTING THE USUAL PARSING.
       push	 cx			;AN029;
       push	 dx			;AN029;
       push	 di			;AN029;

       push	 si			;AN029; remember where command line starts
       mov	 cx,-1			;AN029; init counter
;      $do
$P_loc_eol:				;AN029;
	  inc	    cx			;AN029; bump counter of chars up to EOL
	  lodsb 			;AN029; get a char from command line
	  CALL	    $P_Chk_EOL		;AN029; see if AL is EOL char

;      enddo z
       jnz	 $P_loc_EOL		;AN029; not found that EOL char

       mov	 psdata_seg:$P_count_to_EOL,cx ;AN029;AC034;; save count of chars up to EOL
       pop	 si			;AN029; restore start of command line

;scan command string for combinations including "=",
;      and replace each with just the simple "="

;REPEAT UNTIL ONE PASS IS MADE WHEREIN NO CHANGES WERE MADE
;  $do
$P_DO1: 			   ;AN029;
       push si			   ;AN029; remember where string started
       MOV  CX,psdata_seg:$P_COUNT_TO_EOL ;AN029;AC034;; set  count to no. chars in string,
				   ;AN029; not counting the EOL char
       XOR  BX,BX		   ;AN029;SET $P_REG_BL_DQ_SW TO "NOT IN QUOTES", AND...
				   ;AN029;SET $P_REG_BH_CG_SW TO "NO CHANGES MADE"
;MAKE ONE PASS THRU THE STRING, LOOKING AT EACH CHARACTER
;      $do			   ;AN029;
$P_DO2: 			   ;AN029;
	   cmp	BYTE PTR [SI],$P_double_quote ;AN029;
;	   $if	e		   ;AN029;if a double quote was found
	   JNE $P_IF3		   ;AN029;
	       NOT  $P_REG_BL_DQ_SW ;AN029;TOGGLE THE DOUBLE QUOTE STATE SWITCH
;	   $endif		   ;AN029;
$P_IF3: 			   ;AN029;
	   OR	$P_REG_BL_DQ_SW,$P_REG_BL_DQ_SW ;AN029;IS THE DOUBLE QUOTE SWITCH SET?
;	   $if	Z		   ;AN029;IF NOT IN DOUBLE QUOTES
	   JNZ $P_IF5		   ;AN029;
	       mov  ax,word ptr [si] ;AN029; get pair to be checked out
	       cmp  ax,$P_BL_EQ    ;AN029;" ="
;	       $if  e,or	   ;AN029;
	       JE $P_LL6	   ;AN029;
	       cmp  ax,$P_EQ_BL    ;AN029;"= "
;	       $if  e,or	   ;AN029;
	       JE $P_LL6	   ;AN029;
	       cmp  ax,$P_EQ_TB    ;AN029; "=<tab>"
;	       $if  e,or	   ;AN029;
	       JE $P_LL6	   ;AN029;
	       cmp  ax,$P_TB_EQ    ;AN029;"<tab>="
;	       $if  e		   ;AN029;if this pair to be replaced with a single "="
	       JNE $P_IF6	   ;AN029;
$P_LL6: 			   ;AN029;
		   mov	BYTE PTR [SI],$P_Keyword ;AN029; "="
		   inc	si	   ;AN029;point to next char after the new "="
		   mov	di,si	   ;AN029;move target right after new "="

		   push si	   ;AN029;remember where i am, right after new "="
		   PUSH CX	   ;AN029;SAVE CURRENT COUNT
		   inc	si	   ;AN029;source is one beyond that
		   push es	   ;AN029;remember the extra segment
		   push ds	   ;AN029;temporarily, set source seg and
		   pop	es	   ;AN029; target seg to the command line seg
		   rep	movsb	   ;AN029;move chars left one position
		   pop	es	   ;AN029;restore the extra segment
		   POP	CX	   ;AN029;RESTORE CURRENT COUNT
		   pop	si	   ;AN029;back to where I was

		   DEC	SI	   ;AN029;LOOK AT FIRST CHAR JUST MOVED
		   MOV	$P_REG_BH_CG_SW,-1 ;AN029;set switch to say "a change was made"
		   DEC	psdata_seg:$P_COUNT_TO_EOL ;AN029;AC034;;because just threw away a char
		   dec	CX	   ;AN029;DITTO
;	       $endif		   ;AN029;comparand pair found?
$P_IF6: 			   ;AN029;
;	   $endif		   ;AN029;double quote switch?
$P_IF5: 			   ;AN029;
	   inc	si		   ;AN029;bump index to look at next char in command string
	   dec	CX		   ;AN029;one less char to look at
;(deleted ;AC035;)  CMP  CX,0		    ;AN029;is char count all gone yet?
;      $enddo LE		   ;AN029;quit if no more chars
       JNLE $P_DO2		   ;AN029;
       pop  si			   ;AN029;remember where string started
       OR   $P_REG_BH_CG_SW,$P_REG_BH_CG_SW ;AN029;WAS "A CHANGE MADE"?
;  $enddo Z			   ;AN029;QUIT when no changes were made
   JNZ $P_DO1			   ;AN029;
   pop	di			   ;AN029;
   pop	dx			   ;AN029;
   pop	cx			   ;AN029;

;NOW THAT ALL WHITESPACE SURROUNDING "=" HAVE BEEN COMPRESSED OUT,
;RESUME NORMAL PARSING...
ENDIF					;AN029; KEYWORDS SUPPORTED?
	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
	jnc	$P_Start		;AN000; If EOL is not encountered, do parse

;--------------------------- End of Line
	mov	ax,$P_RC_EOL		;AN000; set exit code to -1
	push	bx			;AN000;
	mov	bx,es:[di].$P_PARMSX_Address ;AN000; Get the PARMSX address to
	cmp	cl,es:[bx].$P_MinP	;AN000; check ORDINAL to see if the minimum
	jae	$P_Fin			;AN000; positional found.

	mov	ax,$P_Op_Missing	;AN000; If no, set exit code to missing operand
$P_Fin: 				;AN000;
	pop	bx			;AN000;
	jmp	$P_Single_Exit		;AN000; return to the caller

;---------------------------
$P_Start:				;AN000;
	mov	psdata_seg:$P_SaveSI_Cmpx,si ;AN000;AC034;  save ptr to command line for later use by complex,
	push	bx			;AN000; quoted string or file spec.
	push	di			;AN000;
	push	bp			;AN000;
	lea	bx,psdata_seg:$P_STRING_BUF ;AC034; set buffer to copy from command string
	test	psdata_seg:$P_Flags2,$P_Extra ;AC034; 3/9 extra delimiter encountered ?
	jne	$P_Pack_End		;AN000; 3/9 if yes, no need to copy

$P_Pack_Loop:				;AN000;
	lodsb				;AN000; Pick a operand from buffer
	call	$P_Chk_Switch		;AN000; Check switch character
	jc	$P_Pack_End_BY_EOL	;AN020; if carry set found delimiter type slash, need backup si, else continue

	call	$P_Chk_EOL		;AN000; Check EOL character
	je	$P_Pack_End_BY_EOL	;AN000; need backup si

	call	$P_Chk_Delim		;AN000; Check delimiter
	jne	$P_PL01 		;AN000; If no, process next byte

	test	psdata_seg:$P_Flags2,$P_Extra ;AC034; 3/9 If yes and white spec,
; (tm08)jne	$P_Pack_End		;AN000; 3/9 then
	jne	$P_Pack_End_backup_si	;AN000; (tm08)

	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end

$P_PAck_End_backup_si:			;AN000; (tm08)
	test	psdata_seg:$P_Flags2,$P_SW+$P_equ ;AN000;AC034;  (tm08)
	je	$P_Pack_End		;AN000; (tm08)

	dec	si			;AN000; (tm08)
	jmp	short $P_Pack_End	;AN025; (tm08)

$P_PL01:				;AN000;
	mov	psdata_seg:[bx],al	;AN000; move byte to STRING_BUF
	cmp	al,$P_Keyword		;AN000; if it is equal character,
	jne	$P_PL00 		;AN000; then

	or	psdata_seg:$P_Flags2,$P_equ ;AC034; remember it in flag
$P_PL00:				;AN000;
	inc	bx			;AN000; ready to see next byte
	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
	jnc	$P_Pack_Loop		;AN000; if no, process to next byte

	lodsb				;AN000; if yes, store
	mov	psdata_seg:[bx],al	;AN000;    2nd byte of DBCS
	inc	bx			;AN000; update pointer
	jmp	short $P_Pack_Loop	;AN000; process to next byte

$P_Pack_End_BY_EOL:			;AN000;
	dec	si			;AN000; backup si pointer
$P_Pack_End:				;AN000;
	mov	psdata_seg:$P_SI_Save,si     ;AC034; save next pointer, SI
	mov	byte ptr psdata_seg:[bx],$P_NULL ;AN000; put NULL at the end
	mov	psdata_seg:$P_Save_EOB,bx    ;AC034; 3/17/87 keep the address for later use of complex
	mov	bx,es:[di].$P_PARMSX_Address ;AN000; get PARMSX address
	lea	si,psdata_seg:$P_STRING_BUF  ;AC034;
	cmp	byte ptr psdata_seg:[si],$P_Switch ;AN000; the operand begins w/ switch char ?
	je	$P_SW_Manager		     ;AN000; if yes, process as switch

	cmp	byte ptr psdata_seg:[si],$P_DQuote	;M005;is it a string?
	je	$P_Positional_Manager			;M005;if so, process as one!

	test	psdata_seg:$P_Flags2,$P_equ   ;AC034; the operand includes equal char ?
	jne	$P_Key_manager		     ;AN000; if yes, process as keyword

$P_Positional_Manager:			;AN000; else process as positional
	mov	al,es:[bx].$P_MaxP	;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	cmp	psdata_seg:$P_ORDINAL,ax ;AC034; too many positional ?
	jae	$P_Too_Many_Error	;AN000; if yes, set exit code to too many

	mov	ax,psdata_seg:$P_ORDINAL ;AC034; see what the current ordinal
	shl	ax,1			;AN000; ax = ax*2
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; now bx points to 1st CONTROL
;(changed ;AC035;) add	   bx,2 	;AN000; now bx points to 1st CONTROL
	add	bx,ax			;AN000; now bx points to specified CONTROL address
	mov	bx,es:[bx]		;AN000; now bx points to specified CONTROL itself
	call	$P_Chk_Pos_Control	;AN000; Do process for positional
	jmp	short $P_Return_to_Caller ;AN000; and return to the caller

$P_Too_Many_Error:			;AN000;
	mov	psdata_seg:$P_RC,$P_Too_Many ;AC034; set exit code
	jmp	short $P_Return_to_Caller ;AN000; and return to the caller
;
$P_SW_Manager:				;AN000;
	mov	al,es:[bx].$P_MaxP	;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	inc	ax			;AN000;
	shl	ax,1			;AN000; ax = (ax+1)*2
	add	bx,ax			;AN000; now bx points to maxs
	mov	cl,es:[bx]		;AN000;
	xor	ch,ch			;AN000; cx = maxs
	or	cx,cx			;AN000; at least one switch ?
	je	$P_SW_Not_Found 	;AN000;

	inc	bx			;AN000; now bx points to 1st CONTROL address

$P_SW_Mgr_Loop: 			;AN000;
	push	bx			;AN000;
	mov	bx,es:[bx]		;AN000; bx points to Switch CONTROL itself
	call	$P_Chk_SW_Control	;AN000; do process for switch
	pop	bx			;AN000;
	jnc	$P_Return_to_Caller	;AN000; if the CONTROL is for the switch, exit

	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; else bx points to the next CONTROL
;(changed ;AC035;)  add     bx,2	;AN000; else bx points to the next CONTROL
	loop	$P_SW_Mgr_Loop		;AN000; and loop

$P_SW_Not_Found:			;AN000;
	mov	psdata_seg:$P_RC,$P_Not_In_SW ;AC034; here no CONTROL for the switch has
	jmp	short $P_Return_to_Caller0    ;AN000; not been found, means error.
;
$P_Key_Manager: 			;AN000;
	mov	al,es:[bx].$P_MaxP	;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	inc	ax			;AN000;
	shl	ax,1			;AN000; ax = (ax+1)*2
	add	bx,ax			;AN000; now bx points to maxs
	mov	al,es:[bx]		;AN000;
	xor	ah,ah			;AN000; ax = maxs
	shl	ax,1			;AN000;
	inc	ax			;AN000; ax = ax*2+1
	add	bx,ax			;AN000; now bx points to maxk
	mov	cl,es:[bx]		;AN000;
	xor	ch,ch			;AN000; cx = maxk
	or	cx,cx			;AN000; at least one keyword ?
	je	$P_Key_Not_Found	;AN000;

	inc	bx			;AN000; now bx points to 1st CONTROL

$P_Key_Mgr_Loop:			;AN000;
	push	bx			;AN000;
	mov	bx,es:[bx]		;AN000; bx points to keyword CONTROL itself
	call	$P_Chk_Key_Control	;AN000; do process for keyword
	pop	bx			;AN000;
	jnc	$P_Return_to_Caller	;AN000; if the CONTROL is for the keyword, exit

	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; else bx points to the next CONTROL
;(changed ;AC035;)  add     bx,2	;AN000; else bx points to the next CONTROL
	loop	$P_Key_Mgr_Loop 	;AN000; and loop

$P_Key_Not_Found:			;AN000;
	mov	psdata_seg:$P_RC,$P_Not_In_Key ;AC034; here no CONTROL for the keyword has
$P_Return_to_Caller0:			;AN000; not been found, means error.

;(deleted ;AN024;)	 mov	 bx,es:[bx-2]		 ;AN000; (tm13) backup bx

;(deleted ;AN024;)	 mov	 al,$P_String		 ;AN000; Set
;(deleted ;AN024;)	 mov	 ah,$P_No_Tag		 ;AN000;     result
;(deleted ;AN024;)	 call	 $P_Fill_Result 	 ;AN000;	    buffer

$P_Return_to_Caller:			;AN000;
	pop	bp			;AN000;
	pop	di			;AN000;
	pop	bx			;AN000;
	mov	cx,psdata_seg:$P_Ordinal    ;AC034; return next ordinal
	mov	ax,psdata_seg:$P_RC	    ;AC034; return exit code
	mov	si,psdata_seg:$P_SI_Save    ;AC034; return next operand pointer
	mov	dx,psdata_seg:$P_DX	    ;AC034; return result buffer address
	mov	bl,psdata_seg:$P_Terminator ;AC034; return delimiter code found
$P_Single_Exit: 			;AN000;
	clc				;AN000;
	ret				;AN000;
SysParse endp				;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_Pos_Control
;
; Function: Parse CONTROL block for a positional
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    None
;
; Use:	 $P_Fill_Result, $P_Check_Match_Flags
;
; Vars: $P_Ordinal(W), $P_RC(W)
;***********************************************************************
$P_Chk_Pos_Control proc 		;AN000;
	push	ax			;AN000;
	mov	ax,es:[bx].$P_Match_Flag ;AN000;
	test	ax,$P_Repeat		;AN000; repeat allowed ?
	jne	$P_CPC00		;AN000; then do not increment ORDINAL

	inc	psdata_seg:$P_ORDINAL	;AC034; update the ordinal
$P_CPC00:				;AN000;
	cmp	byte ptr psdata_seg:[si],$P_NULL ;AN000; no data ?
	jne	$P_CPC01		;AN000;

	test	ax,$P_Optional		;AN000; yes, then is it optional ?
	jne	$P_CPC02		;AN000;

	mov	psdata_seg:$P_RC,$P_Op_Missing ;AC034; no, then error	     3/17/87
	jmp	short $P_CPC_Exit	;AN000;

$P_CPC02:				;AN000;
	push	ax			;AN000;
	mov	al,$P_String		;AN000; if it is optional return NULL
	mov	ah,$P_No_Tag		;AN000; no item tag indication
	call	$P_Fill_Result		;AN000;
	pop	ax			;AN000;
	jmp	short $P_CPC_Exit	;AN000;

$P_CPC01:				;AN000;
	call	$P_Check_Match_Flags	;AN000;
$P_CPC_Exit:				;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Chk_Pos_Control endp 		;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_Key_Control
;
; Function: Parse CONTROL block for a keyword
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
;
; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
;***********************************************************************
$P_Chk_Key_Control proc 		;AN000;
IF	KeySW				;AN000;(Check if keyword is supported)
	or	psdata_seg:$P_Flags2,$P_Key_Cmp ;AC034; Indicate keyword for later string comparison
	call	$P_Search_KEYorSW	;AN000; Search the keyword in the CONTROL block
	jc	$P_Chk_Key_Err0 	;AN000; not found, then try next CONTROL

	and	psdata_seg:$P_Flags2,0ffh-$P_Key_Cmp ;AC034; reset the indicator previously set
;
	push	ax			     ;AN000;	      keyword=
	mov	ax,psdata_seg:$P_KEYorSW_Ptr ;AC034;	      ^       ^
	sub	ax,si			;AN000;  SI	KEYorSW
	add	psdata_seg:$P_SaveSI_Cmpx,ax ;AC034; update for complex, quoted or file spec.
	pop	ax			;AN000;
;
	mov	si,psdata_seg:$P_KEYorSW_Ptr ;AC034; set si just after equal char
	cmp	byte ptr psdata_seg:[si],$P_NULL ;AN000; any data after equal ?
	je	$P_Chk_Key_Err1 	;AN000; if no, syntax error

	call	$P_Check_Match_Flags	;AN000; else, process match flags
	clc				;AN000;
	jmp	short $P_Chk_Key_Exit	;AN000;

$P_Chk_Key_Err0:			;AN000;
	stc				;AN000; not found in keyword synonym list
	jmp	short $P_Chk_Key_Exit	;AN000;

$P_Chk_Key_Err1:			;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; no parameter is not specified after "="
$P_Chk_Key_ErrExit:			;AN000;
	push	ax			;AN000;
	mov	al,$P_String		;AN000; set
	mov	ah,$P_No_Tag		;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer
	pop	ax			;AN000;
	clc				;AN000;
$P_Chk_Key_Exit:			;AN000;
	ret				;AN000;
ELSE					;AN000;(of IF KeySW)
	stc				;AN000;this logic works when the KeySW
	ret				;AN000;is reset.
ENDIF					;AN000;(of KeySW)
$P_Chk_Key_Control endp 		;AN000;
PAGE					;AN000;
;***********************************************************************
IF	KeySW+SwSW			;AN000;(Check if keyword or switch is supported)
; $P_Search_KEYorSW:
;
; Function: Seach specified keyword or switch from CONTROL
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
;***********************************************************************
$P_Search_KEYorSW proc			;AN000;
	push	bp			;AN000;
	push	cx			;AN000;
	mov	cl,es:[bx].$P_nid	;AN000; Get synonym count
	xor	ch,ch			;AN000; and set it to cx
	or	cx,cx			;AN000; No synonyms specified ?
	je	$P_KEYorSW_Not_Found	;AN000; then indicate not found by CY

	lea	bp,es:[bx].$P_KEYorSW	;AN000; BP points to the 1st synonym
$P_KEYorSW_Loop:			;AN000;
	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
	jnc	$P_KEYorSW_Found	;AN000; If match, set it to synonym pointer

	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
$P_KEYorSW_Not_Found:			;AN000;
	stc				;AN000; indicate not found in synonym list
	jmp	short $P_KEYorSW_Exit	;AN000; and exit

$P_KEYorSW_Found:			;AN000;
	mov	psdata_seg:$P_Found_SYNONYM,bp ;AC034; set synonym pointer
	clc				;AN000; indicate found
$P_KEYorSW_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bp			;AN000;
	ret				;AN000;
$P_Search_KEYorSW endp			;AN000;
;***********************************************************************
; $P_MoveBP_NUL
;***********************************************************************
$P_MoveBP_NUL proc			;AN000;
$P_MBP_Loop:				;AN000;
	cmp	byte ptr es:[bp],$P_NULL ;AN000; Increment BP that points
	je	$P_MBP_Exit		;AN000; to the synomym list

	inc	bp			;AN000; until
	jmp	short $P_MBP_Loop	;AN000; NULL encountered.

$P_MBP_Exit:				;AN000;
	inc	bp			;AN000; bp points to next to NULL
	ret				;AN000;
$P_MoveBP_NUL endp			;AN000;
ENDIF					;AN000;(of KeySW+SwSW)
PAGE					;AN000;
;***********************************************************************
; $P_Chk_SW_Control
;
; Function: Parse CONTROL block for a switch
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
;
; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
;***********************************************************************
$P_Chk_SW_Control proc			;AN000;


IF	SwSW				;AN000;(Check if switch is supported)
	or	psdata_seg:$P_Flags2,$P_Sw_Cmp ;AC034; Indicate switch for later string comparison
	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
	jc	$P_Chk_SW_Err0		;AN000; not found, then try next CONTROL

	and	psdata_seg:$P_Flags2,0ffh-$P_Sw_Cmp ;AC034; reset the indicator previously set
;
	push	ax			;AN000; 	      /switch:
	mov	ax,psdata_seg:$P_KEYorSW_Ptr ;AC034;	      ^       ^
	sub	ax,si			;AN000;  SI	KEYorSW
	add	psdata_seg:$P_SaveSI_Cmpx,ax ;AC034; update for complex list
	pop	ax			;AN000;
;
	mov	si,psdata_seg:$P_KEYorSW_Ptr ;AC034; set si at the end or colon
	cmp	byte ptr psdata_seg:[si],$P_NULL ;AN000; any data after colon
	jne	$P_CSW00		;AN000; if yes, process match flags

	cmp	byte ptr psdata_seg:[si-1],$P_Colon ;AN000; if no, the switch terminated by colon ?
	jne	$P_Chk_if_data_required ;AN000; if yes,

	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; return syntax error
	jmp	short $P_Chk_SW_Exit	;AN000;

$P_Chk_if_data_required:		;AN018; no data, no colon
	cmp	es:[bx].$P_Match_Flag,0 ;AN018; should have data? zero match flag means switch followed by nothing is OK
	je	$P_Chk_SW_Exit		;AN018; match flags not zero so should have something if optional bit is not on

	test	es:[bx].$P_Match_Flag,$P_Optional ;AN019; see if no value is valid
	jnz	$P_Chk_SW_Exit		;AN019; if so, then leave, else yell

	mov	psdata_seg:$P_RC,$P_Op_Missing ;AC034; return required operand missing
	jmp	short $P_Chk_SW_Exit	;AN018;

$P_CSW00:				;AN000;
	call	$P_Check_Match_Flags	;AN000; process match flag
	clc				;AN000; indicate match
	jmp	short $P_Chk_SW_Single_Exit ;AN000;

$P_Chk_SW_Err0: 			;AN000;
	stc				;AN000; not found in switch synonym list
	jmp	short $P_Chk_SW_Single_Exit ;AN000;

$P_Chk_SW_Exit: 			;AN000;
	push	ax			;AN000;
	mov	al,$P_String		;AN000; set
	mov	ah,$P_No_Tag		;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer
	pop	ax			;AN000;
	clc				;AN000;
$P_Chk_SW_Single_Exit:			;AN000;
	ret				;AN000;
ELSE					;AN000;(of IF SwSW)
	stc				;AN000; this logic works when the SwSW
	ret				;AN000; is reset.
ENDIF					;AN000;(of SwSW)
$P_Chk_SW_Control endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Fill_Result
;
; Function: Fill the result buffer
;
; Input:    AH = Item tag
;	    AL = type
;		  AL = 1: CX,DX has 32bit number (CX = high)
;		  AL = 2: DX has index(offset) into value list
;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
;		  AL = 7: DX has year, CL has month and CH has date
;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
;			  amd CH has hundredths
;		  AL = else: psdata_seg:SI points to returned string buffer
;	    ES:BX -> CONTROL block
;
; Output:   None
;
; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
;
; Vars: $P_DX(W)
;***********************************************************************
$P_Fill_Result proc			;AN000;
	push	di			;AN000;
	mov	di,es:[bx].$P_Result_Buf ;AN000; di points to result buffer
	mov	psdata_seg:$P_DX,di	;AC034; set returned result address
	mov	es:[di].$P_Type,al	;AN000; store type
	mov	es:[di].$P_Item_Tag,ah	;AN000; store item tag
	push	ax			;AN000;
	mov	ax,psdata_seg:$P_Found_SYNONYM ;AC034; if yes,
	mov	es:[di].$P_SYNONYM_Ptr,ax ;AN000;   then set it to the result
	pop	ax			;AN000;
$P_RLT04:				;AN000;
	cmp	al,$P_Number		;AN000; if number
	jne	$P_RLT00		;AN000;

$P_RLT02:				;AN000;
	mov	word ptr es:[di].$P_Picked_Val,dx ;AN000; then store 32bit
	mov	word ptr es:[di+2].$P_Picked_Val,cx ;AN000;	number
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT00:				;AN000;
	cmp	al,$P_List_Idx		;AN000; if list index
	jne	$P_RLT01		;AN000;

	mov	word ptr es:[di].$P_Picked_Val,dx ;AN000; then store list index
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT01:				;AN000;
	cmp	al,$P_Date_F		;AN000; Date format ?
	je	$P_RLT02		;AN000;

	cmp	al,$P_Time_F		;AN000; Time format ?
	je	$P_RLT02		;AN000;
;
	cmp	al,$P_Drive		;AN000; drive format ?
	jne	$P_RLT03		;AN000;

	mov	byte ptr es:[di].$P_Picked_Val,dl ;AN000; store drive number
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT03:				;AN000;
	cmp	al,$P_Complex		;AN000; complex format ?
	jne	$P_RLT05		;AN000;

	mov	ax,psdata_seg:$P_SaveSI_Cmpx ;AC034; then get pointer in command buffer
	inc	ax			;AN000; skip left Parentheses
	mov	word ptr es:[di].$P_Picked_Val,ax ;AN000; store offset
	mov	word ptr es:[di+2].$P_Picked_Val,ds ;AN000; store segment
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT05:				;AN000;
;------------------------  AL = 3, 5, or 9
	mov	word ptr es:[di].$P_Picked_Val,si ;AN000; store offset of STRING_BUF
;(replaced ;AN031;)  mov word ptr es:[di+word].$P_Picked_Val,cs ;AN000; store segment of STRING_BUF
	mov	word ptr es:[di+2].$P_Picked_Val,Psdata_Seg ;AN031; store segment of STRING_BUF
;
	push	ax			;AN000;
	test	byte ptr es:[bx].$P_Function_Flag,$P_CAP_File ;AN000; need CAPS by file table?
	je	$P_RLT_CAP00		;AN000;

	mov	al,$P_DOSTBL_File	;AN000; use file upper case table
	jmp	short $P_RLT_CAP02	;AN000;

$P_RLT_CAP00:				;AN000;
	test	byte ptr es:[bx].$P_Function_Flag,$P_CAP_Char ;AN000; need CAPS by char table ?
	je	$P_RLT_CAP01		;AN000;

	mov	al,$P_DOSTBL_Char	;AN000; use character upper case table
$P_RLT_CAP02:				;AN000;
	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
$P_RLT_CAP01:				;AN000;
	pop	ax			;AN000;
	test	byte ptr es:[bx].$P_Function_Flag,$P_Rm_Colon ;AN000; removing colon at end ?
	je	$P_RLT_Exit		;AN000;

	call	$P_Remove_Colon 	;AN000; then process it.
$P_RLT_Exit:				;AN000;
	pop	di			;AN000;
	ret				;AN000;
$P_Fill_Result endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Check_Match_Flags
;
; Function:  Check the mutch_flags and make the exit code and set the
;	     result buffer
;
;	    Check for types in this order:
;		Complex
;		Date
;		Time
;		Drive
;		Filespec
;		Quoted String
;		Simple String
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
;	     $P_Drive_Format
;***********************************************************************
$P_Check_Match_Flags proc		;AN000;
	mov	psdata_seg:$P_err_flag,$P_NULL ;AN033;AC034;; clear filespec error flag.
	push	ax			;AN000;
	mov	ax,es:[bx].$P_Match_Flag ;AN000; load match flag(16bit) to ax

	or	ax,ax			;AC035; test ax for zero
;(changed ;AC035;)  cmp     ax,0	;AN000; (tm12)
	jne	$P_Mat			;AN000; (tm12)

	push	ax			;AN000; (tm12)
	push	bx			;AN000; (tm12)
	push	dx			;AN000; (tm12)
	push	di			;AN000; (tm12)
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; (tm12)
	mov	ah,$P_No_Tag		;AN000; (tm12)
	mov	al,$P_String		;AN000; (tm12)
	call	$P_Fill_Result		;AN000; (tm12)
	pop	di			;AN000; (tm12)
	pop	dx			;AN000; (tm12)
	pop	bx			;AN000; (tm12)
	pop	ax			;AN000; (tm12)
	jmp	short $P_Bridge 	;AC035; (tm12)

$P_Mat: 				;AN000; (tm12)

IF	CmpxSW				;AN000;(Check if complex item is supported)
	test	ax,$P_Cmpx_S		;AN000; Complex string
	je	$P_Match01		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Complex_Format	;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Bridge		;AN000;

$P_Match01:				;AN000;
ENDIF					;AN000;(of CmpxSW)
IF	DateSW				;AN000;(Check if date format is supported)
	test	ax,$P_Date_S		;AN000; Date string
	je	$P_Match02		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Date_Format		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Bridge		;AN000;

$P_Match02:				;AN000;
ENDIF					;AN000;(of DateSW)
IF	TimeSW				;AN000;(Check if time format is supported)
	test	ax,$P_Time_S		;AN000; Time string
	je	$P_Match03		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Time_Format		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
;	je	$P_Match03		;AN000:

	jne	$P_Bridge		;AN000; (tm09)

ENDIF					;AN000;(of TimeSW)  (tm04)
	jmp	short $P_Match03	;AN025; (tm09)

$P_Bridge:				;AN000;
;	jmp	short $P_Match_Exit (tm02)

	jmp	$P_Match_Exit		;AN000; (tm02)

$P_Match03:				;AN000;
; ENDIF ;AN000;(of TimeSW) (tm04)
IF	NumSW				;AN000;(Check if numeric value is supported)
	test	ax,$P_Num_Val		;AN000; Numeric value
	je	$P_Match04		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Value		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Match_Exit		;AN000;

$P_Match04:				;AN000;
	test	ax,$P_SNUM_Val		;AN000; Signed numeric value
	je	$P_Match05		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_SValue		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Match_Exit		;AN000;

$P_Match05:				;AN000;
ENDIF					;AN000;(of NumSW)
IF	DrvSW				;AN000;(Check if drive only is supported)
	test	ax,$P_Drv_Only		;AN000; Drive only
	je	$P_Match06		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_File_Format		;AN000; 1st, call file format
	call	$P_Drive_Format 	;AN000; check drive format, next
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examinee the next type
	jne	$P_Match_Exit		;AN000;

$P_Match06:				;AN000;
ENDIF					;AN000;(of DrvSW)
IF	FileSW				;AN000;(Check if file spec is supported)
	test	ax,$P_File_Spc		;AN000; File spec
	je	$P_Match07		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_File_Format		;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Match_Exit		;AN000;

$P_Match07:				;AN000;
ENDIF					;AN000;(of FileSW)
IF	QusSW				;AN000;(Check if quoted string is supported)
	test	ax,$P_Qu_String 	;AN000; Quoted string
	je	$P_Match08		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Quoted_Format	;AN000; do process
	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; if error, examine the next type
	jne	$P_Match_Exit		;AN000;

$P_Match08:				;AN000;
ENDIF					;AN000;(of QusSW)
	test	ax,$P_Simple_S		;AN000; Simple string
	je	$P_Match09		;AN000;

	mov	psdata_seg:$P_RC,$P_No_Error ;AC034; assume no error
	call	$P_Simple_String	;AN000; do process
;;;;	cmp	psdata_seg:$P_RC,$P_Syntax ;AC034; These two lines will be alive
;;;;	jne	$P_Match_Exit			   ;when extending the match_flags.
$P_Match09:				;AN000;
$P_Match_Exit:				;AN000;
	cmp	psdata_seg:$P_err_flag,$P_error_filespec ;AC034; bad filespec ?
	jne	$P_Match2_Exit		;AN033; no, continue
	cmp	psdata_seg:$P_RC,$P_No_Error ;AN033;AC034;; check for other errors ?
	jne	$P_Match2_Exit		;AN033; no, continue
	mov	psdata_seg:$P_RC,$P_Syntax ;AN033;AC034;; set error flag
$P_Match2_Exit: 			;AN033;
	pop	ax			;AN000;
	ret				;AN000;
$P_Check_Match_Flags endp		;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Remove_Colon;
;
; Function: Remove colon at end
;
; Input:    psdata_seg:SI points to string buffer to be examineed
;
; Output:   None
;
; Use:	$P_Chk_DBCS
;***********************************************************************
$P_Remove_Colon proc			;AN000;
	push	ax			;AN000;
	push	si			;AN000;
$P_RCOL_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; get character
	or	al,al			;AN000; end of string ?
	je	$P_RCOL_Exit		;AN000; if yes, just exit

	cmp	al,$P_Colon		;AN000; is it colon ?
	jne	$P_RCOL00		;AN000;

	cmp	byte ptr psdata_seg:[si+byte],$P_NULL ;AN000; if so, next is NULL ?
	jne	$P_RCOL00		;AN000; no, then next char

	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000; yes, remove colon
	jmp	short $P_RCOL_Exit	;AN000; and exit.

$P_RCOL00:				;AN000;
	call	$P_Chk_DBCS		;AN000; if not colon, then check if
	jnc	$P_RCOL01		;AN000; DBCS leading byte.

	inc	si			;AN000; if yes, skip trailing byte
$P_RCOL01:				;AN000;
	inc	si			;AN000; si points to next byte
	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered

$P_RCOL_Exit:				;AN000;
	pop	si			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Remove_Colon endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Do_CAPS_String;
;
; Function: Perform capitalization along with the file case map table
;	    or character case map table.
;
; Input:    AL = 2 : Use character table
;	    AL = 4 : Use file table
;	    psdata_seg:SI points to string buffer to be capitalized
;
; Output:   None
;
; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
;***********************************************************************
$P_Do_CAPS_String proc			;AN000;
	push	si			;AN000;
	push	dx			;AN000;
	mov	dl,al			;AN000; save info id

$P_DCS_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; load charater and
	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
	jc	$P_DCS00		;AN000; if yes, do not need CAPS

	or	al,al			;AN000; end of string ?
	je	$P_DCS_Exit		;AN000; then exit.

	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
	mov	psdata_seg:[si],al	;AN000; stored upper case char to buffer
	jmp	short $P_DCS01		;AN000; process nexit
$P_DCS00:				;AN000;
	inc	si			;AN000; skip DBCS leading and trailing byte
$P_DCS01:				;AN000;
	inc	si			;AN000; si point to next byte
	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
$P_DCS_Exit:				;AN000;
	pop	dx			;AN000;
	pop	si			;AN000;
	ret				;AN000;
$P_Do_CAPS_String endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Do_CAPS_Char;
;
; Function: Perform capitalization along with the file case map table
;	    or character case map table.
;
; Input:    DL = 2 : Use character table
;	    DL = 4 : Use file table
;	    AL = character to be capitalized
;
; Output:   None
;
; Use:	INT 21h /w AH=65h
;***********************************************************************
$P_Do_CAPS_Char proc			;AN000;
	cmp	al,$P_ASCII80		;AN000; need upper case table ?
	jae	$P_DCC_Go		;AN000;

	cmp	al,"a"                  ;AN000; if no,
	jb	$P_CAPS_Ret		;AN000;   check if  "a" <= AL <= "z"

	cmp	al,"z"                  ;AN000;
	ja	$P_CAPS_Ret		;AN000;   if yes, make CAPS

	and	al,$P_Make_Upper	;AN000;   else do nothing.
	jmp	short $P_CAPS_Ret	;AN000;

$P_DCC_Go:				;AN000;
	push	bx			;AN000;
	push	es			;AN000;
	push	di			;AN000;
IF	CAPSW				;AN000;(Check if uppercase conversion is supported)
	lea	di,psdata_seg:$P_File_CAP_Ptr ;AC034;
	cmp	dl,$P_DOSTBL_File	;AN000; Use file CAPS table ?
	je	$P_DCC00		;AN000;

ENDIF					;AN000;(of CAPSW)
	lea	di,psdata_seg:$P_Char_CAP_Ptr ;AC034; or use char CAPS table ?
$P_DCC00:				;AN000;
	cmp	psdata_seg:[di],dl	;AN000; already got table address ?
	je	$P_DCC01		;AN000; if no,

;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
; the GET COUNTYRY INFO call.  This usage of ES is required by the function
; call, regardless of what base register is currently be defined as PSDATA_SEG.
;BASESW EQU 0 means that ES is the psdata_seg reg.

IFDEF BASESW				;AN037; If BASESW has been defined, and
  IFE BASESW				;AN037; If ES is psdata base
	push	PSDATA_SEG		;AN037; save current base reg
  ENDIF 				;AN037;
ENDIF					;AN037;

	push	ax			;AN000; get CAPS table thru DOS call
	push	cx			;AN000;
	push	dx			;AN000;


	push	PSDATA_SEG		;AC036; pass current base seg into
					;(Note: this used to push CS.  BUG...
	pop	es			;AN000;   ES reg, required for
					;get extended country information
	mov	ah,$P_DOS_Get_TBL	;AN000; get extended CDI
	mov	al,dl			;AN000; upper case table
	mov	bx,$P_DOSTBL_Def	;AN000; get active CON
	mov	cx,$P_DOSTBL_BL 	;AN000; buffer length
	mov	dx,$P_DOSTBL_Def	;AN000; get for default code page
					;DI already set to point to buffer
	int	21h			;AN000; es:di point to buffer that
					;now has been filled in with info
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
IFDEF BASESW				;AN037; If BASESW has been defined, and
  IFE BASESW				;AN037; If ES is psdata base
	pop	PSDATA_SEG		;AN037; restore current base reg
  ENDIF 				;AN037;
ENDIF					;AN037;
$P_DCC01:				;AN000;

;In this next section, ES will be used as the base of the XLAT table, provided
; by the previous GET COUNTRY INFO DOS call.  This usage of ES is made
; regardless of which base reg is currently the PSDATA_SEG reg.

IFDEF BASESW				;AN037; If BASESW has been defined, and
  IFE BASESW				;AN037; If ES is psdata base
	push	PSDATA_SEG		;AN037; save current base reg
  ENDIF 				;AN037;
ENDIF					;AN037;
	mov	bx,psdata_seg:[di+$P_DOS_TBL_Off] ;AN000; get offset of table
	mov	es,psdata_seg:[di+$P_DOS_TBL_Seg] ;AN000; get segment of table
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; skip length field
;(changed ;AN035;) add	   bx,word	;AN000; skip length field
	sub	al,$P_ASCII80		;AN000; make char to index
	xlat	es:[bx] 		;AN000; perform case map

IFDEF BASESW				;AN037; If BASESW has been defined, and
  IFE BASESW				;AN037; If ES is psdata base
	pop	PSDATA_SEG		;AN037; restore current base reg
  ENDIF 				;AN037;
ENDIF					;AN037;
	pop	di			;AN000;
	pop	es			;AN000;
	pop	bx			;AN000;
$P_CAPS_Ret:				;AN000;
	ret				;AN000;
$P_Do_CAPS_Char endp			;AN000;
PAGE					;AN000;
;***********************************************************************
IF	NumSW				;AN000;(Check if numeric value is supported)
; $P_Value / $P_SValue
;
; Function:  Make 32bit value from psdata_seg:SI and see value list
;	     and make result buffer.
;	     $P_SValue is an entry point for the signed value
;	     and this will simply call $P_Value after the handling
;	     of the sign character, "+" or "-"
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Check_OVF
;
; Vars: $P_RC(W), $P_Flags(RW)
;***********************************************************************
$P_SValue proc				;AN000; when signed value here
	push	ax			;AN000;
	or	psdata_seg:$P_Flags2,$P_Signed	    ;AC034; indicate a signed numeric
	and	psdata_seg:$P_Flags2,0ffh-$P_Neg  ;AC034; assume positive value
	mov	al,psdata_seg:[si]	;AN000; get sign
	cmp	al,$P_Plus		;AN000; "+" ?
	je	$P_SVal00		;AN000;

	cmp	al,$P_Minus		;AN000; "-" ?
	jne	$P_Sval01		;AN000; else

	or	psdata_seg:$P_Flags2,$P_Neg ;AC034; set this is negative value
$P_SVal00:				;AN000;
	inc	si			;AN000; skip sign char
$P_Sval01:				;AN000;
	call	$P_Value		;AN000; and process value
	pop	ax			;AN000;
	ret				;AN000;
$P_SValue endp				;AN000;
;***********************************************************************
$P_Value proc				;AN000;
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	xor	cx,cx			;AN000; cx = higher 16 bits
	xor	dx,dx			;AN000; dx = lower 16 bits
	push	bx			;AN000; save control pointer
$P_Value_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; get character
	or	al,al			;AN000; end of line ?
	je	$P_Value00		;AN000;

	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
	jc	$P_Value_Err0		;AN000;

	xor	ah,ah			;AN000;
	mov	bp,ax			;AN000; save binary number
	shl	dx,1			;AN000; to have 2*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	mov	bx,dx			;AN000; save low(2*x)
	mov	ax,cx			;AN000; save high(2*x)
	shl	dx,1			;AN000; to have 4*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	shl	dx,1			;AN000; to have 8*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	add	dx,bx			;AN000; now have 10*x
	adc	cx,ax			;AN000; 32bit ADD
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	add	dx,bp			;AN000; Add the current one degree decimal
	adc	cx,0			;AN000; if carry, add 1 to high 16bit
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	$P_Value_Err0		;AN000; then error, exit

	inc	si			;AN000; update pointer
	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
;
$P_Value_Err0:				;AN000;
	pop	bx			;AN000;
	jmp	$P_Value_Err		;AN000; Bridge
;
$P_Value00:				;AN000;
	pop	bx			;AN000; restore control pointer
	test	psdata_seg:$P_Flags2,$P_Neg ;AC034; here cx,dx = 32bit value
	je	$P_Value01		;AN000; was it negative ?

	not	cx			;AN000; +
	not	dx			;AN000; |- Make 2's complement
	add	dx,1			;AN000; |
	adc	cx,0			;AN000; +
$P_Value01:				;AN000; / nval =0
	mov	si,es:[bx].$P_Value_List ;AN000; si points to value list
	mov	al,es:[si]		;AN000; get nval
	cmp	al,$P_nval_None 	;AN000; no value list ?
	jne	$P_Value02		;AN000;

	mov	al,$P_Number		;AN000; Set type
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	$P_Value_Exit		;AN000;

$P_Value02:				;AN000; / nval = 1
IF	Val1SW				;AN000;(Check if value list id #1 is supported)
;(tm07) cmp	al,$P_nval_Range	;AN000; have range list ?
;(tm07) jne	$P_Value03		;AN000;

	inc	si			;AN000;
	mov	al,es:[si]		;AN000; al = number of range
	cmp	al,$P_No_nrng		;AN000; (tm07)
	je	$P_Value03		;AN000; (tm07)

	inc	si			;AN000; si points to 1st item_tag
$P_Val02_Loop:				;AN000;
	test	psdata_seg:$P_Flags2,$P_Signed ;AC034;
	jne	$P_Val02_Sign		;AN000;

	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
	jb	$P_Val02_Next		;AN000;

	ja	$P_Val_In		;AN000;

	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
	jb	$P_Val02_Next		;AN000;

$P_Val_In:				;AN000;
;;;;;;	cmp	cx,es:$P_Val_YH]	; comp cx with YH (tm01)
	cmp	cx,es:[si+$P_Val_YH]	;AN000; comp cx with YH (tm01)
	ja	$P_Val02_Next		;AN000;

	jb	$P_Val_Found		;AN000;

	cmp	dx,es:[si+$P_Val_YL]	;AN000; comp dx with YL
	ja	$P_Val02_Next		;AN000;

	jmp	short $P_Val_Found	;AN000;

$P_Val02_Sign:				;AN000;
	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
	jl	$P_Val02_Next		;AN000;

	jg	$P_SVal_In		;AN000;

	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
	jl	$P_Val02_Next		;AN000;

$P_SVal_In:				;AN000;
	cmp	cx,es:[si+$P_Val_YH]	;AN000; comp cx with YH
	jg	$P_Val02_Next		;AN000;

	jl	$P_Val_Found		;AN000;

	cmp	dx,es:[si+$P_Val_YL]	;AN000; comp dx with YL
	jg	$P_Val02_Next		;AN000;

	jmp	short $P_Val_Found	;AN000;

$P_Val02_Next:				;AN000;
	add	si,$P_Len_Range 	;AN000;
	dec	al			;AN000; loop nrng times in AL
	jne	$P_Val02_Loop		;AN000;
					; / Not found
	mov	psdata_seg:$P_RC,$P_Out_of_Range ;AC034;
	mov	al,$P_Number		;AN000;
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Value_Exit	;AN000;

ENDIF					;AN000;(of Val1SW)
IF	Val1SW+Val2SW			;AN000;(Check if value list id #1 or #2 is supported)
$P_Val_Found:				;AN000;
	mov	al,$P_Number		;AN000;
	mov	ah,es:[si]		;AN000; found ITEM_TAG set
	jmp	short $P_Value_Exit	;AN000;

ENDIF					;AN000;(of Val1SW+Val2SW)
$P_Value03:				;AN000; / nval = 2
IF	Val2SW				;AN000;(Check if value list id #2 is supported)
;;;;	cmp	al,$P_nval_Value	; have match list ? ASSUME nval=2,
;;;;	jne	$P_Value04		; even if it is 3 or more.
;(tm07) inc	si			;AN000;
;(tm07) mov	al,es:[si]		;AN000; al = nrng
	mov	ah,$P_Len_Range 	;AN000;
	mul	ah			;AN000;  Skip nrng field
	inc	ax			;AN000;
	add	si,ax			;AN000; si points to nnval
	mov	al,es:[si]		;AN000; get nnval
	inc	si			;AN000; si points to 1st item_tag
$P_Val03_Loop:				;AN000;
	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
	jne	$P_Val03_Next		;AN000;

	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
	je	$P_Val_Found		;AN000;

$P_Val03_Next:				;AN000;
	add	si,$P_Len_Value 	;AN000; points to next value choice
	dec	al			;AN000; loop nval times in AL
	jne	$P_Val03_Loop		;AN000;
					;AN000; / Not found
	mov	psdata_seg:$P_RC,$P_Not_in_Val ;AC034;
	mov	al,$P_Number		;AN000;
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Value_Exit	;AN000;

ENDIF					;AN000;(of Val2SW)
$P_Value04:				;AN000; / nval = 3 or else
$P_Value_Err:				;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034;
	mov	al,$P_String		;AN000; Set type
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
$P_Value_Exit:				;AN000;
	call	$P_Fill_Result		;AN000;
	pop	si			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Value endp				;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Check_OVF
;
; Function:  Check if overflow is occurred with consideration of
;	     signed or un-signed numeric value
;
; Input:     Flag register
;
; Output:    CY = 1  :	Overflow
;
; Vars:     $P_Flags(R)
;***********************************************************************
$P_Check_OVF proc			;AN000;
	pushf				;AN000;
	test	psdata_seg:$P_Flags2,$P_Neg ;AC034; is it negative value ?
	jne	$P_COVF 		;AN000; if no, check overflow

	popf				;AN000; by the CY bit
	ret				;AN000;

$P_COVF:				;AN000;
	popf				;AN000; else,
	jo	$P_COVF00		;AN000; check overflow by the OF

	clc				;AN000; indicate it with CY bit
	ret				;AN000; CY=0 means no overflow

$P_COVF00:				;AN000;
	stc				;AN000; and CY=1 means overflow
	ret				;AN000;
$P_Check_OVF endp			;AN000;
ENDIF					;AN000;(of FarSW)
;***********************************************************************
; $P_0099;
;
; Function:  Make ASCII 0-9 to Binary 0-9
;
; Input:     AL = character code
;
; Output:    CY = 1 : AL is not number
;	     CY = 0 : AL contains binary value
;***********************************************************************
$P_0099 proc				;AN000;
	cmp	al,"0"                  ;AN000;
	jb	$P_0099Err		;AN000;  must be 0 =< al =< 9

	cmp	al,"9"                  ;AN000;
	ja	$P_0099Err		;AN000;  must be 0 =< al =< 9

	sub	al,"0"                  ;AN000; make char -> bin
	clc				;AN000; indicate no error
	ret				;AN000;

$P_0099Err:				;AN000;
	stc				;AN000; indicate error
	ret				;AN000;
$P_0099 endp				;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Simple_String
;
; Function:  See value list for the simple string
;	     and make result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_String_Comp
;
; Vars: $P_RC(W)
;***********************************************************************
$P_Simple_String proc			;AN000;
	push	ax			;AN000;
	push	bx			;AN000;
	push	dx			;AN000;
	push	di			;AN000;
	mov	di,es:[bx].$P_Value_List ;AN000; di points to value list
	mov	al,es:[di]		;AN000; get nval
	or	al,al			;AN000; no value list ?
	jne	$P_Sim00		;AN000; then

	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Sim_Exit	;AN000; and set result buffer

$P_Sim00:				;AN000;
IF	Val3SW+KeySW			;AN000;(Check if keyword or value list id #3 is supported)
	cmp	al,$P_nval_String	;AN000; String choice list provided ?
	jne	$P_Sim01		;AN000; if no, syntax error

	inc	di			;AN000;
	mov	al,es:[di]		;AN000; al = nrng
	mov	ah,$P_Len_Range 	;AN000;
	mul	ah			;AN000;  Skip nrng field
	inc	ax			;AN000; ax = (nrng*9)+1
	add	di,ax			;AN000; di points to nnval
	mov	al,es:[di]		;AN000; get nnval
	mov	ah,$P_Len_Value 	;AN000;
	mul	ah			;AN000; Skip nnval field
	inc	ax			;AN000; ax = (nnval*5)+1
	add	di,ax			;AN000; di points to nstrval
	mov	al,es:[di]		;AN000; get nstrval
	inc	di			;AC035; add '2' to
	inc	di			;AC035;  DI reg
					;AN000; di points to 1st string in list
;(replaced ;AC035;) add     di,2	;AN000; di points to 1st string in list
$P_Sim_Loop:				;AN000;
	mov	bp,es:[di]		;AN000; get string pointer
	call	$P_String_Comp		;AN000; compare it with operand
	jnc	$P_Sim_Found		;AN000; found on list ?

	add	di,$P_Len_String	;AN000; if no, point to next choice
	dec	al			;AN000; loop nstval times in AL
	jne	$P_Sim_Loop		;AN000;
					;AN000; / Not found
	mov	psdata_seg:$P_RC,$P_Not_In_Str ;AC034;
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Sim_Exit	;AN000;

$P_Sim_Found:				;AN000;
	mov	ah,es:[di-1]		;AN000; set item_tag
	mov	al,$P_List_Idx		;AN000;
	mov	dx,es:[di]		;AN000; get address of STRING
	jmp	short $P_Sim_Exit0	;AN000;
ENDIF					;AN000;(of Val3SW+KeySW)
$P_Sim01:				;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034;
	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
$P_Sim_Exit:				;AN000;
	mov	al,$P_String		;AN000; Set type
$P_Sim_Exit0:				;AN000;
	call	$P_Fill_Result		;AN000;
	pop	di			;AN000;
	pop	dx			;AN000;
	pop	bx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Simple_String endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_String_Comp:
;
; Function:  Compare two string
;
; Input:     psdata_seg:SI -> 1st string
;	     ES:BP -> 2nd string  (Must be upper case)
;	     ES:BX -> CONTROL block
;
; Output:    CY = 1 if not match
;
; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
;
; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
;***********************************************************************
$P_String_Comp proc			;AN000;
	push	ax			;AN000;
	push	bp			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	mov	dl,$P_DOSTBL_Char	;AN000; use character case map table
$P_SCOM_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; get command character
	call	$P_Chk_DBCS		;AN000; DBCS ?
	jc	$P_SCOM00		;AN000; yes,DBCS

	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
IF	KeySW+SwSW			;AN000;(Check if keyword or switch is supported)
	test	psdata_seg:$P_Flags2,$P_Key_Cmp ;AC034; keyword search ?
	je	$P_SCOM04		;AN000;

	cmp	al,$P_Keyword		;AN000; "=" is delimiter
	jne	$P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)

	cmp	byte ptr es:[bp+1],$P_NULL ;AN021;   at end of keyword string in the control block THEN
	jne	$P_SCOM_DIFFER		;AN021;

	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list

$P_SCOM04:				;AN000;
	test	psdata_seg:$P_Flags2,$P_SW_Cmp ;AC034; switch search ?
	je	$P_SCOM03		;AN000;

	cmp	al,$P_Colon		;AN000; ":" is delimiter, at end of switch on command line
	jne	$P_SCOM03		;AN000; continue compares

	cmp	byte ptr es:[bp],$P_NULL ;AN021; IF at end of switch on command AND
	jne	$P_SCOM_DIFFER		;AN021;   at end of switch string in the control block THEN

$P_SCOM05:				;AN000;   found a match
	inc	si			;AN000; si points to just after "=" or ":"
	jmp	short $P_SCOM_Same	;AN000; exit

$P_SCOM03:				;AN000;
ENDIF					;AN000;(of KeySW+SwSW)
	cmp	al,es:[bp]		;AN000; compare operand w/ a synonym
	jne	$P_SCOM_Differ0 	;AN000; if different, check ignore colon option

	or	al,al			;AN000; end of line
	je	$P_SCOM_Same		;AN000; if so, exit

	inc	si			;AN000; update operand pointer
	inc	bp			;AN000; 	   and synonym pointer
	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case

$P_SCOM00:				;AN000; Here al is DBCS leading byte
	cmp	al,es:[bp]		;AN000; compare leading byte
	jne	$P_SCOM_Differ		;AN000; if not match, say different

	inc	si			;AN000; else, load next byte
	mov	al,psdata_seg:[si]	;AN000; and
	inc	bp			;AN000;
	cmp	al,es:[bp]		;AN000; compare 2nd byte
	jne	$P_SCOM_Differ		;AN000; if not match, say different, too

	inc	si			;AN000; else update operand pointer
	inc	bp			;AN000; 		and synonym pointer
$P_SCOM01:				;AN000;
	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case

$P_SCOM_Differ0:			;AN000;

IF	SwSW				;AN000;(tm10)
	test	psdata_seg:$P_Flags2,$P_SW ;AC034;(tm10)
	je	$P_not_applicable	;AN000;(tm10)

	test	es:[bx].$P_Function_Flag,$P_colon_is_not_necessary ;AN000;(tm10)
	je	$P_not_applicable	;AN000;(tm10)

	cmp	byte ptr es:[bp],$P_NULL ;AN000;(tm10)
;(deleted ;AN025;) jne $P_not_applicable ;AN000;(tm10)
	je	$P_SCOM_Same		;AN025;(tm10)

$P_not_applicable:			;AN000;(tm10)
ENDIF					;AN000;(tm10)

	test	es:[bx].$P_Match_Flag,$P_Ig_Colon ;AN000; ignore colon option specified ?
	je	$P_SCOM_Differ		;AN000; if no, say different.

	cmp	al,$P_Colon		;AN000; End up with ":" and
	jne	$P_SCOM02		;AN000;    subseqently

	cmp	byte ptr es:[bp],$P_NULL ;AN000;       NULL ?
	jne	$P_SCOM_Differ		;AN000; if no, say different

	jmp	short $p_SCOM_Same	;AN000; else, say same

$P_SCOM02:				;AN000;
	cmp	al,$P_NULL		;AN000; end up NULL and :
	jne	$P_SCOM_Differ		;AN000;

	cmp	byte ptr es:[bp],$P_Colon ;AN000; if no, say different
	je	$p_SCOM_Same		;AN000; else, say same

$P_SCOM_Differ: 			;AN000;
	stc				;AN000; indicate not found
	jmp	short $P_SCOM_Exit	;AN000;

$P_SCOM_Same:				;AN000;
	mov	psdata_seg:$P_KEYorSW_Ptr,si ;AC034; for later use by keyword or switch
	clc				;AN000; indicate found
$P_SCOM_Exit:				;AN000;
	pop	si			;AN000;
	pop	dx			;AN000;
	pop	bp			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_String_Comp endp			;AN000;
PAGE					;AN000;
;***********************************************************************
IF	DateSW				;AN000;(Check if date format is supported)
; $P_Date_Format
;
; Function:  Convert a date string to DOS date format for int 21h
;	     with format validation.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
;
; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
;***********************************************************************
$P_Date_Format proc			;AN000;
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	call	$P_Set_CDI		;AN000; set country dependent information before process
;	mov	bl,psdata_seg:[si].$P_CDI_DateS ;load date separator ;AN020; (deleted)
;					note: the country info is still needed
;					to determine the order of the fields,
;					but the separator char is no longer used.
	pop	si			;AN000;
	mov	psdata_seg:$P_1st_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_2nd_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_3rd_Val,0 ;AC034; set initial value
	call	$P_Get_DecNum		;AN000; get 1st number
	jc	$P_DateF_Err0		;AN000;-----------------------+

	mov	psdata_seg:$P_1st_Val,ax ;AC034;	      |
	or	bl,bl			;AN000; end of line ?	      |
	je	$P_DateF_YMD		;AN000; 		      |

	call	$P_Get_DecNum		;AN000; get 2nd number	      |
	jc	$P_DateF_Error		;AN000; 		      |

	mov	psdata_seg:$P_2nd_Val,ax ;AC034;	      |
	or	bl,bl			;AN000; end of line ?	      |
	je	$P_DateF_YMD		;AN000; 		      |

	call	$P_Get_DecNum		;AN000; get 3rd number	      |
$P_DateF_Err0:				;AN000; Bridge	  <-----------+
	jc	$P_DateF_Error		;AN000;

	mov	psdata_seg:$P_3rd_Val,ax ;AC034;
	or	bl,bl			;AN000; end of line ?
	jne	$P_DateF_Error		;AN000;

$P_DateF_YMD:				;AN000;
	mov	bx,psdata_seg:$P_Country_Info.$P_CDI_DateF ;AC034; get date format
	cmp	bx,$P_Date_YMD		;AN000;
	je	$P_DateF00		;AN000;

	mov	ax,psdata_seg:$P_1st_Val ;AC034;
	or	ah,ah			;AN000;
	jne	$P_DateF_Error		;AN000;

	mov	cl,al			;AN000; set month
	mov	ax,psdata_seg:$P_2nd_Val ;AC034;
	or	ah,ah			;AN000; if overflow, error.
	jne	$P_DateF_Error		;AN000;

	mov	ch,al			;AN000; set date
	mov	dx,psdata_seg:$P_3rd_Val ;AC034; set year
	cmp	bx,$P_Date_DMY		;AN000; from here format = MDY
	jne	$P_DateF01		;AN000; if it is DMY

	xchg	ch,cl			;AN000;  then swap M <-> D
$P_DateF01:				;AN000;
	jmp	short $P_DateF02	;AN000;

$P_DateF00:				;AN000; / here format = YMD
	mov	dx,psdata_seg:$P_1st_Val ;AC034; set year
	mov	ax,psdata_seg:$P_2nd_Val ;AC034;
	or	ah,ah			;AN000; if overflow, error
	jne	$P_DateF_Error		;AN000;

	mov	cl,al			;AN000; set month
	mov	ax,psdata_seg:$P_3rd_Val ;AC034;
	or	ah,ah			;AN000; if overflow, error
	jne	$P_DateF_Error		;AN000;

	mov	ch,al			;AN000; set date
$P_DateF02:				;AN000;
	cmp	dx,100			;AN000; year is less that 100 ?
	jae	$P_DateF03		;AN000;

	add	dx,1900 		;AN000; set year 19xx
$P_DateF03:				;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_Date_F		;AN000;     result
	call	$P_Fill_Result		;AN000; 	   buffer
	jmp	short $P_Date_Format_Exit ;AN000;	to Date

$P_DateF_Error: 			;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_String		;AN000;     result
	call	$P_Fill_Result		;AN000; 	   buffer  to string
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; indicate syntax error
$P_Date_Format_Exit:			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Date_Format endp			;AN000;
ENDIF					;AN000;(of DateSW)
PAGE					;AN000;
;***********************************************************************
IF	TimeSW+DateSW			;AN000;(Check if time or date format is supported)
; $P_Set_CDI:
;
; Function: Read CDI from DOS if it has not been read yet
;
; Input:    None
;
; Output:   psdata_seg:SI -> CDI
;
; Use:	INT 21h w/ AH = 38h
;***********************************************************************
$P_Set_CDI proc 			;AN000;
	lea	si,psdata_seg:$P_Country_Info ;AC034;
ifndef BILINGUAL
	cmp	psdata_seg:[si].$P_CDI_DateF,$P_NeedToBeRead ;AN000; already read ?
	je	$P_Read_CDI		;AN000;

	jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
endif

$P_Read_CDI:				;AN000; else read CDI thru DOS
	push	ds			;AN000;
	push	dx			;AN000;
	push	ax			;AN000;
	push	PSDATA_SEG		;AC023;
	pop	ds			;AN000; set segment register
	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
	mov	dx,si			;AN000; set offset of CDI in local data area
	int	21h			;AN000;
	pop	ax			;AN000;
	pop	dx			;AN000;
	pop	ds			;AN000;
$P_Set_CDI_Exit:			;AN000;
	ret				;AN000;
$P_Set_CDI endp 			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Get_DecNum:
;
; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
;	     or NULL encountered. And make a decimal number.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    BL = delimiter code or NULL
;	     AX = Decimal number
;	     SI advanced to the next number
;	     CY = 1 : Syntax error, AL = Latest examineed number
;
; Use:	$P_0099
;***********************************************************************
$P_Get_DecNum proc			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	xor	cx,cx			;AN000; cx will have final value
$P_GetNum_Loop: 			;AN000;
	mov	al,psdata_seg:[si]	;AN000; load character
	or	al,al			;AN000; end of line ?
	je	$P_GetNum00		;AN000; if yes, exit

	cmp	psdata_seg:$P_Got_Time,0 ;AC034; ;is this numeric in a time field?    ;AC023
	je	$P_Do_Date_Delims	;AN000;no, go check out Date delimiters  ;AC023

; Determine which delimiter(s) to check for.  Colon & period  or period only
	cmp	bl,$P_colon_period	;AN032; ;Time
	jne	$P_Do_Time_Delim1	;AN032; ;only check for period

	cmp	al,$P_Colon		;AN032; ;Is this a valid delimiter ?
	je	$P_GetNum01		;AN032; ;yes, exit

$P_Do_Time_Delim1:			;AN000;
	cmp	al,$P_Period		;;AC032;;AC023;Is this a valid delimiter ?
	je	$P_GetNum01		;AC023; yes, exit

	jmp	short $P_Neither_Delims ;AN023;

$P_Do_Date_Delims:			;AN000;
;Regardless of the date delimiter character specified in the country
;dependent information, check for the presence of any one of these
;three field delimiters: "-", "/", or ".".
	cmp	al,$P_Minus		;AN020;is this a date delimiter character?
	je	$P_GetNum01		;AN020;if yes, exit

	cmp	al,$P_Slash		;AN020;is this a date delimiter character?
	je	$P_GetNum01		;AN020;if yes, exit

	cmp	al,$P_Period		;AN020;is this a date delimiter character?
	je	$P_GetNum01		;AN000; if yes, exit

$P_Neither_Delims:			;AN023;

	call	$P_0099 		;AN000; convert it to binary
	jc	$P_GetNum_Exit		;AN000; if error exit

	mov	ah,0			;AN000;
	xchg	ax,cx			;AN000;
	mov	dx,10			;AN000;
	mul	dx			;AN000; ax = ax * 10
	or	dx,dx			;AN000; overflow
	jne	$P_GetNum02		;AN000; then exit

	add	ax,cx			;AN000;
	jc	$P_GetNum_Exit		;AN000;

	xchg	ax,cx			;AN000;
	inc	si			;AN000;
	jmp	short $P_GetNum_Loop	;AN000;

$P_GetNum00:				;AN000;
	mov	bl,al			;AN000; set bl to NULL
	clc				;AN000; indicate no error
	jmp	short $P_GetNum_Exit	;AN000;

$P_GetNum01:				;AN000;
	inc	si			;AN000; si points to next number
	clc				;AN000; indicate no error
	jmp	short $P_GetNum_Exit	;AN000;

$P_GetNum02:				;AN000;
	stc				;AN000; indicate error
$P_GetNum_Exit: 			;AN000;
	mov	ax,cx			;AN000;return value
	pop	dx			;AN000;
	pop	cx			;AN000;
	ret				;AN000;
$P_Get_DecNum endp			;AN000;
ENDIF					;AN000;(of TimeSW+DateSW)
PAGE					;AN000;
;***********************************************************************
IF	TimeSW				;AN000;(Check if time format is supported)
; $P_Time_Format
;
; Function:  Convert a time string to DOS time format for int 21h
;	     with format validation.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
;
; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
;	$P_3rd_Val(RW), $P_4th_Val(RW)
;***********************************************************************
$P_Time_Format proc			;AN000;
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	call	$P_Set_CDI		;AN000; Set country independent
					; information before process
;(AN032; deleted)  mov	   bl,psdata_seg:[si].$P_CDI_TimeS ;load time separator
;(AN032; deleted)  mov	   bh,psdata_seg:[si].$P_CDI_Dec ;load decimal separator
	test	byte ptr psdata_seg:[si].$P_CDI_TimeF,1 ;AN000; 24 hour system
	pop	si			;AN000;
	jne	$P_TimeF00		;AN000; if no, means 12 hour system

	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
$P_TimeF00:				;AN000;
	mov	psdata_seg:$P_1st_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_2nd_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_3rd_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_4th_Val,0 ;AC034; set initial value
	mov	psdata_seg:$P_Got_Time,1 ;AN023;AC034;; use time delimiter
	mov	bl,$P_colon_period	;AN032; flag, indicates use of
					; delimiters between hours,
					;  minutes,seconds
	call	$P_Get_DecNum		;AN000; get 1st number
	jc	$P_TimeF_Err0		;AN000;

	mov	psdata_seg:$P_1st_Val,ax ;AC034;
	or	bl,bl			;AN000; end of line ?
	je	$P_TimeF_Rlt		;AN000;

	call	$P_Get_DecNum		;AN000; get 2nd number
	jc	$P_TimeF_Err0		;AC038; if OK

	mov	psdata_seg:$P_2nd_Val,ax ;AC034;
	or	bl,bl			;AN000; end of line ?
	je	$P_TimeF_Rlt		;AN000;

;(;AN032; deleted) mov	   bl,bh		   ;set decimal separator
	mov	bl,$P_period_only	;AN032; flag, which to decimal separator
	call	$P_Get_DecNum		;AN000; get 3rd number
	jc	$P_TimeF_Err0		;AC039; if problem, bridge to error

	mov	psdata_seg:$P_3rd_Val,ax ;AC034;
	or	bl,bl			;AN000; end of line ?
;(DELETED ;AN039;)  je $P_TimeF_Rlt	;AN000;
	jne	$P_Time_4		;AN039; NOT END OF LINE,
					;AN039;   GO TO 4TH NUMBER
	test	psdata_seg:$P_Flags1,$P_Time_Again ;AN039; HAS TIME PARSE
					;AN039;    BEEN REPEATED?
	jnz	$P_TimeF_Rlt		;AN039; yes, this is really
					;AN039;   the end of line
					;AN039; no, time has not been repeated
	mov	si,psdata_seg:$P_SI_Save ;AN039; get where parser quit
					 ;AN039;   in command line
	cmp	byte ptr [si-1],$P_Comma ;AN039; look at delimiter
					;AN039;   from command line
	jne	$P_TimeF_Rlt		;AN039; was not a comma, this is
					;AN039;  really end of line
					;AN039; is comma before hundredths,
					;AN039;   redo TIME
	mov	byte ptr [si-1],$P_Period ;AN039; change that ambiguous
					;AN039;    comma to a decimal point
					;AN039;     parse can understand
	mov	psdata_seg:$P_Flags,0	;AN039; Clear all internal flags
	or	psdata_seg:$P_Flags1,$P_Time_Again ;AN039; indicate TIME
					;AN039; is being repeated
	mov	cx,psdata_seg:$P_ORIG_ORD ;AN039; ORIGINAL ORDINAL FROM CX
	mov	sp,psdata_seg:$P_ORIG_STACK ;AN039; ORIGINAL VALUE
					 ;AN039;   OF STACK FROM SP
	mov	si,psdata_seg:$P_ORIG_SI ;AN039; ORIGINAL START
					 ;AN039;   PARSE POINTER FROM SI
	jmp	$P_Redo_Time		;AN039; go try TIME again
; ===============================================================
$P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
	call	$P_Get_DecNum		;AN000; get 4th number
$P_TimeF_Err0:				;AN000; Bridge
	jc	$P_TimeF_Error		;AN000;

	mov	psdata_seg:$P_4th_Val,ax ;AC034;
	or	bl,bl			;AN000; After hundredth, no data allowed
	jne	$P_TimeF_Error		;AN000; if some, then error

$P_TimeF_RLT:				;AN000;
	mov	ax,psdata_seg:$P_1st_Val ;AC034;
	or	ah,ah			;AN000; if overflow then error
	jne	$P_TimeF_Err		;AN000;

	test	psdata_seg:$P_Flags1,$P_Time12am ;AN038;if "am" specified
	jz	$P_Time_notAM		;AN038;skip if no "AM" specified
					;since "AM" was specified,
	cmp	al,12			;AN038: if hour specified as later than noon
	ja	$P_TimeF_Err		;AN038; error if "AM" on more than noon
	jne	$P_Time_notAM		;AN038; for noon exactly,

	xor	al,al			;AN038; set hour = zero
$P_Time_notAM:				;AN038;
	test	psdata_seg:$P_Flags2,$P_Time12 ;AC034; if 12 hour system and pm is specified
	je	$P_TimeSkip00		;AN000; then

	cmp	al,12			;AN038; if 12:00 o'clock already
	je	$P_TimeSkip00		;AN038; it is PM already

	add	al,12			;AN000; add 12 hours to make it afternoon
	jc	$P_TimeF_Err		;AN000; if overflow then error

	cmp	al,24			;AN038; after adding 12, now cannot be >24
	ja	$P_TimeF_Err		;AN038; if too big, error

$P_TimeSkip00:				;AN000;
	mov	dl,al			;AN000; set hour
	mov	ax,psdata_seg:$P_2nd_Val ;AC034;
	or	ah,ah			;AN000; if overflow then error
	jne	$P_TimeF_Err		;AN000;

	mov	dh,al			;AN000; set minute
	mov	ax,psdata_seg:$P_3rd_Val ;AC034;
	or	ah,ah			;AN000; if overflow then error
	jne	$P_TimeF_Err		;AN000;

	mov	cl,al			;AN000; set second
	mov	ax,psdata_seg:$P_4th_Val ;AC034;
	or	ah,ah			;AN000; if overflow then error
	jne	$P_TimeF_Err		;AN000;

	mov	ch,al			;AN000; set hundredth
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_Time_F		;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer
	jmp	short $P_Time_Format_Exit ;AN000;    to time

$P_TimeF_Error: 			;AN000;
$P_TimeF_Err:				;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_String		;AN000;     result
	call	$P_Fill_Result		;AN000; 	  buffer to string
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; return syntax error
$P_Time_Format_Exit:			;AN000;
	mov	psdata_seg:$P_Got_Time,0 ;AN023;AC034;; finished with this time field
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Time_Format endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Time_2412:
;
; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    Set $P_Time12 flag when the string is terminated by "p"
;	     or "pm"
;
; Vars:  $P_Flags(W)
;***********************************************************************
$P_Time_2412 proc			;AN000;
	push	ax			;AN000;
	push	si			;AN000;
$P_T12_Loop:				;AN000;
	mov	al,psdata_seg:[si]	;AN000; Move
	inc	si			;AN000;     si
	or	al,al			;AN000;       to
	jne	$P_T12_Loop		;AN000; 	end of string

	mov	al,psdata_seg:[si-word] ;AN000; get char just before NULL
	or	al,$P_Make_Lower	;AN000; lower case map
	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
	je	$P_T1200		;AN000;

	cmp	al,"a"                  ;AN000; only "a" of "am" ?
	je	$P_T1201		;AN000;

	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
	jne	$P_T12_Exit		;AN000;

	dec	si			;AN000;
	mov	al,psdata_seg:[si-word] ;AN000;
	or	al,$P_Make_lower	;AN000; lower case map
	cmp	al,"p"                  ;AN000; "p" of "pm" ?
	je	$P_T1200		;AN000;

	cmp	al,"a"                  ;AN000; "a" of "am" ?
	je	$P_T1201		;AN000; go process "a"

	jmp	short $P_T12_Exit	;AN000; no special chars found

$P_T1200:				;AN000; "P" found
	or	psdata_seg:$P_Flags2,$P_Time12 ;AC034; flag "PM" found
	jmp	short $P_Tclr_chr	;AN038; go clear the special char

$P_T1201:				;AN000; "A" found
	or	psdata_seg:$P_Flags1,$P_Time12AM ;AN038; flag "AM" found
$P_Tclr_chr:				;AN038;
	mov	byte ptr psdata_seg:[si-2],$P_NULL ;AN000; null out special char
$P_T12_Exit:				;AN000;
	pop	si			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Time_2412 endp			;AN000;
ENDIF					;AN000;(of TimeSW)
PAGE					;AN000;
;***********************************************************************
IF	CmpxSW				;AN000;(Check if complex item is supported)
; $P_Complex_Format:
;
; Function:  Check if the input string is valid complex format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_Chk_EOL, $P_Skip_Delim
;	$P_Quoted_str, $P_Chk_DSQuote
;
; Vars: $P_RC(W), $P_SI_Save(W), $P_SaveSI_Cmpx(R), $P_Save_EOB(R)
;***********************************************************************
$P_Complex_Format proc			;AN000;
	push	ax			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	mov	bx,psdata_seg:$P_SaveSI_Cmpx ;AC034; bx points to user buffer
	cmp	byte ptr [bx],$P_Lparen ;AN000; 1st char = left parentheses
	jne	$P_Cmpx_Err		;AN000;

	xor	ah,ah			;AN000; ah = parentheses counter
$P_Cmpx_Loop:				;AN000;
	mov	al,[bx] 		;AN000; load character from command buffer
	call	$P_Chk_EOL		;AN000; if it is one of EOL
	je	$P_CmpxErr0		;AN000; then error exit.

	cmp	al,$P_Lparen		;AN000; left parentheses ?
	jne	$P_Cmpx00		;AN000; then

	inc	ah			;AC035; add '1' to AH reg
					;AN000; increment parentheses counter
;(replaced ;AC035;) add     ah,1	;AN000; increment parentheses counter
	jc	$P_CmpxErr0		;AN000; if overflow, error
$P_Cmpx00:				;AN000;
	cmp	al,$P_Rparen		;AN000; right parentheses ?
	jne	$P_Cmpx01		;AN000; then

	dec	ah			;AC035; subtract '1' from AH reg
					;AN000; decrement parentheses counter
;(changed ;AC035;) sub	   ah,1 	;AN000; decrement parentheses counter
	jc	$P_CmpxErr0		;AN000; if overflow error

	je	$P_Cmpx03		;AN000; ok, valid complex

$P_Cmpx01:				;AN000;
;(deleted ;AN025;) call $P_Chk_DSQuote	;AN000; double or single quotation mark ? 3/17/KK
	cmp	al,$P_DQuote		;AN025; double quotation mark?
	jne	$P_Cmpx04		;AN000; 3/17/KK

	mov	psdata_seg:[si],al	;AN000; here quoted string is found in the complex list.
	inc	si			;AN000;
	inc	bx			;AN000; bx points to 2nd character
	call	$P_Quoted_Str		;AN000; skip pointers until closing of quoted string
	jc	$P_CmpxErr0		;AN000; if error in quoted string syntax then exit

	jmp	short $P_Cmpx05 	;AN000;

$P_Cmpx04:				;AN000;
	call	$P_Chk_DBCS		;AN000; was it a lead byte of DBCS ?
	jnc	$P_Cmpx02		;AN000;

	mov	psdata_seg:[si],al	;AN000; then store 1st byte
	inc	si			;AN000;
	inc	bx			;AN000;
	mov	al,[bx] 		;AN000; load 2nd byte
$P_Cmpx02:				;AN000;
	mov	psdata_seg:[si],al	;AN000; store SBCS or 2nd byte of DBCS
$P_Cmpx05:				;AN000;
	inc	si			;AN000;
	inc	bx			;AN000;
	jmp	short $P_Cmpx_Loop	;AN000; loop
;----					;AN000;
$P_Cmpx03:				;AN000;
	mov	byte ptr psdata_seg:[si],al ;AN000;
	mov	byte ptr psdata_seg:[si+byte],$P_NULL ;AN000;
	mov	byte ptr [bx],$P_NULL	;AN000; replace right parentheses with NULL
	mov	si,bx			;AN000; skip whitespaces
	inc	si			;AN000;     after
	call	$P_Skip_Delim		;AN000;        right parentheses
	mov	psdata_seg:$P_SI_Save,si ;AC034; save next pointer, SI
	jmp	short $P_Cmpx_Exit	;AN000;

$P_CmpxErr0:				;AN000;
	mov	si,psdata_seg:$P_Save_EOB ;AC034; if EOF encountered, restore
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000; EOB mark
$P_Cmpx_Err:				;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034;
$P_Cmpx_Exit:				;AN000;
	mov	ah,$P_No_Tag		;AN000;
	mov	al,$P_Complex		;AN000;
	pop	si			;AN000;
	pop	bx			;AN000;
	call	$P_Fill_Result		;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Complex_Format endp			;AN000;
ENDIF					;AN000;(of CpmxSW)
PAGE					;AN000;
;***********************************************************************
IF	QusSW				;AN000;(Check if quoted string is supported)
; $P_Quoted_Format:
;
; Function:  Check if the input string is valid quoted string format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_Chk_EOL, $P_Skip_Delim
;	$P_Chk_DSQuote, $P_Quoted_Str
;
; Vars: $P_RC(W), $P_SI_Save(W), $P_SaveSI_Cmpx(R),$P_Save_EOB(R)
;***********************************************************************
$P_Quoted_Format proc			;AN000;
	push	ax			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	mov	bx,psdata_seg:$P_SaveSI_Cmpx ;AC034; bx points to user buffer
	mov	al,byte ptr [bx]	;AN000; get 1st character
;(deleted ;AN025;) call $P_Chk_DSQuote	;AN000; is it single or double quote ?
	cmp	al,$P_DQuote		;AN025; double quotation mark?
	jne	$P_Qus_Err		;AN000; if no, error

;	mov	psdata_seg:[si],al	;AN000; move it to internal buffer
;	inc	si			;AN000;
	inc	bx			;AN000; bx points to 2nd character
	call	$P_Quoted_Str		;AN000; skip pointers to the closing of quoted string
	jc	$P_Qus_Err0		;AN000; if invali quoted string syntax, exit

	mov	byte ptr psdata_seg:[si+byte],$P_NULL ;AN000; end up with NULL
	mov	si,bx			;AN000;
	inc	si			;AN000;
	call	$P_Skip_Delim		;AN000; skip whitespaces after closing quote
	mov	psdata_seg:$P_SI_Save,si ;AC034; save next pointer, SI
	jmp	short $P_Qus_Exit	;AN000;

$P_Qus_Err0:				;AN000;
	mov	si,psdata_seg:$P_Save_EOB ;AC034; if EOF encountered, restore
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000; EOB mark
$P_Qus_Err:				;AN000;AN000
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034; indicate syntax error
$P_Qus_Exit:				;AN000;
	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_Quoted_String	;AN000;    result
	pop	si			;AN000; 	 buffer
	pop	bx			;AN000; 	       to
	call	$P_Fill_Result		;AN000; 		 quoted string
	pop	ax			;AN000;
	ret				;AN000;
$P_Quoted_Format endp			;AN000;
ENDIF					;AN000;(of QusSW)
PAGE					;AN000;
;***********************************************************************
; $P_Chk_DSQuote;
;
; Function: Check if AL is double quotation or single quotation
;
; Input:    AL = byte to be examineed
;
; Output:   ZF on if AL is single or double quotetaion
;
; Vars:  $P_SorD_Quote(W)
;***********************************************************************
IF	QusSW+CmpxSW			;AN000;(Check if quoted string or complex item is supported)
;(deleted ;AN025;) $P_Chk_DSQuote proc			   ;
;(deleted ;AN025;)	   mov	   $P_SorD_Quote,$P_SQuote ; 3/17/87   assume single quote
;(deleted ;AN025;)	   cmp	   al,$P_DQuote 	   ; 1st char = double quotation ?
;(deleted ;AN025;)	   jne	   $P_CDSQ00		   ; 3/17/87
;(deleted ;AN025;)	   mov	   $P_SorD_Quote,al	   ; 3/17/87 set bigning w/ double quote
;(deleted ;AN025;)	   ret				   ; 3/17/87
;(deleted ;AN025;) $P_CDSQ00:				   ; 3/17/87
;(deleted ;AN025;)	   cmp	   al,$P_SQuote 	   ; 1st char = single quotation ?
;(deleted ;AN025;)	   ret				   ;
;(deleted ;AN025;) $P_Chk_DSQuote endp			   ;
    PAGE				;AN000;
;***********************************************************************
; $P_Quoted_Str:
;
; Function:  Copy chracacter from ES:BX to psdata_seg:SI until closing single
;	     (double) quotation found.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> Operand in command buffer
;
; Output:    CY on indicates EOF encounterd before closing quotation
;	     BX and SI
;
;
; Vars: $P_SorD_Quote(R)
;***********************************************************************
$P_Quoted_Str proc			;AN000;
	push	ax			;AN000;
$P_Qus_Loop:				;AN000;
	mov	ax,[bx] 		;AN000; 3/17/87
	call	$P_Chk_EOL		;AN000;
	je	$P_Qustr_Err0		;AN000;

;(deleted ;AN025;) cmp al,$P_SorD_Quote ;AN000; quotation ?   3/17/87
	cmp	al,$P_DQuote		;AN025; double quote?
	jne	$P_Qus00		;AN000;

;(deleted ;AN025;) cmp ah,$P_SorD_Quote ;AN000; contiguous quotation 3/17/87
	cmp	ah,$P_DQuote		;AN025; double quote?
	jne	$P_Qus02		;AN000;

;(deleted ;AN025:) mov word ptr psdata_seg:[si],ax ;AN000; 3/17/87
	mov	byte ptr psdata_seg:[si],al ;AN025; save one of the quotes
;(deleted ;AN025:) add si,2		;AN000;

	inc	si			;AC035; add '1' to SI reg
					;AN025; adjust target index
;(changed ;AC035;) add	   si,1 	;AN025; adjust target index
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; adjust source index by 2 to skip extra quote
;(changed ;AC035;) add	   bx,2 	;AN000; adjust source index by 2 to skip extra quote
	jmp	short $P_Qus_Loop	;AN000;

$P_Qus00:				;AN000;
	call	$P_Chk_DBCS		;AN000; was it a lead byte of DBCS ?
	jnc	$P_Qus01		;AN000;

	mov	psdata_seg:[si],al	;AN000; store 1st byte
	inc	si			;AN000;
	inc	bx			;AN000;
	mov	al,[bx] 		;AN000; load 2nd byte
$P_Qus01:				;AN000;
	mov	psdata_seg:[si],al	;AN000; store SBCS or 2nd byte of DBCS
	inc	si			;AN000;
	inc	bx			;AN000;
	jmp	short $P_Qus_Loop	;AN000;

$P_Qustr_Err0:				;AN000;
	stc				;AN000; indicate error
	jmp	short $P_Quoted_Str_Exit ;AN000;

$P_Qus02:				;AN000;
	mov	byte ptr psdata_seg:[si],0 ;AN000;
	clc				;AN000; indicate no error
$P_Quoted_Str_Exit:			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Quoted_Str endp			;AN000;
ENDIF					;AN000;(of QusSW+CmpxSW)
PAGE					;AN000;
;***********************************************************************
IF	FileSW+DrvSW			;AN000;(Check if file spec or drive only is supported)
; $P_File_Format;
;
; Function:  Check if the input string is valid file spec format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
;
; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
;	$P_SaveSI_Cmpx(R)
;***********************************************************************
$P_File_Format proc			;AN000;
	push	ax			;AN000;
	push	di			;AN000;
	push	si			;AN000;
	mov	di,psdata_seg:$P_SaveSI_cmpx ;AC034; get user buffer address
$P_FileF_Loop0: 			;AN000; / skip special characters
	mov	al,psdata_seg:[si]	;AN000; load character
	or	al,al			;AN000; end of line ?
	je	$P_FileF_Err		;AN000; if yes, error exit

	call	$P_FileSp_Chk		;AN000; else, check if file special character
	jne	$P_FileF03		;AN000; if yes,

;AN033; deleted   inc	  di			  ;skip
;AN033; deleted   inc	  si			  ;   the
;AN033; deleted   jmp	  short $P_FileF_Loop0	  ;	  character
	mov	psdata_seg:$P_err_flag,$P_error_filespec ;AN033;AC034;; set error flag- bad char.
	pop	si			;AN033;
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN033;
	pop	di			;AN033;
	jmp	short $P_FileF02	;AN033;


$P_FileF_Err:				;AN000;
	pop	si			;AN000;
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000;
;(deleted ;AN030;) mov di,$P_SaveSI_cmpx ;AN000; get user buffer address
;(deleted ;AN030;) mov $P_SI_Save,di	 ;AN000; update pointer to user buffer
	pop	di			;AN000;
	test	es:[bx].$P_Match_Flag,$P_Optional ;AN000; is it optional ?
	jne	$P_FileF02		;AN000;

	mov	psdata_seg:$P_RC,$P_Op_Missing ;AC034; 3/17/87
	jmp	short $P_FileF02	;AN000;

$P_FileF03:				;AN000;
	pop	ax			;AN000; discard save si
	push	si			;AN000; save new si
$P_FileF_Loop1: 			;AN000;
	mov	al,psdata_seg:[si]	;AN000; load character (not special char)
	or	al,al			;AN000; end of line ?
	je	$P_FileF_RLT		;AN000;

	call	$P_FileSp_Chk		;AN000; File special character ?
	je	$P_FileF00		;AN000;

	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
	jnc	$P_FileF01		;AN000;
	inc	di			;AN000; if yes, skip next byte
	inc	si			;AN000;
$P_FileF01:				;AN000;
	inc	di			;AN000;
	inc	si			;AN000;
	jmp	short $P_FileF_Loop1	;AN000;
;
$P_FileF00:				;AN000;
	mov	psdata_seg:$P_Terminator,al ;AC034;
	mov	byte ptr psdata_seg:[si],$P_NULL ;AN000; update end of string
	inc	di			;AN000;
	mov	psdata_seg:$P_SI_Save,di ;AC034; update next pointer in command line
$P_FileF_RLT:				;AN000;
	pop	si			;AN000;
	pop	di			;AN000;
$P_FileF02:				;AN000;

	pop	ax			;AN000; (tm14)
	test	ax,$P_File_Spc		;AN000; (tm14)
	je	$P_Drv_Only_Exit	;AN000; (tm14)

	push	ax			;AN000;  (tm14)

	mov	ah,$P_No_Tag		;AN000; set
	mov	al,$P_File_Spec 	;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer to file spec
	pop	ax			;AN000;

$P_Drv_Only_Exit:			;AN000; (tm14)

	ret				;AN000;
$P_File_Format endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_FileSp_Chk
;
; Function:  Check if the input byte is one of file special characters
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     AL = character code to be examineed
;
; Output:    ZF = 1 , AL is one of special characters
;***********************************************************************
$P_FileSp_Chk proc			;AN000;
	push	bx			;AN000;
	push	cx			;AN000;
	lea	bx,psdata_seg:$P_FileSp_Char ;AC034; special character table
	mov	cx,$P_FileSp_Len	;AN000; load length of it
$P_FileSp_Loop: 			;AN000;
	cmp	al,psdata_seg:[bx]	;AN000; is it one of special character ?
	je	$P_FileSp_Exit		;AN000;

	inc	bx			;AN000;
	loop	$P_FileSp_Loop		;AN000;

	inc	cx			;AN000; reset ZF
$P_FileSp_Exit: 			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	ret				;AN000;
$P_FileSp_Chk endp			;AN000;
ENDIF					;AN000;(of FileSW+DrvSW)
PAGE					;AN000;
;***********************************************************************
IF	DrvSW				;AN000;(Check if drive only is supported)
; $P_Drive_Format;
;
; Function:  Check if the input string is valid drive only format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS
;
; Vars: $P_RC(W)
;***********************************************************************
$P_Drive_Format proc			;AN000;
	push	ax			;AN000;
	push	dx			;AN000;
	mov	al,psdata_seg:[si]	;AN000;
	or	al,al			;AN000; if null string
	je	$P_Drv_Exit		;AN000; do nothing

	call	$P_Chk_DBCS		;AN000; is it leading byte ?
	jc	$P_Drv_Err		;AN000;

	cmp	word ptr psdata_seg:[si+byte],$P_Colon ;AN000; "d", ":", 0  ?
	je	$P_DrvF00		;AN000;

	test	es:[bx].$P_Match_Flag,$P_Ig_Colon ;AN000; colon can be ignored?
	je	$P_Drv_Err		;AN000;

	cmp	byte ptr psdata_seg:[si+byte],$P_NULL ;AN000; "d", 0  ?
	jne	$P_Drv_Err		;AN000;

$P_DrvF00:				;AN000;
	or	al,$P_Make_Lower	;AN000; lower case
	cmp	al,"a"                  ;AN000; drive letter must
	jb	$P_Drv_Err		;AN000; in range of

	cmp	al,"z"                  ;AN000; "a" - "z"
	ja	$P_Drv_Err		;AN000; if no, error

	sub	al,"a"-1                ;AN000; make text drive to binary drive
	mov	dl,al			;AN000; set
	mov	ah,$P_No_Tag		;AN000;    result
	mov	al,$P_Drive		;AN000; 	 buffer
	call	$P_Fill_Result		;AN000; 	       to drive
	jmp	short $P_Drv_Exit	;AN000;

$P_Drv_Err:				;AN000;
	mov	psdata_seg:$P_RC,$P_Syntax ;AC034;
$P_Drv_Exit:				;AN000;
	pop	dx			;AN000;
	pop	ax			;AN000;
	ret				;AN000;
$P_Drive_Format endp			;AN000;
ENDIF					;AN000;(of DrvSW)
PAGE					;AN000;
;***********************************************************************
; $P_Skip_Delim;
;
; Function: Skip delimiters specified in the PARMS list, white space
;	    and comma.
;
; Input:    DS:SI -> Command String
;	    ES:DI -> Parameter List
;
; Output:   CY = 1 if the end of line encounterd
;	    CY = 0 then SI move to 1st non-delimiter character
;	    AL = Last examineed character
;
; Use:	    $P_Chk_EOL, $P_Chk_Delim,
;
; Vars:     $P_Flags(R)
;***********************************************************************
$P_Skip_Delim proc			;AN000;
$P_Skip_Delim_Loop:			;AN000;
	LODSB				;AN000;
	call	$P_Chk_EOL		;AN000; is it EOL character ?
	je	$P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on

	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
	jne	$P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off

	test	psdata_seg:$P_Flags2,$P_Extra ;AC034; extra delim or comma found ?
	je	$P_Skip_Delim_Loop	;AN000; if no, loop

	test	psdata_seg:$P_Flags2,$P_SW+$P_equ ;AC034; /x , or xxx=zzz , (tm08)
	je	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)

	dec	si			;AN000; backup si for next call (tm08)
	jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off

$P_Skip_Delim_CY:			;AN000;
	stc				;AN000; indicate EOL
	jmp	short $P_Skip_Delim_Exit ;AN000;

$P_Skip_Delim_NCY:			;AN000;
	clc				;AN000; indicate non delim
$P_Skip_Delim_Exit:			;AN000; in this case, need
	dec	si			;AN000;  backup index pointer
	ret				;AN000;

$P_Exit_At_Extra:			;AN000;
	clc				;AN000; indicate extra delim
	ret				;AN000;
$P_Skip_Delim endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_EOL;
;
; Function: Check if AL is one of End of Line characters.
;
; Input:    AL = character code
;	    ES:DI -> Parameter List
;
; Output:   ZF = 1 if one of End of Line characters
;**********************************************************************
$P_Chk_EOL proc 			;AN000;
	push	bx			;AN000;
	push	cx			;AN000;
	cmp	al,$P_CR		;AN000; Carriage return ?
	je	$P_Chk_EOL_Exit 	;AN000;

	cmp	al,$P_NULL		;AN000; zero ?
	je	$P_Chk_EOL_Exit 	;AN000;

IF LFEOLSW				;AN028; IF LF TO BE ACCEPTED AS EOL
	cmp	al,$P_LF		;AN000; Line feed ?
	je	$P_Chk_EOL_Exit 	;AN000;
ENDIF					;AN028;

	cmp	byte ptr es:[di].$P_Num_Extra,$P_I_Have_EOL ;AN000; EOL character specified ?
	jb	$P_Chk_EOL_Exit 	;AN000;

	xor	bx,bx			;AN000;
	mov	bl,es:[di].$P_Len_Extra_Delim ;AN000; get length of delimiter list
	add	bx,$P_Len_PARMS 	;AN000; skip it
	cmp	byte ptr es:[bx+di],$P_I_Use_Default ;AN000; No extra EOL character ?
	je	$P_Chk_EOL_NZ		;AN000;

	xor	cx,cx			;AN000; Get number of extra chcracter
	mov	cl,es:[bx+di]		;AN000;
$P_Chk_EOL_Loop:			;AN000;
	inc	bx			;AN000;
	cmp	al,es:[bx+di]		;AN000; Check extra EOL character
	je	$P_Chk_EOL_Exit 	;AN000;

	loop	$P_Chk_EOL_Loop 	;AN000;

$P_Chk_EOL_NZ:				;AN000;
	cmp	al,$P_CR		;AN000; reset ZF
$P_Chk_EOL_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	ret				;AN000;
$P_Chk_EOL endp 			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_Delim;
;
; Function: Check if AL is one of delimiter characters.
;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
;	    blanks.
;
; Input:    AL = character code
;	    DS:SI -> Next Character
;	    ES:DI -> Parameter List
;
; Output:   ZF = 1 if one of delimiter characters
;	    SI points to the next character
; Vars:  $P_Terminator(W), $P_Flags(W)
;***********************************************************************
$P_Chk_Delim proc			;AN000;
	push	bx			;AN000;
	push	cx			;AN000;
	mov	psdata_seg:$P_Terminator,$P_Space   ;AC034; Assume terminated by space
	and	psdata_seg:$P_Flags2,0ffh-$P_Extra ;AC034;
	cmp	al,$P_Space		;AN000; Space ?
	je	$P_Chk_Delim_Exit	;AN000;

	cmp	al,$P_TAB		;AN000; TAB ?
	je	$P_Chk_Delim_Exit	;AN000;

	cmp	al,$P_Comma		;AN000; Comma ?
	je	$P_Chk_Delim_Exit0	;AN000;

$P_Chk_Delim00: 			;AN000;
	cmp	al,$P_DBSP1		;AN000; 1st byte of DBCS Space ?
	jne	$P_Chk_Delim01		;AN000;

	cmp	byte ptr [si],$P_DBSP2	;AN000; 2nd byte of DBCS Space ?
	jne	$P_Chk_Delim01		;AN000;

	mov	al,$P_Space		;AN000;
	inc	si			;AN000; make si point to next character
	cmp	al,al			;AN000; Set ZF
	jmp	short $P_Chk_Delim_Exit ;AN000;

$P_Chk_Delim01: 			;AN000;
	cmp	byte ptr es:[di].$P_Num_Extra,$P_I_Have_Delim ;AN000; delimiter character specified ?
	jb	$P_Chk_Delim_Exit	;AN000;

	xor	cx,cx			;AN000;
	mov	cl,es:[di].$P_Len_Extra_Delim ;AN000; get length of delimiter list
	or	cx,cx			;AN000; No extra Delim character ?
	je	$P_Chk_Delim_NZ 	;AN000;

	mov	bx,$P_Len_PARMS-1	;AN000; set bx to 1st extra delimiter
$P_Chk_Delim_Loop:			;AN000;
	inc	bx			;AN000;
	cmp	al,es:[bx+di]		;AN000; Check extra Delim character
	je	$P_Chk_Delim_Exit0	;AN000;

	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter

$P_Chk_Delim_NZ:			;AN000;
	cmp	al,$P_Space		;AN000; reset ZF
$P_Chk_Delim_Exit:			;AN000;
;;;;	jne	$P_ChkDfin
;;;;	mov	psdata_seg:$P_Terminator,al ;AN034;
$P_ChkDfin:				;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	ret				;AN000;

$P_Chk_Delim_Exit0:			;AN000;
	mov	psdata_seg:$P_Terminator,al ;AC034; keep terminated delimiter
	test	psdata_seg:$P_Flags2,$P_Equ  ;AN027;AC034;; if terminating a key=
	jnz	$P_No_Set_Extra 	;AN027; then do not set the EXTRA bit

	or	psdata_seg:$P_Flags2,$P_Extra ;AC034; flag terminated extra delimiter or comma
$P_No_Set_Extra:			;AN027;
	cmp	al,al			;AN000; set ZF
	jmp	short $P_Chk_Delim_Exit ;AN000;

$P_Chk_Delim endp			;AN000;
PAGE					;AN000;
;***********************************************************************
; $P_Chk_Switch;
;
; Function: Check if AL is the switch character not in first position of
;	    $P_STRING_BUF
;
; Input:    AL = character code
;	    BX = current pointer within $P_String_Buf
;	    SI =>next char on command line (following the one in AL)
;
; Output:   CF = 1 (set)if AL is switch character, and not in first
;		 position, and has no chance of being part of a date string,
;		 i.e. should be treated as a delimiter.

;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
;		 position, or is a slash but may be part of a date string, i.e.
;		 should not be treated as a delimiter.
;
; Vars:  $P_Terminator(W)

; Use:	 $P_0099
;***********************************************************************
$P_Chk_Switch proc			;AN000;

;AN020;; Function: Check if AL is the switch character from 2nd position of $P_STRING_BUF
;AN020;; Output:   ZF = 1 if switch character
;AN020;;	lea	bp,$P_STRING_BUF ;AN000;
;AN020;;	cmp	bx,bp		 ;AN000; 1st position ?
;AN020;;	je	$P_Chk_S_Exit_1  ;AN000;
;AN020;;	cmp	al,$P_Switch	 ;AN000;
;AN020;;	jmp	short $P_Chk_S_Exit_0  ;AN000;
;AN020;;$P_Chk_S_Exit_1:		       ;AN000;
;AN020;;	cmp	al,$P_Switch	 ;AN000; (tm08)
;AN020;;	jne	$P_Nop		;AN000; (tm08)
;AN020;;	or	$P_Flags2,$P_SW  ;AN000; (tm08) It could be valid switch
;AN020;;$P_Nop: 			;AN000; (tm08)
;AN020;;	inc	bp		       ;AN000;
;AN020;;	cmp	bx,bp		       ;AN000; reset ZF
;AN020;;$P_Chk_S_Exit_0:		       ;AN000;
;AN020;;	jne	$P_Chk_S_Exit	       ;AN000;
;AN020;;	mov	   $P_Terminator,al    ;AN000; store switch character
;AN020;;$P_Chk_S_Exit:			       ;AN000;

	LEA	BP,psdata_seg:$P_String_Buf ;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
;	.IF <BX NE BP> THEN		;AN020;IF not first char THEN
	cmp	BX,BP			;AN000;
	je	$P_STRUC_L2		;AN000;

;	    .IF <AL EQ $P_Switch> THEN	;AN020;otherwise see if a slash
	    cmp     AL,$P_Switch	;AN000;
	    jne     $P_STRUC_L5 	;AN000;

		STC			;AN020;not in first position and is slash, now see if might be in date string
IF	DateSw				;AN020;caller looking for date, see if this may be part of one
		PUSH	AX		;AN020;save input char
		MOV	AL,PSDATA_SEG:[BX-1] ;AN026;AL=char before the current char
		CALL	$P_0099 	;AN020;return carry set if not numeric
;		.IF   NC ;AND		;AN020;IF previous char numeric AND
		jc	$P_STRUC_L7	;AN000;

		    MOV     AL,[SI]	;AN020;AL=char after the current char
		    CALL    $P_0099	;AN020;return carry set if not numeric
;(deleted)	    .IF     NC THEN	;AN020;IF next char numeric THEN could be a date
;(deleted)		CLC		;AN020;reset CF so "/" not treated as a delimiter
;(deleted)	    .ENDIF		;AN026;
;		.ENDIF			;AN020;ENDIF looks like date (number/number)
$P_STRUC_L7:				;AN000;
		POP	AX		;AN020;restore AL to input char
ENDIF					;AN020;DateSw
;	    .ELSE			;AN020;
	    jmp     short $P_STRUC_L1	;AN000;

$P_STRUC_L5:				;AN000;
		CLC			;AN020;not a slash
;	    .ENDIF			;AN020;
;	.ELSE				;AN020;is first char in the buffer, ZF=0
	jmp	short $P_STRUC_L1	;AN000;

$P_STRUC_L2:				;AN000;
;	    .IF <AL EQ $P_Switch> THEN	;AN020;
	    cmp     AL,$P_Switch	;AN000;
	    jne     $P_STRUC_L12	;AN000;

		OR	psdata_seg:$P_Flags2,$P_SW ;AN020;AC034;;could be valid switch, first char and is slash
;	    .ENDIF			;AN020;
$P_STRUC_L12:				;AN000;
	    CLC 			;AN020;CF=0 indicating first char
;	.ENDIF				;AN020;
$P_STRUC_L1:				;AN000;

	ret				;AN000;
$P_Chk_Switch endp			;AN000;
	PAGE				;AN000;
;**************************************************************************
; $P_Chk_DBCS:
;
;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
;
;  Input:
;	  AL	= Code to be examineed
;
;  Output:
;	  If CF is on then a lead byte of DBCS
;
; Use: INT 21h w/AH=63
;
; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
;***************************************************************************
$P_Chk_DBCS PROC			;AN000;
;
	PUSH	DS			;AN000;
	PUSH	SI			;AN000;
	PUSH	bx			;AN000; (tm11)
	CMP	psdata_seg:$P_DBCSEV_SEG,0 ;AC034; ALREADY SET ?
	JNE	$P_DBCS00		;AN000;

	PUSH	AX			;AN000;
;	PUSH	BX			;AN000; (tm11)
	PUSH	ds			;AN000; (tm11)
	PUSH	CX			;AN000;
	PUSH	DX			;AN000;
	PUSH	DI			;AN000;
	PUSH	BP			;AN000;
	PUSH	ES			;AN000;
	XOR	SI,SI			;AN000;
	MOV	DS,SI			;AN000;
	MOV	AX,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
	INT	21H			;AN000;

;	MOV	AX,DS			;AN000; (tm11)
;	OR	AX,AX			;AN000; (tm11)
	MOV	bx,DS			;AN000; (tm11)
	OR	bx,bx			;AN000; (tm11)
	POP	ES			;AN000;
	POP	BP			;AN000;
	POP	DI			;AN000;
	POP	DX			;AN000;
	POP	CX			;AN000;
;	POP	BX			;AN000; (tm11)
	POP	ds			;AN000; (tm11)
	POP	AX			;AN000;
	JE	$P_NON_DBCS		;AN000;

$P_DBCS02:				;AN000;
	MOV	psdata_seg:$P_DBCSEV_OFF,SI ;AC034; save EV offset
;	MOV	psdata_seg:$P_DBCSEV_SEG,DS ;AC034; save EV segment
	MOV	psdata_seg:$P_DBCSEV_SEG,bx ;AC034; save EV segment (tm11)
$P_DBCS00:				;AN000;
	MOV	SI,psdata_seg:$P_DBCSEV_OFF ;AC034; load EV offset
	MOV	DS,psdata_seg:$P_DBCSEV_SEG ;AC034; and segment

$P_DBCS_LOOP:				;AN000;
	CMP	WORD PTR [SI],0 	;AN000; zero vector ?
	JE	$P_NON_DBCS		;AN000; then exit

	CMP	AL,[SI] 		;AN000;
	JB	$P_DBCS01		;AN000; Check if AL is in

	CMP	AL,[SI+BYTE]		;AN000;   range of
	JA	$P_DBCS01		;AN000;      the vector

	STC				;AN000; if yes, indicate DBCS and exit
	JMP	short $P_DBCS_EXIT	;AN000;

$P_DBCS01:				;AN000;
	INC	SI			;AC035; add '2' to
	INC	SI			;AC035;  SI reg
					;AN000; get next vector
;(changed ;AC035;) ADD	   SI,2 	;AN000; get next vector
	JMP	short $P_DBCS_LOOP	;AN000; loop until zero vector found

$P_NON_DBCS:				;AN000;
	CLC				;AN000; indicate SBCS
$P_DBCS_EXIT:				;AN000;
	POP	bx			;AN000; (tm11)
	POP	SI			;AN000;
	POP	DS			;AN000;
	RET				;AN000;
$P_Chk_DBCS ENDP			;AN000;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\pathmac.inc ===
;;***********************************************************************
;; NAME: pathlabl
;; DESC: creates a public label at the spot it is placed, using the name
;;       given.
;; INPUT: either module name or procedure name
;; OUTPUT: public label
;; LOGIC: LBL-parameter-name will have four values -
;;            - one for each pass (2)
;;            - one for start and one for stop
;;        if LBL is not defined, it is first pass, at beginning label
;;              - set it to 1 and create the start label
;;        if LBL = 1, it is first pass, at end label
;;              - set it to 2 and create stop label
;;        if LBL = 2, it is second pass, at beginning label
;;              - set it to 3 and create the start label
;;        if LBL = 3, it is second pass, at end label
;;              - set it to 4 and create stop label
;;        if LBL = 4, it is second pass,
;;              - this macro has been invoked more than twice with same parm
;;              - issue error message
;;***********************************************************************
IF1
;    %OUT COMPONENT=COMMON, MODULE=PATHMAC.INC ...
ENDIF

pathlabl MACRO pnam
IFNDEF LBL_&pnam                        ;;IF THIS IS THE FIRST TIME,
    LBL_&pnam = 0                       ;;DEFINE IT, INITIALLY ZERO
ELSE                                    ;;SINCE IT IS DEFINED
    IF (LBL_&pnam GT 3)                 ;;IF USED TOO MANY TIMES,
        .ERR NON-UNIQUE OPERAND ON PATHLABL
        EXITM                           ;;ABORT THIS GENERATION
    ENDIF
ENDIF

IF (LBL_&pnam EQ 0) OR (LBL_&pnam EQ 2) ;;ready for START?
    $$A_START_&pnam:                    ;;create START label
    PUBLIC $$A_START_&pnam              ;;make it public
ELSE                                    ;;SINCE SWITCH MAY BE 1 OR 3,
    $$A_STOP_&pnam:                     ;;create STOP label
    PUBLIC $$A_STOP_&pnam               ;;make it public
ENDIF
LBL_&pnam = LBL_&pnam + 1               ;;INCREMENT SWITCH
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\origin.inc ===
;-------------------------------------------------------------------------
;
; FILE : ORIGIN.INC
;
; This is included in origin.asm and mshead.asm. Contains the equate that
; is used for ORGing the DOS code.
;
; Brief Description of the necessacity of this ORG:
; -------------------------------------------------
;
; A special problem exits when running out of the HMA. The HMA starts at 
; address FFFF:10. There is no place in the HMA with an offset of zero.
; This means programs running out off the HMA must use non-zero offset base
; addresses. It also means that if we're running multiple programs from the
; HMA, the base offset of each segment must atleast be as big as all of the
; HMA segments that precede it.
; 
; One solution to this problem to ORG each module at 64K minus its size.
; For instance a code segment 1234h bytes in length would org'd at edcbh.
; This gives max. flexibility regarding it's location in the HMA. By 
; selecting segment values between f124h and ffffh it could be located 
; anywhere in the HMA. The problem with this is that programs with such 
; high ORGs would not be able to run in low RAM.
;
; A comporomise solution is to set the ORG address somewhere between 0010h
; and ffffh - their size. In the particular case of the BIOS and the DOS 
; the folloowing solution has been implemented:
;
; The Bios Code segment will have a very small offset and run at the very
; front of the HMA, after the VDISK header. THE Dos Code segment will have 
; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
; DATA segment when DOS is running low>). This will reflect the lowest 
; possible physical address at which DOS code will run, while still providing
; max. possible flexibility in HMA positioning. This offset MUST NOT be 
; smaller then that 20+size of Bios Code segment when running high. This is 
; mostly true.
;
; Also this ORG'd value must be communicated to the BIOS. This is done by
; putting this value after the first jmp instruction in the DOS code in
; mshead.asm. 
;
; In order for the stripz utility to know how many zeroes to be stripped 
; out, this value is placed at the beginning of the binary in origin.asm.
;
; Revision History:
;
; Currently this is being done manually. Therefore any change in the DOS DATA
; Size or the BIOS size should be reflected here. --- Feb 90
;
; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
; A utility called getsize will obtain the corresponding values from msdos
; and msbio.map and update the values in BDSIZ.INC if they are different. 
; DOS should now be built using the batch file makedos.bat which invokes this
; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
; dependant on that.				  --- Apr 3 '90
;
; For ROMDOS, however, there is no need to org the doscode to any location
; other than zero.  Therefore the stripz utility will not need to be used,
; so the offset will not need to be included at the beginning of the code
; segment.  Also, the BIOS can just assume that the resident code begins
; at offset zero within the segment.
; 
;
;--------------------------------------------------------------------------
 	
; 	

BIODATASTART	EQU    	00700h
include	bdsize.inc		; this sets the values:
				;	BIODATASIZ
				;	BIOCODESIZ
				;	DOSDATASIZ

ifndef NEC_98
BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
PARASTART	EQU	((BYTSTART + 0FH) AND (NOT 0FH)) - 40h
else    ;NEC_98
BYTSTART	EQU    	BIOCODESIZ
PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	
endif   ;NEC_98

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\msgserv.asm ===
; * * * * * * * * * * * * START OF SPECIFICATIONS * * * * * * * * * * * * * * *
;
; MODULE NAME: MSGSERV.SAL
;
; DESCRIPTIVE NAME: Message Services SALUT file
;
; FUNCTION: This module incorporates all the messages services and
;	    is called upon at build time to INCLUDE the code requested
;	    by a utility. Code is requested using the macro MSG_SERVICES.
;
; ENTRY POINT: Since this a collection of subroutines, entry point is at
;	    requested procedure.
;
; INPUT: Since this a collection of subroutines, input is dependent on function
;	    requested.
;
; EXIT-NORMAL: In all cases, CARRY FLAG = 0
;
; EXIT-ERROR: In all cases, CARRY FLAG = 1
;
; INTERNAL REFERENCES: (list of included subroutines)
;
;	- SYSLOADMSG
;	- SYSDISPMSG
;	- SYSGETMSG
;
;
; EXTERNAL REFERENCES: None
;
; NOTES: At build time, some modules must be included. These are only included
;	 once using assembler switches. Other logic is included at the request
;	 of the utility.
;
;	 COMR and COMT are assembler switches to conditionally assemble code
;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
;	 storage and multiple EQUates.
;
; REVISION HISTORY: Created MAY 1987
;
;     Label: DOS - - Message Retriever
;	     (c) Copyright 1988 Microsoft
;
;
; * * * * * * * * * * * * END OF SPECIFICATIONS * * * * * * * * * * * * * * * *
; Page 

;
;	Revision History
;	================
;
;	M007	SR	08/24/90	Fixed bug #1818 -- changed
;				$M_DISPLAY_H_STRING to properly
;				handle Ctrl-Z being passed
;
;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
;				these routines are no longer assembled.
;
;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
;				CR-LF string also gets reinitialized
;				on every cycle.
;
;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
;				& $_MSG_NUM also in SYSLOADMSG.
;



;   $SALUT	     $M  (2,5,22,62)			     ;;AN000;; Set SALUT formatting

IF  $M_STRUC						     ;;AN000;; IF we haven't included the structures yet THEN
    $M_STRUC	     =	FALSE				     ;;AN000;;	 Let the assembler know that we have
							     ;;AN000;;	   and include them

    PAGE
    SUBTTL	     DOS - Message Retriever - MSGSTR.INC Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_SUBLIST_STRUC
;;
;; Replacable parameters are described by a sublist structure
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_SUBLIST_STRUC STRUC					     ;;AN000;;
							     ;;
    $M_S_SIZE	     DB        11			     ;;AN000;; SUBLIST size  (PTR to next SUBLIST)
    $M_S_RESV	     DB        0			     ;;AN000;; RESERVED
    $M_S_VALUE	     DD        ?			     ;;AN000;; Time, Date or PTR to data item
    $M_S_ID	     DB        ?			     ;;AN000;; n of %n
    $M_S_FLAG	     DB        ?			     ;;AN000;; Data-type flags
    $M_S_MAXW	     DB        ?			     ;;AN000;; Maximum field width
    $M_S_MINW	     DB        ?			     ;;AN000;; Minimum field width
    $M_S_PAD	     DB        ?			     ;;AN000;; Character for Pad field
							     ;;
$M_SUBLIST_STRUC ENDS					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_CLASS_ID
;;
;; Each class will be defined by this structure.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CLASS_ID STRUC					     ;;AN000;;
							     ;;
    $M_CLS_ID	     DB        -1			     ;;AN000;; Class identifer
    $M_COMMAND_VER   DW        EXPECTED_VERSION 	     ;;AN003;; COMMAND.COM version check
ifdef BILINGUAL
    $M_NUM_CLS_MSG   DW        0			     ;;AN000;; Total number of message in class
else
    $M_NUM_CLS_MSG   DB        0			     ;;AN000;; Total number of message in class
endif
							     ;;
$M_CLASS_ID ENDS					     ;;
							     ;;AN000;;
    $M_CLASS_ID_SZ   EQU       SIZE $M_CLASS_ID 	     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_ID_STRUC
;;
;; Each message will be defined by this structure.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_ID STRUC						     ;;AN000;;
							     ;;
    $M_NUM	     DW        -1			     ;;AN000;; Message Number
    $M_TXT_PTR	     DW        ?			     ;;AN000;; Pointer to message text
							     ;;
$M_ID ENDS						     ;;AN000;;
							     ;;AN000;; Status Flag Values:
    $M_ID_SZ	     EQU       SIZE $M_ID		     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_RES_ADDRS
;;
;; Resident data area definition of variables
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_RES_ADDRS STRUC					     ;;AN000;;
							     ;;
    $M_EXT_ERR_ADDRS DD        0			     ;;AN000;; Allow pointers to THREE Extended error locations
    $M_EXT_FILE      DD        0			     ;;AN001;;
    $M_EXT_COMMAND   DD        0			     ;;AN000;;
    $M_EXT_TERM      DD        -1			     ;;AN000;;
    $M_PARSE_COMMAND DD        0			     ;;AN000;;
    $M_PARSE_ADDRS   DD        0			     ;;AN000;; Allow pointers to TWO Parse error locations
    $M_PARSE_TERM    DD        -1			     ;;AN000;;
    $M_CRIT_ADDRS    DD        0			     ;;AN000;; Allow pointers to TWO Critical error locations
    $M_CRIT_COMMAND  DD        0			     ;;AN000;;
    $M_CRIT_TERM     DD        -1			     ;;AN000;;
    $M_DISK_PROC_ADDR DD       -1			     ;;AN004;; Address of READ_DISK_PROC
    $M_CLASS_ADDRS   DD        $M_NUM_CLS DUP(0)	     ;;AN000;; Allow pointers to specified classes
    $M_CLS_TERM      DD        -1			     ;;AN000;;
    $M_DBCS_VEC      DD        0			     ;;AN000;; Save DBCS vector
    $M_HANDLE	     DW        ?			     ;;AN000;;
    $M_SIZE	     DB        0			     ;;AN000;;
    $M_CRLF	     DB        0DH,0AH			     ;;AN004;; CR LF message
    $M_CLASS	     DB        ?			     ;;AN004;; Saved class
    $M_RETURN_ADDR   DW        ?			     ;;AN000;;
    $M_MSG_NUM	     DW        $M_NULL			     ;;AN000;;
    $M_DIVISOR	     DW        10			     ;;AN000;; Default = 10 (must be a WORD for division)
    $M_TEMP_BUF      DB        $M_TEMP_BUF_SZ DUP("$")	     ;;AN000;; Temporary buffer
    $M_BUF_TERM      DB        "$"			     ;;AN000;;

$M_RES_ADDRS ENDS					     ;;AN000;;
							     ;;
$M_RES_ADDRS_SZ EQU  SIZE $M_RES_ADDRS			     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_COUNTRY_INFO
;;
;; Important fields of the Get Country Information call
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_COUNTRY_INFO STRUC					     ;;AN000;; Expected Country infomation
							     ;;
    $M_HEADER	     DB       $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1 DUP(?) ;;AN000;; Go past first part of struc
    $M_DATE_FORMAT   DW       ? 			     ;;AN000;; <------- Date Format
    $M_CURR_SEPARA   DB       5 DUP(?)			     ;;AN000;;
    $M_THOU_SEPARA   DB       ?,0			     ;;AN000;; <------- Thou Separator
    $M_DECI_SEPARA   DB       ?,0			     ;;AN000;; <------- Decimal Separator
    $M_DATE_SEPARA   DB       ?,0			     ;;AN000;; <------- Date Separator
    $M_TIME_SEPARA   DB       ?,0			     ;;AN000;; <------- Time Separator
    $M_CURR_FORMAT   DB       ? 			     ;;AN000;;
    $M_SIG_DIGS_CU   DB       ? 			     ;;AN000;;
    $M_TIME_FORMAT   DB       ? 			     ;;AN000;; <------- Time Format
							     ;;
$M_COUNTRY_INFO ENDS					     ;;AN000;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
ELSE							     ;;AN000;;	ELSE if we have already included the STRUCTURES
; 
;   $SALUT  $M	(2,5,13,62)				     ;;AN000;;	Set SALUT formatting for code section

    IF	    MSGDATA					     ;;AN000;;	IF this is a request to include the data area
      MSGDATA =  FALSE					     ;;AN000;;	  Let the assembler know not to include it again
							     ;;AN000;;	  and include it
      PAGE
      SUBTTL  DOS - Message Retriever - MSGRES.TAB Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	DATA NAME: $M_RES_TABLE
;;
;;	REFERENCE LABEL: $M_RT
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF    COMR						     ;;AN000;; Since COMMAND.COM includes this twice
      $M_RT   EQU	       $M_RT2			     ;;AN000;;	we must redefine the label so no
      $M_RT2  LABEL  BYTE				     ;;AN000;;	 assembly errors occur
      $M_ALTLABEL = TRUE				     ;;AN000;; Flag that label was changed
ELSE							     ;;AN000;;
      $M_RT   LABEL   BYTE				     ;;AN000;;
ENDIF							     ;;AN000;;
      $M_RES_ADDRS <>					     ;;AN000;; Resident addresses
							     ;;
      include COPYRIGH.INC				     ;;AN001;; Include Copyright 1988 Microsoft
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ENDIF						     ;;AN000;; END of include of Data table

; 
    IF	    NOT  $M_MSGDATA_ONLY			     ;;AN000;; IF this was a request for only the data table THEN
							     ;; 	don't include any more code
							     ;;AN000;; Figure out what other code to  include
      IF      DISK_PROC 				     ;;AN003;;	 Is the request to include the READ_DISK code
	IF	COMR					     ;;AN003;;	 (Only Resident COMMAND.COM should ask for it)
	  $M_RT   EQU		   $M_RT2		     ;;AN003;;
	ENDIF
	DISK_PROC = FALSE				     ;;AN003;;	 Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - DISK_PROC Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: DISK_PROC
;;
;;	FUNCTION: Used in COMMAND.COM if we need to access the Parse or Extended
;;		  errors from disk\diskette
;;	INPUTS: AX has the message number
;;		DX has the message class
;;		AND ... the COMMAND.COM Variable RESGROUP:COMSPEC is
;;		assumed to be set!!
;;
;;	OUTPUTS: ES:DI points to message length (BYTE) followed by text
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
	PUBLIC	READ_DISK_PROC				     ;;
							     ;;
READ_DISK_PROC PROC FAR 				     ;;AN003;;

	PUSH	AX					     ;;AN003;; Save everything
	PUSH	BX					     ;;AN003;;
	PUSH	DX					     ;;AN003;;
	PUSH	SI					     ;;AN003;;
	PUSH	BP					     ;;AN003;;
	PUSH	DS					     ;;AN003;;
	PUSH	DI					     ;;AN003;;
	MOV	BP,AX					     ;;AN003;; Save message number
	MOV	AX,DOS_EXTENDED_OPEN			     ;;AN003;; Set INT 21 function
	LEA	SI,RESGROUP:COMSPEC			     ;;AN003;; Get addressibilty to COMMAND.COM
	PUSH	CS					     ;;AN003;;
	POP	DS					     ;;AN003;;
	MOV	DI,-1					     ;;AN003;; No extended attribute list
	MOV	BX,NO_CRIT_OPEN 			     ;;AN003;; Don't generate critical error
	MOV	DX,NOT_EX_FAIL_EX_OPEN			     ;;AN003;; Open Flag
	INT	21H					     ;;AN003;; Open the file
	POP	DI					     ;;AN003;; Retreive LSEEK pointer
							     ;;AN003;; Error ?
;	$IF	NC,LONG 				     ;;AN003;;	No,
	JNC $MXL1
	JMP $MIF1
$MXL1:
	  PUSH	  DI					     ;;AN003;; Save LSEEK pointer
	  MOV	  BX,AX 				     ;;AN003;;	 Set handle in BX
	  MOV	  AX,DOS_LSEEK_FILE			     ;;AN003;;	 LSEEK to the errors
	  XOR	  CX,CX 				     ;;AN003;;	   Value has been set by COMMAND.COM
	  MOV	  DX,DI 				     ;;AN003;;
	  INT	  21H					     ;;AN003;;	 LSEEK the file
	  POP	  DX					     ;;AN003;; Retreive LSEEK pointer
							     ;;AN003;;	 Error ?
;	  $IF	  NC					     ;;AN003;;	  No,
	  JC $MIF2
	    INC     CX					     ;;AN003;;	   Set flag to first pass
;	    $DO 					     ;;AN003;;
$MDO3:
	      PUSH    DX				     ;;AN003;;	   Save LSEEK pointer
	      PUSH    CX				     ;;AN003;;	   Save first pass flag
	      PUSH    AX				     ;;AN003;;	   Save number of messages (if set yet)
	      XOR     SI,SI				     ;;AN003;;	   Reset buffer index
	      MOV     AH,DOS_READ_BYTE			     ;;AN003;;	   Read
	      MOV     CX,$M_TEMP_BUF_SZ 		     ;;AN003;;	     the first part of the header
	      LEA     DX,$M_RT.$M_TEMP_BUF		     ;;AN003;;	       into the temp buffer
	      INT     21H				     ;;AN003;;	   Read it
	      MOV     DI,DX				     ;;AN003;;
	      POP     AX				     ;;AN003;;
	      POP     CX				     ;;AN003;;
	      OR      CX,CX				     ;;AN003;;
;	      $IF     NZ				     ;;AN003;;
	      JZ $MIF4
		XOR	CX,CX				     ;;AN003;;	   Set flag to second pass
ifdef BILINGUAL
		MOV	AX,DS:[DI].$M_NUM_CLS_MSG	     ;;AN003;;
else
		XOR	AH,AH				     ;;AN003;;	   Get number of messages in class
		MOV	AL,DS:[DI].$M_NUM_CLS_MSG	     ;;AN003;;
endif
		MOV	SI,$M_CLASS_ID_SZ		     ;;AN003;;	   Initialize index
		CMP	DS:[DI].$M_COMMAND_VER,EXPECTED_VERSION ;;AN003;;  Is this the right version of COMMAND.COM?
;	      $ENDIF					     ;;AN003;;
$MIF4:
	      POP     DX				     ;;AN003;;
;	      $IF     Z 				     ;;AN003;;	   Yes,
	      JNZ $MIF6
;		$SEARCH 				     ;;AN003;;
$MDO7:
		  CMP	  BP,WORD PTR $M_RT.$M_TEMP_BUF[SI]  ;;AN003;;	     Is this the message I'm looking for?
;		$EXITIF Z				     ;;AN003;;	     Yes, (ZF=1)
		JNZ $MIF7
		  CLC					     ;;AN003;;	      Reset carry, exit search
;		$ORELSE 				     ;;AN003;;	     No,  (ZF=0)
		JMP SHORT $MSR7
$MIF7:
		  ADD	  SI,$M_ID_SZ			     ;;AN003;;	      Increment index
		  ADD	  DX,$M_ID_SZ			     ;;AN003;;	      Add offset of first header
		  DEC	  AX				     ;;AN003;;	      Decrement # of messages left
;		$LEAVE	Z				     ;;AN003;;	      Have we exhausted all messages?
		JZ $MEN7
		  CMP	  SI,$M_TEMP_BUF_SZ-1		     ;;AN003;;	       No, Have we exhausted the buffer?
;		$ENDLOOP A				     ;;AN003;;		No, Check next message (ZF=1)
		JNA $MDO7
$MEN7:
		  STC					     ;;AN003;;	       Yes, (ZF=0) set error (ZF=0)
;		$ENDSRCH				     ;;AN003;;
$MSR7:
;	      $ELSE					     ;;AN003;;	   No,
	      JMP SHORT $MEN6
$MIF6:
		XOR	CX,CX				     ;;AN003;;	     Set Zero flag to exit READ Loop
		STC					     ;;AN003;;	     Set Carry
;	      $ENDIF					     ;;AN003;;
$MEN6:
;	    $ENDDO  Z					     ;;AN003;;	       Get next buffer full if needed
	    JNZ $MDO3
							     ;;AN003;; Error ?
;	    $IF     NC					     ;;AN003;;	No,
	    JC $MIF16
	      MOV     AX,DOS_LSEEK_FILE 		     ;;AN003;;	 Prepare to LSEEK to the specific message
	      XOR     CX,CX				     ;;AN003;;	 Value has been set by COMMAND.COM
	      ADD     DX,$M_CLASS_ID_SZ 		     ;;AN003;;	 Add offset of first header
	      ADD     DX,WORD PTR $M_RT.$M_TEMP_BUF[SI]+2    ;;AN003;;	 Add offset from msg structure
	      INT     21H				     ;;AN003;;	 LSEEK the file
	      MOV     AH,DOS_READ_BYTE			     ;;AN003;;	   Read
	      MOV     CX,$M_TEMP_BUF_SZ 		     ;;AN003;;	     the message
	      LEA     DX,$M_RT.$M_TEMP_BUF		     ;;AN003;;	       into the temp buffer
	      INT     21H				     ;;AN003;;	   Read it
	      MOV     DI,DX				     ;;AN003;;	       into the temp buffer
	      PUSH    DS				     ;;AN003;;	       into the temp buffer
	      POP     ES				     ;;AN003;;	       into the temp buffer
;	    $ENDIF					     ;;AN003;;
$MIF16:
;	  $ENDIF					     ;;AN003;;
$MIF2:
	  PUSHF 					     ;;AN003;;	   Close file handle
	  MOV	  AH,DOS_CLOSE_FILE			     ;;AN003;;	   Close file handle
	  INT	  21H					     ;;AN003;;
	  $M_POPF					     ;;AN003;;
;	$ENDIF						     ;;AN003;; Yes there was an error,
$MIF1:
	POP	DS					     ;;AN003;;
	POP	BP					     ;;AN003;;
	POP	SI					     ;;AN003;;
	POP	DX					     ;;AN003;;
	POP	BX					     ;;AN003;;
	POP	AX					     ;;AN003;;
							     ;;AN003;;	     abort everything
	RET						     ;;AN003;;

READ_DISK_PROC ENDP					     ;;AN003;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ENDIF						     ;;AN003;; END of include for DISK_PROC
;

SETSTDIO = FALSE					; M013
      IF      SETSTDIO					     ;;AN000;;	 Is the request to include the code for SETSTDIO
	SETSTDIO = FALSE				     ;;AN000;;	 Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - SETSTDIO Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: SETSTDIO
;;
;;	FUNCTION:
;;	INPUTS:
;;
;;	OUPUTS:
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	FARmsg						     ;AN001;
	SETSTDINON PROC FAR				     ;AN001;
ELSE							     ;AN001;
	SETSTDINON PROC NEAR				     ;AN001;
ENDIF							     ;AN001;
	PUSH	AX					     ;AN002; Save changed regs
	PUSH	BX					     ;AN002;
	PUSH	DX					     ;AN002;
	MOV	AX,DOS_IOCTL_GET_INFO			     ;AN001; Get info using IOCTL
	MOV	BX,STDIN				     ;AN001;
	XOR	DX,DX					     ;AN001;
	INT	21H					     ;AN001;

	OR	DH,$M_CRIT_ERR_MASK			     ;AN001; Turn on bit
	MOV	AX,DOS_IOCTL_SET_INFO			     ;AN001; Set info using IOCTL
	INT	21H					     ;AN001;
	POP	DX					     ;AN002; Restore Regs
	POP	BX					     ;AN002;
	POP	AX					     ;AN002;

	RET						     ;AN001;
							     ;AN001;
	SETSTDINON ENDP 				     ;AN001;

IF	FARmsg						     ;AN001;
	SETSTDINOFF PROC FAR				     ;AN001;
ELSE							     ;AN001;
	SETSTDINOFF PROC NEAR				     ;AN001;
ENDIF							     ;AN001;

	PUSH	AX					     ;AN002; Save changed regs
	PUSH	BX					     ;AN002;
	PUSH	DX					     ;AN002;
	MOV	AX,DOS_IOCTL_GET_INFO			     ;AN001; Get info using IOCTL
	MOV	BX,STDIN				     ;AN001;
	XOR	DX,DX					     ;AN001;
	INT	21H					     ;AN001;

	AND	DH,NOT $M_CRIT_ERR_MASK 		     ;AN001; Turn off bit
	MOV	AX,DOS_IOCTL_SET_INFO			     ;AN001; Set info using IOCTL
	INT	21H					     ;AN001;
	POP	DX					     ;AN002; Restore Regs
	POP	BX					     ;AN002;
	POP	AX					     ;AN002;

	RET						     ;AN001;

	SETSTDINOFF ENDP				     ;AN001;

IF	FARmsg						     ;AN001;
	SETSTDOUTON PROC FAR				     ;AN001;
ELSE							     ;AN001;
	SETSTDOUTON PROC NEAR				     ;AN001;
ENDIF							     ;AN001;

	PUSH	AX					     ;AN002; Save changed regs
	PUSH	BX					     ;AN002;
	PUSH	DX					     ;AN002;
	MOV	AX,DOS_IOCTL_GET_INFO			     ;AN001; Get info using IOCTL
	MOV	BX,STDOUT				     ;AN001;
	XOR	DX,DX					     ;AN001;
	INT	21H					     ;AN001;

	OR	DH,$M_CRIT_ERR_MASK			     ;AN001; Turn on bit
	MOV	AX,DOS_IOCTL_SET_INFO			     ;AN001; Set info using IOCTL
	INT	21H					     ;AN001;
	POP	DX					     ;AN002; Restore Regs
	POP	BX					     ;AN002;
	POP	AX					     ;AN002;

	RET						     ;AN001;

	SETSTDOUTON ENDP				     ;AN001;

IF	FARmsg						     ;AN001;
	SETSTDOUTOFF PROC FAR				     ;AN001;
ELSE							     ;AN001;
	SETSTDOUTOFF PROC NEAR
ENDIF							     ;AN001;

	PUSH	AX					     ;AN002; Save changed regs
	PUSH	BX					     ;AN002;
	PUSH	DX					     ;AN002;
	MOV	AX,DOS_IOCTL_GET_INFO			     ;AN001; Get info using IOCTL
	MOV	BX,STDOUT				     ;AN001;
	XOR	DX,DX					     ;AN001;
	INT	21H					     ;AN001;

	AND	DH,NOT $M_CRIT_ERR_MASK 		     ;AN001; Turn off bit
	MOV	AX,DOS_IOCTL_SET_INFO			     ;AN001; Set info using IOCTL
	INT	21H					     ;AN001;
	POP	DX					     ;AN002; Restore Regs
	POP	BX					     ;AN002;
	POP	AX					     ;AN002;

	RET						     ;AN001;

	SETSTDOUTOFF ENDP				     ;AN001;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ENDIF						     ;;AN000;; END of include for SETSTDIO
; 
      IF      LOADmsg					     ;;AN000;;	 Is the request to include the code for SYSLOADMSG ?
	IF	COMR					     ;;AN000;;
	  $M_RT   EQU		   $M_RT2		     ;;AN000;;
	ENDIF
	LOADmsg = FALSE 				     ;;AN000;;	 Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - LOADMSG.ASM Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: SYSLOADMSG
;;
;;	FUNCTION:
;;	INPUTS:
;;
;;	OUPUTS:
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	FARmsg						     ;;AN000;;
	SYSLOADMSG PROC FAR				     ;;AN000;;
ELSE							     ;;AN000;;
	SYSLOADMSG PROC NEAR				     ;;AN000;;
ENDIF							     ;;AN000;;
	PUSH	AX					     ;;AN000;
	PUSH	BX					     ;;AN000;
	PUSH	DX					     ;;AN000;
	PUSH	ES					     ;;AN000;
	PUSH	DI					     ;;AN000;
	XOR	CX,CX					     ;;AN000;  Reset to zero
	MOV	ES,CX					     ;;AN000;
	XOR	DI,DI					     ;;AN000;
	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN000;; 2FH Interface
	MOV	DL,DOS_GET_EXTENDED			     ;;AN000;; Where are the Extended errors in COMMAND.COM
	INT	2FH					     ;;AN000;; Private interface
	MOV	WORD PTR $M_RT.$M_EXT_COMMAND+2,ES	     ;;AN000;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_EXT_COMMAND,DI	     ;;AN000;;
							     ;;
	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN000;; 2FH Interface
	MOV	DL,DOS_GET_PARSE			     ;;AN000;; Where are the Parse errors in COMMAND.COM
	INT	2FH					     ;;AN000;; Private interface
	MOV	WORD PTR $M_RT.$M_PARSE_COMMAND+2,ES	     ;;AN000;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_PARSE_COMMAND,DI	     ;;AN000;;
							     ;;
	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN000;; 2FH Interface
	MOV	DL,DOS_GET_CRITICAL			     ;;AN000;; Where are the Critical errors in COMMAND.COM
	INT	2FH					     ;;AN000;; Private interface
	MOV	WORD PTR $M_RT.$M_CRIT_COMMAND+2,ES	     ;;AN000;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_CRIT_COMMAND,DI	     ;;AN000;;

	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN001;; 2FH Interface
	MOV	DL,DOS_GET_FILE 			     ;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
	INT	2FH					     ;;AN001;; Private interface
	MOV	WORD PTR $M_RT.$M_EXT_FILE+2,ES 	     ;;AN001;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_EXT_FILE,DI		     ;;AN001;;

IF	COMR						     ;;  ** Special case for RESIDENT COMMAND.COM
	IF2
	  IFNDEF  READ_DISK_INFO			     ;;AN003;;
	    Extrn   READ_DISK_PROC:Far			     ;;AN003;;
	  ENDIF 					     ;;AN003;;
	ENDIF						     ;;AN003;;
ELSE							     ;;
	IF	FARmsg					     ;;AN000;;
	  CALL	  FAR PTR $M_MSGSERV_1			     ;;AN000;; Get addressibilty to MSGSERV CLASS 1 (EXTENDED Errors)
	ELSE						     ;;AN000;;
	  CALL	  $M_MSGSERV_1				     ;;AN000;; Get addressibilty to MSGSERV CLASS 1 (EXTENDED Errors)
	ENDIF						     ;;AN000;;
	MOV	WORD PTR $M_RT.$M_EXT_ERR_ADDRS+2,ES	     ;;AN000;; Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_EXT_ERR_ADDRS,DI	     ;;AN000;;
	MOV	WORD PTR $M_RT.$M_CRIT_ADDRS+2,ES	     ;;AN000;; Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_CRIT_ADDRS,DI 	     ;;AN000;;
							     ;;
	IF	FARmsg					     ;;AN000;;
	  CALL	  FAR PTR $M_MSGSERV_2			     ;;AN000;; Get addressibilty to MSGSERV CLASS 2 (PARSE Errors)
	ELSE						     ;;AN000;;
	  CALL	  $M_MSGSERV_2				     ;;AN000;; Get addressibilty to MSGSERV CLASS 2 (PARSE Errors)
	ENDIF						     ;;AN000;;
	MOV	WORD PTR $M_RT.$M_PARSE_ADDRS+2,ES	     ;;AN000;; Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_PARSE_ADDRS,DI	     ;;AN000;;
ENDIF							     ;;
							     ;;
	MOV	AX,DOS_GET_EXT_PARSE_ADD		     ;;AN001;; 2FH Interface
	MOV	DL,DOS_GET_ADDR 			     ;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
	INT	2FH					     ;;AN001;; Private interface
	MOV	WORD PTR $M_RT.$M_DISK_PROC_ADDR+2,ES	     ;;AN001;;	Move into first avaliable table location
	MOV	WORD PTR $M_RT.$M_DISK_PROC_ADDR,DI	     ;;AN001;;

;M016; M020
; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
;be safe.  Initialize $M_MSG_NUM and $M_DIVISOR also.
;
	mov	word ptr $M_RT.$M_CRLF,0a0dh		; Reinit CR-LF ;M016
	mov	byte ptr $M_RT.$M_BUF_TERM,'$'		; Reinit buffer end;M016
	mov	word ptr $M_RT.$M_MSG_NUM,$M_NULL	; M020
	mov	word ptr $M_RT.$M_DIVISOR,$M_BASE10	; M020

	$M_BUILD_PTRS %$M_NUM_CLS			     ;;AN000;; Build all utility classes
							     ;;AN000;;
	CALL	$M_GET_DBCS_VEC 			     ;;AN000;; Save the DBCS vector

IF	NOT	NOCHECKSTDIN				     ;;AN000;; IF EOF check is not to be suppressed
	CALL	$M_CHECKSTDIN				     ;;AN000;;	 Set EOF CHECK
ENDIF							     ;;AN000;;
							     ;;AN000;;
IF	NOT	NOCHECKSTDOUT				     ;;AN000;; IF Disk Full check is not to be suppressed
	CALL	$M_CHECKSTDOUT				     ;;AN000;;	 Set Disk Full CHECK
ENDIF							     ;;AN000;;
							     ;;AN000;;
IF	NOVERCHECKmsg					     ;;AN000;; IF version check is to be supressed
	CLC						     ;;AN000;;	 Make sure carry is clear
ELSE							     ;;AN000;; ELSE
	PUSH	CX					     ;;AN000;;
	CALL	$M_VERSION_CHECK			     ;;AN000;;	 Check Version
ENDIF							     ;;AN000;;
							     ;;        Error ?
;	$IF	NC					     ;;AN000;; No.
	JC $MIF20
IF	  NOT	  NOVERCHECKmsg 			     ;;AN000;;	IF version check was not supressed
	  POP	  CX					     ;;AN000;;	Reset stack
ENDIF							     ;;AN000;;
	  POP	  DI					     ;;AN000;;	Restore REGS
	  POP	  ES					     ;;AN000;;
	  POP	  DX					     ;;AN000;;
	  POP	  BX					     ;;AN000;;
	  POP	  AX					     ;;AN000;;
;	$ELSE						     ;;AN000;; Yes,
	JMP SHORT $MEN20
$MIF20:
IF	  NOVERCHECKmsg 				     ;;AN000;;	IF version check is to be supressed
	  ADD	  SP,10 				     ;;AN000;;
	  STC						     ;;AN000;;	Reset carry flag
ELSE							     ;;AN000;;	IF version check is to be supressed
	  ADD	  SP,12 				     ;;AN000;;
	  STC						     ;;AN000;;	Reset carry flag
ENDIF							     ;;AN000;;	IF version check is to be supressed
;	$ENDIF						     ;;AN000;;
$MEN20:
	RET						     ;;AN000;;
							     ;;
	SYSLOADMSG ENDP 				     ;;AN000;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	PAGE
	SUBTTL	DOS - Message Retriever - $M_VERSION_CHECK Proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_GET_DBCS_VEC
;;
;;  Function:	Get the DBCS vector and save it for later use
;;
;;  Inputs:	None
;;
;;  Outputs:	None
;;
;;  Regs Changed:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_GET_DBCS_VEC PROC NEAR				     ;;AN000;;
							     ;;
	PUSH	AX					     ;;AN000;; Save character to check
	PUSH	SI					     ;;AN000;;
	PUSH	DS					     ;;AN000;;
	MOV	AX,DOS_GET_DBCS_INFO			     ;;AN000;; DOS function to get DBSC environment
	INT	21H					     ;;AN000;; Get environment pointer
	PUSH	DS					     ;;AN000;; Get environment pointer
	POP	ES					     ;;AN000;; Get environment pointer
	POP	DS					     ;;AN000;; Get environment pointer
;	$IF	NC					     ;;AN000;;
	JC $MIF23
	  MOV	  WORD PTR $M_RT.$M_DBCS_VEC,SI 	     ;;AN000;; Save DBCS Vector
	  MOV	  WORD PTR $M_RT.$M_DBCS_VEC+2,ES	     ;;AN000;;
;	$ENDIF						     ;;AN000;;
$MIF23:
	POP	SI					     ;;AN000;;
	POP	AX					     ;;AN000;; Retrieve character to check
	RET						     ;;AN000;; Return
							     ;;
$M_GET_DBCS_VEC ENDP					     ;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	IF	NOCHECKSTDIN				     ;AN001; Are we suppose to include the code for Checking EOF ?
	ELSE						     ;AN001; Yes, THEN include it
	  PAGE
	  SUBTTL  DOS - Message Retriever - $M_CHECKSTDIN Proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_CHECKSTDIN
;;
;;  Function:
;;
;;  Inputs:	None
;;
;;  Outputs:
;;
;;  Regs Changed:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CHECKSTDIN PROC NEAR 				     ;AN001;

	  MOV	  AX,DOS_IOCTL_GET_INFO 		     ;AN001; Get info using IOCTL
	  MOV	  BX,STDIN				     ;AN001;
	  XOR	  DX,DX 				     ;AN001;
	  INT	  21H					     ;AN001;

	  AND	  DH,1                                       ;clear top 7 bits
	  OR	  DH,$M_CRIT_ERR_MASK			     ;AN001; Turn on bit
	  MOV	  AX,DOS_IOCTL_SET_INFO 		     ;AN001; Set info using IOCTL
	  INT	  21H					     ;AN001;

	  RET						     ;AN001;

$M_CHECKSTDIN ENDP					     ;AN001;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;AN001; END of include for EOF Check
	IF	NOCHECKSTDOUT				     ;AN001; Are we suppose to include the code for Checking Disk Full?
	ELSE						     ;AN001; Yes, THEN include it
	  PAGE
	  SUBTTL  DOS - Message Retriever - $M_CHECKSTDOUT Proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_CHECKSTDOUT
;;
;;  Function:
;;
;;  Inputs:	None
;;
;;  Outputs:
;;
;;  Regs Changed:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CHECKSTDOUT PROC NEAR				     ;AN001;

	  MOV	  AX,DOS_IOCTL_GET_INFO 		     ;AN001; Get info using IOCTL
	  MOV	  BX,STDOUT				     ;AN001;
	  XOR	  DX,DX 				     ;AN001;
	  INT	  21H					     ;AN001;

	  OR	  DH,$M_CRIT_ERR_MASK			     ;AN001; Turn on bit
	  MOV	  AX,DOS_IOCTL_SET_INFO 		     ;AN001; Set info using IOCTL
	  INT	  21H					     ;AN001;

	  RET						     ;AN001;

$M_CHECKSTDOUT ENDP					     ;AN001;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;AN001;  END of include for Disk Full Check
	IF	NOVERCHECKmsg				     ;;AN000;; Are we suppose to include the code for DOS version check?
	ELSE						     ;;AN000;; Yes, THEN include it
	  PAGE
	  SUBTTL  DOS - Message Retriever - $M_VERSION_CHECK Proc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_VERSION_CHECK
;;
;;  Function:	Determine if DOS version is within allowable limits
;;
;;  Inputs:	None
;;
;;  Outputs:	CARRY_FLAG = 1 if Incorrect DOS version
;;		Registers set for SYSDISPMSG
;;		CARRY_FLAG = 0 if Correct DOS version
;;
;;  Regs Changed: AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_VERSION_CHECK PROC NEAR				     ;;AN000;;
							     ;;
	  MOV	  AH,DOS_GET_VERSION			     ;;AN000;; Check that version matches VERSIONA.INC
	  INT	  21H					     ;;AN000;;
							     ;;
	  CMP	  AX,EXPECTED_VERSION			     ;;AN000;; IF DOS_MAJOR is correct
;	  $IF	  E					     ;;AN000;;
	  JNE $MIF25
	    CLC 					     ;;AN000;;	 Clear the carry flag
;	  $ELSE 					     ;;AN000;; ELSE
	  JMP SHORT $MEN25
$MIF25:
IF	    NOT     COMR				     ;;  ** Special case for RESIDENT COMMAND.COM
	    CMP     AX,LOWEST_4CH_VERSION		     ;;AN000;; Does this version support AH = 4CH
;	    $IF     B					     ;;AN000;; No,
	    JNB $MIF27
	      MOV     BX,NO_HANDLE			     ;;AN000;;	 No handle (version doesn't support)
;	    $ELSE					     ;;AN000;; Yes,
	    JMP SHORT $MEN27
$MIF27:
	      MOV     BX,STDERR 			     ;;AN000;;	 Standard Error
;	    $ENDIF					     ;;AN000;;
$MEN27:
ELSE
	    MOV     BX,NO_HANDLE			     ;;AN000;;	 No handle
ENDIF
	    MOV     AX,1				     ;;AN000;; Set message # 1
	    MOV     CX,NO_REPLACE			     ;;AN000;; No replacable parms
	    MOV     DL,NO_INPUT 			     ;;AN000;; No input
	    MOV     DH,UTILITY_MSG_CLASS		     ;;AN000;; Utility class message
	    STC 					     ;;AN000;; Set Carry Flag
;	  $ENDIF					     ;;AN000;;
$MEN25:
							     ;;
	  RET						     ;;AN000;; Return
							     ;;
$M_VERSION_CHECK ENDP					     ;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;;AN000;; END of include for DOS version check
      ENDIF						     ;;AN000;; END of include for SYSLOADMSG
; 
      IF      GETmsg					     ;;AN000;; Is the request to include the code for SYSGETMSG ?
	IF	COMR					     ;;AN000;;
	  $M_RT   EQU		   $M_RT2		     ;;AN000;;
	ENDIF						     ;;AN000;;
	GETmsg	=      FALSE				     ;;AN000;; Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - GETMSG.ASM Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	SYSGETMSG
;;
;;  Function:	The GET service returns the segment, offset and size of the
;;		message text to the caller based on a message number.
;;		The GET function will not display the message thus assumes
;;		caller will handle replaceable parameters.
;;
;;  Inputs:
;;
;;  Outputs:
;;
;;  Psuedocode:
;;		Call $M_GET_MSG_ADDRESS
;;		IF MSG_NUM exists THEN
;;		   Set DS:SI = MSG_TXT_PTR + 1
;;		   CARRY_FLAG = 0
;;		ELSE
;;		   CARRY_FLAG = 1
;;		ENDIF
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	FARmsg						     ;;AN000;;
	SYSGETMSG PROC	FAR				     ;;AN000;;
ELSE							     ;;AN000;;
	SYSGETMSG PROC	NEAR				     ;;AN000;;
ENDIF							     ;;AN000;;
							     ;;
;; Save registers needed later

	PUSH	AX					     ;;AN000;; Save changed regs
	PUSH	ES					     ;;AN000;;
	PUSH	DI					     ;;AN000;;
	PUSH	BP					     ;;AN000;;
							     ;;
IF	FARmsg						     ;;AN000;;
	CALL	FAR PTR $M_GET_MSG_ADDRESS		     ;;AN000;; Scan thru classes to find message
ELSE							     ;;AN000;;
	CALL	$M_GET_MSG_ADDRESS			     ;;AN000;; Scan thru classes to find message
ENDIF							     ;;AN000;; Return message in ES:DI
;	$IF	NC					     ;;AN000;; Message found?
	JC $MIF31
	  CMP	  DH,UTILITY_MSG_CLASS
	  CLC						     ;;AN000;;
;	  $IF	  NE
	  JE $MIF32
	    PUSH    ES					     ;;AN000;;
	    POP     DS					     ;;AN000;;	   Return message in DS:SI
;	  $ELSE
	  JMP SHORT $MEN32
$MIF32:
IF	    FARmsg					     ;;AN000;;	 Yes,
	    PUSH    ES					     ;;AN000;;
	    POP     DS					     ;;AN000;;	   Return message in DS:SI
ELSE							     ;;AN000;;
	    PUSH    CS					     ;;AN000;;	   Return message in DS:SI
	    POP     DS					     ;;AN000;;
ENDIF							     ;;AN000;;
;	  $ENDIF					     ;;AN000;;
$MEN32:
	  MOV	  SI,DI 				     ;;AN000;;	   Return message in DS:SI
;	$ENDIF						     ;;AN000;;
$MIF31:
							     ;;
	POP	BP					     ;;AN000;; Restore changed regs
	POP	DI					     ;;AN000;;
	POP	ES					     ;;AN000;;
	POP	AX					     ;;AN000;;
							     ;;
	RET						     ;;AN000;;	  Return
							     ;;
	SYSGETMSG ENDP					     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	IF	$M_SUBS 				     ;;AN000;; Include the common subroutines if they haven't yet
	  $M_SUBS = FALSE				     ;;AN000;; No, then include and reset the flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_GET_MSG_ADDRESS
;;
;;	FUNCTION:  To scan thru classes to return pointer to the message header
;;	INPUTS:    Access to $M_RES_ADDRESSES
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN ES:DI points to the specified message
;;	REGS CHANGED: ES,DI,CX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	  FARmsg					     ;;AN000;;
	  $M_GET_MSG_ADDRESS PROC FAR			     ;;AN000;;
ELSE							     ;;AN000;;
	  $M_GET_MSG_ADDRESS PROC NEAR			     ;;AN000;;
ENDIF							     ;;AN000;;
							     ;;
	  PUSH	  SI					     ;;AN000;;
	  PUSH	  BX					     ;;AN000;;
	  XOR	  SI,SI 				     ;;AN000;; Use SI as an index
	  XOR	  CX,CX 				     ;;AN000;; Use CX as an size
;	  $DO						     ;;AN000;;
$MDO36:
	    CMP     DH,UTILITY_MSG_CLASS		     ;;AN000;; Were utility messages requested?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF37
	      IF      FARmsg				     ;;AN000;;
		LES	DI,DWORD PTR $M_RT.$M_CLASS_ADDRS[SI] ;;AN000;;  Get address of class
		MOV	BX,ES				     ;;AN000;
	      ELSE					     ;;AN000;;
		MOV	DI,WORD PTR $M_RT.$M_CLASS_ADDRS[SI] ;;AN000;;	 Get address of class
		MOV	BX,DI				     ;;AN000;
	      ENDIF					     ;;AN000;;
;	    $ELSE					     ;;AN000;; No,
	    JMP SHORT $MEN37
$MIF37:
	      TEST    DH,PARSE_ERR_CLASS		     ;;AN000;;	 Were parse errors requested?
;	      $IF     NE				     ;;AN000;;	 Yes,
	      JE $MIF39
		LES	DI,DWORD PTR $M_RT.$M_PARSE_COMMAND[SI] ;;AN000;;   Get address of class
		MOV	BX,ES				     ;;AN000;
;	      $ELSE					     ;;AN000;;	 No, extended errors were specified
	      JMP SHORT $MEN39
$MIF39:
		CMP	AX,$M_CRIT_LO			     ;;AN000;;	   Is this a critical error?
;		$IF	AE,AND				     ;;AN000;;
		JNAE $MIF41
		CMP	AX,$M_CRIT_HI			     ;;AN000;;
;		$IF	BE				     ;;AN000;;	    Yes,
		JNBE $MIF41
		  LES	  DI,DWORD PTR $M_RT.$M_CRIT_ADDRS[SI] ;;AN000;; Get address of class
		  MOV	  BX,ES 			     ;;AN000;
;		$ELSE					     ;;AN000;;
		JMP SHORT $MEN41
$MIF41:
		  LES	  DI,DWORD PTR $M_RT.$M_EXT_ERR_ADDRS[SI] ;;AN000;; Get address of class
		  MOV	  BX,ES 			     ;;AN000;
;		$ENDIF					     ;;AN000;;
$MEN41:
;	      $ENDIF					     ;;AN000;;
$MEN39:
;	    $ENDIF					     ;;AN000;;
$MEN37:
							     ;;
	    CMP     BX,$M_TERMINATING_FLAG		     ;;AN000;; Are we finished all classes?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF46
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN000;;	  Was it a UTILITY class?
;	      $IF     E 				     ;;AN000;;	  Yes,
	      JNE $MIF47
		STC					     ;;AN000;;	    Set the carry flag
;	      $ELSE					     ;;AN000;;	  No,
	      JMP SHORT $MEN47
$MIF47:
		MOV	$M_RT.$M_MSG_NUM,AX		     ;;AN000;;	    Save message number
		MOV	AX,$M_SPECIAL_MSG_NUM		     ;;AN000;;	    Set special message number
		MOV	BP,$M_ONE_REPLACE		     ;;AN000;;	    Set one replace in message
		XOR	SI,SI				     ;;AN000;;	    Reset the SI index to start again
		CLC					     ;;AN000;;
;	      $ENDIF					     ;;AN000;; No,
$MEN47:
;	    $ELSE					     ;;AN000;;
	    JMP SHORT $MEN46
$MIF46:
	      CMP     BX,$M_CLASS_NOT_EXIST		     ;;AN000;;	 Does this class exist?
;	      $IF     NE				     ;;AN001;;	 Yes,
	      JE $MIF51
		CALL	$M_FIND_SPECIFIED_MSG		     ;;AN000;;	   Try to find the message
;	      $ENDIF					     ;;AN000;;
$MIF51:
	      ADD     SI,$M_ADDR_SZ_FAR 		     ;;AN000;;	     Get next class
	      CLC					     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MEN46:
;	  $LEAVE  C					     ;;AN000;;
	  JC $MEN36
	    OR	    CX,CX				     ;;AN000;;	   Was the message found?
;	  $ENDDO  NZ,LONG				     ;;AN000;;
	  JNZ $MXL2
	  JMP $MDO36
$MXL2:
$MEN36:

	  PUSHF 					     ;;AN006;; Save the flag state
	  CMP	  DH,EXT_ERR_CLASS			     ;;AN006;; Was an extended error requested?
;	  $IF	  E					     ;;AN006;; Yes,
	  JNE $MIF56
	    PUSH    DX					     ;;AN006;;	Save all needed registers
	    PUSH    BP					     ;;AN006;;
	    PUSH    CX					     ;;AN006;;
	    PUSH    ES					     ;;AN006;;
	    PUSH    DI					     ;;AN006;;
	    PUSH    AX					     ;;AN006;;

	    MOV     AX,IFSFUNC_INSTALL_CHECK		     ;;AN006;;	Check if IFSFUNC is installed
	    INT     2FH 				     ;;AN006;;
	    CMP     AL,IFSFUNC_INSTALLED		     ;;AN006;;	Is it installed?
	    POP     AX					     ;;AN006;;	Restore msg number
;	    $IF     E					     ;;AN006;;	 Yes,
	    JNE $MIF57
	      MOV     BX,AX				     ;;AN006;;	  BX is the extended error number
	      MOV     AX,IFS_GET_ERR_TEXT		     ;;AN006;;	  AX is the muliplex number
	      INT     2FH				     ;;AN006;;	  Call IFSFUNC
;	    $ELSE					     ;;AN006;;	 No,
	    JMP SHORT $MEN57
$MIF57:
	      STC					     ;;AN006;;	  Carry conditon
;	    $ENDIF					     ;;AN006;;
$MEN57:

;	    $IF     C					     ;;AN006;;	Was there an update?
	    JNC $MIF60
	      POP     DI				     ;;AN006;;	No,
	      POP     ES				     ;;AN006;;	 Restore old pointer
	      POP     CX				     ;;AN006;;
;	    $ELSE					     ;;AN006;;	Yes
	    JMP SHORT $MEN60
$MIF60:
	      ADD     SP,6				     ;;AN006;;	 Throw away old pointer
	      CALL    $M_SET_LEN_IN_CX			     ;;AN006;;	 Get the length of the ASCIIZ string
;	    $ENDIF					     ;;AN006;;
$MEN60:
	    POP     BP					     ;;AN006;;	Restore other Regs
	    POP     DX					     ;;AN006;;
;	  $ENDIF					     ;;AN006;;
$MIF56:
	  $M_POPF					     ;;AN006;; Restore the flag state

	  POP	  BX					     ;;AN000;;
	  POP	  SI					     ;;AN000;;
	  RET						     ;;AN000;; Return ES:DI pointing to the message
							     ;;
$M_GET_MSG_ADDRESS ENDP 				     ;;
							     ;;
$M_SET_LEN_IN_CX PROC NEAR				     ;;
							     ;;
	  PUSH	  DI					     ;;AN006;; Save position
	  PUSH	  AX					     ;;AN006;;
	  MOV	  CX,-1 				     ;;AN006;; Set CX for decrements
	  XOR	  AL,AL 				     ;;AN006;; Prepare compare register
	  REPNE   SCASB 				     ;;AN006;; Scan for zero
	  NOT	  CX					     ;;AN006;; Change decrement into number
	  DEC	  CX					     ;;AN006;; Don't include the zero
	  POP	  AX					     ;;AN006;;
	  POP	  DI					     ;;AN006;; Restore position
	  RET						     ;;AN006;;
							     ;;
$M_SET_LEN_IN_CX ENDP					     ;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_FIND_SPECIFIED_MSG
;;
;;	FUNCTION:  To scan thru message headers until message is found
;;	INPUTS:    ES:DI points to beginning of msg headers
;;		   CX contains the number of messages in class
;;		   DH contains the message class
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN ES:DI points to header of specified message
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_FIND_SPECIFIED_MSG PROC NEAR 			     ;;AN000;;
							     ;;
ifdef BILINGUAL
	push	ax			; save ax
	push	ax
	push	bx
	mov	ax,4f01h		; get code page
	xor	bx,bx
	int	2fh
ifdef JAPAN
	cmp	bx,932
endif
ifdef KOREA
	cmp	bx,949
endif
ifdef TAIWAN
	cmp	bx,950
endif
ifdef PRC
	cmp	bx,936
endif
	pop	bx
	pop	ax
	jz	MFSM_03			; if DBCS code page
	cmp	ax,$M_SPECIAL_MSG_NUM
	jz	MFSM_03
	cmp	dh,EXT_ERR_CLASS
	jz	MFSM_01
	cmp	dh,PARSE_ERR_CLASS
	jz	MFSM_02
	add	ax,UTILITY_MSG_ADJ
	jmp	short MFSM_03
MFSM_01:
	add	ax,EXT_MSG_ADJ
	jmp	short MFSM_03
MFSM_02:
	add	ax,PARSE_MSG_ADJ
MFSM_03:
endif

	  CMP	  BX,1					     ;;AN004;;	Do we have an address to CALL?
;	  $IF	  E,AND 				     ;;AN004;;	Yes,
	  JNE $MIF64
	  CMP	  WORD PTR $M_RT.$M_DISK_PROC_ADDR,-1	     ;;AN004;;	Do we have an address to CALL?
;	  $IF	  NE					     ;;AN004;;	Yes,
	  JE $MIF64
	    CMP     AX,$M_SPECIAL_MSG_NUM		     ;;AN004;; Are we displaying a default Ext Err?
;	    $IF     E					     ;;AN004;;	. . . and . . .
	    JNE $MIF65
	      PUSH    AX				     ;;AN004;;	 Reset the special message number
	      MOV     AX,$M_RT.$M_MSG_NUM		     ;;AN004;;	 Get the old message number
	      CALL    DWORD PTR $M_RT.$M_DISK_PROC_ADDR      ;;AN004;;	 Call the READ_DISK_PROC to get error text
	      POP     AX				     ;;AN004;;	 Reset the special message number
;	    $ELSE					     ;;AN004;;	 Get the old message number
	    JMP SHORT $MEN65
$MIF65:
	      CALL    DWORD PTR $M_RT.$M_DISK_PROC_ADDR      ;;AN004;;	 Call the READ_DISK_PROC to get error text
;	    $ENDIF					     ;;AN004;;	 Get the old message number
$MEN65:
;	  $ELSE 					     ;;AN004;;
	  JMP SHORT $MEN64
$MIF64:
	    XOR     CX,CX				     ;;AN002;;	 CX = 0 will allow us to
	    CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;
;	    $IF     NE					     ;;AN001;;
	    JE $MIF69
ifdef BILINGUAL
	      MOV     CX,WORD PTR ES:[DI].$M_NUM_CLS_MSG     ;;AN001;;	 Get number of messages in class
else
	      MOV     CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG     ;;AN001;;	 Get number of messages in class
endif
;	    $ELSE					     ;;AN001;;
	    JMP SHORT $MEN69
$MIF69:
IF	      FARmsg					     ;;AN001;;
	      CMP     BYTE PTR ES:[DI].$M_CLASS_ID,DH	     ;;AN002;; Check if class still exists at
ELSE
	      CMP     BYTE PTR CS:[DI].$M_CLASS_ID,DH	     ;;AN002;; Check if class still exists at
ENDIF
;	      $IF     E 				     ;;AN002;;	pointer (hopefully)
	      JNE $MIF71
IF		FARmsg					     ;;AN001;;
ifdef BILINGUAL
		MOV	CX,WORD PTR ES:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
else
		MOV	CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
endif
ELSE
ifdef BILINGUAL
		MOV	CX,WORD PTR CS:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
else
		MOV	CL,BYTE PTR CS:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
endif
ENDIF
;	      $ENDIF					     ;;AN002;;	  go on to the next class
$MIF71:
;	    $ENDIF					     ;;AN001;;
$MEN69:
	    ADD     DI,$M_CLASS_ID_SZ			     ;;AN000;;	   Point past the class header
	    STC 					     ;;AN004;;	 Flag that we haven't found anything yet
;	  $ENDIF					     ;;AN004;;
$MEN64:

;	  $IF	  C					     ;;AN004;; Have we found anything yet?
	  JNC $MIF75
	    CLC 					     ;;AN004;; No, reset carry
;	    $SEARCH					     ;;AN000;;
$MDO76:
	      OR      CX,CX				     ;;AN000;;	  Do we have any to check?
;	    $LEAVE  Z					     ;;AN000;;	     No, return with CX = 0
	    JZ $MEN76
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;
;	      $IF     NE				     ;;AN001;;
	      JE $MIF78
		CMP	AX,WORD PTR ES:[DI].$M_NUM	     ;;AN001;; Is this the message requested?
;	      $ELSE					     ;;AN001;;
	      JMP SHORT $MEN78
$MIF78:
IF		FARmsg					     ;;AN001;;
		CMP	AX,WORD PTR ES:[DI].$M_NUM	     ;;AN000;; Is this the message requested?
ELSE
		CMP	AX,WORD PTR CS:[DI].$M_NUM	     ;;AN000;; Is this the message requested?
ENDIF
;	      $ENDIF
$MEN78:
;	    $EXITIF E					     ;;AN000;;
	    JNE $MIF76
;	    $ORELSE					     ;;AN000;
	    JMP SHORT $MSR76
$MIF76:
	      DEC     CX				     ;;AN000;;	  No, well do we have more to check?
;	    $LEAVE  Z					     ;;AN000;;	     No, return with CX = 0
	    JZ $MEN76
	      ADD     DI,$M_ID_SZ			     ;;AN000;;	     Yes, skip past msg header
;	    $ENDLOOP					     ;;AN000;;
	    JMP SHORT $MDO76
$MEN76:
	      STC					     ;;AN000;;
;	    $ENDSRCH					     ;;AN000;;	     Check next message
$MSR76:
;	    $IF     NC					     ;;AN000;;	 Did we find the message?
	    JC $MIF86
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;	 Yes, is it a utility message?
	      CLC					     ;;AN001;;
;	      $IF     E 				     ;;AN001;;
	      JNE $MIF87
IF		FARmsg					     ;;AN001;;
ELSE							     ;;AN000;;
		PUSH	CS				     ;;AN000;;
		POP	ES				     ;;AN000;;	 Return ES:DI pointing to the message
ENDIF
;	      $ENDIF					     ;;AN001;;
$MIF87:
	      ADD     DI,WORD PTR ES:[DI].$M_TXT_PTR	     ;;AN000;; Prepare ES:DI pointing to the message
;	    $ENDIF					     ;;AN004;;
$MIF86:
;	  $ENDIF					     ;;AN004;;
$MIF75:
							     ;; 	  Yes, great we can return with CX > 0

;	  $IF	  NC					     ;;AN000;;	 Did we find the message?
	  JC $MIF91
	    XOR     CH,CH				     ;;AN000;;
	    MOV     CL,BYTE PTR ES:[DI] 		     ;;AN000;;	 Move size into CX
	    INC     DI					     ;;AN000;;	 Increment past length
;	  $ENDIF					     ;;AN004;;
$MIF91:

	  MOV	  $M_RT.$M_SIZE,$M_NULL 		     ;;AN004;; Reset variable
ifdef BILINGUAL
	pop	ax
endif
	  RET						     ;;AN000;; Return
							     ;;
$M_FIND_SPECIFIED_MSG ENDP				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;;AN000;; END of include of common subroutines
      ENDIF						     ;;AN000;; END of include of SYSGETMSG
; 
      IF      DISPLAYmsg				     ;;AN000;; Is the request to include the code for SYSGETMSG ?
	IF	COMR					     ;;AN000;;
	  $M_RT   EQU		   $M_RT2		     ;;AN000;;
	ENDIF						     ;;AN000;;
	DISPLAYmsg =  FALSE				     ;;AN000;; Yes, THEN include it and reset flag
	PAGE
	SUBTTL	DOS - Message Retriever - DISPMSG.ASM Module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	SYSDISPMSG
;;
;;  Function:	The DISPLAY service will output a defined message to a handle
;;		requested by the caller. It also provides function to display
;;		messages when handles are not applicable (ie. DOS function calls
;;		00h to 0Ah) Replaceable parameters are allowed and are
;;		defined previous to entry.
;;
;;		It is assumes that a PRELOAD function has already determined
;;		the addressibilty internally to the message retriever services.
;;  Inputs:
;;
;;  Outputs:
;;
;;  Psuedocode:
;;		Save registers needed later
;;		Get address of the message requested
;;		IF Message number exists THEN
;;		  IF replacable parameters were specified THEN
;;		     Display message with replacable parms
;;		  ELSE
;;		     Display string without replacable parms
;;		  ENDIF
;;		  IF character input was requested THEN
;;		     Wait for character input
;;		  ENDIF
;;		  Clear CARRY FLAG
;;		ELSE
;;		   Set CARRY FLAG
;;		ENDIF
;;		Return
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	FARmsg						     ;;AN000;;
	SYSDISPMSG PROC FAR				     ;;AN000;;
ELSE							     ;;AN000;;
	SYSDISPMSG PROC NEAR				     ;;AN000;;
ENDIF							     ;;AN000;;
							     ;;
;; Save registers and values needed later

	PUSH	AX					     ;;AN000;; Save changed REGs
	PUSH	BX					     ;;AN000;;
	PUSH	CX					     ;;AN000;;
	PUSH	BP					     ;;AN000;;
	PUSH	DI					     ;;AN000;; Save pointer to input buffer (offset)
	PUSH	ES					     ;;AN000;; Save pointer to input buffer (segment)
	PUSH	DX					     ;;AN000;; Save Input/Class request

	MOV	BP,CX					     ;;AN000;; Use BP to hold replace count
	MOV	WORD PTR $M_RT.$M_HANDLE,BX		     ;;AN000;; Save handle
	MOV	BYTE PTR $M_RT.$M_CLASS,DH		     ;;AN004;; Save class

;; Get address of the message requested

IF	FARmsg						     ;;AN000;;
	CALL	FAR PTR $M_GET_MSG_ADDRESS		     ;;AN000;; Scan thru classes to find message
ELSE							     ;;AN000;;
	CALL	$M_GET_MSG_ADDRESS			     ;;AN000;; Scan thru classes to find message
ENDIF							     ;;AN000;;
	OR	CX,CX					     ;;AN000;; Was message found?
;	$IF	NZ					     ;;AN000;;	 YES, Message address in ES:DI
	JZ $MIF93

;; Test if replacable parameters were specified

	  OR	  BP,BP 				     ;;AN000;;	 Were replacable parameters requested
;	  $IF	  Z					     ;;AN000;;
	  JNZ $MIF94

;; Display string without replacable parms

	    CALL    $M_DISPLAY_STRING			     ;;AN000;; No, great . . . Display message
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN94
$MIF94:
IF	    $M_REPLACE					     ;;AN000;;

;; Display message with replacable parms

	    CALL    $M_DISPLAY_MESSAGE			     ;;AN000;;	 Display the message with substitutions
ENDIF							     ;;AN000;;
;	  $ENDIF					     ;;AN000;;
$MEN94:
;	  $IF	  NC
	  JC $MIF97

	    POP     DX					     ;;AN000;; Get Input/Class request

	    CALL    $M_ADD_CRLF 			     ;;AN004;; Check if we need to add the CR LF chars.

	    POP     ES					     ;;AN000;; Get location of input buffer (if specified)
	    POP     DI					     ;;AN000;;

;; Test if character input was requested

IF	    INPUTmsg					     ;;AN000;;
	    OR	    DL,DL				     ;;AN000;; Was Wait-For-Input requested?
;	    $IF     NZ					     ;;AN000;;
	    JZ $MIF98
	      CALL    $M_WAIT_FOR_INPUT 		     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MIF98:
ENDIF							     ;;AN000;;
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN97
$MIF97:
	    ADD     SP,6				     ;;AN000;;
	    STC 					     ;;AN000;; Reset carry flag
;	  $ENDIF					     ;;AN000;;
$MEN97:
;	$ELSE						     ;;AN000;; No,
	JMP SHORT $MEN93
$MIF93:
	  POP	  ES					     ;;AN000;;	 Get pointer to input buffer (segment)
	  POP	  DI					     ;;AN000;;	 Get base pointer to first sublist (offset)
	  POP	  DX					     ;;AN000;;	 Get base pointer to first sublist (segment)
	  STC						     ;;AN000;;	 Set carry flag
;	$ENDIF						     ;;AN000;;
$MEN93:
							     ;;
;	$IF	NC					     ;;AN000;; Was there an error?
	JC $MIF104
	  POP	  BP					     ;;AN000;; No,
	  POP	  CX					     ;;AN000;;
	  POP	  BX					     ;;AN000;;
IF	  INPUTmsg					     ;;AN000;;
	  ADD	  SP,2					     ;;AN000;;
ELSE							     ;AN000;
	  POP	  AX					     ;;AN000;;
ENDIF							     ;;AN000;;
;	$ELSE						     ;;AN000;;	Yes,
	JMP SHORT $MEN104
$MIF104:
	  ADD	  SP,8					     ;;AN000;;	   Eliminate from stack
	  STC						     ;;AN000;;
;	$ENDIF						     ;;AN000;;
$MEN104:
							     ;;
	RET						     ;;AN000;; Return
							     ;;
	SYSDISPMSG ENDP 				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
;;
;;	PROC NAME: $M_DISPLAY_STRING
;;
;;	FUNCTION:  Will display or write string
;;	INPUTS:    ES:DI points to beginning of message
;;		   CX contains the length of string to write (if applicable)
;;	OUTPUTS:   None
;;	REGS Revised: None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DISPLAY_STRING PROC NEAR				     ;;AN000;;
							     ;;
	PUSH	AX					     ;;AN000;;
	PUSH	BX					     ;;AN000;;
	PUSH	DX					     ;;AN000;;
							     ;;
	MOV	BX,$M_RT.$M_HANDLE			     ;;AN000;; Retrieve handle
							     ;;
IF	COMR						     ;;  ** Special case for RESIDENT COMMAND.COM
	CALL	$M_DISPLAY_$_STRING			     ;;AN000;; No, display $ terminated string
ELSE
	CMP	BX,$M_NO_HANDLE 			     ;;AN000;; Was there a handle specified?
;	$IF	E					     ;;AN000;;
	JNE $MIF107
	  CALL	  $M_DISPLAY_$_STRING			     ;;AN000;; No, display $ terminated string
;	$ELSE						     ;;AN000;;
	JMP SHORT $MEN107
$MIF107:
	  CALL	  $M_DISPLAY_H_STRING			     ;;AN000;; Yes, display string to handle
;	$ENDIF						     ;;AN000;;
$MEN107:
							     ;AN001;
;	$IF	C					     ;;AN000;;	Was there an error?
	JNC $MIF110
	  MOV	  AH,DOS_GET_EXT_ERROR			     ;;AN000;;	Yes,
	  MOV	  BX,DOS_GET_EXT_ERROR_BX		     ;;AN000;;	  Get extended error
	  INT	  21H					     ;;AN000;;
	  XOR	  AH,AH 				     ;;AN000;;	  Clear AH
	  ADD	  SP,6					     ;;AN000;;	  Clean up stack
	  STC						     ;;AN000;;	  Flag that there was an error
;	$ELSE						     ;;AN000;;	No,
	JMP SHORT $MEN110
$MIF110:
	  CMP	  BX,$M_NO_HANDLE			     ;;AN000;; Was there a handle specified?
;	  $IF	  NE					     ;;AN000;;
	  JE $MIF112
	    CMP     AX,CX				     ;AN001;	 Was it ALL written?
;	    $IF     NE					     ;AN001;	 No,
	    JE $MIF113
	      CALL    $M_GET_EXT_ERR_39 		     ;AN001;	   Set Extended error
	      ADD     SP,6				     ;AN001;	   Clean up stack
	      STC					     ;AN001;	   Flag that there was an error
;	    $ENDIF					     ;AN001;
$MIF113:
;	  $ENDIF					     ;AN001;
$MIF112:
;	$ENDIF						     ;;AN000;;
$MEN110:
ENDIF
;	$IF	NC					     ;;AN000;;	Was there ANY error?
	JC $MIF117
	  POP	  DX					     ;;AN000;;	Restore regs
	  POP	  BX					     ;;AN000;;
	  POP	  AX					     ;;AN000;;
;	$ENDIF						     ;;AN000;;
$MIF117:
	RET						     ;;AN000;; Return
							     ;;
$M_DISPLAY_STRING ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_$_STRING
;;
;;	FUNCTION:  Will display a $ terminated string
;;	INPUTS:    ES:DI points to beginning of message text (not the length)
;;	OUPUTS:    None
;;	REGS USED: AX,DX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DISPLAY_$_STRING PROC NEAR				     ;;AN000;;
							     ;;
	PUSH	DS					     ;;AN000;;
	PUSH	ES					     ;;AN000;;
	POP	DS					     ;;AN000;; Set DS to segment of message text
IF	NOT	COMR
	CMP	CX,$M_SINGLE_CHAR			     ;;AN000;; Is this a single character?
;	$IF	E					     ;;AN000;; Yes,
	JNE $MIF119
	  MOV	  AH,DOS_DISP_CHAR			     ;;AN000;;	 DOS Function to display CHARACTER
	  MOV	  DL,BYTE PTR ES:[DI]			     ;;AN000;;	 Get the character
	  INT	  21H					     ;;AN000;;	 Write character
	  POP	  DS					     ;;AN000;; Set DS to segment of message text
	  MOV	  AL,DL 				     ;;AN000;;	 Get the character in AL
	  CALL	  $M_IS_IT_DBCS 			     ;;AN000;;	 Is this the first byte of a DB character
	  PUSH	  DS					     ;;AN000;;
	  PUSH	  ES					     ;;AN000;;
	  POP	  DS					     ;;AN000;; Set DS to segment of message text
;	  $IF	  C					     ;;AN000;;	 Yes,
	  JNC $MIF120
	    MOV     DL,BYTE PTR ES:[DI]+1		     ;;AN000;; Get the next character
	    INT     21H 				     ;;AN000;;	 Write character
	    CLC 					     ;;AN000;;	 Clear the DBCS indicator
;	  $ENDIF					     ;;AN000;;
$MIF120:
;	$ELSE						     ;;AN000;; No,
	JMP SHORT $MEN119
$MIF119:
ENDIF
	  MOV	  AH,DOS_DISP_CHAR			     ;;AN000;;	 DOS Function to display CHARACTER
;	  $DO						     ;;AN002;; No,
$MDO123:
	    OR	    CX,CX				     ;;AN002;;	 Are there any left to display?
;	  $LEAVE  Z					     ;;AN002;;	 Yes,
	  JZ $MEN123
	    MOV     DL,BYTE PTR ES:[DI] 		     ;;AN002;;	   Get the character
	    INT     21H 				     ;;AN002;;	   Display the character
	    INC     DI					     ;;AN002;;	   Set pointer to next character
	    DEC     CX					     ;;AN002;;	   Count this character
;	  $ENDDO  Z					     ;;AN002;; No,
	  JNZ $MDO123
$MEN123:
IF	  NOT	  COMR
;	$ENDIF						     ;;AN000;;
$MEN119:
ENDIF
	CLC						     ;;AN000;;	 Char functions used don't return carry as error
	POP	DS					     ;;AN000;;
	RET						     ;;AN000;;
							     ;;
$M_DISPLAY_$_STRING ENDP				     ;;AN000;;
							     ;;
IF	NOT	COMR


;
;Scan_ctrlZ : This routine looks through the string to be printed and 
;truncates it at the Ctrl-Z if any present.
;
;	ENTRY:	ds:dx = String to be displayed
;		cx = number of chars to be displayed
;
;	EXIT:	cx = number of chars to be displayed
;

Scan_CtrlZ	proc	near

	push	di
	push	ax
	push	es
	push	bx

	mov	di,dx
	push	ds
	pop	es   			;es:di points at string

	mov	bx,cx			;save current count

	mov	al,1ah	
	cld
	repne	scasb			;find first Ctrl-Z
	jnz	noCtrlZ		;no CtrlZ found in string

	sub	bx,cx
	dec	bx			;bx = new count to display
					
noCtrlZ:
	mov	cx,bx			;cx = actual display count

	pop	bx
	pop	es
	pop	ax
	pop	di

	ret

Scan_CtrlZ	endp



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_H_STRING
;;
;;	FUNCTION:  Will display a string to a specified handle
;;	INPUTS:    ES:DI points to beginning of message
;;		   CX contains the number of bytes to write
;;		   BX contains the handle to write to
;;	OUPUTS:    None
;;	REGS USED: AX,DX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DISPLAY_H_STRING PROC NEAR				     ;;AN000;;
							     ;;
	XOR	AX,AX					     ;;AN002;; Set number of bytes written to 0
	OR	CX,CX					     ;;AN002;; For performance, don't write if not necessary
;	$IF	NZ					     ;;AN002;; Any chars to write?
	JZ $MIF127
	  PUSH	  DS					     ;;AN000;; Yes,
	  PUSH	  ES					     ;;AN000;;
	  POP	  DS					     ;;AN000;;	 Set DS to segment of message text
	  MOV	  AH,DOS_WRITE_HANDLE			     ;;AN000;;	 DOS function to write to a handle
	  MOV	  DX,DI 				     ;;AN000;;	 Pointer to data to write
	  CMP	  CX,$M_SINGLE_CHAR			     ;;AN000;;	 Is this a single character?
;	  $IF	  E					     ;;AN000;;	 Yes,
	  JNE $MIF128
	    INT     21H 				     ;;AN000;;	   Write character
	    POP     DS					     ;;AN000;;	     Set DS to segment of message text
	    PUSH    AX					     ;;AN000;;
	    MOV     AL,BYTE PTR ES:[DI] 		     ;;AN000;;	     Get the character
	    CALL    $M_IS_IT_DBCS			     ;;AN000;;	     Is this the first byte of a DB character
	    POP     AX					     ;;AN000;;	     Set DS to segment of message text
	    PUSH    DS					     ;;AN000;;
	    PUSH    ES					     ;;AN000;;
	    POP     DS					     ;;AN000;;	     Set DS to segment of message text
;	    $IF     C					     ;;AN000;;	     Yes,
	    JNC $MIF129
	      CLC					     ;;AN000;;	      Clear the DBCS indicator
	      MOV     AH,DOS_WRITE_HANDLE		     ;;AN000;;	      DOS function to write to a handle
	      INC     DX				     ;;AN000;;	      Point to next character
	      INT     21H				     ;;AN000;;	      Write character
;	    $ENDIF					     ;;AN000;;
$MIF129:
;SR;
; If the single char happened to be a Ctrl-Z, the dos write would return
;0 chars written making the caller think there was an error writing. To 
;avoid this, we check if the single char was a Ctrl-Z and if so, return that
;the char was written, thus fooling the caller.
;
	pushf				;save flags
	cmp	byte ptr es:[di],1ah		;is char a Ctrl-Z?
	jnz	@f		;no, continue

	mov	ax,cx			;yes, fake as if it was written
@@:
	$M_Popf				;restore flags

;	  $ELSE 					     ;;AN000;;	 No,
	  JMP SHORT $MEN128
$MIF128:
;SR;
; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
;
	push	bp			; M007
	push	cx
	call	scan_ctrlZ		;cx = count without Ctrl-Z
	mov	bp,cx			;store no ^Z count in bp ;M007
	pop	cx			;get old count back ;M007
	
	    INT     21H 				     ;;AN000;;	   Write String at DS:SI to handle
	jnc	chk_count		;no error, adjust return count

	jmp	short m_cnt_ok		;error, return with carry set;M007
;M007
;	If we are writing to con and there is a Ctrl-Z in the string, the
;return count will be much less and if this returns to the caller we can get
;spurious error messages. We check here if the count returned is same as
;original count or same as the count if we stop at Ctrl-Z. In the second
;case, we fake it as if all bytes have been written. If the return count
;does not match either count, then we had some other disk error (such as
;insufficient disk space) and we pass it through
;
chk_count:
	cmp	cx,ax			;have all bytes been written?;M007
	je	m_cnt_ok		;there was an error writing ;M007
	cmp	bp,ax			;count = Ctrl-Z count? ;M007
	clc				;no error either way ;M007
	jne	m_cnt_ok		;no, pass it through ;M007
	mov	ax,cx			;return old count ;M007
m_cnt_ok:				; M007
	pop	bp			; M007

;	  $ENDIF					     ;;AN000;;
$MEN128:
	  POP	  DS					     ;;AN000;;
;	$ENDIF						     ;;AN002;;
$MIF127:
							     ;;
	RET						     ;;AN000;;
							     ;;
$M_DISPLAY_H_STRING ENDP				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_GET_EXT_ERR_39
;;
;;	FUNCTION:  Will set registers for extended error #39
;;	INPUTS:    None
;;	OUPUTS:    AX,BX,CX set
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_GET_EXT_ERR_39 PROC NEAR				     ;AN001;
							     ;;
	MOV	AX,EXT_ERR_39				     ;AN001; Set AX=39
	MOV	BX,(ERROR_CLASS_39 SHR 8) + ACTION_39	     ;AN001; Set BH=1 BL=4
	MOV	CH,LOCUS_39				     ;AN001; Set CH=1
							     ;AN001;
	RET						     ;AN001;
							     ;;
$M_GET_EXT_ERR_39 ENDP					     ;AN001;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIF
;;
;;	PROC NAME: $M_ADD_CRLF
;;
;;	FUNCTION:  Will decide whether to display a CRLF
;;	INPUTS:    DX contains the Input/Class requested
;;	OUTPUTS:   None
;;	REGS Revised: CX,ES,DI
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_ADD_CRLF PROC NEAR					     ;;AN004;;
							     ;;
	CMP	DH,UTILITY_MSG_CLASS			     ;;AN004;; Is it a utility message?
;	$IF	NE					     ;;AN004;; No,
	JE $MIF134
	  TEST	  DH,$M_NO_CRLF_MASK			     ;;AN004;;	 Are we to supress the CR LF?
;	  $IF	  Z					     ;;AN004;;	 No,
	  JNZ $MIF135
	    PUSH    DS					     ;;AN004;;
	    POP     ES					     ;;AN004;;	  Set ES to data segment
	    LEA     DI,$M_RT.$M_CRLF			     ;;AN004;;	  Point at CRLF message
	    MOV     CX,$M_CRLF_SIZE			     ;;AN004;;	  Set the message size
	    CALL    $M_DISPLAY_STRING			     ;;AN004;;	  Display the CRLF
;	  $ENDIF					     ;;AN004;;
$MIF135:
;	$ENDIF						     ;;AN004;;
$MIF134:
	RET						     ;;AN004;; Return
							     ;;
$M_ADD_CRLF ENDP					     ;;AN004;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_IS_IT_DBCS
;;
;;	FUNCTION:  Will decide whether character is Single or Double Byte
;;	INPUTS:    AL contains the byte to be checked
;;	OUPUTS:    Carry flag = 0 if byte is NOT in DBCS range
;;		   Carry flag = 1 if byte IS in DBCS range
;;	REGS USED: All restored
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_IS_IT_DBCS PROC NEAR 				     ;;AN000;;
							     ;;
	PUSH	ES					     ;;AN000;; Save Extra segment register
	PUSH	DI					     ;;AN000;; Save SI register
							     ;;
	LES	DI,$M_RT.$M_DBCS_VEC			     ;;AN000;;
	OR	DI,DI					     ;;AN000;; Was the DBCS vector set?
;	$IF	NZ					     ;;AN000;;
	JZ $MIF138
;	  $DO						     ;;AN000;;
$MDO139:
	    CMP     WORD PTR ES:[DI],$M_DBCS_TERM	     ;;AN000;; Is this the terminating flag?
	    CLC 					     ;;AN000;;
;	  $LEAVE  E					     ;;AN000;;
	  JE $MEN139
							     ;;        No,
	    CMP     AL,BYTE PTR ES:[DI] 		     ;;AN000;;	  Does the character fall in the DBCS range?
;	    $IF     AE,AND				     ;;AN000;;
	    JNAE $MIF141
	    CMP     AL,BYTE PTR ES:[DI]+1		     ;;AN000;;	  Does the character fall in the DBCS range?
;	    $IF     BE					     ;;AN000;;
	    JNBE $MIF141
	      STC					     ;;AN000;;	  Yes,
;	    $ENDIF					     ;;AN000;;	     Set carry flag
$MIF141:
	    INC     DI					     ;;AN000;;	  No,
	    INC     DI					     ;;AN000;;	     Go to next vector
;	  $ENDDO					     ;;AN000;;
	  JMP SHORT $MDO139
$MEN139:
;	$ENDIF						     ;;AN000;;
$MIF138:

	POP	DI					     ;;AN000;;
	POP	ES					     ;;AN000;; Restore SI register
	RET						     ;;AN000;; Return
							     ;;
$M_IS_IT_DBCS ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_CONVERT2ASC
;;
;;	FUNCTION: Convert a binary number to a ASCII string
;;	INPUTS: DX:AX contains the number to be converted
;;		$M_RT_DIVISOR contains the divisor
;;	OUPUTS: CX contains the number of characters
;;		Top of stack  --> Last character
;;				     . . .
;;		Bot of stack  --> First character
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CONVERT2ASC PROC NEAR				     ;;AN000;;
							     ;;
	POP	[$M_RT.$M_RETURN_ADDR]			     ;;AN000;; Save Return Address
	XOR	BX,BX					     ;;AN000;; Use BP as a swapping register
							     ;;
	XCHG	BX,AX					     ;;AN000;; Initialize - Low Word in BP
	XCHG	AX,DX					     ;;AN000;;		  - High Word in AX
;	$DO						     ;;AN000;; DO UNTIL Low Word becomes zero
$MDO145:
	  DIV	  $M_RT.$M_DIVISOR			     ;;AN000;; Divide High Word by divisor
	  XCHG	  BX,AX 				     ;;AN000;; Setup to divide Low Word using remainder
							     ;; 	and save reduced High Word in BP
	  DIV	  $M_RT.$M_DIVISOR			     ;;AN000;; Divide Low Word by divisor
	  CMP	  DX,9					     ;;AN000;;	Make a digit of the remainder
;	  $IF	  A					     ;;AN000;;	IF 10 to 15,
	  JNA $MIF146
	    ADD     DL,55				     ;;AN000;;	   Make A to F ASCII
;	  $ELSE 					     ;;AN000;;	IF 0 to 9,
	  JMP SHORT $MEN146
$MIF146:
	    ADD     DL,'0'				     ;;AN000;;	   Make 0 to 9 ASCII
;	  $ENDIF					     ;;AN000;;
$MEN146:
	  PUSH	  DX					     ;;AN000;; Save the digit on the stack
	  INC	  CX					     ;;AN000;; Count that digit
	  OR	  AX,AX 				     ;;AN000;; Are we done?
;	$LEAVE	Z,AND					     ;;AN000;;
	JNZ $MLL149
	  OR	  BX,BX 				     ;;AN000;; AX and BX must be ZERO!!
;	$LEAVE	Z					     ;;AN000;; No,
	JZ $MEN145
$MLL149:
IF	  NOT	  COMR
	  CMP	  CX,$M_FIRST_THOU			     ;;AN000;; Are we at the first thousands mark
;	  $IF	  E					     ;;AN000;; Yes,
	  JNE $MIF150
	    CMP     $M_SL.$M_S_PAD,$M_COMMA		     ;;AN000;; Is the pad character a comma?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF151
	      PUSH    WORD PTR $M_RT.$M_THOU_SEPARA	     ;;AN000;; Insert a thousand separator
	      INC     CX				     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MIF151:
;	  $ELSE 					     ;;AN000;; No,
	  JMP SHORT $MEN150
$MIF150:
	    CMP     CX,$M_SECOND_THOU			     ;;AN000;;	 Are we at the first thousands mark
;	    $IF     E					     ;;AN000;;	      Yes,
	    JNE $MIF154
	      CMP     $M_SL.$M_S_PAD,$M_COMMA		     ;;AN000;; Is the pad character a comma?
;	      $IF     E 				     ;;AN000;; Yes,
	      JNE $MIF155
		PUSH	WORD PTR $M_RT.$M_THOU_SEPARA	     ;;AN000;; Insert a thousand separator
		INC	CX				     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MIF155:
;	    $ELSE					     ;;AN000;;	      No,
	    JMP SHORT $MEN154
$MIF154:
	      CMP     CX,$M_THIRD_THOU			     ;;AN000;;	 Are we at the first thousands mark
;	      $IF     E 				     ;;AN000;;		Yes,
	      JNE $MIF158
		CMP	$M_SL.$M_S_PAD,$M_COMMA 	     ;;AN000;; Is the pad character a comma?
;		$IF	E				     ;;AN000;; Yes,
		JNE $MIF159
		  PUSH	  WORD PTR $M_RT.$M_THOU_SEPARA      ;;AN000;; Insert a thousand separator
		  INC	  CX				     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF159:
;	      $ENDIF					     ;;AN000;;
$MIF158:
;	    $ENDIF					     ;;AN000;;
$MEN154:
;	  $ENDIF					     ;;AN000;;
$MEN150:
ENDIF
	  XCHG	  AX,BX 				     ;;AN000;;	 Setup to divide the reduced High Word
							     ;;AN000;;	   and Revised Low Word
	  XOR	  DX,DX 				     ;;AN000;;	 Reset remainder
;	$ENDDO						     ;;AN000;;	 NEXT
	JMP SHORT $MDO145
$MEN145:
							     ;;AN000;; Yes,
	XOR	DX,DX					     ;;AN000;;	 Reset remainder
	XOR	AX,AX					     ;;AN000;;	 Reset remainder
	PUSH	[$M_RT.$M_RETURN_ADDR]			     ;;AN000;;	 Restore Return Address
	RET						     ;;AN000;;	 Return
							     ;;
$M_CONVERT2ASC ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_MESSAGE
;;
;;	FUNCTION:  Will display or write entire message (with replacable parameters)
;;	INPUTS:    ES:DI points to beginning of message
;;		   DS:SI points to first sublist structure in chain
;;		   BX contains the handle to write to (if applicable)
;;		   CX contains the length of string to write (before substitutions)
;;		   BP contains the count of replacables
;;
;;	OUTPUTS:
;;	REGS USED: All
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DISPLAY_MESSAGE PROC NEAR				     ;;AN000;;
							     ;;
;	$DO						     ;;AN000;; Note: DS:SI -> message
$MDO165:
	  XOR	  DX,DX 				     ;;AN000;; Set size = 0
	  OR	  CX,CX 				     ;;AN000;; Are we finished the message yet?
;	  $IF	  NZ					     ;;AN000;; No,
	  JZ $MIF166
	    MOV     AH,"%"				     ;;AN000;;	 Prepare to scan for %
	    MOV     AL,0				     ;;AN004;;
							     ;;
;	    $DO 					     ;;AN000;;	 Scan through string until %
$MDO167:
	      CMP     BYTE PTR ES:[DI],AH		     ;;AN000;;	 Is this character NOT a %
;	    $LEAVE  E,AND				     ;;AN000;;	 No,
	    JNE $MLL168
	      CMP     BYTE PTR ES:[DI+1],AH		     ;;AN000;;	   Is the next character also a %
;	    $LEAVE  NE,AND				     ;;AN000;;	   No,
	    JE $MLL168
	      CMP     AL,AH				     ;;AN000;;	     Was the character before a %
;	    $LEAVE  NE					     ;;AN000;;	     No, GREAT found it
	    JNE $MEN167
$MLL168:
	      MOV     AL,BYTE PTR ES:[DI]		     ;;AN004;;	 Yes, (to any of the above)
	      CALL    $M_IS_IT_DBCS			     ;;AN004;;	   Is this character the first part of a DBCS?
;	      $IF     C 				     ;;AN004;;	   Yes,
	      JNC $MIF169
		INC	DI				     ;;AN004;;	     Increment past second part
;	      $ENDIF					     ;;AN004;;
$MIF169:
	      INC     DI				     ;;AN000;;	     Next character in string
	      INC     DX				     ;;AN000;;	     Size = Size + 1
	      DEC     CX				     ;;AN000;;	     Decrement total size
;	    $ENDDO  Z					     ;;AN000;;	 Exit scan if we're at the end of the line
	    JNZ $MDO167
$MEN167:
;	  $ENDIF					     ;;AN000;;
$MIF166:
							     ;;
	  PUSH	  SI					     ;;AN000;; Save beginning of sublists
	  XCHG	  CX,DX 				     ;;AN000;; Get size of message to display (tot sz in DX)
	  OR	  BP,BP 				     ;;AN000;; Do we have any replacables to do?
;	  $IF	  NZ					     ;;AN000;; Yes,
	  JZ $MIF173
	    DEC     BP					     ;;AN000;;	 Decrement number of replacables

;; Search through sublists to find applicable one

	    CMP     $M_RT.$M_MSG_NUM,$M_NULL		     ;;AN000;; Is this an Extended/Parse case
;	    $IF     E					     ;;AN000;; No,
	    JNE $MIF174
;	      $SEARCH					     ;;AN000;;
$MDO175:
		MOV	AL,$M_SL.$M_S_ID		     ;;AN000;;	 Get ID byte
		ADD	AL,30H				     ;;AN000;;	 Convert to ASCII
		CMP	AL,BYTE PTR ES:[DI]+1		     ;;AN000;;	 Is this the right sublist?
;	      $EXITIF E 				     ;;AN000;;
	      JNE $MIF175
;	      $ORELSE					     ;;AN000;;	 No,
	      JMP SHORT $MSR175
$MIF175:
		CMP	AL,$M_SPECIAL_CASE		     ;;AN000;;	   Does this sublist have ID = 0
;	      $LEAVE  E,AND				     ;;AN000;;	   Yes,
	      JNE $MLL178
		OR	DX,DX				     ;;AN000;;	   Are we at the end of the message?
;	      $LEAVE  Z 				     ;;AN000;;	   No,
	      JZ $MEN175
$MLL178:
		ADD	SI,WORD PTR $M_SL.$M_S_SIZE	     ;;AN000;;	     Next SUBLIST
;	      $ENDLOOP					     ;;AN000;;	   Yes,
	      JMP SHORT $MDO175
$MEN175:
		CMP	$M_RT.$M_CLASS,UTILITY_MSG_CLASS     ;;AN004;;	     Is it a utility message?
;		$IF	E				     ;;AN004;;	     Yes,
		JNE $MIF180
		  INC	  DX				     ;;AN000;;	       Remember to display CR,LF
		  INC	  DX				     ;;AN000;;		 at the end of the message
		  DEC	  CX				     ;;AN000;;	       Adjust message length
		  DEC	  CX				     ;;AN000;;
		  DEC	  DI				     ;;AN000;;	       Adjust ending address of message
		  DEC	  DI				     ;;AN000;;
;		$ELSE					     ;;AN004;;	     No,
		JMP SHORT $MEN180
$MIF180:
		  MOV	  DX,-1 			     ;;AN004;;	       Set special case
;		$ENDIF					     ;;AN004;;
$MEN180:
;	      $ENDSRCH					     ;;AN000;;
$MSR175:
;	    $ENDIF					     ;;AN000;;
$MIF174:
;	  $ENDIF					     ;;AN000;;
$MIF173:

;; Prepare and display this part of message

	  PUSH	  DI					     ;;AN000;; Save pointer to replace number
	  SUB	  DI,CX 				     ;;AN000;; Determine beginning of string
	  CALL	  $M_DISPLAY_STRING			     ;;AN000;; Display string until % (or end)
	  POP	  DI					     ;;AN000;; Get back pointer to replace number
	  POP	  CX					     ;;AN000;; Clean up stack in case error
;	$LEAVE	C,LONG					     ;;AN000;; Fail if carry was set
	JNC $MXL3
	JMP $MEN165
$MXL3:
	  PUSH	  CX					     ;;AN000;;

;; Save and reset pointer registers

	  MOV	  CX,DX 				     ;;AN000;; Get the size of the rest of the message
	  CMP	  $M_SL.$M_S_ID,$M_SPECIAL_CASE-30H	     ;;AN000;; Is this the %0 case?
;	  $IF	  NE					     ;;AN000;; No,
	  JE $MIF187
	    OR	    CX,CX				     ;;AN000;;	Are we finished the whole message?
;	    $IF     NZ					     ;;AN000;;	No,
	    JZ $MIF188
	      DEC     CX				     ;;AN000;;	  Decrement total size (%)
	      DEC     CX				     ;;AN000;;	  Decrement total size (#)
	      INC     DI				     ;;AN000;;	  Go past %
	      INC     DI				     ;;AN000;;	  Go past replace number
;	    $ELSE					     ;;AN000;;	Yes, (Note this will not leave because INC)
	    JMP SHORT $MEN188
$MIF188:
	      POP     SI				     ;;AN000;;	  Get back pointer to beginning of SUBLISTs
;	    $ENDIF					     ;;AN000;; Yes, Note this will not leave because INC
$MEN188:
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN187
$MIF187:
	    OR	    CX,CX				     ;;AN000;;	Are we finished the whole message?
;	    $IF     Z					     ;;AN004;;	 No,
	    JNZ $MIF192
	      POP     SI				     ;;AN000;;	 Get back pointer to beginning of SUBLISTs
;	    $ELSE					     ;;AN000;; No,
	    JMP SHORT $MEN192
$MIF192:
	      CMP     CX,-1				     ;;AN004;;	 Are we at the end of the message?
;	      $IF     Z 				     ;;AN004;;	 No,
	      JNZ $MIF194
		XOR	CX,CX				     ;;AN004;;
;	      $ENDIF					     ;;AN000;;
$MIF194:
	      OR      DI,DI				     ;;AN004;;	Turn ZF off
;	    $ENDIF					     ;;AN000;;
$MEN192:
;	  $ENDIF					     ;;AN000;; Note this will not leave because INC
$MEN187:
;	$LEAVE	Z					     ;;AN000;;
	JZ $MEN165
	  PUSH	  BP					     ;;AN000;;	 Save the replace count
	  PUSH	  DI					     ;;AN000;;	 Save location to complete message
	  PUSH	  ES					     ;;AN000;;
	  PUSH	  CX					     ;;AN000;;	 Save size of the rest of the message
	  XOR	  CX,CX 				     ;;AN000;;	 Reset CX used for character count

;; Determine what action is required on parameter

	  CMP	  $M_RT.$M_MSG_NUM,$M_NULL		     ;;AN000;; Is this an Extended/Parse case
;	  $IF	  E					     ;;AN000;;
	  JNE $MIF199

IF	    CHARmsg					     ;;AN000;; Was Char specified?
	    TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK ;;AN000;;
;	    $IF     Z					     ;;AN000;;
	    JNZ $MIF200

;; Character type requested
							     ;;AN000;;
	      LES     DI,DWORD PTR $M_SL.$M_S_VALUE	     ;;AN000;; Load pointer to replacing parameter
	      CALL    $M_CHAR_REPLACE			     ;;AN000;;
;	    $ELSE					     ;;AN000;;	 Get the rest of the message to display
	    JMP SHORT $MEN200
$MIF200:
ENDIF							     ;;AN000;;
IF	      NUMmsg					     ;;AN000;; Was Nnmeric type specified?
	      TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK ;;AN000;;
;	      $IF     Z,OR				     ;;AN000;;
	      JZ $MLL202
	      TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK ;;AN000;;
;	      $IF     Z,OR				     ;;AN000;;
	      JZ $MLL202
	      TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Bin_Hex_Type AND $M_TYPE_MASK ;;AN000;;
;	      $IF     Z 				     ;;AN000;;
	      JNZ $MIF202
$MLL202:

;; Numeric type requested

		LES	DI,DWORD PTR $M_SL.$M_S_VALUE	     ;;AN000;; Load pointer to replacing parameter
		CALL	$M_BIN2ASC_REPLACE		     ;;AN000;;
;	      $ELSE					     ;;AN000;; Get the rest of the message to display
	      JMP SHORT $MEN202
$MIF202:
ENDIF							     ;;AN000;;
IF		DATEmsg 				     ;;AN000;; Was date specified?
		TEST	BYTE PTR $M_SL.$M_S_FLAG,NOT Date_Type AND $M_TYPE_MASK ;;AN000;;
;		$IF	E				     ;;AN000;;
		JNE $MIF204

;; Date type requested

		  CALL	  $M_DATE_REPLACE		     ;;AN000;;
;		$ELSE					     ;;AN000;; Get the rest of the message to display
		JMP SHORT $MEN204
$MIF204:
ENDIF							     ;;AN000;;
IF		  TIMEmsg				     ;;AN000;;	Was time (12 hour format) specified?

;; Time type requested (Default if we have not matched until here)

		  CALL	  $M_TIME_REPLACE		     ;;AN000;;
ENDIF							     ;;AN000;;

IF		  DATEmsg				     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MEN204:
ENDIF							     ;;AN000;;
IF		NUMmsg					     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MEN202:
ENDIF							     ;;AN000;;
IF	      CHARmsg					     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MEN200:
ENDIF							     ;;AN000;;

IF	    $M_REPLACE					     ;;AN000;;
;; With the replace information of the Stack, display the replaceable field

	    CALL    $M_DISPLAY_REPLACE			     ;;AN000;; Display the replace
ENDIF							     ;;AN000;;
;; None of the above - Extended/Parse replace
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN199
$MIF199:
IF	    NOT     COMR
	    CALL    $M_EXT_PAR_REPLACE			     ;;AN000;;
ENDIF
;	  $ENDIF					     ;;AN000;;
$MEN199:

;; We must go back and complete the message after the replacable parameter if there is any left

;	  $IF	  NC					     ;;AN000;; IF there was an error displaying then EXIT
	  JC $MIF211
	    POP     CX					     ;;AN000;; Get size of the rest of the message
	    POP     ES					     ;;AN000;; Get address of the rest of the message
	    POP     DI					     ;;AN000;;
	    POP     BP					     ;;AN000;; Get replacment count
	    POP     SI					     ;;AN000;; ELSE get address of first sublist structure
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN211
$MIF211:
	    ADD     SP,10				     ;;AN000;; Clean up stack if error
	    STC 					     ;;AN000;;
;	  $ENDIF					     ;;AN000;;
$MEN211:
	  CMP	  $M_RT.$M_MSG_NUM,$M_NULL		     ;;AN000;; Is this an Extended/Parse case
;	$ENDDO	NE,OR					     ;;AN000;;
	JNE $MLL214
;	$ENDDO	C,LONG					     ;;AN000;; Go back and display the rest of the message
	JC $MXL4
	JMP $MDO165
$MXL4:
$MLL214:
$MEN165:
							     ;;        IF there was an error displaying then EXIT
	MOV	$M_RT.$M_MSG_NUM,0			     ;;AN000;; Reset message number to null
	RET						     ;;AN000;; Return
							     ;;
$M_DISPLAY_MESSAGE ENDP 				     ;;AN000;;
IF	NOT	COMR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_EXT_PAR_REPLACE
;;
;;	FUNCTION:
;;	INPUTS:
;;	OUPUTS:
;;
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_EXT_PAR_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	XOR	DX,DX					     ;;AN000;; Prepare for get binary value (HIGH)
	MOV	AX,$M_RT.$M_MSG_NUM			     ;;AN000;; Prepare for get binary value (LOW)
	MOV	$M_RT.$M_DIVISOR,$M_BASE10		     ;;AN000;; Set default divisor
							     ;;
	CALL	$M_CONVERT2ASC				     ;;AN000;;
							     ;;
;	$DO						     ;;AN000;;
$MDO215:
	  POP	  AX					     ;;AN000;;	 Get character in register
	  MOV	  BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL	     ;;AN000;;	Move char into the buffer
	  INC	  BX					     ;;AN000;;	 Increase buffer count
	  CMP	  BX,$M_TEMP_BUF_SZ			     ;;AN000;;	 Is buffer full?
;	  $IF	  E					     ;;AN000;;	 Yes,
	  JNE $MIF216
	    CALL    $M_FLUSH_BUF			     ;;AN000;;	   Flush the buffer
;	  $ENDIF					     ;;AN000;;
$MIF216:
	  DEC	  CL					     ;;AN000;;	 Have we completed replace?
;	$ENDDO	Z					     ;;AN000;;
	JNZ $MDO215
							     ;;
	MOV	AX,$M_CR_LF				     ;;AN000;;	Move char into the buffer
	MOV	WORD PTR $M_RT.$M_TEMP_BUF[BX],AX	     ;;AN000;;	Move char into the buffer
	INC	BX					     ;;AN000;;	 Increase buffer count
	INC	BX					     ;;AN000;;	 Increase buffer count
	CALL	$M_FLUSH_BUF				     ;;AN000;;	   Flush the buffer
	RET						     ;;AN000::
							     ;;
$M_EXT_PAR_REPLACE ENDP 				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIF
	IF	$M_SUBS 				     ;;AN000;; Include the common subroutines if they haven't yet
	  $M_SUBS = FALSE				     ;;AN000;; No, then include and reset the flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_GET_MSG_ADDRESS
;;
;;	FUNCTION:  To scan thru classes to return pointer to the message header
;;	INPUTS:    Access to $M_RES_ADDRESSES
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN DS:SI points to the specified message
;;	REGS CHANGED: ES,DI,CX,DS,SI
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
IF	  FARmsg					     ;;AN000;;
	  $M_GET_MSG_ADDRESS PROC FAR			     ;;AN000;;
ELSE							     ;;AN000;;
	  $M_GET_MSG_ADDRESS PROC NEAR			     ;;AN000;;
ENDIF							     ;;AN000;;
							     ;;
	  PUSH	  SI					     ;;AN000;;
	  PUSH	  BX					     ;;AN000;;
	  XOR	  SI,SI 				     ;;AN000;; Use SI as an index
	  XOR	  CX,CX 				     ;;AN000;; Use CX as an size
;	  $DO						     ;;AN000;;
$MDO219:
	    CMP     DH,UTILITY_MSG_CLASS		     ;;AN000;; Were utility messages requested?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF220
	      IF      FARmsg				     ;;AN000;;
		LES	DI,DWORD PTR $M_RT.$M_CLASS_ADDRS[SI] ;;AN000;;  Get address of class
		MOV	BX,ES				     ;;AN000;
	      ELSE					     ;;AN000;;
		MOV	DI,WORD PTR $M_RT.$M_CLASS_ADDRS[SI] ;;AN000;;	 Get address of class
		MOV	BX,DI				     ;;AN000;
	      ENDIF					     ;;AN000;;
;	    $ELSE					     ;;AN000;; No,
	    JMP SHORT $MEN220
$MIF220:
	      TEST    DH,PARSE_ERR_CLASS		     ;;AN000;;	 Were parse errors requested?
;	      $IF     NE				     ;;AN000;;	 Yes,
	      JE $MIF222
		LES	DI,DWORD PTR $M_RT.$M_PARSE_COMMAND[SI] ;;AN000;;   Get address of class
		MOV	BX,ES				     ;;AN000;
;	      $ELSE					     ;;AN000;;	 No, extended errors were specified
	      JMP SHORT $MEN222
$MIF222:
		CMP	AX,$M_CRIT_LO			     ;;AN000;;	   Is this a critical error?
;		$IF	AE,AND				     ;;AN000;;
		JNAE $MIF224
		CMP	AX,$M_CRIT_HI			     ;;AN000;;
;		$IF	BE				     ;;AN000;;	    Yes,
		JNBE $MIF224
		  LES	  DI,DWORD PTR $M_RT.$M_CRIT_ADDRS[SI] ;;AN000;; Get address of class
		  MOV	  BX,ES 			     ;;AN000;
;		$ELSE					     ;;AN000;;
		JMP SHORT $MEN224
$MIF224:
		  LES	  DI,DWORD PTR $M_RT.$M_EXT_ERR_ADDRS[SI] ;;AN000;; Get address of class
		  MOV	  BX,ES 			     ;;AN000;
;		$ENDIF					     ;;AN000;;
$MEN224:
;	      $ENDIF					     ;;AN000;;
$MEN222:
;	    $ENDIF					     ;;AN000;;
$MEN220:
							     ;;
	    CMP     BX,$M_TERMINATING_FLAG		     ;;AN000;; Are we finished all classes?
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF229
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN000;;	  Was it a UTILITY class?
;	      $IF     E 				     ;;AN000;;	  Yes,
	      JNE $MIF230
		STC					     ;;AN000;;	    Set the carry flag
;	      $ELSE					     ;;AN000;;	  No,
	      JMP SHORT $MEN230
$MIF230:
		MOV	$M_RT.$M_MSG_NUM,AX		     ;;AN000;;	    Save message number
		MOV	AX,$M_SPECIAL_MSG_NUM		     ;;AN000;;	    Set special message number
		MOV	BP,$M_ONE_REPLACE		     ;;AN000;;	    Set one replace in message
		XOR	SI,SI				     ;;AN000;;	    Reset the SI index to start again
		CLC					     ;;AN000;;
;	      $ENDIF					     ;;AN000;; No,
$MEN230:
;	    $ELSE					     ;;AN000;;
	    JMP SHORT $MEN229
$MIF229:
	      CMP     BX,$M_CLASS_NOT_EXIST		     ;;AN000;;	 Does this class exist?
;	      $IF     NE				     ;;AN001;;	 Yes,
	      JE $MIF234
		CALL	$M_FIND_SPECIFIED_MSG		     ;;AN000;;	   Try to find the message
;	      $ENDIF					     ;;AN000;;
$MIF234:
	      ADD     SI,$M_ADDR_SZ_FAR 		     ;;AN000;;	     Get next class
	      CLC					     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MEN229:
;	  $LEAVE  C					     ;;AN000;;
	  JC $MEN219
	    OR	    CX,CX				     ;;AN000;;	   Was the message found?
;	  $ENDDO  NZ,LONG				     ;;AN000;;
	  JNZ $MXL5
	  JMP $MDO219
$MXL5:
$MEN219:

	  PUSHF 					     ;;AN006;; Save the flag state
	  CMP	  DH,EXT_ERR_CLASS			     ;;AN006;; Was an extended error requested?
;	  $IF	  E					     ;;AN006;; Yes,
	  JNE $MIF239
	    PUSH    DX					     ;;AN006;;	Save all needed registers
	    PUSH    BP					     ;;AN006;;
	    PUSH    CX					     ;;AN006;;
	    PUSH    ES					     ;;AN006;;
	    PUSH    DI					     ;;AN006;;
	    PUSH    AX					     ;;AN006;;

	    MOV     AX,IFSFUNC_INSTALL_CHECK		     ;;AN006;;	Check if IFSFUNC is installed
	    INT     2FH 				     ;;AN006;;
	    CMP     AL,IFSFUNC_INSTALLED		     ;;AN006;;	Is it installed?
	    POP     AX					     ;;AN006;;	Restore msg number
;	    $IF     E					     ;;AN006;;	 Yes,
	    JNE $MIF240
	      MOV     BX,AX				     ;;AN006;;	  BX is the extended error number
	      MOV     AX,IFS_GET_ERR_TEXT		     ;;AN006;;	  AX is the muliplex number
	      INT     2FH				     ;;AN006;;	  Call IFSFUNC
;	    $ELSE					     ;;AN006;;	 No,
	    JMP SHORT $MEN240
$MIF240:
	      STC					     ;;AN006;;	  Carry conditon
;	    $ENDIF					     ;;AN006;;
$MEN240:

;	    $IF     C					     ;;AN006;;	Was there an update?
	    JNC $MIF243
	      POP     DI				     ;;AN006;;	No,
	      POP     ES				     ;;AN006;;	 Restore old pointer
	      POP     CX				     ;;AN006;;
;	    $ELSE					     ;;AN006;;	Yes
	    JMP SHORT $MEN243
$MIF243:
	      ADD     SP,6				     ;;AN006;;	 Throw away old pointer
	      CALL    $M_SET_LEN_IN_CX			     ;;AN006;;	 Get the length of the ASCIIZ string
;	    $ENDIF					     ;;AN006;;
$MEN243:
	    POP     BP					     ;;AN006;;	Restore other Regs
	    POP     DX					     ;;AN006;;
;	  $ENDIF					     ;;AN006;;
$MIF239:
	  $M_POPF					     ;;AN006;; Restore the flag state

	  POP	  BX					     ;;AN000;;
	  POP	  SI					     ;;AN000;;
	  RET						     ;;AN000;; Return ES:DI pointing to the message
							     ;;
$M_GET_MSG_ADDRESS ENDP 				     ;;
							     ;;
$M_SET_LEN_IN_CX PROC NEAR				     ;;
							     ;;
	  PUSH	  DI					     ;;AN006;; Save position
	  PUSH	  AX					     ;;AN006;;
	  MOV	  CX,-1 				     ;;AN006;; Set CX for decrements
	  XOR	  AL,AL 				     ;;AN006;; Prepare compare register
	  REPNE   SCASB 				     ;;AN006;; Scan for zero
	  NOT	  CX					     ;;AN006;; Change decrement into number
	  DEC	  CX					     ;;AN006;; Don't include the zero
	  POP	  AX					     ;;AN006;;
	  POP	  DI					     ;;AN006;; Restore position
	  RET						     ;;AN006;;
							     ;;
$M_SET_LEN_IN_CX ENDP					     ;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_FIND_SPECIFIED_MSG
;;
;;	FUNCTION:  To scan thru message headers until message is found
;;	INPUTS:    ES:DI points to beginning of msg headers
;;		   CX contains the number of messages in class
;;		   DH contains the message class
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN ES:DI points to header of specified message
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_FIND_SPECIFIED_MSG PROC NEAR 			     ;;AN000;;
							     ;;
ifdef BILINGUAL
	push	ax			; save ax
	push	ax
	push	bx
	mov	ax,4f01h		; get code page
	xor	bx,bx
	int	2fh
ifdef JAPAN
	cmp	bx,932
endif
ifdef KOREA
	cmp	bx,949
endif
ifdef TAIWAN
	cmp	bx,950
endif
ifdef PRC
	cmp	bx,936
endif
	pop	bx
	pop	ax
	jz	MFSM_13			; if DBCS code page
	cmp	ax,$M_SPECIAL_MSG_NUM
	jz	MFSM_13
	cmp	dh,EXT_ERR_CLASS
	jz	MFSM_11
	cmp	dh,PARSE_ERR_CLASS
	jz	MFSM_12
	add	ax,UTILITY_MSG_ADJ
	jmp	short MFSM_13
MFSM_11:
	add	ax,EXT_MSG_ADJ
	jmp	short MFSM_13
MFSM_12:
	add	ax,PARSE_MSG_ADJ
MFSM_13:
endif

	  CMP	  BX,1					     ;;AN004;;	Do we have an address to CALL?
;	  $IF	  E,AND 				     ;;AN004;;	Yes,
	  JNE $MIF247
	  CMP	  WORD PTR $M_RT.$M_DISK_PROC_ADDR,-1	     ;;AN004;;	Do we have an address to CALL?
;	  $IF	  NE					     ;;AN004;;	Yes,
	  JE $MIF247
	    CMP     AX,$M_SPECIAL_MSG_NUM		     ;;AN004;; Are we displaying a default Ext Err?
;	    $IF     E					     ;;AN004;;	. . . and . . .
	    JNE $MIF248
	      PUSH    AX				     ;;AN004;;	 Reset the special message number
	      MOV     AX,$M_RT.$M_MSG_NUM		     ;;AN004;;	 Get the old message number
	      CALL    DWORD PTR $M_RT.$M_DISK_PROC_ADDR      ;;AN004;;	 Call the READ_DISK_PROC to get error text
	      POP     AX				     ;;AN004;;	 Reset the special message number
;	    $ELSE					     ;;AN004;;	 Get the old message number
	    JMP SHORT $MEN248
$MIF248:
	      CALL    DWORD PTR $M_RT.$M_DISK_PROC_ADDR      ;;AN004;;	 Call the READ_DISK_PROC to get error text
;	    $ENDIF					     ;;AN004;;	 Get the old message number
$MEN248:
;	  $ELSE 					     ;;AN004;;
	  JMP SHORT $MEN247
$MIF247:
	    XOR     CX,CX				     ;;AN002;;	 CX = 0 will allow us to
	    CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;
;	    $IF     NE					     ;;AN001;;
	    JE $MIF252
ifdef BILINGUAL
	      MOV     CX,WORD PTR ES:[DI].$M_NUM_CLS_MSG     ;;AN001;;	 Get number of messages in class
else
	      MOV     CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG     ;;AN001;;	 Get number of messages in class
endif
;	    $ELSE					     ;;AN001;;
	    JMP SHORT $MEN252
$MIF252:
IF	      FARmsg					     ;;AN001;;
	      CMP     BYTE PTR ES:[DI].$M_CLASS_ID,DH	     ;;AN002;; Check if class still exists at
ELSE
	      CMP     BYTE PTR CS:[DI].$M_CLASS_ID,DH	     ;;AN002;; Check if class still exists at
ENDIF
;	      $IF     E 				     ;;AN002;;	pointer (hopefully)
	      JNE $MIF254
IF		FARmsg					     ;;AN001;;
ifdef BILINGUAL
		MOV	CX,WORD PTR ES:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
else
		MOV	CL,BYTE PTR ES:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
endif
ELSE
ifdef BILINGUAL
		MOV	CX,WORD PTR CS:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
else
		MOV	CL,BYTE PTR CS:[DI].$M_NUM_CLS_MSG   ;;AN000;;	   Get number of messages in class
endif
ENDIF
;	      $ENDIF					     ;;AN002;;	  go on to the next class
$MIF254:
;	    $ENDIF					     ;;AN001;;
$MEN252:
	    ADD     DI,$M_CLASS_ID_SZ			     ;;AN000;;	   Point past the class header
	    STC 					     ;;AN004;;	 Flag that we haven't found anything yet
;	  $ENDIF					     ;;AN004;;
$MEN247:

;	  $IF	  C					     ;;AN004;; Have we found anything yet?
	  JNC $MIF258
	    CLC 					     ;;AN004;; No, reset carry
;	    $SEARCH					     ;;AN000;;
$MDO259:
	      OR      CX,CX				     ;;AN000;;	  Do we have any to check?
;	    $LEAVE  Z					     ;;AN000;;	     No, return with CX = 0
	    JZ $MEN259
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;
;	      $IF     NE				     ;;AN001;;
	      JE $MIF261
		CMP	AX,WORD PTR ES:[DI].$M_NUM	     ;;AN001;; Is this the message requested?
;	      $ELSE					     ;;AN001;;
	      JMP SHORT $MEN261
$MIF261:
IF		FARmsg					     ;;AN001;;
		CMP	AX,WORD PTR ES:[DI].$M_NUM	     ;;AN000;; Is this the message requested?
ELSE
		CMP	AX,WORD PTR CS:[DI].$M_NUM	     ;;AN000;; Is this the message requested?
ENDIF
;	      $ENDIF
$MEN261:
;	    $EXITIF E					     ;;AN000;;
	    JNE $MIF259
;	    $ORELSE					     ;;AN000;
	    JMP SHORT $MSR259
$MIF259:
	      DEC     CX				     ;;AN000;;	  No, well do we have more to check?
;	    $LEAVE  Z					     ;;AN000;;	     No, return with CX = 0
	    JZ $MEN259
	      ADD     DI,$M_ID_SZ			     ;;AN000;;	     Yes, skip past msg header
;	    $ENDLOOP					     ;;AN000;;
	    JMP SHORT $MDO259
$MEN259:
	      STC					     ;;AN000;;
;	    $ENDSRCH					     ;;AN000;;	     Check next message
$MSR259:
;	    $IF     NC					     ;;AN000;;	 Did we find the message?
	    JC $MIF269
	      CMP     DH,UTILITY_MSG_CLASS		     ;;AN001;;	 Yes, is it a utility message?
	      CLC					     ;;AN001;;
;	      $IF     E 				     ;;AN001;;
	      JNE $MIF270
IF		FARmsg					     ;;AN001;;
ELSE							     ;;AN000;;
		PUSH	CS				     ;;AN000;;
		POP	ES				     ;;AN000;;	 Return ES:DI pointing to the message
ENDIF
;	      $ENDIF					     ;;AN001;;
$MIF270:
	      ADD     DI,WORD PTR ES:[DI].$M_TXT_PTR	     ;;AN000;; Prepare ES:DI pointing to the message
;	    $ENDIF					     ;;AN004;;
$MIF269:
;	  $ENDIF					     ;;AN004;;
$MIF258:
							     ;; 	  Yes, great we can return with CX > 0

;	  $IF	  NC					     ;;AN000;;	 Did we find the message?
	  JC $MIF274
	    XOR     CH,CH				     ;;AN000;;
	    MOV     CL,BYTE PTR ES:[DI] 		     ;;AN000;;	 Move size into CX
	    INC     DI					     ;;AN000;;	 Increment past length
;	  $ENDIF					     ;;AN004;;
$MIF274:

	  MOV	  $M_RT.$M_SIZE,$M_NULL 		     ;;AN004;; Reset variable
ifdef BILINGUAL
	pop	ax
endif
	  RET						     ;;AN000;; Return
							     ;;
$M_FIND_SPECIFIED_MSG ENDP				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;;AN000;; END of include of common subroutines
; 
	IF	$M_REPLACE				     ;;AN000;; Is the request to include the code for replaceable parms
	  $M_REPLACE = FALSE				     ;;AN000;;	   Tell the assembler we did
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
$M_DISPLAY_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	  XOR	  BX,BX 				     ;;AN000;; Use BX for buffer count
IF	  NOT	  COMR
	  CMP	  $M_SL.$M_S_ID,$M_SPECIAL_CASE-30H	     ;;AN000;; Is this the special case (convert to ASCII)
;	  $IF	  E					     ;;AN000;; Yes,
	  JNE $MIF276
	    MOV     WORD PTR $M_RT.$M_TEMP_BUF[BX],$M_SPACE_HYP ;;AN000;; Move in a " -"
	    INC     BX					     ;;AN000;;	   Increment count
	    INC     BX					     ;;AN000;;	   Increment count
	    MOV     BYTE PTR $M_RT.$M_TEMP_BUF[BX],$M_SPACE  ;;AN000;;	   Move in a " "
	    INC     BX					     ;;AN000;;	   Increment count
	    CALL    $M_FLUSH_BUF			     ;;AN000;;	   Write out " - " to prepare for special case
;	  $ENDIF					     ;;AN000;;	   If it fails we will catch it later
$MIF276:
ENDIF

	  POP	  BP					     ;;AN000;; Remember the return address
	  XOR	  BX,BX 				     ;;AN000;; Use BX for buffer count
	  XOR	  DX,DX 				     ;;AN000;; Use DX for count of parms taken off the stack

	  MOV	  $M_RT.$M_SIZE,CL			     ;;AN000;; Save size to later clear stack
	  MOV	  AL,BYTE PTR $M_SL.$M_S_MINW		     ;;AN000;; Get the minimum width
							     ;;
	  CMP	  AL,CL 				     ;;AN000;; Do we need pad chars added?
;	  $IF	  A					     ;;AN000;; Yes,
	  JNA $MIF278
	    SUB     AL,CL				     ;;AN000;;	 Calculate how many pad chars are needed.
	    MOV     DH,AL				     ;;AN000;;	 Save the number of pad characters
	    TEST    BYTE PTR $M_SL.$M_S_FLAG,Right_Align     ;;AN000;;	 Was replaceable parm to be right aligned?
;	    $IF     NZ					     ;;AN000;;	 Yes,
	    JZ $MIF279
;	      $DO					     ;;AN000;;	   Begin filling buffer with pad chars
$MDO280:
		MOV	AL,BYTE PTR $M_SL.$M_S_PAD	     ;;AN000;;
		MOV	BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL    ;;AN000;;	   Move in a pad char
		INC	BX				     ;;AN000;;
		CMP	BX,$M_TEMP_BUF_SZ		     ;;AN000;;	   Is buffer full?
;		$IF	E				     ;;AN000;;	   Yes,
		JNE $MIF281
		  CALL	  $M_FLUSH_BUF			     ;;AN000;;	     Flush the buffer
;		$ENDIF					     ;;AN000;;
$MIF281:
		DEC	DH				     ;;AN000;;	   Have we filled with enough pad chars?
;	      $ENDDO  Z 				     ;;AN000;;	   No, next pad character
	      JNZ $MDO280
;	    $ENDIF					     ;;AN000;;
$MIF279:
;	  $ENDIF					     ;;AN000;;	   Yes,
$MIF278:
							     ;;
	  CMP	  BYTE PTR $M_SL.$M_S_MAXW,$M_UNLIM_W	     ;;AN000;; Is maximum width unlimited?
;	  $IF	  NE					     ;;AN000;;
	  JE $MIF286
	    CMP     BYTE PTR $M_SL.$M_S_MAXW,CL 	     ;;AN000;; Will we exceed maximum width?
;	    $IF     B					     ;;AN000;; Yes,
	    JNB $MIF287
	      SUB     CL,BYTE PTR $M_SL.$M_S_MAXW	     ;;AN000;;	 Calculate how many extra chars
	      MOV     DL,CL				     ;;AN000;;	 Remember how many chars to pop off
	      MOV     CL,BYTE PTR $M_SL.$M_S_MAXW	     ;;AN000;;	 Set new string length
;	    $ENDIF					     ;;AN000;;
$MIF287:
;	  $ENDIF					     ;;AN000;;
$MIF286:
	  OR	  CX,CX 				     ;;AN000;;
;	  $IF	  NZ					     ;;AN000;;
	  JZ $MIF290
;	    $DO 					     ;;AN000;; Begin filling buffer with string
$MDO291:
	      TEST    BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK ;;AN000;;
;	      $IF     Z,AND				     ;;AN000;;
	      JNZ $MIF292
	      TEST    $M_SL.$M_S_FLAG,Char_field_ASCIIZ AND $M_SIZE_MASK ;  Is this replace a ASCIIZ string?
;	      $IF     NZ				     ;;AN000;; Yes,
	      JZ $MIF292
		MOV	AL,BYTE PTR ES:[DI]		     ;;AN000;;	 Get first character from string
		INC	DI				     ;;AN000;;	 Next character in string
;	      $ELSE					     ;;AN000;; No,
	      JMP SHORT $MEN292
$MIF292:
		POP	AX				     ;;AN000;;	 Get character in register
;	      $ENDIF					     ;;AN000;;
$MEN292:
	      MOV     BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL      ;;AN000;;	Move char into the buffer
	      INC     BX				     ;;AN000;;	 Increase buffer count
	      CMP     BX,$M_TEMP_BUF_SZ 		     ;;AN000;;	 Is buffer full?
;	      $IF     E 				     ;;AN000;;	 Yes,
	      JNE $MIF295
		CALL	$M_FLUSH_BUF			     ;;AN000;;	   Flush the buffer
;	      $ENDIF					     ;;AN000;;
$MIF295:
	      DEC     CL				     ;;AN000;;	 Have we completed replace?
;	    $ENDDO  Z					     ;;AN000;;	   Test again
	    JNZ $MDO291
;	  $ENDIF					     ;;AN000;;
$MIF290:
							     ;;
	  TEST	  BYTE PTR $M_SL.$M_S_FLAG,Right_Align	     ;;AN000;;	 Was replaceable parm to be left aligned?
;	  $IF	  Z					     ;;AN000;; Yes,
	  JNZ $MIF299
	    OR	    DH,DH				     ;;AN000;;	 Do we need pad chars added?
;	    $IF     NZ					     ;;AN000;;	 Yes,
	    JZ $MIF300
;	      $DO					     ;;AN000;;	   Begin filling buffer with pad chars
$MDO301:
		MOV	AL,BYTE PTR $M_SL.$M_S_PAD	     ;;AN000;;
		MOV	BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL    ;;AN000;;	   Move in a pad char
		INC	BX				     ;;AN000;;
		CMP	BX,$M_TEMP_BUF_SZ		     ;;AN000;;	   Is buffer full?
;		$IF	E				     ;;AN000;;	   Yes,
		JNE $MIF302
		  CALL	  $M_FLUSH_BUF			     ;;AN000;;	     Flush the buffer
;		$ENDIF					     ;;AN000;;
$MIF302:
		DEC	DH				     ;;AN000;;	   Have we filled with enough pad chars?
;	      $ENDDO  Z 				     ;;AN000;;	     Test again
	      JNZ $MDO301
;	    $ENDIF					     ;;AN000;;
$MIF300:
;	  $ENDIF					     ;;AN000;;
$MIF299:
							     ;;
	  TEST	  BYTE PTR $M_SL.$M_S_FLAG,NOT Char_Type AND $M_TYPE_MASK ;;AN000;;
;	  $IF	  Z,AND 				     ;;AN000;;
	  JNZ $MIF307
	  TEST	  $M_SL.$M_S_FLAG,Char_field_ASCIIZ AND $M_SIZE_MASK ;;AN000;;	Is this replace a ASCIIZ string?
;	  $IF	  NZ					     ;;AN000;; Yes,
	  JZ $MIF307
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN307
$MIF307:
	    OR	    DL,DL				     ;;AN000;;
;	    $IF     NE					     ;;AN000;;
	    JE $MIF309
;	      $DO					     ;;AN000;;
$MDO310:
		POP	[$M_RT.$M_RETURN_ADDR]		     ;;AN000;;	 Clean Up stack using spare variable
		DEC	DL				     ;;AN000;;	 Are we done?
;	      $ENDDO  Z 				     ;;AN000;;
	      JNZ $MDO310
;	    $ENDIF					     ;;AN000;;
$MIF309:
;	  $ENDIF					     ;;AN000;;
$MEN307:
	  CALL	  $M_FLUSH_BUF				     ;;AN000;;	     Flush the buffer for the final time
	  PUSH	  BP					     ;;AN000;; Restore the return address
							     ;;
	  RET						     ;;AN000;;
							     ;;
$M_DISPLAY_REPLACE ENDP 				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_FLUSH_BUFFER
;;
;;	FUNCTION: Display the contents of the temporary buffer
;;	INPUTS: DI contains the number of bytes to display
;;	OUTPUTS: BX reset to zero
;;
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_FLUSH_BUF PROC NEAR					     ;;AN000;;
							     ;;
	  PUSH	  CX					     ;;AN000;; Save changed regs
	  PUSH	  ES					     ;;AN000;;
	  PUSH	  DI					     ;;AN000;;
	  PUSH	  DS					     ;;AN000;; Set ES pointing to buffer
	  POP	  ES					     ;;AN000;;
							     ;;
	  MOV	  CX,BX 				     ;;AN000;; Set number of bytes to display
	  XOR	  BX,BX 				     ;;AN000;; Reset buffer counter
	  LEA	  DI,$M_RT.$M_TEMP_BUF			     ;;AN000;; Reset buffer location pointer
	  CALL	  $M_DISPLAY_STRING			     ;;AN000;; Display the buffer
							     ;;
;	  $IF	  NC					     ;;AN000;; Error?
	  JC $MIF314
	    POP     DI					     ;;AN000;; No, Restore changed regs
	    POP     ES					     ;;AN000;;
	    POP     CX					     ;;AN000;;
;	  $ELSE 					     ;;AN000;; Yes,
	  JMP SHORT $MEN314
$MIF314:
	    ADD     SP,6				     ;;AN000;;	Fix stack
	    STC 					     ;;AN000;;
;	  $ENDIF					     ;;AN000;; Error?
$MEN314:
							     ;;
	  RET						     ;;AN000;; Return
							     ;;
$M_FLUSH_BUF ENDP					     ;;AN000;;
							     ;;
							     ;;
	  IF	  CHARmsg				     ;;AN000;; Is the request to include the code for CHAR replace?
	    $M_REPLACE =  TRUE				     ;;AN000;; Yes, THEN include it and flag that we will need common
	    $M_CHAR_ONLY = TRUE 			     ;;AN000;;	 replacement code later
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_CHAR_REPLACE
;;
;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI contains the VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;
;;	OTHER REGS Revised: AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_CHAR_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	    POP     BP					     ;;AN000;; Save return address
	    TEST    $M_SL.$M_S_FLAG,NOT Char_Field_Char AND $M_SIZE_MASK ;;AN000;; Was Character specified?
;	    $IF     Z					     ;;AN000;; Yes,
	    JNZ $MIF317
	      MOV     AL,BYTE PTR ES:[DI]		     ;;AN000;;	 Get the character
	      PUSH    AX				     ;;AN000;;	 Put it on the stack
	      INC     CX				     ;;AN000;;	 Increase the count
	      CALL    $M_IS_IT_DBCS			     ;;AN000;;	 Is this the first byte of a DB character
;	      $IF     C 				     ;;AN000;;	 Yes,
	      JNC $MIF318
		MOV	AL,BYTE PTR ES:[DI]+1		     ;;AN000;;	   Get the next character
		PUSH	AX				     ;;AN000;;	   Put it on the stack
		CLC					     ;;AN000;;	   Clear the carry
;	      $ENDIF					     ;;AN000;;
$MIF318:
;	    $ELSE					     ;;AN000;; No, it was an ASCIIZ string
	    JMP SHORT $MEN317
$MIF317:
;	      $DO					     ;;AN000;;
$MDO321:
		MOV	AL,BYTE PTR ES:[DI]		     ;;AN000;;	 Get the character
		OR	AL,AL				     ;;AN000;;	 Is it the NULL?
;	      $LEAVE  Z 				     ;;AN000;;	 No,
	      JZ $MEN321
		INC	DI				     ;;AN000;;	   Next character
		INC	CX				     ;;AN000;;	   Increment the count
;	      $ENDDO					     ;;AN000;;	 Yes,
	      JMP SHORT $MDO321
$MEN321:
	      SUB     DI,CX				     ;;AN000;;	 Set SI at the beginning of the string
;	    $ENDIF					     ;;AN000;;
$MEN317:
							     ;;AN000;;
	    PUSH    BP					     ;;AN000;; Restore return address
	    RET 					     ;;AN000;; Return
							     ;;
$M_CHAR_REPLACE ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ENDIF 					     ;;AN000;; END of include of CHAR replace code
; 
	  IF	  NUMmsg				     ;;AN000;; Is the request to include the code for NUM replace?
	    $M_REPLACE =  TRUE				     ;;AN000;; Yes, THEN include it and flag that we will need common
	    $M_CHAR_ONLY = FALSE			     ;;AN000;;	 replacement code later
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_BIN2ASC_REPLACE
;;
;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
;;		  and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI contains the VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	OTHER REGS Revised: BX,DX,AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_BIN2ASC_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	    POP     BP					     ;;AN000;; Save return address
							     ;;
	    XOR     DX,DX				     ;;AN000;; Prepare for get binary value (HIGH)
	    XOR     AX,AX				     ;;AN000;; Prepare for get binary value (LOW)
	    MOV     $M_RT.$M_DIVISOR,$M_BASE16		     ;;AN000;; Set default divisor
	    XOR     BX,BX				     ;;AN000;; Use BP as the NEG flag (if applicable)
IF	    NOT     COMR
	    TEST    $M_SL.$M_S_FLAG,NOT $M_BYTE AND $M_SIZE_MASK ;;AN000;; Was BYTE specified?
;	    $IF     Z					     ;;AN000;;
	    JNZ $MIF325
	      MOV     AL, BYTE PTR ES:[DI]		     ;;AN000;; Setup byte in AL
	      TEST    $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;	      $IF     Z 				     ;;AN000;;
	      JNZ $MIF326
		TEST	AL,10000000b			     ;;AN000;; Is this number negative?
;		$IF	NZ				     ;;AN000;;	 Yes,
		JZ $MIF327
		  INC	  BX				     ;;AN000;;	   Remember that it was negative
		  AND	  AL,01111111b			     ;;AN000;;	   Make it positive
;		$ENDIF					     ;;AN000;;
$MIF327:
		MOV	$M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MIF326:
	      TEST    $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;	      $IF     Z 				     ;;AN000;;
	      JNZ $MIF330
		MOV	$M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MIF330:
;	    $ELSE					     ;;AN000;;
	    JMP SHORT $MEN325
$MIF325:
ENDIF
	      TEST    $M_SL.$M_S_FLAG,NOT $M_WORD AND $M_SIZE_MASK ;;AN000;; Was WORD specified?
;	      $IF     Z 				     ;;AN000;;
	      JNZ $MIF333
		MOV	AX, WORD PTR ES:[DI]		     ;;AN000;; Setup byte in AL
		TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK ;; AN000;; Was Signed binary specified?
;		$IF	Z				     ;;AN000;;
		JNZ $MIF334
		  TEST	  AH,10000000b			     ;;AN000;; Is this number negative?
;		  $IF	  NZ				     ;;AN000;;	 Yes,
		  JZ $MIF335
		    INC     BX				     ;;AN000;;	   Remember that it was negative
		    AND     AH,01111111b		     ;;AN000;;	   Make it positive
;		  $ENDIF				     ;;AN000;;
$MIF335:
		  MOV	  $M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF334:
		TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;		$IF	Z				     ;;AN000;;
		JNZ $MIF338
		  MOV	  $M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF338:
;	      $ELSE					     ;;AN000;;
	      JMP SHORT $MEN333
$MIF333:
IF		NOT	COMR
		MOV	AX, WORD PTR ES:[DI]		     ;;AN000;; Setup Double word in DX:AX
		MOV	DX, WORD PTR ES:[DI]+2		     ;;AN000;;
		TEST	$M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;		$IF	Z				     ;;AN000;;
		JNZ $MIF341
		  TEST	  DH,10000000b			     ;;AN000;; Is this number negative?
;		  $IF	  NZ				     ;;AN000;;	 Yes,
		  JZ $MIF342
		    INC     BX				     ;;AN000;;	   Remember that it was negative
		    AND     DH,01111111b		     ;;AN000;;	   Make it positive
;		  $ENDIF				     ;;AN000;;
$MIF342:
		  MOV	  $M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF341:
		TEST	$M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
;		$IF	Z				     ;;AN000;;
		JNZ $MIF345
		  MOV	  $M_RT.$M_DIVISOR,$M_BASE10	     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MIF345:
ENDIF
;	      $ENDIF					     ;;AN000;;
$MEN333:
;	    $ENDIF					     ;;AN000;;
$MEN325:
							     ;;
	    CALL    $M_CONVERT2ASC			     ;;AN000;; Convert to ASCII string
IF	    NOT     COMR
	    OR	    BX,BX				     ;;AN000;;
;	    $IF     NZ					     ;;AN000;; Was number negative?
	    JZ $MIF349
	      XOR     DX,DX				     ;;AN000;; Yes,
	      MOV     DL,$M_NEG_SIGN			     ;;AN000;;	 Put "-" on the stack with the number
	      PUSH    DX				     ;;AN000;;
;	    $ENDIF					     ;;AN000;; No,
$MIF349:
ENDIF
							     ;;
	    PUSH    BP					     ;;AN000;; Restore return address
	    RET 					     ;;AN000;; Return
							     ;;
$M_BIN2ASC_REPLACE ENDP 				     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ENDIF 					     ;;AN000;; END of include of NUM replace code
; 
	  IF	  DATEmsg				     ;;AN000;; Is the request to include the code for DATE replace?
	    $M_REPLACE =  TRUE				     ;;AN000;; Yes, THEN include it and flag that we will need common
	    $M_CHAR_ONLY = FALSE			     ;;AN000;;	  replacement code later
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DATE_REPLACE
;;
;;	FUNCTION: Convert a date to a decimal ASCII string using current
;;		  country format and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI points at VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	OTHER REGS Revised: DX, AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_DATE_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	    POP     BP					     ;;AN000;; Save return address
	    MOV     $M_RT.$M_DIVISOR,$M_BASE10		     ;;AN000;; Set default divisor
	    CALL    $M_GET_DATE 			     ;;AN000;; Set date format/separator in $M_RT
							     ;;AN000;; All O.K.?
	    XOR     DX,DX				     ;;AN000;; Reset DX value
	    XOR     AX,AX				     ;;AN000;; Reset AX value
	    CMP     WORD PTR $M_RT.$M_DATE_FORMAT,0	     ;;AN000;; USA Date Format
;	    $IF     E					     ;;AN000;;	Beginning from end: (saved on the stack)
	    JNE $MIF351
	      CALL    $M_YEAR				     ;;AN000;;	 Get Year
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;; Increment count
	      XOR     AX,AX				     ;;AN000;; Reset AX value
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+3	     ;;AN000;;	Get Day
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;; Increment count
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+2	     ;;AN000;;	Get Month
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
;	    $ENDIF					     ;;AN000;;
$MIF351:
							     ;;
	    CMP     WORD PTR $M_RT.$M_DATE_FORMAT,1	     ;;AN000;; EUROPE Date Format
;	    $IF     E					     ;;AN000;;	Beginning from end: (saved on the stack)
	    JNE $MIF353
	      CALL    $M_YEAR				     ;;AN000;;	 Get Year
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
	      XOR     AX,AX				     ;;AN000;; Reset AX
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+2	     ;;AN000;;	Get Month
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+3	     ;;AN000;;	Get Day
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
;	    $ENDIF					     ;;AN000;;
$MIF353:
							     ;;
	    CMP     WORD PTR $M_RT.$M_DATE_FORMAT,2	     ;;AN000;; JAPAN Date Format
;	    $IF     E					     ;;AN000;;	Beginning from end: (saved on the stack)
	    JNE $MIF355
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+3	     ;;AN000;;	Get Day
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+2	     ;;AN000;;	Get Month
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
	      PUSH    WORD PTR $M_RT.$M_DATE_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
	      CALL    $M_YEAR				     ;;AN000;;	 Get Year
	      CALL    $M_CONVERTDATE			     ;;AN000;;	Convert it to an ASCII string
;	    $ENDIF					     ;;AN000;;
$MIF355:
							     ;;
	    PUSH    BP					     ;;AN000;; Restore return address
	    RET 					     ;;AN000;; Return
							     ;;
$M_DATE_REPLACE ENDP					     ;;AN000;;
							     ;;
$M_GET_DATE PROC    NEAR				     ;;AN000;;
	    MOV     AH,DOS_GET_COUNTRY			     ;;AN000;; Call DOS for country dependant info
	    MOV     AL,0				     ;;AN000;; Get current country info
	    LEA     DX,$M_RT.$M_TEMP_BUF		     ;;AN000;; Set up addressibility to buffer
	    INT     21H 				     ;;AN000;;
;	    $IF     C					     ;;AN000;; No,
	    JNC $MIF357
	      MOV     WORD PTR $M_RT.$M_DATE_FORMAT,$M_DEF_DATE_FORM ;;AN000;;	 Set default date format    (BH)
	      MOV     BYTE PTR $M_RT.$M_DATE_SEPARA,$M_DEF_DATE_SEP ;;AN000;;	Set default date separator (BL)
;	    $ENDIF					     ;;AN000;;
$MIF357:
	    RET 					     ;;AN000;;
$M_GET_DATE ENDP					     ;;AN000;;
							     ;;
$M_YEAR     PROC    NEAR				     ;;AN000;;
	    MOV     AX,WORD PTR $M_SL.$M_S_VALUE	     ;;AN000;;	Get Year
	    TEST    $M_SL.$M_S_FLAG,Date_MDY_4 AND $M_DATE_MASK ;;AN000;; Was Month/Day/Year (2 Digits) specified?
;	    $IF     Z					     ;;AN000;;
	    JNZ $MIF359
	      CMP     AX,$M_MAX_2_YEAR			     ;;AN000;;	Get Year
;	      $IF     A 				     ;;AN000;;
	      JNA $MIF360
		MOV	AX,$M_MAX_2_YEAR		     ;;AN000;;
;	      $ENDIF					     ;;AN000;;
$MIF360:
;	    $ENDIF					     ;;AN000;;
$MIF359:
	    RET 					     ;;AN000;;
$M_YEAR     ENDP					     ;;AN000;;
							     ;;
$M_CONVERTDATE PROC NEAR				     ;;AN000;;
	    POP     WORD PTR $M_RT.$M_TEMP_BUF		     ;;AN000;; Save return address
	    MOV     $M_RT.$M_SIZE,CL			     ;;AN000;; Save the size before conversion
	    CALL    $M_CONVERT2ASC			     ;;AN000;; Convert it to an ASCII string
	    DEC     CX					     ;;AN000;; Test if size only grew by 1
	    CMP     CL,$M_RT.$M_SIZE			     ;;AN000;; Did size only grow by one
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF363
	      MOV     AX,$M_TIMEDATE_PAD		     ;;AN000;;	 Get a pad character (0)
	      PUSH    AX				     ;;AN000;;	 Save it
	      INC     CX				     ;;AN000;;	 Count it
;	    $ENDIF					     ;;AN000;;
$MIF363:
	    INC     CX					     ;;AN000;; Restore CX
	    PUSH    WORD PTR $M_RT.$M_TEMP_BUF		     ;;AN000;; Save return address
	    RET 					     ;;AN000;;
$M_CONVERTDATE ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ENDIF 					     ;;AN000;; END of include of DATE replace code
; 
	  IF	  TIMEmsg				     ;;AN000;; Is the request to include the code for TIME replace?
	    $M_REPLACE =  TRUE				     ;;AN000;; Yes, THEN include it and flag that we will need common
	    $M_CHAR_ONLY = FALSE			     ;;AN000;;	  replacement code later
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_TIME_REPLACE
;;
;;	FUNCTION: Convert a time to a decimal ASCII string
;;		  and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI points at VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	REGS USED: BP,CX,AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_TIME_REPLACE PROC NEAR				     ;;AN000;;
							     ;;
	    POP     BP					     ;;AN000;; Save return address
	    MOV     $M_RT.$M_DIVISOR,$M_BASE10		     ;;AN000;; Set default divisor
	    CALL    $M_GET_TIME 			     ;;AN000;; All O.K.?
	    TEST    $M_SL.$M_S_FLAG,Time_Cty_Type AND $M_TIME_MASK ;;AN000;; Is this a request for current country info?
;	    $IF     NZ					     ;;AN000;; Yes,
	    JZ $MIF365
	      CMP     BYTE PTR $M_RT.$M_TIME_FORMAT,0	     ;;AN000;; Is the current country format 12 Hour?
;	      $IF     E 				     ;;AN000;; Yes,
	      JNE $MIF366
		MOV	AL,BYTE PTR $M_SL.$M_S_VALUE	     ;;AN000;;	Get Hours
		CMP	AL,12				     ;;AN000;;	Is hour 12 or less?
;		$IF	L,OR				     ;;AN000;;	 or
		JL $MLL367
		CMP	AL,23				     ;;AN000;;	  Is hour 24 or greater?
;		$IF	G				     ;;AN000;;	Yes,
		JNG $MIF367
$MLL367:
		  MOV	  AL,$M_AM			     ;;AN000;;
		  PUSH	  AX				     ;;AN000;;	  Push an "a" to represent AM.
		  INC	  CX				     ;;AN000;;
;		$ELSE					     ;;AN000;;	No,
		JMP SHORT $MEN367
$MIF367:
		  MOV	  AL,$M_PM			     ;;AN000;;
		  PUSH	  AX				     ;;AN000;;	  Push an "p" to represent PM.
		  INC	  CX				     ;;AN000;;
;		$ENDIF					     ;;AN000;;
$MEN367:
;	      $ENDIF					     ;;AN000;;
$MIF366:
;	    $ENDIF					     ;;AN000;;
$MIF365:
							     ;;
	    XOR     AX,AX				     ;;AN000;;
	    XOR     DX,DX				     ;;AN000;;
	    TEST    $M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty AND $M_SIZE_MASK ;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
;	    $IF     NZ					     ;;AN000;;
	    JZ $MIF372
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+3	     ;;AN000;;	Get Hundreds
	      CALL    $M_CONVERTTIME			     ;;AN000;;
	      PUSH    WORD PTR $M_RT.$M_DECI_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MIF372:
	    TEST    $M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty AND $M_SIZE_MASK ;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
;	    $IF     NZ,OR				     ;;AN000;;
	    JNZ $MLL374
	    TEST    $M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK ;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
;	    $IF     NZ					     ;;AN000;;
	    JZ $MIF374
$MLL374:
	      MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+2	     ;;AN000;;	Get Seconds
	      CALL    $M_CONVERTTIME			     ;;AN000;;
	      PUSH    WORD PTR $M_RT.$M_TIME_SEPARA	     ;;AN000;;
	      INC     CX				     ;;AN000;;
;	    $ENDIF					     ;;AN000;;
$MIF374:
							     ;;        Do Hour/Min (12 Hour)
	    MOV     AL,BYTE PTR $M_SL.$M_S_VALUE+1	     ;;AN000;;	Get Minutes
	    CALL    $M_CONVERTTIME			     ;;AN000;;
	    PUSH    WORD PTR $M_RT.$M_TIME_SEPARA	     ;;AN000;;
	    INC     CX					     ;;AN000;;
							     ;;
	    MOV     AL,BYTE PTR $M_SL.$M_S_VALUE	     ;;AN000;;	Get Hours
	    TEST    $M_SL.$M_S_FLAG,Time_Cty_Type AND $M_TIME_MASK ;;AN000;; Is this a request for current country info?
;	    $IF     NZ					     ;;AN000;; Yes,
	    JZ $MIF376
	      CMP     BYTE PTR $M_RT.$M_TIME_FORMAT,0	     ;;AN000;; Is the current country format 12 Hour?
;	      $IF     E 				     ;;AN000;; Yes,
	      JNE $MIF377
		CMP	AL,13				     ;;AN000;;	Is hour less than 12?
;		$IF	GE				     ;;AN000;;	Yes,
		JNGE $MIF378
		  SUB	  AL,12 			     ;;AN000;;	  Set to a 12 hour value
;		$ENDIF					     ;;AN000;;
$MIF378:
		CMP	AL,0				     ;;AN000;;	Is hour less than 12?
;		$IF	E				     ;;AN000;;	Yes,
		JNE $MIF380
		  MOV	  AL,12 			     ;;AN000;;	  Set to a 12 hour value
;		$ENDIF					     ;;AN000;;
$MIF380:
;	      $ENDIF					     ;;AN000;;
$MIF377:
;	    $ENDIF					     ;;AN000;;
$MIF376:
	    CALL    $M_CONVERT2ASC			     ;;AN000;; Convert it to ASCII
							     ;;
	    PUSH    BP					     ;;AN000;; Restore return address
	    RET 					     ;;AN000;; Return
							     ;;
$M_TIME_REPLACE ENDP					     ;;AN000;;
							     ;;
$M_GET_TIME PROC    NEAR				     ;;AN000;;
	    MOV     AH,DOS_GET_COUNTRY			     ;;AN000;; Call DOS for country dependant info
	    MOV     AL,0				     ;;AN000;; Get current country info
	    LEA     DX,$M_RT.$M_TEMP_BUF		     ;;AN000;; Set up addressibility to buffer
	    INT     21H 				     ;;AN000;;
;	    $IF     C					     ;;AN000;; No,
	    JNC $MIF384
	      MOV     WORD PTR $M_RT.$M_TIME_FORMAT,$M_DEF_TIME_FORM ;;AN000;;	 Set default time format    (BH)
	      MOV     BYTE PTR $M_RT.$M_TIME_SEPARA,$M_DEF_TIME_SEP ;;AN000;;	Set default time separator (BL)
	      MOV     BYTE PTR $M_RT.$M_DECI_SEPARA,$M_DEF_DECI_SEP ;;AN000;;	Set default time separator (BL)
;	    $ENDIF					     ;;AN000;;
$MIF384:
	    RET 					     ;;AN000;;
$M_GET_TIME ENDP					     ;;AN000;;
							     ;;
$M_CONVERTTIME PROC NEAR				     ;;AN000;;
	    POP     WORD PTR $M_RT.$M_TEMP_BUF		     ;;AN000;; Save return address
	    MOV     $M_RT.$M_SIZE,CL			     ;;AN000;; Save the size before conversion
	    CALL    $M_CONVERT2ASC			     ;;AN000;; Convert it to an ASCII string
	    DEC     CX					     ;;AN000;; Test if size only grew by 1
	    CMP     CL,$M_RT.$M_SIZE			     ;;AN000;; Did size only grow by one
;	    $IF     E					     ;;AN000;; Yes,
	    JNE $MIF386
	      MOV     AX,$M_TIMEDATE_PAD		     ;;AN000;;	 Get a pad character (0)
	      PUSH    AX				     ;;AN000;;	 Save it
	      INC     CX				     ;;AN000;;	 Count it
;	    $ENDIF					     ;;AN000;;
$MIF386:
	    INC     CX					     ;;AN000;; Restore CX
	    PUSH    WORD PTR $M_RT.$M_TEMP_BUF		     ;;AN000;; Save return address
	    RET 					     ;;AN000;;
$M_CONVERTTIME ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	  ENDIF 					     ;;AN000;; END of include of TIME replace
	ENDIF						     ;;AN000;; END of include of Replacement common code
; 
	IF	INPUTmsg				     ;;AN000;; Is the request to include the code for NUM replace?
	  INPUTmsg =	FALSE				     ;;AN000;; Yes, THEN include it and reset the flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_WAIT_FOR_INPUT
;;
;;	FUNCTION:  To accept keyed input and return extended key value
;;		   in AX register
;;	INPUTS:    DL contains the DOS function requested for input
;;	OUPUTS:    AX contains the extended key value that was read
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							     ;;
$M_WAIT_FOR_INPUT PROC NEAR				     ;;AN000;;
							     ;;
	  PUSH	  CX					     ;;AN000;; Save CX
	  PUSH	  DX					     ;;AN000;; Save DX
	  PUSH	  DS					     ;;AN000;; Save Data segment
							     ;;
	  CMP	  DL,DOS_CLR_KEYB_BUF_MASK		     ;;AN001;; Are we to clear the keyboard buffer?
;	  $IF	  A					     ;;AN001;; Yes,
	  JNA $MIF388
	    MOV     AL,DL				     ;;AN001;;	 Mov function into AL
	    AND     AL,LOW_NIB_MASK			     ;;AN001;;	 Mask out the C in high nibble
	    MOV     AH,DOS_CLR_KEYB_BUF 		     ;;AN001;;	 Set input function
;	  $ELSE 					     ;;AN001;; No,
	  JMP SHORT $MEN388
$MIF388:
	    MOV     AH,DL				     ;;AN000;;	 Put DOS function in AH
;	  $ENDIF					     ;;AN001;;
$MEN388:
	  PUSH	  ES					     ;;AN000;; Get output buffer segment
	  POP	  DS					     ;;AN000;;
	  MOV	  DX,DI 				     ;;AN000;;	 Get output buffer offset in case needed
	  INT	  21H					     ;;AN000;; Get keyboard input
	  POP	  DS					     ;;AN000;;

	  CMP	  DL,DOS_BUF_KEYB_INP			     ;;AN000;;
	  CLC						     ;;AN000;;
;	  $IF	  NE					     ;;AN000;; If character input
	  JE $MIF391
	    CALL    $M_IS_IT_DBCS			     ;;AN000;;	Is this character DBCS?
;	    $IF     C					     ;;AN000;;
	    JNC $MIF392
	      MOV     CL,AL				     ;;AN000;; Save first character
	      MOV     AH,DL				     ;;AN001;; Get back function
	      INT     21H				     ;;AN000;; Get keyboard input
	      MOV     AH,CL				     ;;AN000;; Retreive first character  AX = xxxx
	      CLC					     ;;AN000;; Clear carry condition
;	    $ELSE					     ;;AN000;;
	    JMP SHORT $MEN392
$MIF392:
	      MOV     AH,0				     ;;AN000;; AX = 00xx where xx is SBCS
;	    $ENDIF					     ;;AN000;;
$MEN392:
;	  $ENDIF					     ;;AN000;;
$MIF391:
							     ;;
;	  $IF	  NC					     ;;AN000;;
	  JC $MIF396
	    POP     DX					     ;;AN000;;
	    POP     CX					     ;;AN000;;
;	  $ELSE 					     ;;AN000;;
	  JMP SHORT $MEN396
$MIF396:
	    ADD     SP,4				     ;;AN000;;
	    STC 					     ;;AN000;; Reset carry flag
;	  $ENDIF					     ;;AN000;;
$MEN396:
	  RET						     ;;AN000;; Return
							     ;;
$M_WAIT_FOR_INPUT ENDP					     ;;AN000;;
							     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ENDIF						     ;;AN000;; END of include of Wait for Input
      ENDIF						     ;;AN000;; END of include of SYSDISPMSG
    ENDIF						     ;;AN000;; END of include of MSG_DATA_ONLY
ENDIF							     ;;AN000;; END of include of Structure only
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\pcinput.inc ===
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; Source...: PCINPUT.INC						      :
; Created..: 01-01-82							      :
; Standards: 01-07-86							      :
; Revised..: 11-17-87							      :
; Version..: PC DOS							      :
; Called as: FAR, NEAR or INT						      :
; Public as: INPUT							      :
;									      :
;-----------------------------------------------------------------------------+
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; DEFAULT								      :
;									      :
;	  Performs the following functions:				      :
;									      :
;	  - Initializes pointers and counters				      :
;	  - Initializes input buffer with default value (from screen or strg) :
;	  - Set options and display input buffer as default on screen	      :
;	  - Display field delimiters					      :
;	  - Display minus or plus sign					      :
;									      :
;									      :
; Entry:  ES:SI        = Points to current ICB				      :
;	  DS:DI        = Points to PB					      :
;									      :
;	  WR_CURSIZE   = Current cursor size				      :
;									      :
; Exit:   Default displayed						      :
;									      :
;-----------------------------------------------------------------------------+
;
DEFAULT        PROC NEAR
;
; Initialize input buffer with default buffer
;
	       PUSH BP
	       PUSH ES			     ;save registers
	       PUSH DS
	       PUSH DI
	       PUSH SI
;
	       MOV  DX,ES:[SI]+ICB_FIELDLEN  ;save for later				 ;=W
	       MOV  BX,ES:[SI]+ICB_DEFLEN    ;save for later				 ;=W
;
	       MOV  AX,ES:[SI]+ICB_DEFSEG    ;get source string segment 		 ;=W
	       MOV  DS,AX								 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDOFF  ;get destination offset			 ;=W
	       MOV  DI,AX								 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDSEG  ;get destination segment			 ;=W
	       MOV  CX,ES:[SI]+ICB_DEFOFF    ;get source string offset			 ;=W
	       MOV  SI,CX								 ;=W
	       MOV  ES,AX								 ;=W
;
	       PUSH DI
	       MOV  CX,DX		     ;clear input buffer			 ;=W
	       MOV  AL,WR_SPACE 							 ;=W
	       CLD									 ;=W
	       REP  STOSB								 ;=W
	       POP  DI
;											 ;=W
	       MOV  BP,0
	       MOV  CX,BX		     ;initialize number of bytes in		 ;=W
					     ; default string
	       CMP  CX,DX		     ;check if default string is
	       JBE  DEF10		     ; longer than input buffer
;
	       MOV  CX,DX		     ;error set to input buffer leng
	       MOV  BP,ICB_STRU 	     ;set error indicating default was
					     ; truncated
DEF10:
	       CLD
	       REP  MOVSB		     ;move default into input buffer
;
	       POP  SI			     ;restore registers
	       POP  DI
	       POP  DS
	       POP  ES
;
	       OR   ES:[SI]+ICB_STATUS,BP    ;save error status
	       POP  BP
;
; Calculate row and column of input field and set the desired display attribute
;
	       MOV  AX,ES:[SI]+ICB_ROW	     ;get input field row
	       MOV  [DI]+CR_ROW,AX
;
	       MOV  AX,ES:[SI]+ICB_COL	     ;get input field column
	       MOV  [DI]+CR_COL,AX
;
	       CALL PCROWCL_CALL	     ;calculate row and column info
					     ; return CR_RCOFF and CR_BEGROWOFF
	       MOV  AL,[DI]+WR_EATTR	     ;set the entry attribute to the
	       MOV  [DI]+WR_CATTR,AL	     ; current attribute
;
; Initialize variables for left justified field
;
	       TEST ES:[SI]+ICB_OPT1,ICB_RJU ;check if right justified
	       JNE  DEF20
;
	       MOV  [DI]+WR_LEFTCHAR,1	     ;set left character marker to
					     ;beginning of input field
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get max field length			 ;=W
;
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;check if horizontal scrolling		 ;=W
	       JE   DEF15		     ;no					 ;=W
	       MOV  AX,ES:[SI]+ICB_WIDTH     ;get field width for horizontal scrolling	 ;=W
					     ;because we only show a windowful of field  ;=W
DEF15:											 ;=W
	       MOV  [DI]+WR_RIGHTCHAR,AX     ;set ptr to rightmost character		 ;=W
	       CALL CAL_COORS		     ;get end of field char, byte		 ;=W
	       JMP  DEF30		     ;and next byte positions
;
; Initialize variables for right justified field
;
DEF20:	       ;
	       ; code here
	       ;
;
; Display default even if password option is active
;
DEF30:	       PUSH ES:[SI]+ICB_OPT1	     ;save option word
;
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active
	       JE   DEF40
;
	       AND  ES:[SI]+ICB_OPT1,NOT ICB_PSW
					     ;set option word to force disp
					     ; of default value
DEF40:
	       MOV  AX,2		     ;set option to actually display
	       CALL WORD PTR [DI]+WR_DISPLAY ; default value in proper
					     ; justification
	       POP  ES:[SI]+ICB_OPT1	     ;restore original password
;
; Display initial cursor in proper size and location
;
	       MOV  AX,[DI]+IN_CURNOR	     ;set cursor size for replace
	       MOV  [DI]+WR_CURSIZE,AX
;
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS
	       JE   DEF45		     ;check if insert is active
;
	       MOV  AX,[DI]+IN_CURINS	     ;set cursor size for insert
	       MOV  [DI]+WR_CURSIZE,AX
;
DEF45:
	       CALL CAL_COORS		     ;calculate coordinates			 ;=W
	       CALL CURSOR		     ;initialize cursor size and locat
;
; Determine if characters in input buffer are allowonce chars and set flags
;

    jmp  Def65	 ;temp until bug in allowonce scan fixed

	       PUSH ES			     ;save registers
	       PUSH SI
;
	       MOV  BX,ES		     ;set segment of ICB
	       MOV  DX,SI		     ;set offset of ICB
;
	       MOV  CX,ES:[SI]+ICB_FIELDLEN  ;get field length
;
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get field offset
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get field segment
	       POP  ES
	       POP  SI
;
DEF50:	       MOV  AL,ES:[SI]		     ;get character from input buffer
	       MOV  [DI]+DBC_KS,AL	     ; and set to PCINDBC PB
;
	       INC  SI			     ;point to next byte
;
	       CALL PCINDBC_CALL	     ;call PCINDBC

	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if keystroke double byte
	       JE   DEF60
;
	       CMP  CX,0		     ;if last loop is double character
	       JBE  DEF60		     ; and is missing trailing byte
					     ; then, consider a single byte
;
	       MOV  AH,ES:[SI]		     ;get character from input buffer
	       MOV  [DI]+DBC_KS,AH	     ; and set to PCINDBC PB
	       INC  SI			     ;point to next byte
	       DEC  CX			     ;adjust loop pointer for additial
					     ; character read (double byte)
;
DEF60:	       PUSH ES			     ;save registers
	       PUSH SI
;
	       MOV  ES,BX		     ;load ICB
	       MOV  SI,DX
;
	       CALL ON_ALLOWONCE	     ;Scan the allowonce string for
					     ; the character in AX and set flag
					     ; if found
	       POP  SI			     ;restore registers
	       POP  ES
;
	       LOOP DEF50		     ;get next keystroke
;
	       POP  SI			     ;restore registers
	       POP  ES
;
; Display field delimiters
;
DEF65:											 ;=W
	       MOV  AX,01		     ;assume "[ ]" as delimiters                 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_BEN ;display entry delimiters			 ;=W
	       JE   DEF100		     ;no, leave 				 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_OPT3,ICB_WIN ;does field use windowing			 ;=W
	       JE   DEF70		     ;no, check others				 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_BOX ;check if delimiter = box			 ;=W
	       JE   DEF90		     ;no, display normal delimiters		 ;=W
;											 ;=W
	       MOV  AX,06		     ;display box				 ;=W
	       JMP  DEF90		     ;done with delimiters			 ;=W
DEF70:											 ;=W
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;does field use horiz. window		 ;=W
	       JE   DEF80								 ;=W
;											 ;=W
	       MOV  AX,03		     ;display "[ >"                              ;=W
	       CMP  ES:[SI]+ICB_HRSTART,01H  ;are we at beginning of window ?		 ;=W
	       JLE  DEF80		     ;yes					 ;=W
;
	       MOV  AX,04		     ;no, display "< >"                          ;=W
DEF80:											 ;=W
	       CALL DELIMITER		     ;do it					 ;=W
;
	       TEST ES:[SI]+ICB_OPT1,ICB_BOX ;check if also need box			 ;=W
	       JE   DEF100								 ;=W
;											 ;=W
	       MOV  AX,06		     ;display box				 ;=W
DEF90:											 ;=W
	       CALL DELIMITER		     ;do it					 ;=W
;
; Display minus or plus sign if active
;
DEF100:
	       TEST ES:[SI]+ICB_OPT1,ICB_MUS ;Check if minus/plus sign
	       JE   DEFEXIT		     ; display option is active
;
	       MOV  [DI]+WR_KEYCONF,0	     ;initialize to plus sign key
;
	       TEST ES:[SI]+ICB_OPT1,ICB_SMU ;Check if default is negative
	       JE   DEF110
;
	       OR   [DI]+WR_KEYCONF,WR_MUS   ;initialize to minus sign key
;
DEF110:        CALL PLUS_MINUS		     ;display plus or minus sign and
					     ; set status
;
DEFEXIT:				     ;continue
;
	       RET
DEFAULT        ENDP
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; PRE_EXIT								      :
;									      :
;	  Performs the following functions:				      :
;									      :
;	  - Removes field delimiters					      :
;	  - Inserts commas as specified 				      :
;	  - Inserts decimal point as specified				      :
;	  - Adjusts field to specified significant digits		      :
;	  - Displays buffer contents in exit color			      :
;	  - Checks if original default has changed			      :
;	  - Check if entry is in specified numeric range		      :
;	  - Sets minus or plus sign indicator in exit color		      :
;	  - Remove thousand separators from input string buffer 	      :
;	  - Restore original cursor position and size, only in text mode      :
;									      :
; Entry:  ES:SI        = Points to current ICB				      :
;	  DS:DI        = Points to PB					      :
;									      :
; Exit:   None								      :
;									      :
;-----------------------------------------------------------------------------+
;
PRE_EXIT       PROC NEAR

;
; Inserts commas as specified
;
	       ;
	       ; Code here
	       ;
;
; Inserts decimal point as specified
;
	       ;
	       ; Code here
	       ;
;
; Adjusts field to specified significant digits
;
	       ;
	       ; Code here
	       ;
;
; Calculate color attribute of exit colors
;
	       TEST ES:[SI]+ICB_OPT1,ICB_XCL ;check if option to use exit
	       JE   PRE10		     ; colors is active
;
	       MOV  AL,[DI]+WR_XATTR	     ;set the exit attribute to the
	       MOV  [DI]+WR_CATTR,AL	     ; current attribute
;
; Display default value of input buffer in proper justification
;
PRE10:	       MOV  [DI]+WR_LEFTCHAR,1	     ;set left character
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set right marker
;
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;horizontal scrolling mode ?		 ;=W
	       JE   PRE15		     ;no, display all buffer			 ;=W
	       MOV  AX,ES:[SI]+ICB_WIDTH     ;use width instead of all buffer		 ;=W
PRE15:
	       MOV  [DI]+WR_RIGHTCHAR,AX
;
	       MOV  AX,2		     ;set option to actually display
	       CALL WORD PTR [DI]+WR_DISPLAY ; default value in proper
;					     ; justification
; Process minus/plus key options
;
	       TEST ES:[SI]+ICB_OPT1,ICB_MUS ;Check if minus/plus sign
	       JE   PRE40		     ; display option is active
;
	       MOV [DI]+WR_KEYCONF,0	     ;initialize to plus sign
;
	       TEST ES:[SI]+ICB_STATUS,ICB_SMUS
	       JE   PRE20		     ;Check if sign is negative
;
	       OR   [DI]+WR_KEYCONF,WR_MUS   ;initialize to minus sign key
;
PRE20:	       TEST ES:[SI]+ICB_STATUS,ICB_SPUS
	       JE   PRE30		     ;Check if sign is positive
;
	       OR   [DI]+WR_KEYCONF,WR_PUS   ;initialize to plus sign key
;
PRE30:	       CALL PLUS_MINUS		     ;display plus or minus sign
					     ; according to WR_KEYCONF setting
;
; Replace field entry delimiters with exit delimiters
;
PRE40:	       TEST ES:[SI]+ICB_OPT1,ICB_BEX ;check if field delimiters
	       JE   PRE60		     ; should be displayed on exit
;
	       MOV  AX,2		     ;option to remove delimiters
	       CALL DELIMITER		     ;display delimiters
;
	       TEST ES:[SI]+ICB_OPT1,ICB_BOX ;check if box around field
	       JE   PRE60		     ; should be displayed
;
	       MOV  AX,7		     ;set option to remove box
	       CALL DELIMITER		     ;display delimiters
;
; Check if default value has changed and set return flag
;
PRE60:	       PUSH DS			     ;save registers
	       PUSH SI
	       PUSH ES
	       PUSH DI
;
	       MOV  CX,ES:[SI]+ICB_DEFLEN    ;initialize to default length
	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;check if default length is less
	       JBE  PRE70		     ; than field length
;
	       MOV  CX,ES:[SI]+ICB_FIELDLEN  ;initialize to field length
;
PRE70:	       MOV  AX,ES:[SI]+ICB_DEFSEG    ;compare default string to 		 ;=W
	       MOV  DS,AX								 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDOFF						 ;=W
	       MOV  DI,AX								 ;=W
;
	       MOV  AX,ES:[SI]+ICB_DEFOFF    ;	current input string			 ;=W
	       MOV  BX,ES:[SI]+ICB_FIELDSEG						 ;=W
	       MOV  ES,BX								 ;=W
	       MOV  SI,AX								 ;=W
;
	       REPE CMPSB		     ;compare default and input strings
;
	       POP  DI			     ;restore registers
	       POP  ES
	       POP  SI
	       POP  DS
;
	       CMP  CX,0		     ;are we done ?				 ;=W
	       JE   PRE80		     ;check if strings compared
;
	       OR   ES:[SI]+ICB_STATUS,ICB_SDEF
					     ;set flag that default changed
;
; Check if entry is within specified numeric range, if not set flag
;
PRE80:	       ;
	       ; code here
	       ;
;
; Remove thousand separators if specified from input string buffer
;
PRE90:	       ;
	       ; code here
	       ;
;
; Restore original cursor position and size
;
PRE95:
	       TEST ES:[SI]+ICB_STATUS,ICB_CUR_ON  ;is cursor on ?
	       JE   PRE100			   ;no, quit
	       CALL CURSOR		     ;erase the graphics cursor
PRE100:
	       OR   ES:[SI]+ICB_STATUS,ICB_DONE ;exit condition found, exit		 ;=W
;											 ;=W
; Check if ICB_SAV option selected. If selected, then save contents of the		 ;=W
; input buffer to the default buffer.							 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_OPT4,ICB_SAV ;check ?					 ;=W
	       JE   PRE200		     ;no, exit now				 ;=W
;											 ;=W
	       PUSH ES			     ;save registers				 ;=W
	       PUSH DS									 ;=W
	       PUSH DI									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  CX,ES:[SI]+ICB_ENDBYTE   ;# of bytes to copy from input		 ;=W
					     ; buffer to default buffer 		 ;=W
	       MOV  ES:[SI]+ICB_DEFLEN,CX    ;reset default length
;
	       MOV  AX,ES:[SI]+ICB_FIELDSEG  ;get destination segment			 ;=W
	       MOV  DS,AX								 ;=W
;											 ;=W
	       MOV  AX,ES:[SI]+ICB_DEFOFF    ;get source string offset			 ;=W
	       MOV  DI,AX								 ;=W
;											 ;=W
	       MOV  AX,ES:[SI]+ICB_DEFSEG    ;get source string segment 		 ;=W
	       MOV  BX,ES:[SI]+ICB_FIELDOFF  ;get destination offset			 ;=W
	       MOV  SI,BX								 ;=W
	       MOV  ES,AX								 ;=W
;											 ;=W
	       CLD									 ;=W
	       REP  MOVSB		     ;move default into input buffer		 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  DI									 ;=W
	       POP  DS									 ;=W
	       POP  ES									 ;=W
PRE200: 										 ;=W
	       RET
PRE_EXIT       ENDP
;											 ;=W
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; RIGHT_H_JUST								      : 	 ;=W
;									      : 	 ;=W
;	  Process keystroke and update display with input buffer changes      : 	 ;=W
;	  for the following functions:					      : 	 ;=W
;									      : 	 ;=W
;	  Home key	  Up arrow	  Allowonce replace mode	      : 	 ;=W
;	  End key	  Down arrow	  Allowonce insert mode 	      : 	 ;=W
;	  Left arrow	  Control end	  Allow replace mode		      : 	 ;=W
;	  Right arrow	  Delete key	  Allow insert mode		      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
RIGHT_H_JUST   PROC NEAR								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; code here								 ;=W
	       ;									 ;=W
;											 ;=W
	       RET									 ;=W
RIGHT_H_JUST   ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; RIGHT_JUST								      :
;									      :
;	  Process keystroke and update display with input buffer changes      :
;	  for the following functions:					      :
;									      :
;	  Home key	  Up arrow	  Allowonce replace mode	      :
;	  End key	  Down arrow	  Allowonce insert mode 	      :
;	  Left arrow	  Control end	  Allow replace mode		      :
;	  Right arrow	  Delete key	  Allow insert mode		      :
;									      :
;-----------------------------------------------------------------------------+
;
RIGHT_JUST     PROC NEAR
;
	       ;
	       ; code here
	       ;
;
	       RET
RIGHT_JUST     ENDP
;											 ;=W
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; LEFT_H_JUST								      : 	 ;=W
;									      : 	 ;=W
;	  Process keystroke and update display with input buffer changes      : 	 ;=W
;	  for the following functions:					      : 	 ;=W
;									      : 	 ;=W
;	  Home key	  Up arrow	  Allowonce replace mode	      : 	 ;=W
;	  End key	  Down arrow	  Allowonce insert mode 	      : 	 ;=W
;	  Left arrow	  Control end	  Allow replace mode		      : 	 ;=W
;	  Right arrow	  Delete key	  Allow insert mode		      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	  Following information is used:				      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      : 	 ;=W
;	    				   buffer in memory.		      : 	 ;=W
;	    								      : 	 ;=W
;	    		 (WR_CUBYTE)	 Byte offset into the input buffer    : 	 ;=W
;	    				 of where characters will be added    : 	 ;=W
;	    				 to input buffer.		      : 	 ;=W
;	    								      : 	 ;=W
;	  Ŀ	      : 	 ;=W
;	   S  L  T  L  T  S  S                      	      : 	 ;=W
;	  	      : 	 ;=W
;	    	      : 	 ;=W
;				     					      : 	 ;=W
;		 (ICB_FIELDLEN) Length of input field in bytes. 	      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	  The following demonstrates the before and after input buffer	      : 	 ;=W
;	  images.  (S = Single byte, L = DBCS lead byte, T = DBCS trailing    : 	 ;=W
;	  byte) 							      : 	 ;=W
;									      : 	 ;=W
;	  Deleting a double byte:					      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  S 	   	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Deleting a single byte:					      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  S  L  T     S  L  T  L  T    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Backspace removal of a double byte:				      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  S 	   	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Backspace removal of a single byte:				      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  S  S  S  L  T     S  S  S  L  T    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a double byte with a double byte:			      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  L  T  S 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a double byte with a single byte: (Option 1)	      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  S  S    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a double byte with a single byte: (Option 2)	      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  S 	 S 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a single byte with a single byte:			      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  S  L  T     S  L  T  S  L  T 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a single byte with a double byte.			      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  S    	    S  L  T  L  T    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Replacing a single byte with a double byte without enough buffer:   : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  S  L  T     S  L  T  S  L  T 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Inserting a single byte.					      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  L  T 	    S  L  T  S  L  T 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Inserting a single byte without enough buffer generate an error:    : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  L  T  S     S  L  T  L  T  S 	      : 	 ;=W
;		   	      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  S  S 	    S  L  T  S  S    	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;	  Inserting a double byte character:				      : 	 ;=W
;		Ŀ   Ŀ	      : 	 ;=W
;		 S  L  T  S    	    S  L  T  L  T  S 	      : 	 ;=W
;		   	      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; Entry:  ES:SI       = Points to current ICB				      : 	 ;=W
;	  DS:DI       = Points to PB					      : 	 ;=W
;									      : 	 ;=W
;	  INC_KS      = Keystroke from returned from PCINCHA		      : 	 ;=W
;									      : 	 ;=W
;	  WR_KEYCONF  = Bit flag inidicating the options set for INC_KS       : 	 ;=W
;	  WR_KEYCONF2	keystroke.					      : 	 ;=W
;									      : 	 ;=W
; Exit:   None. 							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
LEFT_H_JUST    PROC NEAR								 ;=W
;											 ;=W
; Initialize right and left boundary markers						 ;=W
;											 ;=W
	       TEST [DI]+WR_KEYCONF,WR_MASK  ;check to see if editing key entered	 ;=W
	       JNE  LHJ5		     ;yes, must check for editing keys		 ;=W
	       JMP  LHJ190		     ;no, skip checks for editing keys		 ;=W
											 ;=W
;											 ;=W
; Process home key									 ;=W
;											 ;=W
LHJ5:	       TEST [DI]+WR_KEYCONF,WR_HOM   ;check if home key pressed 		 ;=W
	       JE   LHJ10								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; add ICB_WHM option to process window home key movement 		 ;=W
	       ;									 ;=W
;											 ;=W
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;initialize cursor to 1st byte		 ;=W
					     ; position, assuming no windowing		 ;=W
					     ; wrap is occurring			 ;=W
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJEXIT		     ; returns WR_CURROW, WR_CURROW		 ;=W
					     ; and WR_CUBYTE				 ;=W
;											 ;=W
; Process end key									 ;=W
;											 ;=W
LHJ10:	       TEST [DI]+WR_KEYCONF,WR_END   ;check if home key pressed 		 ;=W
	       JNE  LHJ12								 ;=W
	       JMP  LHJ20
LHJ12:											 ;=W
	       ;									 ;=W
	       ; add ICB_WEN to move cursor to end of current window row		 ;=W
	       ;									 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get current end of field info		 ;=W
	       MOV  AX,[DI]+WR_ENCHAR	     ;adjust one past end buffer charac 	 ;=W
	       INC  AX									 ;=W
	       MOV  ES:[SI]+ICB_CURCHAR,AX   ;set current cursor position to		 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ17		     ;no					 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ15
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       JMP  LHJ19		     ;exit
LHJ15:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LHJ16		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
LHJ16:											 ;=W
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;adjust horizontal window			 ;=W
	       SUB  BX,ES:[SI]+ICB_WIDTH     ;(below this line may not work for 	 ;=W
	       INC  BX			     ; DBCS support)				 ;=W
	       MOV  [DI]+WR_HRCHAR,BX							 ;=W
	       JMP  LHJ19								 ;=W
LHJ17:											 ;=W
	       MOV  CX,[DI]+WR_CUBYTE	     ;check if need to adjust horz.		 ;=W
	       CMP  CX,ES:[SI]+ICB_WIDTH     ; window					 ;=W
	       JA   LHJ18								 ;=W
	       MOV  [DI]+WR_HRCHAR,1							 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       JMP  LHJ19								 ;=W
LHJ18:											 ;=W
	       MOV  BX,[DI]+WR_ENBYTE	     ;yes, adjust it				 ;=W
	       SUB  BX,ES:[SI]+ICB_WIDTH						 ;=W
	       ADD  BX,2								 ;=W
	       MOV  [DI]+WR_HRCHAR,BX							 ;=W
LHJ19:											 ;=W
	       CALL CAL_COORS		     ;re-calculate display			 ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process left arrow									 ;=W
;											 ;=W
LHJ20:	       TEST [DI]+WR_KEYCONF,WR_LFT   ;check if left arrow key pressed		 ;=W
	       JE   LHJ40								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; add ICB_CSW option to wrap cursor from top/bottom end to end		 ;=W
	       ;									 ;=W
;											 ;=W
	       ;									 ;=W
	       ; add ICB_WAR option to wrap cursor on same row end to end		 ;=W
	       ;									 ;=W
;											 ;=W
	       MOV  BX,ES:[SI]+ICB_CURCHAR   ;get cursor position			 ;=W
	       CMP  BX,1		     ;is cursor in first position ?		 ;=W
	       JA   LHJ30		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ23
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;adjust horizontal window			 ;=W
	       MOV  ES:[SI]+ICB_CURCHAR,BX   ;wrap to first character position
	       SUB  BX,ES:[SI]+ICB_WIDTH     ;(below this line may not work for 	 ;=W
	       INC  BX			     ; DBCS support)				 ;=W
	       MOV  [DI]+WR_HRCHAR,BX							 ;=W
;
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ32		     ;exit
LHJ23:
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LHJ25		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
	       JMP  LHJ400								 ;=W
LHJ25:											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
LHJ30:											 ;=W
	       DEC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position		 ;=W
;
	       CMP  BX,[DI]+WR_HRCHAR	     ;is cursor to the left of horz.wind. ?	 ;=W
	       JG   LHJ32		     ;no					 ;=W
	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust horiz. window 		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ32:					     ; towards the left 			 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process right arrow									 ;=W
;											 ;=W
LHJ40:	       TEST [DI]+WR_KEYCONF,WR_RGT   ;check if left arrow key pressed		 ;=W
	       JE   LHJ60								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; add ICB_WAR option to wrap cursor on same row end to end		 ;=W
	       ;									 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
;											 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ50								 ;=W
;											 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
LHJ50:	       INC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position		 ;=W
					     ; towards the right			 ;=W
	       MOV  BX,[DI]+WR_HRCHAR	     ;get begin. of horiz. wondow		 ;=W
	       ADD  BX,ES:[SI]+ICB_WIDTH     ;add width to get end of window		 ;=W
	       CMP  BX,ES:[SI]+ICB_CURCHAR   ;is cursor past end of window ?		 ;=W
	       JG   LHJ52		     ;no					 ;=W
	       INC  [DI]+WR_HRCHAR	     ;yes, adjust the horiz. window		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ52:											 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ55		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ53
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ55		     ;exit
LHJ53:
	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust wind back one position	 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LHJ55		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LHJ55:											 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process up arrow									 ;=W
;											 ;=W
LHJ60:	       ;									 ;=W
	       ; adjust cursor position 						 ;=W
	       ;									 ;=W
											 ;=W
	       ;									 ;=W
	       ; check for field wrap, exit, error beep 				 ;=W
	       ;									 ;=W
;											 ;=W
; Process down arrow									 ;=W
;											 ;=W
LHJ70:	       ;									 ;=W
	       ; adjust cursor position 						 ;=W
	       ;									 ;=W
											 ;=W
	       ;									 ;=W
	       ; check for field wrap, exit, error beep 				 ;=W
	       ;									 ;=W
;											;=W
; Process cntrl+end key 								 ;=W
;											 ;=W
LHJ80:	       TEST [DI]+WR_KEYCONF,WR_CED   ;check if control+end key pressed		 ;=W
	       JE   LHJ100								 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ90								 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
LHJ90:
	       MOV  BX,[DI]+WR_CUBYTE	     ;delete from current byte position 	 ;=W
	       CALL CLEAR_BUFFER							 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       JMP  LHJEXIT		     ;display field, set cursor, exit		 ;=W
;											 ;=W
; Process delete key									 ;=W
;											 ;=W
LHJ100:        TEST [DI]+WR_KEYCONF,WR_DEL   ;check if delete key pressed		 ;=W
	       JE   LHJ130								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; Add ICB_WDL option in off state to delete on current line only 	 ;=W
	       ;									 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
;											 ;=W
	       CMP  [DI]+WR_FIELDEND,1	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ110								 ;=W
;											 ;=W
	       CALL REMOVE_CHAR 	     ;remove character at current offst 	 ;=W
					     ; and shift remaining in place		 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       JMP  LHJEXIT		     ;display field, set cursor, exit		 ;=W
;											 ;=W
LHJ110:        CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process backspace key 								 ;=W
;											 ;=W
LHJ130:        TEST [DI]+WR_KEYCONF,WR_BCK   ;check if backspace key pressed		 ;=W
	       JE   LHJ160								 ;=W
;											 ;=W
	       MOV  BX,ES:[SI]+ICB_CURCHAR   ;get cursor position			 ;=W
	       CMP  BX,1		     ;check if cursor is at first		 ;=W
	       JA   LHJ140		     ; field position				 ;=W
;
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ133
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;adjust horizontal window			 ;=W
	       MOV  ES:[SI]+ICB_CURCHAR,BX   ;wrap to first character position
	       SUB  BX,ES:[SI]+ICB_WIDTH     ;(below this line may not work for 	 ;=W
	       INC  BX			     ; DBCS support)				 ;=W
	       MOV  [DI]+WR_HRCHAR,BX							 ;=W
;
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ145		     ;exit
LHJ133:
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LHJ135		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ400								 ;=W
LHJ135: 										 ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       CALL PCMBEEP_CALL	     ;error beep				 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
LHJ140: 										 ;=W
	       DEC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position
					     ; towards the left 			 ;=W
	       CMP  BX,[DI]+WR_HRCHAR	     ;is cursor in front of the wind. ? 	 ;=W
	       JG   LHJ142		     ;no					 ;=W
	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust the horiz. window		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ142: 										 ;=W
;											 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CALL REMOVE_CHAR 	     ;remove character at current offst 	 ;=W
					     ; and shift remaining in place		 ;=W
LHJ145: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       JMP  LHJEXIT		     ;display field, set cursor, exit		 ;=W
;											 ;=W
; Process insert key toggle								 ;=W
;											 ;=W
LHJ160:        TEST [DI]+WR_KEYCONF,WR_INS   ;check if insert key pressed		 ;=W
	       JE   LHJ180		     ; if not, continue 			 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS  ;check if in insert mode ?		 ;=W
	       JE   LHJ165		     ;no, put in insert mode			 ;=W
;											 ;=W
	       MOV  BX,[DI]+IN_CURNOR	     ;set cursor size for normal		 ;=W
	       MOV  [DI]+WR_CURSIZE,BX	     ; cursor					 ;=W
;											 ;=W
	       AND  ES:[SI]+ICB_STATUS,NOT ICB_SINS					 ;=W
	       JMP  LHJ170		     ;turn insert mode off			 ;=W
;											 ;=W
LHJ165:        MOV  BX,[DI]+IN_CURINS	     ;set cursor size for insert		 ;=W
	       MOV  [DI]+WR_CURSIZE,BX	     ; cursor					 ;=W
;											 ;=W
	       OR   ES:[SI]+ICB_STATUS,ICB_SINS 					 ;=W
					     ;turn insert mode on			 ;=W
;											 ;=W
LHJ170: 										 ;=W
;											 ;=W
	       PUSH DS			     ;save registers				 ;=W
	       PUSH DI									 ;=W
;											 ;=W
	       MOV  DI,40H		     ;point DS:DI to KB_FLAG in BIOS		 ;=W
	       MOV  DS,DI								 ;=W
	       MOV  DI,17H								 ;=W
	       MOV  AX,[DI]		     ;get current BIOS KB_FLAG			 ;=W
;											 ;=W
	       AND  AX,NOT WR_INSSTATE	     ;set BIOS insert active flag off		 ;=W
;											 ;=W
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS 					 ;=W
	       JE   LHJ175		     ;check if insert should be set on		 ;=W
;											 ;=W
	       OR   AX,WR_INSSTATE	     ;set BIOS insert active flag on		 ;=W
;											 ;=W
LHJ175:        POP  DI			     ;restore registers 			 ;=W
	       POP  DS									 ;=W
;											 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Process allowonce key option								 ;=W
;											 ;=W
LHJ180:        ;									 ;=W
	       ; insert or replace							 ;=W
	       ;									 ;=W
;											 ;=W
	       ;									 ;=W
	       ; adjust input buffer							 ;=W
	       ;									 ;=W
;											 ;=W
	       ;									 ;=W
	       ; check for field wrap, exit, error beep 				 ;=W
	       ;									 ;=W
;											 ;=W
	       ;									 ;=W
	       ; adjust cursor position 						 ;=W
	       ;									 ;=W
;											 ;=W
; Process allowed keystroke in replace mode						 ;=W
;											 ;=W
LHJ190:        TEST [DI]+WR_KEYCONF,WR_ALL   ;check if allow key pressed		 ;=W
	       JNE  LHJ195								 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep key not defined		 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
LHJ195:        TEST ES:[SI]+ICB_STATUS,ICB_SINS 					 ;=W
	       JE   LHJ198		     ;check if insert is active 		 ;=W
;											 ;=W
	       JMP  LHJ270		     ;do insert display 			 ;=W
;											 ;=W
LHJ198: 										 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ200								 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep key not defined		 ;=W
	       JMP  LHJEXIT		     ;exit					 ;=W
;											 ;=W
; Check if character to be replaced in field buffer is double byte character		 ;=W
;											 ;=W
LHJ200:        PUSH ES			     ;save registers				 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer		 ;=W
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer		 ;=W
	       POP  SI									 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       ADD  SI,[DI]+WR_CUBYTE	     ;add cursor offset into buffer		 ;=W
	       DEC  SI			     ;make zero based				 ;=W
;											 ;=W
	       MOV  CX,ES		     ;save offset of character to		 ;=W
	       MOV  DX,SI		     ; replace					 ;=W
;											 ;=W
	       MOV  AL,ES:[SI]		     ;get byte that cursor is pointing		 ;=W
	       MOV  [DI]+DBC_KS,AL	     ; to check if DBCS 			 ;=W
	       CALL PCINDBC_CALL	     ;call routine to check if char		 ;=W
					     ; is lead double byte char 		 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if char is lead DBCS		 ;=W
	       JE   LHJ220		     ; if no, jump to single byte code		 ;=W
;											 ;=W
; Replace double byte character with double byte character				 ;=W
;											 ;=W
	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check if keystroke is DBC 		 ;=W
	       JE   LHJ210		     ;continue with single byte 		 ;=W
;											 ;=W
	       MOV  AX,[DI]+INC_KS	     ;set double byte character to		 ;=W
					     ; input buffer replacing			 ;=W
					     ; double byte character			 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace					 ;=W
	       MOV  ES:[SI],AX		     ;replace double byte			 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       JMP  LHJ260		     ;exit					 ;=W
;											 ;=W
; Replace double byte character with single byte character				 ;=W
;											 ;=W
LHJ210:        MOV  AX,[DI]+INC_KS	     ;get keystroke and replace double		 ;=W
					     ; byte with single byte			 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace single byte			 ;=W
	       MOV  ES:[SI],AL								 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set ending byte				 ;=W
	       MOV  [DI]+WR_RIGHTBYTE,AX						 ;=W
;											 ;=W
	       MOV  AX,[DI]+WR_CUBYTE	     ;set markers for shift to remove		 ;=W
	       INC  AX			     ;adjust past replaced leading byte 	 ;=W
	       MOV  [DI]+WR_LEFTBYTE,AX      ; trailing byte				 ;=W
;											 ;=W
	       MOV  BX,1		     ;set number of positions to shift		 ;=W
	       MOV  AX,2		     ;set option to shift left			 ;=W
	       CALL SHIFT		     ;call shift 1 position toward left 	 ;=W
	       JMP  LHJ260		     ;exit					 ;=W
;											 ;=W
; Replace single byte character with single byte character				 ;=W
;											 ;=W
LHJ220:        TEST [DI]+WR_KEYCONF2,WR_DBC  ;check if double byte character		 ;=W
	       JNE  LHJ230		     ; continue with single byte		 ;=W
;											 ;=W
	       MOV  AX,[DI]+INC_KS	     ;get keystroke				 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace single byte			 ;=W
	       MOV  ES:[SI],AL								 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       JMP  LHJ260		     ;exit					 ;=W
;											 ;=W
; Replace single byte character with double byte character				 ;=W
;											 ;=W
LHJ230: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       MOV  BX,[DI]+WR_ENBYTE	     ;get end byte of input field		 ;=W
	       MOV  AX,[DI]+WR_ENCHAR	     ;get end character of field		 ;=W
	       CMP  AX,ES:[SI]+ICB_CURCHAR   ;is cursor past end character		 ;=W
	       JA   LHJ240								 ;=W
;											 ;=W
	       MOV  BX,[DI]+WR_CUBYTE	     ;set cursor character position		 ;=W
LHJ240: 										 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get end of field position 		 ;=W
	       SUB  AX,BX		     ;subtract to get the remaining space	 ;=W
	       CMP  AX,1		     ;will byte fit ?				 ;=W
	       JGE  LHJ250		     ;yes					 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep because replace char		 ;=W
	       JMP  LHJEXIT		     ; will not fit and exit			 ;=W
;											 ;=W
LHJ250:        MOV  BX,ES:[SI]+ICB_FIELDLEN  ;set ending byte				 ;=W
	       MOV  [DI]+WR_RIGHTBYTE,BX						 ;=W
;											 ;=W
	       MOV  BX,[DI]+WR_CUBYTE	     ;set markers for shift to remove		 ;=W
	       INC  BX			     ;adjust past replaced leading byte 	 ;=W
	       MOV  [DI]+WR_LEFTBYTE,BX      ; trailing byte				 ;=W
;											 ;=W
	       MOV  BX,1		     ;set number of positions to shift		 ;=W
	       MOV  AX,1		     ;set option to shift right 		 ;=W
	       CALL SHIFT		     ;call shift 1 position toward		 ;=W
					     ; left					 ;=W
	       MOV  AX,[DI]+INC_KS	     ;get keystroke				 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace double byte			 ;=W
	       MOV  ES:[SI],AX								 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
; Calculate new ending and cursor coordinates						 ;=W
;											 ;=W
LHJ260: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       INC  ES:[SI]+ICB_CURCHAR      ;point to next char			 ;=W
	       MOV  BX,[DI]+WR_HRCHAR	     ;get begin. of horiz. wondow		 ;=W
	       ADD  BX,ES:[SI]+ICB_WIDTH     ;add width to get end of window		 ;=W
	       CMP  BX,ES:[SI]+ICB_CURCHAR   ;is cursor past end of window ?		 ;=W
	       JG   LHJ265		     ;no					 ;=W
	       INC  [DI]+WR_HRCHAR	     ;yes, adjust the horiz. window		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ265: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ267		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ266
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ267		     ;exit
LHJ266:

	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust wind back one position	 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXD ;is autoexit option set ?			 ;=W
	       JE   LHJ267		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LHJ267: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       JMP  LHJEXIT		     ;display field, set cursor, exit		 ;=W
;											 ;=W
; Process allowed keystroke in insert mode						 ;=W
;											 ;=W
LHJ270: 										 ;=W
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ280								 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep key not defined		 ;=W
	       JMP  LHJEXIT		      ;exit					 ;=W
;											 ;=W
; Check if enough room available to insert single or double byte character		 ;=W
;											 ;=W
LHJ280: 										 ;=W
	       MOV  CX,ES:[SI]+ICB_FIELDSEG  ;get segment of input buffer		 ;=W
	       MOV  DX,ES:[SI]+ICB_FIELDOFF  ;get offset of input buffer		 ;=W
;											 ;=W
	       ADD  DX,[DI]+WR_CUBYTE	     ;add cursor offset into buffer		 ;=W
	       DEC  DX			     ;make zero based				 ;=W
;											 ;=W
	       MOV  BX,1		     ;initialize to single byte 		 ;=W
;											 ;=W
	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check for double byte character		 ;=W
	       JE   LHJ290								 ;=W
;											 ;=W
	       MOV  BX,2		     ;reset to double byte character		 ;=W
LHJ290: 										 ;=W
	       PUSH BX									 ;=W
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       MOV  BX,[DI]+WR_ENBYTE	     ;get end byte of input field		 ;=W
	       MOV  AX,[DI]+WR_ENCHAR	     ;get end character of field		 ;=W
	       CMP  AX,ES:[SI]+ICB_CURCHAR   ;is cursor past end character		 ;=W
	       JA   LHJ300								 ;=W
;											 ;=W
	       MOV  BX,[DI]+WR_CUBYTE	     ;set cursor character position		 ;=W
LHJ300: 										 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get end of field position 		 ;=W
	       SUB  AX,BX		     ;subtract to get the remaining space	 ;=W
	       POP  BX									 ;=W
	       CMP  AX,BX		     ;will byte fit ?				 ;=W
	       JGE  LHJ310		     ;yes					 ;=W
;											 ;=W
	       CALL PCMBEEP_CALL	     ;error beep replace character		 ;=W
	       JMP  LHJEXIT		     ; will not fit and exit			 ;=W
;											 ;=W
; Shift to insert single or double byte character, BX= # bytes to shift 		 ;=W
;											 ;=W
LHJ310:        MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set ending byte to make room in		 ;=W
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; buffer by shifting characters		 ;=W
;											 ;=W
	       MOV  AX,[DI]+WR_CUBYTE	     ;set markers for shift to remove		 ;=W
	       MOV  [DI]+WR_LEFTBYTE,AX      ; trailing byte				 ;=W
;											 ;=W
	       MOV  AX,1		     ;set option to shift right, BX=		 ;=W
					     ; number of bytes to insert		 ;=W
	       CALL SHIFT		     ;call shift 1 position toward		 ;=W
					     ; left					 ;=W
	       MOV  AX,[DI]+INC_KS	     ;get keystroke				 ;=W
;											 ;=W
; Insert single byte character								 ;=W
;											 ;=W
	       CMP  BX,2		     ;check how many bytes should be		 ;=W
	       JE   LHJ320		     ; inserted 				 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace single byte			 ;=W
	       MOV  ES:[SI],AL		     ;insert single byte character		 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
	       JMP  LHJ330								 ;=W
;											 ;=W
; Insert double byte character								 ;=W
;											 ;=W
LHJ320:        PUSH ES									 ;=W
	       PUSH SI									 ;=W
;											 ;=W
	       MOV  ES,CX		     ;save offset of character to		 ;=W
	       MOV  SI,DX		     ; replace					 ;=W
	       MOV  ES:[SI],AX		     ;insert double byte character		 ;=W
;											 ;=W
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
; Calculate new ending and cursor coordinates						 ;=W
;											 ;=W
LHJ330: 										 ;=W
	       CALL CAL_COORS		     ;get new end coordinates			 ;=W
;											 ;=W
	       INC  ES:[SI]+ICB_CURCHAR      ;point to next char			 ;=W
	       MOV  BX,[DI]+WR_HRCHAR	     ;get begin. of horiz. wondow		 ;=W
	       ADD  BX,ES:[SI]+ICB_WIDTH     ;add width to get end of window		 ;=W
	       CMP  BX,ES:[SI]+ICB_CURCHAR   ;is cursor past end of window ?		 ;=W
	       JG   LHJ332		     ;no					 ;=W
	       INC  [DI]+WR_HRCHAR	     ;yes, adjust the horiz. window		 ;=W
	       MOV  AX,4		     ;display delimiters "< >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
LHJ332: 										 ;=W
	       CALL CAL_COORS		     ;calculate cursor position
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LHJ335		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LHJ333
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       MOV  [DI]+WR_HRCHAR,1	     ;reset the horiz. window			 ;=W
	       MOV  AX,3		     ;display delimiters "[ >"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       JMP  LHJ335		     ;exit
LHJ333:
	       DEC  [DI]+WR_HRCHAR	     ;yes, adjust wind back one position	 ;=W
	       MOV  AX,5		     ;display delimiters "< ]"                   ;=W
	       CALL DELIMITER		     ;display delimiter 			 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_AXD ;is autoexit option set ?			 ;=W
	       JE   LHJ335		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LHJ335:
	       CALL CAL_COORS		     ;calculate cursor position 		 ;=W
	       JMP  LHJEXIT		     ;display cursor
;											 ;=W
; Display field & Exit									 ;=W
;											 ;=W
LHJ400:
	       CALL WORD PTR [DI]+WR_DISPLAY ;display current input buffer		 ;=W
					     ; in left justified field			 ;=W
	       JMP  LHJCUR
LHJEXIT:										 ;=W
	       CALL WORD PTR [DI]+WR_DISPLAY ;display current input buffer		 ;=W
					     ; in left justified field			 ;=W
	       TEST ES:[SI]+ICB_STATUS,ICB_CUR_ON ;is cursor on ?
	       JNE  LHJCUR			  ;cursor is already on, don't turn it on ;=W
	       CALL CURSOR		     ;display cursor				 ;=W
LHJCUR:
;											 ;=W
	       RET									 ;=W
LEFT_H_JUST    ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; LEFT_JUST								      :
;									      :
;	  Process keystroke and update display with input buffer changes      :
;	  for the following functions:					      :
;									      :
;	  Home key	  Up arrow	  Allowonce replace mode	      :
;	  End key	  Down arrow	  Allowonce insert mode 	      :
;	  Left arrow	  Control end	  Allow replace mode		      :
;	  Right arrow	  Delete key	  Allow insert mode		      :
;									      :
;									      :
;	  Following information is used:				      :
;									      :
;									      :
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      :
;	    				   buffer in memory.		      :
;	    								      :
;	    		 (WR_CUBYTE)	 Byte offset into the input buffer    :
;	    				 of where characters will be added    :
;	    				 to input buffer.		      :
;	    								      :
;	  Ŀ	      :
;	   S  L  T  L  T  S  S                      	      :
;	  	      :
;	    	      :
;				     					      :
;		 (ICB_FIELDLEN) Length of input field in bytes. 	      :
;									      :
;									      :
;	  The following demonstrates the before and after input buffer	      :
;	  images.  (S = Single byte, L = DBCS lead byte, T = DBCS trailing    :
;	  byte) 							      :
;									      :
;	  Deleting a double byte:					      :
;		Ŀ   Ŀ	      :
;		 S  L  T  L  T  S     S  L  T  S 	   	      :
;		   	      :
;									      :
;	  Deleting a single byte:					      :
;		Ŀ   Ŀ	      :
;		 S  L  T  S  L  T     S  L  T  L  T    	      :
;		   	      :
;									      :
;	  Backspace removal of a double byte:				      :
;		Ŀ   Ŀ	      :
;		 S  L  T  L  T  S     S  L  T  S 	   	      :
;		   	      :
;									      :
;	  Backspace removal of a single byte:				      :
;		Ŀ   Ŀ	      :
;		 S  S  S  S  L  T     S  S  S  L  T    	      :
;		   	      :
;									      :
;	  Replacing a double byte with a double byte:			      :
;		Ŀ   Ŀ	      :
;		 S  L  T  L  T  S     S  L  T  L  T  S 	      :
;		   	      :
;									      :
;	  Replacing a double byte with a single byte: (Option 1)	      :
;		Ŀ   Ŀ	      :
;		 S  L  T  L  T  S     S  L  T  S  S    	      :
;		   	      :
;									      :
;	  Replacing a double byte with a single byte: (Option 2)	      :
;		Ŀ   Ŀ	      :
;		 S  L  T  L  T  S     S  L  T  S 	 S 	      :
;		   	      :
;									      :
;	  Replacing a single byte with a single byte:			      :
;		Ŀ   Ŀ	      :
;		 S  L  T  S  L  T     S  L  T  S  L  T 	      :
;		   	      :
;									      :
;	  Replacing a single byte with a double byte.			      :
;		Ŀ   Ŀ	      :
;		 S  L  T  S    	    S  L  T  L  T    	      :
;		   	      :
;									      :
;	  Replacing a single byte with a double byte without enough buffer:   :
;		Ŀ   Ŀ	      :
;		 S  L  T  S  L  T     S  L  T  S  L  T 	      :
;		   	      :
;									      :
;	  Inserting a single byte.					      :
;		Ŀ   Ŀ	      :
;		 S  L  T  L  T 	    S  L  T  S  L  T 	      :
;		   	      :
;									      :
;	  Inserting a single byte without enough buffer generate an error:    :
;		Ŀ   Ŀ	      :
;		 S  L  T  L  T  S     S  L  T  L  T  S 	      :
;		   	      :
;		Ŀ   Ŀ	      :
;		 S  L  T  S  S 	    S  L  T  S  S    	      :
;		   	      :
;									      :
;	  Inserting a double byte character:				      :
;		Ŀ   Ŀ	      :
;		 S  L  T  S    	    S  L  T  L  T  S 	      :
;		   	      :
;									      :
;									      :
; Entry:  ES:SI       = Points to current ICB				      :
;	  DS:DI       = Points to PB					      :
;									      :
;	  INC_KS      = Keystroke from returned from PCINCHA		      :
;									      :
;	  WR_KEYCONF  = Bit flag inidicating the options set for INC_KS       :
;	  WR_KEYCONF2	keystroke.					      :
;									      :
; Exit:   None. 							      :
;									      :
;-----------------------------------------------------------------------------+
;
LEFT_JUST      PROC NEAR
;
; Initialize right and left boundary markers
;
	       MOV  [DI]+WR_LEFTCHAR,1	     ;set left character to beginning
					     ; of field
;
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set right marker past end of
	       INC  AX			     ; field
	       MOV  [DI]+WR_RIGHTCHAR,AX
;
	       TEST [DI]+WR_KEYCONF,WR_MASK  ;check to see if editing key entered	 ;=W
	       JNE  LJ5 		     ;yes, must check for editing keys		 ;=W
	       JMP  LJ190		     ;no, skip checks for editing keys		 ;=W

;
; Process home key
;
LJ5:	       TEST [DI]+WR_KEYCONF,WR_HOM   ;check if home key pressed
	       JE   LJ10
;
	       ;
	       ; add ICB_WHM option to process window home key movement
	       ;
;
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;initialize cursor to 1st byte
					     ; position, assuming no windowing
					     ; wrap is occurring
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       JMP  LJEXIT		     ; returns WR_CURROW, WR_CURROW
					     ; and WR_CUBYTE
;
; Process end key
;
LJ10:	       TEST [DI]+WR_KEYCONF,WR_END   ;check if home key pressed
	       JE   LJ20
;
	       ;
	       ; add ICB_WEN to move cursor to end of current window row
	       ;
;
	       CALL CAL_COORS		     ;get current end of field info		 ;=W
;
	       MOV  AX,[DI]+WR_ENCHAR	     ;adjust one past end buffer charac
	       INC  AX
	       MOV  ES:[SI]+ICB_CURCHAR,AX   ;set current cursor position to
					     ; end of field
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LJ17		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ16
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       CALL CAL_COORS		     ;get cursor position
	       JMP  LJEXIT		     ;exit
LJ16:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LJ17		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
LJ17:											 ;=W
	       JMP  LJEXIT		     ;exit
;
; Process left arrow
;
LJ20:	       TEST [DI]+WR_KEYCONF,WR_LFT   ;check if left arrow key pressed
	       JE   LJ40
;
	       ;
	       ; add ICB_WAR option to wrap cursor on same row end to end
	       ;
;
	       CMP  ES:[SI]+ICB_CURCHAR,1    ;check if cursor is at first
	       JA   LJ30		     ; field position
;
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LJ25		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
	       JMP  LJCUR								 ;=W
LJ25:											 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ27
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get last position
	       MOV  ES:[SI]+ICB_CURCHAR,AX   ;put as current position
	       CALL CAL_COORS
	       JMP  LJEXIT
LJ27:
	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
LJ30:	       DEC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position
					     ; towards the left
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       JMP  LJEXIT		     ;exit
;
; Process right arrow
;
LJ40:	       TEST [DI]+WR_KEYCONF,WR_RGT   ;check if left arrow key pressed
	       JE   LJ60
;
	       ;
	       ; add ICB_CSW option to wrap cursor from top/bottom end to end
	       ;
;
	       ;
	       ; add ICB_AXC option to auto enter if cursor reaches end
	       ;
;
	       ;
	       ; add ICB_WAR option to wrap cursor on same row end to end
	       ;
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field
	       JE   LJ50
;
	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
LJ50:	       INC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position
					     ; towards the left
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LJ55		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ52
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       CALL CAL_COORS		     ;get cursor position
	       JMP  LJEXIT		     ;exit
LJ52:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LJ55		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LJ55:											 ;=W
	       JMP  LJEXIT		     ;exit
;
; Process up arrow
;
LJ60:	       ;
	       ; adjust cursor position
	       ;

	       ;
	       ; check for field wrap, exit, error beep
	       ;
;
; Process down arrow
;
LJ70:	       ;
	       ; adjust cursor position
	       ;

	       ;
	       ; check for field wrap, exit, error beep
	       ;
;
; Process cntrl+end key
;
LJ80:	       TEST [DI]+WR_KEYCONF,WR_CED   ;check if control+end key pressed
	       JE   LJ100
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field
	       JE   LJ90
;
	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
LJ90:	       CALL CAL_COORS		     ;get current end of field info		 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set rightmost area to refresh on
	       MOV  [DI]+WR_RIGHTDISP,AX     ; display to entire field
;
	       MOV  BX,[DI]+WR_CUBYTE	     ;delete from current byte position
	       CALL CLEAR_BUFFER
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       JMP  LJ340		     ;display field, set cursor, exit
;
; Process delete key
;
LJ100:	       TEST [DI]+WR_KEYCONF,WR_DEL   ;check if delete key pressed
	       JE   LJ130
;
	       ;
	       ; Add ICB_WDL option in off state to delete on current line only
	       ;
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,1	     ;check if cursor past end of field
	       JE   LJ110
;
	       CALL REMOVE_CHAR 	     ;remove character at current offst
					     ; and shift remaining in place
	       JMP  LJ340		     ;display field, set cursor, exit
;
LJ110:	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
; Process backspace key
;
LJ130:	       TEST [DI]+WR_KEYCONF,WR_BCK   ;check if backspace key pressed
	       JE   LJ160
;
	       CMP  ES:[SI]+ICB_CURCHAR,1    ;check if cursor is at first
	       JA   LJ140		     ; field position
;
	       TEST ES:[SI]+ICB_OPT2,ICB_AXC ;is autoexit option set ?			 ;=W
	       JE   LJ135		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;yes, set autoexit flag			 ;=W
	       JMP  LJCUR								 ;=W
LJ135:											 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ137
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;get last position
	       MOV  ES:[SI]+ICB_CURCHAR,AX   ;put as current position
	       CALL CAL_COORS
	       JMP  LJEXIT
LJ137:
	       CALL PCMBEEP_CALL	     ;error beep
	       JMP  LJEXIT		     ;exit
;
LJ140:	       DEC  ES:[SI]+ICB_CURCHAR      ;adjust cursor to one position
					     ; towards the left
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CALL REMOVE_CHAR 	     ;remove character at current offst
					     ; and shift remaining in place
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       JMP  LJ340		     ;display field, set cursor, exit
;
; Process insert key toggle
;
LJ160:	       TEST [DI]+WR_KEYCONF,WR_INS   ;check if insert key pressed
	       JE   LJ180		     ; if not, continue
;
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS  ;check if in insert mode ?
	       JE   LJ165		     ;no, put in insert mode
;
	       MOV  BX,[DI]+IN_CURNOR	     ;set cursor size for normal
	       MOV  [DI]+WR_CURSIZE,BX	     ; cursor
;
	       AND  ES:[SI]+ICB_STATUS,NOT ICB_SINS
	       JMP  LJ170		     ;turn insert mode off
;
LJ165:	       MOV  BX,[DI]+IN_CURINS	     ;set cursor size for insert
	       MOV  [DI]+WR_CURSIZE,BX	     ; cursor
;
	       OR   ES:[SI]+ICB_STATUS,ICB_SINS
					     ;turn insert mode on
;
LJ170:
;
	       PUSH DS			     ;save registers
	       PUSH DI
;
	       MOV  DI,40H		     ;point DS:DI to KB_FLAG in BIOS
	       MOV  DS,DI
	       MOV  DI,17H
	       MOV  AX,[DI]		     ;get current BIOS KB_FLAG
;
	       AND  AX,NOT WR_INSSTATE	     ;set BIOS insert active flag off
;
	       TEST ES:[SI]+ICB_STATUS,ICB_SINS
	       JE   LJ175		     ;check if insert should be set on
;
	       OR   AX,WR_INSSTATE	     ;set BIOS insert active flag on
;
LJ175:	       POP  DI			     ;restore registers
	       POP  DS
;
	       JMP  LJEXIT		     ;exit
;
; Process allowonce key option
;
LJ180:	       ;
	       ; insert or replace
	       ;
;
	       ;
	       ; adjust input buffer
	       ;
;
	       ;
	       ; check for field wrap, exit, error beep
	       ;
;
	       ;
	       ; adjust cursor position
	       ;
;
; Process allowed keystroke in replace mode
;
LJ190:	       TEST [DI]+WR_KEYCONF,WR_ALL   ;check if allow key pressed
	       JNE  LJ195
;
	       CALL PCMBEEP_CALL	     ;error beep key not defined
	       JMP  LJEXIT		     ;exit
;
LJ195:	       TEST ES:[SI]+ICB_STATUS,ICB_SINS
	       JE   LJ198		     ;check if insert is active
;
	       JMP  LJ270		     ;do insert display
;
LJ198:
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field
	       JE   LJ200
;
	       CALL PCMBEEP_CALL	     ;error beep key not defined
	       JMP  LJEXIT		     ;exit
;
; Check if character to be replaced in field buffer is double byte character
;
LJ200:	       PUSH ES			     ;save registers
	       PUSH SI
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer
	       POP  SI
	       POP  ES
;
	       ADD  SI,[DI]+WR_CUBYTE	     ;add cursor offset into buffer
	       DEC  SI			     ;make zero based
;
	       MOV  CX,ES		     ;save offset of character to
	       MOV  DX,SI		     ; replace
;
	       MOV  AL,ES:[SI]		     ;get byte that cursor is pointing
	       MOV  [DI]+DBC_KS,AL	     ; to check if DBCS
	       CALL PCINDBC_CALL	     ;call routine to check if char
					     ; is lead double byte char
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if char is lead DBCS
	       JE   LJ220		     ; if no, jump to single byte code
;
; Replace double byte character with double byte character
;
	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check if keystroke is DBC
	       JE   LJ210		     ;continue with single byte
;
	       MOV  AX,[DI]+INC_KS	     ;set double byte character to
					     ; input buffer replacing
					     ; double byte character
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace
	       MOV  ES:[SI],AX		     ;replace double byte
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       JMP  LJ260		     ;exit
;
; Replace double byte character with single byte character
;
LJ210:	       MOV  AX,[DI]+INC_KS	     ;get keystroke and replace double
					     ; byte with single byte
;
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace single byte
	       MOV  ES:[SI],AL
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set ending byte
	       MOV  [DI]+WR_RIGHTBYTE,AX
;
	       MOV  AX,[DI]+WR_CUBYTE	     ;set markers for shift to remove
	       INC  AX			     ;adjust past replaced leading byte 	 ;=W
	       MOV  [DI]+WR_LEFTBYTE,AX      ; trailing byte
;
	       MOV  BX,1		     ;set number of positions to shift
	       MOV  AX,2		     ;set option to shift left
	       CALL SHIFT		     ;call shift 1 position toward left
	       JMP  LJ260		     ;exit
;
; Replace single byte character with single byte character
;
LJ220:	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check if double byte character
	       JNE  LJ230		     ; continue with single byte
;
	       MOV  AX,[DI]+INC_KS	     ;get keystroke
;
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace single byte
	       MOV  ES:[SI],AL
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       JMP  LJ260		     ;exit
;
; Replace single byte character with double byte character
;
LJ230:	       MOV  BX,ES:[SI]+ICB_CURCHAR   ;set cursor character position
	       MOV  [DI]+WR_LEFTCHAR,BX      ; to left marker
;
	       CALL CAL_COORS		     ;get the current end of field		 ;=W
					     ; coordinates
	       MOV  AX,[DI]+WR_ENCHAR	     ;get end character of field
	       CMP  AX,ES:[SI]+ICB_CURCHAR   ;is cursor past end character
	       JA   LJ240
;
	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;cursor is past last char
;
LJ240:	       MOV  [DI]+WR_RIGHTCHAR,AX     ;set right marker
;
	       MOV  BX,1		     ;One byte is already available
					     ; check if room for trailing byte
	       MOV  AX,1		     ;set up call to LEFT_DISP to
	       CALL WORD PTR [DI]+WR_DISPLAY ; determine if additional byte
					     ; will fit in input buffer
	       CMP  AX,0		     ;check if double byte character
	       JE   LJ250		     ; will fit
;
	       CALL PCMBEEP_CALL	     ;error beep because replace char
	       JMP  LJEXIT		     ; will not fit and exit
;
LJ250:	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;set ending byte
	       MOV  [DI]+WR_RIGHTBYTE,BX
;
	       MOV  BX,[DI]+WR_CUBYTE	     ;set markers for shift to remove
	       INC  BX			     ;adjust past replaced leading byte
	       MOV  [DI]+WR_LEFTBYTE,BX      ; trailing byte
;
	       MOV  BX,1		     ;set number of positions to shift
	       MOV  AX,1		     ;set option to shift right
	       CALL SHIFT		     ;call shift 1 position toward
					     ; left
	       MOV  AX,[DI]+INC_KS	     ;get keystroke
;
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace double byte
	       MOV  ES:[SI],AX
;
	       POP  SI			     ;restore registers
	       POP  ES
;
; Calculate new ending and cursor coordinates
;
LJ260:
	       MOV  BX,[DI]+WR_ENCHAR	     ;set rightmost area to refresh on		 ;=W
	       CALL CAL_COORS		     ;get new end coordinates			 ;=W
	       CMP  BX,[DI]+WR_ENCHAR	     ;is old END_CHAR > new END_CHAR ?		 ;=W
	       JG   LJ261		     ;yes, use old END_CHAR (so display 	 ;=W
	       MOV  BX,[DI]+WR_ENCHAR	     ; is updated correctly)

LJ261:					     ;set rightmost area to refresh on		 ;=W
	       MOV  [DI]+WR_RIGHTDISP,BX     ; display to new ending character

	       INC  ES:[SI]+ICB_CURCHAR      ;point to next char

	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LJ265		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ262
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       JMP  LJ340		     ;display field, set cursor, exit
LJ262:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXD ;is autoexit option set ?			 ;=W
	       JE   LJ265		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
LJ265:											 ;=W
	       JMP  LJ340		     ;display field, set cursor, exit
;
; Process allowed keystroke in insert mode
;
LJ270:
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field
	       JE   LJ280
;
	       CALL PCMBEEP_CALL	     ;error beep key not defined
	       JMP  LJEXIT		     ;exit
;
; Check if enough room available to insert single or double byte character
;
LJ280:
	       MOV  CX,ES:[SI]+ICB_FIELDSEG  ;get segment of input buffer
	       MOV  DX,ES:[SI]+ICB_FIELDOFF  ;get offset of input buffer
;
	       ADD  DX,[DI]+WR_CUBYTE	     ;add cursor offset into buffer
	       DEC  DX			     ;make zero based
;
	       MOV  BX,1		     ;initialize to single byte
;
	       TEST [DI]+WR_KEYCONF2,WR_DBC  ;check for double byte character
	       JE   LJ290
;
	       MOV  BX,2		     ;reset to double byte character
;
LJ290:	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;set cursor character position
	       MOV  [DI]+WR_LEFTCHAR,AX      ; to left marker
;
	       CALL CAL_COORS		     ;get the current end of field		 ;=W
					     ; coordinates
	       MOV  AX,[DI]+WR_ENCHAR	     ;get end character of field
;
	       CMP  AX,ES:[SI]+ICB_CURCHAR   ;is cursor past end character
	       JA   LJ300
;
	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;cursor is past last char
	       DEC  AX
;
LJ300:	       MOV  [DI]+WR_RIGHTCHAR,AX     ;set right marker
;
	       MOV  AX,1		     ;set up call to LEFT_DISP to
	       CALL WORD PTR [DI]+WR_DISPLAY ; determine if additional byte
					     ; will fit in input buffer
					     ; BX= number of bytes to insert
	       CMP  AX,0		     ;check if double byte character
	       JE   LJ310		     ; will fit
;
	       CALL PCMBEEP_CALL	     ;error beep replace character
	       JMP  LJEXIT		     ; will not fit and exit
;
; Shift to insert single or double byte character, BX= # bytes to shift
;
LJ310:	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;set ending byte to make room in
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; buffer by shifting characters
;
	       MOV  AX,[DI]+WR_CUBYTE	     ;set markers for shift to remove
	       MOV  [DI]+WR_LEFTBYTE,AX      ; trailing byte
;
	       MOV  AX,1		     ;set option to shift right, BX=
					     ; number of bytes to insert
	       CALL SHIFT		     ;call shift 1 position toward
					     ; left
	       MOV  AX,[DI]+INC_KS	     ;get keystroke
;
; Insert single byte character
;
	       CMP  BX,2		     ;check how many bytes should be
	       JE   LJ320		     ; inserted
;
	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace single byte
	       MOV  ES:[SI],AL		     ;insert single byte character
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       JMP  LJ330
;
; Insert double byte character
;
LJ320:	       PUSH ES
	       PUSH SI
;
	       MOV  ES,CX		     ;save offset of character to
	       MOV  SI,DX		     ; replace
	       MOV  ES:[SI],AX		     ;insert double byte character
;
	       POP  SI			     ;restore registers
	       POP  ES
;
; Calculate new ending and cursor coordinates
;
LJ330:
	       CALL CAL_COORS		     ;get new end coordinates			 ;=W
;
	       MOV  AX,[DI]+WR_ENCHAR	     ;set rightmost area to refresh on
	       MOV  [DI]+WR_RIGHTDISP,AX     ; display to old ending character
;
	       INC  ES:[SI]+ICB_CURCHAR      ;point to next char
;
	       CALL CAL_COORS		     ;get cursor position			 ;=W
	       CMP  [DI]+WR_FIELDEND,0	     ;check if cursor past end of field 	 ;=W
	       JE   LJ340		     ;no					 ;=W
	       TEST ES:[SI]+ICB_OPT2,ICB_CSW ;is cursor wrap option on ?		 ;=W
	       JE   LJ335
	       MOV  ES:[SI]+ICB_CURCHAR,1    ;wrap to first character position
	       JMP  LJ340		     ;display field, set cursor, exit
LJ335:
	       TEST ES:[SI]+ICB_OPT2,ICB_AXD ;is autoexit option set ?			 ;=W
	       JE   LJ340		     ;no					 ;=W
	       OR   [DI]+WR_KEYCONF2,WR_RET  ;set autoexit flag 			 ;=W
;
; Display field
;
LJ340:
	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;set left character to cursor
	       DEC  AX			     ; last cursor position
	       MOV  [DI]+WR_LEFTCHAR,AX
;
	       MOV  AX,[DI]+WR_RIGHTDISP     ;set right character marker to		 ;=W
	       MOV  [DI]+WR_RIGHTCHAR,AX     ; max possible field length
;
	       CALL CAL_COORS		     ;get end of field char, byte		 ;=W
					     ; and next byte positions

	       MOV  AX,2		     ;set display option
	       CALL WORD PTR [DI]+WR_DISPLAY ;display current input buffer
					     ; in left justified field
;
; Exit
;
LJEXIT: 					  ;continue
	       TEST ES:[SI]+ICB_STATUS,ICB_CUR_ON ;is cursor on ?
	       JNE  LJCUR			  ;cursor is already on, don't turn it on ;=W
	       CALL CURSOR			  ;display cursor			      ;=W
LJCUR:
;
	       RET
LEFT_JUST      ENDP
;-----------------------------------------------------------------------------+
;									      :
; CAL_COORS								      :
;									      :
;	 Calculates character coordinates based on the display format	      :
;	 currently active (windowing and horizontal display).		      :
;									      :
;	 The following examples demonstrate the values that are set on	      :
;	 exit from this routine:					      :
;									      :
;									      :
;	 Example: Horizontal field coordinates calculated.		      :
;									      :
;		  			      :
;		  123456789012345678901234567890			      :
;		  2							      :
;		  3	   [sLtLtssss....]				      :
;			       ^					      :
;			          					      :
;			           WR_ENCHAR = 7			      :
;			             WR_ENBYTE = 9			      :
;			             WR_RGCHAR = 7			      :
;			      					      :
;			       WR_CUCHAR = 3			      :
;			    	       WR_CUBYTE = 4			      :
;			    	       WR_UPCHAR = 3			      :
;			    	       WR_DNCHAR = 3			      :
;			    	       WR_CURROW = 3			      :
;			    	       WR_CURCOL = 13			      :
;			    						      :
;			     WR_LFCHAR = 1			      :
;				       WR_HRCHAR = 1			      :
;									      :
;									      :
;	 Example: Horizontal field scroll coordinates calculated:	      :
;									      :
;		  			      :
;		  123456789012345678901234567890			      :
;		  2	     Ŀ					      :
;		  3	    sLtLt Ltsss.....				      :
;			    					      :
;			      ^					      :
;			      					      :
;			      	 WR_ENCHAR = 7 		      :
;			      	  WR_ENBYTE = 10		      :
;			      	  WR_RGCHAR = 7 		      :
;			      					      :
;			       WR_CUCHAR = 3 		      :
;			      	  WR_CUBYTE = 4 		      :
;			      	  WR_UPCHAR = 3 		      :
;			      	  WR_DNCHAR = 3 		      :
;			      	  WR_CURROW = 3 		      :
;			      	  WR_CURCOL = 14		      :
;			      					      :
;			      WR_HRCHAR = 2 		      :
;			    						      :
;			     WR_LFCHAR = 1 		      :
;									      :
;									      :
;									      :
;	 Example: Windowed field coordinates calculated.		      :
;									      :
;		  			      :
;		  123456789012345678901234567890			      :
;		  2		      WR_LFCHAR=	6	      :
;		  3		     	   WR_UPCHAR=	3	      :
;		  4		      ĳĿ				      :
;		  5		      ABCDE				      :
;		  6		     FGHI.				      :
;		  7		        ڳ WR_RGCHAR= 10	      :
;		  8		       ĳ WR_ENCHAR=	9	      :
;		  9			 				      :
;					  WR_CUCHAR=	8	      :
;					 	  WR_CURCOL= 24	      :
;					 	  WR_CURROW=	6	      :
;					 				      :
;					  WR_DNCHAR= 13	      :
;									      :
;									      :
; Entry: ICB_CURCHAR   = The character position into the input field from     :
;			 which the exit coordinates will be calculated.       :
;									      :
;	 WR_HRCHAR     = The character position into the input field that     :
;			 is currently the first displayed character of the    :
;			 horizontal window.				      :
;									      :
;	 ICB_WIDTH     = The width of windowed or horizontal scroll field.    :
;									      :
;	 ICB_FIELDLEN  = Input field buffer length.			      :
;									      :
;	 ICB_FIELDOFF  = Input field buffer offset.			      :
;									      :
;	 ICB_FIELDSEG  = Input field buffer segment.			      :
;									      :
;									      :
; Exit:  WR_RGCHAR     = Character offset into input buffer of the character  :
;			 appearing at the beginning of the current line that  :
;			 WR_CUCHAR is located on.			      :
;									      :
;	 WR_LFCHAR     = Character offset into input buffer of the character  :
;			 appearing at the end of the current line that	      :
;			 WR_CUCHAR is located on.			      :
;									      :
;	 WR_UPCHAR     = Character offset into input buffer of the character  :
;			 displayed directly above the position that	      :
;			 WR_CUCHAR is located on.			      :
;									      :
;	 WR_DNCHAR     = Character offset into input buffer of the character  :
;			 displayed directly below the position that	      :
;			 WR_CUCHAR is located on.			      :
;									      :
;	 WR_ENCHAR     = Number of characters currently entered in the	      :
;			 field.  This value may be less than the number       :
;			 of bytes used to represent the characters if	      :
;			 double byte characters are present.		      :
;									      :
;	 WR_CURROW     = Actual row offset into the video buffer of the       :
;			 character specified by WR_CURCHAR.		      :
;									      :
;	 WR_CURCOL     = Actual column offset into the video buffer of the    :
;			 character specified by WR_CUCHAR.		      :
;									      :
;	 WR_ENBYTE     = Number of bytes currently used to represent	      :
;			 entered characters in the buffer.  This counter      :
;			 can be used to calculate the current end	      :
;			 position of the entered data in the field.	      :
;									      :
;	 WR_CUBYTE     = Number of bytes into input field where WR_CUCHAR     :
;			 appears.					      :
;									      : 	 ;=W
;	 WR_CUCHAR     = Offset of current cursor position in input field.    : 	 ;=W
;									      : 	 ;=W
;	 WR_HRBYTE     = Number of bytes into input field where WR_HRCHAR     :
;			 appears.					      :
;									      :
;	 WR_FIELDEND   = Boolean flag,	 0 = cursor not past end of field     : 	 ;=W
;					 1 = cursor is past end of field      : 	 ;=W
;									      :
;-----------------------------------------------------------------------------+
;
CAL_COORS      PROC NEAR
;
	       PUSH AX			     ;save registers
	       PUSH BX
	       PUSH CX
	       PUSH DX
	       PUSH ES
	       PUSH SI
	       PUSH BP									 ;=W
;											 ;=W
; initialize general variables for all display modes					 ;=W
;
	       MOV  [DI]+WR_FIELDEND,0	     ;initialize boolean flag that		 ;=W
					     ;cursor is not past end of field		 ;=W
	       MOV  AX,ES:[SI]+ICB_CURCHAR   ;get current char. offset			 ;=W
	       MOV  [DI]+WR_CUCHAR,AX	     ;save it					 ;=W
;
	       MOV  AX,ES:[SI]+ICB_ROW	     ;initialize row offset of field		 ;=W
	       DEC  AX									 ;=W
	       MOV  [DI]+WR_CURROW,AX	     ;char row offset inot video buf		 ;=W
	       MOV  AX,ES:[SI]+ICB_COL	     ;initialize col offset of field		 ;=W
	       DEC  AX									 ;=W
	       MOV  [DI]+WR_CURCOL,AX	     ;char col offset into video buf		 ;=W
;
	       MOV  [DI]+WR_LFCHAR,1	     ;leftmost character possible char		 ;=W
	       MOV  [DI]+WR_RGCHAR,1	     ;rightmost character possible char 	 ;=W
	       MOV  [DI]+WR_ENBYTE,0	     ;end byte of data in input buffer		 ;=W
	       MOV  [DI]+WR_ENCHAR,0	     ;end character in input buffer		 ;=W
	       MOV  [DI]+WR_HRBYTE,1	     ;byte of first char in horz. window	 ;=W
;
	       MOV  AX,[DI]+WR_CUCHAR	     ;get current position			 ;=W
	       MOV  [DI]+WR_UPCHAR,1	     ;topmost char in current column		 ;=W
	       MOV  [DI]+WR_DNCHAR,1	     ;bottommost char in current column 	 ;=W
;
	       MOV  BP,0		     ;have not found current char yet		 ;=W
	       MOV  CX,1		     ;counter tracking number of bytes		 ;=W
	       MOV  DX,1		     ;counter tracking number of chars		 ;=W
;
; Determine display format of field
;
	       TEST ES:[SI]+ICB_OPT3,ICB_WIN ;check if windowing option on
	       JE   CC10
;
	       JMP  CC200		     ;process window option
;
CC10:	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;check if horizontal scroll option
	       JE   CC20		     ; on
;
	       JMP  CC100		     ;process horizontal scroll
;
; Process fully displayed horizontal field
;
CC20:											 ;=W
	       MOV  [DI]+WR_HRCHAR,1	     ;leftmost character possible char
;
; Examine the next byte in the input buffer
;
CC30:	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;check if entire field has been
	       JBE  CC35		     ; scanned and exit
;
	       CMP  BP,0		     ;found current char yet ?			 ;=W
	       JE   CC40		     ;no, find it				 ;=W
	       JMP  CCEXIT
;
CC35:	       PUSH ES			     ;save registers
	       PUSH SI
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer
	       POP  SI
	       POP  ES
;
	       DEC  CX			     ;make byte count zero based
	       ADD  SI,CX		     ;add byte count to input fld offst
	       INC  CX			     ;make byte count one based
	       MOV  AL,ES:[SI]		     ;get byte in input buffer to
	       MOV  [DI]+DBC_KS,AL	     ; check if DBCS
	       CALL PCINDBC_CALL	     ;call routine to check if char
					     ; is lead double byte char
;
	       POP  SI			     ;restore registers
	       POP  ES
;
; Check if end data byte and character should be updated
;
	       CMP  AL,WR_BLANK 	     ;check if blanking character found
	       JE   CC40		     ;now adjust pointers
;
	       MOV  [DI]+WR_ENBYTE,CX	     ;set current byte count
	       MOV  [DI]+WR_ENCHAR,DX	     ;set current character count
	       MOV  [DI]+WR_RGCHAR,DX	     ;set right most character
;
; Check if current character pointer
;
CC40:	       CMP  [DI]+WR_CUCHAR,DX	     ;check if current character found
	       JNE  CC50
;
	       MOV  BP,1		     ;current char found			 ;=W
	       MOV  [DI]+WR_UPCHAR,DX	     ;set up and down character
	       MOV  [DI]+WR_DNCHAR,DX	     ; to current character
;
	       MOV  [DI]+WR_CUBYTE,CX	     ;set current character byte count
	       ADD  [DI]+WR_CURCOL,CX	     ;set actual column of cursor based
	       DEC  [DI]+WR_CURCOL	     ; on current character byte count		 ;=W
;
; Increment pointers and counters to next character and byte position check
;
CC50:	       INC  CX			     ;adjust byte counter
	       INC  DX			     ;adjust character counter
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if byte is leading DBC byte
	       JE   CC30
;
	       INC  CX			     ;adjust byte count for trail byte
	       JMP  CC30





;
; Calculate horizontal scroll coordinates
;
CC100:
	       MOV  AX,[DI]+WR_CUCHAR	     ;initialize current character
	       CMP  AX,[DI]+WR_HRCHAR	     ;horizontal display position must
	       JAE  CC120		     ; not be less than current char
					     ; position
	       MOV  [DI]+WR_HRCHAR,AX	     ;set current char position as
					     ; new horizontal position
;
; Examine the next byte in the input buffer
;
CC120:	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;check if entire field has been
	       JBE  CC122		     ; scanned and exit 			 ;=W
;
	       CMP  BP,0		     ;found current char yet ?			 ;=W
	       JE   CC130		     ;no, find it				 ;=W
;
	       JMP  CCEXIT								 ;=W
CC122:											 ;=W
	       PUSH ES			     ;save registers
	       PUSH SI
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer
	       POP  SI
	       POP  ES
;
	       DEC  CX			     ;make byte count zero based
	       ADD  SI,CX		     ;add byte count to input fld offst
	       INC  CX			     ;make byte count one based
	       MOV  AL,ES:[SI]		     ;get byte in input buffer to
	       MOV  [DI]+DBC_KS,AL	     ; check if DBCS
	       CALL PCINDBC_CALL	     ;call routine to check if char
					     ; is lead double byte char
;
	       POP  SI			     ;restore registers
	       POP  ES
;											 ;=W
; Set WR_HRBYTE to correct byte count							 ;=W
;											 ;=W
	       CMP  [DI]+WR_HRCHAR,DX	     ;is this position the first char		 ;=W
					     ;in the horizl. window ?			 ;=W
	       JNE  CC125		     ;no					 ;=W
;
	       MOV  [DI]+WR_HRBYTE,CX	     ;save # byte for first char in h. wind.	 ;=W
;
; Check if end data byte and character should be updated
;
CC125:	       CMP  AL,WR_BLANK 	     ;check if blanking character found
	       JE   CC130		     ;now adjust pointers
;
	       MOV  [DI]+WR_ENBYTE,CX	     ;set current byte count
	       MOV  [DI]+WR_ENCHAR,DX	     ;set current character count
	       MOV  [DI]+WR_RGCHAR,DX	     ;set right most character
;
; Check if current character pointer
;
CC130:	       CMP  [DI]+WR_CUCHAR,DX	     ;check if current character found
	       JNE  CC140
;
	       MOV  BP,1		     ;current char found
	       MOV  [DI]+WR_UPCHAR,DX	     ;set up and down character
	       MOV  [DI]+WR_DNCHAR,DX	     ; to current character
;
	       MOV  [DI]+WR_CUBYTE,CX	     ;set current character byte count
	       MOV  BX,CX		     ;set actual column of cursor based 	 ;=W
					     ; on current character byte count		 ;=W
	       SUB  BX,[DI]+WR_HRBYTE	     ;subtract beginning of horiz. wind.	 ;=W
	       ADD  [DI]+WR_CURCOL,BX	     ;add to window offset = new column 	 ;=W
;
; Increment pointers and counters to next character and byte position check
;
CC140:	       INC  CX			     ;adjust byte counter
	       INC  DX			     ;adjust character counter
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if byte is leading DBC byte
	       JE   CC120
;
	       INC  CX			     ;adjust byte count for trail byte
	       JMP  CC120





;
; Calculate windowing coordinates							 ;=W
;
CC200:											 ;=W
;
; Examine the next byte in the input buffer						 ;=W
;
	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;check if entire field has been		 ;=W
	       JBE  CC235		     ; scanned and exit 			 ;=W
;
	       CMP  BP,0		     ;found current char yet ?			 ;=W
	       JE   CC240		     ;no, find it				 ;=W
;
	       JMP  CCBYE		     ;boolean flag should have been set 	 ;=W
					     ; already, if needed			 ;=W
CC235:	       PUSH ES			     ;save registers				 ;=W
	       PUSH SI									 ;=W
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ;get segment of input buffer		 ;=W
	       PUSH ES:[SI]+ICB_FIELDOFF     ;get offset of input buffer		 ;=W
	       POP  SI									 ;=W
	       POP  ES									 ;=W
;
	       DEC  CX			     ;make byte count zero based		 ;=W
	       ADD  SI,CX		     ;add byte count to input fld offst 	 ;=W
	       INC  CX			     ;make byte count one based 		 ;=W
	       MOV  AL,ES:[SI]		     ;get byte in input buffer to		 ;=W
	       MOV  [DI]+DBC_KS,AL	     ; check if DBCS				 ;=W
	       CALL PCINDBC_CALL	     ;call routine to check if char		 ;=W
					     ; is lead double byte char 		 ;=W
;
	       POP  SI			     ;restore registers 			 ;=W
	       POP  ES									 ;=W
;											 ;=W
; Check if end data byte and character should be updated				 ;=W
;											 ;=W
	       CMP  AL,WR_BLANK 	     ;check if blanking character found 	 ;=W
	       JE   CC240		     ;now adjust pointers			 ;=W
;
	       MOV  [DI]+WR_ENBYTE,CX	     ;set current byte count			 ;=W
	       MOV  [DI]+WR_ENCHAR,DX	     ;set current character count		 ;=W
	       MOV  [DI]+WR_RGCHAR,DX	     ;set right most character			 ;=W
;											 ;=W
; Check if current character pointer							 ;=W
;											 ;=W
CC240:
	       CMP  [DI]+WR_CUCHAR,DX	     ;check if current character found		 ;=W
	       JNE  CC250		     ;no					 ;=W
;
	       MOV  BP,1		     ;found current char
	       MOV  [DI]+WR_CUBYTE,CX	     ;set current character byte count		 ;=W
;
	       PUSH DX			     ;needed for division			 ;=W
	       MOV  AX,CX		     ;get current cursor pos. in field		 ;=W
	       DEC  AX			     ;make it zero based for divide		 ;=W
;
	       CMP  CX,ES:[SI]+ICB_FIELDLEN  ;are we past end of field ?		 ;=W
	       JLE  CC241		     ;no					 ;=W
	       MOV  [DI]+WR_FIELDEND,1	     ;yes, set boolean flag			 ;=W
	       DEC  AX			     ;make cursor pos. be inside field		 ;=W
					     ; for division				 ;=W
	       CWD			     ;calculate current row,column		 ;=W
	       IDIV ES:[SI]+ICB_WIDTH	     ; row = cur_byte / width-1 		 ;=W
					     ; col = cur_byte mod width-1		 ;=W
	       INC  DX			     ;reposition cursor in correct pos. 	 ;=W
	       JMP  CC244								 ;=W
CC241:											 ;=W
	       CWD			     ;calculate current row,column for		 ;=W
	       IDIV ES:[SI]+ICB_WIDTH	     ; cursor positions inside the field	 ;=W
					     ; row = cur_byte / width of field		 ;=W
					     ; col = cur_byte mod width of field	 ;=W
CC244:											 ;=W
	       ADD  [DI]+WR_CURROW,AX	     ;set actual row of cursor			 ;=W
	       ADD  [DI]+WR_CURCOL,DX	     ;set actual column of cursor		 ;=W
;
	       MOV  BX,CX		     ;calculate WR_LFCHAR			 ;=W
CC245:	       DEC  BX			     ;get the correct cur_byte			 ;=W
	       MOV  AX,BX		     ;cur_byte/width				 ;=W
	       CWD									 ;=W
	       IDIV ES:[SI]+ICB_WIDTH							 ;=W
	       CMP  DX,0		     ;is the remainder zero ?			 ;=W
	       JNE  CC245		     ;no, not at beginning of row, do again	 ;=W
;
	       MOV  [DI]+WR_LFCHAR,BX	     ;yes, this is beginning of row		 ;=W
;
	       POP  DX									 ;=W
;
; Increment pointers and counters to next character and byte position check		 ;=W
;											 ;=W
CC250:	       INC  CX			     ;adjust byte counter			 ;=W
	       INC  DX			     ;adjust character counter			 ;=W
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if byte is leading DBC byte 	 ;=W
	       JE   CC260								 ;=W
;
	       INC  CX			     ;adjust byte count for trail byte		 ;=W
CC260:
	       JMP  CC200								 ;=W
;
; Exit
;
CCEXIT: 										 ;=W
	       MOV  AX,[DI]+WR_CUBYTE	     ;is cursor past end of field		 ;=W
	       CMP  AX,ES:[SI]+ICB_FIELDLEN  ;??					 ;=W
	       JLE  CCBYE		     ;no					 ;=W
;
	       MOV  [DI]+WR_FIELDEND,1	     ;yes, set boolean flag			 ;=W
CCBYE:
	       MOV  AX,[DI]+WR_ENBYTE	     ;set ICB_ENDBYTE				 ;=W
	       MOV  ES:[SI]+ICB_ENDBYTE,AX						 ;=W
;
	       MOV  AX,[DI]+WR_HRBYTE	     ;set ICB_HRSTART				 ;=W
	       MOV  ES:[SI]+ICB_HRSTART,AX						 ;=W
;
	       POP  BP
	       POP  SI			     ;restore registers
	       POP  ES
	       POP  DX			     ;restore registers
	       POP  CX
	       POP  BX
	       POP  AX
;
	       RET
CAL_COORS      ENDP
;
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; SET_DISP_ADDR 							      : 	 ;=W
;									      : 	 ;=W
;	    Determine which display routine to use. The choice is between     : 	 ;=W
;	    left justified, right justified, double byte support, no double   : 	 ;=W
;	    byte support, windowing, horizontal scrolling.		      : 	 ;=W
;	    Also pick the justify routine to use.			      : 	 ;=W
;									      : 	 ;=W
;			     Ŀ			      : 	 ;=W
;			     	   DISPLAY				      : 	 ;=W
;			     			      : 	 ;=W
;	Ŀ 	      : 	 ;=W
;  Ŀ        		 Ŀ         	      : 	 ;=W
;  LEFT_DISP        		 RIGHT_DISP         	      : 	 ;=W
;          		          	      : 	 ;=W
;	 Ŀ 		       Ŀ  	      : 	 ;=W
;	 LEFT_H_DISP 		       RIGHT_H_DISP  	      : 	 ;=W
;	  		         	      : 	 ;=W
;		 Ŀ			       Ŀ	      : 	 ;=W
;		 LEFTS_DISP			       RIGHTS_DISP	      : 	 ;=W
;		 			       	      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; DISPLAY ROUTINES							      : 	 ;=W
;  LEFT_DISP	 - left justified, double byte support, windowing	      : 	 ;=W
;  LEFTS_DISP	 - left justified, no double byte support, windowing	      : 	 ;=W
;  LEFT_H_DISP	 - left justified, double byte support, horizontal scrolling  : 	 ;=W
;  RIGHT_DISP	 - right justified, double byte support, windowing	      : 	 ;=W
;  RIGHTS_DISP	 - right justified, no double byte support, windowing	      : 	 ;=W
;  RIGHT_H_DISP  - right justified, double byte support, horizontal scrolling : 	 ;=W
;									      : 	 ;=W
; JUSTIFY ROUTINES							      : 	 ;=W
;  LEFT_H_JUST	 - left justified, horizontal scrolling 		      : 	 ;=W
;  LEFT_JUST	 - left justified, windowing				      : 	 ;=W
;  RIGHT_H_JUST  - right justified, horizontal scrolling		      : 	 ;=W
;  RIGHT_JUST	 - right justified, windowing				      : 	 ;=W
;									      : 	 ;=W
; Entry:    ES:SI - ICB control block					      : 	 ;=W
;	    DS:DI - IN control block					      : 	 ;=W
; Exit:     none							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
SET_DISP_ADDR  PROC NEAR								 ;=W
;
	       PUSH AX									 ;=W
	       PUSH BX									 ;=W
;
	       TEST ES:[SI]+ICB_OPT1,ICB_RJU ;check if field right just 		 ;=W
	       JNE  SD20		     ;if yes, jump				 ;=W
;
; Display value of input buffer left justified						 ;=W
;
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;check if field is in horizontial		 ;=W
	       JE   SD10		     ;no,  windowing mode			 ;=W
;
	       MOV  AX,OFFSET LEFT_H_DISP						 ;=W
	       MOV  BX,OFFSET LEFT_H_JUST						 ;=W
;
	       JMP  SDEXIT								 ;=W
SD10:											 ;=W
	       MOV  AX,OFFSET LEFT_DISP 						 ;=W
	       MOV  BX,OFFSET LEFT_JUST 						 ;=W
;
	       TEST DS:[DI]+IN_OPT,IN_ADBCS  ;check if double byte is active		 ;=W
	       JNE  SDEXIT		     ;yes					 ;=W
	       MOV  AX,OFFSET LEFTS_DISP     ;no, single byte only			 ;=W
	       JMP  SDEXIT								 ;=W
;
; Display default value of input buffer right justified 				 ;=W
;
SD20:											 ;=W
	       TEST ES:[SI]+ICB_OPT3,ICB_HOR ;check if field is in horizontial		 ;=W
	       JE   SD30		     ;no,  windowing mode			 ;=W
;
	       MOV  AX,OFFSET RIGHT_H_DISP						 ;=W
	       MOV  BX,OFFSET RIGHT_H_JUST						 ;=W
;
	       JMP  SDEXIT								 ;=W
SD30:											 ;=W
	       MOV  AX,OFFSET RIGHT_DISP						 ;=W
	       MOV  BX,OFFSET RIGHT_DISP						 ;=W
;
	       TEST DS:[DI]+IN_OPT,IN_ADBCS  ;check if double byte is active		 ;=W
	       JNE  SDEXIT		     ;yes					 ;=W
	       MOV  AX,OFFSET RIGHTS_DISP    ;no, single byte only			 ;=W
;
SDEXIT: 										 ;=W
	       MOV  DS:[DI]+WR_DISPLAY,AX    ;save addr of routine to call		 ;=W
	       MOV  DS:[DI]+WR_JUSTIFY,BX    ;save addr of routine to call		 ;=W
;
	       POP  BX									 ;=W
	       POP  AX									 ;=W
;
	       RET									 ;=W
SET_DISP_ADDR  ENDP									 ;=W
;
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; RIGHTS_DISP								      : 	 ;=W
;									      : 	 ;=W
; Entry:								      : 	 ;=W
;									      : 	 ;=W
; Exit: 								      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
RIGHTS_DISP    PROC NEAR								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; code here								 ;=W
	       ;									 ;=W
;											 ;=W
	       RET									 ;=W
RIGHTS_DISP    ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; RIGHT_H_DISP								      :
;									      :
; Entry:								      :
;									      :
; Exit: 								      :
;									      :
;-----------------------------------------------------------------------------+
;
RIGHT_H_DISP   PROC NEAR
;
	       ;
	       ; code here
	       ;
;
	       RET
RIGHT_H_DISP   ENDP
;
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; RIGHT_DISP								      : 	 ;=W
;									      : 	 ;=W
; Entry:								      : 	 ;=W
;									      : 	 ;=W
; Exit: 								      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
RIGHT_DISP     PROC NEAR								 ;=W
;											 ;=W
	       ;									 ;=W
	       ; code here								 ;=W
	       ;									 ;=W
;											 ;=W
	       RET									 ;=W
RIGHT_DISP     ENDP									 ;=W
;											 ;=W
PAGE											 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; LEFT_H_DISP								      : 	 ;=W
;									      : 	 ;=W
;	  Calculates if the specified character will fit in the input	      : 	 ;=W
;	  buffer at the specified character position without display.	      : 	 ;=W
;	  The byte offset where this character should be inserted is	      : 	 ;=W
;	  returned or a flag indicating that the character will not fit.      : 	 ;=W
;									      : 	 ;=W
;	  Displays the specified portion of the input field buffer from       : 	 ;=W
;	  the left character marker to the end of the field.  The following   : 	 ;=W
;	  display options are handled by this routine:			      : 	 ;=W
;									      : 	 ;=W
;	  - Display of the input field in a wrapped window		      : 	 ;=W
;	  - Adjustment of double byte characters to prevent malformed	      : 	 ;=W
;	    characters							      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	  The following pointers are used:				      : 	 ;=W
;									      : 	 ;=W
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      : 	 ;=W
;	    				 buffer in memory.		      : 	 ;=W
;	    								      : 	 ;=W
;	    		 (WR_HRCHAR)	 Left marker delimiting the left      : 	 ;=W
;	    				 most character position in the       : 	 ;=W
;	    				 input buffer.			      : 	 ;=W
;	    								      : 	 ;=W
;	    								      : 	 ;=W
;	    								      : 	 ;=W
;	    								      : 	 ;=W
;	    								      : 	 ;=W
;	  Ŀ	      : 	 ;=W
;	   S  L  T  L  T  S  L  T  S  S  S  S       	      : 	 ;=W
;	  	      : 	 ;=W
;	    	      Ĵ	      : 	 ;=W
;	    	          Area to display (ICB_WIDTH)			      : 	 ;=W
;	    	      : 	 ;=W
;				     					      : 	 ;=W
;		ICB_FIELDLEN  Length of input field in bytes.		      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; Entry:  ES:SI        = Points to current ICB				      : 	 ;=W
;	  DS:DI        = Points to PB					      : 	 ;=W
;									      : 	 ;=W
;	  WR_CATTR     = Logical color attribute to use when updating screen  : 	 ;=W
;			 if the use of the color attribute string is not      : 	 ;=W
;			 specified.					      : 	 ;=W
;									      : 	 ;=W
;	  CR_RCOFF     = Beginning offset of the upper left input field       : 	 ;=W
;			 display corner from the beginning of the video       : 	 ;=W
;			 buffer.					      : 	 ;=W
;									      : 	 ;=W
;	  CR_SCRWIDTH  = Width of the video buffer in characters and	      : 	 ;=W
;			 attributes.					      : 	 ;=W
;									      : 	 ;=W
;	  WR_HRCHAR    = The offset into the input buffer, in characters,     : 	 ;=W
;			 of where to begin display.			      : 	 ;=W
;									      : 	 ;=W
; Exit:   (none)							      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
LEFT_H_DISP    PROC NEAR								 ;=W
;
	       PUSH ES			     ;save PB pointers				 ;=W
	       PUSH DI									 ;=W
	       PUSH BX									 ;=W
	       PUSH [DI]+CR_RCOFF	     ;save input field display offset		 ;=W
;											 ;=W
; Initialize MOVEG parm block								 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDOFF  ;get offset of the input buffer		 ;=W
	       MOV  [DI]+WR_FIELDOFF,AX 						 ;=W
											 ;=W
	       MOV  AX,ES:[SI]+ICB_FIELDSEG  ;get segment of the input buffer		 ;=W
	       MOV  [DI]+MG_TEXTSEG,AX							 ;=W
											 ;=W
	       MOV  AX,ES:[SI]+ICB_ATTROFF   ;get offset of color attribute buffer	 ;=W
	       MOV  [DI]+MG_ATTOFF,AX							 ;=W
											 ;=W
	       MOV  AX,ES:[SI]+ICB_ATTRSEG   ;get segment of color attribute		 ;=W
	       MOV  [DI]+MG_ATTSEG,AX	     ;buffer					 ;=W
											 ;=W
	       MOV  AX,[DI]+IN_LVBSEG	     ;get segment of the LVB			 ;=W
	       MOV  [DI]+MG_MIXSEG,AX							 ;=W
											 ;=W
	       MOV  AL,[DI]+WR_CATTR	     ;get logical color attribute		 ;=W
	       MOV  [DI]+MG_SOURCE_A,AL 						 ;=W
;											 ;=W
; Display all characters in input buffer starting with WR_HRCHAR			 ;=W
; and continuing until ICB_WIDTH-1 number of characters has been displayed.		 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDOFF  ;calcuate beginning character		 ;=W
	       ADD  AX,[DI]+WR_HRBYTE	     ;to display				 ;=W
	       DEC  AX									 ;=W
	       MOV  [DI]+WR_FIELDOFF,AX      ;save it					 ;=W
	       MOV  [DI]+MG_TEXTOFF,AX	     ; to display				 ;=W
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UA					 ;=W
					     ;set write attribute option		 ;=W
					     ;set use logical attribute option		 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active		 ;=W
	       JNE  LHD10								 ;=W
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option		 ;=W
LHD10:											 ;=W
	       MOV  AX,ES:[SI]+ICB_WIDTH     ;get field width				 ;=W
	       MOV  [DI]+MG_NUM,AX	     ;number of words to move into the		 ;=W
					     ; LVB					 ;=W
;
	       MOV  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of		 ;=W
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write			 ;=W
	       MOV  [DI]+MG_MIXOFF,AX							 ;=W
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s) 	 ;=W
;											 ;=W
; Check if last character is DBCS							 ;=W
;											 ;=W
	       PUSH ES									 ;=W
	       PUSH SI									 ;=W
;
	       MOV  AX,ES:[SI]+ICB_FIELDSEG ;get input buffer segment			 ;=W
	       MOV  BX,ES:[SI]+ICB_FIELDOFF ;get input buffer offset			 ;=W
	       ADD  BX,[DI]+WR_HRBYTE	    ;add offset of beginning of window		 ;=W
	       ADD  BX,ES:[SI]+ICB_WIDTH    ;add width to get last character		 ;=W
	       SUB  BX,2		    ;subtract to get correct byte		 ;=W
	       MOV  ES,AX								 ;=W
	       MOV  SI,BX								 ;=W
	       MOV  AL,ES:[SI]		    ;get the character				 ;=W
;
	       POP  SI									 ;=W
	       POP  ES									 ;=W
;
	       PUSH AX									 ;=W
	       MOV  [DI]+DBC_KS,AL							 ;=W
	       CALL PCINDBC_CALL	    ;check if char is lead DBCS 		 ;=W
	       POP  AX									 ;=W
	       TEST [DI]+DBC_STAT,DBC_DBCS  ;is it ?					 ;=W
	       JE   LHD30		    ;no, display the character			 ;=W
;
	       MOV  AL,1DH		    ;display '', can't split DBCS char          ;=W
;											 ;=W
; Display the last character								 ;=W
;											 ;=W
LHD30:											 ;=W
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UA					 ;=W
					     ;set write attribute option		 ;=W
					     ;set use logical attribute option		 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active		 ;=W
	       JNE  LHD40								 ;=W
;
	       OR   [DI]+MG_OPT,MG_WC+MG_UC  ;set write character option		 ;=W
LHD40:											 ;=W
	       MOV  [DI]+MG_SOURCE_C,AL      ;character to display			 ;=W
	       MOV  [DI]+MG_NUM,1	     ;number of words to move into the		 ;=W
					     ; LVB					 ;=W
;
	       MOV  AX,ES:[SI]+ICB_WIDTH     ;add width to get last character		 ;=W
	       MOV  BX,2								 ;=W
	       MUL  BX			     ;x2 to account for attr. bytes		 ;=W
	       ADD  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of		 ;=W
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write			 ;=W
	       SUB  AX,2		     ;subtract to get correct byte		 ;=W
	       MOV  [DI]+MG_MIXOFF,AX							 ;=W
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s) 	 ;=W
LHDEXIT:										 ;=W
	       POP  [DI]+CR_RCOFF	     ;save input field display offset		 ;=W
	       POP  BX			     ;restore registers 			 ;=W
	       POP  DI									 ;=W
	       POP  ES									 ;=W
;
	       RET									 ;=W
LEFT_H_DISP    ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+
;									      :
; LEFT_DISP								      :
;									      :
;	  Calculates if the specified character will fit in the input	      :
;	  buffer at the specified character position without display.	      :
;	  The byte offset where this character should be inserted is	      :
;	  returned or a flag indicating that the character will not fit.      :
;									      :
;	  Displays the specified portion of the input field buffer from       :
;	  the left character marker to the end of the field.  The following   :
;	  display options are handled by this routine:			      :
;									      :
;	  - Display of the input field in a wrapped window		      :
;	  - Adjustment of double byte characters to prevent malformed	      :
;	    characters							      :
;									      :
;									      :
;	  The following pointers are used:				      :
;									      :
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      :
;	    				 buffer in memory.		      :
;	    								      :
;	    		 (WR_LEFTCHAR) Left marker delimiting the left      :
;	    				 most character position in the       :
;	    				 input buffer.			      :
;	    								      :
;	    				 Right marker delimiting the right    :
;	    				 most character position in the       :
;	    				 input buffer.	 (WR_RIGHTCHAR)       :
;	    								      :
;	  Ŀ	      :
;	   S  L  T  L  T  S  L  T  S  S  S  S       	      :
;	  	      :
;	    	      Ĵ	      :
;	    	          Area to display				      :
;	    	      :
;				     					      :
;		ICB_FIELDLEN  Length of input field in bytes.		      :
;									      :
;									      :
; Entry:  ES:SI        = Points to current ICB				      :
;	  DS:DI        = Points to PB					      :
;									      :
;	  AX	     1 = This option will calculate if the specified number   :
;			 of bytes in BX can fit into input buffer at the      :
;			 specified character position considering the display :
;			 coordinates and options.  No update of the display   :
;			 screen will occur.  A flag indicating if the bytes   :
;			 can be inserted or not is returned.  If the bytes    :
;			 will fit the offset from the beginning of the input  :
;			 field in bytes is returned indicating where the      :
;			 characters should be inserted. 		      :
;									      :
;		     2 = This option will update the display screen in the    :
;			 proper format with the input buffer characters       :
;			 starting at the specified left offset character      :
;			 to the right character marker. 		      :
;									      :
;	  BX	       = Number of bytes to insert starting at the specified  :
;			 character position.				      :
;									      :
;	  WR_CATTR     = Logical color attribute to use when updating screen  :
;			 if the use of the color attribute string is not      :
;			 specified.					      :
;									      :
;	  CR_RCOFF     = Beginning offset of the upper left input field       :
;			 display corner from the beginning of the video       :
;			 buffer.					      :
;									      :
;	  CR_SCRWIDTH  = Width of the video buffer in characters and	      :
;			 attributes.					      :
;									      :
;	  WR_LEFTCHAR  = The offset into the input buffer, in characters,     :
;			 of where the specified bytes should fit.	      :
;									      :
;	  WR_RIGHTCHAR = The offset into the input buffer, in characters,     :
;			 of where the right most character position.	      :
;									      :
;									      :
; Exit:   If AX on entry is set to 1 then on exit:			      :
;									      :
;	  AX	     0 = The specified number of characters will fit.	      :
;		     1 = The specified number of characters will not fit.     :
;									      :
;	  WR_LEFTBYTE  = The offset into the input buffer, in bytes, of the   :
;			 left most character position.			      :
;									      :
;	  WR_RIGHTBYTE = The offset into the input buffer, in bytes, of the   :
;			 right most character position. 		      :
;									      :
;									      :
;	 If AX on entry is set to 2 then the input field buffer is	      :
;	 displayed on the screen.					      :
;									      :
;-----------------------------------------------------------------------------+
;
LEFT_DISP      PROC NEAR
;
	       PUSH ES			     ;save PB pointers
	       PUSH DI
	       PUSH BX
	       PUSH [DI]+CR_RCOFF	     ;save input field display offset
;
	       CALL LEFT_DISP_INIT	     ;initialize internal counter & vars	 ;=W
;
	       JMP  LF20		     ;begin of first row
;
; Start a new row in LVB
;
LF10:	       MOV  AX,[DI]+CR_RCOFF	     ;set ptr into LVB to next row.
	       ADD  AX,[DI]+CR_SCRWIDTH      ; Start with current position in
	       SUB  AX,ES:[SI]+ICB_WIDTH     ; LVB, add screen width in text
	       SUB  AX,ES:[SI]+ICB_WIDTH     ; and attributes, then subtract
	       MOV  [DI]+CR_RCOFF,AX	     ; the length of the input field
					     ; twice since length is just in
					     ; text chars
;
; Do not start new row
;
LF20:	       MOV  AX,ES:[SI]+ICB_WIDTH     ;counter contains number of bytes
	       MOV  [DI]+WR_CNTR2,AX	     ; available in current row of
					     ; input field
;
; Prepare to place next byte into LVB, verify chars remaining in input buffer
;
LF30:	       MOV  AX,[DI]+WR_CNTR3	     ;check if last character has been
	       CMP  [DI]+WR_RIGHTCHAR,AX     ; written in LVB (rightmost)
	       JGE  LF40		     ;if not last char jump ?
;
	       JMP  LF160		     ;yes, last character written
					     ; prepare to exit
;
; Check if end of field on display has been reached
;
LF40:	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;loop if number chars moved is
	       CMP  [DI]+WR_CNTR1,AX	     ; less than input buffer length
	       JLE  LF50		     ;
;
	       JMP  LF160
;
; Not complete
;
LF50:	       CMP  [DI]+WR_CNTR2,0	     ;loop while number of bytes
	       JE   LF10		     ; remaining in the row is greater
					     ; than zero, jump if bytes avail
;
	       CMP  [DI]+WR_MOVE,1	     ;check if entry option is to
	       JNE  LF60		     ; determine if bytes may be
					     ; inserted in displayed field
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if insertion calculations
	       CMP  [DI]+WR_CNTR3,AX	     ; should begin by comparing
	       JNE  LF60		     ; current counter with beginning
					     ; left character marker
;
	       MOV  AL,1		     ;check if insertion calculations
	       CMP  [DI]+WR_INSDONE,AL	     ; are complete
	       JE   LF60		     ;if yes, jump
;
; Adjust counters after pretending to insert a character into string and LVB
;
	       MOV  AX,[DI]+WR_BYTESINST     ;dec number bytes avail in row
	       ADD  [DI]+WR_CNTR1,AX	     ;inc number bytes moved into LVB
	       SUB  [DI]+WR_CNTR2,AX	     ;dec number bytes remaining in row
	       MOV  [DI]+WR_INSDONE,1	     ;set flag indicating insert calc
	       JMP  LF30		     ; complete
;
; Determine if current byte is a DBCS lead byte
;
LF60:	       MOV  BX,[DI]+WR_FIELDOFF      ;get the current byte in the
;
	       PUSH ES			     ;save registers
	       PUSH SI
;
	       PUSH ES:[SI]+ICB_FIELDSEG     ; input field buffer
	       PUSH [DI]+WR_FIELDOFF	     ;get the current byte in the
	       POP  SI
	       POP  ES
;
	       MOV  AL,ES:[SI]		     ;get character in input buffer
;
	       POP  SI			     ;restore registers
	       POP  ES
;
	       MOV  [DI]+DBC_KS,AL
;
	       CALL PCINDBC_CALL	     ;call routine to check if char
					     ; is lead double byte char
;
	       TEST [DI]+DBC_STAT,DBC_DBCS   ;check if char is lead DBCS
	       JNE  LF70		     ;if yes, jump to double byte code
;
	       JMP  LF130		     ;if no, jump to single byte code
;
; Current byte is leading byte of a double byte character
;
LF70:	       CMP  [DI]+WR_CNTR2,1	     ;check if there is room in current
	       JNE  LF80		     ; row for double byte character
;
	       JMP  LF110		     ;no room, adjust to next row
;
; Double byte character fits on current row
;
LF80:	       CMP  [DI]+WR_MOVE,2	     ;check if option to actually
	       JNE  LF100		     ; update display is active
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if character should be
	       CMP  [DI]+WR_CNTR3,AX	     ; displayed by verifying that
	       JL   LF100		     ; current character falls
					     ; between the left and right
	       MOV  AX,[DI]+WR_RIGHTCHAR     ; character markers
	       CMP  [DI]+WR_CNTR3,AX
	       JG   LF100
;
	       MOV  AX,[DI]+WR_FIELDOFF      ;get offset of character(s)
	       MOV  [DI]+MG_TEXTOFF,AX	     ; to display
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC  ;set write attribute option
;
	       TEST ES:[SI]+ICB_OPT1,ICB_USC ;use attribute string
	       JNE  LF84
;
	       OR   [DI]+MG_OPT,MG_UA	     ;set use logical attribute option
;
LF84:	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;is option for password write
	       JNE  LF85		     ; active
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option
;
LF85:	       MOV  [DI]+MG_NUM,2	     ;number of words to move into LVB
	       MOV  AX,[DI]+IN_LVBOFF	     ;set actual offset into LVB
	       ADD  AX,[DI]+CR_RCOFF	     ; where character(s) will be
	       MOV  [DI]+MG_MIXOFF,AX	     ; written
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write characters
;
; Adjust pointers and counters after moving double byte character
;
LF100:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left
	       CMP  AX,[DI]+WR_LEFTCHAR      ; byte positions of the right and
	       JNE  LF104		     ; left chars.  See if the current
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the left char, if so
	       MOV  [DI]+WR_LEFTBYTE,AX      ; store the byte offset, WR_CNTR4,
	       JMP  LF106		     ; into WR_LEFTBYTE
;
; Update right byte marker
;
LF104:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left
	       CMP  AX,[DI]+WR_RIGHTCHAR     ; byte positions of the right and
	       JNE  LF106		     ; left chars.  See if the current
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the right char, if so
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; store the byte offset, WR_CNTR4,
					     ; into WR_RIGHTBYTE
;
LF106:	       ADD  [DI]+WR_FIELDOFF,2	     ;inc number bytes moved from input
					     ; buffer
	       ADD  [DI]+CR_RCOFF,4	     ;inc pointer into LVB
	       ADD  [DI]+WR_CNTR1,2	     ;inc number of bytes moved into
					     ; LVB
	       SUB  [DI]+WR_CNTR2,2	     ;dec number of bytes remain
	       INC  [DI]+WR_CNTR3	     ;inc number of characters moved
					     ; into LVB from input string
	       ADD  [DI]+WR_CNTR4,2	     ;inc number of bytes moved from
	       JMP  LF30		     ; input string
;
; Blank fill remaining screen character positions on current row to prevent
;  double byte character from being split
;
LF110:	       CMP  [DI]+WR_MOVE,2	     ;check if option to update display
	       JNE  LF120		     ; is active
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if current character
	       CMP  [DI]+WR_CNTR3,AX	     ; should be displayed by verifying
	       JL   LF120		     ; that the character falls
					     ; within  the left and right
	       MOV  AX,[DI]+WR_RIGHTCHAR     ; character markers
	       CMP  [DI]+WR_CNTR3,AX
	       JG   LF120
;
	       MOV  AL,WR_BLANK 	     ;get blanking character
	       MOV  [DI]+MG_SOURCE_C,AL
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UC
					     ;set write attr, char and syn chk
	       TEST ES:[SI]+ICB_OPT1,ICB_USC
	       JNE  LF114		     ;use attribute string
;
	       OR   [DI]+MG_OPT,MG_UA	     ;set use logical attribute option
;
LF114:	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active
	       JNE  LF115
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option
;
LF115:	       MOV  [DI]+MG_NUM,1	     ;number of words to move into the
					     ; LVB
	       MOV  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write
	       MOV  [DI]+MG_MIXOFF,AX
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s)
;
; Adjust pointers and counters after writing blanking character to LVB
;
LF120:	       ADD  [DI]+CR_RCOFF,2	     ;inc pointer into the LVB
	       INC  [DI]+WR_CNTR1	     ;inc number of bytes moved into
					     ; the LVB
	       DEC  [DI]+WR_CNTR2	     ;dec number of bytes remaining in
	       JMP  LF10		     ; the current row
;
; Byte is a single byte character
;
LF130:	       CMP  [DI]+WR_MOVE,2	     ;check if option to update display
	       JNE  LF150		     ; is active
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if current character
	       CMP  [DI]+WR_CNTR3,AX	     ; should be displayed by verifying
	       JL   LF150		     ; that the character falls
;
	       MOV  AX,[DI]+WR_RIGHTCHAR     ; character markers
	       CMP  [DI]+WR_CNTR3,AX
	       JG   LF150
;
	       MOV  AX,[DI]+WR_FIELDOFF      ;get offset of character(s)
	       MOV  [DI]+MG_TEXTOFF,AX	     ; to display
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UA
					     ;set write attribute option
					     ;set use logical attribute option
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active
	       JNE  LF135
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option
;
LF135:	       MOV  [DI]+MG_NUM,1	     ;number of words to move into the
					     ; LVB
;
	       MOV  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write
	       MOV  [DI]+MG_MIXOFF,AX
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s)
;
; Adjust pointers and counters after moving single byte character
;
LF150:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left
	       CMP  AX,[DI]+WR_LEFTCHAR      ; byte positions of the right and
	       JNE  LF154		     ; left chars.  See if the current
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the left char, if so
	       MOV  [DI]+WR_LEFTBYTE,AX      ; store the byte offset, WR_CNTR4,
	       JMP  LF156		     ; into WR_LEFTBYTE
;
; Update right byte marker
;
LF154:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left
	       CMP  AX,[DI]+WR_RIGHTCHAR     ; byte positions of the right and
	       JNE  LF156		     ; left chars.  See if the current
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the right char, if so
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; store the byte offset, WR_CNTR4,
					     ; into WR_RIGHTBYTE
;
LF156:	       INC  [DI]+WR_FIELDOFF	     ;inc pointer input buffer
	       ADD  [DI]+CR_RCOFF,2	     ;inc pointer into LVB
	       INC  [DI]+WR_CNTR1	     ;inc counter with number bytes
					     ; moved into LVB
	       DEC  [DI]+WR_CNTR2	     ;dec counter with number of bytes
					     ; remaining in current row
	       ADD  [DI]+WR_CNTR3,1	     ;inc counter with number of chars
					     ; moved into the LVB from input
					     ; buffer
	       ADD  [DI]+WR_CNTR4,1	     ;inc counter with number of bytes
	       JMP  LF30		     ; moved into the LVB from input
					     ; buffer
;
; Completed updating LVB, adjust pointers
;
LF160:	       CMP  [DI]+WR_MOVE,1	     ;Check if option to calculate
	       JNE  LFEXIT		     ; if chars fit in buffer
;
; Set up proper return values for insert calculation
;
	       MOV  AX,1		     ;set flag indicating insert did
					     ; not fit
	       MOV  BX,[DI]+WR_CNTR3	     ;see if input field fit into LVB
	       DEC  BX			     ; by comparing the right char
	       CMP  [DI]+WR_RIGHTCHAR,BX     ; number with the number of chars
	       JNE  LFEXIT		     ; moved into the LVB.  If they
					     ; are equal the string fit into
					     ; the LVB.
	       CMP  [DI]+WR_INSDONE,1	     ;see if insert has been done
	       JE   LF170		     ;if yes set up return values
;
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;if no, then insert is at end of
	       SUB  BX,[DI]+WR_CNTR1	     ; line i.e. past right char
	       INC  BX			     ;see if there is enough room left
	       CMP  BX,[DI]+WR_BYTESINST     ; to display char being inserted
	       JL   LFEXIT
;
LF170:	       MOV  AX,0		     ;set flag indicating insert fits
;
; Restores the registers to entry values and exits
;
LFEXIT:        POP  [DI]+CR_RCOFF	     ;save input field display offset
;
	       POP  BX			     ;restore registers
	       POP  DI
	       POP  ES
;
	       RET
LEFT_DISP      ENDP
;
PAGE
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
; LEFTS_DISP			     (no double byte support)		      : 	 ;=W
;									      : 	 ;=W
;	  Calculates if the specified character will fit in the input	      : 	 ;=W
;	  buffer at the specified character position without display.	      : 	 ;=W
;	  The byte offset where this character should be inserted is	      : 	 ;=W
;	  returned or a flag indicating that the character will not fit.      : 	 ;=W
;									      : 	 ;=W
;	  Displays the specified portion of the input field buffer from       : 	 ;=W
;	  the left character marker to the end of the field.  The following   : 	 ;=W
;	  display options are handled by this routine:			      : 	 ;=W
;									      : 	 ;=W
;	  - Display of the input field in a wrapped window		      : 	 ;=W
;	  - Adjustment of double byte characters to prevent malformed	      : 	 ;=W
;	    characters							      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	  The following pointers are used:				      : 	 ;=W
;									      : 	 ;=W
;	     (ICB_FIELDSEG:ICB_FIELDOFF) Beginning address of input	      : 	 ;=W
;	    				 buffer in memory.		      : 	 ;=W
;	    								      : 	 ;=W
;	    		 (WR_LEFTCHAR) Left marker delimiting the left      : 	 ;=W
;	    				 most character position in the       : 	 ;=W
;	    				 input buffer.			      : 	 ;=W
;	    								      : 	 ;=W
;	    				 Right marker delimiting the right    : 	 ;=W
;	    				 most character position in the       : 	 ;=W
;	    				 input buffer.	 (WR_RIGHTCHAR)       : 	 ;=W
;	    								      : 	 ;=W
;	  Ŀ	      : 	 ;=W
;	   S  L  T  L  T  S  L  T  S  S  S  S       	      : 	 ;=W
;	  	      : 	 ;=W
;	    	      Ĵ	      : 	 ;=W
;	    	          Area to display				      : 	 ;=W
;	    	      : 	 ;=W
;				     					      : 	 ;=W
;		ICB_FIELDLEN  Length of input field in bytes.		      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; Entry:  ES:SI        = Points to current ICB				      : 	 ;=W
;	  DS:DI        = Points to PB					      : 	 ;=W
;									      : 	 ;=W
;	  AX	     1 = This option will calculate if the specified number   : 	 ;=W
;			 of bytes in BX can fit into input buffer at the      : 	 ;=W
;			 specified character position considering the display : 	 ;=W
;			 coordinates and options.  No update of the display   : 	 ;=W
;			 screen will occur.  A flag indicating if the bytes   : 	 ;=W
;			 can be inserted or not is returned.  If the bytes    : 	 ;=W
;			 will fit the offset from the beginning of the input  : 	 ;=W
;			 field in bytes is returned indicating where the      : 	 ;=W
;			 characters should be inserted. 		      : 	 ;=W
;									      : 	 ;=W
;		     2 = This option will update the display screen in the    : 	 ;=W
;			 proper format with the input buffer characters       : 	 ;=W
;			 starting at the specified left offset character      : 	 ;=W
;			 to the right character marker. 		      : 	 ;=W
;									      : 	 ;=W
;	  BX	       = Number of bytes to insert starting at the specified  : 	 ;=W
;			 character position.				      : 	 ;=W
;									      : 	 ;=W
;	  WR_CATTR     = Logical color attribute to use when updating screen  : 	 ;=W
;			 if the use of the color attribute string is not      : 	 ;=W
;			 specified.					      : 	 ;=W
;									      : 	 ;=W
;	  CR_RCOFF     = Beginning offset of the upper left input field       : 	 ;=W
;			 display corner from the beginning of the video       : 	 ;=W
;			 buffer.					      : 	 ;=W
;									      : 	 ;=W
;	  CR_SCRWIDTH  = Width of the video buffer in characters and	      : 	 ;=W
;			 attributes.					      : 	 ;=W
;									      : 	 ;=W
;	  WR_LEFTCHAR  = The offset into the input buffer, in characters,     : 	 ;=W
;			 of where the specified bytes should fit.	      : 	 ;=W
;									      : 	 ;=W
;	  WR_RIGHTCHAR = The offset into the input buffer, in characters,     : 	 ;=W
;			 of where the right most character position.	      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
; Exit:   If AX on entry is set to 1 then on exit:			      : 	 ;=W
;									      : 	 ;=W
;	  AX	     0 = The specified number of characters will fit.	      : 	 ;=W
;		     1 = The specified number of characters will not fit.     : 	 ;=W
;									      : 	 ;=W
;	  WR_LEFTBYTE  = The offset into the input buffer, in bytes, of the   : 	 ;=W
;			 left most character position.			      : 	 ;=W
;									      : 	 ;=W
;	  WR_RIGHTBYTE = The offset into the input buffer, in bytes, of the   : 	 ;=W
;			 right most character position. 		      : 	 ;=W
;									      : 	 ;=W
;									      : 	 ;=W
;	 If AX on entry is set to 2 then the input field buffer is	      : 	 ;=W
;	 displayed on the screen.					      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
;											 ;=W
LEFTS_DISP    PROC NEAR 								;=W
;
	       PUSH ES			     ;save PB pointers				 ;=W
	       PUSH DI									 ;=W
	       PUSH BX									 ;=W
	       PUSH [DI]+CR_RCOFF	     ;save input field display offset		 ;=W
;
	       CALL LEFT_DISP_INIT	     ;initialize internal counters & vars	 ;=W
;
	       JMP  LS20		     ;begin of first row			 ;=W
;											 ;=W
; Start a new row in LVB								 ;=W
;											 ;=W
LS10:	       MOV  AX,[DI]+CR_RCOFF	     ;set ptr into LVB to next row.		 ;=W
	       ADD  AX,[DI]+CR_SCRWIDTH      ; Start with current position in		 ;=W
	       SUB  AX,ES:[SI]+ICB_WIDTH     ; LVB, add screen width in text		 ;=W
	       SUB  AX,ES:[SI]+ICB_WIDTH     ; and attributes, then subtract		 ;=W
	       MOV  [DI]+CR_RCOFF,AX	     ; the length of the input field		 ;=W
					     ; twice since length is just in		 ;=W
					     ; text chars				 ;=W
;											 ;=W
; Do not start new row									 ;=W
;											 ;=W
LS20:	       MOV  AX,ES:[SI]+ICB_WIDTH     ;counter contains number of bytes		 ;=W
	       MOV  [DI]+WR_CNTR2,AX	     ; available in current row of		 ;=W
					     ; input field				 ;=W
;											 ;=W
; Prepare to place next byte into LVB, verify chars remaining in input buffer		 ;=W
;											 ;=W
LS30:	       MOV  AX,[DI]+WR_CNTR3	     ;check if last character has been		 ;=W
	       CMP  [DI]+WR_RIGHTCHAR,AX     ; written in LVB (rightmost)		 ;=W
	       JGE  LS40		     ;if not last char jump ?			 ;=W
;
	       JMP  LS160		     ;yes, last character written		 ;=W
					     ; prepare to exit				 ;=W
;											 ;=W
; Check if end of field on display has been reached					 ;=W
;											 ;=W
LS40:	       MOV  AX,ES:[SI]+ICB_FIELDLEN  ;loop if number chars moved is		 ;=W
	       CMP  [DI]+WR_CNTR1,AX	     ; less than input buffer length		 ;=W
	       JLE  LS50		     ;						 ;=W
;
	       JMP  LS160								 ;=W
;											 ;=W
; Not complete										 ;=W
;											 ;=W
LS50:	       CMP  [DI]+WR_CNTR2,0	     ;loop while number of bytes		 ;=W
	       JE   LS10		     ; remaining in the row is greater		 ;=W
					     ; than zero, jump if bytes avail		 ;=W
;
	       CMP  [DI]+WR_MOVE,1	     ;check if entry option is to		 ;=W
	       JNE  LS130		     ; determine if bytes may be		 ;=W
					     ; inserted in displayed field		 ;=W
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if insertion calculations		 ;=W
	       CMP  [DI]+WR_CNTR3,AX	     ; should begin by comparing		 ;=W
	       JNE  LS130		     ; current counter with beginning		 ;=W
					     ; left character marker			 ;=W
;
	       MOV  AL,1		     ;check if insertion calculations		 ;=W
	       CMP  [DI]+WR_INSDONE,AL	     ; are complete				 ;=W
	       JE   LS130		     ;if yes, jump				 ;=W
;											 ;=W
; Adjust counters after pretending to insert a character into string and LVB		 ;=W
;											 ;=W
	       MOV  AX,[DI]+WR_BYTESINST     ;dec number bytes avail in row		 ;=W
	       ADD  [DI]+WR_CNTR1,AX	     ;inc number bytes moved into LVB		 ;=W
	       SUB  [DI]+WR_CNTR2,AX	     ;dec number bytes remaining in row 	 ;=W
	       MOV  [DI]+WR_INSDONE,1	     ;set flag indicating insert calc		 ;=W
	       JMP  LS30		     ; complete 				 ;=W
;											 ;=W
; Byte is a single byte character							 ;=W
;											 ;=W
LS130:	       CMP  [DI]+WR_MOVE,2	     ;check if option to update display 	 ;=W
	       JNE  LS150		     ; is active				 ;=W
;
	       MOV  AX,[DI]+WR_LEFTCHAR      ;check if current character		 ;=W
	       CMP  [DI]+WR_CNTR3,AX	     ; should be displayed by verifying 	 ;=W
	       JL   LS150		     ; that the character falls 		 ;=W
					     ; within  the left and right		 ;=W
	       MOV  AX,[DI]+WR_RIGHTCHAR     ; character markers			 ;=W
	       CMP  [DI]+WR_CNTR3,AX							 ;=W
	       JG   LS150								 ;=W
;
	       MOV  AX,[DI]+WR_FIELDOFF      ;get offset of character(s)		 ;=W
	       MOV  [DI]+MG_TEXTOFF,AX	     ; to display				 ;=W
;
	       MOV  [DI]+MG_OPT,MG_WA+MG_SC+MG_UA					 ;=W
					     ;set write attribute option		 ;=W
					     ;set use logical attribute option		 ;=W
	       TEST ES:[SI]+ICB_OPT1,ICB_PSW ;check if password option active		 ;=W
	       JNE  LS135								 ;=W
;
	       OR   [DI]+MG_OPT,MG_WC	     ;set write character option		 ;=W
;
LS135:	       MOV  [DI]+MG_NUM,1	     ;number of words to move into the		 ;=W
					     ; LVB					 ;=W
;
	       MOV  AX,[DI]+IN_LVBOFF	     ;set the actual LVB offset of		 ;=W
	       ADD  AX,[DI]+CR_RCOFF	     ; the character to write			 ;=W
	       MOV  [DI]+MG_MIXOFF,AX							 ;=W
;
	       CALL PCMOVEG_CALL	     ;call PCMOVEG to write the char(s) 	 ;=W
;											 ;=W
; Adjust pointers and counters after moving single byte character			 ;=W
;											 ;=W
LS150:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left		 ;=W
	       CMP  AX,[DI]+WR_LEFTCHAR      ; byte positions of the right and		 ;=W
	       JNE  LS154		     ; left chars.  See if the current		 ;=W
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the left char, if so		 ;=W
	       MOV  [DI]+WR_LEFTBYTE,AX      ; store the byte offset, WR_CNTR4, 	 ;=W
	       JMP  LS156		     ; into WR_LEFTBYTE 			 ;=W
;											 ;=W
; Update right byte marker								 ;=W
;											 ;=W
LS154:	       MOV  AX,[DI]+WR_CNTR3	     ;LEFT returns the right and left		 ;=W
	       CMP  AX,[DI]+WR_RIGHTCHAR     ; byte positions of the right and		 ;=W
	       JNE  LS156		     ; left chars.  See if the current		 ;=W
;
	       MOV  AX,[DI]+WR_CNTR4	     ; char is the right char, if so		 ;=W
	       MOV  [DI]+WR_RIGHTBYTE,AX     ; store the byte offset, WR_CNTR4, 	 ;=W
					     ; into WR_RIGHTBYTE			 ;=W
LS156:	       INC  [DI]+WR_FIELDOFF	     ;inc pointer input buffer			 ;=W
	       ADD  [DI]+CR_RCOFF,2	     ;inc pointer into LVB			 ;=W
	       INC  [DI]+WR_CNTR1	     ;inc counter with number bytes		 ;=W
					     ; moved into LVB				 ;=W
	       DEC  [DI]+WR_CNTR2	     ;dec counter with number of bytes		 ;=W
					     ; remaining in current row 		 ;=W
	       ADD  [DI]+WR_CNTR3,1	     ;inc counter with number of chars		 ;=W
					     ; moved into the LVB from input		 ;=W
					     ; buffer					 ;=W
	       ADD  [DI]+WR_CNTR4,1	     ;inc counter with number of bytes		 ;=W
	       JMP  LS30		     ; moved into the LVB from input		 ;=W
					     ; buffer					 ;=W
;											 ;=W
; Completed updating LVB, adjust pointers						 ;=W
;											 ;=W
LS160:	       CMP  [DI]+WR_MOVE,1	     ;Check if option to calculate		 ;=W
	       JNE  LSEXIT		     ; if chars fit in buffer			 ;=W
;											 ;=W
; Set up proper return values for insert calculation					 ;=W
;											 ;=W
	       MOV  AX,1		     ;set flag indicating insert did		 ;=W
					     ; not fit					 ;=W
	       MOV  BX,[DI]+WR_CNTR3	     ;see if input field fit into LVB		 ;=W
	       DEC  BX			     ; by comparing the right char		 ;=W
	       CMP  [DI]+WR_RIGHTCHAR,BX     ; number with the number of chars		 ;=W
	       JNE  LSEXIT		     ; moved into the LVB.  If they		 ;=W
					     ; are equal the string fit into		 ;=W
					     ; the LVB. 				 ;=W
	       CMP  [DI]+WR_INSDONE,1	     ;see if insert has been done		 ;=W
	       JE   LS170		     ;if yes set up return values		 ;=W
;
	       MOV  BX,ES:[SI]+ICB_FIELDLEN  ;if no, then insert is at end of		 ;=W
	       SUB  BX,[DI]+WR_CNTR1	     ; line i.e. past right char		 ;=W
	       INC  BX			     ;see if there is enough room left		 ;=W
	       CMP  BX,[DI]+WR_BYTESINST     ; to display char being inserted		 ;=W
	       JL   LSEXIT								 ;=W
;
LS170:	       MOV  AX,0		     ;set flag indicating insert fits		 ;=W
;											 ;=W
; Restores the registers to entry values and exits					 ;=W
;											 ;=W
LSEXIT:        POP  [DI]+CR_RCOFF	     ;save input field display offset		 ;=W
;
	       POP  BX			     ;restore registers 			 ;=W
	       POP  DI									 ;=W
	       POP  ES									 ;=W
;
	       RET									 ;=W
LEFTS_DISP     ENDP									 ;=W
;
PAGE
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
;  DRAW_DEM								      : 	 ;=W
;	    Draw a input field delimiter				      : 	 ;=W
;									      : 	 ;=W
;  Entry:								      : 	 ;=W
;	   ES:SI  address of icon					      : 	 ;=W
;	   GC_ROW - character row to display delimiter			      : 	 ;=W
;	   GC_COL - character column to display delimiter		      : 	 ;=W
;									      : 	 ;=W
;  Exit:   None 							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
DRAW_DEM       PROC NEAR								 ;=W
;
	       PUSH AX									 ;=W
	       PUSH BX									 ;=W
	       PUSH CX									 ;=W
	       PUSH DX									 ;=W
	       PUSH DI									 ;=W
	       PUSH SI									 ;=W
	       PUSH DS									 ;=W
	       PUSH ES									 ;=W
	       PUSH BP									 ;=W
;
	       MOV  BP,AX
;
	       MOV  DX,300H + graph_addr						 ;=W
	       MOV  AH,2		     ; Write Mode 2				 ;=W
	       MOV  AL,5		     ; Write Mode Register			 ;=W
	       OUT  DX,AX								 ;=W
;
	       MOV  DL,seq_addr 							 ;=W
	       MOV  AH,0FFH		     ;enable all maps				 ;=W
	       MOV  AL,s_map		     ;map mask					 ;=W
	       OUT  DX,AX		     ;set the registers 			 ;=W
;
	       MOV  AX,[DI]+WR_ROWBYTES 						 ;=W
	       MOV  BX,50H								 ;=W
	       MUL  BX									 ;=W
											 ;=W
	       MOV  BX,[DI]+GC_ROW							 ;=W
	       MUL  BX									 ;=W
	       ADD  AX,[DI]+GC_COL							 ;=W
;
	       MOV  BH,[DI]+WR_CATTR	     ;get current color attribute		 ;=W
;
	       CMP  [DI]+WR_VIDMODE,11H      ;check for graphics mode 11H
	       JNE  DD05		     ;nop, continue
	       MOV  BH,0FH		     ;yes, mode 11 is only black &
;
DD05:	       MOV  CL,4		     ;count for shift				 ;=W
	       SHR  BX,CL		     ;separate background/foreground		 ;=W
	       MOV  CL,4		     ;count for shift				 ;=W
	       SHR  BL,CL		     ;put in low order nibble			 ;=W
	       XCHG BL,BH		     ;foreground/background are reversed	 ;=W
					     ; for delimiter
; BL = background color, BH = foreground color
	       CMP  BP,02		     ;check if we want to remove delimiters	 ;=W
	       JNE  DD10		     ;no, ok					 ;=W
	       MOV  BH,BL		     ;make both background color		 ;=W
											 ;=W
DD10:											 ;=W
	       MOV  CL,[DI]+WR_VIDMODE							 ;=W
	       MOV  DX,[DI]+IN_OPT
;
	       PUSH ES			     ;make DS:SI point to bit maps		 ;=W
	       POP  DS									 ;=W
;
	       MOV  DI,AX								 ;=W
	       MOV  AX,0A000H								 ;=W
	       MOV  ES,AX								 ;=W
;
	       TEST DX,IN_MCGA		     ;mode 11H, non-VGA hardware?
	       JNE  DD100		     ;if so, go do it
;---------------------------------------------						 ;=W
; Mode 10,11,12 with VGA		     :						 ;=W
;---------------------------------------------						 ;=W
	       MOV  DX,300H + graph_addr       ;graphics chip				 ;=W
	       XOR  CH,CH								 ;=W
;
	       MOV  AL,CL		       ;save vid mode
	       MOV  CL,0EH		       ;# pixel rows in delimiter		 ;=W
	       CMP  AL,10H		       ;are we in graphics mode 10H
	       JE   DD40		       ;yes, # rows ok
	       ADD  CL,2		       ;no, mode 11,12 have 16 pixel rows
DD40:					       ; instead of 14 pixel rows.
	       MOV  BP,02H		       ;# pixel columns/8 in delimiter		 ;=W
;
	       MOV  AH,0FFH								 ;=W
	       MOV  AL,g_bit_mask	       ;bit mask index				 ;=W
	       OUT  DX,AX		       ;set bit mask				 ;=W
DD50:											 ;=W
	       PUSH CX									 ;=W
	       PUSH DI									 ;=W
	       MOV  CX,BP								 ;=W
DD60:											 ;=W
	       MOV  AH,0FFH		       ;background				 ;=W
	       MOV  AL,g_bit_mask	       ;bit mask index				 ;=W
	       OUT  DX,AX		       ;set bit mask				 ;=W
;
	       MOV  AL,ES:[DI]		       ;latch data				 ;=W
	       MOV  ES:[DI],BH		       ;set the dot				 ;=W
;
	       LODSB			       ;foreground				 ;=W
	       XCHG AL,AH								 ;=W
;
	       MOV  AL,g_bit_mask	       ;bit mask index				 ;=W
	       OUT  DX,AX		       ;set bit mask				 ;=W
;
	       MOV  AL,ES:[DI]		       ;latch data				 ;=W
	       MOV  ES:[DI],BL		       ;set the dot				 ;=W
;
	       INC  DI									 ;=W
	       LOOP DD60								 ;=W
;
	       POP  DI									 ;=W
	       ADD  DI,LINELEN								 ;=W
	       POP  CX									 ;=W
	       LOOP DD50								 ;=W
	       JMP  DDEXIT								 ;=W
;---------------------------------------------						 ;=W
; Mode 11H with no VGA			     :						 ;=W
;---------------------------------------------						 ;=W
DD100:	       XOR  CH,CH
	       MOV  CL,10H		     ;# pixel rows in delimiter
	       MOV  BP,02H		     ;# of pixel columns in delimiter

DD110:	       PUSH CX
	       PUSH DI
;
	       MOV  CX,BP
;
DD120:	       LODSB			     ;get icon row
;
DD130:	       XOR  AL,0FFH
	       MOV  ES:[DI],AL		     ;set the dot
	       INC  DI
	       LOOP DD120
;
	       POP  DI
;
	       ADD  DI,50H		     ;line length, 80
;
	       POP  CX
;
	       LOOP DD110
;
DDEXIT:        POP  BP
	       POP  ES
	       POP  DS
	       POP  SI
	       POP  DI
	       POP  DX
	       POP  CX
	       POP  BX
	       POP  AX
;
	       RET
DRAW_DEM       ENDP
;
PAGE
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
;  GET_MONO_DOS 							      : 	 ;=W
;	    Get segment and offset of the DOS monocasing table and return it  : 	 ;=W
;									      : 	 ;=W
;  Entry:  None 							      : 	 ;=W
;									      : 	 ;=W
;  Exit:   None 							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
GET_MONO_DOS   PROC NEAR								 ;=W
;
	       PUSH SI			     ;save registers				 ;=W
	       PUSH ES									 ;=W
	       PUSH DI									 ;=W
;
	       MOV  AH,65H		     ;extended country info			 ;=W
	       MOV  AL,02H		     ;get uppercase table ptrs			 ;=W
	       MOV  BX,-1		     ;default code page 			 ;=W
	       MOV  DX,-1		     ;default country id			 ;=W
	       MOV  CX,05H		     ;# bytes returned				 ;=W
	       PUSH DS									 ;=W
	       POP  ES			     ;ES:DI ptrs to return buffer		 ;=W
	       MOV  DI,OFFSET WR_CUCHAR      ;use as temp buffer			 ;=W
;
	       INT  21H 								 ;=W
;
	       INC  DI			     ;skip info id				 ;=W
	       MOV  SI,DI		     ;we need DI so use SI			 ;=W
	       POP  DI									 ;=W
;
	       MOV  AX,WORD PTR [SI]	     ;get DOS monocasing table offset		 ;=W
	       MOV  [DI]+IN_MONOOFF,AX	     ;save it					 ;=W
	       ADD  SI,2								 ;=W
	       MOV  AX,WORD PTR [SI]	     ;get DOS monocasing table segment		 ;=W
	       MOV  [DI]+IN_MONOSEG,AX	     ;save it					 ;=W
;
	       POP  ES			     ;restore registers 			 ;=W
	       POP  SI									 ;=W
;
	       RET									 ;=W
GET_MONO_DOS   ENDP
;
PAGE
;-----------------------------------------------------------------------------+ 	 ;=W
;									      : 	 ;=W
;  GET_DBCS								      : 	 ;=W
;	    Get segment and offset of the DOS double byte support table.      : 	 ;=W
;									      : 	 ;=W
;  Entry:  DS:DI							      : 	 ;=W
;									      : 	 ;=W
;  Exit:   None 							      : 	 ;=W
;									      : 	 ;=W
;-----------------------------------------------------------------------------+ 	 ;=W
GET_DBCS       PROC NEAR								 ;=W
;
	       PUSH SI
	       PUSH ES									 ;=W
	       PUSH DI									 ;=W
	       PUSH DI									 ;=W
;
	       MOV  AH,65H		     ;get extended country info
	       MOV  AL,07H		     ;get DBCS environment table
	       INT  21H 		     ;DOS function call,vector returned
					     ; in ES:DI
	       POP  SI			     ;ptr, SI -> IN_PB
	       INC  DI			     ;skip over id byte returned
	       MOV  AX,WORD PTR ES:[DI]      ;get offset of DBCS table
	       MOV  [DI]+IN_DBCSOFF,AX	     ;save it
;
	       ADD  DI,2		     ;skip over offset to get segment
	       MOV  BX,WORD PTR ES:[DI]      ;get segment of DBCS table
	       MOV  [DI]+IN_DBCSSEG,BX	     ;save it
;
	       POP  DI
;
	       MOV  SI,AX		     ;Point to DBCS table to get length
	       MOV  ES,BX
	       MOV  AX,WORD PTR ES:[SI]
	       MOV  [DI]+IN_DBCSLEN,AX
	       ADD  [DI]+IN_DBCSOFF,2	     ;change offset to point to table
;
	       POP  ES
	       POP  SI
;
	       RET
GET_DBCS       ENDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\rombios.inc ===
; Definitions of interesting variables in ROM BIOS data segment at 40:0
;
; Revision History
; ================
; 7/13/90	md		Created


	ROMBIOS_DATA	segment AT 040h

	org 049h

CRT_Mode	db	?	; current screen mode
CRT_Cols	dw	?	; current number of columns

	org 084h

CRT_Rows	db	?	; current number of screen rows
DEFAULT_ROWS	equ	24	; standard default for screen height

	ROMBIOS_DATA	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\psdata.inc ===
;*******************************************************************
; Parser include file
;*******************************************************************
IF1					;AN000;
;        %OUT    INCLUDING COMP=COMMON DSN=PSDATA.INC...;AN000;
ENDIF					;AN000;

	INCLUDE version.inc

;
;**** Default assemble switches definition *************************

IFNDEF	FarSW				;AN000;
FarSW	equ	0			;AN000; Near call expected
ENDIF					;AN000;

IFNDEF	DateSW				;AN000;
DateSW	equ	1			;AN000; Check date format
ENDIF					;AN000;

IFNDEF	TimeSW				;AN000;
TimeSW	equ	1			;AN000; Check time format
ENDIF					;AN000;

IFNDEF	FileSW				;AN000;
FileSW	equ	1			;AN000; Check file specification
ENDIF					;AN000;

IFNDEF	CAPSW				;AN000;
CAPSW	equ	1			;AN000; Perform CAPS if specified
ENDIF					;AN000;

IFNDEF	CmpxSW				;AN000;
CmpxSW	equ	1			;AN000; Check complex list
ENDIF					;AN000;

IFNDEF	NumSW				;AN000;
NumSW	equ	1			;AN000; Check numeric value
ENDIF					;AN000;

IFNDEF	KeySW				;AN000;
KeySW	equ	1			;AN000; Support keywords
ENDIF					;AN000;

IFNDEF	SwSW				;AN000;
SwSW	equ	1			;AN000; Support switches
ENDIF					;AN000;

IFNDEF	Val1SW				;AN000;
Val1SW	equ	1			;AN000; Support value definition 1
ENDIF					;AN000;

IFNDEF	Val2SW				;AN000;
Val2SW	equ	1			;AN000; Support value definition 2
ENDIF					;AN000;

IFNDEF	Val3SW				;AN000;
Val3SW	equ	1			;AN000; Support value definition 3
ENDIF					;AN000;

IFNDEF	DrvSW				;AN000;
DrvSW	equ	1			;AN000; Support drive only format
ENDIF					;AN000;

IFNDEF	QusSW				;AN000;
QusSW	equ	1			;AN000; Support quoted string format
ENDIF					;AN000;

IFNDEF	LFEOLSW 			;AN028;
LFEOLSW EQU	1			;AN028; Accept Line feed (0AH) as end of line
ENDIF					;AN028;

;**** Equation field
;-------- Character code definition

$P_DBSP1	   equ	DB_SP_HI	;AN000; 1st byte of DBCS blank
$P_DBSP2	   equ	DB_SP_LO	;AN000; 2nd byte of DBCS blank
$P_Period	   equ	"."             ;AN020;
$P_Slash	   equ	"/"             ;AN020;
$P_Space	   equ	" "             ;AN000; SBCS blank
$P_Comma	   equ	","             ;AN000;
$P_Switch	   equ	"/"             ;AN000;
$P_Keyword	   equ	"="             ;AN000;
$P_Colon	   equ	":"             ;AN000;
$P_Plus 	   equ	"+"             ;AN000;
$P_Minus	   equ	"-"             ;AN000;
$P_Rparen	   equ	")"             ;AN000;
$P_Lparen	   equ	"("             ;AN000;
;(deleted ;AN025;) $P_SQuote	      equ  "'"
$P_DQuote	   equ	'"'             ;AN000;
$P_NULL 	   equ	0		;AN000;
$P_TAB		   equ	9		;AN000;
$P_CR		   equ	0Dh		;AN000;
$P_LF		   equ	0Ah		;AN000;
$P_ASCII80	   equ	80h		;AN000; ASCII 80h character code

;-------- Masks
$P_Make_Lower	   equ	20h		;AN000; make lower case character
$P_Make_Upper	   equ	0ffh-$P_Make_Lower ;AN000; make upper case character

		   PAGE 		   ;AN000;
;-------- DOS function call related equs

$P_DOS_Get_CDI	   equ	3800h		;AN000; get country dependent information
					; by this call, following information
$P_CDI		   struc		;AN000; is returned.
$P_CDI_DateF	   dw	0		;AN000;
$P_CDI_Money	   db	0,0,0,0,0	;AN000;
$P_CDI_1000	   db	0,0		;AN000;
$P_CDI_Dec	   db	0,0		;AN000;
$P_CDI_DateS	   db	0,0		;AN000;
$P_CDI_TimeS	   db	0,0		;AN000;
		   db	0		;AN000;
		   db	0		;AN000;
$P_CDI_TimeF	   db	0		;AN000;
		   dw	0,0		;AN000;
		   db	0,0		;AN000;
		   dw	5 dup(0)	;AN000;
$P_CDI		   ends 		;AN000;

$P_Date_MDY	   equ	0		;AN000;
$P_Date_DMY	   equ	1		;AN000;
$P_Date_YMD	   equ	2		;AN000;
;-------------
$P_DOS_GetEV	   equ	6300h		;AN000; get DBCS EV call
					;AN000; DS:SI will points to DBCS EV
;-------------
$P_DOS_Get_TBL	   equ	65h		;AN000; get uppercase table call
					;AN000; following parameters are set
					;AN000; to get casemap table.
$P_DOSTBL_Def	   equ	-1		;AN000; get default
$P_DOSTBL_BL	   equ	5		;AN000; buffer length for Tbl pointer
$P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
$P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
					; By this call following information
					; is returned.
$P_DOS_TBL	   struc		;AN000;
$P_DOS_InfoID	   db	0		;AN000; information id for the table
$P_DOS_TBL_Off	   dw	0		;AN000; offset address of the table
$P_DOS_TBL_Seg	   dw	0		;AN000; segment address of the table
$P_DOS_TBL	   ends 		;AN000;
		   PAGE 		;AN000;
;---------------------------------------------------------------------------------------------------------
; PARMS 	LABEL	BYTE
;		DW	PARMSX
;		DB	2			; NUMBER OF STRINGS (0, 1, 2)
;		DB	length			; LENGTH OF THE NEXT LIST, 0 IF NONE
;		DB	" .. "                  ; EXTRA DELIMITER LIST,
;						; TYPICAL ARE ";", "="
;						; "," & WHITESPACE ALWAYS
;		DB	length			; LENGTH OF THE NEXT LIST, 0 IF NONE
;		DB	" .. "                  ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
;---------------------------------------------------------------------------------------------------------

;-------------------------------- PARMS block structure
$P_PARMS_Blk	   struc		;AN000;
$P_PARMSX_Address  dw	0		;AN000; Address of PARMSX
$P_Num_Extra	   db	0		;AN000; Number of extra stuff
$P_Len_Extra_Delim db	0		;AN000; Length of extra delimiter
$P_PARMS_Blk	   ends 		;AN000;

$P_Len_PARMS	   equ	4		;AN000;
$P_I_Use_Default   equ	0		;AN000; no extra stuff specified
$P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
$P_I_Have_EOL	   equ	2		;AN000; extra EOL specified

;---------------------------------------------------------------------------------------------------------
; PARMSX	LABEL	BYTE
;		DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
;		DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
;		:				; REPEATS maxp-1 TIMES
;		DB	maxs			; # OF SWITCHES
;		DW	CONTROL 		; DESCRIPTION OF SWITCH 1
;		:				; REPEATS maxs-1 TIMES
;		DB	maxk			; # OF KEYWORD
;		DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
;		:				; REPEATS maxk-1 TIMES
;---------------------------------------------------------------------------------------------------------

;-------------------------------- PARMSX block structure
$P_PARMSX_Blk	   struc		;AN000;
$P_MinP 	   db	0		;AN000; Minimum positional number
$P_Maxp 	   db	0		;AN000; Maximum positional number
$P_1st_Control	   dw	0		;AN000; Address of the 1st CONTROL block
$P_PARMSX_Blk	   ends 		;AN000;
		   PAGE 		;AN000;
;---------------------------------------------------------------------------------------------------------
; << Control field definition  >>
;
;
;CONTROL   LABEL   BYTE
;	   DW	   MATCH_FLAGS	   ; CONTROLS TYPE MATCHED
;				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
;				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
;				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
;				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
;				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
;				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
;				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0010H=IGNORE ":" AT END IN MATCH
;				   ; 0002H=REPEATS ALLOWED
;				   ; 0001H=OPTIONAL
;	   DW	   FUNCTION_FLAGS
;				   ; 0001H=CAP RESULT BY FILE TABLE
;				   ; 0002H=CAP RESULT BY CHAR TABLE
;				   ; 0010H=REMOVE ":" AT END
; (tm10)			   ; 0020H=colon is not necessary for switch
;	   DW	   RESULT	   ; RESULT BUFFER
;	   DW	   VALUES	   ; VALUE LISTS
;	   DB	   nid		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
;	   DB	   "...",0         ; IF n >0, KEYWORD 1
;	   :
;
;Note:
;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
;      DATE bit simalteniously.
;
;      The parser examins each bit along with the following priority.
;
;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
;      FILE SPEC -> SIMPLE STRING.
;
;
;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
;      in the result buffer is capitalized.
;
;    - Match_Flags 0001H and 0002H have meaning only for the positional.
;
;
;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
;      switch, for example, '/A', then STRING points to;
;
;			DB    1 	; number of following synonyms
;			DB   '/A',0
;
;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
;
;			DB    1 	; number of following synonyms
;			DB   'CODEPAGE=',0
;
;
;    - "..." must consist of upper case characters only because the parser
;      performs pattern matching after converting input to upper case (by
;      using the current country upper case table)
;
;
;    - One "..." can contain only one switch or keyword. If you need, for
;      example /A and /B, the format will be;
;
;			DB    2 	; number of following synonyms
;			DB    '/A',0
;			DB    '/B',0
;---------------------------------------------------------------------------------------------------------

;**** Match_Flags

$P_Num_Val	   equ	8000h		;AN000; Numeric Value
$P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
$P_Simple_S	   equ	2000h		;AN000; Simple string
$P_Date_S	   equ	1000h		;AN000; Date string
$P_Time_S	   equ	0800h		;AN000; Time string
$P_Cmpx_S	   equ	0400h		;AN000; Complex string
$P_File_Spc	   equ	0200h		;AN000; File Spec
$P_Drv_Only	   equ	0100h		;AN000; Drive Only
$P_Qu_String	   equ	0080h		;AN000; Quoted string
$P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
$P_Repeat	   equ	0002h		;AN000; Repeat allowed
$P_Optional	   equ	0001h		;AN000; Optional

;**** Function flags

$P_CAP_File	   equ	0001h		;AN000; CAP result by file table
$P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
$P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
$P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10

;-------------------------------- Control block structure
$P_Control_Blk	   struc		;AN000;
$P_Match_Flag	   dw	0		;AN000; Controls type matched
$P_Function_Flag   dw	0		;AN000; Function should be taken
$P_Result_Buf	   dw	0		;AN000; Result buffer address
$P_Value_List	   dw	0		;AN000; Value list address
$P_nid		   db	0		;AN000; # of keyword/SW synonyms
$P_KeyorSW	   db	0		;AN000; keyword or sw
$P_Control_Blk	   ends 		;AN000;
		   PAGE 		;AN000;
;---------------------------------------------------------------------------------------------------------
; << Value List Definition >>
;
;VALUES 	LABEL	BYTE
;		DB	nval			; NUMBER OF VALUE DEFINITIONS (0 - 3)
;	     +-
;	     |	DB	nrng			; NUMBER OF RANGES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF RANGE MATCHED
;	     | +DD	X,Y			; RANGE OF VALUES
;	     |	:
;	     |	DB	nnval			; NUMBER OF CHOICES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF NUMBER CHOICE MATCHED
;	     | +DD	VALUE			; SPECIFIC CHOICE IF NUMBER
;	     |	:
;	     |	DB	nstrval 		; NUMBER OF CHOICES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF STRING CHOICE MATCHED
;	     | +DW	STRING			; SPECIFIC CHOICE IF STING
;	     +-	:
;
;STRING 	DB	"...",0                 ; ASCIIZ STRING IMAGE
;
;Note:
;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
;      when no choice lists are provided.
;
;    - STRING must consist of upper case characters only because the parser
;      performs pattern matching after converting input to upper case (by
;      using the current country upper case table)
;---------------------------------------------------------------------------------------------------------

$P_nval_None	   equ	0		;AN000; no value list ID
$P_nval_Range	   equ	1		;AN000; range list ID
$P_nval_Value	   equ	2		;AN000; value list ID
$P_nval_String	   equ	3		;AN000; string list ID
$P_Len_Range	   equ	9		;AN000; Length of a range choice(two DD plus one DB)
$P_Len_Value	   equ	5		;AN000; Length of a value choice(one DD plus one DB)
$P_Len_String	   equ	3		;AN000; Length of a string choice(one DW plus one DB)
$P_No_nrng	   equ	0		;AN000; (tm07) no nrng. nnval must not be 0.

$P_Val_List	   struc		;AN000;
$P_NumofList	   db	0		;AN000; number of following choice
$P_Val_XL	   dw	0		;AN000; lower word of value
$P_Val_XH	   dw	0		;AN000; higher word of value
$P_Val_YL	   dw	0		;AN000; lower word of another value
$P_Val_YH	   dw	0		;AN000; higher word of another value
$P_Val_List	   ends 		;AN000;
		   PAGE 		;AN000;
;---------------------------------------------------------------------------------------------------------
; << Result Buffer Definition  >>
;
;RESULT 	LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
;		DB	type			; TYPE RETURNED: 0=RESERVED,
;						;	1=NUMBER, 2=LIST INDEX,
;						;	3=STRING, 4=COMPLEX,
;						;	5=FILESPEC, 6=DRIVE
;						;	7=DATE, 8=TIME
;						;	9=QUOTED STRING
;		DB	ITEM_TAG		; MATCHED ITEM TAG
;
;		dw	synonym@		; es:@ points to found SYNONYM if provided.
;
;            +-
;	    | DD	n			; VALUE IF NUMBER
;	    | or
;	    |	DW	i			; INDEX (OFFSET) INTO VALUE LIST
;	    |					; (ES presents Segment address)
;	    | or
;	    |	DD	STRING			; OFFSET OF STRING VALUE
;	    | or
;	    |	DB	drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
;	    | or
;	    |	DW	YEAR	   ;(1980-2099)  IN CASE OF DATE
;	    |	DB	MONTH	   ;(1-12)	 Note: Range check is not performed.
;	    |	DB	DATE	   ;(1-31)	       0 is filled when the corresponding field was not specified.
;	    | or
;	    |	DB	HOUR	   ;(0-23)	  IN CASE OF TIME
;	    |	DB	MINUTES    ;(0-59)	  Note: Range check is not performed .
;	    |	DB	SECONDS    ;(0-59)		0 is filled when the corresponding field was not specified .
;	    |	DB	HUNDREDTHS ;(0-99)
;	    +-
;
;
;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
;      list.
;
;      YEAR: If the input value for the year is less than 100, parser
;	     adds 1900 to it.  For example, when 87 is input to parser for
;	     the year value, he returns 1987.
;---------------------------------------------------------------------------------------------------------

;-------------------------------- Result block structure
$P_Result_Blk	   struc		;AN000;
$P_Type 	   db	0		;AN000; Type returned
$P_Item_Tag	   db	0		;AN000; Matched item tag
$P_SYNONYM_Ptr	   dw	0		;AN000; pointer to Synonym list returned
$P_Picked_Val	   db	0,0,0,0 	;AN000; value
$P_Result_Blk	   ends 		;AN000;
;--------------------------------
;**** values for the type field in the result block

$P_EOL		   equ	0		;AN000; End of line
$P_Number	   equ	1		;AN000; Number
$P_List_Idx	   equ	2		;AN000; List Index
$P_String	   equ	3		;AN000; String
$P_Complex	   equ	4		;AN000; Complex
$P_File_Spec	   equ	5		;AN000; File Spec
$P_Drive	   equ	6		;AN000; Drive
$P_Date_F	   equ	7		;AN000; Date
$P_Time_F	   equ	8		;AN000; Time
$P_Quoted_String   equ	9		;AN000; Quoted String

$P_No_Tag	   equ	0FFH		;AN000; No ITEM_TAG found
;**** Return code
;
; following return code will be returned in the AX register.

$P_No_Error	   equ	0		;AN000; No error
$P_Too_Many	   equ	1		;AN000; Too many operands
$P_Op_Missing	   equ	2		;AN000; Required operand missing
$P_Not_In_SW	   equ	3		;AN000; Not in switch list provided
$P_Not_In_Key	   equ	4		;AN000; Not in keyword list provided
$P_Out_Of_Range    equ	6		;AN000; Out of range specified
$P_Not_In_Val	   equ	7		;AN000; Not in value list provided
$P_Not_In_Str	   equ	8		;AN000; Not in string list provided
$P_Syntax	   equ	9		;AN000; Syntax error
$P_RC_EOL	   equ	-1		;AN000; End of command line

		   PAGE 		;AN000;
;********************** Local Data *************************************
$P_ORDINAL	   dw	0		;AN000; Operand ordinal save area
$P_RC		   dw	0		;AN000; Return code from parser
$P_SI_Save	   dw	0		;AN000; Pointer of command buffer
$P_DX		   dw	0		;AN000; Return result buffer address
$P_Terminator	   db	0		;AN000; Terminator code (ASCII)
$P_DBCSEV_OFF	   dw	0		;AN000; Offset of DBCS EV
$P_DBCSEV_SEG	   dw	0		;AN000; Segment of DBCS EV
$P_Flags	   dw	0		;AN000; Parser internal flags
$P_Flags1	   equ	byte ptr $P_Flags ;AN038; to reference first byte flags
$P_Flags2	   equ	byte ptr $P_Flags+1 ;AN038; to reference second byte flags only

;in second byte of $P_Flags, referenced as $P_Flags2:
$P_equ		   equ	01h	      ;AN000; "=" packed in string buffet
$P_Neg		   equ	02h	      ;AN000; Negative value
$P_Time12	   equ	04h	      ;AN000; set when PM is specified
$P_Key_Cmp	   equ	08h	      ;AN000; set when keyword compare
$P_SW_Cmp	   equ	10h	      ;AN000; set when switch compare
$P_Extra	   equ	20h	      ;AN000; set when extra delimiter found
$P_SW		   equ	40h	      ;AN000; set when switch found (tm08)
$P_Signed	   equ	80h	      ;AN000; signed numeric specified

;in first byte of $P_Flags, referenced as $P_Flags1:
$P_time12am	   equ	01h	      ;AN038; set when AM is specified on time
$P_TIME_AGAIN	   EQU	02H	      ;AN039; SET WHEN READY TO RE-PARSE TIME

$P_SaveSI_Cmpx	   dw	0		;AN000; save si for later use by complex
$P_KEYorSW_Ptr	   dw	0		;AN000; points next to "=" or ":" code
$P_Save_EOB	   dw	0		;AN000; save pointer to EOB
$P_Found_SYNONYM   dw	0		;AN000; es:@ points to found synonym

$P_STRING_BUF	   db	128 dup(0)	;AN000; Pick a operand from command line
$P_STRING_BUF_END  equ	$		;AN000;
IF		   TimeSw		;AN039; For TIME only
$P_ORIG_ORD	   DW	0		;AN039; ORIGINAL ORDINAL FROM CX
$P_ORIG_STACK	   DW	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
$P_ORIG_SI	   DW	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
ENDIF					;AN039;
IF		   DateSw+TimeSw	;AN000;(Check if date or time format is supported)
;------------------------------
;
$P_Got_Time	   db	0		;AN023; if 1, use Time delimiters
$P_NeedToBeRead    equ	0ffffh		;AN000;

$P_COUNTRY_INFO    $P_CDI <$P_NeedToBeRead> ;AN000;
;
$P_1st_Val	   dw	0		;AN000; used when process date or time
$P_2nd_Val	   dw	0		;AN000; used when process date or time
$P_3rd_Val	   dw	0		;AN000; used when process date or time
$P_4th_Val	   dw	0		;AN000; used when process date or time
;------------------------------
ENDIF					;AN000;(of DateSW+TimeSW)
$P_Char_CAP_Ptr    db	0ffh		;AN000; info id
		   dw	0		;AN000; offset	of char case map table
		   dw	0		;AN000; segment of char case map table
IF		   CAPSW		;AN000;(Check if uppercase conversion is supported)
$P_File_CAP_Ptr    db	0ffh		;AN000; info id
		   dw	0		;AN000; offset	of file case map table
		   dw	0		;AN000; segment of file case map table
ENDIF					;AN000;(of CAPSW)
; (tm06) IF	   FileSW		;AN000;(Check if file spec is supported)
;

;M029
;!!!WARNING!!!
; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
;hardcoded strings. If the chars in the string are changed here, corresponding
;changes need to be made in SYSPARSE
;
IF		   FileSW+DrvSW 	;AN000;(Check if file spec is supported)
$P_FileSp_Char	   db	'[]|<>+=;"'     ;AN000; delimitter of file spec
$P_FileSp_Len	   equ	$-$P_FileSp_Char ;AN000;
ENDIF					;AN000;(of FileSW)
; (tm05) IF	   QusSW		;AN000;(Check if quoted string is supported)
;(deleted ;AN025;) IF		      QusSW+CmpxSW	   ; (tm05) ;AN000;(Check if quoted string is supported)
;(deleted ;AN025;) $P_SorD_Quote      db   0		   ;AN000; keep double or single quote
;(deleted ;AN025;) ENDIF				   ;AN000;(of QueSW)
IF		   KeySW		;AN029; if keywords supported
$P_count_to_eol    dw	0		;AN029; count of chars not including EOL
;	REGISTER EQUATES - SPECIAL USAGE FOR REGISTERS
$P_REG_BH_CG_SW    EQU	BH		;AN029;0="NO CHANGES MADE", FF=CHANGES MADE
$P_REG_BL_DQ_SW    EQU	BL		;AN029;0=NOT IN QUOTES,FF=IN QUOTES

$P_DOUBLE_QUOTE    EQU	""""            ;AN029;
$P_BL_EQ	   EQU	" ="            ;AN029;
$P_EQ_BL	   EQU	"= "            ;AN029;
$P_TB_EQ	   EQU	093DH		;AN029; ;"<TAB>="
$P_EQ_TB	   EQU	3D09H		;AN029; ;"=<TAB>"
ENDIF					;AN029; IF KeySW Supported

; delimiter parsing
$P_colon_period    equ	01		;AN032; check for colon & period
$P_period_only	   equ	02		;AN032; check only for period

;filespec error flag
$P_err_flag	   db	00		;AN033; flag set if filespec parsing error
					;AN033;  was detected.
$P_error_filespec  equ	01		;AN033; mask to set flag
;***********************************************************************

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\pdb.inc ===
;	SCCSID = @(#)pdb.asm	1.1 85/04/10
BREAK <Process data block>

;**	Process data block (otherwise known as program header)
;

;	These offset are documented in the MSDOS Encyclopedia, so nothing
;	can be rearranged here, ever.  Reserved areas are probably safe
;	for use.


FilPerProc	    EQU     20

Process_data_block  STRUC
PDB_Exit_Call	DW	?		; INT int_abort system terminate
PDB_block_len	DW	?		; size of execution block
		DB	?
PDB_CPM_Call	DB	5 DUP (?)	; ancient call to system
PDB_Exit	DD	?		; pointer to exit routine
PDB_Ctrl_C	DD	?		; pointer to ^C routine
PDB_Fatal_abort DD	?		; pointer to fatal error
PDB_Parent_PID	DW	?		; PID of parent (terminate PID)
PDB_JFN_Table	DB	FilPerProc DUP (?)
PDB_environ	DW	?		; seg addr of environment
PDB_User_stack	DD	?		; stack of self during system calls
PDB_JFN_Length	DW	?		; number of handles allowed
PDB_JFN_Pointer DD	?		; pointer to JFN table
PDB_Next_PDB	DD	?		; pointer to nested PDB's

PDB_InterCon	DB	?		; *** jh-3/28/90 *** 
PDB_Append	DB	?		; *** Not sure if still used ***

PDB_Novell_Used	DB	2 DUP (?)	; Novell shell (redir) uses these

PDB_Version	DW	?		; DOS version reported to this app

PDB_PAD1	DB	0Eh DUP (?)
PDB_Call_system DB	5   DUP (?)	; portable method of system call
PDB_PAD2	DB	7h  DUP (?)	; reserved so FCB 1 can be used as
					;  an extended FCB
PDB_FCB1	DB	10h dup (?)	; default FCB 1
PDB_FCB2	DB	10h dup (?)	; default FCB 2
PDB_PAD3	DB	4   dup (?)	; not sure if this is used by PDB_FCB2
PDB_TAIL	DB	128 dup (?)	; command tail and default DTA



Process_data_block  ENDS


;
;PDB_Append	equ	BYTE PTR  PDB_PAD1 + 1    ; reincluded because APPEND
;                        ; wouldn't build w/o it.  feb 1990, leaf
;
;PDB_InterCon	EQU	BYTE PTR PDB_PAD1	; 2/12/KK
;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\sf.inc ===
BREAK <Internal system file table format>


;**	SF.INC - System File Table
;
;   AN000   version 4.00   Jan. 1988
;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
;   AN009   PTM 3839	 reorder SFT for MS WINDOWS


;**	System File Table SuperStructure
;
;	The system file table entries are allocated in contiguous groups.
;	There may be more than one such groups; the SF "superstructure"
;	tracks the groups.

SF		STRUC
SFLink		DD	?
SFCount 	DW	?		; number of entries
SFTable 	DW	?		; beginning of array of the following
SF		ENDS


;**	System file table entry
;
;	These are the structures which are at SFTABLE in the SF structure.

sf_entry	STRUC
sf_ref_count	DW	?		; number of processes sharing entry
					;   if FCB then ref count
sf_mode 	DW	?		; mode of access or high bit on if FCB
sf_attr 	DB	?		; attribute of file
sf_flags	DW	?		;Bits 8-15
					; Bit 15 = 1 if remote file
					;	 = 0 if local file or device
					; Bit 14 = 1 if date/time is not to be
					;   set from clock at CLOSE.  Set by
					;   FILETIMES and FCB_CLOSE.  Reset by
					;   other reseters of the dirty bit
					;   (WRITE)
					; Bit 13 = Pipe bit (reserved)
					;
					; Bits 0-7 (old FCB_devid bits)
					; If remote file or local file, bit
					; 6=0 if dirty Device ID number, bits
					; 0-5 if local file.
					; bit 7=0 for local file, bit 7
					;      =1 for local I/O device
					; If local I/O device, bit 6=0 if EOF (input)
					;		Bit 5=1 if Raw mode
					;		Bit 0=1 if console input device
					;		Bit 1=1 if console output device
					;		Bit 2=1 if null device
					;		Bit 3=1 if clock device
sf_devptr	DD	?		; Points to device header
sf_time 	DW	?		; Time associated with file
sf_date 	DW	?		; Date associated with file
sf_size 	DD	?		; Size associated with file
sf_position	DD	?		; LRU count for FCBs

; SHARING INFO
sf_chain	DD	?		; link to next SF
sf_PID		DW	?
sf_NTHandle	DD	?		; NT File Handle
sf_entry	ENDS

sf_OpenAge	EQU	WORD PTR sf_position+2
sf_LRU		EQU	WORD PTR sf_position

sf_default_number   EQU     5h

;
; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
; by placing a -1 in the ref_count field.
;

sf_busy EQU -1


; Flag word masks
sf_isfcb		EQU	1000000000000000B
sf_isnet		EQU	1000000000000000B
sf_close_nodate 	EQU	0100000000000000B
sf_pipe 		EQU	0010000000000000B
sf_no_inherit		EQU	0001000000000000B
sf_net_spool		EQU	0000100000000000B
sf_scs_console          EQU     0000010000000000B   ; special for NT DOSEM
sf_nt_seek		EQU	0000001000000000B   ; special for NT DOSEM
sf_nt_pipe_in		EQU	0000000100000000B   ; for stdin redirection
                                                    ; true if seek is needed
                                                    ; with next read/write operation

devid_file_clean	EQU	40h	; true if file and not written
devid_file_mask_drive	EQU	3Fh	; mask for drive number

devid_device		EQU	80h	; true if a device
devid_device_EOF	EQU	40h	; true if end of file reached
devid_device_raw	EQU	20h	; true if in raw mode
devid_device_special	EQU	10h	; true if special device
devid_device_clock	EQU	08h	; true if clock device
devid_device_null	EQU	04h	; true if null device
devid_device_con_out	EQU	02h	; true if console output
devid_device_con_in	EQU	01h	; true if consle input

;
; structure of devid field as returned by IOCTL is:
;
;	BIT	7   6	5   4	3   2	1   0
;	      |---|---|---|---|---|---|---|---|
;	      | I | E | R | S | I | I | I | I |
;	      | S | O | A | P | S | S | S | S |
;	      | D | F | W | E | C | N | C | C |
;	      | E |   |   | C | L | U | O | I |
;	      | V |   |   | L | K | L | T | N |
;	      |---|---|---|---|---|---|---|---|
;	ISDEV = 1 if this channel is a device
;	      = 0 if this channel is a disk file
;
;	If ISDEV = 1
;
;	      EOF = 0 if End Of File on input
;	      RAW = 1 if this device is in Raw mode
;		  = 0 if this device is cooked
;	      ISCLK = 1 if this device is the clock device
;	      ISNUL = 1 if this device is the null device
;	      ISCOT = 1 if this device is the console output
;	      ISCIN = 1 if this device is the console input
;
;	If ISDEV = 0
;	      EOF = 0 if channel has been written
;	      Bits 0-5	are  the  block  device  number  for
;		  the channel (0 = A, 1 = B, ...)
;
devid_ISDEV	EQU	80h
devid_EOF	EQU	40h
devid_RAW	EQU	20h
devid_SPECIAL	EQU	10H
devid_ISCLK	EQU	08h
devid_ISNUL	EQU	04h
devid_ISCOT	EQU	02h
devid_ISCIN	EQU	01h

devid_block_dev EQU	1Fh		; mask for block device number

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\redirsym.inc ===
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;  Redirector MACROS
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

EDW	MACRO	name
	extrn	name:near
	DW	OFFSET	RG:name
ENDM

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

CHECK_DIALECT	  MACRO   name

    IF2 					;AN000; If not defined yet,
       IFNDEF CHECKDIALECT			;AN000;  THEN Extrn
	  Extrn CHECKDIALECT&name:NEAR		;AN000;
       ENDIF					;AN000;
    ENDIF					;AN000;
	CALL	CHECKDIALECT&name		;AN000; Call the appropriate routine

ENDM

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

CallREDIRSub MACRO   name,fn,save,restore	;AN000;
    IF2 					;AN000; If not defined yet,
       IFNDEF REDIRSub&fn			;AN000;  THEN Extrn
	  Extrn REDIRSub&fn:NEAR		;AN000;
       ENDIF					;AN000;
    ENDIF					;AN000;
    IFNB    <save>				;AN000; If not blank
	SAVE <save>				;AN000;    Save the regs
    ENDIF					;AN000;
	CALL	REDIRSub&fn			;AN000; Call the appropriate routine
    IFNB    <restore>				;AN000; If not blank
	RESTORE	<restore>			;AN000;    Save the regs
    ENDIF					;AN000;
ENDM						;AN000;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;  Redirector structures
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	INCLUDE IFSSYM.INC		 ;AN000;
	INCLUDE ERROR.INC		 ;AN000;
	INCLUDE FILEMODE.INC		 ;AN000;

;; CD_FSDA STRUCTURE

   CD_FSDA_OFF	   EQU WORD PTR CD_FSDA        ;AN000;
   CD_FSDA_SEG	   EQU WORD PTR CD_FSDA+2      ;AN000;
   CD_FSDA_FLAGS   EQU WORD PTR CD_FSDA+4      ;AN000;

;; DFL_FSDA STRUCTURE

   DF_FSDA_OFF	   EQU WORD PTR DFL_FSDA        ;AN000;
   DF_FSDA_SEG	   EQU WORD PTR DFL_FSDA+2      ;AN000;
   DF_FSDA_FLAGS   EQU WORD PTR DFL_FSDA+4      ;AN000;

;; SFF_FSDA STRUCTURE

   SFF_FSDA_OFF    EQU WORD PTR SFF_FSDA       ;AN000;
   SFF_FSDA_SEG    EQU WORD PTR SFF_FSDA+2     ;AN000;
   SFF_FSDA_FLAGS  EQU WORD PTR SFF_FSDA+4     ;AN000;

;; IFS Structure fixes

   ifsr_fcn_def    EXECAPI		 ;AN000;
   ifsr_api_def    OPENFILE		 ;AN000;
IFSR_OPENNAME@	=  IFSR_NAME@		 ;AN000;
   ifsr_api_def    SEARCHFILE		 ;AN000;
IFSR_SRCHNAME@	=  IFSR_NAME@		 ;AN000;
   ifsr_api_def    MKDIR		 ;AN000;
IFSR_DIRNAME@	=  IFSR_NAME@		 ;AN000;
   ifsr_api_def    DELFILE		 ;AN000;
IFSR_DELNAME@	=  IFSR_NAME@		 ;AN000;
   ifsr_api_def    FILEATTR		 ;AN000;
IFSR_ATTRNAME@	=  IFSR_NAME@		 ;AN000;

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;  Redirector Equates
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Get_Interrupt_Vector EQU     35H      ;AN000;
Set_Interrupt_Vector EQU     25H      ;AN000;
Deallocate_memory    EQU     49H      ;AN000;

GET_SYS_CONFIG	     EQU     0C000H   ;AN000; INT 15H to get configuration
CONFIG_STRUC	STRUC		      ;AN001;
   LENGTH	DW   ?		      ;AN001;
   MODEL_BYTE	DB   ?		      ;AN001;
CONFIG_STRUC	ENDS		      ;AN001;

LOWEST_386_MODEL     EQU     0F8H     ;AN001;

INCOR_DOS	     EQU     1	      ;AN000;
ALREADY_INST	     EQU     2	      ;AN000;
NOT_INST	     EQU     3	      ;AN000;
NET_NOT_STARTED      EQU     4	      ;AN000;
INSUFF_MEM	     EQU     5	      ;AN000;
BAD_PARM	     EQU     10       ;AN000;
INSUFFICENT_MEM      EQU     76       ;AN001; Extended Error

ONE_REPLACE	     EQU     1	      ;AN000;
SINGLE_COUNT	     EQU     1	      ;AN000;
TESTDIALECT	     =	     0	      ;AN001;

REDIR_INSTALLED      EQU     -1       ;AN000;
REDIR_SYS_INSTALL    EQU     0BF80H   ;AN000; REDIR.SYS 2FH Function number
REDIR_EXE_INSTALL    EQU     0BF00H   ;AN000; REDIR.EXE 2FH Function number

FASSIGN_ON	     EQU     -1       ;AN000;
FASSIGN_OFF	     EQU     0	      ;AN000;
FPRINT_ON	     EQU     -1       ;AN000;
FPRINT_OFF	     EQU     0	      ;AN000;

EXT_ERR_72	     EQU     72       ;AN000;
PSP_ENVIRO_SEG	     EQU     002CH    ;AN000; Offset into the PSP of the Enviroment Segment

PrnIO		     EQU     17H      ; Int vector for Printer IO
PrntScr 	     EQU     05H      ; Int vector for Print Screen
PrnRdrMark	     EQU     2	      ; Mark for port addr

VER12		     EQU     00000010b ;AN001;
VER13		     EQU     00000100b ;AN001;

FIRST_TIME	     EQU     1		 ;AN001;
SECOND_TIME	     EQU     2		 ;AN001;

SHIFT_BY_7	     EQU     7		 ;AN001;

HI_BIT_SHARING_MASK  EQU     1111111101111111b ;AN001; Turns off Hi bit in nibble


;; ###############################################################
;;		MISC.INC
;; ###############################################################

; NETFILE

attr_read_only	       = 00000001b

; NETINIT

IFSR_INVALID_CMD	=   -1							      ;AN000;

; NETUTIL

MACRO_4 	=	4
DATE_TIME	=	0


; NETHAND

LOCK_ALL_OPERS	   =	   0
POS_LEN_PTR_SIZE   =	   8		  ;AN001; 8 bytes for position/length

FIND_BUF    STRUC

find_buf_drive	    DB	?		; drive of search
find_buf_name	    DB	11 DUP (?)	; formatted name
find_buf_sattr	    DB	?		; attribute of search
find_buf_LastEnt    DW	?		; LastEnt
find_buf_DirStart   DW	?		; DirStart
find_buf_NetID	    DB	4 DUP (?)	; Reserved for NET
find_buf_attr	    DB	?		; attribute found
find_buf_time	    DW	?		; time
find_buf_date	    DW	?		; date
find_buf_size_l     DW	?		; low(size)
find_buf_size_h     DW	?		; high(size)
find_buf_pname	    DB	13 DUP (?)	; packed name

FIND_BUF    ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\postequ.inc ===
;
; M024 MD 01/28/91      Added new keyboard commands
;
;----------------------------------------------------------------------------
;               EQUATES                 :
;----------------------------------------------------------------------------
TTEST           EQU     0               ; CONDITIONAL ASM (TEST2.SRC)
KY_LOCK         EQU     0               ; CONDITIONAL ASM (TEST2.SRC)
KEY_NUMS        EQU     0               ; CONDITIONAL ASM (KYBD.SRC)
;----------------------------------------------------------------------------
X287            EQU     0F0H            ; MATH PROCESSOR
;----------------------------------------------------------------------------
LOOP_POST       EQU     020H            ; MFG LOOP POST JUMPER
;----------------------------------------------------------------------------
REFRESH_BIT     EQU     010H            ; REFRESH TEST BIT
;----------------------------------------------------------------------------
POST_SS         EQU     0H              ; POST STACK SEGMENT
POST_SP         EQU     8000H           ; POST STACK POINTER
TEMP_STACK_LO   EQU     0FFFFH          ;
TEMP_STACK_HI   EQU     0               ; SET PROTECTED MODE TEMP_SS
                                        ; 0:FFFFH
;----------------------------------------------------------------------------
PORT_A          EQU     60H             ; 8042 KEYBOARD SCAN/DIAG OUTPUTS
PORT_B          EQU     61H             ; 8042 READ WRITE REGISTER
PARITY_ERR      EQU     0C0H            ; RAM/IO CHANNEL PARITY ERROR
RAM_PAR_ON      EQU     11110011B       ; AND THIS VALUE
RAM_PAR_OFF     EQU     00001100B       ; OR THIS VALUE
IO_CHK          EQU     01000000B       ; IO CHECK?
PRTY_CHK        EQU     10000000B       ; PARITY CHECK?

STATUS_PORT     EQU     64H             ;8042 STATUS PORT
OUT_BUF_FULL    EQU     01H             ; 0 = +OUTPUT BUFFER FULL
INPT_BUF_FULL   EQU     02H             ; 1 = +INPUT BUFFER FULL
SYS_FLAG        EQU     04H             ; 2 = -SYSTEM FLAG -POR/-SELF TEST
CMD_DATA        EQU     08H             ; 3 = -COMMAND/+DATA
KYBD_INH        EQU     10H             ; 4 = +KEYBOARD INHIBITED
TRANS_TMOUT     EQU     20H             ; 5 = +TRANSMIT TIMEOUT
RCV_TMOUT       EQU     40H             ; 6 = +RECEIVE TIME OUT
PARITY_EVEN     EQU     80H             ; 7 = +PARITY IS EVEN
SHUT_CMD        EQU     0FEH            ; CAUSE A SHUTDOWN COMMAND
INTR_FACE_CK    EQU     0ABH            ; CHECK 8042 INTERFACE CMD
KYBD_CLK_DATA   EQU     0E0H            ; GET KYBD CLOCK AND DATA CMD
KYBD_CLK        EQU     001H            ; KEYBOARD CLOCK BIT 0
;----------MANUFACTURING PORT------------------------------------------------
MFG_PORT        EQU     80H             ; MANUFACTURING CHECKPOINT PORT
;----------MANUFACTURING BIT DEFINITION FOR MFG_ERR_FLAG+1-------------------
MEM_FAIL        EQU     00000001B      ; STORAGE TEST FAILED (ERROR 20X)
PRO_FAIL        EQU     00000010B      ; VIRTUAL MODE TEST FAILED (ERROR 104)
LMCS_FAIL       EQU     00000100B      ; LOW MEG CHIP SELECT FAILED (ERROR 109)
KYCLK_FAIL      EQU     00001000B      ; KEYBOARD CLOCK TEST FAILED (ERROR 304)
KY_SYS_FAIL     EQU     00010000B      ; KEYBOARD OR SYSTEM FAILED (ERROR 303)
KYBD_FAIL       EQU     00100000B      ; KEYBOARD FAILED (ERROR 301)
DSK_FAIL        EQU     01000000B      ; DISKETTE TEST FAILED (ERROR 601)
KEY_FAIL        EQU     10000000B      ; KEYBOARD LOCKED (ERROR 302)
;----------8042 INPUT PORT BIT DEFINITION------------------------------------
BASE_RAM        EQU     10H             ;BASE R/W MEMORY
MFG_JMP         EQU     20H             ;LOOP POST JUMPER
DSP_JMP         EQU     40H             ;DISPLAY TYPE JUMPER
KEY_BD_INHIB    EQU     80H             ;KEYBOARD INHIBIT SWITCH
;----------8042 RAM DEFINITION-----------------------------------------------
INH_KEYBOARD    EQU     10H             ;BYTE 0 BIT 4 OF 8042 RAM
;-------------- COMMANDS ----------------------------------------------------
READ_8042_RAM   EQU     20H             ; BITS 0-4 = ADDRESS (20-3F)
WRITE_8042_RAM  EQU     60H             ;
SELF_8042_TEST  EQU     0AAH            ; 8042 SELF TEST
READ_8042_INPUT EQU     0C0H            ; READ 8042 INPUT PORT
ENA_KBD         EQU     0AEH            ; ENABLE KEYBOARD COMMAND
DIS_KBD         EQU     0ADH            ; DISABLE KEYBOARD COMMAND
ENABLE_BIT20    EQU     0DFH            ; ENABLE ADDR LINE BIT 20
DISABLE_BIT20   EQU     0DDH            ; DISABLE ADDR LINE BIT 20
ENABLE_AUX      EQU     0A8H            ; ENABLE AUX DEVICE COMMAND    ;M024
DISABLE_AUX     EQU     0A7H            ; DISABLE AUX DEVICE COMMAND   ;M024
;-------------- KEYBOARD/LED COMMANDS --------------------------------------
KB_MENU         EQU     0F1H            ; SELECT MENU COMMAND
KB_TYPA_RD      EQU     0F3H            ; SET TYPAMATIC RATE/DELAY         RWV 10-07-85
KB_ENABLE       EQU     0F4H            ; KEYBOARD ENABLE
KB_MAKE_BREAK   EQU     0F7H            ; TYPAMATIC
KB_ECHO         EQU     0FEH            ; ECHO COMMAND
KB_RESET        EQU     0FFH            ; SELF DIAGNOSTIC COMMAND
LED_CMD         EQU     0EDH            ; LED WRITE COMMAND
;--------------- KEYBOARD RESPONSE -----------------------------------------
KB_OK           EQU     0AAH            ; RESPONSE FROM SELF DIAG
KB_ACK          EQU     0FAH            ; ACKNOWLEDGE FROM TRANSMISSION
KB_OVER_RUN     EQU     0FFH            ; OVER RUN
KB_RESEND       EQU     0FEH            ; RESEND REQUEST
KB_BREAK        EQU     0F0H            ; KEYBOARD BREAK CODE
;-------------- CMOS EQUATES -------------------------------------------------
CMOS_PORT       EQU     070H            ; IO ADDRESS OF CMOS PORT
CLK_UP          EQU     08AH            ; CLOCK UPDATE STATUS
CMOS_ALARM      EQU     08BH            ;
CMOS_BEGIN      EQU     090H            ;
CMOS_END        EQU     0ADH            ;
SHUT_DOWN       EQU     08FH            ; SHUTDOWN OFFSET
BATTERY_COND_STATUS EQU 08DH            ; BATTERY STATUS
M_SIZE_HI       EQU     0B1H            ; IO MEMORY SIZE HIGH BYTE (POST)
M_SIZE_LO       EQU     0B0H            ; IO MEMORY SIZE LO BYTE   (POST)
M1_SIZE_HI      EQU     096H            ; 0->640K CONFIG MEMORY SIZE (SETUP)
M1_SIZE_LO      EQU     095H            ;   LOW BYTE (SETUP)
M2_SIZE_HI      EQU     098H            ; 640K->UP CONFIG MEMORY SIZE (SETUP)
M2_SIZE_LO      EQU     097H            ;   LOW BYTE (SETUP)
C_EQUIP         EQU     094H            ; CMOS EQUIPMENT FLAG
HD_FILE_TYPE    EQU     092H            ; HARD FILE TYPE BYTE
PAGE
;--------------- CMOS DIAG_STATUS ERROR FLAGS--------------------------------
DIAG_STATUS     EQU     08EH            ; CMOS ADDRESS OF DIAG_STATUS
BAD_BAT         EQU     080H            ; DEAD BATTERY
BAD_CKSUM       EQU     040H            ; CHECKSUM ERROR
BAD_CONFIG      EQU     020H            ; MINIMUM CONFIG USED INSTEAD OF CMOS
W_MEM_SIZE      EQU     010H            ; MEMORY SIZE NOT EQUAL TO CONFIG
HF_FAIL         EQU     008H            ; HARD FILE FAILURE ON INIT
CMOS_CLK_FAIL   EQU     004H            ; CMOS CLK NOT UPDATING OR NOT VALID
;--------------- CMOS INFORMATION FLAGS--------------------------------------
INFO_STATUS     EQU     0B3H            ; CMOS ADDRESS OF INFO BYTE
M640K           EQU     080H            ; 512K -> 640K CARD INSTALLED
NEW_INST        EQU     040H            ; FLAG USED BY CMOS SETUP UTILITY
HF_BOOT         EQU     020H            ; BOOT HARD FILE FLAG
;--------------- INTERRUPT EQUATES ------------------------------------------
INTA00          EQU     20H             ; 8259 PORT
INTA01          EQU     21H             ; 8259 PORT
EOI             EQU     20H
INTB00          EQU     0A0H            ; 2ND 8259
INTB01          EQU     0A1H            ;
INT_TYPE        EQU     070H            ; START OF 8259 INTERRUPT TABLE LOCATION
INT_VIDEO       EQU     010H            ; VIDEO VECTOR
;---------------------------------------------------------------------------
TIMER           EQU     40H
TIM_CTL         EQU     43H             ; 8253 TIMER CONTROL PORT ADDR
TIMER0          EQU     40H             ; 8253 TIMER/CNTER 0 PORT ADDR
TMINT           EQU     01              ; TIMER 0 INTR RECVD MASK
;--------------------------------------------------------------------------
DMA08           EQU     08              ; DMA STATUS REG PORT ADDR
DMA             EQU     00              ; DMA CH.0 ADDR. REG PORT ADDR
;--------------------------------------------------------------------------
DMA18           EQU     0D0H            ; 2ND DMA STATUS PORT ADDR
DMA1            EQU     0C0H            ; 2ND DMA CH.0 ADDR. REG PORT ADDR
;--------------------------------------------------------------------------
DMA_PAGE        EQU     81H             ; START OF DMA PAGE REGISTERS
LAST_DMA_PAGE   EQU     8FH             ; LAST DMA PAGE REGISTER
;--------------------------------------------------------------------------
MAX_PERIOD      EQU     540H
MIN_PERIOD      EQU     410H
KBD_IN          EQU     60H             ; KEYBOARD DATA IN ADDR PORT
KBDINT          EQU     02              ; KEYBOARD INTR MASK
KB_DATA         EQU     60H             ; KEYBOARD SCAN CODE PORT
KB_CTL          EQU     61H             ; CONTROL BITS FOR KEYBOARD SENSE DATA
KB_ERR          EQU     80H             ; KEYBOARD TRANSMIT ERROR FLAG
;----- SHIFT FLAG EQUATES WITHIN KB_FLAG
INS_STATE       EQU     80H             ; INSERT STATE IS ACTIVE
CAPS_STATE      EQU     40H             ; CAPS LOCK STATE HAS BEEN TOGGLED
NUM_STATE       EQU     20H             ; NUM LOCK STATE HAS BEEN TOGGLED
SCROLL_STATE    EQU     10H             ; SCROLL LOCK STATE HAS BEEN TOGGLED
ALT_SHIFT       EQU     08H             ; ALTERNATE SHIFT KEY DEPRESSED
CTL_SHIFT       EQU     04H             ; CONTROL SHIFT KEY DEPRESSED
LEFT_SHIFT      EQU     02H             ; LEFT SHIFT KEY DEPRESSED
RIGHT_SHIFT     EQU     01H             ; RIGHT SHIFT KEY DEPRESSED
;----- SHIFT FLAG EQUATES WITHIN KB_FLAG_1
INS_SHIFT       EQU     80H             ; INSERT KEY IS DEPRESSED
CAPS_SHIFT      EQU     40H             ; CAPS LOCK KEY IS DEPRESSED
NUM_SHIFT       EQU     20H             ; NUM LOCK KEY IS DEPRESSED
SCROLL_SHIFT    EQU     10H             ; SCROLL LOCK KEY IS DEPRESSED
HOLD_STATE      EQU     08H             ; SUSPEND KEY HAS BEEN TOGGLED
SYS_SHIFT       EQU     04H             ; SYSTEM KEY DEPRESSED AND HELD
L_ALT_SHIFT     EQU     02H             ; LEFT ALT KEY DOWN                RWV 8-28-85
L_CTL_SHIFT     EQU     01H             ; LEFT CTL KEY DOWN                RWV 8-28-85
;---------------FLAGS WITHIN KB_FLAG_2
KB_ERR          EQU     80H             ; KEYBOARD TRANSMIT ERROR FLAG
KB_PR_LED       EQU     40H             ; MODE INDICATOR UPDATE
KB_FE           EQU     20H             ; RESEND RECEIVED FLAG
KB_FA           EQU     10H             ; ACK RECEIVED
CIRCUS_SYSTEM   EQU     08H             ; CIRCUS SYSTEM INDICATOR
KB_LEDS         EQU     07H             ; KEYBOARD LED STATE BITS
;                       04H             ; CAPS LOCK INDICATOR
;                       02H             ; NUM LOCK INDICATOR
;                       01H             ; SCROLL LOCK INDICATOR
;---------------FLAGS WITHIN KB_FLAG_3
RD_ID           EQU     80H             ; DOING A READ ID (MUST BE BIT0)   AEV
LC_AB           EQU     40H             ; LAST CHAR WAS FIRST ID CHAR      AEV
SET_NUM_LK      EQU     20H             ; FORCE NUM LOCK IF RD ID & KBX    AEV
KBX             EQU     10H             ; ENHANCED KEYBOARD INSTALLED      RWV 7-18-85
R_ALT_SHIFT     EQU     08H             ; RIGHT ALT KEY DOWN               RWV 7-18-85
GRAPH_ON        EQU     08H             ; ALT GRAPHICS KEY DOWN (WT ONLY)  AEV
R_CTL_SHIFT     EQU     04H             ; RIGHT CTL KEY DOWN               RWV 7-18-85
LC_E0           EQU     02H             ; LAST CODE WAS THE E0 HIDDEN CODE RWV 7-18-85
LC_E1           EQU     01H             ; LAST CODE WAS THE E1 HIDDEN CODE RWV 7-18-85
;----- SCAN CODE EQUATES FOR THE KEYBOARD
NUM_KEY         EQU     69              ; SCAN CODE FOR NUMBER LOCK
SCROLL_KEY      EQU     70              ; SCAN CODE FOR SCROLL LOCK
ALT_KEY         EQU     56              ; SCAN CODE FOR ALTERNATE KEY
CTL_KEY         EQU     29              ; SCAN CODE FOR CONTROL KEY
CAPS_KEY        EQU     58              ; SCAN CODE FOR SHIFT LOCK
LEFT_KEY        EQU     42              ; SCAN CODE FOR LEFT SHIFT
RIGHT_KEY       EQU     54              ; SCAN CODE FOR RIGHT SHIFT
INS_KEY         EQU     82              ; SCAN CODE FOR INSERT KEY
DEL_KEY         EQU     83              ; SCAN CODE FOR DELETE KEY
SYS_KEY         EQU     84              ; SCAN CODE FOR SYSTEM KEY
;-------------- ENHANCED KEYBOARD EQUATES
ID_1            EQU     0ABH            ; 1ST ID CHAR FOR KBX
ID_2            EQU     041H            ; 2ND ID CHAR FOR KBX              AEV
ID_2A           EQU     054H            ; ALTERNATE 2ND ID CHAR FOR KBX    RWV 8-16-85
F11_M           EQU     87              ; F11 KEY MAKE
F12_M           EQU     88              ; F12 KEY MAKE
MC_E0           EQU     224             ; GENERAL MARKER CODE
MC_E1           EQU     225             ; PAUSE KEY MARKER CODE

;-------------- DISKETTE EQUATES
INT_FLAG        EQU     080H            ; INTERRUPT OCCURRENCE FLAG
MOTOR_WAIT      EQU     37              ; 2 SECS OF COUNTS FOR MOTOR TURN OFF
TIME_OUT        EQU     80H             ; ATTACHMENT FAILED TO RESPOND
BAD_SEEK        EQU     40H             ; SEEK OPERATION FAILED
BAD_NEC         EQU     20H             ; NEC CONTROLLER HAS FAILED
BAD_CRC         EQU     10H             ; BAD CRC ON DISKETTE READ
DMA_BOUNDARY    EQU     09H             ; ATTEMPT TO DMA ACROSS 64K BOUNDARY
BAD_DMA         EQU     08H             ; DMA OVERRUN ON OPERATION
MEDIA_CHANGE    EQU     06H             ; MEDIA REMOVED ON DUAL ATTACH CARD
RECORD_NOT_FND  EQU     04H             ; REQUESTED SECTOR NOT FOUND
WRITE_PROTECT   EQU     03H             ; WRITE ATTEMPTED ON WRITE PROT DISK
BAD_ADDR_MARK   EQU     02H             ; ADDRESS MARK NOT FOUND
BAD_CMD         EQU     01H             ; BAD COMMAND PASSED TO DISKETTE I/O

XRATE           EQU     02H             ; 250KBS DATA TRANSFER RATE
DUAL            EQU     01H             ; DUAL ATTACH CARD PRESENT FLAG

DSK_CHG         EQU     080H            ; DISKETTE CHANGE FLAG MASK BIT
STATE_MSK       EQU     007H            ; USED TO STRIP OFF STATE OF MEDIA
REV_STATE       EQU     0F8H            ; USED AS MASK FOR STATE BITS
DETERMINED      EQU     010H            ; SET STATE DETERMINED IN STATE BITS
TRAN_MSK        EQU     03H             ; ISOLATE SHIFTED TRANSFER RATE BITS
DOUBLE_STEP     EQU     020H            ; MASK TO TURN ON DOUBLE STEPPING
MOTOR_MSK       EQU     0F0H            ; MASK TO CLEAR MOTOR ON BITS
MAX_DRV         EQU     002H            ; MAX NUMBER OF DRIVES
;HOME            EQU     010H            ; TRACK 0 MASK
SENSE_DRV_ST    EQU     004H            ; SENSE DRIVE STATUS COMMAND
ONE             EQU     001H            ; SEEK ONE TRACK
TRK_SLAP        EQU     030H            ; CRASH STOP (48 TPI DRIVES)
QUIET_SEEK      EQU     00AH            ; SEEK TO TRACK 10
HD12_SETTLE     EQU     015D            ; 1.2 M HEAD SETTLE TIME
HD320_SETTLE    EQU     020D            ; 320 K HEAD SETTLE TIME
WRITE_OP        EQU     080H            ; WRITE OPERATION FLAG
DD_MASK         EQU     010H            ; MASK TO INDICATE DRIVE IS 80 TRACKS
PAGE
;------ DISK CHANGE LINE EQUATES
NOCHGLN         EQU     001H            ; NO DISK CHANGE LINE AVAILABLE
CHGLN           EQU     002H            ; DISK CHANGE LINE AVAILABLE
;------ MEDIA/DRIVE STATE INDICATORS
M326D326        EQU     093H            ; STATE MACHINE - 320/360 MEDIA/DRIVE
M326D12         EQU     074H            ; STATE MACHINE - 320/360 MEDIA,1.2DRIVE
M12D12          EQU     015H            ; STATE MACHINE - 1.2 MEDIA/DRIVE
POA_DUAL        EQU     061H            ; 300K DATA TRANSFER RATE & STATE 1
POA_START       EQU     080H            ; 250K DATA TRANSFER RATE & STATE 0
TRK_80          EQU     008H            ; DISKETTE DRIVE HAS 80 TRACKS
;------ CMOS NON-VOLATILE RAM EQUATES
CMOSDSB_ADDR    EQU     00EH            ; DISKETTE STATUS BYTE ADDRESS
CADR_PRT        EQU     070H            ; CMOS ADDRESS PORT ADDRESS
CDATA_PRT       EQU     071H            ; CMOS DATA PORT ADDRESS
CMOS_GOOD       EQU     0C0H            ; BATTERY AND CHECKSUM INDICATOR
CMOSDSK_BYTE    EQU     010H            ; DISKETTE BYTE ADDRESS
LOWNIB          EQU     00FH            ; ISOLATE LOW NIBBLE IN REGISTER MASK
INVALID_DRV     EQU     002H            ; FIRST INVALID DISKETTE TYPE
;----------------------------------------
;       TIMER DATA AREA                 :
;----------------------------------------
; COUNTS_SEC    EQU     18
; COUNTS_MIN    EQU     1092
; COUNTS_HOUR   EQU     65543
; COUNTS_DAY    EQU     1573040 = 1800B0H
PAGE

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\smifssym.inc ===
;	PAGE	60,132
;	SCCSID = @(#)smifssym.inc 1.0 87/05/11
;
;   Modification history:
;	Created: May 11 1987 
;
;	SMifssym is only for IBMBIO.  It will only has definitions
;	for IFSHEADER, IFSRH of INIT function.
;	When ifssym.inc is Revised, make sure that SMifssym.inc
;	is also correct. - JK.
;

;==================
;IFS drive header
;=================

    IFSDEVICE	EQU	8000H	;  Supports single device/file functions
    IFSDISK	EQU	4000H	;  Supports multi-file functions
    IFSUNC	EQU	2000H	;  Support UNC (nameless) connection
    IFSREMOTE	EQU	0800H	;  File system is remote
    IFSFILTER	EQU	0400H	;  FS will filter (if off, use DOS
				;    standard, cap & 8.3)
    IFSIOCTL	EQU	0002H	;  Supports IOCTL functions
    IFSUSESHARE EQU	0001H	;  Uses DOS share support (vs own share)

IFSHEADER	STRUC
IFS_NEXT	DD	-1	; Next header in list (-1=end)
IFS_NAME	DB	"        " ; IFS name
IFS_ATTRIBUTE	DW	?	; Attributes
IFS_VERSION	DW	0	; Request level supported
IFS_DOSCALL@	DD	?	; DOS interface routine
				;   (set by TUPPER before the init call)
IFS_CALL@	DW	?	; Function entry point
IFSHEADER	ENDS

;=====================
; IFS Request Header
;=====================

IFSRH		STRUC
IFSR_LENGTH	DW    ? 		; Total length of request
IFSR_FUNCTION	DB    ? 		; Requested function
IFSR_RETCODE	DB    ? 		; Explicit error
IFSR_RETCLASS	DB    ? 		; Error class
IFSR_RESV1	DB    17 DUP(0) 	; DOS reserved
IFSR_FCN_PARMS	DB    38 DUP(0) 	; Additional parameters
IFSRH		ENDS

; IFSR_FUNCTION codes
;	Control requests:
IFSINIT        EQU     1
IFSATTSTART    EQU     2
IFSATTEND      EQU     3
IFSEXECAPI     EQU     4
IFSCRITMSG     EQU     5
IFSCBUPDATE    EQU     6
; INIT function.
IFSR_PARMS@	   =  DWORD PTR  IFSR_FCN_PARMS    ; command parameters
IFSR_RESSIZE	   =  WORD  PTR  IFSR_FCN_PARMS+4  ; driver total size
LENGTH_INIT	   EQU IFSR_RESSIZE-IFSRH+2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\smdossym.inc ===
;	SCCSID = @(#)dossym.asm 1.1 85/04/10
;	SCCSID = @(#)dossym.asm 1.1 85/04/10

	ERROR - who uses this?	Not DOS and kernel.  Whoever uses this
		should use DOSSYM instead.  See JGL if there's a problem

;	PAGE 80,132
TRUE	    EQU 0FFFFh
FALSE	    EQU 0

Installed   = TRUE
IFNDEF	DEBUG
    DEBUG	= FALSE
ENDIF

include dosmac.INC
INCLUDE VERSIONA.INC		;DEFINE THE MAJOR AND MINOR VERSION NUMBERS

IF2
;    %OUT    DOSSYM in Pass 2
ENDIF

BREAK <Control character definitions>

c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
c_BS	    EQU     08h 		; ^H ASCII backspace
c_CR	    EQU     0Dh 		; ^M ASCII carriage return
c_LF	    EQU     0Ah 		; ^J ASCII linefeed
c_ETB	    EQU     17h 		; ^W ASCII end of transmission
c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
c_ETX	    EQU     03h 		; ^C ASCII end of text
c_HT	    EQU     09h 		; ^I ASCII tab

BREAK <Read This and Weep>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
; Certain structures, constants and system  calls  below  are  private	to ;
; the DOS  and	are  extremely	version-dependent.  They may change at any ;
; time at  the	implementors'  whim.   As  a  result,  they  must  not  be ;
; documented to  the  general  public.	 If  an  extreme case arises, they ;
; must be documented with this warning. 				   ;
;									   ;
; Those structures and constants that are subject to  the  above  will	be ;
; marked and bracketed with the flag:					   ;
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

include bpb.INC

include buffer.INC

BREAK <User stack inside of system call and SysVars>
; Location of user registers relative user stack pointer

user_environ	STRUC
user_AX     DW	    ?
user_BX     DW	    ?
user_CX     DW	    ?
user_DX     DW	    ?
user_SI     DW	    ?
user_DI     DW	    ?
user_BP     DW	    ?
user_DS     DW	    ?
user_ES     DW	    ?
user_IP     DW	    ?
user_CS     DW	    ?
user_F	    DW	    ?
user_environ	ENDS

include sysvar.INC

include vector.INC

;include mult.INC

BREAK <Disk map>
;  MSDOS partitions the disk into 4 sections:
;
;  phys sector 0:   +-------------------+
;	|	    | boot/reserved	|
;	|	    +-------------------+
;	|	    |  File allocation	|
;	v	    |	   table(s)	|
;		    |  (multiple copies |
;		    |	  are kept)	|
;		    +-------------------+
;		    |	  Directory	|
;		    +-------------------+
;		    |	  File space	|
;		    +-------------------+
;		    |	Unaddressable	|
;		    |  (to end of disk) |
;		    +-------------------+
;
; All partition boundaries are sector boundaries.  The size of the FAT is
; adjusted to maximize the file space addressable.

include dirent.INC

BREAK <File allocation Table information>
;
; The File Allocation Table uses a 12-bit entry for each allocation unit on
; the disk.  These entries are packed, two for every three bytes.  The contents
; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
; to the base address of the Allocation Table; 3) fetching the 16-bit word
; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
; number zero is used as an end-of-file trap in the OS and is passed to the
; BIOS to help determine disk format.  Entry 1 is reserved for future use.
; The first available allocation unit is assigned entry number two, and even
; though it is the first, is called cluster 2.	Entries greater than 0FF8H
; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
; are unallocated.  Otherwise, the contents of a FAT entry is the number of
; the next cluster in the file.
;
; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
; do because these clusters show as allocated, but are not part of any
; allocation chain and thus will never be allocated to a file.	A particular
; number is selected so that disk checking programs know what to do (ie.  a
; cluster with entry FF7H which is not in a chain is not an error).

include dpb.INC

include curdir.INC

;include cpmfcb.INC

;include find.INC

include pdb.INC

include exe.INC

include sf.INC

include arena.INC

include intnat.INC

include mi.INC

fChk	equ 1
fDelim	equ 2
fSpChk	equ 4
fFCB	equ 8

;include filemode.INC

;include error.INC

include syscall.INC

include doscntry.inc		;J.K. 5/26/86

SUBTTL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\syscall.inc ===
;	SCCSID = @(#)syscall.asm	1.1 85/04/10
;BREAK <system call definitions>
SUBTTL	system call definitions
PAGE

Abort				EQU 0	;  0	  0
Std_Con_Input			EQU 1	;  1	  1
Std_Con_Output			EQU 2	;  2	  2
Std_Aux_Input			EQU 3	;  3	  3
Std_Aux_Output			EQU 4	;  4	  4
Std_Printer_Output		EQU 5	;  5	  5
Raw_Con_IO			EQU 6	;  6	  6
Raw_Con_Input			EQU 7	;  7	  7
Std_Con_Input_No_Echo		EQU 8	;  8	  8
Std_Con_String_Output		EQU 9	;  9	  9
Std_Con_String_Input		EQU 10	; 10	  A
Std_Con_Input_Status		EQU 11	; 11	  B
Std_Con_Input_Flush		EQU 12	; 12	  C
Disk_Reset			EQU 13	; 13	  D
Set_Default_Drive		EQU 14	; 14	  E
FCB_Open			EQU 15	; 15	  F
FCB_Close			EQU 16	; 16	 10
Dir_Search_First		EQU 17	; 17	 11
Dir_Search_Next 		EQU 18	; 18	 12
FCB_Delete			EQU 19	; 19	 13
FCB_Seq_Read			EQU 20	; 20	 14
FCB_Seq_Write			EQU 21	; 21	 15
FCB_Create			EQU 22	; 22	 16
FCB_Rename			EQU 23	; 23	 17
Get_Default_Drive		EQU 25	; 25	 19
Set_DMA 			EQU 26	; 26	 1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_Default_DPB 		EQU 31	; 31	 1F
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_Random_Read 		EQU 33	; 33	 21
FCB_Random_Write		EQU 34	; 34	 22
Get_FCB_File_Length		EQU 35	; 35	 23
Get_FCB_Position		EQU 36	; 36	 24
Set_Interrupt_Vector		EQU 37	; 37	 25
Create_Process_Data_Block	EQU 38	; 38	 26
FCB_Random_Read_Block		EQU 39	; 39	 27
FCB_Random_Write_Block		EQU 40	; 40	 28
Parse_File_Descriptor		EQU 41	; 41	 29
Get_Date			EQU 42	; 42	 2A
Set_Date			EQU 43	; 43	 2B
Get_Time			EQU 44	; 44	 2C
Set_Time			EQU 45	; 45	 2D
Set_Verify_On_Write		EQU 46	; 46	 2E
; Extended functionality group
Get_DMA 			EQU 47	; 47	 2F
Get_Version			EQU 48	; 48	 30
Keep_Process			EQU 49	; 49	 31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_DPB 			EQU 50	; 50	 32
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Set_CTRL_C_Trapping		EQU 51	; 51	 33
Get_InDOS_Flag			EQU 52	; 52	 34
Get_Interrupt_Vector		EQU 53	; 53	 35
Get_Drive_Freespace		EQU 54	; 54	 36
Char_Oper			EQU 55	; 55	 37
International			EQU 56	; 56	 38
;   Directory Group
MKDir				EQU 57	; 57	 39
RMDir				EQU 58	; 58	 3A
CHDir				EQU 59	; 59	 3B
;   File Group
Creat				EQU 60	; 60	 3C
Open				EQU 61	; 61	 3D
Close				EQU 62	; 62	 3E
Read				EQU 63	; 63	 3F
Write				EQU 64	; 64	 40
Unlink				EQU 65	; 65	 41
LSeek				EQU 66	; 66	 42
CHMod				EQU 67	; 67	 43
IOCtl				EQU 68	; 68	 44
XDup				EQU 69	; 69	 45
XDup2				EQU 70	; 70	 46
Current_Dir			EQU 71	; 71	 47
;    Memory Group
Alloc				EQU 72	; 72	 48
Dealloc 			EQU 73	; 73	 49
Setblock			EQU 74	; 74	 4A
;    Process Group
Exec				EQU 75	; 75	 4B
Exit				EQU 76	; 76	 4C
WaitProcess			EQU 77	; 77	 4D
Find_First			EQU 78	; 78	 4E
;   Special Group
Find_Next			EQU 79	; 79	 4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Current_PDB 		EQU 80	; 80	 50
Get_Current_PDB 		EQU 81	; 81	 51
Get_In_Vars			EQU 82	; 82	 52
SetDPB				EQU 83	; 83	 53
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Get_Verify_On_Write		EQU 84	; 84	 54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Dup_PDB 			EQU 85	; 85	 55
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Rename				EQU 86	; 86	 56
File_Times			EQU 87	; 87	 57
AllocOper			EQU 88	; 88	 58
; Network extention system calls
GetExtendedError		EQU 89	; 89	 59
CreateTempFile			EQU 90	; 90	 5A
CreateNewFile			EQU 91	; 91	 5B
LockOper			EQU 92	; 92	 5C Lock and Unlock
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
UserOper			EQU 94	; 94	 5E Get and Set
AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
xNameTrans			EQU 96	; 96	 60
PathParse			EQU 97	; 97	 61
GetCurrentPSP			EQU 98	; 98	 62
Hongeul 			EQU 99	; 99	 63
ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Printer_Flag		EQU 100 ; 100	 64
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GetExtCntry			EQU 101 ; 101	 65
GetSetCdPg			EQU 102 ; 102	 66
ExtHandle			EQU 103 ; 103	 67
Commit				EQU 104 ; 104	 68
GetSetMediaID			EQU 105 ; 105	 69
IFS_IOCTL			EQU 107 ; 107	 6B
ExtOpen 			EQU 108 ; 108	 6C
;
;
Set_Oem_Handler 		EQU 248 ; 248	 F8
OEM_C1				EQU 249 ; 249	 F9
OEM_C2				EQU 250 ; 250	 FA
OEM_C3				EQU 251 ; 251	 FB
OEM_C4				EQU 252 ; 252	 FC
OEM_C5				EQU 253 ; 253	 FD
OEM_C6				EQU 254 ; 254	 FE
OEM_C7				EQU 255 ; 255	 FF

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\sysmsg.inc ===
;	PAGE	,132
	SUBTTL	DOS - Message Retriever - SYSTEM CONTROL file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DOS -- Message Retriever
;; (c) Copyright 1988 Microsoft
;;
;; File Name:	SYSMSG.INC
;; ----------
;;
;; Description: Message retriever functions are included into source code
;; ------------ by referencing a MSG_SERVICES macro. That macro is defined
;;		here as well as the logic to include necessary .ASM and .INC
;;		files.
;;
;;
;; Documentation Reference:
;; ------------------------
;;		DOS -Message Retriever I0 Document - Feb. ?? 1987
;;		DOS -Message Retriever I1 Document - Mar. ?? 1987
;;		DOS -Message Retriever I2 Document - Mar. ?? 1987
;;		DOS -Final Functional Specification Document - Mar ?? 1987
;;
;; Procedures Contained in This File:
;; ---------------------------------
;;		None
;;
;; Include Files Required:
;; -----------------------
;;		MSGSERV.INC	   := All message services
;;		????		   := ????
;;
;; External Procedure References:
;; ------------------------------
;;		None
;;
;; Linkage Instructions:
;; --------------------
;;		None
;;
;; Change History:
;; ---------------
;;		CREATED 	March, 1987	RPS
;;
;; Psuedocode:
;; -----------
;;		None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
INCLUDE        VERSIONA.INC	       ;;AN003;;

FALSE	       = 0		       ;;
TRUE	       = NOT FALSE	       ;;    List message services and flags
				       ;;

; Control Characters For Message Skeleton file

NULL			EQU	00H    ;; Null
BELL			EQU	07H    ;; Bell
TAB			EQU	09H    ;; Tab
LF			EQU	0AH    ;; Line Feed
HOME			EQU	0BH    ;; Home
FORMFD			EQU	0CH    ;; Form Feed
CR			EQU	0DH    ;; Carriage Return
COLON			EQU	3AH    ;; Colon

; SYSDISPMSG and SYSGETMSG Equates

MSG_SER_CLASS		EQU	00H    ;; Message Service Class (reserved)
EXT_ERR_CLASS		EQU	01H    ;; DOS Extended error class
PARSE_ERR_CLASS 	EQU	02H    ;; Parse error class
UTILITY_MSG_CLASS	EQU	0FFH   ;; Utility message class

NO_HANDLE		EQU	0FFFFH ;; No handle specified (Use DOS functions 01H-09H only)

NO_REPLACE		EQU	0000H  ;; No replacable parameters

; SUBLIST Equates

  Sublist_Length	EQU	11     ;; Length of sublist structure
  Reserved		EQU	0      ;; Reserved byte field

  Left_Align		EQU	0      ;;00xxxxxx
  Right_Align		EQU	80h    ;;10xxxxxx

  Char_type		EQU	0      ;;axxx0000 - Character type
  Char_Field_Char	EQU	0      ;;a0000000
  Char_Field_ASCIIZ	EQU	10h    ;;a0010000

  Unsgn_Bin_Type	EQU	01h    ;;axxx0001 - Unsigned Binary to Decimal character
  Unsgn_Bin_Byte	EQU	11h    ;;a0010001
  Unsgn_Bin_Word	EQU	21h    ;;a0100001
  Unsgn_Bin_DWord	EQU	31h    ;;a0110001

  Sgn_Bin_Type		EQU	02h    ;;axxx0010 - Signed Binary to Decimal character
  Sgn_Bin_Byte		EQU	12h    ;;a0010010
  Sgn_Bin_Word		EQU	22h    ;;a0100010
  Sgn_Bin_DWord 	EQU	32h    ;;a0110010

  Bin_Hex_Type		EQU	03h    ;;axxx0011 - Unsigned Binary to Hexidecimal character
  Bin_Hex_Byte		EQU	13h    ;;a0010011
  Bin_Hex_Word		EQU	23h    ;;a0100011
  Bin_Hex_DWord 	EQU	33h    ;;a0110011

  Date_Type		EQU	04h    ;;axxx0100 - Date to character using current country format
  Date_MD		EQU	14h    ;;a0010100
  Date_MDY_2		EQU	24h    ;;a0100100
  Date_MDY_4		EQU	34h    ;;a0110100

  Time_Cty_Type 	EQU	05h    ;;axxx0101 - Time to character using current country format
  Time_HHMM_Cty 	EQU	05h    ;;a0000101
  Time_HHMMSS_Cty	EQU	15h    ;;a0010101
  Time_HHMMSSHH_Cty	EQU	25h    ;;a0100101

  Time_24_Type		EQU	06h    ;;axxx0110 - Time to character using 24 hour format
  Time_HHMM_24		EQU	06h    ;;a0000110
  Time_HHMMSS_24	EQU	16h    ;;a0010110
  Time_HHMMSSHH_24	EQU	26h    ;;a0100110

  $M_EXTPAR_Type	EQU	08h    ;;axxx1000 - Special case for extended parse replace format

NO_INPUT		EQU	00H    ;; No input characters
DOS_KEYB_INP		EQU	01H    ;; DOS INT 21H - AH=01H := Keyboard Input
DOS_DIR_CON_INP 	EQU	07H    ;; DOS INT 21H - AH=07H := Direct Console Input Without Echo
DOS_CON_INP		EQU	08H    ;; DOS INT 21H - AH=08H := Console Input Without Echo (Check CTL-BK)
DOS_BUF_KEYB_INP	EQU	0AH    ;; DOS INT 21H - AH=0AH := Buffered Keyboard Input
DOS_CLR_KEYB_BUF	EQU	0CH    ;; DOS INT 21H - AH=0CH := Clear keyboard buffer
DOS_WRITE_HANDLE	EQU	40H    ;; DOS INT 21H - AH=40H := Write to a DOS handle
DOS_DISP_STRING 	EQU	09H    ;; DOS INT 21H - AH=09H := Display $ terminated string
DOS_DISP_CHAR		EQU	02H    ;; DOS INT 21H - AH=02H := Display Character
LOWEST_4CH_VERSION	EQU	0002H  ;; First DOS version to allow AH = 4CH Exit (VERSION 2.00)

DOS_GET_DBCS_INFO	EQU   6300H    ;; DOS INT 21H - AX=6507H := Get DBCS Vector Table
DOS_GET_EXT_ERROR	EQU	59H    ;; DOS INT 21H - AH=59H := Get Extended Error
DOS_GET_EXT_ERROR_BX	EQU	00H    ;; DOS INT 21H - BX=0000H := Version 0

DOS_EXTENDED_OPEN	EQU   6C00H    ;AN003; DOS INT 21H - AX=6C00H := Extended Open
NO_CRIT_OPEN		EQU   2000H    ;AN003; Extended Open Mode bit
NOT_EX_FAIL_EX_OPEN	EQU   0101H    ;AN003; Extended Open Flag
DOS_LSEEK_FILE		EQU   4200H    ;AN003; DOS INT 21H - AX=4200H := LSEEK file
DOS_READ_BYTE		EQU	3FH    ;AN003; DOS INT 21H - AH=3FH   := Read byte block
DOS_CLOSE_FILE		EQU	3EH    ;AN003; DOS INT 21H - AH=3EH   := Close file handle

IFSFUNC_INSTALL_CHECK	EQU   0500H    ;AN006; IFSFUNC Installation Check
IFS_GET_ERR_TEXT	EQU   0502H    ;AN006; IFSFUNC Get Extended Error Text
IFSFUNC_INSTALLED	EQU    0FFH    ;AN006; Return code if IFSFUNC is installed

EXT_ERR_39		EQU	39     ;; Insufficent Disk Space EXTENDED ERROR (changed from hex to decimal - eg d201)
ERROR_CLASS_39		EQU	01H    ;;   Error Class = 1
ACTION_39		EQU	04H    ;;   Suggested Action = 4
LOCUS_39		EQU	01H    ;;   Locus = 1

DOS_GET_COUNTRY 	EQU	38H    ;; DOS INT 21H - AH=38H := Get Country Dependant Information
DOS_GET_VERSION 	EQU	30H    ;; DOS INT 21H - AH=30H := Get DOS Version number
DOS_IOCTL_GET_INFO	EQU	4400H  ;; DOS INT 21H - AH=4400H := I/O control for devices
DOS_IOCTL_SET_INFO	EQU	4401H  ;; DOS INT 21H - AH=4401H := I/O control for devices
DOS_GET_EXT_PARSE_ADD	EQU	122EH  ;; DOS INT 2FH - AX=122EH := Get Extended/Parse error address
DOS_GET_EXTENDED	EQU	00     ;; DOS INT 2FH - AX=122EH - DL=00 := Get Extended address
DOS_GET_PARSE		EQU	02     ;; DOS INT 2FH - AX=122EH - DL=02 := Get Parse address
DOS_GET_CRITICAL	EQU	04     ;; DOS INT 2FH - AX=122EH - DL=04 := Get Critical address
DOS_GET_FILE		EQU	06     ;; DOS INT 2FH - AX=122EH - DL=06 := Get File system dependant
DOS_GET_ADDR		EQU	08     ;; DOS INT 2FH - AX=122EH - DL=08 := Get Address of READ_DISK_PROC
DOS_SET_ADDR		EQU	09     ;; DOS INT 2FH - AX=122EH - DL=09 := Set Address of READ_DISK_PROC
LOW_NIB_MASK		EQU	0FH    ;; Mask out the high byte
DOS_CLR_KEYB_BUF_MASK	EQU	0C0H   ;; Check if high nibble is C Hex
$M_CON_INP		EQU	-1     ;; If DOS INT 21H Function 06H - DL := 0FFH for input
$M_CRIT_LO		EQU	19     ;; First Extended Error considered CRITICAL
$M_CRIT_HI		EQU	39     ;; Last Extended Error considered CRITICAL (EG - D191)
$M_AM			EQU	"a"    ;; Time format AM indicator
$M_PM			EQU	"p"    ;; Time format PM indicator
$M_NEG_SIGN		EQU	"-"    ;; Signed decimal number format negative indicator
$M_DEF_TIME_FORM	EQU	 1     ;; Default Time format - 24 hour
$M_DEF_DATE_FORM	EQU	 0     ;; Default Time format - 0 := USA format
$M_DEF_TIME_SEP 	EQU	":"    ;; Default Time separator - ":"
$M_DEF_DATE_SEP 	EQU	"-"    ;; Default Time separator - "-"
$M_DEF_DECI_SEP 	EQU	"."    ;; Default Time hundreds separator - "."
$M_TIMEDATE_PAD 	EQU	"0"    ;; Time/Date PAD character - "0" (ie 12:03p)
$M_MAX_2_YEAR		EQU	99     ;; Maximum 2 digit year
$M_SINGLE_CHAR		EQU	1      ;; A single character is this long      ^
$M_SPECIAL_CASE 	EQU	30H    ;; Special case for replacable parameters %0
$M_UNLIM_W		EQU	0      ;; Unlimited width character
$M_COMMA		EQU	","    ;; Default Thousand separate
$M_CR_LF		EQU	0A0DH  ;; Default CR/LF
$M_SPACE_HYP		EQU	"- "   ;; Default Space/Hyphan
$M_SPACE		EQU	" "    ;; Default Space
$M_NULL 		EQU	0      ;; Null
$M_FIRST_THOU		EQU	3      ;; Location of first thousand separator
$M_SECOND_THOU		EQU	6      ;; Location of second thousand separator
$M_THIRD_THOU		EQU	9      ;; Location of third thousand separator
$M_BASE10		EQU	10     ;; Base 10 for arthmetic
$M_BASE16		EQU	16     ;; Base 16 for arthmetic
$M_CLASS_NOT_EXIST	EQU	 0     ;; Does class exist?
$M_TERMINATING_FLAG	EQU	-1     ;; Is there any more classes?
$M_ADDR_SZ_NEAR 	EQU	2      ;; Size to increment if NEAR
$M_ADDR_SZ_FAR		EQU	4      ;; Size to increment if FAR
$M_SL			EQU   DS:[SI]  ;; Refer to SUBLIST as $M_SL
$M_NO_HANDLE		EQU	-1     ;; No handle flag
$M_TEMP_BUF_SZ		EQU	64     ;; Size of temporary buffer	 ;AN003;
$M_NEXT_DBCS_VECTOR	EQU	2      ;; Amount to increment to get next vector
$M_DBCS_TERM		EQU    0000    ;; DBCS vector table terminating flag
$M_SPECIAL_MSG_NUM	EQU    0FFFFH  ;; Special generic message number
$M_CRLF_SIZE		EQU    2       ;; Size of the CR LF message
$M_NO_CRLF_MASK 	EQU  10000000B ;; Mask to supress CR LF
$M_ONE_REPLACE		EQU    1       ;; Indicate one replacement
$M_CRIT_ERR_MASK	EQU  00000001B ;; Mask to allow EOF/EOI Crit error
				       ;;
$M_ALIGN_MASK		EQU  10000000b ;; Mask for align
$M_TYPE_MASK		EQU  00001111b ;; Mask for types
$M_SIZE_MASK		EQU  00110000b ;; Mask for types
$M_TIME_MASK		EQU  00000001b ;; Mask for TIME
$M_DATE_MASK		EQU  00010000b ;; Mask for TIME
$M_BYTE 		EQU  00010000b ;; BYTE indicator
$M_WORD 		EQU  00100000b ;; WORD indicator
$M_DWORD		EQU  00110000b ;; DWORD indicator

; Standard reserved DOS handles

STDIN			EQU	0000H  ;; Standard Input device handle
STDOUT			EQU	0001H  ;; Standard Output device handle
STDERR			EQU	0002H  ;; Standard Error Output device handle
STDAUX			EQU	0003H  ;; Standard Auxiliary device handle
STDPRN			EQU	0004H  ;; Standard Printer device handle

ifdef BILINGUAL

; BILINGUAL equates

EXT_MSG_ADJ		EQU	90
PARSE_MSG_ADJ		EQU	11
UTILITY_MSG_ADJ		EQU	8000

endif

; Reserved Message Service equates

NEARmsg 		 =	TRUE   ;; \
NOVERCHECKmsg		 =	FALSE  ;;  |
MSGDATA 		 =	FALSE  ;;  |
FARmsg			 =	FALSE  ;;  |
GETmsg			 =	FALSE  ;;  |
LOADmsg 		 =	FALSE  ;;  |
DISPLAYmsg		 =	FALSE  ;;   } Set default cases
SETSTDIO		 =	FALSE  ;;  |
NOCHECKSTDIN		 =	FALSE  ;;  |
NOCHECKSTDOUT		 =	FALSE  ;;  |
DISK_PROC		 =	FALSE  ;;  |			       ;AN003;
INPUTmsg		 =	FALSE  ;;  |
CHARmsg 		 =	FALSE  ;;  |
NUMmsg			 =	FALSE  ;;  |
TIMEmsg 		 =	FALSE  ;;  |
DATEmsg 		 =	FALSE  ;; /

IF1				       ;;
COMR			 =	FALSE  ;;  COMMAND.COM Cases (resident)
COMT			 =	FALSE  ;;		     (transient)
ENDIF				       ;;

$M_STRUC		 =	TRUE   ;; Internal message service defaults
$M_LOAD 		 =	TRUE   ;;
$M_SUBS 		 =	TRUE   ;;
$M_REPLACE		 =	TRUE   ;;
$M_REPL_DONE		 =	FALSE  ;;
$M_CHAR_ONLY		 =	TRUE   ;;
$M_PARSE_FLAG		 =	TRUE   ;;
$M_EXT_ERR_FLAG 	 =	TRUE   ;;
$M_MSGDATA_ONLY 	 =	TRUE   ;;
$M_END			 =	FALSE  ;;
$M_EXT_CLS		 =	TRUE   ;;
$M_PAR_CLS		 =	TRUE   ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	$M_POPF 	     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

$M_POPF    MACRO
	   LOCAL   $M_MYRET
	   JMP	   $+3
$M_MYRET   LABEL   NEAR
	   IRET
	   PUSH    CS
	   CALL    $M_MYRET
ENDM

; This Macro was removed from sysmsg.inc. We had to remove this
; macro and put it into it's own include file in order to clear up
; some assembly errors. MS MASM will not allow a public declaration
; during the second pass of the assembler. IBM MASM will allow this.
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	$M_DECLARE	     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;
;$M_DECLARE    macro	numcls	       ;
;   $M_DCOUNT = 0		       ;
;   REPT  numcls 		       ;
;     $M_DCOUNT =  $M_DCOUNT + 1        ;
;     $M_DECLARE2  %$M_DCOUNT	       ;
;   ENDM 			       ;
;
;  IF COMR
;    IFNDEF $M_RT2			;  If Resident table is not in this assembly,
;	EXTRN	$M_RT2:BYTE		;     Must be external
;    ELSE
;	PUBLIC	$M_RT2
;    ENDIF				;
;  ELSE
;    IFNDEF $M_RT			;  If Resident table is not in this assembly,
;	EXTRN	$M_RT:BYTE		;     Must be external
;    ELSE
;	PUBLIC	$M_RT
;    ENDIF				;
;  ENDIF
;
;  $M_CHECK $M_GET_MSG_ADDRESS	      ;  If this subroutine is not in this assembly,
;  $M_CHECK $M_MSGSERV_1 	      ;  If this subroutine is not in this assembly,
;  $M_CHECK $M_MSGSERV_2 	      ;  If this subroutine is not in this assembly,
;
;ENDM				       ;
;				       ;
;$M_DECLARE2   macro   innum	       ;
;  IF NOT COMR			       ; IF Not resident COMMAND.COM
;    IF NOT COMT 			 ; IF Not transient COMMAND.COM
;      IFNDEF  $M_CLS_&innum		 ; IF class is not in this assembly,
;	IF	FARmsg			 ;
;	  EXTRN   $M_CLS_&innum:FAR	 ;    Must be external
;	ELSE				 ;
;	  EXTRN   $M_CLS_&innum:NEAR	 ;    Must be external
;	ENDIF				 ;
;      ELSE				 ; ELSE
;	PUBLIC	$M_CLS_&innum		 ;    Label PUBLIC
;      ENDIF				 ;
;    ELSE				 ; ELSE
;      IFDIF  <$M_CLS_&innum>,<$M_CLS_1>  ; IF NOT $M_CLS_1 or
;	IFDIF <$M_CLS_&innum>,<$M_CLS_2> ;   IF NOT $M_CLS_2 then
;	  IFNDEF  $M_CLS_&innum 	 ;     IF class is not in this assembly,
;	    IF	    FARmsg		 ;
;	      EXTRN   $M_CLS_&innum:FAR  ;	 Must be external
;	    ELSE			 ;
;	      EXTRN   $M_CLS_&innum:NEAR ;	 Must be external
;	    ENDIF			 ;
;	  ELSE				 ;     ELSE
;	    PUBLIC  $M_CLS_&innum	 ;	 Label PUBLIC
;	  ENDIF 			 ;
;	ENDIF				 ;
;      ENDIF				 ;
;    ENDIF				 ;
;  ELSE					 ; ELSE
;    IFDIF  <$M_CLS_&innum>,<$M_CLS_1>	 ; IF NOT $M_CLS_1 or
;      IFDIF <$M_CLS_&innum>,<$M_CLS_2>	 ;   IF NOT $M_CLS_2 then
;	IFNDEF	$M_CLS_&innum		 ;     IF class is not in this assembly,
;	  IF	  FARmsg		 ;
;	    EXTRN   $M_CLS_&innum:FAR	 ;	 Must be external
;	  ELSE				 ;
;	    EXTRN   $M_CLS_&innum:NEAR	 ;	 Must be external
;	  ENDIF 			 ;
;	ELSE				 ;     ELSE
;	  PUBLIC  $M_CLS_&innum 	 ;	 Label PUBLIC
;	ENDIF				 ;
;      ENDIF				 ;
;    ENDIF				 ;
;  ENDIF 			       ;
;ENDM				       ;
;				       ;
;$M_CHECK      macro   parm	       ;
;  IFNDEF  parm			       ; IF class is not in this assembly,
;    IF	    FARmsg		       ;
;      EXTRN   parm:FAR		       ;    Must be external
;    ELSE			       ;
;      EXTRN   parm:NEAR 	       ;    Must be external
;    ENDIF			       ;
;  ELSE
;    IF COMR
;    ELSE
;      PUBLIC parm
;    ENDIF
;  ENDIF 			       ;
;ENDM				       ;
;				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;
;IF2				       ;
;  $M_DECLARE %$M_NUM_CLS	       ;  Declare any class not in this assembly
;ENDIF				       ;
;				       ;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Message Retreiver requests
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;
MSG_UTILNAME  Macro   utilname	       ;
				       ;
   INCLUDE &utilname.CTL	       ;  Include the control file for the utility
   $M_STRUC = TRUE		       ;
   INCLUDE MSGSERV.ASM		       ;  Get structure definitions
				       ;
ENDM				       ;
				       ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	MSG_SERVICES		Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					  ;
MSG_SERVICES Macro   varlist		  ;  MACRO used in source routine
					  ;
   $M_SERVICE = FALSE			  ;  Reset service flag
   IRP	   var,<varlist>		  ;  FOR each variable in the list
     $M_INCLUDE = TRUE			  ;  Reset include flag
					  ;	For each service predefined

IRP  serv,<MSGDATA,LOADmsg,NOVERCHECKmsg,DISPLAYmsg,GETmsg,INPUTmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,NEARmsg,FARmsg,COMR,COMT>

	 IFDIF <var>,<serv>		  ;	  IF it IS a service (defined above)
	 ELSE				  ;
	   IFDIF <var>,<MSGDATA>	  ;	    IF it is NOT the message data space request
	     $M_MSGDATA_ONLY = FALSE	  ;	       Instruct the assembler to include all services
	   ENDIF			  ;	    ENDIF
	   IRP	repl,<CHARmsg,NUMmsg,TIMEmsg,DATEmsg>  ; IF it is a replace service
	     IFIDN  <var>,<repl>	  ;
	       $M_REPLACE = TRUE	  ;	       Set replace flag
	     ENDIF			  ;
	   ENDM 			  ;
	   serv = TRUE			  ;	    Let the assembler know about the service
	   $M_SERVICE = TRUE		  ;	    Let the macro know it was a service
	   $M_INCLUDE = FALSE		  ;	    Let the macro know it wasn't a class
	 ENDIF				  ;	  ENDIF
      ENDM				  ;	NEXT service

MSG_SERVICES2  <varlist>
					  ; Continue further checks (If we add any more predefined
					  ;  function to the above IRP command, it generates a
					  ;  syntax error. We must continue the processing in another
					  ;  MACRO called MSG_SERVICES2)

      IF $M_INCLUDE			  ;	IF message class was requested
	 $M_INC var			  ;	   Include it as a message class
      ENDIF				  ;	ENDIF
   ENDM 				  ;  NEXT variable
					  ;
   IF $M_SERVICE			  ;	IF it any services were requested THEN
     INCLUDE MSGSERV.ASM		  ;	   THEN include module to get service
   ENDIF				  ;	ENDIF

ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	MSG_SERVICES2		Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					  ;
MSG_SERVICES2 Macro   varlist2		  ;  MACRO used in source routine
					  ;
					    ;  FOR each variable in the list
   IRP	   var2,<varlist2>
						       ; For each service predefined
      IRP  serv2,<SETSTDIO,NOCHECKSTDIN,NOCHECKSTDOUT,DISK_PROC>
					    ;AN003; IF it IS a service (defined above)
	 IFDIF <var2>,<serv2>
	 ELSE				  ;
	   serv2 = TRUE 		   ;	     Let the assembler know about the service
	   $M_SERVICE = TRUE		  ;	    Let the macro know it was a service
	   $M_INCLUDE = FALSE		  ;	    Let the macro know it wasn't a class
	 ENDIF				  ;	  ENDIF
      ENDM				  ;	NEXT service
   ENDM 				  ;  NEXT variable
ENDM					  ;
					  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_INC		Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_INC	Macro	ext				 ;
						 ;
INCLUDE &ext					 ;
						 ;
ENDM						 ;
						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_BUILD_PTRS	Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_BUILD_PTRS Macro nummsg			 ;
						 ;
    $M_INDEX =	    0				 ;
IF COMR 				     ; IF this is resident COMMAND.COM
    $M_MAKE_COMR			     ;
ELSE						 ; ELSE
  IF COMT				     ;	 IF this is transient COMMAND.COM
    $M_MAKE_COMT			     ;
  ELSE						 ;   ELSE
						 ;
    $M_INDEX =	    0				 ;
    $M_COUNT =	    0				 ;     Build normal utilities
						 ;
    REPT    nummsg				 ;
    $M_COUNT =	    $M_COUNT + 1		 ;
    $M_MAKE %$M_COUNT				 ;
    ENDM					 ;
  ENDIF 					 ;
ENDIF						 ;
ENDM						 ;
						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_MAKE		Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_MAKE Macro $m_append 			 ;
IF  FARmsg					 ;
    CALL    FAR PTR $M_CLS_&$m_append		 ;  Get addressibilty to class &$M_APPEND (ES:DI)
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX+2,ES ;  Move into first avaliable table location
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
ELSE						 ;
    CALL    $M_CLS_&$m_append			 ;  Get addressibilty to class &$M_APPEND (ES:DI)
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
ENDIF						 ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
ENDM						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_MAKE_COMR     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_MAKE_COMR   macro			     ;
						 ;
    CALL    $M_CLS_3				 ;  Get addressibilty to class A
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
    CALL    $M_CLS_4				 ;  Get addressibilty to class B
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
    CALL    $M_CLS_5				 ;  Get addressibilty to class C
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
    CALL    $M_CLS_6				 ;  Get addressibilty to class D
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
    CALL    $M_CLS_7				 ;  Get addressibilty to class E
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
ENDM						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; $M_MAKE_COMT     Macro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;
$M_MAKE_COMT  macro			     ;
						 ;
;;    CALL    $M_CLS_8				 ;  Get addressibilty to class A
    CALL    $M_CLS_3				 ;  Get addressibilty to class F
    MOV     WORD PTR $M_RT.$M_CLASS_ADDRS+$M_INDEX,DI ;
$M_INDEX =  $M_INDEX + 4			 ;  Set next available table location
						 ;
ENDM						 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\vector.inc ===
;	SCCSID = @(#)vector.asm	1.1 85/04/10
BREAK <interrupt definitions>

Asmvar	AltVect

INTTAB		EQU	20H
INTBASE 	EQU	4 * inttab
ENTRYPOINT	EQU	INTBASE+40H

	IF	ALTVECT
ALTTAB	EQU	0F0H
ALTBASE EQU	4 * ALTTAB
	ENDIF

;
; interrupt assignments
;
	IF	NOT ALTVECT
int_abort	    EQU     INTTAB	; abort process
int_command	    EQU     int_abort+1 ; call MSDOS
int_terminate	    EQU     int_abort+2 ; int to terminate address
int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
int_fatal_abort     EQU     int_abort+4 ; hard disk error
int_disk_read	    EQU     int_abort+5 ; logical sector disk read
int_disk_write	    EQU     int_abort+6 ; logical sector disk write
int_keep_process    EQU     int_abort+7 ; terminate program and stay
					; resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
int_spooler	    EQU     int_abort+8 ; spooler call
int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
int_IBM 	    EQU     int_abort+10; critical section maintenance
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
	ELSE
int_abort	    EQU     INTTAB	; abort process
int_command	    EQU     int_abort+1 ; call MSDOS
int_terminate	    EQU     ALTTAB	; int to terminate address
int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
int_fatal_abort     EQU     int_terminate+2 ; hard disk error
int_disk_read	    EQU     int_abort+5 ; logical sector disk read
int_disk_write	    EQU     int_abort+6 ; logical sector disk write
int_keep_process    EQU     int_abort+7 ; terminate program and stay resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
int_spooler	    EQU     int_terminate+3 ; spooler call
int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
	ENDIF

addr_int_abort		EQU    4 * int_abort
addr_int_command	EQU    4 * int_command
addr_int_terminate	EQU    4 * int_terminate
addr_int_ctrl_c 	EQU    4 * int_ctrl_c
addr_int_fatal_abort	EQU    4 * int_fatal_abort
addr_int_disk_read	EQU    4 * int_disk_read
addr_int_disk_write	EQU    4 * int_disk_write
addr_int_keep_process	EQU    4 * int_keep_process
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
addr_int_spooler	EQU    4 * int_spooler
addr_int_fastcon	EQU    4 * int_fastcon
addr_int_IBM		EQU    4 * int_IBM
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\sysvar.inc ===
;	SCCSID = @(#)sysvar.asm 1.1 85/04/10

SysInitVars STRUC
SYSI_DPB	    DD	    ?		; DPB chain
SYSI_SFT	    DD	    ?		; SFT chain
SYSI_CLOCK	    DD	    ?		; CLOCK device
SYSI_CON	    DD	    ?		; CON device
SYSI_MAXSEC	    DW	    ?		; maximum sector size
SYSI_BUF	    DD	    ?		; points to Hashinitvar
SYSI_CDS	    DD	    ?		; CDS list
SYSI_FCB	    DD	    ?		; FCB chain
SYSI_Keep	    DW	    ?		; keep count
SYSI_NUMIO	    DB	    ?		; Number of block devices
SYSI_NCDS	    DB	    ?		; number of CDS's
SYSI_DEV	    DD	    ?		; device list
SYSI_ATTR	    DW	    ?		; null device attribute word
SYSI_STRAT	    DW	    ?		; null device strategy entry point
SYSI_INTER	    DW	    ?		; null device interrupt entry point
SYSI_NAME	    DB	 8 DUP(?)	; null device name
SYSI_SPLICE	    DB	    0		; TRUE -> splicees being done
SYSI_IBMDOS_SIZE    DW	    ?		; DOS size in paragraphs
SYSI_IFS_DOSCALL@   DD	    ?		; IFS DOS service rountine entry
SYSI_IFS	    DD	    ?		; IFS header chain
SYSI_BUFFERS	    DW	    ?,0 	; BUFFERS= values (m,n)
SYSI_BOOT_DRIVE     DB	    ?		; boot drive A=1 B=2,..
SYSI_DWMOVE	    DB	    0		; 1 if 386 machine
SYSI_EXT_MEM	    DW	    0		; Extended memory size in KB.
SysInitVars ENDS

;This is added for more information exchage between DOS, BIOS.
;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
SysInitVars_Ext struc
SYSI_InitVars		DD	0	; Points to the above structure.
SYSI_Country_Tab	DD	0	; DOS_Country_cdpg_info
SysInitVars_Ext ends

;The SYSI_BUF of SysInitVars points to the follwong structure
EMS_MAP_BUFF_SIZE      EQU	12	; EMS map buffer size

Buffinfo    STRUC
Buff_Queue	 DD	 ?		     ; Head of list of buffers
Dirty_Buff_Count DW	 ?		     ; number of dirty buffers in list
Cache_ptr	 DD	 ?		     ; pointer to secondary cache
Cache_count	 DW	 0		     ; number of secondary cache entries

Buff_In_HMA	db	0		     ; flag to indicate that buffers
					     ; are in HMA
Lo_Mem_Buff	dd	0		     ; Ptr to scratch buff in Low Mem
					     ;  used to read/write on disks

;smr; removal of BUFFERFLAG; IF	BUFFERFLAG

UU_EMS_FIRST_PAGE	DW	0, 0
UU_EMS_NPA640	DW	0

;smr; removal of BUFFERFLAG; ENDIF

UU_EMS_mode	 DB	 -1		     ; no EMS = -1
UU_EMS_handle	 DW	 ?		     ; EMS handle for buffers
UU_EMS_PageFrame_Number	DW   -1 	     ; EMS page frame number
UU_EMS_Seg_Cnt	 DW	 1		     ; EMS segment count
UU_EMS_Page_Frame	 DW	 -1		     ; EMS page frame segment address
UU_EMS_reserved	 DW	 0		     ; EMS segment count

;smr; removal of BUFFERFLAG; IF	BUFFERFLAG
UU_EMS_Map_Buff	 DB	 0  ; map buffer
;smr; removal of BUFFERFLAG; ELSE
;smr; removal of BUFFERFLAG; EMS_Map_Buff	DB	12 dup(0)
;smr; removal of BUFFERFLAG; ENDIF

Buffinfo    ENDS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\versiona.inc ===
major_version	    equ     5	    ;Major DOS version
minor_version	    equ     00	    ;Minor DOS Version for int 21h/30h
minor_version_NT    equ     50	    ;Minor DOS VersionN for int 21h/3306

expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION

DOSREVNM	equ	00000000B	; bits 0-2 = revision number of DOS
					; currently 0.
DOSINROM	equ	00001000B	; bit 3 of ver flags returned in BH
DOSINHMA	equ	00010000B	; bit 4 of ver flags 


;      if1
;      %OUT  ... for DOS Version 5.00 ...
;      endif

       ;******************************
       ;Each assembler program should:
       ;  mov ah,030h			;DOS Get Version function
       ;  int 021h			;Version ret. in AX,minor version first
       ;  cmp ax,expected_version	;ALL utilities should check for an
       ;  jne error_handler		; EXACT version match.
       ;******************************


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\struc.inc ===
;;STRUC--Stucture Macro Library
;;Optimizing Version 2.30  03/31/87

if1
$NoConj 	equ	0
$And		equ	1
$Or		equ	2
$Short		equ	3
$Near		equ	4
$NearToShort	equ	5
$ncxz		equ	6
$AndOr		=	0
$Temp		=	0
$Temp2		=	0
$Dist		=	0

$NoType 	equ	10
$ConjIfType	equ	11
$IfType 	equ	12
$ElseType	equ	13
$WhileType	equ	14
$ConjWhileType	equ	15
$RepeatType	equ	16
$ConjUntilType	equ	17
$ForType	equ	18
$ConjLeaveType	equ	19
$SelectType	equ	20
$WhenType	equ	21
$ConjWhenType	equ	22
$OtherwiseType	equ	$ElseType

$StrucError macro text
					Structure error -- text
endm

J	macro
endm
JN	macro
endm

$BuildJump   macro   j1,j2
	j1  macro   t
	    .xcref  j1
					j2 t
	endm
endm

irp	x,<<jeq,je>,<jlt,jl>,<jgt,jg>,<jneq,jne>,<jnlt,jnl>,<jngt,jng>,<jnpe,jpo>,<jnpo,jpe>>
	$BuildJump x
endm
irp	x,<<jzero,jz>,<jnzero,jnz>,<jnonzero,jnz>,<jnnonzero,jz>,<jand,jnz>,<jnand,jz>,<jnnand,jnz>>
	$BuildJump x
endm
irp	x,<a,ae,b,be,c,e,g,ge,l,le,o,p,s,z,cxz>
	$BuildJump jnn&x,j&x
endm

jncxz	macro	t
	if	$Dist eq $NearToShort
					jcxz $+5
					jmp t
	else
					jcxz $+4
					jmp short t
	endif
endm

purge	$BuildJump

$GetConj macro	p1,p2
	$AndOr	= $NoConj
	irp	parm,<p1,p2>
	    ifnb    <&parm>
		irp	x,<and,AND,or,OR>
		    ifidn   <parm>,<x>
			 $AndOr = $&&&x
			 exitm
		    endif
		endm
	    endif
	endm
endm

$GetDist macro	p1,p2
	irp	parm,<p1,p2>
	    ifnb    <parm>
		irp	x,<short,SHORT,near,NEAR>
		    ifidn   <parm>,<x>
			$Dist	= $&&&x
			 exitm
		     endif
		endm
	    endif
	endm
endm


$Poke	macro	n,m
	$st&n	= m
.xcref	$st&n
endm

$Peek	macro	x,n
	x	= $st&n
endm

$Push	macro	n
	$st	= $st+1
	$Poke	%$st,n
endm

$Pop	macro	x
	if	$st gt 0
	    $Peek   x,%$st
	    $st     = $st-1
	else
	    $StrucError <open structure>
	endif
endm

$EquateLabel macro last,this
	if	$LastLabelOrg eq $
	    $ll&last = this
	    .xcref  $ll&last
	endif
endm

$TraceLabel macro n,a,b
	if	$ll&a eq $ll&b
	    $ll&n   = b
	    .xcref  $ll&n
	else
	    $TraceLabel n,%$ll&a,%$ll&b
	endif
endm

$Label	 macro	 n
	if1
	    $EquateLabel %$LastLabel,n
	    $ll&n   = n
	    .xcref  $ll&n
	    $LastLabel = n
	    $LastLabelOrg = $
$l&n:
	else
	    if	    $ll&n eq n
$l&n:
	    else
		.xcref	$l&n
		.xcref	$ll&n
	    endif
	endif
endm

$CondJump macro l,tf,c
	if1
	    ifb     <c>
		$EquateLabel %$LastLabel,l
	    endif
	    ifndef  <$ll&l>
		$ll&l	= l
		.xcref	$ll&l
	    endif
	else
	    $TraceLabel l,l,%$ll&l
	endif
	$CondJump2 %$ll&l,tf,c
endm

$CondJump2 macro l,tf,c
	if	$Dist eq $Short
	    ifb     <c>
					jmp short $l&l
	    else
		ifidn <tf>,<f>
					jn&c $l&l
		else
					j&c $l&l
		endif
	    endif
	else
	    ifnb    <c>
		ifdef	$l&l
		    if	    (($ - $l&l) le 126) and (($l&l - $) le 129)
			$Dist	= $NearToShort
			$nops	= 3
			ifidn <tf>,<f>
					jn&c $l&l
			    ifdef   $n&c
				if	$n&c eq $ncxz
				    $nops = 0
				endif
			    endif
			    ifdef   $&c
				if	$&c eq $ncxz
				    $nops = 5
				endif
			    endif
			else
					j&c $l&l
			    ifdef   $n&c
				if	$n&c eq $ncxz
				    $nops = 5
				endif
			    endif
			    ifdef   $&c
				if	$&c eq $ncxz
				    $nops = 0
				endif
			    endif
			endif
			    rept $nops
				nop
			    endm
		    else
			ifidn <tf>,<f>
					j&c $+5
			else
					jn&c $+5
			endif
					jmp $l&l
		    endif
		else
		    ifidn <tf>,<f>
					j&c $+5
		    else
					jn&c $+5
		    endif
					jmp $l&l
		endif
	    else
		ifdef	$l&l
		    ifidn   <tf>,<NoFold>
					jmp $l&l
		    else
			if	(($ - $l&l) le 126) and (($l&l - $) le 129)
					jmp short $l&l
					nop
			else
					jmp $l&l
			endif
		    endif
		else
					jmp $l&l
		endif
	    endif
	endif
endm


$CondLoop macro l,c
					loop&c $l&l
endm

$Test	macro	tgt,a1,a2,a3,a4,x
	ifb	<a1>
	    $StrucError <invalid condition>
	else
	ifb	<a2>
	    $CondJump %&tgt,a1
	else
	ifb	<a3>
	    ifdif   <a1>,<zero>
	    ifdif   <a1>,<nonzero>
	    ifdif   <a1>,<ZERO>
	    ifdif   <a1>,<NONZERO>
		$StrucError <invalid condition>
		exitm
	    endif
	    endif
	    endif
	    endif
					or a2,a2
	    $CondJump %&tgt,a1
	else
	ifb	<a4>
					cmp a1,a3
	    $CondJump %&tgt,a2
	else
	ifb	<x>
	    ifdif   <a1>,<bit>
	    ifdif   <a1>,<BIT>
		$StrucError <invalid condition>
		exitm
	    endif
	    endif
					test a2,a4
	    $CondJump %&tgt,a3
	else
	    $StrucError <invalid condition>
	endif
	endif
	endif
	endif
	endif
endm

$TopTest macro	args,n,c,p4,p5
	$GetConj p4,p5
	$Dist	= $DefDist
	$GetDist p4,p5
	if	$AndOr eq $NoConj
	    $Test   <$sn-1,f>,args
	    $Pop    $Temp
	    if	    $OrFound
		$Label	%$Temp
	    endif
	    $Push   n
	else
	    if	    $AndOr eq $And
		$Test	<$sn-1,f>,args
	    else
		$OrFound = 1
		$Test	<$sn,t>,args
	    endif
	    $Push   c
	endif
endm
;;*****************************************************************************
.if	macro	t,p2,p3
	$Peek	$Temp,%$st
	if	$Temp eq $ConjIfType
	    $Pop    $Temp
	else
	    $OrFound = 0
	    $sn     = $sn+1
	    $Push   $sn
	    $sn     = $sn+1
	    $Push   $sn
	    $sn     = $sn+1
	    $Push   $sn
	endif
	$TopTest <t>,$IfType,$ConjIfType,p2,p3
endm
;;*****************************************************************************
.then	macro
	$Peek	$Temp,%$st
	if	$Temp ne $IfType
	if	$Temp ne $WhenType
	    $StrucError <then without if or when>
	endif
	endif
endm
;;*****************************************************************************
.elseif macro	t,p2,p3
	$Pop	$Temp
	if	$Temp ne $IfType
	    $StrucError <elseif without if>
	    exitm
	endif
	$OrFound = 0
	$Pop	$Temp
	$Peek	$Temp2,%$st
	$Dist	= $Near
	$CondJump %$Temp2
	$Label	%$Temp
	$sn	= $sn+1
	$Push	$sn
	$sn	= $sn+1
	$Push	$sn
	$TopTest <t>,$IfType,$ConjIfType,p2,p3
endm
;;*****************************************************************************
.else	macro	dist
	$Pop	$Temp
	if	$Temp ne $IfType
	if	$Temp ne $WhenType
	if	$Temp ne $SelectType
	    $StrucError <else without if, when or select>
	    exitm
	endif
	endif
	endif
	$sn	= $sn+1
	if	$Temp eq $SelectType
	    $Push   $sn
	else
	    $Dist   = $DefDist
	    $GetDist dist
	    $CondJump %$sn
	    $Pop    $Temp
	    $Label  %$Temp
	    $Push   $sn
	endif
	$push	$ElseType
endm
;;*****************************************************************************
.endif	macro
	$Pop	$Temp
	if	$Temp ne $IfType
	    if	    $Temp ne $ElseType
		$StrucError <endif without if>
		exitm
	    endif
	endif
	$Pop	$Temp
	$Label	%$Temp
	$Pop	$Temp
	$Label	%$Temp
endm
;;*****************************************************************************
.select macro	x
	$OrFound = 0
	$sn	= $sn+1
	$Push	$sn
	$Push	$SelectType
endm
;;*****************************************************************************
.when	macro	tst,p2,p3
	$Pop	$Temp
	if	$Temp ne $SelectType
	if	$Temp ne $WhenType
	if	$Temp ne $ConjWhenType
	    $StrucError <when without select>
	    exitm
	endif
	endif
	endif
	if	$Temp ne $ConjWhenType
	    $Dist   = $Near
	    $OrFound = 0
	    if	    $Temp eq $WhenType
		$Pop	$Temp2
		$Peek	$Temp,%$st
		$CondJump %$Temp
		$Label	 %$Temp2
	    endif
	    $sn     = $sn+1
	    $Push   $sn
	    $sn     = $sn+1
	    $Push   $sn
	endif
	$TopTest <tst>,$WhenType,$ConjWhenType,p2,p3
endm
;;*****************************************************************************
.otherwise	macro	dist
	$Pop	$Temp
	if	$Temp ne $WhenType
	if	$Temp ne $SelectType
	if	$Temp ne $IfType
	    $StrucError <otherwise without if, when or select>
	    exitm
	endif
	endif
	endif
	$sn	= $sn+1
	if	$Temp eq $SelectType
	    $Push   $sn
	else
	    $Dist   = $DefDist
	    $GetDist dist
	    $CondJump %$sn
	    $Pop    $Temp
	    $Label  %$Temp
	    $Push   $sn
	endif
	$push	$OtherwiseType
endm
;;*****************************************************************************
.endselect	macro
	$Pop	$Temp
	if	$Temp ne $WhenType
	if	$Temp ne $OtherwiseType
	if	$Temp ne $SelectType
	    $StrucError <endselect without select>
	    exitm
	endif
	endif
	endif
	$pop	$Temp2
	if	$Temp ne $SelectType
	    $Label  %$Temp2
	    $Pop    $Temp2
	    $Label  %$Temp2
	endif
endm
;;*****************************************************************************
.while	macro	t,p2,p3
	$Peek	$Temp,%$st
	if	$Temp eq $ConjWhileType
	    $Pop    $Temp
	else
	    $Push   $LoopEnd
	    $OrFound = 0
	    $sn     = $sn + 1
	    $Push   $sn
	    $Label  %$sn
	    $sn     = $sn + 2
	    $Push   $sn
	    $LoopEnd = $sn - 1
	endif
	$TopTest <t>,$WhileType,$ConjWhileType,p2,p3
endm
;;*****************************************************************************
.endwhile macro p1
	$Pop	$Temp
	if	$Temp ne $WhileType
	    $StrucError <endwhile without while>
	    exitm
	endif
	$Dist	= $Near
	$Pop	$Temp
	$CondJump %$Temp,NoFold
	$Label	%$Temp+1
	$Pop	$LoopEnd
endm
;;*****************************************************************************
.repeat macro
	$Push	$LoopEnd
	$Push	$LeaveFound
	$sn	= $sn+1
	$Label	%$sn
	$Push	$sn
	$Push	$RepeatType
	$sn	= $sn+1
	$LoopEnd = $sn
	$LeaveFound = 0
endm
;;*****************************************************************************
.until	macro	t,p2,p3
	$until2 p2,p3,t
endm
$until2 macro	p2,p3,a1,a2,a3,a4,x
	$Pop	$Temp
	if	$Temp ne $RepeatType
	    if	    $Temp ne $ConjUntilType
		$StrucError <until without repeat>
		exitm
	    endif
	else
	    $OrFound = 0
	endif
	$Dist	= $DefDist
	$GetDist p2,p3
	$GetConj p2,p3

	if	$AndOr eq $NoConj
	    $Pop    $Temp
	    ifb     <a1>
		$Dist	= $Near
		$CondJump %$Temp,NoFold
	    else
		$Test	 <$Temp,f>,<a1>,<a2>,<a3>,<a4>,<x>
	    endif
	    if	    $OrFound or $LeaveFound
		$Label	 %$Temp+1
	    endif
	    $Pop    $LeaveFound
	    $Pop    $LoopEnd
	else
	    $Peek   $Temp,%$st
	    if	    $AndOr eq $And
		$Test	 <$Temp,f>,<a1>,<a2>,<a3>,<a4>,<x>
	    else
		$OrFound = 1
		$Test	 <$Temp+1,t>,<a1>,<a2>,<a3>,<a4>,<x>
	    endif
	    $Push   $ConjUntilType
	endif
endm
;;*****************************************************************************
.loop	macro	cond
	$Pop	$Temp
	if	$Temp ne $RepeatType
	    $StrucError <loop without repeat>
	    exitm
	endif
	$Pop	$Temp
	$CondLoop %$Temp,cond
	if	$LeaveFound
	    $Label  %$Temp+1
	endif
	$Pop	$LeaveFound
	$Pop	$LoopEnd
endm
;;*****************************************************************************
.for	macro	index,equals,start,to,stop,by,step,dist
					mov index,start
	$Push	$LoopEnd
	$sn	= $sn+1
	$Push	$sn
	$Label	%$sn
	$sn	= $sn+1
	$LoopEnd = $sn
					cmp index,stop
	$Dist	= $DefDist
	ifb	<step>
	    $Push   1
	    $GetDist by
	    $CondJump %$sn,t,gt
	else
	    $GetDist dist
	    $Push   %(step)
	    if	    step lt 0
		$CondJump %$sn,t,lt
	    else
		$CondJump %$sn,t,gt
	    endif
	endif
	$Push	$ForType
endm
;;*****************************************************************************
.next	macro	index,dist
	$Pop	$Temp
	if	$Temp ne $ForType
	    $StrucError <next without for>
	    exitm
	endif
	$Pop	$Temp
	if	$Temp eq 1
					inc index
	else
	    if	    $Temp eq -1
					dec index
	    else
					add index,$Temp
	    endif
	endif
	$Pop	$Temp
	$Dist	= $Near
	$CondJump %$Temp,NoFold
	$Label	%$Temp+1
	$Pop	$LoopEnd
endm
;;*****************************************************************************
.leave	macro	t,p2,p3
	$leave2 p2,p3,t
endm
$leave2 macro  p2,p3,a1,a2,a3,a4,x
	ife	$LoopEnd
	    $StrucError <leave outside a loop>
	    exitm
	endif
	$LeaveFound = 1
	$Peek	$Temp,%$st
	if	$Temp eq $ConjLeaveType
	    $Pop    $Temp
	else
	    $OrFound = 0
	    $sn     = $sn + 1
	endif
	$Dist	= 0
	$GetDist <a1>
	if	$Dist
	    $CondJump %$LoopEnd
	    if	    $OrFound
		$Label	%$sn
	    endif
	else
	    $Dist   = $DefDist
	    $GetDist p2,p3
	    $GetConj p2,p3
	    if	    $AndOr eq $NoConj
		ifb	<a1>
		    $CondJump %$LoopEnd,t
		else
		    $Test   <$LoopEnd,t>,<a1>,<a2>,<a3>,<a4>,<x>
		endif
		if	$OrFound
		    $Label  %$sn
		endif
	    else
		if	$AndOr eq $And
		    $OrFound = 1
		    $Test   <$sn,f>,<a1>,<a2>,<a3>,<a4>,<x>
		else
		    $Test   <$LoopEnd,t>,<a1>,<a2>,<a3>,<a4>,<x>
		endif
		$Push	$ConjLeaveType
	    endif
	endif
endm
;;*****************************************************************************
else	       ;else for if1
$Pop	$Temp
;;if	   $Temp ne $NoType
if	$st ne 0
     $StrucError <open structure(s)>
endif
.xcref $NoConj,$And,$Or,$Short,$Near,$NearToShort,$AndOr,$Temp,$Temp2,$Dist
.xcref $NoType,$ConjIfType,$IfType,$ElseType,$WhileType,$ConjWhileType
.xcref $RepeatType,$ConjUntilType,$ForType,$ConjLeaveType,jncxz
.xcref $SelectType,$WhenType,$OtherwiseType,$ConjWhenType
.xcref jeq,jgt,jlt,jneq,jngt,jnlt,jnna,jnnae,jnnb,jnnbe,jnnc,jnncxz
.xcref jnne,jnng,jnnge,jnnl,jnnle,jnno,jnnp,jnns,jnnz,jnpe,jnpo,$BuildJump
.xcref $GetConj,$GetDist,$Poke,$Peek,$Push,$Pop,$Label,$CondJump,$CondLoop,$Test
.xcref $TopTest,$leave2,$until2,$StrucError,j,jn,jand,jnand,jnnand
.xcref jnnonzero,jnonzero,jnzero,jzero
.xcref $st,$sn,$OrFound,$LoopEnd,$LeaveFound,$DefDist
.xcref $LastLabel,$LastLabelOrg,$EquateLabel,$TraceLabel,$CondJump2,$ncxz
endif


$st	= 0
$sn	= 0
$OrFound = 0
$LoopEnd = 0
$LeaveFound = 0
$LastLabel = -1
$LastLabelOrg = $
$DefDist= $Short
$Push	%$NoType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\umb.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989
;
;   Module:   UMB.INC - Definitions for link umb utility
;
;   Version:  0.01
;
;   Date:     Jun. 26, 1990
;
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   06/26/90  Original
;
;******************************************************************************

XMM_MULTIPLEX		equ	43h	; XMM multiplex number of INT 2Fh
XMM_INSTALL_CHECK	equ	00h	; install check call
XMM_FUNCTION_ADDR	equ	10h	; get control function address call
;
; XMM functions
;
XMM_GET_VERSION		equ	00h
XMM_REQUEST_UMB		equ	10h
XMM_RELEASE_UMB		equ	11h
;
; All error codes has this bit on.
; Used for test sucess of XMM_QUERY_FREE_EXTMEM
;
XMM_ERROR_BIT		equ	80h

;
;  Previous HIMEM.SYS versions are not reliable
;
GOOD_HIMEM_VERSION	equ	208h


;**	Arena Header
;

arena	STRUC
arena_signature     DB	?		; 4D for valid item, 5A for last item
arena_owner	    DW	?		; owner of arena item
arena_size	    DW	?		; size in paragraphs of item
arena_reserved	    DB	3 DUP(?)	; reserved
arena_name	    DB	8 DUP(?)	; owner file name
arena	ENDS

arena_owner_system	EQU 0		; free block indication

arena_signature_normal	EQU 4Dh 	; valid signature, not end of arena
arena_signature_end	EQU 5Ah 	; valid signature, last block in arena

DOS_ARENA		EQU 24H		; offset of arena_head var in DOS 
					; data segment
UMB_ARENA		EQU 8CH		; offset of umb_head in DOS data

.list		; end of UMB.INC

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\lib\xmm\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\win386.inc ===
;
; WIN386.INC
;
;  Symbols and structures relating to WIN386 support.
;
;  Used by files in both the DOS and the BIOS.
;
;  Created: 7-13-89 by MRW
;

;
; WIN386 broadcast int 2fh multiplex number and subfunction numbers
;

MultWin386		equ     16H	; Int 2f multiplex number

Win386_Init		equ	05H	; Win386 initialization
Win386_Exit		equ	06H	; Win386 exit
Win386_Devcall		equ	07H	; Win386 device call out
Win386_InitDone		equ	08H	; Win386 initialization is complete

;
; When Win386_Devcall is broadcast, BX is the Device ID.  DOS must 
; answer call outs from the DOSMGR
;

Win386_DOSMGR		equ	15H

;
; The following structures are used to communicate instance data to 
; Win386 from the DOS and the BIOS.  See Win386 API documentation
; (chapter 3, "Call Out Interfaces") for further description.
;

Win386_SIS		struc		; Startup Info Structure
SIS_Version		db	3, 0
SIS_Next_Dev_Ptr	dd	0	; pointer to next SIS in list
SIS_Virt_Dev_File_Ptr	dd	0
SIS_Reference_Data	dd	0
SIS_Instance_Data_Ptr	dd	0	; pointer to instance data array
Win386_SIS		ends

Win386_IIS		struc		; Instance Item Structure
IIS_Ptr			dd	?	; pointer to an instance item
IIS_Size		dw	?	; size of an instance item
Win386_IIS		ends

;
;Win386 DOSMGR function return values to indicate operation done
;

WIN_OP_DONE		equ	0b97cH	; 
DOSMGR_OP_DONE		equ	0a2abH	;

;M021
; WInoldap callout multiplex number
;
WINOLDAP		equ	46h	;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\wpatch.inc ===
DOSDATA	Segment

;
; first and second DOS patches
;	Non-console device read/write (system calls 3Fh and 40h)
;
; Code in disk.asm, 2 locations, one for read, one for write
;	DVRDLP:
;	DVWRTLP:
;
;
; 036h	lds	si,SS:[????]				  ; ThisSFT
;	lds	si,si+7 				  ; sf_devptr
; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
;
;
DOSP1_ID	db	036h,0C5h,036h
DOSP1_THISSFT	db	036h,005h,0C5h,074h,007h,0E8h
DOSP1_ID_LEN	equ	$-DOSP1_ID

		db	90h, 90h

DOSP12_ID	db	036h,0C5h,036h
DOSP12_THISSFT	db	036h,005h,0C5h,074h,007h,0E8h
DOSP12_ID_LEN	equ	$-DOSP1_ID


;
; Third/Fourth DOS patch - System call 3Fh (Read) from console
;
; Code in disk.asm, 1 location
;	GETBUF:
;
; 051h	push	cx	<- begin special int28 mode
;	push	es
;	push	di
;	mov	dx,???? ; offset dosgroup:CONBUF
;	call	????	; $STD_CON_STRING_INPUT
;	pop	di
;	pop	es
; 059h	pop	cx	<- end special int28 mode
;
DOSP3_ID	db	051h,006h,057h,0BAh
DOSP3_CONBUF	db	029h,002h,0E8h
DOSP3_ID_LEN	equ	$-DOSP3_ID
		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
DOSP4_ID	db	059h			; pop cx
DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
	
;
; Fifth DOS patch - System call 40h (Write) to console
;
;
; Code in disk.asm, 1 location
;
;		push	cx
;      WRCONLP: lodsb
;		cmp	al,1Ah
;		jz	????
;		call	????	<- "simulate" int28 event
;		loop	WRCONLP
;      CONEOF:	pop	ax
;
DOSP5_ID	db	051h			; push cx
		db	0ACh,03Ch,01Ah,074h,005h
		db	0E8h			; call
DOSP5_ID_LEN	equ	$-DOSP5_ID

;
; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
;
; Code in disp.asm, 1 location
;
;
;	mov [SaveDS],ds
;	mov [SaveBX],bx
;	mov bx,cs
;	mov ds,bx
;	inc [indos]
;	xor ax,ax
;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
;
;
DOSP7_ID	db	02Eh,08Ch,01Eh
DOSP7_SAVEDS	db	07Eh,05h		; mov [SaveDS],ds
		db	02Eh,089h,01Eh
DOSP7_SAVEBX	db	07Ch,05h		; mov [SaveBX],bx
		db	08Ch,0CBh		; mov bx,cs
		db	08Eh,0DBh		; mov ds,bx
		db	0FEh,006h
DOSP7_INDOS	db	0CFh,002h		; inc [indos]
		db	033h,0C0h		; xor ax,ax
DOSP7_ID_LEN	equ	$-DOSP7_ID

;
; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
;
; Code in handle.asm, 1 location in routine CheckOwner
;
;
;
;	push	ax
;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
;	cmp	ax,es:[di.sf_UID]   <- NOP
;	pop	ax
;	jz	????
;
;
;
DOSP8_ID	db	050h			; push ax
		db	036h,0A1h
DOSP8_USER_ID	db	0EAh,002h		; mov  ax,ss:[USER_ID]
		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
DOSP8_ID_LEN	equ	$-DOSP8_ID
		db	02Fh,058h		; pop  ax


;
; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
;
;   Take RAW read to STDIN SFT and turn it into a polling loop doing
;   a yeild when a character is not ready to be read.
;
; Code in disk.asm, 3 locations
;
;   DVRDRAW:
;	    PUSH    ES
;	    POP     DS
;   ReadRawRetry:				<- Patch 10
;	    MOV     BX,DI
;	    XOR     AX,AX			<- Reenter #2
;	    MOV     DX,AX
;	    call    SETREAD
;	    PUSH    DS				<- Reenter #1
;	    LDS     SI,[THISSFT]
;	    call    DEVIOCALL
;	    MOV     DX,DI
;	    MOV     AH,86H
;	    MOV     DI,[DEVCALL.REQSTAT]
;	    TEST    DI,STERR
;	    JZ	    CRDROK
;	    call    CHARHARD
;	    MOV     DI,DX
;	    OR	    AL,AL
;	    JZ	    CRDROK
;	    CMP     AL,3
;	    JZ	    CRDFERR
;	    POP     DS
;	    JMP     ReadRawRetry
;
;   CRDFERR:
;	    POP     DI				<- Patch 11
;   DEVIOFERR:
;	    LES     DI,[THISSFT]
;	    jmp     SET_ACC_ERR_DS
;
;   CRDROK:
;	    POP     DI				<- Patch 12
;	    MOV     DI,DX
;	    ADD     DI,[CALLSCNT]
;	    JMP     SHORT ENDRDDEVJ3
;
;
DOSP10_ID		db	006H,01FH
DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
DOSP10_LOC		db	08BH,0DFH
DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
			db	033H,0C0H,08BH,0D0H,0E8H
DOSP10_ID_LEN		equ	$-DOSP10_ID
			db	0DFH,00EH
DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
			db	009H,003H
			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
			db	01FH,0EBH,0CFH
DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
			db	05FH
DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H

DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
			db	05FH,08BH,0FAH


;
; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
;		which prints the fatal stack fault error on DOS >= 3.20.
;
;	    Sets focus to current VM so user can see fatal message.
;
;
;	l0: lodsb		<- Setfocus here
;	    cmp al, '$'
;	    je l1
;	    mov bl, 7
;	    mov ah, 0Eh
;	    int 10h
;	    jmp l0
;	l1: jmp $
;
;
;
DOSP13_ID	db	0ACh			; l0: lodsb
		db	03Ch,024h		;     cmp al, '$'
		db	074h,008h		;     je l1
		db	0B3h,007h		;     mov bl, 7
		db	0B4h,00Eh		;     mov ah, 0Eh
		db	0CDh,010h		;     int 10h
		db	0EBh,0F3h		;     jmp l0
		db	0EBh,0FEh		; l1: jmp $
DOSP13_ID_LEN	equ	$-DOSP13_ID


DOSDATA	ends


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\lib\xmm\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\version.inc ===
; Some modules really want TRUE to be 0FFH.  Best to let them have their way.
ifndef TRUE
	TRUE	   EQU	   0FFFFh
endif
ifndef TRUEBYTE
	TRUEBYTE   EQU     0FFh
endif
ifndef FALSE
	FALSE	   EQU	   0
endif


; This flag should be defined to create the ROM executable version of DOS.
; To build the regular version, it should be UNDEFINED.
;
; ROMDOS	equ	TRUE

; This flag should be defined to enable a special version of the EXEC
; function that will find and execute ROM executable programs.
;
; ROMEXEC	equ	TRUE

if1
	ifdef romdos
		%out ***** BUILDING ROM EXECUTABLE DOS *****
	endif
endif

;
; Use the following switches to control cmacros.inc
;
?PLM       =       0
?WIN       =       0

memS       EQU     1			; Small model
;
; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system
;
; The below chart will indicate how to set the switches to build the various
; versions
;
;                     IBMVER          IBMCOPYRIGHT
; --------------------------------------------------------
;  IBM Version     |   TRUE              TRUE
; --------------------------------------------------------
;  ISA Version     |   TRUE              FALSE
; --------------------------------------------------------
;  non ISA Version |   FALSE             FALSE
;
ifndef NEC_98
IBMVER          EQU     TRUE
else    ;NEC_98
IBMVER          EQU     FALSE
endif   ;NEC_98
IBMCOPYRIGHT    EQU     FALSE

;smr; removal of bufferflag; BUFFERFLAG	EQU	NOT IBMCOPYRIGHT

;mw 8/23/90 ; removal of ROMVER, superceded by ROMDOS and ROMEXEC, above...
; ROMVER		EQU	FALSE

ifndef NEC_98
CPU8086		EQU	FALSE
else    ;NEC_98
CPU8086		EQU	TRUE
endif   ;NEC_98

ifndef	MSVER	
MSVER           EQU     NOT IBMVER
endif
IBM             EQU     IBMVER
;
;
  IF1
	IF IBMVER
	    IF IBMCOPYRIGHT
              %OUT ... IBM version build switch on ...
	    ELSE
              ; %OUT ... ISA version build switch on ...
	    ENDIF
	ELSE
	    IF NOT IBMCOPYRIGHT
              %OUT ... non ISA version build switch on ...
	    ELSE
	      %OUT !!!!!!!!!  VERSION SWITCHES SET INCORECTLY  !!!!!!!!!
	      %OUT !!!!!!!!! CHECK SETTINGS IN INC\VERSION.INC !!!!!!!!!
	    ENDIF
	ENDIF   
	IF CPU8086
	    %OUT !!!!!!! 8080 / 8086 Version !!!!!!!
	ENDIF
  ENDIF

;****************************************************************************
;
;		<<< Followings are the DBCS relating Definition >>>
;
;
;	To build DBCS version, Define DBCS by using MASM option via
;	Dos environment.
;
;	ex.		set MASM=-DDBCS
;
;
;
;	To build Country/Region depend version, Define JAPAN, KOREA ,TAIWAN or PRC
;	by using MASM option via Dos environment.
;
;	ex.		set MASM=-DJAPAN
;			set MASM=-DKOREA
;			set MASM=-DTAIWAN
;			set MASM=-DPRC
;
;****************************************************************************


BUGFIX	   EQU	   TRUE


IBMJAPVER  EQU	   FALSE		; if TRUE define DBCS also
IBMJAPAN   EQU	   FALSE		; if TRUE define DBCS also


	ifdef xxTAIWANxx
CSIBIOS    EQU	   FALSE		; BIOS	       CSI
CSIDRV	   EQU	   TRUE 		; Device Drive CSI
CSITSR	   EQU	   FALSE		; TSR	       CSI
	else
CSIBIOS    EQU	   FALSE
CSIDRV	   EQU	   FALSE
CSITSR	   EQU	   FALSE
	endif

;
; Set DBCS Blank constant
;
	ifndef DBCS
DB_SPACE EQU	 2020h
DB_SP_HI EQU	 20h
DB_SP_LO EQU	 20h
	else

	ifdef JAPAN
DB_SPACE EQU	 8140h
DB_SP_HI EQU	 81h
DB_SP_LO EQU	 40h
	endif

	ifdef TAIWAN ; by gchang, 06/23/94
DB_SPACE EQU	 0A140h
DB_SP_HI EQU	 0A1h
DB_SP_LO EQU	 40h
	endif

	ifdef PRC ; by gchang, 06/23/94
DB_SPACE EQU	 0A1A1h
DB_SP_HI EQU	 0A1h
DB_SP_LO EQU	 0A1h
	endif

	ifdef KOREA
DB_SPACE EQU	 0A1A1h
DB_SP_HI EQU	 0A1h
DB_SP_LO EQU	 0A1h
	endif

	endif

ifndef altvect				; avoid jerking off vector.inc
ALTVECT    EQU	   FALSE		;Switch to build ALTVECT version
endif

;
	IF1

	ifdef DBCS
%OUT    DBCS Version Build Switch ON

	ifdef JAPAN
%OUT    JAPAN Version Build Switch ON
	endif

	ifdef TAIWAN
%OUT    TAIWAN Version Build Switch ON
	endif

	ifdef KOREA
%OUT    KOREA Version Build Switch ON
	endif

	endif

	ENDIF

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\yesno.asm ===
; This is for contry Yes and No
  PUBLIC NLS_YES,NLS_yes2,NLS_NO,NLS_no2
include msdos.cl3

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\br\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\xmm.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   XMM.INC - Definitions for extended memory manger (XMM)
;
;   Version:  0.01
;
;   Date:     Feb. 15, 1989
;
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   02/15/89  Original
;   02/19/89  pc	add other struct and equ
;
;******************************************************************************

XMM_MULTIPLEX						equ	43h	; XMM multiplex number of INT 2Fh
XMM_INSTALL_CHECK				equ	00h	; install check call
XMM_FUNCTION_ADDR				equ	10h	; get control function address call
;
; XMM functions
;
XMM_GET_VERSION					equ	00h
XMM_REQUEST_HMA					equ	01h
XMM_RELEASE_HMA					equ	02h
XMM_GLOBAL_ENABLE_A20		equ	03h
XMM_GLOBAL_DISABLE_A20	equ	04h
XMM_LOCAL_ENABLE_A20		equ	05h
XMM_LOCAL_DISABLE_A20		equ	06h
XMM_QUERY_A20						equ	07h
XMM_QUERY_FREE_EXTMEM		equ	08h
XMM_ALLOC_EMB						equ	09h
XMM_FREE_EMB						equ	0Ah
XMM_MOVE_EMB						equ	0Bh
XMM_LOCK_EMB						equ	0Ch
XMM_UNLOCK_EMB					equ	0Dh
XMM_GET_EMB_INFO				equ	0Eh
XMM_REALLOC_EMB					equ	0Fh
XMM_REQUEST_UMB					equ	10h
XMM_RELEASE_UMB					equ	11h
;
; All error codes has this bit on.
; Used for test sucess of XMM_QUERY_FREE_EXTMEM
;
XMM_ERROR_BIT						equ	80h

;
;  Previous HIMEM.SYS versions are not reliable
;
GOOD_HIMEM_VERSION			equ	208h

;
; struct pass to XMM_MOVE_EMB in DS:SI
;
ExtMemMoveStruct	struc
	mov_length	dd	?	; 32 bit number of bytes to transfer
	src_handle	dw	?	; handle of source block
	src_offset	dd	?	; 32 bit offset into source
	dst_handle	dw	?	; handle of destination block
	dst_offset	dd	?	; 32 bit offset into destination
ExtMemMoveStruct	ends

.list		; end of XMM.INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\inc\_parse.asm ===
page           60,132
name           _parse
title          C to PARSER interface
;-------------------------------------------------------------------
;
;       MODULE:         _parse
;
;       PURPOSE:        Supplies an interface between C programs and
;                       the DOS 3.30 parser
;
;       CALLING FORMAT:
;                       parse(&inregs,&outregs);
;
;       DATE:           5-21-87
;
;-------------------------------------------------------------------

;       extrn   sysparse:far

        public  _parse

;-------------------------------------------------------------------

; SET FOR SUBST
; -------------

FarSW   equ     0       ; make sysparse be a NEAR proc
TimeSW  equ     0       ; Check time format
FileSW  equ     1       ; Check file specification
CAPSW   equ     1       ; Perform CAPS if specified
CmpxSW  equ     0       ; Check complex list
NumSW   equ     0       ; Check numeric value
KeySW   equ     0       ; Support keywords
SwSW    equ     1       ; Support switches
Val1SW  equ     0       ; Support value definition 1
Val2SW  equ     0       ; Support value definition 2
Val3SW  equ     0       ; Support value definition 3
DrvSW   equ     1       ; Support drive only format
QusSW   equ     0       ; Support quoted string format
;-------------------------------------------------------------------

_DATA   segment byte public 'DATA'
_DATA   ends

_TEXT   segment byte public 'CODE'

        ASSUME  CS: _TEXT
        ASSUME  DS: _DATA

;-------------------------------------------------------------------
include parse.asm               ; include the parser
;-------------------------------------------------------------------

_parse  proc    near

        push    bp              ; save user's base pointer
        mov     bp,sp           ; set bp to current sp
        push    di              ; save some registers
        push    si

;       copy C inregs into proper registers

        mov     di,[bp+4]       ; fix di (arg 0)

;-------------------------------------------------------------------

        mov     ax,[di+0ah]     ; load di
        push    ax              ; the di value from inregs is now on stack

        mov     ax,[di+00]      ; get inregs.x.ax
        mov     bx,[di+02]      ; get inregs.x.bx
        mov     cx,[di+04]      ; get inregs.x.cx
        mov     dx,[di+06]      ; get inregs.x.dx
        mov     si,[di+08]      ; get inregs.x.si
        pop     di              ; get inregs.x.di from stack

        push    bp              ; save base pointer

;        int     3               ; debugger

;-------------------------------------------------------------------
        call    sysparse        ; call the parser
;-------------------------------------------------------------------

;        int     3               ; debugger

        pop     bp              ; restore base pointer
        push    di              ; the di value from call is now on stack
        mov     di,[bp+6]       ; fix di (arg 1)

        mov     [di+00],ax      ; load outregs.x.ax
        mov     [di+02],bx      ; load outregs.x.bx
        mov     [di+04],cx      ; load outregs.x.cx
        mov     [di+06],dx      ; load outregs.x.dx
        mov     [di+08],si      ; load outregs.x.si

        xor     ax,ax           ; clear ax
        lahf                    ; get flags into ax
        mov     [di+0ch],ax     ; load outregs.x.cflag

        pop     ax              ; get di from stack
        mov     [di+0ah],ax     ; load outregs.x.di

;-------------------------------------------------------------------

        pop     si              ; restore registers
        pop     di
        mov     sp,bp           ; restore sp
        pop     bp              ; restore user's bp
        ret

_parse  endp

_TEXT   ends                    ; end code segment
        end


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\makefile.inc ===
#************************* makefile for messages **************************
!IFNDEF LANGUAGE
LANGUAGE =usa
!ENDIF

idx=$(LANGUAGE).idx
msg=$(LANGUAGE).msg

#
####################### dependencies begin here. #########################
#

make_idx: $(idx)

$(idx): $(msg)
    -attrib -r $(LANGUAGE).idx
    -$(_NTBINDIR)\tools\tools16\buildidx $(LANGUAGE).msg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\br\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

	msg	BadVerMsg,   <"Versao incorreta do DOS",CR,LF>
	msg	OutEnvMsg,   <"Espao insuficiente para o ambiente",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg	BadComLkMsg, <"Pasta incorreta especificada p/localizaao de COMMAND",CR,LF>
	msg	BadComAccMsg,<"Acesso negado  pasta de localiz. de COMMAND especificada",CR,LF>

	msg	Help1Msg  <"Inicia uma nova cpia do interpretador de comandos do MS-DOS.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[unidade:]caminho] [dispositivo] [/E:nnnnn] [/P] [/C comando] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <" [unidade:]caminho  Especifica a pasta que contm o arquivo COMMAND.COM.",CR,LF>
        msg     Help4Msg <" dispositivo        Especifica o dispositivo a ser usado para entrada e sada de comando.",CR,LF>
	msg	Help5Msg  <" /E:nnnnn           Define o tamanho inicial do ambiente como nnnnn bytes.",CR,LF>
        msg     Help6Msg  <" /P                 Torna o novo interpretador de comandos permanente (nao  possvel sair)",CR,LF>
	msg	Help7Msg  <" /C seqncia         Executa o comando especificado e se encerra.",CR,LF>
	msg	Help8Msg  <" /MSG               Armazena todas as mensagens de erro na memria.",CR,LF>
	msg	Help9Msg  <"                    A chave /P tambm deve ser especificada.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

SOURCES=

NTTARGETFILE0=make_idx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\br\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char        db      "S"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

        msg     Req_Abort, <"Anular">
        msg     Req_Retry, <", Repetir">
        msg     Req_Ignore,<", Ignorar">
        msg     Req_Fail,  <", Falhar">
	msg	Req_End,   <"?">
        msg     MRead,     <"lendo",0>
        msg     MWrite,    <"gravando",0>
        msg     BlkDevErr, <" %1 unidade %2",CR,LF>
        msg     CharDevErr,<" %1 dispositivo %2",CR,LF>
        msg     NeedVolMsg,<"Fornea o volume %1 srie %2-%3",CR,LF>
        msg     BadFatMsg, <"Tabela de alocao de arquivos invlida, unidade %1",CR,LF>
        msg     ComBad,    <"COMMAND.COM invlido",CR,LF>
        msg     PutBackMsg,<"Insira o disco com %1 na unidade %2",CR,LF>
        msg     Prompt,    <"Pressione qualquer tecla para continuar . . .",CR,LF>
        msg     EndBatMes, <CR,LF,"Finalizar a execuo do arquivo em lote (S/N)?">
        msg     ExecEMes,  <"No foi possvel executar %1",CR,LF>
        msg     ExeBad,    <"Erro no arquivo EXE",CR,LF>
        msg     TooBig,    <"Programa muito extenso para ser colocado na memria",CR,LF>
        msg     NoHandMes, <CR,LF,"No h identificadores de arquivos disponveis">
        msg     RBadNam,   <"Comando ou nome de arquivo incorreto",CR,LF>
        msg     AccDen,    <"Acesso negado ">
        msg     BMemMes,   <CR,LF,"Erro de alocao de memria">
        msg     HaltMes,   <CR,LF,"No foi possvel carregar o COMMAND, sistema interrompido",CR,LF>
        msg     FRetMes,   <CR,LF,"No foi possvel iniciar o COMMAND, saindo",CR,LF>
        msg     Patricide, <CR,LF,"Processo de nvel principal anulado, no  possvel continuar",CR,LF>
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

        msg     ExtErr19,<"Erro de proteo contra gravao">
        msg     ExtErr20,<"Unidade invlida">
        msg     ExtErr21,<"No est pronta">
        msg     ExtErr22,<"Requisio de dispositivo invlida">
        msg     ExtErr23,<"Erro de dados">
        msg     ExtErr24,<"Parmetros de requisio de dispositivo invlidos">
        msg     ExtErr25,<"Erro de procura">
        msg     ExtErr26,<"Meio de comunicao invlido">
        msg     ExtErr27,<"No foi encontrado o setor">
        msg     ExtErr28,<"Erro de impressora sem papel">
        msg     ExtErr29,<"Erro de gravao">
        msg     ExtErr30,<"Erro de leitura">
        msg     ExtErr31,<"Falha geral">
        msg     ExtErr32,<"Violao de compartilhamento">
        msg     ExtErr33,<"Violao de bloqueio">
        msg     ExtErr34,<"Alterao de disco invlida">
        msg     ExtErr35,<"FCB no disponvel">
        msg     ExtErr36,<"Esgotados os recursos do sistema">
        msg     ExtErr37,<"Pgina de cdigos inconsistente">
        msg     ExtErr38,<"No h mais entrada">
        msg     ExtErr39,<"Espao em disco insuficiente">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

        msg     ParsErr01,<"Excesso de parmetros">
        msg     ParsErr02,<"Falta um parmetro necessrio">
        msg     ParsErr03,<"Opo invlida">
        msg     ParsErr04,<"Palavra-chave invlida">
	msg	ParsErr05,<" ">
        msg     ParsErr06,<"Valor do parmetro fora do intervalo permitido">
        msg     ParsErr07,<"Valor do parmetro no permitido">
        msg     ParsErr08,<"Valor de parmetro no permitido">
        msg     ParsErr09,<"Formato do parmetro incorreto">
        msg     ParsErr10,<"Parmetro invlido">
        msg     ParsErr11,<"Combinao de parmetros invlida">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

        msg     ExtErr01,<"Funo invlida">
        msg     ExtErr02,<"Arquivo no encontrado">
        msg     ExtErr03,<"Caminho no encontrado">
        msg     ExtErr04,<"H muitos arquivos abertos">
        msg     ExtErr05,<"Acesso negado">
        msg     ExtErr06,<"Identificador invlido">
        msg     ExtErr07,<"Blocos de controle de memria destrudos">
        msg     ExtErr08,<"Memria insuficiente">
        msg     ExtErr09,<"Endereo do bloco de memria invlido">
        msg     ExtErr10,<"Ambiente operacional invlido">
        msg     ExtErr11,<"Formato invlido">
        msg     ExtErr12,<"Parmetro de funo invlido">
        msg     ExtErr13,<"Dados invlidos">

        msg     ExtErr15,<"Unidade especificada invlida">
        msg     ExtErr16,<"Tentativa de remoo da pasta atual">
        msg     ExtErr17,<"No  o mesmo dispositivo">
        msg     ExtErr18,<"No h mais arquivos">

        msg     ExtErr80,<"Arquivo j existe">

        msg     ExtErr82,<"No foi possvel realizar entrada de pasta">
        msg     ExtErr83,<"Falha em INT 24">
        msg     ExtErr84,<"Excesso de redirecionamentos">
        msg     ExtErr85,<"Redirecionamento duplicado">
        msg     ExtErr86,<"Senha invlida">
        msg     ExtErr87,<"Parmetro invlido">
        msg     ExtErr88,<"Falha nos dados da rede">
        msg     ExtErr89,<"Funo no aceita pela rede">
        msg     ExtErr90,<"Componente necessrio do sistema no instalado">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\lib\xmm\xmm.asm ===
TITLE   XMM_INTERFACE.ASM
	NAME    XMM_INTERFACE

;*******************************************************************************
;									       ;
;	XMM C Interface Routines					       ;
;									       ;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1988,1991
;       All Rights Reserved.
;									       ;
;*******************************************************************************

?PLM=0
?WIN=0

include	cmacros.inc

sBegin	Data
XMM_Initialised	dw	0
XMM_Control	label	dword
		dw	CodeOFFSET XMM_NotInitialised
		dw	seg _TEXT
sEnd	Data

sBegin	CODE
assumes cs, CODE
assumes ds, DGROUP

;
; Macro to convert from XMS success/fail to
; a form more acceptable for C.  IE.
;
; AX == 1 becomes DX:AX = 0
; AX != 1 becomes DX:AX = BL << 24 | (AX - 1)
;
; Since Error Codes returned in BL have the top bit
; set, C will interpret the return as negative.
;
SuccessFail	macro
	local	Success
	xor	dx, dx
	dec	ax
	jz	Success
	mov	dh, bl
Success:
	endm

;
; Macro to convert from XMS return value in AX
; a form more acceptable for C.  IE.
;
; AX != 0 becomes DX:AX = AX
; AX == 0 becomes DX:AX = BL << 24 | AX
;
; Since Error Codes returned in BL have the top bit
; set, C will interpret the return as negative.
; XMS returns of this type return BL == 0 on success.
;
SuccessFailAX	macro
	local	Success
	xor	dx, dx
	or	ax, ax
	jnz	Success
	mov	dh, bl
Success:
	endm

;
; Macro to convert from XMS return value in DX
; a form more acceptable for C.  IE.
;
; AX != 0 becomes DX:AX = DX
; AX == 0 becomes DX:AX = BL << 24 | DX
;
; Since Error Codes returned in BL have the top bit
; set, C will interpret the return as negative.
; XMS returns of this type return BL == 0 on success.
;
SuccessFailDX	macro
	local	Success
	or	ax, ax
	mov	ax, dx
	mov	dx, 0				; Preserves Flags
	jnz	Success
	mov	dh, bl
Success:
	endm


cProc	XMM_NotInitialised, <FAR>
cBegin
	xor	ax, ax				; Immediate failure
	mov	bl, 80h				; Not Implemented
cEnd

cProc	XMM_Installed, <NEAR, PUBLIC>, <si, di>
cBegin
	cmp	[XMM_Initialised], 0
	jne	Already_Initialised
	mov	ax, 4300h			; Test for XMM
	int	2fh
	cmp	al, 80h
	jne	NoDriver

	mov	ax, 4310h			; Get Control Function
	int	2fh
	mov	word ptr [XMM_Control], bx
	mov	word ptr [XMM_Control+2], es
	inc	[XMM_Initialised]
NoDriver:
Already_Initialised:
	mov	ax, [XMM_Initialised]
cEnd


cProc	XMM_Version, <NEAR, PUBLIC>, <si, di>
cBegin
	xor	ah, ah				; Function 0
	call	[XMM_Control]
	mov	dx, bx				; Return a long
cEnd


;
;	long	XMM_RequestHMA(Space_Needed: unsigned short);
;
cProc	XMM_RequestHMA, <NEAR, PUBLIC>, <si, di>
parmW	Space_Needed
cBegin
	mov	ah, 1
	mov	dx, Space_Needed
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_ReleaseHMA, <NEAR, PUBLIC>, <si, di>
cBegin
	mov	ah, 2
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_GlobalEnableA20, <NEAR, PUBLIC>, <si, di>
cBegin
	mov	ah, 3
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_GlobalDisableA20, <NEAR, PUBLIC>, <si, di>
cBegin
	mov	ah, 4
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_EnableA20, <NEAR, PUBLIC>, <si, di>
cBegin
	mov	ah, 5
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_DisableA20, <NEAR, PUBLIC>, <si, di>
cBegin
	mov	ah, 6
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_QueryA20, <NEAR, PUBLIC>, <si, di>
cBegin
	mov	ah, 7
	call	[XMM_Control]
	SuccessFailAX
cEnd

cProc	XMM_QueryLargestFree, <NEAR, PUBLIC>, <si, di>
cBegin
	mov	ah, 8
	call	[XMM_Control]
	SuccessFailAX
cEnd

cProc	XMM_QueryTotalFree, <NEAR, PUBLIC>, <si, di>
cBegin
	mov	ah, 8
	call	[XMM_Control]
	SuccessFailDX
cEnd

cProc	XMM_AllocateExtended, <NEAR, PUBLIC>, <si, di>
parmW	SizeK
cBegin
	mov	ah, 9
	mov	dx, SizeK
	call	[XMM_Control]
	SuccessFailDX
cEnd

cProc	XMM_FreeExtended, <NEAR, PUBLIC>, <si, di>
parmW	Handle
cBegin
	mov	ah, 0Ah
	mov	dx, Handle
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_MoveExtended, <NEAR, PUBLIC>, <si, di>
parmW	pInfo
cBegin
	mov	ah, 0Bh
	mov	si, pInfo			; DS:SI => Description 
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_LockExtended, <NEAR, PUBLIC>, <si, di>
parmW	Handle
cBegin
	mov	ah, 0Ch
	mov	dx, Handle
	call	[XMM_Control]
	xchg	ax, bx
	dec	bx
	jz	XMML_Success
	mov	dh, al
XMML_Success:
cEnd

cProc	XMM_UnLockExtended, <NEAR, PUBLIC>, <si, di>
parmW	Handle
cBegin
	mov	ah, 0Dh
	mov	dx, Handle
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_GetHandleLength, <NEAR, PUBLIC>, <si, di>
parmW	Handle
cBegin
	mov	ah, 0Eh
	mov	dx, Handle
	call	[XMM_Control]
	SuccessFailDX
cEnd

cProc	XMM_GetHandleInfo, <NEAR, PUBLIC>, <si, di>
parmW	Handle
cBegin
	mov	ah, 0Eh
	mov	dx, Handle
	call	[XMM_Control]
	mov	dx, bx
	SuccessFailDX
cEnd

cProc	XMM_ReallocateExtended, <NEAR, PUBLIC>, <si, di>
parmW	Handle
parmW	NewSize
cBegin
	mov	ah, 0Fh
	mov	dx, Handle
	mov	bx, NewSize
	call	[XMM_Control]
	SuccessFail
cEnd

cProc	XMM_RequestUMB, <NEAR, PUBLIC>, <si, di>
parmW	UMBSize
cBegin
	mov	ah, 10h
	mov	dx, UMBSize
	call	[XMM_Control]
	xchg	bx, ax			; Segment in AX, Size in DX
	dec	bx
	jz	RUMB_Success
	xchg	ax, dx			; Largest available size in AX
	mov	dh, dl			; Error code now in DH
RUMB_Success:
cEnd

cProc	XMM_ReleaseUMB, <NEAR, PUBLIC>, <si, di>
parmW	UMBSegment
cBegin
	mov	ah, 11h
	mov	dx, UMBSegment
	call	[XMM_Control]
	SuccessFail
cEnd

sEnd	CODE

END

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\chp\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"Abort">
	msg	Req_Retry, <", Retry">
	msg	Req_Ignore,<", Ignore">
	msg	Req_Fail,  <", Fail">
	msg	Req_End,   <"?">
	msg	MRead,	   <"reading",0>
	msg	MWrite,	   <"writing",0>
	msg	BlkDevErr, <" %1 drive %2",CR,LF>
	msg	CharDevErr,<" %1 device %2",CR,LF>
	msg	NeedVolMsg,<"Please insert volume %1 serial %2-%3",CR,LF>
	msg	BadFatMsg, <"File allocation table bad, drive %1",CR,LF>
	msg	ComBad,	   <"Invalid COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"Insert disk with %1 in drive %2",CR,LF>
	msg	Prompt,	   <"Press any key to continue . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"Terminate batch job (Y/N)?">
	msg	ExecEMes,  <"Cannot execute %1",CR,LF>
	msg	ExeBad,	   <"Error in EXE file",CR,LF>
	msg	TooBig,	   <"Program too big to fit in memory",CR,LF>
	msg	NoHandMes, <CR,LF,"No free file handles">
	msg	RBadNam,   <"Bad Command or file name",CR,LF>
	msg	AccDen,	   <"Access denied ">
	msg	BMemMes,   <CR,LF,"Memory allocation error">
	msg	HaltMes,   <CR,LF,"Cannot load COMMAND, system halted",CR,LF>
	msg	FRetMes,   <CR,LF,"Cannot start COMMAND, exiting",CR,LF>
	msg	Patricide, <CR,LF,"Top level process aborted, cannot continue",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Write protect error">
	msg	ExtErr20,<"Invalid unit">
	msg	ExtErr21,<"Not ready">
	msg	ExtErr22,<"Invalid device request">
	msg	ExtErr23,<"Data error">
	msg	ExtErr24,<"Invalid device request parameters">
	msg	ExtErr25,<"Seek error">
	msg	ExtErr26,<"Invalid media type">
	msg	ExtErr27,<"Sector not found">
	msg	ExtErr28,<"Printer out of paper error">
	msg	ExtErr29,<"Write fault error">
	msg	ExtErr30,<"Read fault error">
	msg	ExtErr31,<"General failure">
	msg	ExtErr32,<"Sharing violation">
	msg	ExtErr33,<"Lock violation">
	msg	ExtErr34,<"Invalid disk change">
	msg	ExtErr35,<"FCB unavailable">
	msg	ExtErr36,<"System resource exhausted">
	msg	ExtErr37,<"Code page mismatch">
	msg	ExtErr38,<"Out of input">
	msg	ExtErr39,<"Insufficient disk space">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"Too many parameters">
	msg	ParsErr02,<"Required parameter missing">
	msg	ParsErr03,<"Invalid switch">
	msg	ParsErr04,<"Invalid keyword">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Parameter value not in allowed range">
	msg	ParsErr07,<"Parameter value not allowed">
	msg	ParsErr08,<"Parameter value not allowed">
	msg	ParsErr09,<"Parameter format not correct">
	msg	ParsErr10,<"Invalid parameter">
	msg	ParsErr11,<"Invalid parameter combination">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Invalid function">
	msg	ExtErr02,<"File not found">
	msg	ExtErr03,<"Path not found">
	msg	ExtErr04,<"Too many open files">
	msg	ExtErr05,<"Access denied ">
	msg	ExtErr06,<"Invalid handle">
	msg	ExtErr07,<"Memory control blocks destroyed">
	msg	ExtErr08,<"Insufficient memory">
	msg	ExtErr09,<"Invalid memory block address">
	msg	ExtErr10,<"Invalid Environment">
	msg	ExtErr11,<"Invalid format">
	msg	ExtErr12,<"Invalid function parameter">
	msg	ExtErr13,<"Invalid data">

	msg	ExtErr15,<"Invalid drive specification">
	msg	ExtErr16,<"Attempt to remove current directory">
	msg	ExtErr17,<"Not same device">
	msg	ExtErr18,<"No more files">

	msg	ExtErr80,<"File exists">

	msg	ExtErr82,<"Cannot make directory entry">
	msg	ExtErr83,<"Fail on INT 24">
	msg	ExtErr84,<"Too many redirections">
	msg	ExtErr85,<"Duplicate redirection">
	msg	ExtErr86,<"Invalid password">
	msg	ExtErr87,<"Invalid parameter">
	msg	ExtErr88,<"Network data fault">
	msg	ExtErr89,<"Function not supported by network">
	msg	ExtErr90,<"Required system component not installed">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\cs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\chp\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

	msg	BadVerMsg,   <"Incorrect DOS version",CR,LF>
	msg	OutEnvMsg,   <"Out of environment space",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg	BadComLkMsg, <"Specified COMMAND search directory bad",CR,LF>
	msg	BadComAccMsg,<"Specified COMMAND search directory bad access denied",CR,LF>

	msg	Help1Msg  <"Starts a new instance of the MS-DOS command interpreter.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [drive:]path    Specifies the directory containing COMMAND.COM file.",CR,LF>
        msg     Help4Msg  <"  device          Specifies the device to use for command input and output.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn        Sets the initial environment size to nnnnn bytes.",CR,LF>
	msg	Help6Msg  <"  /P              Makes the new command interpreter permanent (can't exit).",CR,LF>
	msg	Help7Msg  <"  /C string       Carries out the command specified by string, and then stops.",CR,LF>
	msg	Help8Msg  <"  /MSG            Specifies that all error messages be stored in memory. You",CR,LF>
	msg	Help9Msg  <"                  need to specify /P with this switch.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\chs\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"Abort">
	msg	Req_Retry, <", Retry">
	msg	Req_Ignore,<", Ignore">
	msg	Req_Fail,  <", Fail">
	msg	Req_End,   <"?">
	msg	MRead,	   <"reading",0>
	msg	MWrite,	   <"writing",0>
	msg	BlkDevErr, <" %1 drive %2",CR,LF>
	msg	CharDevErr,<" %1 device %2",CR,LF>
	msg	NeedVolMsg,<"Please insert volume %1 serial %2-%3",CR,LF>
	msg	BadFatMsg, <"File allocation table bad, drive %1",CR,LF>
	msg	ComBad,	   <"Invalid COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"Insert disk with %1 in drive %2",CR,LF>
	msg	Prompt,	   <"Press any key to continue . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"Terminate batch job (Y/N)?">
	msg	ExecEMes,  <"Cannot execute %1",CR,LF>
	msg	ExeBad,	   <"Error in EXE file",CR,LF>
	msg	TooBig,	   <"Program too big to fit in memory",CR,LF>
	msg	NoHandMes, <CR,LF,"No free file handles">
	msg	RBadNam,   <"Bad Command or file name",CR,LF>
	msg	AccDen,	   <"Access denied ">
	msg	BMemMes,   <CR,LF,"Memory allocation error">
	msg	HaltMes,   <CR,LF,"Cannot load COMMAND, system halted",CR,LF>
	msg	FRetMes,   <CR,LF,"Cannot start COMMAND, exiting",CR,LF>
	msg	Patricide, <CR,LF,"Top level process aborted, cannot continue",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Write protect error">
	msg	ExtErr20,<"Invalid unit">
	msg	ExtErr21,<"Not ready">
	msg	ExtErr22,<"Invalid device request">
	msg	ExtErr23,<"Data error">
	msg	ExtErr24,<"Invalid device request parameters">
	msg	ExtErr25,<"Seek error">
	msg	ExtErr26,<"Invalid media type">
	msg	ExtErr27,<"Sector not found">
	msg	ExtErr28,<"Printer out of paper error">
	msg	ExtErr29,<"Write fault error">
	msg	ExtErr30,<"Read fault error">
	msg	ExtErr31,<"General failure">
	msg	ExtErr32,<"Sharing violation">
	msg	ExtErr33,<"Lock violation">
	msg	ExtErr34,<"Invalid disk change">
	msg	ExtErr35,<"FCB unavailable">
	msg	ExtErr36,<"System resource exhausted">
	msg	ExtErr37,<"Code page mismatch">
	msg	ExtErr38,<"Out of input">
	msg	ExtErr39,<"Insufficient disk space">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"Too many parameters">
	msg	ParsErr02,<"Required parameter missing">
	msg	ParsErr03,<"Invalid switch">
	msg	ParsErr04,<"Invalid keyword">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Parameter value not in allowed range">
	msg	ParsErr07,<"Parameter value not allowed">
	msg	ParsErr08,<"Parameter value not allowed">
	msg	ParsErr09,<"Parameter format not correct">
	msg	ParsErr10,<"Invalid parameter">
	msg	ParsErr11,<"Invalid parameter combination">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Invalid function">
	msg	ExtErr02,<"File not found">
	msg	ExtErr03,<"Path not found">
	msg	ExtErr04,<"Too many open files">
	msg	ExtErr05,<"Access denied ">
	msg	ExtErr06,<"Invalid handle">
	msg	ExtErr07,<"Memory control blocks destroyed">
	msg	ExtErr08,<"Insufficient memory">
	msg	ExtErr09,<"Invalid memory block address">
	msg	ExtErr10,<"Invalid Environment">
	msg	ExtErr11,<"Invalid format">
	msg	ExtErr12,<"Invalid function parameter">
	msg	ExtErr13,<"Invalid data">

	msg	ExtErr15,<"Invalid drive specification">
	msg	ExtErr16,<"Attempt to remove current directory">
	msg	ExtErr17,<"Not same device">
	msg	ExtErr18,<"No more files">

	msg	ExtErr80,<"File exists">

	msg	ExtErr82,<"Cannot make directory entry">
	msg	ExtErr83,<"Fail on INT 24">
	msg	ExtErr84,<"Too many redirections">
	msg	ExtErr85,<"Duplicate redirection">
	msg	ExtErr86,<"Invalid password">
	msg	ExtErr87,<"Invalid parameter">
	msg	ExtErr88,<"Network data fault">
	msg	ExtErr89,<"Function not supported by network">
	msg	ExtErr90,<"Required system component not installed">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\cht\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

	msg	BadVerMsg,   <"Incorrect DOS version",CR,LF>
	msg	OutEnvMsg,   <"Out of environment space",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg	BadComLkMsg, <"Specified COMMAND search directory bad",CR,LF>
	msg	BadComAccMsg,<"Specified COMMAND search directory bad access denied",CR,LF>

	msg	Help1Msg  <"Starts a new instance of the MS-DOS command interpreter.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [drive:]path    Specifies the directory containing COMMAND.COM file.",CR,LF>
        msg     Help4Msg  <"  device          Specifies the device to use for command input and output.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn        Sets the initial environment size to nnnnn bytes.",CR,LF>
	msg	Help6Msg  <"  /P              Makes the new command interpreter permanent (can't exit).",CR,LF>
	msg	Help7Msg  <"  /C string       Carries out the command specified by string, and then stops.",CR,LF>
	msg	Help8Msg  <"  /MSG            Specifies that all error messages be stored in memory. You",CR,LF>
	msg	Help9Msg  <"                  need to specify /P with this switch.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\chs\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

	msg	BadVerMsg,   <"Incorrect DOS version",CR,LF>
	msg	OutEnvMsg,   <"Out of environment space",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg	BadComLkMsg, <"Specified COMMAND search directory bad",CR,LF>
	msg	BadComAccMsg,<"Specified COMMAND search directory bad access denied",CR,LF>

	msg	Help1Msg  <"Starts a new instance of the MS-DOS command interpreter.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [drive:]path    Specifies the directory containing COMMAND.COM file.",CR,LF>
        msg     Help4Msg  <"  device          Specifies the device to use for command input and output.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn        Sets the initial environment size to nnnnn bytes.",CR,LF>
	msg	Help6Msg  <"  /P              Makes the new command interpreter permanent (can't exit).",CR,LF>
	msg	Help7Msg  <"  /C string       Carries out the command specified by string, and then stops.",CR,LF>
	msg	Help8Msg  <"  /MSG            Specifies that all error messages be stored in memory. You",CR,LF>
	msg	Help9Msg  <"                  need to specify /P with this switch.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\cs\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

        msg     BadVerMsg,   <"Nesprvn verze systmu DOS",CR,LF>
        msg     OutEnvMsg,   <"Nedostatek pamti pro systmov promnn",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
        msg     BadComLkMsg, <"Zadan adres pro vyhledn pkazu COMMAND je chybn",CR,LF>
        msg     BadComAccMsg,<"K zadanmu adresi pro vyhledn pkazu COMMAND byl odmtnut pstup",CR,LF>

        msg     Help1Msg  <"Spout nov prosted pkazovho dku MS-DOS.",CR,LF,CR,LF>
        msg     Help2Msg  <"COMMAND [[jednotka:]cesta] [zazen] [/E:nnnnn] [/P] [/C etzec] [/MSG]",CR,LF,CR,LF>
        msg     Help3Msg  <" [jednotka:]cesta Ur jednotku a adres obsahujc soubor COMMAND.COM.",CR,LF>
        msg     Help4Msg  <" zazen         Ur zazen pro vstup a vstup pkaz.",CR,LF>
        msg     Help5Msg  <" /E:nnnnn         Nastav velikost pamti pro promnn systmu na nnnnn bajt.",CR,LF>
        msg     Help6Msg  <" /P               Ur, e prosted MS-DOS nelze ukonit.",CR,LF>
        msg     Help7Msg  <" /C etzec       Vykon pkaz uren etzcem, pak se zastav.",CR,LF>
        msg     Help8Msg  <" /MSG             Ur, e vechny chybov zprvy se ulo do pamti.",CR,LF>
        msg     Help9Msg  <"                  S pepnaem /MSG je nutno nastavit i pepna /P.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
                dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
                dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
                dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
                dw      RESGROUP:Help9Msg,0

        public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\da\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\cht\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"Abort">
	msg	Req_Retry, <", Retry">
	msg	Req_Ignore,<", Ignore">
	msg	Req_Fail,  <", Fail">
	msg	Req_End,   <"?">
	msg	MRead,	   <"reading",0>
	msg	MWrite,	   <"writing",0>
	msg	BlkDevErr, <" %1 drive %2",CR,LF>
	msg	CharDevErr,<" %1 device %2",CR,LF>
	msg	NeedVolMsg,<"Please insert volume %1 serial %2-%3",CR,LF>
	msg	BadFatMsg, <"File allocation table bad, drive %1",CR,LF>
	msg	ComBad,	   <"Invalid COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"Insert disk with %1 in drive %2",CR,LF>
	msg	Prompt,	   <"Press any key to continue . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"Terminate batch job (Y/N)?">
	msg	ExecEMes,  <"Cannot execute %1",CR,LF>
	msg	ExeBad,	   <"Error in EXE file",CR,LF>
	msg	TooBig,	   <"Program too big to fit in memory",CR,LF>
	msg	NoHandMes, <CR,LF,"No free file handles">
	msg	RBadNam,   <"Bad Command or file name",CR,LF>
	msg	AccDen,	   <"Access denied ">
	msg	BMemMes,   <CR,LF,"Memory allocation error">
	msg	HaltMes,   <CR,LF,"Cannot load COMMAND, system halted",CR,LF>
	msg	FRetMes,   <CR,LF,"Cannot start COMMAND, exiting",CR,LF>
	msg	Patricide, <CR,LF,"Top level process aborted, cannot continue",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Write protect error">
	msg	ExtErr20,<"Invalid unit">
	msg	ExtErr21,<"Not ready">
	msg	ExtErr22,<"Invalid device request">
	msg	ExtErr23,<"Data error">
	msg	ExtErr24,<"Invalid device request parameters">
	msg	ExtErr25,<"Seek error">
	msg	ExtErr26,<"Invalid media type">
	msg	ExtErr27,<"Sector not found">
	msg	ExtErr28,<"Printer out of paper error">
	msg	ExtErr29,<"Write fault error">
	msg	ExtErr30,<"Read fault error">
	msg	ExtErr31,<"General failure">
	msg	ExtErr32,<"Sharing violation">
	msg	ExtErr33,<"Lock violation">
	msg	ExtErr34,<"Invalid disk change">
	msg	ExtErr35,<"FCB unavailable">
	msg	ExtErr36,<"System resource exhausted">
	msg	ExtErr37,<"Code page mismatch">
	msg	ExtErr38,<"Out of input">
	msg	ExtErr39,<"Insufficient disk space">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"Too many parameters">
	msg	ParsErr02,<"Required parameter missing">
	msg	ParsErr03,<"Invalid switch">
	msg	ParsErr04,<"Invalid keyword">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Parameter value not in allowed range">
	msg	ParsErr07,<"Parameter value not allowed">
	msg	ParsErr08,<"Parameter value not allowed">
	msg	ParsErr09,<"Parameter format not correct">
	msg	ParsErr10,<"Invalid parameter">
	msg	ParsErr11,<"Invalid parameter combination">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Invalid function">
	msg	ExtErr02,<"File not found">
	msg	ExtErr03,<"Path not found">
	msg	ExtErr04,<"Too many open files">
	msg	ExtErr05,<"Access denied ">
	msg	ExtErr06,<"Invalid handle">
	msg	ExtErr07,<"Memory control blocks destroyed">
	msg	ExtErr08,<"Insufficient memory">
	msg	ExtErr09,<"Invalid memory block address">
	msg	ExtErr10,<"Invalid Environment">
	msg	ExtErr11,<"Invalid format">
	msg	ExtErr12,<"Invalid function parameter">
	msg	ExtErr13,<"Invalid data">

	msg	ExtErr15,<"Invalid drive specification">
	msg	ExtErr16,<"Attempt to remove current directory">
	msg	ExtErr17,<"Not same device">
	msg	ExtErr18,<"No more files">

	msg	ExtErr80,<"File exists">

	msg	ExtErr82,<"Cannot make directory entry">
	msg	ExtErr83,<"Fail on INT 24">
	msg	ExtErr84,<"Too many redirections">
	msg	ExtErr85,<"Duplicate redirection">
	msg	ExtErr86,<"Invalid password">
	msg	ExtErr87,<"Invalid parameter">
	msg	ExtErr88,<"Network data fault">
	msg	ExtErr89,<"Function not supported by network">
	msg	ExtErr90,<"Required system component not installed">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\cs\comrmsg.inc ===
;***    Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "P"
Retry_Char      db      "Z"
Ignore_Char     db      "I"
Fail_Char       db      "C"
Yes_Char        db      "A"
No_Char         db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

        msg     Req_Abort, <" (P)eruit">
        msg     Req_Retry, <", (Z)novu">
        msg     Req_Ignore,<", (I)gnorovat">
        msg     Req_Fail,  <", (C)hyba">
        msg     Req_End,   <"?">
        msg     MRead,     <"ten",0>
        msg     MWrite,    <"zpis",0>
        msg     BlkDevErr, <" %1 jednotka %2",CR,LF>
        msg     CharDevErr,<" %1 zazen %2",CR,LF>
        msg     NeedVolMsg,<"Vloit svazek %1 sriov . %2-%3",CR,LF>
        msg     BadFatMsg, <"Chybn tabulka FAT, jednotka %1",CR,LF>
        msg     ComBad,    <"Neplatn soubor COMMAND.COM",CR,LF>
        msg     PutBackMsg,<"Vloit disketu s %1 do jednotky %2",CR,LF>
        msg     Prompt,    <"Pokraujte libovolnou klvesou . . .",CR,LF>
        msg     EndBatMes, <CR,LF,"Ukonit dvkovou lohu (A/N)?">
        msg     ExecEMes,  <"Nelze spustit %1",CR,LF>
        msg     ExeBad,    <"Chyba v souboru EXE",CR,LF>
        msg     TooBig,    <"Program se nevejde do pamti",CR,LF>
        msg     NoHandMes, <CR,LF,"dn voln popisovae">
        msg     RBadNam,   <"Chybn pkaz nebo nzev souboru",CR,LF>
        msg     AccDen,    <"Pstup zamtnut ">
        msg     BMemMes,   <CR,LF,"Chyba alokace pamti">
        msg     HaltMes,   <CR,LF,"Nelze nast COMMAND, systm zastaven",CR,LF>
        msg     FRetMes,   <CR,LF,"Nelze spustit COMMAND, nvrat",CR,LF>
        msg     Patricide, <CR,LF,"Proces na nejvy rovni peruen, nelze pokraovat",CR,LF>
        msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
        dw      DATARES:ExtMsgPtrs,1    ; extended error messages
        dw      DATARES:ParsMsgPtrs,1   ; parse error messages
        dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
                                        ;  use extended error list
        dw      0,0                     ; file system error messages - none
        dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

        msg     ExtErr19,<"Chyba - ochrana proti zpisu">
        msg     ExtErr20,<"Neplatn jednotka">
        msg     ExtErr21,<"Nen pipraveno">
        msg     ExtErr22,<"Neplatn poadavek na zazen">
        msg     ExtErr23,<"Datov chyba">
        msg     ExtErr24,<"Neplatn parametry poadavku na zazen">
        msg     ExtErr25,<"Chyba vyhledn">
        msg     ExtErr26,<"Neplatn typ mdia">
        msg     ExtErr27,<"Sektor nenalezen">
        msg     ExtErr28,<"Chyba - v tiskrn nen papr">
        msg     ExtErr29,<"Chyba pi zpisu">
        msg     ExtErr30,<"Chyba pi ten">
        msg     ExtErr31,<"Obecn chyba">
        msg     ExtErr32,<"Chybn operace (SHARE)">
        msg     ExtErr33,<"Chybn operace (LOCK)">
        msg     ExtErr34,<"Neplatn vmna disku">
        msg     ExtErr35,<"Kontroln blok souboru (FCB) nen k dispozici">
        msg     ExtErr36,<"Systmov prostedky vyerpny">
        msg     ExtErr37,<"Kdov strnky jsou odlin">
        msg     ExtErr38,<"Nen dn vstup">
        msg     ExtErr39,<"Nedostatek msta na disku">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
        dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
        dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
        dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
        dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

        msg     ParsErr01,<"Pli mnoho parametr">
        msg     ParsErr02,<"Schz poadovan parametr">
        msg     ParsErr03,<"Neplatn pepna">
        msg     ParsErr04,<"Neplatn klov slovo">
        msg     ParsErr05,<" ">
        msg     ParsErr06,<"Hodnota parametru je mimo povolen rozsah">
        msg     ParsErr07,<"Nedovolen hodnota parametru">
        msg     ParsErr08,<"Nedovolen hodnota parametru">
        msg     ParsErr09,<"Nesprvn formt parametru">
        msg     ParsErr10,<"Neplatn parametr">
        msg     ParsErr11,<"Neplatn kombinace parametr">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
        dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
        dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
        dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
        dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

        msg     ExtErr01,<"Neplatn funkce">
        msg     ExtErr02,<"Soubor nenalezen">
        msg     ExtErr03,<"Cesta nenalezena">
        msg     ExtErr04,<"Pli mnoho otevench soubor">
        msg     ExtErr05,<"Pstup zamtnut ">
        msg     ExtErr06,<"Neplatn popisova">
        msg     ExtErr07,<"Znieny dc bloky pamti">
        msg     ExtErr08,<"Nedostatek pamti">
        msg     ExtErr09,<"Neplatn adresa pam؜ovho bloku">
        msg     ExtErr10,<"Neplatn tabulka systmovch promnnch">
        msg     ExtErr11,<"Neplatn formt">
        msg     ExtErr12,<"Neplatn parametr funkce">
        msg     ExtErr13,<"Neplatn data">

        msg     ExtErr15,<"Neplatn uren jednotky">
        msg     ExtErr16,<"Pokus o odstrann aktulnho adrese">
        msg     ExtErr17,<"Nen stejn zazen">
        msg     ExtErr18,<"Nejsou dal soubory">

        msg     ExtErr80,<"Soubor ji existuje">

        msg     ExtErr82,<"V adresi nelze vytvoit poloku">
        msg     ExtErr83,<"Chyba peruen (INT 24)">
        msg     ExtErr84,<"Pli mnoho pesmrovn">
        msg     ExtErr85,<"Duplicitn pesmrovn">
        msg     ExtErr86,<"Neplatn heslo">
        msg     ExtErr87,<"Neplatn parametr">
        msg     ExtErr88,<"Chyba sovch dat">
        msg     ExtErr89,<"Tato funkce nen st podporovna">
        msg     ExtErr90,<"Nen nainstalovan poadovan systmov komponenta">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
        dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
        dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
        dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
        dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
        dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
        dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
        dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
        dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
        dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
        dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
        dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
        dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
        dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
        dw      80-40 dup (0) ; null ptrs for errors 40-79
        dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
        dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
        dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
        dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
                                ; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\el\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\es\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\da\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

	msg     BadVerMsg,   <"Forkert DOS-version",CR,LF>
	msg     OutEnvMsg,   <"Der er ikke plads til flere miljvariable",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg     BadComLkMsg, <"Den angivne COMMAND-sgemappe er forkert",CR,LF>
	msg     BadComAccMsg,<"Den angivne COMMAND-sgemappe er forkert, adgang ngtet",CR,LF>

	msg     Help1Msg  <"Starter en ny hndelse af MS-DOS-kommandofortolkeren.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[drev:]sti] [enhed] [/E:nnnnn] [/P] [/C streng] [/MSG]",CR,LF,CR,LF>
	msg     Help3Msg  <"  [drev:]sti      Angiver den mappe, som indeholder filen COMMAND.COM.",CR,LF>
	msg     Help4Msg  <"  enhed           Angiver inddata- og uddataenheden for COMMAND.COM.",CR,LF>
	msg     Help5Msg  <"  /E:nnnnn        Stter startvrdien for miljstrrelsen til nnnnn byte.",CR,LF>
	msg     Help6Msg  <"  /P              Gr den nye kommandofortolker permanent (den kan ikke afsluttes).",CR,LF>
	msg     Help7Msg  <"  /C streng       Udfrer den kommando, som strengen angiver, og stopper.",CR,LF>
	msg     Help8Msg  <"  /MSG            Angiver, at alle fejlmeddelelser skal gemmes i hukommelsen.",CR,LF>
	msg     Help9Msg  <"                  Denne parameter kan kun angives sammen med parameteren /P.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw      RESGROUP:Help9Msg,0

	public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\fi\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\es\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"O"
Fail_Char	db	"D"
Yes_Char	db	"S"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"Anular">
	msg	Req_Retry, <", Repetir">
	msg	Req_Ignore,<", Omitir">
	msg	Req_Fail,  <", Descartar">
	msg	Req_End,   <"?">
	msg	MRead,	   <"leyendo",0>
	msg	MWrite,	   <"escribiendo",0>
	msg	BlkDevErr, <" %1 unidad %2",CR,LF>
	msg	CharDevErr,<" %1 dispositivo %2",CR,LF>
	msg	NeedVolMsg,<"Inserte el volumen %1 serie %2-%3",CR,LF>
	msg	BadFatMsg, <"Tabla de asignacin de archivos no vlida, unidad %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM no vlido",CR,LF>
	msg	PutBackMsg,<"Inserte el disco con %1 en unidad %2",CR,LF>
	msg	Prompt,	   <"Presione una tecla para continuar . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"Desea terminar el proceso por lotes (S/N)?">
	msg	ExecEMes,  <"No se puede ejecutar %1",CR,LF>
	msg	ExeBad,	   <"Error en archivo EXE",CR,LF>
	msg	TooBig,	   <"Programa demasiado extenso para colocarlo en memoria",CR,LF>
	msg	NoHandMes, <CR,LF,"No hay identificadores de archivos disponibles">
	msg	RBadNam,   <"Comando o nombre de archivo incorrecto",CR,LF>
	msg	AccDen,	   <"Acceso denegado ">
	msg	BMemMes,   <CR,LF,"Error en asignacin de memoria">
	msg	HaltMes,   <CR,LF,"No se puede cargar COMMAND, sistema interrumpido",CR,LF>
	msg	FRetMes,   <CR,LF,"No se puede iniciar COMMAND, saliendo",CR,LF>
	msg	Patricide, <CR,LF,"Proceso de nivel principal anulado, no se puede continuar",CR,LF>
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Error de proteccin contra escritura">
	msg	ExtErr20,<"Unidad no vlida">
	msg	ExtErr21,<"No est lista">
	msg	ExtErr22,<"Peticin de dispositivo no vlida">
	msg	ExtErr23,<"Error de datos">
	msg	ExtErr24,<"Parmetros de peticin de dispositivo no vlidos">
	msg	ExtErr25,<"Error de bsqueda">
	msg	ExtErr26,<"Medio de comunicacin no vlido">
	msg	ExtErr27,<"No se ha encontrado el sector">
	msg	ExtErr28,<"Error de impresora sin papel">
	msg	ExtErr29,<"Error de escritura">
	msg	ExtErr30,<"Error de lectura">
	msg	ExtErr31,<"Error general">
	msg	ExtErr32,<"Infraccin de comparticin">
	msg	ExtErr33,<"Infraccin de bloqueo">
	msg	ExtErr34,<"Cambio de disco no vlido">
	msg	ExtErr35,<"FCB no disponible">
	msg	ExtErr36,<"Agotado el recurso de sistema">
	msg	ExtErr37,<"La pgina de cdigos no coincide">
	msg	ExtErr38,<"Informacin de entrada agotada">
	msg	ExtErr39,<"Espacio insuficiente en disco">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"Demasiados parmetros">
	msg	ParsErr02,<"Falta el parmetro requerido">
	msg	ParsErr03,<"Modificador no vlido">
	msg	ParsErr04,<"Palabra clave no vlida">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Valor de parmetro en rango no permitido">
	msg	ParsErr07,<"Valor de parmetro no permitido">
	msg	ParsErr08,<"Valor de parmetro no permitido">
	msg	ParsErr09,<"Formato de parmetro incorrecto">
	msg	ParsErr10,<"Parmetro no vlido">
	msg	ParsErr11,<"Combinacin de parmetros no vlida">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Funcin no vlida">
	msg	ExtErr02,<"No se encuentra el archivo">
	msg	ExtErr03,<"No se encuentra la ruta de acceso">
	msg	ExtErr04,<"Hay demasiados archivos abiertos">
	msg	ExtErr05,<"Acceso denegado">
	msg	ExtErr06,<"Identificador no vlido">
	msg	ExtErr07,<"Bloques de control de memoria destruidos">
	msg	ExtErr08,<"Memoria insuficiente">
	msg	ExtErr09,<"Direccin del bloque de memoria no vlida">
	msg	ExtErr10,<"Entorno operativo no vlido">
	msg	ExtErr11,<"Formato no vlido">
	msg	ExtErr12,<"Parmetro de funcin no vlido">
	msg	ExtErr13,<"Datos no vlidos">

	msg	ExtErr15,<"Unidad especificada no vlida">
	msg	ExtErr16,<"Se intent quitar el directorio actual">
	msg	ExtErr17,<"No es el mismo dispositivo">
	msg	ExtErr18,<"No hay ms archivos">

	msg	ExtErr80,<"El archivo existe">

	msg	ExtErr82,<"No se puede realizar entrada en directorio">
	msg	ExtErr83,<"Fallo en INT 24">
	msg	ExtErr84,<"Demasiadas redirecciones">
	msg	ExtErr85,<"Redireccin duplicada">
	msg	ExtErr86,<"Contrasea no vlida">
	msg	ExtErr87,<"Parmetro no vlido">
	msg	ExtErr88,<"Error de datos en red">
	msg	ExtErr89,<"Funcin no aceptada por la red">
	msg	ExtErr90,<"Componente requerido del sistema no instalado">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\da\comrmsg.inc ===
;***    Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "A"
Retry_Char      db      "F"
Ignore_Char     db      "I"
Fail_Char       db      "M"
Yes_Char        db      "J"
No_Char         db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

	msg     Req_Abort, <"Afbryd">
	msg     Req_Retry, <", Forsg igen">
	msg     Req_Ignore,<", Ignorer">
	msg     Req_Fail,  <", Meld fejl til program">
	msg     Req_End,   <"?">
	msg     MRead,     <"lser",0>
	msg     MWrite,    <"skriver",0>
	msg     BlkDevErr, <" %1 drev %2",CR,LF>
	msg     CharDevErr,<" %1 enhed %2",CR,LF>
	msg     NeedVolMsg,<"Indst disketten %1 med serienummeret %2-%3",CR,LF>
	msg     BadFatMsg, <"Filallokeringstabellen p drev %1 er defekt",CR,LF>
	msg     ComBad,    <"Ugyldig COMMAND.COM",CR,LF>
	msg     PutBackMsg,<"Indst disketten med %1 i drev %2",CR,LF>
	msg     Prompt,    <"Tryk p en vilkrlig tast for at fortstte . . .",CR,LF>
	msg     EndBatMes, <CR,LF,"Afbryd batchjob (J/N)?">
	msg     ExecEMes,  <"%1 kan ikke kres",CR,LF>
	msg     ExeBad,    <"Fejl i EXE-fil",CR,LF>
	msg     TooBig,    <"Programmet er for stort til at passe ind i hukommelsen",CR,LF>
	msg     NoHandMes, <CR,LF,"Der er ingen ledige fil-handles">
	msg     RBadNam,   <"Ugyldig kommando eller filnavn",CR,LF>
	msg     AccDen,    <"Adgang ngtet">
	msg     BMemMes,   <CR,LF,"Fejl i hukommelsestildelingen">
	msg     HaltMes,   <CR,LF,"COMMAND kan ikke indlses, systemet er afbrudt",CR,LF>
	msg     FRetMes,   <CR,LF,"COMMAND kan ikke startes, der afsluttes",CR,LF>
	msg     Patricide, <CR,LF,"Process p topniveau er afbrudt, der kan ikke fortsttes",CR,LF>
	msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
	dw      DATARES:ExtMsgPtrs,1    ; extended error messages
	dw      DATARES:ParsMsgPtrs,1   ; parse error messages
	dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
					;  use extended error list
	dw      0,0                     ; file system error messages - none
	dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

	msg     ExtErr19,<"Skrivebeskyttelsesfejl">
	msg     ExtErr20,<"Ugyldig enhed">
	msg     ExtErr21,<"Ikke klar">
	msg     ExtErr22,<"Ugyldig enhedsforesprgsel">
	msg     ExtErr23,<"Datafejl">
	msg     ExtErr24,<"Ugyldige parametre for enhedsforesprgsel">
	msg     ExtErr25,<"Sgefejl">
	msg     ExtErr26,<"Ugyldig medietype">
	msg     ExtErr27,<"Sektoren kan ikke findes">
	msg     ExtErr28,<"Der er ikke mere papir i printeren">
	msg     ExtErr29,<"Skrivefejl">
	msg     ExtErr30,<"Lsefejl">
	msg     ExtErr31,<"Generel fejl">
	msg     ExtErr32,<"Fildelingsfejl">
	msg     ExtErr33,<"Fejl pga. ls">
	msg     ExtErr34,<"Ugyldigt disketteskift">
	msg     ExtErr35,<"FCB ikke tilgngelig">
	msg     ExtErr36,<"Systemressourcer opbrugt">
	msg     ExtErr37,<"Uoverensstemmelse i tegntabel">
	msg     ExtErr38,<"Mangler input">
	msg     ExtErr39,<"Utilstrkkelig diskplads">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

	msg     ParsErr01,<"Der er for mange parametre">
	msg     ParsErr02,<"Der mangler en krvet parameter">
	msg     ParsErr03,<"Ugyldig parameter">
	msg     ParsErr04,<"Ugyldigt ngleord">
	msg     ParsErr05,<" ">
	msg     ParsErr06,<"Parametervrdien er uden for tilladt omrde">
	msg     ParsErr07,<"Parametervrdien er ikke tilladt">
	msg     ParsErr08,<"Parametervrdien er ikke tilladt">
	msg     ParsErr09,<"Ukorrekt parameterformat">
	msg     ParsErr10,<"Ugyldig parameter">
	msg     ParsErr11,<"Ugyldig parameterkombination">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
	dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

	msg     ExtErr01,<"Ugyldig funktion">
	msg     ExtErr02,<"Filen kan ikke findes">
	msg     ExtErr03,<"Stien kan ikke findes">
	msg     ExtErr04,<"Der er for mange filer bne">
	msg     ExtErr05,<"Adgang ngtet ">
	msg     ExtErr06,<"Ugyldig handle">
	msg     ExtErr07,<"Hukommelsens kontrolblokke er delagt">
	msg     ExtErr08,<"Utilstrkkelig hukommelse">
	msg     ExtErr09,<"Ugyldig adresse p hukommelseskontrolblok">
	msg     ExtErr10,<"Ugyldigt milj">
	msg     ExtErr11,<"Ugyldigt format">
	msg     ExtErr12,<"Ugyldig funktionsparameter">
	msg     ExtErr13,<"Ugyldige data">

	msg     ExtErr15,<"Ugyldig drevspecifikation">
	msg     ExtErr16,<"Det blev forsgt at fjerne den aktuelle mappe">
	msg     ExtErr17,<"Det er ikke samme enhed">
	msg     ExtErr18,<"Der er ikke flere filer">

	msg     ExtErr80,<"Filen findes">

	msg     ExtErr82,<"Der kan ikke oprettes mappeelement">
	msg     ExtErr83,<"Der opstod en fejl p INT 24">
	msg     ExtErr84,<"Der er for mange omdirigeringer">
	msg     ExtErr85,<"Dobbel omdirigering">
	msg     ExtErr86,<"Ugyldig adgangskode">
	msg     ExtErr87,<"Ugyldig parameter">
	msg     ExtErr88,<"Datafejl p netvrket">
	msg     ExtErr89,<"Funktionen er ikke understttet af netvrket">
	msg     ExtErr90,<"En krvet systemkomponent er ikke installeret">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
	dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw      80-40 dup (0) ; null ptrs for errors 40-79
	dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\es\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

	msg     BadVerMsg,   <"Versin incorrecta de DOS",CR,LF>
	msg     OutEnvMsg,   <"Espacio de entorno agotado",CR,LF>
	msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg     BadComLkMsg, <"Directorio incorrecto especificado para bsqueda de COMMAND",CR,LF>
	msg     BadComAccMsg,<"Acceso denegado al directorio especificado para bsqueda de COMMAND",CR,LF>

	msg     Help1Msg  <"Inicia una nueva instancia del procesador de comandos MS-DOS.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[unidad:]ruta] [dispositivo] [/E:nnnnn] [/P] [/C cadena] [/MSG]",CR,LF,CR,LF>
	msg     Help3Msg  <"  [unidad:]ruta   Especifica el directorio que contiene el archivo COMMAND.COM.",CR,LF>
	msg     Help4Msg  <"  dispositivo     Especifica los dispositivos de E/S para comandos.",CR,LF>
	msg     Help5Msg  <"  /E:nnnnn        Fija el entorno inicial a nnnnn bytes.",CR,LF>
	msg     Help6Msg  <"  /P              Fija la permanencia del nuevo procesador de comandos (impide salir).",CR,LF>
	msg     Help7Msg  <"  /C cadena       Ejecuta el comando especificado por la cadena de caracteres y termina.",CR,LF>
	msg     Help8Msg  <"  /MSG            Especifica que se almacenen en memoria todos los mensajes de error. Puede",CR,LF>
	msg     Help9Msg  <"                  hacer falta /P con este modificador.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw      RESGROUP:Help9Msg,0

	public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\el\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

	msg     BadVerMsg,   <"⤞ ⡛  DOS",CR,LF>
	msg     OutEnvMsg,   <" 㣞 ᢢ 㟞",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C) 飘 Microsoft Corp 1990-2001.",CR,LF>
	msg     BadComLkMsg, <" ⤦ ᢦ 㫞  COMMAND 夘 ᢢ",CR,LF>
	msg     BadComAccMsg,<" ⤦ ᢦ 㫞  COMMAND 夘 ᢢ",CR,LF," ᧞  橙",CR,LF>

	msg     Help1Msg  <"夞 ⦬ interpreter   MS-DOS.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[婡:]] [] [/E:nnnnn] [/P] [/C ] [/MSG]",CR,LF,CR,LF>
	msg     Help3Msg  <"  [婡:]     ᢦ   婡   COMMAND.COM.",CR,LF>
	msg     Help4Msg  <"             婦/⥦  .",CR,LF>
	msg     Help5Msg  <"  /E:nnnnn         ⚜ ᢢ  nnnnn byte.",CR,LF>
	msg     Help6Msg  <"  /P                ⦬ interpreter  椠",CR,LF,"( 櫞 曦).",CR,LF>
	msg     Help7Msg  <"  /C     ⢜    婫   ,",CR,LF,"  穞.",CR,LF>
	msg     Help8Msg  <"  /MSG            坜  梘  磘 ᢣ 夘 ⤘",CR,LF>
	msg     Help9Msg  <"                   㣞. ⧜  婜  槫 /P 高.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw      RESGROUP:Help9Msg,0

	public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\el\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"(A)ਫ਼">
	msg	Req_Retry, <", (R)ᢞ">
	msg	Req_Ignore,<", (I)ᙢ">
	msg	Req_Fail,  <", (F)">
	msg	Req_End,   <"?">
	msg	MRead,	   <"ᚤਫ਼",0>
	msg	MWrite,	   <"",0>
	msg	BlkDevErr, <"   %1 ᛘ 婡 %2",CR,LF>
	msg	CharDevErr,<"   %1  %2",CR,LF>
	msg	NeedVolMsg,<"㩫  ᛘ  棦 %1   %2-%3",CR,LF>
	msg	BadFatMsg, <"ᢢ 夘 騞   ᛘ 婡 %1",CR,LF>
	msg	ComBad,	   <" ⚡ COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"㩫  ⫘   %1  ᛘ %2",CR,LF>
	msg	Prompt,	   <"⩫ ⤘ 㡫   婜 . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"     ⩣ (y()/n(殠));">
	msg	ExecEMes,  <" 夘   ⢜  %1",CR,LF>
	msg	ExeBad,	   <"ᢣ   EXE",CR,LF>
	msg	TooBig,	   <" 暨 夘  ᢦ   ⩜  㣞",CR,LF>
	msg	NoHandMes, <CR,LF," ᨮ ⬟ 填  ">
	msg	RBadNam,   <"⤞   椦 妬",CR,LF>
	msg	AccDen,	   <" ᧞  橙 ">
	msg	BMemMes,   <CR,LF,"ᩫ ᢣ  騞 㣞">
	msg	HaltMes,   <CR,LF," 夘     COMMAND,  穫 槞",CR,LF>
	msg	FRetMes,   <CR,LF," 夘   夞  COMMAND, 夜 ⢦",CR,LF>
	msg	Patricide, <CR,LF,"   ᫦ ⛦ 韞,  夘   ⮜",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"ᢣ 嘪 ">
	msg	ExtErr20,<" ᛘ  夘 ⚡">
	msg	ExtErr21,<" 夘 ⫦">
	msg	ExtErr22,<" 嫞   夘 ⚡">
	msg	ExtErr23,<"ᢣ ">
	msg	ExtErr24,<" 嫞   ⮜ ⚡ ⫨">
	msg	ExtErr25,<"ᩫ ᢣ 㫞">
	msg	ExtErr26,<" 秦   ⩦  夘 ⚡">
	msg	ExtErr27,<" ⟞ ⤘ ☪ 婡">
	msg	ExtErr28,<"⢦  ">
	msg	ExtErr29,<"ᢣ ">
	msg	ExtErr30,<"ᢣ ᚤਫ਼">
	msg	ExtErr31,<" ᢣ">
	msg	ExtErr32,<"嘩  㩞">
	msg	ExtErr33,<"嘩 飘">
	msg	ExtErr34,<"뚠  ⚡  婡">
	msg	ExtErr35,<"  ⚮ (FCB) 夘 ⩠">
	msg	ExtErr36,<" 樦 㣘 㟞">
	msg	ExtErr37,<" ">
	msg	ExtErr38,<" 棜 㟞">
	msg	ExtErr39,<" ᨮ  騦  婡">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"ᨮ ᨘ  ᣜ">
	msg	ParsErr02,<"姜  嫞 ᣜ">
	msg	ParsErr03,<"뤘 槫  夘 ⚡">
	msg	ParsErr04,<" ⥞   ⠤ ⚡">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<" ᣜ ⮜   ">
	msg	ParsErr07,<" ᣜ ⮜    ⧜">
	msg	ParsErr08,<" ᣜ ⮜    ⧜">
	msg	ParsErr09,<"⤞  ⫨">
	msg	ParsErr10,<" ᣜ  夘 ⚡">
	msg	ParsErr11,<"  ⫨  夘 ⚡">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"   夘 ⚡">
	msg	ExtErr02,<"   ⟞">
	msg	ExtErr03,<"   ⟞">
	msg	ExtErr04,<"ᨮ ᨘ   ">
	msg	ExtErr05,<" ᧞  橙 ">
	msg	ExtErr06,<" 填   夘 ⚡">
	msg	ExtErr07,<"᭞  ⚮  㣞">
	msg	ExtErr08,<" ᨮ  㣞">
	msg	ExtErr09,<" 矬   㣞  夘 ⚡">
	msg	ExtErr10,<" ᢢ  夘 ⚡">
	msg	ExtErr11,<" 樭ਫ਼  夘 ⚡">
	msg	ExtErr12,<" ᣜ  嘪  夘 ⚡">
	msg	ExtErr13,<" ⤘  夘 ⚡">

	msg	ExtErr15,<" ᛘ 婡  婫  夘 ⚡">
	msg	ExtErr16,<"뚠 槜     ᢦ">
	msg	ExtErr17,<" 桜   因 ">
	msg	ExtErr18,<" ᨮ ᢢ ">

	msg	ExtErr80,<"  ᨮ">

	msg	ExtErr82,<" 夘    騞 暦">
	msg	ExtErr83,<"  INT 24">
	msg	ExtErr84,<"  礩">
	msg	ExtErr85,<"  矬">
	msg	ExtErr86,<"  橙  夘 ⚡">
	msg	ExtErr87,<" ᣜ  夘 ⚡">
	msg	ExtErr88,<"ᩫ ᢣ  ⤘ 禬">
	msg	ExtErr89,<" 填  坜   ">
	msg	ExtErr90,<"뤘 嫞   㣘  ⮜ ">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\fr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\fi\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Hylk, Uudelleen, Eponnistunut, Ohita?"
;	and Yes/No.

Abort_Char      db      "H"
Retry_Char      db      "U"
Ignore_Char     db      "O"
Fail_Char       db      "E"
Yes_Char        db      "K"
No_Char         db      "E"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

	msg     Req_Abort, <"Hylk">
	msg     Req_Retry, <", Uudelleen">
	msg     Req_Ignore,<", Ohita">
	msg     Req_Fail,  <", Eponnistunut">
	msg     Req_End,   <"?">
	msg     MRead,     <"luettaessa:",0>
	msg     MWrite,    <"kirjoitettaessa:",0>
	msg     BlkDevErr, <" %1 asema %2",CR,LF>
	msg     CharDevErr,<" %1 laite %2",CR,LF>
	msg     NeedVolMsg,<"Aseta asemaan levy %1 sarjanumero %2-%3",CR,LF>
	msg     BadFatMsg, <"Tilanvaraustaulukko (FAT) vahingoittunut, asema %1",CR,LF>
	msg     ComBad,    <"COMMAND.COM ei kelpaa",CR,LF>
	msg     PutBackMsg,<"Aseta asemaan %2 levy, jossa on tiedosto %1.",CR,LF>
	msg     Prompt,    <"Paina mit tahansa nppint jatkaaksesi...",CR,LF>
	msg     EndBatMes, <CR,LF,"Pysytetnk komentojonoty (K/E)?">
	msg     ExecEMes,  <"Tiedostoa %1 ei voi suorittaa",CR,LF>
	msg     ExeBad,    <"Virhe EXE-tiedostossa",CR,LF>
	msg     TooBig,    <"Ohjelma on liian suuri muistiin",CR,LF>
	msg     NoHandMes, <CR,LF,"Ei vapaita tiedostokahvoja">
	msg     RBadNam,   <"Komennon tai tiedoston nimi ei kelpaa",CR,LF>
	msg     AccDen,    <"Kytt estetty ">
	msg     BMemMes,   <CR,LF,"Muistin varausvirhe">
	msg     HaltMes,   <CR,LF,"Ei voi ladata COMMAND.COM:ia, jrjestelm pysytetty",CR,LF>
	msg     FRetMes,   <CR,LF,"Ei voi kynnist COMMAND.COM:ia, poistutaan",CR,LF>
	msg     Patricide, <CR,LF,"Yltason prosessi keskeytetty, ei voi jatkaa",CR,LF> 
	msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
	dw      DATARES:ExtMsgPtrs,1    ; extended error messages
	dw      DATARES:ParsMsgPtrs,1   ; parse error messages
	dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
					;  use extended error list
	dw      0,0                     ; file system error messages - none
	dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

	msg     ExtErr19,<"Kirjoitussuojausvirhe">
	msg     ExtErr20,<"Yksikk ei kelpaa">
	msg     ExtErr21,<"Ei valmis">
	msg     ExtErr22,<"Laitepyynt ei kelpaa">
	msg     ExtErr23,<"Datavirhe">
	msg     ExtErr24,<"Laitepyynnn parametrit eivt kelpaa">
	msg     ExtErr25,<"Etsintvirhe">
	msg     ExtErr26,<"Mediatyyppi ei kelpaa">
	msg     ExtErr27,<"Sektoria ei lydy">
	msg     ExtErr28,<"Kirjoittimen paperi on loppu">
	msg     ExtErr29,<"Kirjoituksen virhe">
	msg     ExtErr30,<"Lukemisen virhe">
	msg     ExtErr31,<"Yleinen virhe">
	msg     ExtErr32,<"Jakovirhe">
	msg     ExtErr33,<"Lukitusvirhe">
	msg     ExtErr34,<"Levyn vaihto ei kelpaa">
	msg     ExtErr35,<"Tiedoston valvontalohko (FCB) ei kytettviss">
	msg     ExtErr36,<"Jrjestelmresurssi lopussa">
	msg     ExtErr37,<"Koodisivu ei tsm">
	msg     ExtErr38,<"Vienti on lopussa">
	msg     ExtErr39,<"Levytila ei riit">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

	msg     ParsErr01,<"Liian monta parametria">
	msg     ParsErr02,<"Vaadittu parametri puuttuu">
	msg     ParsErr03,<"Valitsin ei kelpaa">
	msg     ParsErr04,<"Avainsana ei kelpaa">
	msg     ParsErr05,<" ">
	msg     ParsErr06,<"Parametrin arvo ei sallitulla vlill">
	msg     ParsErr07,<"Parametrin arvo ei sallittu">
	msg     ParsErr08,<"Parametrin arvo ei sallittu">
	msg     ParsErr09,<"Parametrin muoto ei kelpaa">
	msg     ParsErr10,<"Parametri ei kelpaa">
	msg     ParsErr11,<"Parametriyhdistelm ei kelpaa">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
	dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

	msg     ExtErr01,<"Toiminto ei kelpaa">
	msg     ExtErr02,<"Tiedostoa ei lydy">
	msg     ExtErr03,<"Polkua ei lydy">
	msg     ExtErr04,<"Liian monta tiedostoa avoinna">
	msg     ExtErr05,<"Kytt estetty ">
	msg     ExtErr06,<"Kahva ei kelpaa">
	msg     ExtErr07,<"Muistinvalvontalohkoja tuhoutunut">
	msg     ExtErr08,<"Ei riittvsti muistia">
	msg     ExtErr09,<"Muistilohkon osoite ei kelpaa">
	msg     ExtErr10,<"Ymprist ei kelpaa">
	msg     ExtErr11,<"Muoto ei kelpaa">
	msg     ExtErr12,<"Funktion parametri ei kelpaa">
	msg     ExtErr13,<"Data ei kelpaa">

	msg     ExtErr15,<"Asemamritys ei kelpaa">
	msg     ExtErr16,<"Yritys poistaa nykyinen hakemisto">
	msg     ExtErr17,<"Ei sama laite">
	msg     ExtErr18,<"Ei enemp tiedostoja">

	msg     ExtErr80,<"Tiedosto on olemassa">

	msg     ExtErr82,<"Hakemistovienti ei voi tehd">
	msg     ExtErr83,<"Virhe INT 24:ss">
	msg     ExtErr84,<"Liian monta uudelleenohjausta">
	msg     ExtErr85,<"Kaksinkertainen uudelleenohjaus">
	msg     ExtErr86,<"Salasana ei kelpaa">
	msg     ExtErr87,<"Parametri ei kelpaa">
	msg     ExtErr88,<"Verkon datavirhe">
	msg     ExtErr89,<"Verkko ei tue toimintoa">
	msg     ExtErr90,<"Tarvittava jrjestelmn osa ei ole asennettuna">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.  
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
	dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw      80-40 dup (0) ; null ptrs for errors 40-79
	dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\ger\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\fi\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

	msg     BadVerMsg,   <"DOS-versio ei kelpaa",CR,LF>
	msg     OutEnvMsg,   <"Ympristmuuttujien tila on lopussa",CR,LF>
	msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990 - 2001.",CR,LF>
	msg     BadComLkMsg, <"Mritetty COMMAND-hakupolku ei kelpaa",CR,LF>
	msg     BadComAccMsg,<"Mritetty COMMAND-hakupolku ei kelpaa. Kytt on estetty",CR,LF>

	msg     Help1Msg  <"Aloittaa uuden MS-DOS-komentotulkin.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[asema:]polku] [laite] [/E:nnnnn] [/P] [/C merkkijono] [/MSG]",CR,LF,CR,LF>
	msg     Help3Msg  <"  [asema:]polku   Mritt COMMAND.COM-tiedoston hakemiston.",CR,LF>
	msg     Help4Msg  <"  laite           Mritt sytss ja tulostuksessa kytettvn laitteen.",CR,LF>
	msg     Help5Msg  <"  /E:nnnnn        Asettaa ympristn kooksi nnnnn tavua.",CR,LF>
	msg     Help6Msg  <"  /P              Asettaa komentotulkin pysyvksi (ei voi lopettaa).",CR,LF>
	msg     Help7Msg  <"  /C merkkijono   Suorittaa merkkijonon mrittelemn komennon ja lopettaa.",CR,LF>
	msg     Help8Msg  <"  /MSG            Mritt kaikki virheilmoitukset tallennettavaksi muistiin.",CR,LF>
	msg     Help9Msg  <"                  Kyt valitsinta /P tmn valitsimen kanssa.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\hu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\fr\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

	msg	BadVerMsg,   <"Mauvaise version de MS-DOS",CR,LF>
	msg	OutEnvMsg,   <"Espace d'environnement insuffisant",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg	BadComLkMsg, <"Mauvais rpertoire de recherche de COMMAND.COM",CR,LF>
	msg	BadComAccMsg,<"Mauvais rpertoire de recherche de COMMAND.COM, accs refus",CR,LF>

	msg	Help1Msg  <"Lance une nouvelle copie de l'interprteur de commandes MS-DOS.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[lecteur:]chemin] [priph] [/E:nnnnn] [/P] [/[C|K] commande] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [lecteur:]chemin  Emplacement du fichier COMMAND.COM.",CR,LF>
        msg     Help4Msg  <"  priph            Priphrique utilis pour les E/S des commandes.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn          Spcifie la taille initiale de l'espace d'environnement.",CR,LF>
	msg	Help6Msg  <"  /P                Rend le nouvel interprteur de commande permanent.",CR,LF>
	msg	Help7Msg  <"  /C chane         Excute la commande spcifie par chane, puis s'arrte.",CR,LF>
	msg	Help8Msg  <"  /MSG              Stocke tous les messages d'erreurs en mmoire. Vous",CR,LF>
	msg	Help9Msg  <"                    devez spcifier /P avec ce commutateur",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\it\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\ger\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

	msg     BadVerMsg,   <"Falsche DOS-Version",CR,LF>
	msg     OutEnvMsg,   <"Kein Speicherplatz mehr im Umgebungsbereich",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg     BadComLkMsg, <"Angegebenes COMMAND-Verzeichnis fehlerhaft",CR,LF>
	msg     BadComAccMsg,<"Angegebenes COMMAND-Verzeichnis fehlerhaft, Zugriff verweigert",CR,LF>

	msg     Help1Msg  <"Startet eine neue Kopie des MS-DOS-Befehlsinterpreters.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[Laufwerk:]Pfad] [Gert] [/E:nnnnn] [/P] [/C Befehl [/MSG]",CR,LF,CR,LF>
	msg     Help3Msg  <" [Laufwerk:]Pfad Bezeichnet das Verzeichnis mit der Datei COMMAND.COM.",CR,LF>
	msg     Help4Msg  <" Gert           Gert fr die Ein- und Ausgabe des Befehlsprozessors.",CR,LF>
	msg     Help5Msg  <" /E:nnnnn        Stellt die anfngliche Umgebungsgre auf nnnnn Bytes ein.",CR,LF>
	msg     Help6Msg  <" /P              Macht den neuen Befehlsinterpreter permanent (nicht beendbar).",CR,LF>
	msg     Help7Msg  <" /C Befehl       Fhrt den Befehl in Zeichenkette aus und endet dann.",CR,LF>
	msg     Help8Msg  <" /MSG            Alle Fehlermeldungen werden im Arbeitsspeicher gehalten",CR,LF>
	msg     Help9Msg  <"                 (nur zusammen mit der Option /P verwendbar).",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw      RESGROUP:Help9Msg,0

	public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\ger\comrmsg.inc ===
;***    Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "A"
Retry_Char      db      "W"
Ignore_Char     db      "I"
Fail_Char               db      "U"
Yes_Char                db      "J"
No_Char                 db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

	msg     Req_Abort,  <"(A)bbrechen">
	msg     Req_Retry,  <", (W)iederholen">
	msg     Req_Ignore, <", (I)gnorieren">
	msg     Req_Fail,   <", (U)ebergehen">
	msg     Req_End,    <"?">
	msg     MRead,      <"beim Lesen von",0>
	msg     MWrite,     <"beim Schreiben auf",0>
	msg     BlkDevErr,  <" %1 Laufwerk %2",CR,LF>
	msg     CharDevErr, <" %1 Gert %2",CR,LF>
	msg     NeedVolMsg, <"Bitte Datentrger %1 Seriennummer %2-%3 einlegen",CR,LF>
	msg     BadFatMsg,  <"Fehlerhafte Dateizuordnungstabelle, Laufwerk %1",CR,LF>
	msg     ComBad,     <"COMMAND.COM ungltig",CR,LF>
	msg     PutBackMsg, <"Diskette mit %1 in Laufwerk %2 einlegen",CR,LF>
	msg     Prompt,     <"Eine beliebige Taste drcken, um fortzusetzen . . .",CR,LF>
	msg     EndBatMes,  <CR,LF,"Stapelverarbeitung abbrechen (J/N)?">
	msg     ExecEMes,   <"%1 nicht ausfhrbar",CR,LF>
	msg     ExeBad,     <"Fehler in .EXE-Datei",CR,LF>
	msg     TooBig,     <"Programm zu gro fr den Arbeitsspeicher",CR,LF>
	msg     NoHandMes,  <CR,LF,"Keine freien Zugriffsnummern">
	msg     RBadNam,    <"Befehl oder Dateiname nicht gefunden",CR,LF>
	msg     AccDen,     <"Zugriff verweigert ">
	msg     BMemMes,    <CR,LF,"Speicherzuordnungsfehler">
	msg     HaltMes,    <CR,LF,"COMMAND kann nicht geladen werden, System angehalten",CR,LF>
	msg     FRetMes,    <CR,LF,"COMMAND kann nicht gestartet werden, Verarbeitung wird beendet",CR,LF>
	msg     Patricide,  <CR,LF,"Verarbeitung der obersten Programmebene abgebrochen. Fortsetzung nicht mglich",CR,LF> 
	msg     Newlin,     <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
	dw      DATARES:ExtMsgPtrs,1    ; extended error messages
	dw      DATARES:ParsMsgPtrs,1   ; parse error messages
	dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
							; use extended error list
	dw      0,0                                     ; file system error messages - none
	dw      DATARES:MsgRetrv_Trap   ; address of message retriever
MySeg3  dw      ?                               ; (segment filled in during init)



;*      Critical error messages.

	msg     ExtErr19,<"Schreibschutzfehler">
	msg     ExtErr20,<"Ungltige Einheit">
	msg     ExtErr21,<"Nicht bereit">
	msg     ExtErr22,<"Unzulssige Gerteanforderung">
	msg     ExtErr23,<"Datenfehler">
	msg     ExtErr24,<"Unzulssige Gerteanforderungsparameter">
	msg     ExtErr25,<"Positionierungsfehler">
	msg     ExtErr26,<"Unzulssiger Datentrgertyp">
	msg     ExtErr27,<"Sektor nicht gefunden">
	msg     ExtErr28,<"Der Drucker hat kein Papier mehr">
	msg     ExtErr29,<"Schreibstrung">
	msg     ExtErr30,<"Lesestrung">
	msg     ExtErr31,<"Allgemeiner Fehler">
	msg     ExtErr32,<"Unzulssige SHARE-Operation">
	msg     ExtErr33,<"Unzulssige LOCK-Operation">
	msg     ExtErr34,<"Unzulssiger Diskettenwechsel">
	msg     ExtErr35,<"Dateisteuerblock (FCB) nicht verfgbar">
	msg     ExtErr36,<"Systemressource erschpft">
	msg     ExtErr37,<"Codepages stimmen nicht berein">
	msg     ExtErr38,<"Keine Eingabe mehr vorhanden">
	msg     ExtErr39,<"Zuwenig Speicherplatz auf dem Datentrger">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

	msg     ParsErr01,<"Zu viele Parameter">
	msg     ParsErr02,<"Erforderlicher Parameter fehlt">
	msg     ParsErr03,<"Unzulssige Option">
	msg     ParsErr04,<"Unzulssiges Schlsselwort">
	msg     ParsErr05,<" ">
	msg     ParsErr06,<"Parameterwert nicht im erlaubten Rahmen">
	msg     ParsErr07,<"Parameterwert nicht zulssig">
	msg     ParsErr08,<"Parameterwert nicht zulssig">
	msg     ParsErr09,<"Parameterformat nicht korrekt">
	msg     ParsErr10,<"Unzulssiger Parameter">
	msg     ParsErr11,<"Unzulssige Parameterkombination">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
	dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

	msg     ExtErr01,<"Ungltige Funktion">
	msg     ExtErr02,<"Datei nicht gefunden">
	msg     ExtErr03,<"Pfad nicht gefunden">
	msg     ExtErr04,<"Zu viele Dateien geffnet">
	msg     ExtErr05,<"Zugriff verweigert/nicht mglich ">
	msg     ExtErr06,<"Undefinierte Zugriffsnummer">
	msg     ExtErr07,<"Speichersteuerblcke zerstrt">
	msg     ExtErr08,<"Zuwenig Arbeitsspeicher">
	msg     ExtErr09,<"Ungltige Speicherblockadresse">
	msg     ExtErr10,<"Ungltige Umgebung">
	msg     ExtErr11,<"Ungltiges Format">
	msg     ExtErr12,<"Unzulssige Funktionsparameter">
	msg     ExtErr13,<"Ungltige Daten">

	msg     ExtErr15,<"Ungltige Laufwerkangabe">
	msg     ExtErr16,<"Versuch, aktuelles Verzeichnis zu lschen">
	msg     ExtErr17,<"Nicht dasselbe Gert">
	msg     ExtErr18,<"Keine weiteren Dateien">

	msg     ExtErr80,<"Datei existiert bereits">

	msg     ExtErr82,<"Verzeichniseintrag kann nicht erstellt werden">
	msg     ExtErr83,<"Fehler bei INT 24">
	msg     ExtErr84,<"Zu viele Netzwerk-Umleitungen">
	msg     ExtErr85,<"Doppelte Netzwerk-Umleitung">
	msg     ExtErr86,<"Ungltiges Passwort">
	msg     ExtErr87,<"Unzulssiger Parameter">
	msg     ExtErr88,<"Netzwerkdaten-Strung">
	msg     ExtErr89,<"Diese Funktion wird nicht vom Netzwerk untersttzt">
	msg     ExtErr90,<"Erforderliche Systemkomponente nicht installiert">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.  
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
	dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw      80-40 dup (0) ; null ptrs for errors 40-79
	dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\fr\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"E"
Yes_Char	db	"O"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"Abandon">
	msg	Req_Retry, <", Reprise">
	msg	Req_Ignore,<", Ignorer">
	msg	Req_Fail,  <", Echec">
	msg	Req_End,   <" ?">
	msg	MRead,	   <"lecture",0>
	msg	MWrite,	   <"criture",0>
	msg	BlkDevErr, <" %1 sur lecteur %2",CR,LF>
	msg	CharDevErr,<" %1 sur lecteur %2",CR,LF>
	msg	NeedVolMsg,<"Insrez le volume %1 numro de srie %2-%3",CR,LF>
	msg	BadFatMsg, <"Lecteur %1: Table d'allocation des fichiers incorrecte",CR,LF>
	msg	ComBad,	   <"COMMAND.COM non valide",CR,LF>
	msg	PutBackMsg,<"Insrez le disque contenant %1 dans le lecteur %2",CR,LF>
	msg	Prompt,	   <"Appuyez sur une touche pour continuer. . .",CR,LF>
	msg	EndBatMes, <CR,LF,"Terminer le fichier de commandes (O/N) ?">
	msg	ExecEMes,  <"Impossible d'excuter %1",CR,LF>
	msg	ExeBad,	   <"Erreur dans fichier .EXE",CR,LF>
	msg	TooBig,	   <"Programme trop grand pour tenir en mmoire",CR,LF>
	msg	NoHandMes, <CR,LF,"Aucun descripteur de fichier libre">
	msg	RBadNam,   <"Nom de commande ou de fichier incorrect.",CR,LF>
	msg	AccDen,	   <"Accs refus ">
	msg	BMemMes,   <CR,LF,"Erreur d'allocation de mmoire">
	msg	HaltMes,   <CR,LF,"Impossible de charger COMMAND.COM, systme arrt",CR,LF>
	msg	FRetMes,   <CR,LF,"Impossible de dmarrer COMMAND.COM, sortie",CR,LF>
	msg	Patricide, <CR,LF,"Procdure de niveau suprieur abandonne, arrt",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Erreur de protection en criture : ">
	msg	ExtErr20,<"Lecteur non valide : ">
	msg	ExtErr21,<"Non prt : ">
	msg	ExtErr22,<"Requte priphrique non valide : ">
	msg	ExtErr23,<"Erreur de donnes : ">
	msg	ExtErr24,<"Paramtres de requte priphrique non valides : ">
	msg	ExtErr25,<"Erreur de positionnement de la tte : ">
	msg	ExtErr26,<"Type de support non valide : ">
	msg	ExtErr27,<"Secteur non trouv : ">
	msg	ExtErr28,<"Attente de papier : ">
	msg	ExtErr29,<"Erreur d'criture : ">
	msg	ExtErr30,<"Erreur de lecture : ">
	msg	ExtErr31,<"Echec gnral : ">
	msg	ExtErr32,<"Violation de partage : ">
	msg	ExtErr33,<"Violation de verrouillage : ">
	msg	ExtErr34,<"Changement de disque non valide : ">
	msg	ExtErr35,<"FCB non disponible : ">
	msg	ExtErr36,<"Ressources du systme puises : ">
	msg	ExtErr37,<"Page de codes non concordante : ">
	msg	ExtErr38,<"Plus de donnes en entre : ">
	msg	ExtErr39,<"Espace disque insuffisant : ">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"Trop de paramtres">
	msg	ParsErr02,<"Paramtre requis manquant">
	msg	ParsErr03,<"Commutateur non valide">
	msg	ParsErr04,<"Mot-cl non valide">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Valeur du paramtre hors de l'intervalle permis">
	msg	ParsErr07,<"Valeur de paramtre non permise">
	msg	ParsErr08,<"Valeur de paramtre non permise">
	msg	ParsErr09,<"Format de paramtre incorrect">
	msg	ParsErr10,<"Paramtre non valide">
	msg	ParsErr11,<"Combinaison de paramtres non valide">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Fonction non valide">
	msg	ExtErr02,<"Fichier non trouv">
	msg	ExtErr03,<"Chemin non trouv">
	msg	ExtErr04,<"Trop de fichiers ouverts">
	msg	ExtErr05,<"Accs refus">
	msg	ExtErr06,<"Descripteur non valide">
	msg	ExtErr07,<"Blocs de contrle mmoire dtruits">
	msg	ExtErr08,<"Mmoire insuffisante">
	msg	ExtErr09,<"Adresse de bloc mmoire non valide">
	msg	ExtErr10,<"Environnement non valide">
	msg	ExtErr11,<"Format non valide">
	msg	ExtErr12,<"Paramtre de fonction non valide">
	msg	ExtErr13,<"Donnes non valides">

	msg	ExtErr15,<"Spcification du lecteur non valide">
	msg	ExtErr16,<"Tentative de suppression du rpertoire en cours">
	msg	ExtErr17,<"Pas le mme priphrique">
	msg	ExtErr18,<"Plus de fichier">

	msg	ExtErr80,<"Le fichier existe">

	msg	ExtErr82,<"Impossible de crer entre dans rpertoire">
	msg	ExtErr83,<"Echec dans INT 24">
	msg	ExtErr84,<"Trop de redirections">
	msg	ExtErr85,<"Redirection en double">
	msg	ExtErr86,<"Mot de passe non valide">
	msg	ExtErr87,<"Paramtre non valide">
	msg	ExtErr88,<"Erreur donnes rseau">
	msg	ExtErr89,<"Fonction non gre par le rseau">
	msg	ExtErr90,<"Composant du systme requis mais non install">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\hu\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

        msg     BadVerMsg,   <"Nem megfelel DOS verzi. ",CR,LF>
        msg     OutEnvMsg,   <"Elfogyott a krnyezeti vltozk szmra fenntartott hely.",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
        msg     BadComLkMsg, <"A megadott COMMAND keressi knyvtr hibs. ",CR,LF>
        msg     BadComAccMsg,<" A megadott COMMAND keressi knyvtr hibs, a hozzfrs megtagadva. ",CR,LF>

        msg     Help1Msg  <"Elindtja az MS-DOS parancsrtelmez j pldnyt.",CR,LF,CR,LF>
        msg     Help2Msg  <"COMMAND [[meghajt:]elrsi t] [eszkz] [/E:nnnnn] [/P] [/C parancs] [/MSG]",CR,LF,CR,LF>
        msg     Help3Msg  <"  [meghajt:]elrsi t A COMMAND.COM fjlt tartalmaz knyvtr elrsi tja.",CR,LF>
        msg     Help4Msg  <"  eszkz               A parancsok be- s kimenethez hasznlt eszkz.",CR,LF>
        msg     Help5Msg  <"  /E:nnnnn             A krnyezeti vltozk szmra fenntartott hely kezdeti mrete bjtokban.",CR,LF>
        msg     Help6Msg  <"  /P                   Az j parancsrtelmezt llandv teszi (nem lehet kilpni).",CR,LF>
        msg     Help7Msg  <"  /C parancs           Vgrehajtja a megadott parancsot s lell.",CR,LF>
        msg     Help8Msg  <"  /MSG                 Minden hibazenetet a memriban trol.",CR,LF>
        msg     Help9Msg  <"                       (A /P kapcsolt is meg kell adni.)",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
                dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
                dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
                dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
                dw      RESGROUP:Help9Msg,0

	public	HelpMsgs

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\it\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

	msg     BadVerMsg,   <"Versione DOS errata",CR,LF>
	msg     OutEnvMsg,   <"Spazio di ambiente esaurito",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg     BadComLkMsg, <"Directory di ricerca specificata per COMMAND non valida",CR,LF>
	msg     BadComAccMsg,<"Directory di ricerca specificata per COMMAND non valida. Accesso negato",CR,LF>

	msg     Help1Msg  <"Avvia una nuova istanza dell'interprete di comandi MS-DOS.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[unit:]percorso] [periferica] [/E:nnnnn] [/P] [/C stringa] [/MSG]",CR,LF,CR,LF>
	msg     Help3Msg  <"  [unit:]percorso   Specifica la directory che contiene il file COMMAND.COM.",CR,LF>
	msg     Help4Msg  <"  periferica         Specifica la periferica da usare per l'input e l'output dei comandi.",CR,LF>
	msg     Help5Msg  <"  /E:nnnnn           Imposta la dimensione iniziale dell'ambiente a nnnnn byte.",CR,LF>
	msg     Help6Msg  <"  /P                 Rende permanente il nuovo interprete di comandi.",CR,LF>
	msg     Help7Msg  <"  /C stringa         Esegue il comando specificato nella stringa e si ferma.",CR,LF>
	msg     Help8Msg  <"  /MSG               Memorizza tutti i messaggi di errore. Con questa opzione",CR,LF>
	msg     Help9Msg  <"                      necessario specificare anche l'opzione /P.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw      RESGROUP:Help9Msg,0

	public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\it\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"T"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"L"
Yes_Char	db	"S"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"Termina">
	msg	Req_Retry, <", Riprova">
	msg	Req_Ignore,<", Ignora">
	msg	Req_Fail,  <", Tralascia">
	msg	Req_End,   <"?">
	msg	MRead,	   <"lettura di",0>
	msg	MWrite,	   <"scrittura di",0>
	msg	BlkDevErr, <" %1 unit %2",CR,LF>
	msg	CharDevErr,<" %1 unit %2",CR,LF>
	msg	NeedVolMsg,<"Inserire il volume %1 numero di serie %2-%3",CR,LF>
	msg	BadFatMsg, <"Tabella di allocazione file difettosa, unit %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM non valido",CR,LF>
	msg	PutBackMsg,<"Inserire il disco con %1 nell'unit %2",CR,LF>
	msg	Prompt,	   <"Premere un tasto per continuare . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"Terminare il processo batch (S/N)?">
	msg	ExecEMes,  <"Impossibile eseguire %1",CR,LF>
	msg	ExeBad,	   <"Errore nel file EXE",CR,LF>
	msg	TooBig,	   <"Programma troppo grande per la memoria",CR,LF>
	msg	NoHandMes, <CR,LF,"Nessuna handle di file libera">
	msg	RBadNam,   <"Nome di comando o file non valido",CR,LF>
	msg	AccDen,	   <"Accesso negato ">
	msg	BMemMes,   <CR,LF,"Errore di allocazione della memoria">
	msg	HaltMes,   <CR,LF,"Impossibile caricare COMMAND, sistema arrestato",CR,LF>
	msg	FRetMes,   <CR,LF,"Impossibile avviare COMMAND, terminazione",CR,LF>
	msg	Patricide, <CR,LF,"Processo di alto livello terminato, impossibile proseguire",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Errore per protezione in scrittura">
	msg	ExtErr20,<"Unit non valida">
	msg	ExtErr21,<"Non pronto">
	msg	ExtErr22,<"Richiesta di periferica non valida">
	msg	ExtErr23,<"Errore di dati">
	msg	ExtErr24,<"Parametri di richiesta di periferica non valida">
	msg	ExtErr25,<"Errore di ricerca">
	msg	ExtErr26,<"Tipo di supporto non valido">
	msg	ExtErr27,<"Impossibile trovare il settore">
	msg	ExtErr28,<"Carta esaurita nella stampante">
	msg	ExtErr29,<"Errore di scrittura">
	msg	ExtErr30,<"Errore di lettura">
	msg	ExtErr31,<"Errore generale">
	msg	ExtErr32,<"Violazione di condivisione">
	msg	ExtErr33,<"Violazione di blocco">
	msg	ExtErr34,<"Sostituzione del disco non valida">
	msg	ExtErr35,<"FCB non disponibile">
	msg	ExtErr36,<"Risorse di sistema esaurite">
	msg	ExtErr37,<"Tabella codici non corrispondente">
	msg	ExtErr38,<"Input esaurito">
	msg	ExtErr39,<"Spazio su disco insufficiente">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"Troppi parametri">
	msg	ParsErr02,<"Parametro richiesto mancante">
	msg	ParsErr03,<"Opzione non valida">
	msg	ParsErr04,<"Parola chiave non valida">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Valore del parametro fuori dall'intervallo permesso">
	msg	ParsErr07,<"Valore del parametro non valido">
	msg	ParsErr08,<"Valore del parametro non valido">
	msg	ParsErr09,<"Formato del parametro non corretto">
	msg	ParsErr10,<"Parametro non valido">
	msg	ParsErr11,<"Combinazione di parametri non valida">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Funzione non valida">
	msg	ExtErr02,<"Impossibile trovare il file">
	msg	ExtErr03,<"Impossibile trovare il percorso">
	msg	ExtErr04,<"Troppi file aperti">
	msg	ExtErr05,<"Accesso negato ">
	msg	ExtErr06,<"Handle non valido">
	msg	ExtErr07,<"Blocchi di controllo di memoria danneggiati">
	msg	ExtErr08,<"Memoria insufficiente">
	msg	ExtErr09,<"Indirizzo di blocco di memoria non valido">
	msg	ExtErr10,<"Ambiente non valido">
	msg	ExtErr11,<"Formato non valido">
	msg	ExtErr12,<"Parametro di funzione non valido">
	msg	ExtErr13,<"Dato non valido">

	msg	ExtErr15,<"Specifica di unit non valida">
	msg	ExtErr16,<"Tentativo di rimuovere la directory corrente">
	msg	ExtErr17,<"Diversa periferica">
	msg	ExtErr18,<"File esauriti">

	msg	ExtErr80,<"Il file esiste">

	msg	ExtErr82,<"Impossibile creare la voce di directory">
	msg	ExtErr83,<"Errore su INT 24">
	msg	ExtErr84,<"Troppe redirezioni">
	msg	ExtErr85,<"Redirezione duplicata">
	msg	ExtErr86,<"Password non valida">
	msg	ExtErr87,<"Parametro non valido">
	msg	ExtErr88,<"Errore nei dati di rete">
	msg	ExtErr89,<"Funzione non supportata dalla rete">
	msg	ExtErr90,<"Componente di sistema richiesto non installato">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\hu\comrmsg.inc ===
;***        Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "K"
Retry_Char      db      "I"
Ignore_Char     db      "M"
Fail_Char       db      "M"
Yes_Char        db      "I"
No_Char         db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

        msg     Req_Abort, <"Kilps">
        msg     Req_Retry, <", Ismt">
        msg     Req_Ignore,<", Mgse">
        msg     Req_Fail,  <", Mgse">
        msg     Req_End,   <"?">
        msg     MRead,     <"olvass",0>
        msg     MWrite,    <"rs",0>
        msg     BlkDevErr, <" %1 meghajt %2",CR,LF>
        msg     CharDevErr,<" %1 meghajt %2",CR,LF>
        msg     NeedVolMsg,<"Helyezze be a %1 cmkj, %2-%3 sorozatszm lemezt ",CR,LF>
        msg     BadFatMsg, <"A(z) %1 meghajtban lv lemez FAT tblja hibs. ",CR,LF>
        msg     ComBad,    <"A COMMAND.COM fjl srlt. ",CR,LF>
        msg     PutBackMsg,<"Helyezze be a(z) %1 fjlt tartalmaz lemezt a(z) %2 meghajtba. ",CR,LF>
        msg     Prompt,    <"A folytatshoz nyomjon meg egy billentyt . . .",CR,LF>
        msg     EndBatMes, <CR,LF, "Befejezi a parancsfjl feldolgozst (I/N)?">
        msg     ExecEMes,  <"A kvetkez programot nem lehet futtatni: %1",CR,LF>
        msg     ExeBad,    <"Az EXE fjl formtuma hibs. ",CR,LF>
        msg     TooBig,    <"A program nem fr el a memriban. ",CR,LF>
        msg     NoHandMes, <CR,LF, "Nincs tbb szabad fjller. ">
        msg     RBadNam,   <"Rossz parancs vagy fjlnv. ",CR,LF>
        msg     AccDen,    <"A hozzfrs megtagadva. ">
        msg     BMemMes,   <CR,LF, "Memriafoglalsi hiba. ">
        msg     HaltMes,   <CR,LF,"A COMMAND.COM nem tlthet be, a rendszer lellt. ",CR,LF>
        msg     FRetMes,   <CR,LF,"A COMMAND.COM nem tlthet be, kilps. ",CR,LF>
        msg     Patricide, <CR,LF,"A fels szint folyamat megszakadt, a vgrehajts nem folytathat. ",CR,LF> 
        msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
        dw      DATARES:ExtMsgPtrs,1    ; extended error messages
        dw      DATARES:ParsMsgPtrs,1   ; parse error messages
        dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
                                        ;  use extended error list
        dw      0,0                     ; file system error messages - none
        dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

        msg     ExtErr19,<"rsvdelmi hiba">
        msg     ExtErr20,<"rvnytelen egysg">
        msg     ExtErr21,<"Nincs ksz">
        msg     ExtErr22,<"rvnytelen eszkzignyls">
        msg     ExtErr23,<"Adathiba">
        msg     ExtErr24,<" rvnytelen eszkzignylsi paramterek">
        msg     ExtErr25,<"r/olvas fej pozcionlsi hiba">
        msg     ExtErr26,<"rvnytelen adathordoz-tpus">
        msg     ExtErr27,<"A szektor nem tallhat">
        msg     ExtErr28,<"A nyomtatbl kifogyott a papr">
        msg     ExtErr29,<"rsi hiba">
        msg     ExtErr30,<"Olvassi hiba">
        msg     ExtErr31,<"Meghatrozatlan hiba">
        msg     ExtErr32,<"Megoszts megsrtse">
        msg     ExtErr33,<"Zrols megsrtse">
        msg     ExtErr34,<"rvnytelen lemezcsere">
        msg     ExtErr35,<"Az FCB nem rhet el">
        msg     ExtErr36,<"A rendszer erforrsi elfogytak">
        msg     ExtErr37,<"Nem egyez kdlap">
        msg     ExtErr38,<"Nincs tbb bemen adat">
        msg     ExtErr39,<"Nincs elg hely a lemezen">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
        dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
        dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
        dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
        dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

        msg     ParsErr01,<"Tl sok paramter">
        msg     ParsErr02,<"Hinyz ktelez paramter">
        msg     ParsErr03,<"rvnytelen kapcsol">
        msg     ParsErr04,<"rvnytelen kulcssz">
        msg     ParsErr05,<" ">
        msg     ParsErr06,<"A paramter rtke kiesik a megengedett tartomnybl">
        msg     ParsErr07,<"Nem megengedett paramter rtk">
        msg     ParsErr08,<"Nem megengedett paramter rtk ">
        msg     ParsErr09,<"Hibs paramterformtum">
        msg     ParsErr10,<"Hibs paramter">
        msg     ParsErr11,<"Nem megengedett paramter kombinci">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
        dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
        dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
        dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
        dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

        msg     ExtErr01,<"rvnytelen fggvny">
        msg     ExtErr02,<"A fjl nem tallhat">
        msg     ExtErr03,<"Az elrsi t nem tallhat">
        msg     ExtErr04,<"Tl sok fjl van nyitva">
        msg     ExtErr05,<"A hozzfrs megtagadva ">
        msg     ExtErr06,<"rvnytelen ler">
        msg     ExtErr07,<"A memriavezrl blokkok megsrltek">
        msg     ExtErr08,<"Nincs elg memria">
        msg     ExtErr09,<"A memriavezrl blokk cme rvnytelen">
        msg     ExtErr10,<"rvnytelen krnyezet">
        msg     ExtErr11,<"rvnytelen formtum">
        msg     ExtErr12,<"rvnytelen fggvny paramter">
        msg     ExtErr13,<"rvnytelen adat">

        msg     ExtErr15,<"rvnytelen meghajt">
        msg     ExtErr16,<"Az aktulis knyvtr nem trlhet">
        msg     ExtErr17,<"Nem ugyanaz az eszkz">
        msg     ExtErr18,<"Nincs tbb fjl">

        msg     ExtErr80,<"A fjl mr ltezik">

        msg     ExtErr82,<"A knyvtr-bejegyzs nem hozhat ltre">
        msg     ExtErr83,<"Hiba az INT 24 rendszerhvsban">
        msg     ExtErr84,<"Tl sok tirnyts">
        msg     ExtErr85,<"Ktszeres tirnyts">
        msg     ExtErr86,<"rvnytelen jelsz">
        msg     ExtErr87,<"rvnytelen paramter">
        msg     ExtErr88,<"Hibs adatok rkeztek a hlzatrl">
        msg     ExtErr89,<"A hlzat nem tmogatja ezt a funkcit">
        msg     ExtErr90,<"A szksges rendszerkomponens nincs teleptve">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.  
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
        dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
        dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
        dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
        dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
        dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
        dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
        dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
        dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
        dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
        dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
        dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
        dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
        dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
        dw      80-40 dup (0) ; null ptrs for errors 40-79
        dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
        dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
        dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
        dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
                                ; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\kor\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

ifdef BILINGUAL
	msg	BadVerMsg,   <"DOS  Ʋϴ.",CR,LF,0,"Incorrect DOS version",CR,LF>
	msg	OutEnvMsg,   <"ȯ  մϴ.",CR,LF,0,"Out of environment space",CR,LF>
ifndef ROMDOS
        msg     CopyrightMsg,<CR,LF,"Microsoft(R) Windows DOS",CR,LF,\
"             (C)Copyright Microsoft Corp 1990-2001.  ",CR,LF,0,"Microsoft(R) Windows DOS",CR,LF,\
"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
else
        msg     CopyrightMsg,<CR,LF,CR,LF,"Microsoft(R) MS-DOS(R) ROM  5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.  ",CR,LF,0,CR,LF,CR,LF,"Microsoft(R) MS-DOS(R) ROM Version 5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.",CR,LF>
endif
	msg	BadComLkMsg, <" COMMAND ã 丮 ùٸ ʽϴ.",CR,LF,0,"Specified COMMAND search directory bad",CR,LF>
	msg	BadComAccMsg,<" COMMAND ã 丮  ׼ źεǾϴ.",CR,LF,0,"Specified COMMAND search directory bad access denied",CR,LF>

	msg	Help1Msg  <"MS-DOS ɾ ͸  մϴ.",CR,LF,CR,LF,0,"Starts a new instance of the MS-DOS command interpreter.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[̺:] [̽] [/E:nnnnn] [/P] [/C ڿ] [/MSG]",CR,LF,CR,LF,0,"COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [̺:]   COMMAND.COM  ִ 丮 մϴ.",CR,LF,0,"  [drive:]path    Specifies the directory containing COMMAND.COM file.",CR,LF>
        msg     Help4Msg  <"  ̽          ɾ ¿  ̽ մϴ.",CR,LF,0,"  device          Specifies the device to use for command input and output.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn          ʱ ȯ ũ⸦ nnnnn Ʈ մϴ.",CR,LF,0,"  /E:nnnnn        Sets the initial environment size to nnnnn bytes.",CR,LF>
	msg	Help6Msg  <"  /P                 ɾ ͸  ϴ. ( )",CR,LF,0,"  /P              Makes the new command interpreter permanent (can't exit).",CR,LF>
	msg	Help7Msg  <"  /C ڿ         ڿ  ɾ ϰ ϴ.",CR,LF,0,"  /C string       Carries out the command specified by string, and then stops.",CR,LF>
	msg	Help8Msg  <"  /MSG                ޽ ޸𸮿 ϵ մϴ.",CR,LF,0,"  /MSG            Specifies that all error messages be stored in memory. You",CR,LF>
	msg	Help9Msg  <"                     ġ/P Բ ؾ մϴ.",CR,LF,0,"                  need to specify /P with this switch.",CR,LF>
else
	msg	BadVerMsg,   <"DOS  Ʋϴ.",CR,LF>
	msg	OutEnvMsg,   <"ȯ  մϴ.",CR,LF>
        msg     CopyrightMsg,<CR,LF,CR,LF,"Microsoft(R) MS-DOS(R)  5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.  ",CR,LF>
	msg	BadComLkMsg, <" COMMAND ã 丮 ùٸ ʽϴ.",CR,LF>
	msg	BadComAccMsg,<" COMMAND ã 丮  ׼ źεǾϴ.",CR,LF>

	msg	Help1Msg  <"MS-DOS ɾ ͸  մϴ.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[̺:] [̽] [/E:nnnnn] [/P] [/C ڿ] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [̺:]   COMMAND.COM  ִ 丮 մϴ.",CR,LF>
        msg     Help4Msg  <"  ̽          ɾ ¿  ̽ մϴ.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn          ʱ ȯ ũ⸦ nnnnn Ʈ մϴ.",CR,LF>
	msg	Help6Msg  <"  /P                 ɾ ͸  ϴ. ( )",CR,LF>
	msg	Help7Msg  <"  /C ڿ         ڿ  ɾ ϰ ϴ.",CR,LF>
	msg	Help8Msg  <"  /MSG                ޽ ޸𸮿 ϵ մϴ.  ġ",CR,LF>
	msg	Help9Msg  <"                    /P Բ ؾ մϴ.",CR,LF>
endif


HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
                dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\jpn\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

ifdef BILINGUAL
	msg	BadVerMsg,   <"DOS ̃o[WႢ܂.",CR,LF,0,"Incorrect DOS version",CR,LF>
	msg	OutEnvMsg,   <"ϐ̂߂̃܂.",CR,LF,0,"Out of environment space",CR,LF>
ifndef ROMDOS
        msg     CopyrightMsg,<CR,LF,"Microsoft(R) Windows DOS",CR,LF,\
"             (C)Copyright Microsoft Corp 1990-2001.  ",CR,LF,0,"Microsoft(R) Windows DOS",CR,LF,\
"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
else
        msg     CopyrightMsg,<CR,LF,CR,LF,"Microsoft(R) MS-DOS(R) ROM ްޮ 5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.  ",CR,LF,0,CR,LF,CR,LF,"Microsoft(R) MS-DOS(R) ROM Version 5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.",CR,LF>
endif
	msg	BadComLkMsg, <"w肳ꂽR}hfBNgႢ܂.",CR,LF,0,"Specified COMMAND search directory bad",CR,LF>
	msg	BadComAccMsg,<"w肳ꂽR}hfBNgɃANZXł܂.",CR,LF,0,"Specified COMMAND search directory bad access denied",CR,LF>

	msg	Help1Msg  <"MS-DOSR}hC^v^VN܂.",CR,LF,CR,LF,0,"Starts a new instance of the MS-DOS command interpreter.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[ײ:]߽] [޲] [/E:nnnnn] [/P] [/C ] [/MSG]",CR,LF,CR,LF,0,"COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [ײ:]߽   COMMAND.COMt@ĈfBNgw肵܂.",CR,LF,0,"  [drive:]path    Specifies the directory containing COMMAND.COM file.",CR,LF>
        msg     Help4Msg  <"  ޲         R}ho͂̂߂ɎgpfoCXw肵܂.",CR,LF,0,"  device          Specifies the device to use for command input and output.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn       ϐ̃TCY̏lƂ nnnnn oCgݒ肵܂.",CR,LF,0,"  /E:nnnnn        Sets the initial environment size to nnnnn bytes.",CR,LF>
	msg	Help6Msg  <"  /P             VȃR}hC^v^풓܂. (A܂)",CR,LF,0,"  /P              Makes the new command interpreter permanent (can't exit).",CR,LF>
	msg	Help7Msg  <"  /C       Ŏw肵R}h̎s, A܂.",CR,LF,0,"  /C string       Carries out the command specified by string, and then stops.",CR,LF>
	msg	Help8Msg  <"  /MSG           SG[bZ[Wɕێ܂. ̃XCb`",CR,LF,0,"  /MSG            Specifies that all error messages be stored in memory. You",CR,LF>
	msg	Help9Msg  <"                 /P XCb`ƓɎw肵Ȃ΂Ȃ܂.",CR,LF,0,"                  need to specify /P with this switch.",CR,LF>
else
	msg	BadVerMsg,   <"DOS ̃o[WႢ܂.",CR,LF>
	msg	OutEnvMsg,   <"ϐ̂߂̃܂.",CR,LF>
        msg     CopyrightMsg,<CR,LF,CR,LF,"Microsoft(R) MS-DOS(R) ްޮ 5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.  ",CR,LF>
	msg	BadComLkMsg, <"w肳ꂽR}hfBNgႢ܂.",CR,LF>
	msg	BadComAccMsg,<"w肳ꂽR}hfBNgɃANZXł܂.",CR,LF>

	msg	Help1Msg  <"MS-DOS R}hC^v^VN܂.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[ײ:]߽] [޲] [/E:nnnnn] [/P] [/C ] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [ײ:]߽   COMMAND.COM t@ĈfBNgw肵܂.",CR,LF>
        msg     Help4Msg  <"  ޲         R}ho͂̂߂ɎgpfoCXw肵܂.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn       ϐ̃TCY̏lƂ nnnnn oCgݒ肵܂.",CR,LF>
	msg	Help6Msg  <"  /P             VȃR}hC^v^풓܂. (A܂)",CR,LF>
	msg	Help7Msg  <"  /C       Ŏw肵R}h̎s, A܂.",CR,LF>
	msg	Help8Msg  <"  /MSG           SG[bZ[Wɕێ܂. ̃XCb`",CR,LF>
	msg	Help9Msg  <"                 /P XCb`ƓɎw肵Ȃ΂Ȃ܂.",CR,LF>
endif


HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
                dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\jpn\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

ifdef BILINGUAL
	msg	Req_Abort, <"~<A>",0,"Abort">
	msg	Req_Retry, <", x<R>",0,", Retry">
	msg	Req_Ignore,<", <I>",0,", Ignore">
	msg	Req_Fail,  <", s<F>",0,", Fail">
	msg	Req_End,   <"?",0,"?">
	msg	MRead,	   <"ǂݎ蒆",0,"reading",0>
	msg	MWrite,	   <"ݒ",0,"writing",0>
	msg	BlkDevErr, <" %1 hCu %2",CR,LF,0," %1 drive %2",CR,LF>
	msg	CharDevErr,<" %1 foCX %2",CR,LF,0," %1 device %2",CR,LF>
	msg	NeedVolMsg,<"{[ %1 VA %2-%3 ̃fBXN}Ă.",CR,LF,0,"Please insert volume %1 serial %2-%3",CR,LF>
	msg	BadFatMsg, <"t@CAP[Ve[usǂł. hCu %1",CR,LF,0,"File allocation table bad, drive %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM Ⴂ܂.",CR,LF,0,"Invalid COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"%1 ̃fBXNhCu %2 ɓĂ.",CR,LF,0,"Insert disk with %1 in drive %2",CR,LF>
	msg	Prompt,	   <"ǂꂩL[đĂ . . .",CR,LF,0,"Press any key to continue . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"ob`t@CI܂ <Y/N>?",0,CR,LF,"Terminate batch job (Y/N)?">
	msg	ExecEMes,  <"%1 ͎sł܂.",CR,LF,0,"Cannot execute %1",CR,LF>
	msg	ExeBad,	   <".EXEt@C̃G[ł.",CR,LF,0,"Error in EXE file",CR,LF>
	msg	TooBig,	   <"vO傫ăɓ܂.",CR,LF,0,"Program too big to fit in memory",CR,LF>
	msg	NoHandMes, <CR,LF,"󂢂Ăt@Cnh͂܂.",0,CR,LF,"No free file handles">
	msg	RBadNam,   <"R}h܂̓t@CႢ܂.",CR,LF,0,"Bad Command or file name",CR,LF>
	msg	AccDen,	   <"ANZX͋ۂ܂. ",0,"Access denied ">
	msg	BMemMes,   <CR,LF,"AP[VG[ł.",0,CR,LF,"Memory allocation error">
	msg	HaltMes,   <CR,LF,"COMMAND [hł܂. ZbgĂ.",CR,LF,0,CR,LF,"Cannot load COMMAND, system halted",CR,LF>
	msg	FRetMes,   <CR,LF,"COMMAND Nł܂. A܂.",CR,LF,0,CR,LF,"Cannot start COMMAND, exiting",CR,LF>
	msg	Patricide, <CR,LF,"gbvx̏~܂. sł܂.",CR,LF,0,CR,LF,"Top level process aborted, cannot continue",CR,LF> 
	msg	Newlin,	   <CR,LF,0,CR,LF>
else
	msg	Req_Abort, <"~<A>">
	msg	Req_Retry, <", x<R>">
	msg	Req_Ignore,<", <I>">
	msg	Req_Fail,  <", s<F>">
	msg	Req_End,   <"?">
	msg	MRead,	   <"ǂݎ蒆",0>
	msg	MWrite,	   <"ݒ",0>
	msg	BlkDevErr, <" %1 hCu %2",CR,LF>
	msg	CharDevErr,<" %1 foCX %2",CR,LF>
	msg	NeedVolMsg,<"{[ %1 VA %2-%3 ̃fBXN}Ă.",CR,LF>
	msg	BadFatMsg, <"t@CAP[Ve[usǂł. hCu %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM Ⴂ܂.",CR,LF>
	msg	PutBackMsg,<"%1 ̃fBXNhCu %2 ɓĂ.",CR,LF>
	msg	Prompt,	   <"ǂꂩL[đĂ . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"ob`t@CI܂ <Y/N>?">
	msg	ExecEMes,  <"%1 ͎sł܂.",CR,LF>
	msg	ExeBad,	   <"EXE t@C̃G[ł.",CR,LF>
	msg	TooBig,	   <"vO傫ăɓ܂.",CR,LF>
	msg	NoHandMes, <CR,LF,"󂢂Ăt@Cnh͂܂.">
	msg	RBadNam,   <"R}h܂̓t@CႢ܂.",CR,LF>
	msg	AccDen,	   <"ANZX͋ۂ܂. ">
	msg	BMemMes,   <CR,LF,"AP[VG[ł.">
	msg	HaltMes,   <CR,LF,"COMMAND [hł܂. ZbgĂ.",CR,LF>
	msg	FRetMes,   <CR,LF,"COMMAND Nł܂. A܂.",CR,LF>
	msg	Patricide, <CR,LF,"gbvx̏~܂. sł܂.",CR,LF> 
	msg	Newlin,	   <CR,LF>
endif


;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

ifdef BILINGUAL
	msg	ExtErr19,<"݋֎~ł.">
	msg	ExtErr20,<"ȃjbgł.">
	msg	ExtErr21,<"łĂ܂.">
	msg	ExtErr22,<"foCX̗vႢ܂.">
	msg	ExtErr23,<"f[^G[ł.">
	msg	ExtErr24,<"foCX̗vp[^Ⴂ܂.">
	msg	ExtErr25,<"V[NG[ł.">
	msg	ExtErr26,<"̃fBXN͎g܂.">
	msg	ExtErr27,<"ZN^܂.">
	msg	ExtErr28,<"p܂.">
	msg	ExtErr29,<"݂ł܂.">
	msg	ExtErr30,<"ǂݍ݂ł܂.">
	msg	ExtErr31,<"G[ł.">
	msg	ExtErr32,<"Lᔽł.">
	msg	ExtErr33,<"bNᔽł.">
	msg	ExtErr34,<"fBXN͌ł܂.">
	msg	ExtErr35,<"FCB g܂.">
	msg	ExtErr36,<"VXe\[Xςł.">
	msg	ExtErr37,<"R[hy[Wv܂.">
	msg	ExtErr38,<"͂I܂.">
	msg	ExtErr39,<"fBXNςł.">
	msg	ExtErr8019,<"Write protect error">
	msg	ExtErr8020,<"Invalid unit">
	msg	ExtErr8021,<"Not ready">
	msg	ExtErr8022,<"Invalid device request">
	msg	ExtErr8023,<"Data error">
	msg	ExtErr8024,<"Invalid device request parameters">
	msg	ExtErr8025,<"Seek error">
	msg	ExtErr8026,<"Invalid media type">
	msg	ExtErr8027,<"Sector not found">
	msg	ExtErr8028,<"Printer out of paper error">
	msg	ExtErr8029,<"Write fault error">
	msg	ExtErr8030,<"Read fault error">
	msg	ExtErr8031,<"General failure">
	msg	ExtErr8032,<"Sharing violation">
	msg	ExtErr8033,<"Lock violation">
	msg	ExtErr8034,<"Invalid disk change">
	msg	ExtErr8035,<"FCB unavailable">
	msg	ExtErr8036,<"System resource exhausted">
	msg	ExtErr8037,<"Code page mismatch">
	msg	ExtErr8038,<"Out of input">
	msg	ExtErr8039,<"Insufficient disk space">
else
	msg	ExtErr19,<"݋֎~ł.">
	msg	ExtErr20,<"ȃjbgł.">
	msg	ExtErr21,<"łĂ܂.">
	msg	ExtErr22,<"foCX̗vႢ܂.">
	msg	ExtErr23,<"f[^G[ł.">
	msg	ExtErr24,<"foCX̗vp[^Ⴂ܂.">
	msg	ExtErr25,<"V[NG[ł.">
	msg	ExtErr26,<"̃fBXN͎g܂.">
	msg	ExtErr27,<"ZN^܂.">
	msg	ExtErr28,<"p܂.">
	msg	ExtErr29,<"݂ł܂.">
	msg	ExtErr30,<"ǂݍ݂ł܂.">
	msg	ExtErr31,<"G[ł.">
	msg	ExtErr32,<"Lᔽł.">
	msg	ExtErr33,<"bNᔽł.">
	msg	ExtErr34,<"fBXN͌ł܂.">
	msg	ExtErr35,<"FCB g܂.">
	msg	ExtErr36,<"VXe\[Xςł.">
	msg	ExtErr37,<"R[hy[Wv܂.">
	msg	ExtErr38,<"͂I܂.">
	msg	ExtErr39,<"fBXNςł.">
endif

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	DATARES:ExtErr8019,DATARES:ExtErr8020,DATARES:ExtErr8021,DATARES:ExtErr8022,DATARES:ExtErr8023,DATARES:ExtErr8024
	dw	DATARES:ExtErr8025,DATARES:ExtErr8026,DATARES:ExtErr8027,DATARES:ExtErr8028,DATARES:ExtErr8029,DATARES:ExtErr8030
	dw	DATARES:ExtErr8031,DATARES:ExtErr8032,DATARES:ExtErr8033,DATARES:ExtErr8034,DATARES:ExtErr8035,DATARES:ExtErr8036
	dw	DATARES:ExtErr8037,DATARES:ExtErr8038,DATARES:ExtErr8039
else
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
endif

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

ifdef BILINGUAL
	msg	ParsErr01,<"p[^܂.">
	msg	ParsErr02,<"p[^܂.">
	msg	ParsErr03,<"XCb`Ⴂ܂.">
	msg	ParsErr04,<"L[[hႢ܂.">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"p[^͈͂ł͂܂.">
	msg	ParsErr07,<"ȃp[^ł.">
	msg	ParsErr08,<"ȃp[^ł.">
	msg	ParsErr09,<"p[^̃tH[}bgႢ܂.">
	msg	ParsErr10,<"p[^Ⴂ܂.">
	msg	ParsErr11,<"p[^̑gݍ킹Ⴂ܂.">
	msg	ParsErr8001,<"Too many parameters">
	msg	ParsErr8002,<"Required parameter missing">
	msg	ParsErr8003,<"Invalid switch">
	msg	ParsErr8004,<"Invalid keyword">
	msg	ParsErr8005,<" ">
	msg	ParsErr8006,<"Parameter value not in allowed range">
	msg	ParsErr8007,<"Parameter value not allowed">
	msg	ParsErr8008,<"Parameter value not allowed">
	msg	ParsErr8009,<"Parameter format not correct">
	msg	ParsErr8010,<"Invalid parameter">
	msg	ParsErr8011,<"Invalid parameter combination">
else
	msg	ParsErr01,<"p[^܂.">
	msg	ParsErr02,<"p[^܂.">
	msg	ParsErr03,<"XCb`Ⴂ܂.">
	msg	ParsErr04,<"L[[hႢ܂.">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"p[^͈͂ł͂܂.">
	msg	ParsErr07,<"ȃp[^ł.">
	msg	ParsErr08,<"ȃp[^ł.">
	msg	ParsErr09,<"p[^̃tH[}bgႢ܂.">
	msg	ParsErr10,<"p[^Ⴂ܂.">
	msg	ParsErr11,<"p[^̑gݍ킹Ⴂ܂.">
endif

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11
	dw	DATARES:ParsErr8001,DATARES:ParsErr8002,DATARES:ParsErr8003
	dw	DATARES:ParsErr8004,DATARES:ParsErr8005,DATARES:ParsErr8006
	dw	DATARES:ParsErr8007,DATARES:ParsErr8008,DATARES:ParsErr8009
	dw	DATARES:ParsErr8010,DATARES:ParsErr8011
else
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11
endif

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

ifdef BILINGUAL
	msg	ExtErr01,<"ȋ@\ł.">
	msg	ExtErr02,<"t@C܂.">
	msg	ExtErr03,<"pX܂.">
	msg	ExtErr04,<"I[vĂt@C܂.">
	msg	ExtErr05,<"ANZX͋ۂ܂.">
	msg	ExtErr06,<"nhł.">
	msg	ExtErr07,<"ubNj󂳂܂.">
	msg	ExtErr08,<"܂.">
	msg	ExtErr09,<"ubNAhX܂.">
	msg	ExtErr10,<"܂.">
	msg	ExtErr11,<"tH[}bg܂.">
	msg	ExtErr12,<"t@NVp[^܂.">
	msg	ExtErr13,<"f[^܂.">

	msg	ExtErr15,<"hCu̎w肪Ⴂ܂.">
	msg	ExtErr16,<"JgfBNg폜悤Ƃ܂.">
	msg	ExtErr17,<"foCXł͂܂.">
	msg	ExtErr18,<"t@Cȏ゠܂.">

	msg	ExtErr80,<"t@C݂͑܂.">

	msg	ExtErr82,<"fBNgGg쐬ł܂.">
	msg	ExtErr83,<"INT 24H Ɏs܂.">
	msg	ExtErr84,<"_CNg܂.">
	msg	ExtErr85,<"d`ł.">
	msg	ExtErr86,<"pX[hႢ܂.">
	msg	ExtErr87,<"p[^̎w肪Ⴂ܂.">
	msg	ExtErr88,<"lbg[Nւ݂̏Ɏs܂.">
	msg	ExtErr89,<"t@NV̓lbg[Nł̓T|[gĂ܂.">
	msg	ExtErr90,<"KvȃVXeR|[lg[hĂ܂.">

	msg	ExtErr8001,<"Invalid function">
	msg	ExtErr8002,<"File not found">
	msg	ExtErr8003,<"Path not found">
	msg	ExtErr8004,<"Too many open files">
	msg	ExtErr8005,<"Access denied ">
	msg	ExtErr8006,<"Invalid handle">
	msg	ExtErr8007,<"Memory control blocks destroyed">
	msg	ExtErr8008,<"Insufficient memory">
	msg	ExtErr8009,<"Invalid memory block address">
	msg	ExtErr8010,<"Invalid Environment">
	msg	ExtErr8011,<"Invalid format">
	msg	ExtErr8012,<"Invalid function parameter">
	msg	ExtErr8013,<"Invalid data">

	msg	ExtErr8015,<"Invalid drive specification">
	msg	ExtErr8016,<"Attempt to remove current directory">
	msg	ExtErr8017,<"Not same device">
	msg	ExtErr8018,<"No more files">

	msg	ExtErr8080,<"File exists">

	msg	ExtErr8082,<"Cannot make directory entry">
	msg	ExtErr8083,<"Fail on INT 24">
	msg	ExtErr8084,<"Too many redirections">
	msg	ExtErr8085,<"Duplicate redirection">
	msg	ExtErr8086,<"Invalid password">
	msg	ExtErr8087,<"Invalid parameter">
	msg	ExtErr8088,<"Network data fault">
	msg	ExtErr8089,<"Function not supported by network">
	msg	ExtErr8090,<"Required system component not installed">

else
	msg	ExtErr01,<"ȋ@\ł.">
	msg	ExtErr02,<"t@C܂.">
	msg	ExtErr03,<"pX܂.">
	msg	ExtErr04,<"I[vĂt@C܂.">
	msg	ExtErr05,<"ANZX͋ۂ܂.">
	msg	ExtErr06,<"nhł.">
	msg	ExtErr07,<"ubNj󂳂܂.">
	msg	ExtErr08,<"܂.">
	msg	ExtErr09,<"ubNAhX܂.">
	msg	ExtErr10,<"܂.">
	msg	ExtErr11,<"tH[}bg܂.">
	msg	ExtErr12,<"t@NVp[^܂.">
	msg	ExtErr13,<"f[^܂.">

	msg	ExtErr15,<"hCu̎w肪Ⴂ܂.">
	msg	ExtErr16,<"JgfBNg폜悤Ƃ܂.">
	msg	ExtErr17,<"foCXł͂܂.">
	msg	ExtErr18,<"t@Cȏ゠܂.">

	msg	ExtErr80,<"t@C݂͑܂.">

	msg	ExtErr82,<"fBNgGg쐬ł܂.">
	msg	ExtErr83,<"INT 24H Ɏs܂.">
	msg	ExtErr84,<"_CNg܂.">
	msg	ExtErr85,<"d`ł.">
	msg	ExtErr86,<"pX[hႢ܂.">
	msg	ExtErr87,<"p[^̎w肪Ⴂ܂.">
	msg	ExtErr88,<"lbg[Nւ݂̏Ɏs܂.">
	msg	ExtErr89,<"t@NV̓lbg[Nł̓T|[gĂ܂.">
	msg	ExtErr90,<"KvȃVXeR|[lg[hĂ܂.">
endif

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
	dw	DATARES:ExtErr8001,DATARES:ExtErr8002,DATARES:ExtErr8003
	dw	DATARES:ExtErr8004,DATARES:ExtErr8005,DATARES:ExtErr8006
	dw	DATARES:ExtErr8007,DATARES:ExtErr8008,DATARES:ExtErr8009
	dw	DATARES:ExtErr8010,DATARES:ExtErr8011,DATARES:ExtErr8012
	dw	DATARES:ExtErr8013,0,                DATARES:ExtErr8015
	dw	DATARES:ExtErr8016,DATARES:ExtErr8017,DATARES:ExtErr8018
	dw	DATARES:ExtErr8019,DATARES:ExtErr8020,DATARES:ExtErr8021
	dw	DATARES:ExtErr8022,DATARES:ExtErr8023,DATARES:ExtErr8024
	dw	DATARES:ExtErr8025,DATARES:ExtErr8026,DATARES:ExtErr8027
	dw	DATARES:ExtErr8028,DATARES:ExtErr8029,DATARES:ExtErr8030
	dw	DATARES:ExtErr8031,DATARES:ExtErr8032,DATARES:ExtErr8033
	dw	DATARES:ExtErr8034,DATARES:ExtErr8035,DATARES:ExtErr8036
	dw	DATARES:ExtErr8037,DATARES:ExtErr8038,DATARES:ExtErr8039
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr8080,0,                DATARES:ExtErr8082
	dw	DATARES:ExtErr8083,DATARES:ExtErr8084,DATARES:ExtErr8085
	dw	DATARES:ExtErr8086,DATARES:ExtErr8087,DATARES:ExtErr8088
	dw	DATARES:ExtErr8089,DATARES:ExtErr8090
else
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
endif
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\nl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\no\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\nec_98\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

ifdef BILINGUAL
	msg	Req_Abort, <"~<A>",0,"Abort">
	msg	Req_Retry, <", x<R>",0,", Retry">
	msg	Req_Ignore,<", <I>",0,", Ignore">
	msg	Req_Fail,  <", s<F>",0,", Fail">
	msg	Req_End,   <"?",0,"?">
	msg	MRead,	   <"ǂݎ蒆",0,"reading",0>
	msg	MWrite,	   <"ݒ",0,"writing",0>
	msg	BlkDevErr, <" %1 hCu %2",CR,LF,0," %1 drive %2",CR,LF>
	msg	CharDevErr,<" %1 foCX %2",CR,LF,0," %1 device %2",CR,LF>
	msg	NeedVolMsg,<"{[ %1 VA %2-%3 ̃fBXN}Ă.",CR,LF,0,"Please insert volume %1 serial %2-%3",CR,LF>
	msg	BadFatMsg, <"t@CAP[Ve[usǂł. hCu %1",CR,LF,0,"File allocation table bad, drive %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM Ⴂ܂.",CR,LF,0,"Invalid COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"%1 ̃fBXNhCu %2 ɓĂ.",CR,LF,0,"Insert disk with %1 in drive %2",CR,LF>
	msg	Prompt,	   <"ǂꂩL[đĂ . . .",CR,LF,0,"Press any key to continue . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"ob`t@CI܂ <Y/N>?",0,CR,LF,"Terminate batch job (Y/N)?">
	msg	ExecEMes,  <"%1 ͎sł܂.",CR,LF,0,"Cannot execute %1",CR,LF>
	msg	ExeBad,	   <".EXEt@C̃G[ł.",CR,LF,0,"Error in EXE file",CR,LF>
	msg	TooBig,	   <"vO傫ăɓ܂.",CR,LF,0,"Program too big to fit in memory",CR,LF>
	msg	NoHandMes, <CR,LF,"󂢂Ăt@Cnh͂܂.",0,CR,LF,"No free file handles">
	msg	RBadNam,   <"R}h܂̓t@CႢ܂.",CR,LF,0,"Bad Command or file name",CR,LF>
	msg	AccDen,	   <"ANZX͋ۂ܂. ",0,"Access denied ">
	msg	BMemMes,   <CR,LF,"AP[VG[ł.",0,CR,LF,"Memory allocation error">
	msg	HaltMes,   <CR,LF,"COMMAND [hł܂. ZbgĂ.",CR,LF,0,CR,LF,"Cannot load COMMAND, system halted",CR,LF>
	msg	FRetMes,   <CR,LF,"COMMAND Nł܂. A܂.",CR,LF,0,CR,LF,"Cannot start COMMAND, exiting",CR,LF>
	msg	Patricide, <CR,LF,"gbvx̏~܂. sł܂.",CR,LF,0,CR,LF,"Top level process aborted, cannot continue",CR,LF> 
	msg	Newlin,	   <CR,LF,0,CR,LF>
else
	msg	Req_Abort, <"~<A>">
	msg	Req_Retry, <", x<R>">
	msg	Req_Ignore,<", <I>">
	msg	Req_Fail,  <", s<F>">
	msg	Req_End,   <"?">
	msg	MRead,	   <"ǂݎ蒆",0>
	msg	MWrite,	   <"ݒ",0>
	msg	BlkDevErr, <" %1 hCu %2",CR,LF>
	msg	CharDevErr,<" %1 foCX %2",CR,LF>
	msg	NeedVolMsg,<"{[ %1 VA %2-%3 ̃fBXN}Ă.",CR,LF>
	msg	BadFatMsg, <"t@CAP[Ve[usǂł. hCu %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM Ⴂ܂.",CR,LF>
	msg	PutBackMsg,<"%1 ̃fBXNhCu %2 ɓĂ.",CR,LF>
	msg	Prompt,	   <"ǂꂩL[đĂ . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"ob`t@CI܂ <Y/N>?">
	msg	ExecEMes,  <"%1 ͎sł܂.",CR,LF>
	msg	ExeBad,	   <"EXE t@C̃G[ł.",CR,LF>
	msg	TooBig,	   <"vO傫ăɓ܂.",CR,LF>
	msg	NoHandMes, <CR,LF,"󂢂Ăt@Cnh͂܂.">
	msg	RBadNam,   <"R}h܂̓t@CႢ܂.",CR,LF>
	msg	AccDen,	   <"ANZX͋ۂ܂. ">
	msg	BMemMes,   <CR,LF,"AP[VG[ł.">
	msg	HaltMes,   <CR,LF,"COMMAND [hł܂. ZbgĂ.",CR,LF>
	msg	FRetMes,   <CR,LF,"COMMAND Nł܂. A܂.",CR,LF>
	msg	Patricide, <CR,LF,"gbvx̏~܂. sł܂.",CR,LF> 
	msg	Newlin,	   <CR,LF>
endif

ifndef NEC_98
else    ;NEC_98
; TSR message for MVDM

	public	tsr_msg

tsr_msg db 'WINDOWS MEMORY-RESIDENT PROGRAM SUPPORT'
        db 0dh,0ah,0dh,0ah
	db 'An MS-DOS TSR has been loaded. You may use it now.',0dh,0ah
	db 'Or press Ctrl+Z to return to the command prompt where the TSR ', 0dh, 0ah
	db 'will be accessible from any MS-DOS program started in this window.'
        db 0dh,0ah,0ah
        db '$'
endif   ;NEC_98

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

ifdef BILINGUAL
	msg	ExtErr19,<"݋֎~ł.">
	msg	ExtErr20,<"ȃjbgł.">
	msg	ExtErr21,<"łĂ܂.">
	msg	ExtErr22,<"foCX̗vႢ܂.">
	msg	ExtErr23,<"f[^G[ł.">
	msg	ExtErr24,<"foCX̗vp[^Ⴂ܂.">
	msg	ExtErr25,<"V[NG[ł.">
	msg	ExtErr26,<"̃fBXN͎g܂.">
	msg	ExtErr27,<"ZN^܂.">
	msg	ExtErr28,<"p܂.">
	msg	ExtErr29,<"݂ł܂.">
	msg	ExtErr30,<"ǂݍ݂ł܂.">
	msg	ExtErr31,<"G[ł.">
	msg	ExtErr32,<"Lᔽł.">
	msg	ExtErr33,<"bNᔽł.">
	msg	ExtErr34,<"fBXN͌ł܂.">
	msg	ExtErr35,<"FCB g܂.">
	msg	ExtErr36,<"VXe\[Xςł.">
	msg	ExtErr37,<"R[hy[Wv܂.">
	msg	ExtErr38,<"͂I܂.">
	msg	ExtErr39,<"fBXNςł.">
	msg	ExtErr8019,<"Write protect error">
	msg	ExtErr8020,<"Invalid unit">
	msg	ExtErr8021,<"Not ready">
	msg	ExtErr8022,<"Invalid device request">
	msg	ExtErr8023,<"Data error">
	msg	ExtErr8024,<"Invalid device request parameters">
	msg	ExtErr8025,<"Seek error">
	msg	ExtErr8026,<"Invalid media type">
	msg	ExtErr8027,<"Sector not found">
	msg	ExtErr8028,<"Printer out of paper error">
	msg	ExtErr8029,<"Write fault error">
	msg	ExtErr8030,<"Read fault error">
	msg	ExtErr8031,<"General failure">
	msg	ExtErr8032,<"Sharing violation">
	msg	ExtErr8033,<"Lock violation">
	msg	ExtErr8034,<"Invalid disk change">
	msg	ExtErr8035,<"FCB unavailable">
	msg	ExtErr8036,<"System resource exhausted">
	msg	ExtErr8037,<"Code page mismatch">
	msg	ExtErr8038,<"Out of input">
	msg	ExtErr8039,<"Insufficient disk space">
else
	msg	ExtErr19,<"݋֎~ł.">
	msg	ExtErr20,<"ȃjbgł.">
	msg	ExtErr21,<"łĂ܂.">
	msg	ExtErr22,<"foCX̗vႢ܂.">
	msg	ExtErr23,<"f[^G[ł.">
	msg	ExtErr24,<"foCX̗vp[^Ⴂ܂.">
	msg	ExtErr25,<"V[NG[ł.">
	msg	ExtErr26,<"̃fBXN͎g܂.">
	msg	ExtErr27,<"ZN^܂.">
	msg	ExtErr28,<"p܂.">
	msg	ExtErr29,<"݂ł܂.">
	msg	ExtErr30,<"ǂݍ݂ł܂.">
	msg	ExtErr31,<"G[ł.">
	msg	ExtErr32,<"Lᔽł.">
	msg	ExtErr33,<"bNᔽł.">
	msg	ExtErr34,<"fBXN͌ł܂.">
	msg	ExtErr35,<"FCB g܂.">
	msg	ExtErr36,<"VXe\[Xςł.">
	msg	ExtErr37,<"R[hy[Wv܂.">
	msg	ExtErr38,<"͂I܂.">
	msg	ExtErr39,<"fBXNςł.">
endif

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	DATARES:ExtErr8019,DATARES:ExtErr8020,DATARES:ExtErr8021,DATARES:ExtErr8022,DATARES:ExtErr8023,DATARES:ExtErr8024
	dw	DATARES:ExtErr8025,DATARES:ExtErr8026,DATARES:ExtErr8027,DATARES:ExtErr8028,DATARES:ExtErr8029,DATARES:ExtErr8030
	dw	DATARES:ExtErr8031,DATARES:ExtErr8032,DATARES:ExtErr8033,DATARES:ExtErr8034,DATARES:ExtErr8035,DATARES:ExtErr8036
	dw	DATARES:ExtErr8037,DATARES:ExtErr8038,DATARES:ExtErr8039
else
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
endif

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

ifdef BILINGUAL
	msg	ParsErr01,<"p[^܂.">
	msg	ParsErr02,<"p[^܂.">
	msg	ParsErr03,<"XCb`Ⴂ܂.">
	msg	ParsErr04,<"L[[hႢ܂.">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"p[^͈͂ł͂܂.">
	msg	ParsErr07,<"ȃp[^ł.">
	msg	ParsErr08,<"ȃp[^ł.">
	msg	ParsErr09,<"p[^̃tH[}bgႢ܂.">
	msg	ParsErr10,<"p[^Ⴂ܂.">
	msg	ParsErr11,<"p[^̑gݍ킹Ⴂ܂.">
	msg	ParsErr8001,<"Too many parameters">
	msg	ParsErr8002,<"Required parameter missing">
	msg	ParsErr8003,<"Invalid switch">
	msg	ParsErr8004,<"Invalid keyword">
	msg	ParsErr8005,<" ">
	msg	ParsErr8006,<"Parameter value not in allowed range">
	msg	ParsErr8007,<"Parameter value not allowed">
	msg	ParsErr8008,<"Parameter value not allowed">
	msg	ParsErr8009,<"Parameter format not correct">
	msg	ParsErr8010,<"Invalid parameter">
	msg	ParsErr8011,<"Invalid parameter combination">
else
	msg	ParsErr01,<"p[^܂.">
	msg	ParsErr02,<"p[^܂.">
	msg	ParsErr03,<"XCb`Ⴂ܂.">
	msg	ParsErr04,<"L[[hႢ܂.">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"p[^͈͂ł͂܂.">
	msg	ParsErr07,<"ȃp[^ł.">
	msg	ParsErr08,<"ȃp[^ł.">
	msg	ParsErr09,<"p[^̃tH[}bgႢ܂.">
	msg	ParsErr10,<"p[^Ⴂ܂.">
	msg	ParsErr11,<"p[^̑gݍ킹Ⴂ܂.">
endif

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11
	dw	DATARES:ParsErr8001,DATARES:ParsErr8002,DATARES:ParsErr8003
	dw	DATARES:ParsErr8004,DATARES:ParsErr8005,DATARES:ParsErr8006
	dw	DATARES:ParsErr8007,DATARES:ParsErr8008,DATARES:ParsErr8009
	dw	DATARES:ParsErr8010,DATARES:ParsErr8011
else
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11
endif

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

ifdef BILINGUAL
	msg	ExtErr01,<"ȋ@\ł.">
	msg	ExtErr02,<"t@C܂.">
	msg	ExtErr03,<"pX܂.">
	msg	ExtErr04,<"I[vĂt@C܂.">
	msg	ExtErr05,<"ANZX͋ۂ܂.">
	msg	ExtErr06,<"nhł.">
	msg	ExtErr07,<"ubNj󂳂܂.">
	msg	ExtErr08,<"܂.">
	msg	ExtErr09,<"ubNAhX܂.">
	msg	ExtErr10,<"܂.">
	msg	ExtErr11,<"tH[}bg܂.">
	msg	ExtErr12,<"t@NVp[^܂.">
	msg	ExtErr13,<"f[^܂.">

	msg	ExtErr15,<"hCu̎w肪Ⴂ܂.">
	msg	ExtErr16,<"JgfBNg폜悤Ƃ܂.">
	msg	ExtErr17,<"foCXł͂܂.">
	msg	ExtErr18,<"t@Cȏ゠܂.">

	msg	ExtErr80,<"t@C݂͑܂.">

	msg	ExtErr82,<"fBNgGg쐬ł܂.">
	msg	ExtErr83,<"INT 24H Ɏs܂.">
	msg	ExtErr84,<"_CNg܂.">
	msg	ExtErr85,<"d`ł.">
	msg	ExtErr86,<"pX[hႢ܂.">
	msg	ExtErr87,<"p[^̎w肪Ⴂ܂.">
	msg	ExtErr88,<"lbg[Nւ݂̏Ɏs܂.">
	msg	ExtErr89,<"t@NV̓lbg[Nł̓T|[gĂ܂.">
	msg	ExtErr90,<"KvȃVXeR|[lg[hĂ܂.">

	msg	ExtErr8001,<"Invalid function">
	msg	ExtErr8002,<"File not found">
	msg	ExtErr8003,<"Path not found">
	msg	ExtErr8004,<"Too many open files">
	msg	ExtErr8005,<"Access denied ">
	msg	ExtErr8006,<"Invalid handle">
	msg	ExtErr8007,<"Memory control blocks destroyed">
	msg	ExtErr8008,<"Insufficient memory">
	msg	ExtErr8009,<"Invalid memory block address">
	msg	ExtErr8010,<"Invalid Environment">
	msg	ExtErr8011,<"Invalid format">
	msg	ExtErr8012,<"Invalid function parameter">
	msg	ExtErr8013,<"Invalid data">

	msg	ExtErr8015,<"Invalid drive specification">
	msg	ExtErr8016,<"Attempt to remove current directory">
	msg	ExtErr8017,<"Not same device">
	msg	ExtErr8018,<"No more files">

	msg	ExtErr8080,<"File exists">

	msg	ExtErr8082,<"Cannot make directory entry">
	msg	ExtErr8083,<"Fail on INT 24">
	msg	ExtErr8084,<"Too many redirections">
	msg	ExtErr8085,<"Duplicate redirection">
	msg	ExtErr8086,<"Invalid password">
	msg	ExtErr8087,<"Invalid parameter">
	msg	ExtErr8088,<"Network data fault">
	msg	ExtErr8089,<"Function not supported by network">
	msg	ExtErr8090,<"Required system component not installed">

else
	msg	ExtErr01,<"ȋ@\ł.">
	msg	ExtErr02,<"t@C܂.">
	msg	ExtErr03,<"pX܂.">
	msg	ExtErr04,<"I[vĂt@C܂.">
	msg	ExtErr05,<"ANZX͋ۂ܂.">
	msg	ExtErr06,<"nhł.">
	msg	ExtErr07,<"ubNj󂳂܂.">
	msg	ExtErr08,<"܂.">
	msg	ExtErr09,<"ubNAhX܂.">
	msg	ExtErr10,<"܂.">
	msg	ExtErr11,<"tH[}bg܂.">
	msg	ExtErr12,<"t@NVp[^܂.">
	msg	ExtErr13,<"f[^܂.">

	msg	ExtErr15,<"hCu̎w肪Ⴂ܂.">
	msg	ExtErr16,<"JgfBNg폜悤Ƃ܂.">
	msg	ExtErr17,<"foCXł͂܂.">
	msg	ExtErr18,<"t@Cȏ゠܂.">

	msg	ExtErr80,<"t@C݂͑܂.">

	msg	ExtErr82,<"fBNgGg쐬ł܂.">
	msg	ExtErr83,<"INT 24H Ɏs܂.">
	msg	ExtErr84,<"_CNg܂.">
	msg	ExtErr85,<"d`ł.">
	msg	ExtErr86,<"pX[hႢ܂.">
	msg	ExtErr87,<"p[^̎w肪Ⴂ܂.">
	msg	ExtErr88,<"lbg[Nւ݂̏Ɏs܂.">
	msg	ExtErr89,<"t@NV̓lbg[Nł̓T|[gĂ܂.">
	msg	ExtErr90,<"KvȃVXeR|[lg[hĂ܂.">
endif

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
	dw	DATARES:ExtErr8001,DATARES:ExtErr8002,DATARES:ExtErr8003
	dw	DATARES:ExtErr8004,DATARES:ExtErr8005,DATARES:ExtErr8006
	dw	DATARES:ExtErr8007,DATARES:ExtErr8008,DATARES:ExtErr8009
	dw	DATARES:ExtErr8010,DATARES:ExtErr8011,DATARES:ExtErr8012
	dw	DATARES:ExtErr8013,0,                DATARES:ExtErr8015
	dw	DATARES:ExtErr8016,DATARES:ExtErr8017,DATARES:ExtErr8018
	dw	DATARES:ExtErr8019,DATARES:ExtErr8020,DATARES:ExtErr8021
	dw	DATARES:ExtErr8022,DATARES:ExtErr8023,DATARES:ExtErr8024
	dw	DATARES:ExtErr8025,DATARES:ExtErr8026,DATARES:ExtErr8027
	dw	DATARES:ExtErr8028,DATARES:ExtErr8029,DATARES:ExtErr8030
	dw	DATARES:ExtErr8031,DATARES:ExtErr8032,DATARES:ExtErr8033
	dw	DATARES:ExtErr8034,DATARES:ExtErr8035,DATARES:ExtErr8036
	dw	DATARES:ExtErr8037,DATARES:ExtErr8038,DATARES:ExtErr8039
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr8080,0,                DATARES:ExtErr8082
	dw	DATARES:ExtErr8083,DATARES:ExtErr8084,DATARES:ExtErr8085
	dw	DATARES:ExtErr8086,DATARES:ExtErr8087,DATARES:ExtErr8088
	dw	DATARES:ExtErr8089,DATARES:ExtErr8090
else
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
endif
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\nec_98\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

ifdef BILINGUAL
	msg	BadVerMsg,   <"DOS ̃o[WႢ܂.",CR,LF,0,"Incorrect DOS version",CR,LF>
	msg	OutEnvMsg,   <"ϐ̂߂̃܂.",CR,LF,0,"Out of environment space",CR,LF>
ifndef ROMDOS
        msg     CopyrightMsg,<CR,LF,"Microsoft(R) Windows DOS",CR,LF,\
"             (C)Copyright Microsoft Corp 1990-2001.  ",CR,LF,0,"Microsoft(R) Windows DOS",CR,LF,\
"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
else
        msg     CopyrightMsg,<CR,LF,CR,LF,"Microsoft(R) MS-DOS(R) ROM ްޮ 5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.  ",CR,LF,0,CR,LF,CR,LF,"Microsoft(R) MS-DOS(R) ROM Version 5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.",CR,LF>
endif
	msg	BadComLkMsg, <"w肳ꂽR}hfBNgႢ܂.",CR,LF,0,"Specified COMMAND search directory bad",CR,LF>
	msg	BadComAccMsg,<"w肳ꂽR}hfBNgɃANZXł܂.",CR,LF,0,"Specified COMMAND search directory bad access denied",CR,LF>

	msg	Help1Msg  <"MS-DOSR}hC^v^VN܂.",CR,LF,CR,LF,0,"Starts a new instance of the MS-DOS command interpreter.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[ײ:]߽] [޲] [/E:nnnnn] [/P] [/C ] [/MSG]",CR,LF,CR,LF,0,"COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [ײ:]߽   COMMAND.COMt@ĈfBNgw肵܂.",CR,LF,0,"  [drive:]path    Specifies the directory containing COMMAND.COM file.",CR,LF>
        msg     Help4Msg  <"  ޲         R}ho͂̂߂ɎgpfoCXw肵܂.",CR,LF,0,"  device          Specifies the device to use for command input and output.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn       ϐ̃TCY̏lƂ nnnnn oCgݒ肵܂.",CR,LF,0,"  /E:nnnnn        Sets the initial environment size to nnnnn bytes.",CR,LF>
	msg	Help6Msg  <"  /P             VȃR}hC^v^풓܂. (A܂)",CR,LF,0,"  /P              Makes the new command interpreter permanent (can't exit).",CR,LF>
	msg	Help7Msg  <"  /C       Ŏw肵R}h̎s, A܂.",CR,LF,0,"  /C string       Carries out the command specified by string, and then stops.",CR,LF>
	msg	Help8Msg  <"  /MSG           SG[bZ[Wɕێ܂. ̃XCb`",CR,LF,0,"  /MSG            Specifies that all error messages be stored in memory. You",CR,LF>
	msg	Help9Msg  <"                 /P XCb`ƓɎw肵Ȃ΂Ȃ܂.",CR,LF,0,"                  need to specify /P with this switch.",CR,LF>
else
	msg	BadVerMsg,   <"DOS ̃o[WႢ܂.",CR,LF>
	msg	OutEnvMsg,   <"ϐ̂߂̃܂.",CR,LF>
ifndef NEC_98
        msg     CopyrightMsg,<CR,LF,CR,LF,"Microsoft(R) MS-DOS(R) ްޮ 5.00",CR,LF,\
"             (C)Copyright Microsoft Corp 1981-2001.  ",CR,LF>
else    ;NEC_98
        msg     CopyrightMsg,<CR,LF,"ϲۿ MS-DOS ްޮ5.00A",CR,LF,"Copyright (C) 1981,99 Microsoft Corp. / NEC Corporation",CR,LF,CR,LF>	;NEC01 91/07/29
endif   ;NEC_98
	msg	BadComLkMsg, <"w肳ꂽR}hfBNgႢ܂.",CR,LF>
	msg	BadComAccMsg,<"w肳ꂽR}hfBNgɃANZXł܂.",CR,LF>

	msg	Help1Msg  <"MS-DOS R}hC^v^VN܂.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[ײ:]߽] [޲] [/E:nnnnn] [/P] [/C ] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [ײ:]߽   COMMAND.COM t@ĈfBNgw肵܂.",CR,LF>
        msg     Help4Msg  <"  ޲         R}ho͂̂߂ɎgpfoCXw肵܂.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn       ϐ̃TCY̏lƂ nnnnn oCgݒ肵܂.",CR,LF>
	msg	Help6Msg  <"  /P             VȃR}hC^v^풓܂. (A܂)",CR,LF>
	msg	Help7Msg  <"  /C       Ŏw肵R}h̎s, A܂.",CR,LF>
	msg	Help8Msg  <"  /MSG           SG[bZ[Wɕێ܂. ̃XCb`",CR,LF>
	msg	Help9Msg  <"                 /P XCb`ƓɎw肵Ȃ΂Ȃ܂.",CR,LF>
endif


HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
                dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\kor\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

ifdef BILINGUAL
	msg	Req_Abort, <"<A>",0,"Abort">
	msg	Req_Retry, <", ٽ õ<R>",0,", Retry">
	msg	Req_Ignore,<", <I>",0,", Ignore">
	msg	Req_Fail,  <", <F>",0,", Fail">
	msg	Req_End,   <"?",0,"?">
	msg	MRead,	   <"д ",0,"reading",0>
	msg	MWrite,	   <" ",0,"writing",0>
	msg	BlkDevErr, <" %1 ̺ %2",CR,LF,0," %1 drive %2",CR,LF>
	msg	CharDevErr,<" %1 ̽ %2",CR,LF,0," %1 device %2",CR,LF>
	msg	NeedVolMsg,<" %1 Ϸ ȣ %2-%3() ʽÿ.",CR,LF,0,"Please insert volume %1 serial %2-%3",CR,LF>
	msg	BadFatMsg, <" Ҵ ̺ ջǾϴ. ̺ %1",CR,LF,0,"File allocation table bad, drive %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM ùٸ ʽϴ.",CR,LF,0,"Invalid COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"%1 ũ %2 ̺꿡 ʽÿ.",CR,LF,0,"Insert disk with %1 in drive %2",CR,LF>
	msg	Prompt,	   <"ƹ Ű  ӵ˴ϴ . . .",CR,LF,0,"Press any key to continue . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"ϰ ۾  <Y/N>?",0,CR,LF,"Terminate batch job (Y/N)?">
	msg	ExecEMes,  <"%1()   ϴ.",CR,LF,0,"Cannot execute %1",CR,LF>
	msg	ExeBad,	   <".EXE  Դϴ.",CR,LF,0,"Error in EXE file",CR,LF>
	msg	TooBig,	   <"α׷ ʹ Ŀ ޸𸮿  ʽϴ.",CR,LF,0,"Program too big to fit in memory",CR,LF>
	msg	NoHandMes, <CR,LF,"  ڵ ϴ.",0,CR,LF,"No free file handles">
	msg	RBadNam,   <"ɾ Ǵ  ̸ Ʋϴ.",CR,LF,0,"Bad Command or file name",CR,LF>
	msg	AccDen,	   <"׼  ϴ. ",0,"Access denied ">
	msg	BMemMes,   <CR,LF,"޸ Ҵ Դϴ.",0,CR,LF,"Memory allocation error">
	msg	HaltMes,   <CR,LF,"COMMAND о  ϴ. ý ˴ϴ.",CR,LF,0,CR,LF,"Cannot load COMMAND, system halted",CR,LF>
	msg	FRetMes,   <CR,LF,"COMMAND   ϴ. մϴ.",CR,LF,0,CR,LF,"Cannot start COMMAND, exiting",CR,LF>
	msg	Patricide, <CR,LF,"ֻ μ ҵǾ   ϴ.",CR,LF,0,CR,LF,"Top level process aborted, cannot continue",CR,LF> 
	msg	Newlin,	   <CR,LF,0,CR,LF>
else
	msg	Req_Abort, <"<A>">
	msg	Req_Retry, <", ٽ õ<R>">
	msg	Req_Ignore,<", <I>">
	msg	Req_Fail,  <", <F>">
	msg	Req_End,   <"?">
	msg	MRead,	   <"д ",0>
	msg	MWrite,	   <" ",0>
	msg	BlkDevErr, <" %1 ̺ %2",CR,LF>
	msg	CharDevErr,<" %1 ̽ %2",CR,LF>
	msg	NeedVolMsg,<" %1 Ϸ ȣ %2-%3() ʽÿ.",CR,LF>
	msg	BadFatMsg, <" Ҵ ̺ ջǾϴ. ̺ %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM ùٸ ʽϴ.",CR,LF>
	msg	PutBackMsg,<"%1 ũ %2 ̺꿡 ʽÿ.",CR,LF>
	msg	Prompt,	   <"ƹ Ű  ӵ˴ϴ . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"ϰ ۾  <Y/N>?">
	msg	ExecEMes,  <"%1()   ϴ.",CR,LF>
	msg	ExeBad,	   <"EXE  Դϴ.",CR,LF>
	msg	TooBig,	   <"α׷ ʹ Ŀ ޸𸮿  ʽϴ.",CR,LF>
	msg	NoHandMes, <CR,LF,"  ڵ ϴ.">
	msg	RBadNam,   <"ɾ Ǵ  ̸ Ʋϴ.",CR,LF>
	msg	AccDen,	   <"׼  ϴ. ">
	msg	BMemMes,   <CR,LF,"޸ Ҵ Դϴ.">
	msg	HaltMes,   <CR,LF,"COMMAND о  ϴ. ý ˴ϴ.",CR,LF>
	msg	FRetMes,   <CR,LF,"COMMAND   ϴ. մϴ.",CR,LF>
	msg	Patricide, <CR,LF,"ֻ μ ҵǾ   ϴ.",CR,LF> 
	msg	Newlin,	   <CR,LF>
endif

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

ifdef BILINGUAL
	msg	ExtErr19,<"  ">
	msg	ExtErr20,<"ùٸ  ">
	msg	ExtErr21,<"غ ">
	msg	ExtErr22,<"ùٸ  ̽ û">
	msg	ExtErr23,<" ">
	msg	ExtErr24,<"ùٸ  ̽ û Ű ">
	msg	ExtErr25,<"ã ">
	msg	ExtErr26,<"ùٸ  ü ">
	msg	ExtErr27,<" ">
	msg	ExtErr28,<"   ">
	msg	ExtErr29,<"  ">
	msg	ExtErr30,<"б  ">
	msg	ExtErr31,<"Ϲ ">
	msg	ExtErr32,<" ">
	msg	ExtErr33,<" ">
	msg	ExtErr34,<"ùٸ  ũ ٲٱ">
	msg	ExtErr35,<"FCB  Ұ">
	msg	ExtErr36,<"ý ҽ ">
	msg	ExtErr37,<"ڵ  ġ">
	msg	ExtErr38,<"Է ">
	msg	ExtErr39,<"ũ  ">
	msg	ExtErr8019,<"Write protect error">
	msg	ExtErr8020,<"Invalid unit">
	msg	ExtErr8021,<"Not ready">
	msg	ExtErr8022,<"Invalid device request">
	msg	ExtErr8023,<"Data error">
	msg	ExtErr8024,<"Invalid device request parameters">
	msg	ExtErr8025,<"Seek error">
	msg	ExtErr8026,<"Invalid media type">
	msg	ExtErr8027,<"Sector not found">
	msg	ExtErr8028,<"Printer out of paper error">
	msg	ExtErr8029,<"Write fault error">
	msg	ExtErr8030,<"Read fault error">
	msg	ExtErr8031,<"General failure">
	msg	ExtErr8032,<"Sharing violation">
	msg	ExtErr8033,<"Lock violation">
	msg	ExtErr8034,<"Invalid disk change">
	msg	ExtErr8035,<"FCB unavailable">
	msg	ExtErr8036,<"System resource exhausted">
	msg	ExtErr8037,<"Code page mismatch">
	msg	ExtErr8038,<"Out of input">
	msg	ExtErr8039,<"Insufficient disk space">
else
	msg	ExtErr19,<"  ">
	msg	ExtErr20,<"ùٸ  ">
	msg	ExtErr21,<"غ ">
	msg	ExtErr22,<"ùٸ  ̽ û">
	msg	ExtErr23,<" ">
	msg	ExtErr24,<"ùٸ  ̽ û Ű ">
	msg	ExtErr25,<"ã ">
	msg	ExtErr26,<"ùٸ  ü ">
	msg	ExtErr27,<" ">
	msg	ExtErr28,<"   ">
	msg	ExtErr29,<"  ">
	msg	ExtErr30,<"б  ">
	msg	ExtErr31,<"Ϲ ">
	msg	ExtErr32,<" ">
	msg	ExtErr33,<" ">
	msg	ExtErr34,<"ùٸ  ũ ٲٱ">
	msg	ExtErr35,<"FCB  Ұ">
	msg	ExtErr36,<"ý ҽ ">
	msg	ExtErr37,<"ڵ  ġ">
	msg	ExtErr38,<"Է ">
	msg	ExtErr39,<"ũ  ">
endif

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	DATARES:ExtErr8019,DATARES:ExtErr8020,DATARES:ExtErr8021,DATARES:ExtErr8022,DATARES:ExtErr8023,DATARES:ExtErr8024
	dw	DATARES:ExtErr8025,DATARES:ExtErr8026,DATARES:ExtErr8027,DATARES:ExtErr8028,DATARES:ExtErr8029,DATARES:ExtErr8030
	dw	DATARES:ExtErr8031,DATARES:ExtErr8032,DATARES:ExtErr8033,DATARES:ExtErr8034,DATARES:ExtErr8035,DATARES:ExtErr8036
	dw	DATARES:ExtErr8037,DATARES:ExtErr8038,DATARES:ExtErr8039
else
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
endif

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

ifdef BILINGUAL
	msg	ParsErr01,<"Ű  ʹ ϴ.">
	msg	ParsErr02,<"ʿ Ű   ʾҽϴ.">
	msg	ParsErr03,<"ġ Ʋϴ.">
	msg	ParsErr04,<"Ű尡 Ʋϴ.">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Ű     ϴ.">
	msg	ParsErr07,<" ʴ Ű  Դϴ.">
	msg	ParsErr08,<" ʴ Ű  Դϴ.">
	msg	ParsErr09,<"Ű   Ʋϴ.">
	msg	ParsErr10,<"Ű  Ʋϴ.">
	msg	ParsErr11,<"Ű   Ʋϴ.">
	msg	ParsErr8001,<"Too many parameters">
	msg	ParsErr8002,<"Required parameter missing">
	msg	ParsErr8003,<"Invalid switch">
	msg	ParsErr8004,<"Invalid keyword">
	msg	ParsErr8005,<" ">
	msg	ParsErr8006,<"Parameter value not in allowed range">
	msg	ParsErr8007,<"Parameter value not allowed">
	msg	ParsErr8008,<"Parameter value not allowed">
	msg	ParsErr8009,<"Parameter format not correct">
	msg	ParsErr8010,<"Invalid parameter">
	msg	ParsErr8011,<"Invalid parameter combination">
else
	msg	ParsErr01,<"Ű  ʹ ϴ.">
	msg	ParsErr02,<"ʿ Ű   ʾҽϴ.">
	msg	ParsErr03,<"ġ Ʋϴ.">
	msg	ParsErr04,<"Ű尡 Ʋϴ.">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Ű     ϴ.">
	msg	ParsErr07,<" ʴ Ű  Դϴ.">
	msg	ParsErr08,<" ʴ Ű  Դϴ.">
	msg	ParsErr09,<"Ű   Ʋϴ.">
	msg	ParsErr10,<"Ű  Ʋϴ.">
	msg	ParsErr11,<"Ű   Ʋϴ.">
endif

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11
	dw	DATARES:ParsErr8001,DATARES:ParsErr8002,DATARES:ParsErr8003
	dw	DATARES:ParsErr8004,DATARES:ParsErr8005,DATARES:ParsErr8006
	dw	DATARES:ParsErr8007,DATARES:ParsErr8008,DATARES:ParsErr8009
	dw	DATARES:ParsErr8010,DATARES:ParsErr8011
else
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11
endif

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

ifdef BILINGUAL
	msg	ExtErr01,<"Լ ùٸ ʽϴ.">
	msg	ExtErr02,<" ϴ.">
	msg	ExtErr03,<"ΰ ϴ.">
	msg	ExtErr04,<"ִ  ʹ ϴ.">
	msg	ExtErr05,<"׼  ϴ.">
	msg	ExtErr06,<"ùٸ  ڵԴϴ.">
	msg	ExtErr07,<"޸   ջǾϴ.">
	msg	ExtErr08,<"޸𸮰 մϴ.">
	msg	ExtErr09,<"޸  ּҰ Ʋϴ.">
	msg	ExtErr10,<"ȯ ùٸ ʽϴ.">
	msg	ExtErr11,<" Ʋϴ.">
	msg	ExtErr12,<"Լ Ű  Ʋϴ.">
	msg	ExtErr13,<"ùٸ  Դϴ.">

	msg	ExtErr15,<"̺  ùٸ ʽϴ.">
	msg	ExtErr16,<" 丮  ߽ϴ.">
	msg	ExtErr17,<" ̽ ƴմϴ.">
	msg	ExtErr18,<"  ̻ ϴ.">

	msg	ExtErr80,<" ֽϴ.">

	msg	ExtErr82,<"丮 ׸   ϴ.">
	msg	ExtErr83,<"INT 24H Դϴ.">
	msg	ExtErr84,<" ȯ ʹ ϴ.">
	msg	ExtErr85,<" ȯ ߺ˴ϴ.">
	msg	ExtErr86,<"ȣ Ʋϴ.">
	msg	ExtErr87,<"Ű  Ʋϴ.">
	msg	ExtErr88,<"Ʈũ  Դϴ.">
	msg	ExtErr89,<"Ʈũ  ʴ ԼԴϴ.">
	msg	ExtErr90,<"ʿ ý  Ұ ġ ʾҽϴ.">

	msg	ExtErr8001,<"Invalid function">
	msg	ExtErr8002,<"File not found">
	msg	ExtErr8003,<"Path not found">
	msg	ExtErr8004,<"Too many open files">
	msg	ExtErr8005,<"Access denied ">
	msg	ExtErr8006,<"Invalid handle">
	msg	ExtErr8007,<"Memory control blocks destroyed">
	msg	ExtErr8008,<"Insufficient memory">
	msg	ExtErr8009,<"Invalid memory block address">
	msg	ExtErr8010,<"Invalid Environment">
	msg	ExtErr8011,<"Invalid format">
	msg	ExtErr8012,<"Invalid function parameter">
	msg	ExtErr8013,<"Invalid data">

	msg	ExtErr8015,<"Invalid drive specification">
	msg	ExtErr8016,<"Attempt to remove current directory">
	msg	ExtErr8017,<"Not same device">
	msg	ExtErr8018,<"No more files">

	msg	ExtErr8080,<"File exists">

	msg	ExtErr8082,<"Cannot make directory entry">
	msg	ExtErr8083,<"Fail on INT 24">
	msg	ExtErr8084,<"Too many redirections">
	msg	ExtErr8085,<"Duplicate redirection">
	msg	ExtErr8086,<"Invalid password">
	msg	ExtErr8087,<"Invalid parameter">
	msg	ExtErr8088,<"Network data fault">
	msg	ExtErr8089,<"Function not supported by network">
	msg	ExtErr8090,<"Required system component not installed">

else
	msg	ExtErr01,<"Լ ùٸ ʽϴ.">
	msg	ExtErr02,<" ϴ.">
	msg	ExtErr03,<"ΰ ϴ.">
	msg	ExtErr04,<"ִ  ʹ ϴ.">
	msg	ExtErr05,<"׼  ϴ.">
	msg	ExtErr06,<"ùٸ  ڵԴϴ.">
	msg	ExtErr07,<"޸   ջǾϴ.">
	msg	ExtErr08,<"޸𸮰 մϴ.">
	msg	ExtErr09,<"޸  ּҰ Ʋϴ.">
	msg	ExtErr10,<"ȯ ùٸ ʽϴ.">
	msg	ExtErr11,<" Ʋϴ.">
	msg	ExtErr12,<"Լ Ű  Ʋϴ.">
	msg	ExtErr13,<"ùٸ  Դϴ.">

	msg	ExtErr15,<"̺  ùٸ ʽϴ.">
	msg	ExtErr16,<" 丮  ߽ϴ.">
	msg	ExtErr17,<" ̽ ƴմϴ.">
	msg	ExtErr18,<"  ̻ ϴ.">

	msg	ExtErr80,<" ֽϴ.">

	msg	ExtErr82,<"丮 ׸   ϴ.">
	msg	ExtErr83,<"INT 24H Դϴ.">
	msg	ExtErr84,<" ȯ ʹ ϴ.">
	msg	ExtErr85,<" ȯ ߺ˴ϴ.">
	msg	ExtErr86,<"ȣ Ʋϴ.">
	msg	ExtErr87,<"Ű  Ʋϴ.">
	msg	ExtErr88,<"Ʈũ  Դϴ.">
	msg	ExtErr89,<"Ʈũ  ʴ ԼԴϴ.">
	msg	ExtErr90,<"ʿ ý  Ұ ġ ʾҽϴ.">
endif

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
ifdef BILINGUAL
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
	dw	DATARES:ExtErr8001,DATARES:ExtErr8002,DATARES:ExtErr8003
	dw	DATARES:ExtErr8004,DATARES:ExtErr8005,DATARES:ExtErr8006
	dw	DATARES:ExtErr8007,DATARES:ExtErr8008,DATARES:ExtErr8009
	dw	DATARES:ExtErr8010,DATARES:ExtErr8011,DATARES:ExtErr8012
	dw	DATARES:ExtErr8013,0,                DATARES:ExtErr8015
	dw	DATARES:ExtErr8016,DATARES:ExtErr8017,DATARES:ExtErr8018
	dw	DATARES:ExtErr8019,DATARES:ExtErr8020,DATARES:ExtErr8021
	dw	DATARES:ExtErr8022,DATARES:ExtErr8023,DATARES:ExtErr8024
	dw	DATARES:ExtErr8025,DATARES:ExtErr8026,DATARES:ExtErr8027
	dw	DATARES:ExtErr8028,DATARES:ExtErr8029,DATARES:ExtErr8030
	dw	DATARES:ExtErr8031,DATARES:ExtErr8032,DATARES:ExtErr8033
	dw	DATARES:ExtErr8034,DATARES:ExtErr8035,DATARES:ExtErr8036
	dw	DATARES:ExtErr8037,DATARES:ExtErr8038,DATARES:ExtErr8039
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr8080,0,                DATARES:ExtErr8082
	dw	DATARES:ExtErr8083,DATARES:ExtErr8084,DATARES:ExtErr8085
	dw	DATARES:ExtErr8086,DATARES:ExtErr8087,DATARES:ExtErr8088
	dw	DATARES:ExtErr8089,DATARES:ExtErr8090
else
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
endif
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\nl\comimsg.inc ===
;   Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

        msg     BadVerMsg,   <"Onjuiste DOS-versie",CR,LF>
        msg     OutEnvMsg,   <"Geen omgevingsruimte meer",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
        msg     BadComLkMsg, <"Gespecificeerde COMMAND-zoekmap is onjuist",CR,LF>
        msg     BadComAccMsg,<"Gespecificeerde COMMAND-zoekmap is onjuist, toegang geweigerd",CR,LF>

        msg     Help1Msg  <"Start een nieuwe versie van het MS-DOS-opdrachtinterpreter.",CR,LF,CR,LF>
        msg     Help2Msg  <"COMMAND [[station:]pad] [apparaat] [/E:nnnnn] [/P] [/C reeks] [/MSG]",CR,LF,CR,LF>
        msg     Help3Msg  <"  [station:]pad     Specificeert de map die het bestand COMMAND.COM",CR,LF,"                    bevat.",CR,LF>
        msg     Help4Msg  <"  apparaat          Specificeert het apparaat dat voor opdracht-I/O gebruikt",CR,LF,"                    wordt.",CR,LF>
        msg     Help5Msg  <"  /E:nnnnn          Stelt de initile omgevingsruimte in op nnnnn",CR,LF,"                    bytes.",CR,LF>
        msg     Help6Msg  <"  /P                Maakt de nieuwe opdrachtinterpreter permanent",CR,LF,"                    (kan niet afsluiten).",CR,LF>
        msg     Help7Msg  <"  /C reeks          Voert de door de reeks gespecificeerde opdracht uit en",CR,LF,"                    stopt vervolgens.",CR,LF>
        msg     Help8Msg  <"  /MSG              Specificeert dat alle foutberichten in het geheugen ",CR,LF,"                    worden opgeslagen.",CR,LF>
        msg     Help9Msg  <"                    U moet /P specificeren bij deze schakeloptie.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
                dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
                dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
                dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
                dw      RESGROUP:Help9Msg,0


        public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\nl\comrmsg.inc ===
;***    Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "A"
Retry_Char      db      "H"
Ignore_Char     db      "N"
Fail_Char       db      "O"
Yes_Char        db      "J"
No_Char         db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

	msg     Req_Abort, <"Afbreken">
	msg     Req_Retry, <", Herhalen">
	msg     Req_Ignore,<", Negeren">
	msg     Req_Fail,  <", Overslaan">
	msg     Req_End,   <"?">
	msg     MRead,     <"bij het lezen van",0>
	msg     MWrite,    <"bij het schrijven naar",0>
	msg     BlkDevErr, <" %1 station %2",CR,LF>
	msg     CharDevErr,<" %1 apparaat %2",CR,LF>
	msg     NeedVolMsg,<"Plaats a.u.b. volume %1 nummer %2-%3",CR,LF>
	msg     BadFatMsg, <"FAT onbruikbaar van station %1",CR,LF>
	msg     ComBad,    <"Ongeldige COMMAND.COM",CR,LF>
	msg     PutBackMsg,<"Plaats diskette met %1 in station %2",CR,LF>
	msg     Prompt,    <"Druk op een toets om verder te gaan . . .",CR,LF>
	msg     EndBatMes, <CR,LF,"Batch-verwerking beindigen (J/N)?">
	msg     ExecEMes,  <"Uitvoeren %1 onmogelijk",CR,LF>
	msg     ExeBad,    <"Fout in .EXE-bestand",CR,LF>
	msg     TooBig,    <"Programma te groot voor geheugen",CR,LF>
	msg     NoHandMes, <CR,LF,"Geen bestandsingangen beschikbaar">
	msg     RBadNam,   <"Opdracht of bestandsnaam onjuist",CR,LF>
	msg     AccDen,    <"Geen toegang ">
	msg     BMemMes,   <CR,LF,"Fout in geheugentoewijzing">
	msg     HaltMes,   <CR,LF,"COMMAND.COM kan niet worden geladen, systeem is gestopt",CR,LF>
	msg     FRetMes,   <CR,LF,"COMMAND.COM kan niet worden gestart, programma is afgesloten",CR,LF>
	msg     Patricide, <CR,LF,"Actief proces afgebroken, kan niet verder gaan",CR,LF>
	msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
	dw      DATARES:ExtMsgPtrs,1    ; extended error messages
	dw      DATARES:ParsMsgPtrs,1   ; parse error messages
	dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
					;  use extended error list
	dw      0,0                     ; file system error messages - none
	dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

	msg     ExtErr19,<"Schijf is tegen schrijven beveiligd">
	msg     ExtErr20,<"Ongeldig apparaat">
	msg     ExtErr21,<"Niet gereed">
	msg     ExtErr22,<"Ongeldig apparaat opgegeven">
	msg     ExtErr23,<"Gegevensfout">
	msg     ExtErr24,<"Ongeldige parameters opgegeven voor apparaat">
	msg     ExtErr25,<"Zoekfout">
	msg     ExtErr26,<"Ongeldig type medium">
	msg     ExtErr27,<"Sector niet gevonden">
	msg     ExtErr28,<"Geen papier in printer">
	msg     ExtErr29,<"Schrijffout">
	msg     ExtErr30,<"Leesfout">
	msg     ExtErr31,<"Algemene storing">
	msg     ExtErr32,<"Inbreuk op gemeenschappelijk bestandsgebruik">
	msg     ExtErr33,<"Inbreuk op vergrendelde bestanden">
	msg     ExtErr34,<"Wisselen van schijven niet toegestaan">
	msg     ExtErr35,<"FCB niet beschikbaar">
	msg     ExtErr36,<"Systeembronnen uitgeput">
	msg     ExtErr37,<"Codetabellen komen niet overeen">
	msg     ExtErr38,<"Geen invoer meer mogelijk">
	msg     ExtErr39,<"Onvoldoende schijfruimte">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

	msg     ParsErr01,<"Te veel parameters">
	msg     ParsErr02,<"Benodigde parameter ontbreekt">
	msg     ParsErr03,<"Ongeldige schakeloptie">
	msg     ParsErr04,<"Ongeldig trefwoord">
	msg     ParsErr05,<" ">
	msg     ParsErr06,<"Parameterwaarde buiten toegestaan bereik">
	msg     ParsErr07,<"Parameterwaarde niet toegestaan">
	msg     ParsErr08,<"Parameterwaarde niet toegestaan">
	msg     ParsErr09,<"Parameterformulering onjuist">
	msg     ParsErr10,<"Ongeldige parameter">
	msg     ParsErr11,<"Ongeldige combinatie van parameters">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
	dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

	msg     ExtErr01,<"Ongeldige functie">
	msg     ExtErr02,<"Bestand niet gevonden">
	msg     ExtErr03,<"Pad niet gevonden">
	msg     ExtErr04,<"Te veel open bestanden">
	msg     ExtErr05,<"Geen toegang ">
	msg     ExtErr06,<"Ongeldige ingang">
	msg     ExtErr07,<"Geheugenbesturingsblokken vernietigd">
	msg     ExtErr08,<"Onvoldoende geheugen">
	msg     ExtErr09,<"Ongeldig geheugenblokadres">
	msg     ExtErr10,<"Ongeldige verwerkingsomgeving">
	msg     ExtErr11,<"Ongeldige indeling">
	msg     ExtErr12,<"Ongeldige functieparameter">
	msg     ExtErr13,<"Ongeldige gegevens">

	msg     ExtErr15,<"Ongeldig station opgegeven">
	msg     ExtErr16,<"Huidige map kan niet worden verwijderd">
	msg     ExtErr17,<"Niet hetzelfde apparaat">
	msg     ExtErr18,<"Geen bestanden meer">

	msg     ExtErr80,<"Bestand bestaat reeds">

	msg     ExtErr82,<"Directory-ingang kan niet worden gemaakt">
	msg     ExtErr83,<"Fout op INT 24">
	msg     ExtErr84,<"Te veel omleidingen">
	msg     ExtErr85,<"Dubbele omleiding">
	msg     ExtErr86,<"Ongeldig wachtwoord">
	msg     ExtErr87,<"Ongeldige parameter">
	msg     ExtErr88,<"Gegevensfout in netwerk">
	msg     ExtErr89,<"Functie niet ondersteund door netwerk">
	msg     ExtErr90,<"Benodigd systeemonderdeel niet genstalleerd">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.  
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
	dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw      80-40 dup (0) ; null ptrs for errors 40-79
	dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\pl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\pt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\no\comrmsg.inc ===
;***    Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "A"
Retry_Char      db      "P"
Ignore_Char     db      "I"
Fail_Char       db      "F"
Yes_Char        db      "J"
No_Char         db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

	msg     Req_Abort, <"Avbryt">
	msg     Req_Retry, <", Prv p nytt">
	msg     Req_Ignore,<", Ignorer">
	msg     Req_Fail,  <", Feil">
	msg     Req_End,   <"?">
	msg     MRead,     <"ved lesing fra",0>
	msg     MWrite,    <"ved skriving til",0>
	msg     BlkDevErr, <" %1 stasjon %2",CR,LF>
	msg     CharDevErr,<" %1 enhet %2",CR,LF>
	msg     NeedVolMsg,<"Sett inn volum %1, serienr. %2-%3",CR,LF>
	msg     BadFatMsg, <"Feil i filtildelingstabell p stasjon %1",CR,LF>
	msg     ComBad,    <"Ugyldig COMMAND.COM",CR,LF>
	msg     PutBackMsg,<"Sett inn diskett med %1 i stasjon %2",CR,LF>
	msg     Prompt,    <"Trykk en tast for  fortsette . . .",CR,LF>
	msg     EndBatMes, <CR,LF,"Vil du avslutte den satsvise jobben (J/N)?">
	msg     ExecEMes,  <"Kan ikke kjre %1",CR,LF>
	msg     ExeBad,    <"Feil i EXE-filen",CR,LF>
	msg     TooBig,    <"Programmet er for stort til  f plass i minnet",CR,LF>
	msg     NoHandMes, <CR,LF,"Det er ingen ledige filreferanser">
	msg     RBadNam,   <"Ugyldig kommando eller filnavn",CR,LF>
	msg     AccDen,    <"Ingen tilgang ">
	msg     BMemMes,   <CR,LF,"Minnetildelingsfeil">
	msg     HaltMes,   <CR,LF,"Kan ikke laste COMMAND - maskinen er stoppet",CR,LF>
	msg     FRetMes,   <CR,LF,"Kan ikke starte COMMAND - avslutter",CR,LF>
	msg     Patricide, <CR,LF,"Toppnivprosess avbrutt - kan ikke fortsette",CR,LF> 
	msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
	dw      DATARES:ExtMsgPtrs,1    ; extended error messages
	dw      DATARES:ParsMsgPtrs,1   ; parse error messages
	dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
					;  use extended error list
	dw      0,0                     ; file system error messages - none
	dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

	msg     ExtErr19,<"Skrivebeskyttelsesfeil">
	msg     ExtErr20,<"Ugyldig enhet">
	msg     ExtErr21,<"Ikke klar">
	msg     ExtErr22,<"Ugyldig enhetsforesprsel">
	msg     ExtErr23,<"Datafeil">
	msg     ExtErr24,<"Ugyldige parametere ved enhetsforesprsel">
	msg     ExtErr25,<"Skefeil">
	msg     ExtErr26,<"Ugyldig medietype">
	msg     ExtErr27,<"Finner ikke sektor">
	msg     ExtErr28,<"Skriveren er tom for papir">
	msg     ExtErr29,<"Skrivefeil">
	msg     ExtErr30,<"Lesefeil">
	msg     ExtErr31,<"Generell feil">
	msg     ExtErr32,<"Brudd p deletillatelse">
	msg     ExtErr33,<"Brudd p lsetillatelse">
	msg     ExtErr34,<"Ugyldig diskettbytte">
	msg     ExtErr35,<"FCB er ikke tilgjengelig">
	msg     ExtErr36,<"Systemressursene er oppbrukt">
	msg     ExtErr37,<"Tegntabellene samsvarer ikke">
	msg     ExtErr38,<"Tomt for inndata">
	msg     ExtErr39,<"Ikke nok diskplass">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

	msg     ParsErr01,<"For mange parametere">
	msg     ParsErr02,<"Ndvendig parameter mangler">
	msg     ParsErr03,<"Ugyldig bryter">
	msg     ParsErr04,<"Ugyldig tastatur">
	msg     ParsErr05,<" ">
	msg     ParsErr06,<"Parameterverdi er ikke innenfor tillatt omrde">
	msg     ParsErr07,<"Ugyldig parameterverdi">
	msg     ParsErr08,<"Ugyldig parameterverdi">
	msg     ParsErr09,<"Ugyldig parameterformat">
	msg     ParsErr10,<"Ugyldig parameter">
	msg     ParsErr11,<"Ugyldig parameterkombinasjon">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
	dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

	msg     ExtErr01,<"Ugyldig funksjon">
	msg     ExtErr02,<"Finner ikke filen">
	msg     ExtErr03,<"Finner ikke banen">
	msg     ExtErr04,<"For mange pne filer">
	msg     ExtErr05,<"Ingen tilgang ">
	msg     ExtErr06,<"Ugyldig referanse">
	msg     ExtErr07,<"Minnekontrollblokker er delagt">
	msg     ExtErr08,<"Ikke nok minne">
	msg     ExtErr09,<"Ugyldig minneblokkadresse">
	msg     ExtErr10,<"Ugyldig milj">
	msg     ExtErr11,<"Ugyldig format">
	msg     ExtErr12,<"Ugyldig funksjonsparameter">
	msg     ExtErr13,<"Ugyldige data">

	msg     ExtErr15,<"Ugyldig stasjonsangivelse">
	msg     ExtErr16,<"Forsk p  fjerne gjeldende katalog">
	msg     ExtErr17,<"Ikke samme enhet">
	msg     ExtErr18,<"Ingen flere filer">

	msg     ExtErr80,<"Filen finnes">

	msg     ExtErr82,<"Kan ikke skrive til katalogen">
	msg     ExtErr83,<"Feil p INT 24">
	msg     ExtErr84,<"For mange omadresseringer">
	msg     ExtErr85,<"Dobbel omadressering">
	msg     ExtErr86,<"Ugyldig passord">
	msg     ExtErr87,<"Ugyldig parameter">
	msg     ExtErr88,<"Nettverksdatafeil">
	msg     ExtErr89,<"Funksjonen stttes ikke av nettverket">
	msg     ExtErr90,<"Ndvendig systemkomponent er ikke installert">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.  
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
	dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw      80-40 dup (0) ; null ptrs for errors 40-79
	dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\pl\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

        msg     BadVerMsg,   <"Niepoprawna wersja systemu DOS",CR,LF>
        msg     OutEnvMsg,   <"Brak miejsca na rodowisko",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
        msg     BadComLkMsg, <"Podany katalog wyszukiwania pliku COMMAND jest niewaciwy",CR,LF>
        msg     BadComAccMsg,<"Podany katalog wyszukania pliku COMMAND jest niewaciwy; odmowa dostpu",CR,LF>

        msg     Help1Msg  <"Uruchamia nowe wystpienie interpretera polece MS-DOS.",CR,LF,CR,LF>
        msg     Help2Msg  <"COMMAND [[dysk:]cieka] [urzdzenie] [/E:nnnnn] [/P] [/C polecenie] [/MSG]",CR,LF,CR,LF>
        msg     Help3Msg  <"  [dysk:]cieka  Okrela katalog zawierajcy plik COMMAND.COM",CR,LF>
        msg     Help4Msg  <"  urzdzenie      Okrela urzdzenie uyte jako wejcie i wyjcie polecenia.",CR,LF>
        msg     Help5Msg  <"  /E:nnnnn        Ustawia pocztkowy rozmiar rodowiska na nnnnn bajtw.",CR,LF>
        msg     Help6Msg  <"  /P              Ustala nowy interpreter polece jako stay (wyjcie niemoliwe).",CR,LF>
        msg     Help7Msg  <"  /C polecenie    Wykonuje okrelone polecenie i powraca.",CR,LF>
        msg     Help8Msg  <"  /MSG            Przechowuje wszystkie komunikaty o bdach. Wymagany jest",CR,LF>
        msg     Help9Msg  <"                  rwnie parametr /P.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\ru\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\no\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

	msg     BadVerMsg,   <"Feil DOS-versjon",CR,LF>
	msg     OutEnvMsg,   <"Ikke nok miljplass",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corporation 1990-2001.",CR,LF>
	msg     BadComLkMsg, <"Angitt COMMAND skekatalog er skadet",CR,LF>
	msg     BadComAccMsg,<"Angitt COMMAND skekatalog er skadet. Ingen tilgang.",CR,LF>

	msg     Help1Msg  <"Starter en ny forekomst av MS-DOS-kommandotolken.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[stasjon:]bane] [enhet] [/E:nnnnn] [/P] [/C streng] [/MSG]",CR,LF,CR,LF>
	msg     Help3Msg  <"  [stasjon:]bane  Angir mappen som inneholder COMMAND.COM-filen.",CR,LF>
	msg     Help4Msg  <"  enhet           Angir enheten som brukes til kommando-inndata og -utdata.",CR,LF>
	msg     Help5Msg  <"  /E:nnnnn        Setter oppstartsmiljstrrelse til nnnnn byte.",CR,LF>
	msg     Help6Msg  <"  /P              Gjr den nye kommandotolken fast (kan ikke avsluttes).",CR,LF>
	msg     Help7Msg  <"  /C streng       Utfrer kommandoen streng, og stopper",CR,LF>
	msg     Help8Msg  <"  /MSG            Angir at alle feilmeldinger lagres i minnet. Du",CR,LF>
	msg     Help9Msg  <"                  m angi /P sammen med denne bryteren.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw      RESGROUP:Help9Msg,0

	public	HelpMsgs


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\ru\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

        msg     BadVerMsg,   <"ࠢ쭠  DOS",CR,LF>
        msg     OutEnvMsg,   <"筮   ६ ।",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
        msg     BadComLkMsg, <"⠫ ᪠  COMMAND  ࠢ쭮",CR,LF>
        msg     BadComAccMsg,<"⠫ ᪠  COMMAND  ࠢ쭮,  㯠",CR,LF>

        msg     Help1Msg  <"      MS-DOS.",CR,LF,CR,LF>
        msg     Help2Msg  <"COMMAND [[:]] [ன⢮] [/E:nnnnn] [/P] [/C ப] [/MSG]",CR,LF,CR,LF>
        msg     Help3Msg  <"  [:]     ⠫, ᮤঠ騩 䠩 COMMAND.COM.",CR,LF>
        msg     Help4Msg  <"  ன⢮      ன⢮, ᯮ㥬    뢮 .",CR,LF>
        msg     Help5Msg  <"  /E:nnnnn        室 ࠧ  ६ ।  .",CR,LF>
        msg     Help6Msg  <"  /P              㧪     室.",CR,LF>
        msg     Help7Msg  <"  /C ப       믮 , 㪠  ப,  室.",CR,LF>
        msg     Help8Msg  <"  /MSG            ࠭ ᮮ饭  訡  . ॡ ਬ",CR,LF>
        msg     Help9Msg  <"                  ࠬ /P ᮢ⭮  ⨬ ࠬ஬.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\pt\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"S"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"Abortar">
	msg	Req_Retry, <", Repetir">
	msg	Req_Ignore,<", Ignorar">
	msg	Req_Fail,  <", Falhar">
	msg	Req_End,   <"?">
	msg	MRead,	   <"a ler",0>
	msg	MWrite,	   <"a escrever",0>
	msg	BlkDevErr, <" %1 unidade %2",CR,LF>
	msg	CharDevErr,<" %1 dispositivo %2",CR,LF>
	msg	NeedVolMsg,<"Introduza volume %1 n. srie %2-%3",CR,LF>
	msg	BadFatMsg, <"FAT invlida, unidade %1",CR,LF>
	msg	ComBad,	   <"COMMAND.COM invlido",CR,LF>
	msg	PutBackMsg,<"Introduza disco com %1 na unidade %2",CR,LF>
	msg	Prompt,	   <"Prima qualquer tecla para continuar . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"Terminar tarefa batch (S/N)?">
	msg	ExecEMes,  <"Impossvel executar %1",CR,LF>
	msg	ExeBad,	   <"Erro no ficheiro EXE",CR,LF>
	msg	TooBig,	   <"Programa demasiado grande para a memria",CR,LF>
	msg	NoHandMes, <CR,LF,"Sem identificadores de ficheiro livres">
	msg	RBadNam,   <"Comando ou nome de ficheiro no vlido",CR,LF>
	msg	AccDen,	   <"Acesso negado ">
	msg	BMemMes,   <CR,LF,"Erro de atribuio de memria">
	msg	HaltMes,   <CR,LF,"Impossvel carregar o COMMAND, sistema parado",CR,LF>
	msg	FRetMes,   <CR,LF,"Impossvel comear o COMMAND, a sair",CR,LF>
	msg	Patricide, <CR,LF,"Processo de topo abortado, impossvel continuar",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Erro de proteco contra escrita ">
	msg	ExtErr20,<"Unidade invlida">
	msg	ExtErr21,<"No preparado">
	msg	ExtErr22,<"Pedido de dispositivo invlido">
	msg	ExtErr23,<"Erro de dados">
	msg	ExtErr24,<"Parmetros de pedido de dispositivo invlidos">
	msg	ExtErr25,<"Erro de procura">
	msg	ExtErr26,<"Tipo de media invlido">
	msg	ExtErr27,<"Sector no encontrado">
	msg	ExtErr28,<"Erro de impressora sem papel">
	msg	ExtErr29,<"Erro de falha na escrita">
	msg	ExtErr30,<"Erro de falha na leitura">
	msg	ExtErr31,<"Falha geral">
	msg	ExtErr32,<"Violao de partilha">
	msg	ExtErr33,<"Violao de bloqueio">
	msg	ExtErr34,<"Troca de disco invlida">
	msg	ExtErr35,<"FCB indisponvel">
	msg	ExtErr36,<"Sem recursos de sistema">
	msg	ExtErr37,<"Discordncia de pg. de cdigos">
	msg	ExtErr38,<"Sem dados de entrada">
	msg	ExtErr39,<"Espao em disco insuficiente">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"Demasiados parmetros">
	msg	ParsErr02,<"Falta(m) parmetro(s) necessrio(s)">
	msg	ParsErr03,<"Parmetro invlido">
	msg	ParsErr04,<"Palavra-chave invlida">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Valor do parmetro fora do intervalo permitido">
	msg	ParsErr07,<"Valor do parmetro no permitido">
	msg	ParsErr08,<"Valor do parmetro no permitido">
	msg	ParsErr09,<"Formato incorrecto do parmetro">
	msg	ParsErr10,<"Parmetro invlido">
	msg	ParsErr11,<"Combinao de parmtros invlida">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Funo invlida">
	msg	ExtErr02,<"Ficheiro no enontrado">
	msg	ExtErr03,<"Caminho no encontrado">
	msg	ExtErr04,<"Demasiados ficheiros abertos">
	msg	ExtErr05,<"Acesso negado ">
	msg	ExtErr06,<"Identificador invlido">
	msg	ExtErr07,<"Blocos de controlo de memria destrudos">
	msg	ExtErr08,<"Memria insuficiente">
	msg	ExtErr09,<"Endereo de blocos de memria invlido">
	msg	ExtErr10,<"Ambiente invlido">
	msg	ExtErr11,<"Formato invlido">
	msg	ExtErr12,<"Parmetro de funo invlido">
	msg	ExtErr13,<"Dados invlidos">

	msg	ExtErr15,<"Especificao de unidade invlida">
	msg	ExtErr16,<"Tentativa de remoo do directrio actual">
	msg	ExtErr17,<"No  o mesmo dispositivo">
	msg	ExtErr18,<"No h mais ficheiros">

	msg	ExtErr80,<"Ficheiro existe">

	msg	ExtErr82,<"Impossvel criar entrada de directrio">
	msg	ExtErr83,<"Falha no INT 24">
	msg	ExtErr84,<"Demasiados redireccionamentos">
	msg	ExtErr85,<"Redireccionamento duplo">
	msg	ExtErr86,<"Palavra-passe invlida">
	msg	ExtErr87,<"Parmetro invlido">
	msg	ExtErr88,<"Falha de dados de rede">
	msg	ExtErr89,<"Funo no suportada pela rede">
	msg	ExtErr90,<"Componente de sistema necessrio no instalado">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\pt\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.


	msg     BadVerMsg,   <"Versao incorrecta de DOS",CR,LF>
	msg     OutEnvMsg,   <"Esgotado o espao de ambiente",CR,LF>
	msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg     BadComLkMsg, <"O directrio especificado de procura do COMMAND  invlido",CR,LF>
	msg     BadComAccMsg,<"Negado o acesso ao directrio especificado de procura do COMMAND",CR,LF>

	msg     Help1Msg  <"Inicia uma nova instncia do interpretador de comandos do MS-DOS.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[unidade:]caminho] [dispositivo] [/E:nnnnn] [/P] [/C cadeia] [/MSG]",CR,LF,CR,LF>
	msg     Help3Msg  <"  [unidade:]caminho  Especifica o directrio que contm o ficheiro COMMAND.COM.",CR,LF>
	msg     Help4Msg  <"  dispositivo        Especifica o dispositivo a utilizar para entrada e sada de comandos.",CR,LF>
	msg     Help5Msg  <"  /E:nnnnn           Define o tamanho inicial do ambiente como nnnnn bytes.",CR,LF>
	msg     Help6Msg  <"  /P                 Torna permanente o novo interpretador de comandos (sem exit).",CR,LF>
	msg     Help7Msg  <"  /C cadeia          Executa o comando especificado na cadeia e pra.",CR,LF>
	msg     Help8Msg  <"  /MSG               Especifica que todas as mensagens de erro devem ser armazenadas em memria.",CR,LF>
	msg     Help9Msg  <"                     Tem de especificar /P com este parmetro.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw      RESGROUP:Help9Msg,0

	public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\sv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\tr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\usa\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

	msg	BadVerMsg,   <"Incorrect DOS version",CR,LF>
	msg	OutEnvMsg,   <"Out of environment space",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corp 1990-2001.",CR,LF>
	msg	BadComLkMsg, <"Specified COMMAND search directory bad",CR,LF>
	msg	BadComAccMsg,<"Specified COMMAND search directory bad access denied",CR,LF>

	msg	Help1Msg  <"Starts a new instance of the MS-DOS command interpreter.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [drive:]path    Specifies the directory containing COMMAND.COM file.",CR,LF>
        msg     Help4Msg  <"  device          Specifies the device to use for command input and output.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn        Sets the initial environment size to nnnnn bytes.",CR,LF>
	msg	Help6Msg  <"  /P              Makes the new command interpreter permanent (can't exit).",CR,LF>
	msg	Help7Msg  <"  /C string       Carries out the command specified by string, and then stops.",CR,LF>
	msg	Help8Msg  <"  /MSG            Specifies that all error messages be stored in memory. You",CR,LF>
	msg	Help9Msg  <"                  need to specify /P with this switch.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\pl\comrmsg.inc ===
;***    Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "P"
Retry_Char      db      "O"
Ignore_Char     db      "I"
Fail_Char       db      "Z"
Yes_Char        db      "T"
No_Char         db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

	msg     Req_Abort, <"Przerwij">
	msg     Req_Retry, <", pOnw">
	msg     Req_Ignore,<", Ignoruj">
	msg     Req_Fail,  <", Zrezygnuj">
	msg     Req_End,   <"?">
	msg     MRead,     <"odczytu",0>
	msg     MWrite,    <"zapisu",0>
	msg     BlkDevErr, <" %1 dysk %2",CR,LF>
	msg     CharDevErr,<" %1 urzdzenie %2",CR,LF>
	msg     NeedVolMsg,<"W wolumin %1 seria %2-%3",CR,LF>
	msg     BadFatMsg, <"Uszkodzona tablica alokacji plikw, dysk %1",CR,LF>
    msg     ComBad,    <"Nieprawidowy plik COMMAND.COM",CR,LF>
	msg     PutBackMsg,<"W dysk z %1 do stacji %2",CR,LF>
    msg     Prompt,    <"Nacinij jaki klawisz, aby kontynuowa...",CR,LF>
	msg     EndBatMes, <CR,LF,"Czy zakoczy zadanie w trybie wsadowym (T/N)?">
	msg     ExecEMes,  <"Nie mona wykona %1",CR,LF>
	msg     ExeBad,    <"Bd w pliku EXE",CR,LF>
	msg     TooBig,    <"Program za duy do umieszczenia w pamici",CR,LF>
	msg     NoHandMes, <CR,LF,"Brak wolnych doj do plikw">
	msg     RBadNam,   <"Ze polecenie lub nazwa pliku",CR,LF>
	msg     AccDen,    <"Odmowa dostpu ">
	msg     BMemMes,   <CR,LF,"Bd alokacji pamici">
    msg     HaltMes,   <CR,LF,"Nie mona zaadowa pliku COMMAND, system zosta zatrzymany",CR,LF>
	msg     FRetMes,   <CR,LF,"Nie mona uruchomi pliku COMMAND, koczenie pracy",CR,LF>
	msg     Patricide, <CR,LF,"Proces najwyszego poziomu zosta przerwany, nie mona kontynuowa",CR,LF> 
	msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
	dw      DATARES:ExtMsgPtrs,1    ; extended error messages
	dw      DATARES:ParsMsgPtrs,1   ; parse error messages
	dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
					;  use extended error list
	dw      0,0                     ; file system error messages - none
	dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

	msg     ExtErr19,<"Bd zabezpieczenia przed zapisem">
	msg     ExtErr20,<"Nieprawidowa jednostka">
	msg     ExtErr21,<"Niegotowy">
	msg     ExtErr22,<"Nieprawidowe danie urzdzenia">
	msg     ExtErr23,<"Bd danych">
	msg     ExtErr24,<"Nieprawidowe parametry dania urzdzenia">
	msg     ExtErr25,<"Bd wyszukiwania">
	msg     ExtErr26,<"Nieprawidowy typ nonika">
    msg     ExtErr27,<"Sektor nie znaleziony">
	msg     ExtErr28,<"Bd braku papieru">
	msg     ExtErr29,<"Bd zapisu">
	msg     ExtErr30,<"Bd odczytu">
	msg     ExtErr31,<"Bd oglny">
	msg     ExtErr32,<"Naruszenie wspuytkowania">
	msg     ExtErr33,<"Naruszenie blokady">
	msg     ExtErr34,<"Nieprawidowa zmiana dysku">
	msg     ExtErr35,<"Niedostpny FCB">
	msg     ExtErr36,<"Wyczerpane zasoby systemu">
	msg     ExtErr37,<"Niezgodno stron kodowych">
	msg     ExtErr38,<"Za mao danych wejciowych">
	msg     ExtErr39,<"Za mao miejsca na dysku">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

	msg     ParsErr01,<"Zbyt duo parametrw">
	msg     ParsErr02,<"Brak wymaganego parametru">
	msg     ParsErr03,<"Nieprawidowy przecznik">
	msg     ParsErr04,<"Nieprawidowe sowo kluczowe">
	msg     ParsErr05,<" ">
	msg     ParsErr06,<"Warto parametru poza dozwolonym zakresem">
	msg     ParsErr07,<"Niedozwolona warto parametru">
	msg     ParsErr08,<"Niedozwolona warto parametru">
	msg     ParsErr09,<"Niepoprawny format parametru">
	msg     ParsErr10,<"Nieprawidowy parametr">
	msg     ParsErr11,<"Nieprawidowa kombinacja parametrw">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
	dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

	msg     ExtErr01,<"Nieprawidowa funkcja">
	msg     ExtErr02,<"Nie znaleziono pliku">
	msg     ExtErr03,<"Nie znaleziono cieki">
	msg     ExtErr04,<"Za duo otwartych plikw">
	msg     ExtErr05,<"Brak dostpu ">
	msg     ExtErr06,<"Nieprawidowe dojcie">
    msg     ExtErr07,<"Zniszczone bloki kontroli pamici">
    msg     ExtErr08,<"Za mao pamici">
	msg     ExtErr09,<"Nieprawidowy adres bloku pamici">
	msg     ExtErr10,<"Nieprawidowe rodowisko">
	msg     ExtErr11,<"Nieprawidowy format">
	msg     ExtErr12,<"Nieprawidowy parametr funkcji">
	msg     ExtErr13,<"Nieprawidowe dane">

	msg     ExtErr15,<"Nieprawidowe okrelenie dysku">
	msg     ExtErr16,<"Prba usunicia biecego katalogu">
	msg     ExtErr17,<"Inne urzdzenie">
	msg     ExtErr18,<"Nie ma wicej plikw">

	msg     ExtErr80,<"Plik istnieje">

	msg     ExtErr82,<"Nie mona utworzy wpisu katalogu">
	msg     ExtErr83,<"Bd przerwania 24">
	msg     ExtErr84,<"Zbyt wiele przekierowa">
    msg     ExtErr85,<"Powtrzone przekierowanie">
	msg     ExtErr86,<"Nieprawidowe haso">
	msg     ExtErr87,<"Nieprawidowy parametr">
	msg     ExtErr88,<"Bd danych sieci">
	msg     ExtErr89,<"Funkcja nie jest obsugiwana przez sie">
    msg     ExtErr90,<"Wymagany skadnik systemu nie jest zainstalowany">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.  
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
	dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw      80-40 dup (0) ; null ptrs for errors 40-79
	dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\usa\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"Abort">
	msg	Req_Retry, <", Retry">
	msg	Req_Ignore,<", Ignore">
	msg	Req_Fail,  <", Fail">
	msg	Req_End,   <"?">
	msg	MRead,	   <"reading",0>
	msg	MWrite,	   <"writing",0>
	msg	BlkDevErr, <" %1 drive %2",CR,LF>
	msg	CharDevErr,<" %1 device %2",CR,LF>
	msg	NeedVolMsg,<"Please insert volume %1 serial %2-%3",CR,LF>
	msg	BadFatMsg, <"File allocation table bad, drive %1",CR,LF>
	msg	ComBad,	   <"Invalid COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"Insert disk with %1 in drive %2",CR,LF>
	msg	Prompt,	   <"Press any key to continue . . .",CR,LF>
	msg	EndBatMes, <CR,LF,"Terminate batch job (Y/N)?">
	msg	ExecEMes,  <"Cannot execute %1",CR,LF>
	msg	ExeBad,	   <"Error in EXE file",CR,LF>
	msg	TooBig,	   <"Program too big to fit in memory",CR,LF>
	msg	NoHandMes, <CR,LF,"No free file handles">
	msg	RBadNam,   <"Bad Command or file name",CR,LF>
	msg	AccDen,	   <"Access denied ">
	msg	BMemMes,   <CR,LF,"Memory allocation error">
	msg	HaltMes,   <CR,LF,"Cannot load COMMAND, system halted",CR,LF>
	msg	FRetMes,   <CR,LF,"Cannot start COMMAND, exiting",CR,LF>
	msg	Patricide, <CR,LF,"Top level process aborted, cannot continue",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Write protect error">
	msg	ExtErr20,<"Invalid unit">
	msg	ExtErr21,<"Not ready">
	msg	ExtErr22,<"Invalid device request">
	msg	ExtErr23,<"Data error">
	msg	ExtErr24,<"Invalid device request parameters">
	msg	ExtErr25,<"Seek error">
	msg	ExtErr26,<"Invalid media type">
	msg	ExtErr27,<"Sector not found">
	msg	ExtErr28,<"Printer out of paper error">
	msg	ExtErr29,<"Write fault error">
	msg	ExtErr30,<"Read fault error">
	msg	ExtErr31,<"General failure">
	msg	ExtErr32,<"Sharing violation">
	msg	ExtErr33,<"Lock violation">
	msg	ExtErr34,<"Invalid disk change">
	msg	ExtErr35,<"FCB unavailable">
	msg	ExtErr36,<"System resource exhausted">
	msg	ExtErr37,<"Code page mismatch">
	msg	ExtErr38,<"Out of input">
	msg	ExtErr39,<"Insufficient disk space">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"Too many parameters">
	msg	ParsErr02,<"Required parameter missing">
	msg	ParsErr03,<"Invalid switch">
	msg	ParsErr04,<"Invalid keyword">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Parameter value not in allowed range">
	msg	ParsErr07,<"Parameter value not allowed">
	msg	ParsErr08,<"Parameter value not allowed">
	msg	ParsErr09,<"Parameter format not correct">
	msg	ParsErr10,<"Invalid parameter">
	msg	ParsErr11,<"Invalid parameter combination">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Invalid function">
	msg	ExtErr02,<"File not found">
	msg	ExtErr03,<"Path not found">
	msg	ExtErr04,<"Too many open files">
	msg	ExtErr05,<"Access denied ">
	msg	ExtErr06,<"Invalid handle">
	msg	ExtErr07,<"Memory control blocks destroyed">
	msg	ExtErr08,<"Insufficient memory">
	msg	ExtErr09,<"Invalid memory block address">
	msg	ExtErr10,<"Invalid Environment">
	msg	ExtErr11,<"Invalid format">
	msg	ExtErr12,<"Invalid function parameter">
	msg	ExtErr13,<"Invalid data">

	msg	ExtErr15,<"Invalid drive specification">
	msg	ExtErr16,<"Attempt to remove current directory">
	msg	ExtErr17,<"Not same device">
	msg	ExtErr18,<"No more files">

	msg	ExtErr80,<"File exists">

	msg	ExtErr82,<"Cannot make directory entry">
	msg	ExtErr83,<"Fail on INT 24">
	msg	ExtErr84,<"Too many redirections">
	msg	ExtErr85,<"Duplicate redirection">
	msg	ExtErr86,<"Invalid password">
	msg	ExtErr87,<"Invalid parameter">
	msg	ExtErr88,<"Network data fault">
	msg	ExtErr89,<"Function not supported by network">
	msg	ExtErr90,<"Required system component not installed">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\ru\comrmsg.inc ===
;***    Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "A"
Retry_Char      db      "R"
Ignore_Char     db      "I"
Fail_Char       db      "F"
Yes_Char        db      "Y"
No_Char         db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

	msg     Req_Abort, <"Abort (⮯)">
	msg     Req_Retry, <", Retry ()">
	msg     Req_Ignore,<", Ignore (ய)">
	msg     Req_Fail,  <", Fail ()">
	msg     Req_End,   <"?">
	msg     MRead,     <"⥭",0>
	msg     MWrite,    <"",0>
	msg     BlkDevErr, <" %1  %2",CR,LF>
	msg     CharDevErr,<" %1 ன⢮ %2",CR,LF>
	msg     NeedVolMsg,<"⠢ ⮬ %1, ਩  %2-%3",CR,LF>
	msg     BadFatMsg, <"ᯮ祭 ⠡ ࠧ饭 䠩 (FAT)  ᪥ %1",CR,LF>
	msg     ComBad,    <"ࠢ COMMAND.COM",CR,LF>
	msg     PutBackMsg,<"⠢   %1  ᪮ %2",CR,LF>
	msg     Prompt,    <"  ...",CR,LF>
	msg     EndBatMes, <CR,LF,"४ 믮 ⭮  [Y()/N()]?">
	msg     ExecEMes,  <" 㤠 믮 %1",CR,LF>
	msg     ExeBad,    <"訡  EXE-䠩",CR,LF>
	msg     TooBig,    <"ணࠬ  㬥頥  ",CR,LF>
	msg     NoHandMes, <CR,LF," ᢮ ਯ஢ 䠩">
	msg     RBadNam,   <"ࠢ쭠    䠩",CR,LF>
	msg     AccDen,    <" 㯠 ">
	msg     BMemMes,   <CR,LF,"訡  뤥 ">
	msg     HaltMes,   <CR,LF," 㤠 㧨 COMMAND.COM, ⥬ ⠭",CR,LF>
	msg     FRetMes,   <CR,LF," 㤠  COMMAND.COM, 襭 ࠡ",CR,LF>
	msg     Patricide, <CR,LF,"ࢠ  孥 ஢, த ",CR,LF> 
	msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
	dw      DATARES:ExtMsgPtrs,1    ; extended error messages
	dw      DATARES:ParsMsgPtrs,1   ; parse error messages
	dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
					;  use extended error list
	dw      0,0                     ; file system error messages - none
	dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

	msg     ExtErr19,<"訡   ">
	msg     ExtErr20,<"ࠢ쭮 ன⢮">
	msg     ExtErr21,<" ⮢">
	msg     ExtErr22,<"ࠢ   ன">
	msg     ExtErr23,<"訡  ">
	msg     ExtErr24,<"ࠢ 㬥   ன">
	msg     ExtErr25,<"訡 ᪠">
	msg     ExtErr26,<"ࠢ ⨯ ⥫">
	msg     ExtErr27,<"  ">
	msg     ExtErr28,<" ਭ  㬠">
	msg     ExtErr29,<"訡  ">
	msg     ExtErr30,<"訡  ⥭">
	msg     ExtErr31,<"騩 ᡮ ⥬">
	msg     ExtErr32,<"襭 ० ᮢ⭮ 㯠">
	msg     ExtErr33,<"襭 ஢">
	msg     ExtErr34,<"ࠢ쭠 ᬥ ᪠">
	msg     ExtErr35,<"㯥 FCB ( ࠢ 䠩)">
	msg     ExtErr36,<" ⥬ ௠">
	msg     ExtErr37,<"ᮮ⢥⢨  ࠭">
	msg     ExtErr38,<"筮  ">
	msg     ExtErr39,<"筮   ᪥">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

	msg     ParsErr01,<"誮  ࠬ஢">
	msg     ParsErr02,<" 易⥫ ࠬ">
	msg     ParsErr03,<"ࠢ ࠬ">
	msg     ParsErr04,<"ࠢ쭮 祢 ᫮">
	msg     ParsErr05,<" ">
	msg     ParsErr06,<"祭 ࠬ 室  । ⨬ ">
	msg     ParsErr07,<"⨬ 祭 ࠬ">
	msg     ParsErr08,<"⨬ 祭 ࠬ">
	msg     ParsErr09,<"ࠢ ଠ ࠬ">
	msg     ParsErr10,<"ࠢ ࠬ">
	msg     ParsErr11,<"ࠢ쭮 ⠭ ࠬ஢">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
	dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

	msg     ExtErr01,<"ࠢ쭠 㭪">
	msg     ExtErr02,<"  ">
	msg     ExtErr03,<"  ">
	msg     ExtErr04,<" ᫨誮  䠩">
	msg     ExtErr05,<" 㯠 ">
	msg     ExtErr06,<"ࠢ ਯ">
	msg     ExtErr07,<"ᯮ祭  ࠢ ">
	msg     ExtErr08,<"筮 ">
	msg     ExtErr09,<"ࠢ   ">
	msg     ExtErr10,<"訡  ६ । (Environment)">
	msg     ExtErr11,<"ࠢ ଠ">
	msg     ExtErr12,<"ࠢ ࠬ 㭪樨">
	msg     ExtErr13,<"ࠢ ">

	msg     ExtErr15,<"ࠢ쭮  ">
	msg     ExtErr16,<"⪠ 㤠 ⥪騩 ⠫">
	msg     ExtErr17,<"㣮 ன⢮">
	msg     ExtErr18,<" ">

	msg     ExtErr80,<" ">

	msg     ExtErr82,<" 㤠 ᮧ  ⠫">
	msg     ExtErr83,<"訡  饭  뢠 INT 24">
	msg     ExtErr84,<"誮 讥 ᫮ ॠ権">
	msg     ExtErr85,<" ॠ">
	msg     ExtErr86,<"ࠢ ஫">
	msg     ExtErr87,<"ࠢ ࠬ">
	msg     ExtErr88,<"訡   ">
	msg     ExtErr89,<"㭪  ন ">
	msg     ExtErr90,<"ॡ㥬  ⥬  ⠭">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.  
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
	dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw      80-40 dup (0) ; null ptrs for errors 40-79
	dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\sv\comimsg.inc ===
;       Command.com initialization messages.
;
;       See resmsg.equ for macro definition.

	msg     BadVerMsg,   <"Felaktig DOS-version",CR,LF>
        msg     OutEnvMsg,   <"Det finns inte tillrckligt med ledigt minne i den aktuella miljn",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Copyright Microsoft Corporation 1990-2001.",CR,LF>
	msg     BadComLkMsg, <"Felaktig skvg fr COMMAND.COM",CR,LF>
	msg     BadComAccMsg,<"Felaktig skvg fr COMMAND.COM. tkomst nekad",CR,LF>

	msg     Help1Msg  <"Startar en ny instans av kommandotolken.",CR,LF,CR,LF>
	msg     Help2Msg  <"COMMAND [[enhet:]skvg] [enhet] [/E:nnnnn] [/P] [/C strng] [/MEDD]",CR,LF,CR,LF>
	msg     Help3Msg  <"  [enhet:]skvg  Anger skvg fr filen COMMAND.COM.",CR,LF>
	msg     Help4Msg  <"  enhet           Anger om ngon extern enhet ska anvndas fr I/O.",CR,LF>
	msg     Help5Msg  <"  /E:nnnnn        Anger initial miljstorlek till nnnnn byte.",CR,LF>
	msg     Help6Msg  <"  /P              Gr den nya kommandotolken permanent (kan inte avbrytas).",CR,LF>
	msg     Help7Msg  <"  /C strng       Utfr kommandot som anges med strng och avbryter sedan.",CR,LF>
	msg     Help8Msg  <"  /MEDD           Anger att alla felmeddelanden lagras i minnet. ",CR,LF>
	msg     Help9Msg  <"                  Vxeln /P mste anvndas med denna vxel.",CR,LF>

HelpMsgs        dw      RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw      RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw      RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw      RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw      RESGROUP:Help9Msg,0

	public  HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\sv\comrmsg.inc ===
;***    Translateable text for command.com resident data.


;*      Input characters for critical error "Abort, Retry, Fail, Ignore?"
;       and Yes/No.

Abort_Char      db      "A"
Retry_Char      db      "N"
Ignore_Char     db      "I"
Fail_Char       db      "F"
Yes_Char        db      "J"
No_Char         db      "N"


;*      MESSAGES
;
;       See resmsg.equ for macro definition.


;*      Local messages.

	msg     Req_Abort, <"Avbryt">
	msg     Req_Retry, <", Nytt frsk">
	msg     Req_Ignore,<", Ignorera">
	msg     Req_Fail,  <", Fortstt">
	msg     Req_End,   <"?">
        msg     MRead,     <"vid lsning av",0>
        msg     MWrite,    <"vid skrivning av",0>
	msg     BlkDevErr, <" %1 enhet %2",CR,LF>
	msg     CharDevErr,<" %1 enhet %2",CR,LF>
	msg     NeedVolMsg,<"Stt in volymen %1 med serienummer %2-%3",CR,LF>
	msg     BadFatMsg, <"Filallokeringstabellen (FAT) p enhet %1 r skadad.",CR,LF>
	msg     ComBad,    <"Felaktig COMMAND.COM",CR,LF>
	msg     PutBackMsg,<"Mata in disketten med %1 i enhet %2",CR,LF>
	msg     Prompt,    <"Tryck p valfri tangent fr att fortstta . . .",CR,LF>
	msg     EndBatMes, <CR,LF,"Vill du avsluta kommandofilen (J/N)?">
	msg     ExecEMes,  <"Det gr inte att kra %1",CR,LF>
	msg     ExeBad,    <"Fel i EXE-filen",CR,LF>
	msg     TooBig,    <"Programmet r fr stort fr minnet",CR,LF>
	msg     NoHandMes, <CR,LF,"Det finns inte ngra lediga filreferenser (handles)">
	msg     RBadNam,   <"Felaktigt kommando eller filnamn",CR,LF>
	msg     AccDen,    <"tkomst nekad ">
	msg     BMemMes,   <CR,LF,"Minnesallokeringsfel">
	msg     HaltMes,   <CR,LF,"Det gr inte att lsa in COMMAND.COM. Systemet avbrts",CR,LF>
	msg     FRetMes,   <CR,LF,"Det gr inte att starta COMMAND.COM. Systemet avlustas",CR,LF>
	msg     Patricide, <CR,LF,"Process p toppniv avbrts. Det gr inte att fortstta",CR,LF> 
	msg     Newlin,    <CR,LF>

;*      Ptrs to message lists.
;       Segment portion is 1, signalling message services to call retriever.

MsgPtrLists     label   dword
	dw      DATARES:ExtMsgPtrs,1    ; extended error messages
	dw      DATARES:ParsMsgPtrs,1   ; parse error messages
	dw      DATARES:ExtMsgPtrs,1    ; critical error messages -
					;  use extended error list
	dw      0,0                     ; file system error messages - none
	dw      DATARES:MsgRetrv_Trap           ; address of message retriever
MySeg3  dw      ?                       ;  (segment filled in during init)



;*      Critical error messages.

	msg     ExtErr19,<"Skrivskyddsfel">
	msg     ExtErr20,<"Felaktig enhet">
	msg     ExtErr21,<"Inte klar">
	msg     ExtErr22,<"Felaktig enhetsbegran">
	msg     ExtErr23,<"Datafel">
	msg     ExtErr24,<"Felaktiga parametrar fr enhetsbegran">
	msg     ExtErr25,<"Skfel">
	msg     ExtErr26,<"Felaktig mediatyp">
	msg     ExtErr27,<"Hittar inte sektor">
	msg     ExtErr28,<"Slut p papper i skrivaren">
	msg     ExtErr29,<"Skrivfel">
	msg     ExtErr30,<"Lsfel">
	msg     ExtErr31,<"Allmnt fel">
	msg     ExtErr32,<"Fildelningsfel">
	msg     ExtErr33,<"Lsningsfel (vertrdelse)">
	msg     ExtErr34,<"Felaktigt diskbyte">
	msg     ExtErr35,<"FCB otillgnglig">
	msg     ExtErr36,<"Systemresurserna r uttmda">
	msg     ExtErr37,<"Teckentabell: matchningsfel">
	msg     ExtErr38,<"Slut p indata">
	msg     ExtErr39,<"Det saknas diskutrymme">

;       List of ptrs to critical error messages.
;       Code assumes extended error number order, beginning
;       with extended error number 19.

CritMsgPtrs     label   word
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd      label   byte    ; end of resident portion if /msg not used



;*      Parse error messages.

	msg     ParsErr01,<"Fr mnga parametrar">
        msg     ParsErr02,<"En ndvndig parameter saknas">
	msg     ParsErr03,<"Felaktig vxel">
	msg     ParsErr04,<"Felaktigt nyckelord">
	msg     ParsErr05,<" ">
	msg     ParsErr06,<"Parametervrdet r utanfr tilltet intervall">
	msg     ParsErr07,<"Otilltet parametervrde">
	msg     ParsErr08,<"Otilltet parametervrde">
	msg     ParsErr09,<"Felaktigt parameterformat">
	msg     ParsErr10,<"Felaktig parameter">
	msg     ParsErr11,<"Felaktig parameterkombination">

;       List of ptrs to parse error messages.
;       In order, beginning with parse error number 1.

ParsMsgPtrs     label   word
	dw      DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw      DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw      DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw      DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS     equ     ($ - ParsMsgPtrs) / 2   ;M033


;*      Extended error messages.

	msg     ExtErr01,<"Felaktig funktion">
	msg     ExtErr02,<"Filen kan inte hittas">
	msg     ExtErr03,<"Skvgen kan inte hittas">
	msg     ExtErr04,<"Fr mnga filer r ppna">
	msg     ExtErr05,<"tkomst nekad ">
	msg     ExtErr06,<"Felaktig referens">
	msg     ExtErr07,<"Kontrollblock fr minnet frstrda">
	msg     ExtErr08,<"Otillrckligt med minne">
	msg     ExtErr09,<"Felaktig adress fr minnesblocket">
	msg     ExtErr10,<"Felaktig milj">
	msg     ExtErr11,<"Felaktigt format">
	msg     ExtErr12,<"Felaktig funktionsparameter">
	msg     ExtErr13,<"Felaktiga data">

	msg     ExtErr15,<"Felaktig enhetsangivelse">
	msg     ExtErr16,<"Frsk gjordes att bort den aktuella katalogen">
	msg     ExtErr17,<"Inte samma enhet">
	msg     ExtErr18,<"Inga fler filer">

	msg     ExtErr80,<"Filen finns redan">

	msg     ExtErr82,<"Det gr inte att skapa katalogpost">
	msg     ExtErr83,<"Fel uppstod p INT 24">
	msg     ExtErr84,<"Fr mnga omdirigeringar">
	msg     ExtErr85,<"Duplicerad omdirigering">
	msg     ExtErr86,<"Felaktigt lsenord">
	msg     ExtErr87,<"Felaktig parameter">
	msg     ExtErr88,<"Datafel - ntverk">
	msg     ExtErr89,<"Funktionen stds inte av ntverket">
        msg     ExtErr90,<"En systemkomponent som krvs saknas">

;       List of ptrs to extended error messages.
;       In order, beginning with extended error number 1.
;       Critical error messages are included here, as well as in the
;       critical error message list.  
;       Error numbers without messages are included as null ptrs.

ExtMsgPtrs      label   word
	dw      DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw      DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw      DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw      DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw      DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw      DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw      DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw      DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw      DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw      DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw      DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw      DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw      DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw      80-40 dup (0) ; null ptrs for errors 40-79
	dw      DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw      DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw      DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw      DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd   label   word

NUMEXTMSGS      equ     ($ - ExtMsgPtrs) / 2    ;M033

ExtMsgEnd       label   byte    ; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\tr\comimsg.inc ===
;	Command.com initialization messages.
;
;	See resmsg.equ for macro definition.

	msg	BadVerMsg,   <"Yanl DOS srm",CR,LF>
	msg	OutEnvMsg,   <"Ortam alan bitti",CR,LF>
        msg     CopyrightMsg,<"Microsoft(R) Windows DOS",CR,LF,"(C)Telif Hakk Microsoft Corp 1990-2001.",CR,LF>
	msg	BadComLkMsg, <" Belirtilen COMMAND arama dizini bozuk",CR,LF>
	msg	BadComAccMsg,<" Belirtilen COMMAND arama dizini bozuk, eriim engellendi",CR,LF>

	msg	Help1Msg  <"Yeni bir MS-DOS komut yorumlaycs kopyasn balatr.",CR,LF,CR,LF>
	msg	Help2Msg  <"COMMAND [[src:]yol] [aygt] [/E:nnnnn] [/P] [/C dize] [/MSG]",CR,LF,CR,LF>
	msg	Help3Msg  <"  [src:]yol    COMMAND.COM dosyasn ieren dizini belirtir.",CR,LF>
        msg     Help4Msg  <"  aygt           Komut girii ve k iin kullanlacak aygt belirtir.",CR,LF>
	msg	Help5Msg  <"  /E:nnnnn        Balang ortam boyutunu nnnnn bayta ayarlar.",CR,LF>
	msg	Help6Msg  <"  /P              Yeni komut yorumlaycsn kalc yapar (kamaz).",CR,LF>
	msg	Help7Msg  <"  /C string       Dizede belirtilen komutu yerine getirir ve durur.",CR,LF>
	msg	Help8Msg  <"  /MSG            Tm hata iletilerinin bellekte tutulmasn belirtir. Bu",CR,LF>
	msg	Help9Msg  <"                  anahtarla birlikte /P belirtmelisiniz.",CR,LF>

HelpMsgs	dw	RESGROUP:Help1Msg,RESGROUP:Help2Msg
		dw	RESGROUP:Help3Msg,RESGROUP:Help4Msg
		dw	RESGROUP:Help5Msg,RESGROUP:Help6Msg
		dw	RESGROUP:Help7Msg,RESGROUP:Help8Msg
		dw	RESGROUP:Help9Msg,0

	public	HelpMsgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\messages\tr\comrmsg.inc ===
;***	Translateable text for command.com resident data.


;*	Input characters for critical error "Abort, Retry, Fail, Ignore?"
;	and Yes/No.

Abort_Char	db	"A"
Retry_Char	db	"R"
Ignore_Char	db	"I"
Fail_Char	db	"F"
Yes_Char	db	"Y"
No_Char 	db	"N"


;*	MESSAGES
;
;	See resmsg.equ for macro definition.


;*	Local messages.

	msg	Req_Abort, <"ptal et">
	msg	Req_Retry, <", Yeniden dene">
	msg	Req_Ignore,<", Yoksay">
	msg	Req_Fail,  <", Fail">
	msg	Req_End,   <"?">
	msg	MRead,	   <"okuyor",0>
	msg	MWrite,	   <"yazyor",0>
	msg	BlkDevErr, <" %1 src %2",CR,LF>
	msg	CharDevErr,<" %1 src %2",CR,LF>
	msg	NeedVolMsg,<"Ltfen birim %1 seri %2-%3 yerletirin",CR,LF>
	msg	BadFatMsg, <"Dosya ayrma tablosu bozuk, src %1",CR,LF>
	msg	ComBad,	   <"Geersiz COMMAND.COM",CR,LF>
	msg	PutBackMsg,<"%1 bulunduran diski %2 srcsne yerletirin",CR,LF>
	msg	Prompt,	   <" Devam etmek iin bir tua basn . . .",CR,LF>
	msg	EndBatMes, <CR,LF," Toplu i sonlandrlsn m (E/H)?">
	msg	ExecEMes,  <"%1 altrlamyor",CR,LF>
	msg	ExeBad,	   <"EXE dosyasnda hata",CR,LF>
	msg	TooBig,	   <"Program bellee smayacak kadar byk",CR,LF>
	msg	NoHandMes, <CR,LF,"Bo dosya ileyicisi yok">
	msg	RBadNam,   <"Bozuk komut veya dosya ad",CR,LF>
	msg	AccDen,	   <"Eriim engellendi">
	msg	BMemMes,   <CR,LF,"Bellek ayrma hatas">
	msg	HaltMes,   <CR,LF,"COMMAND yklenemiyor, sistem durdu",CR,LF>
	msg	FRetMes,   <CR,LF,"COMMAND balatlamyor, klyor",CR,LF>
	msg	Patricide, <CR,LF,"st dzey ilem durduruldu, devam edilemiyor",CR,LF> 
	msg	Newlin,	   <CR,LF>

;*	Ptrs to message lists.
;	Segment portion is 1, signalling message services to call retriever.

MsgPtrLists	label	dword
	dw	DATARES:ExtMsgPtrs,1	; extended error messages
	dw	DATARES:ParsMsgPtrs,1	; parse error messages
	dw	DATARES:ExtMsgPtrs,1	; critical error messages -
					;  use extended error list
	dw	0,0			; file system error messages - none
	dw	DATARES:MsgRetrv_Trap		; address of message retriever
MySeg3	dw	?			;  (segment filled in during init)



;*	Critical error messages.

	msg	ExtErr19,<"Yazma koruma hatas">
	msg	ExtErr20,<"Geersiz birim">
	msg	ExtErr21,<"Hazr deil">
	msg	ExtErr22,<"Geersiz aygt istei">
	msg	ExtErr23,<"Veri hatas">
	msg	ExtErr24,<"Geersiz veri istei parametreleri">
	msg	ExtErr25,<"Arama hatas">
	msg	ExtErr26,<"Geersiz ortam tr">
	msg	ExtErr27,<"Kesim bulunamad">
	msg	ExtErr28,<"Yazc kad bitti hatas">
	msg	ExtErr29,<"Yazma hatas">
	msg	ExtErr30,<"Okuma hatas">
	msg	ExtErr31,<"Genel hata">
	msg	ExtErr32,<"Paylam ihlali">
	msg	ExtErr33,<"Kilit ihlali">
	msg	ExtErr34,<"Geersiz disk deiiklii">
	msg	ExtErr35,<"FCB kullanlamyor">
	msg	ExtErr36,<"Sistem kaynaklar tkendi">
	msg	ExtErr37,<"Kod sayfas uyumazl">
	msg	ExtErr38,<"Giri bitti">
	msg	ExtErr39,<"Yetersiz disk alan">

;	List of ptrs to critical error messages.
;	Code assumes extended error number order, beginning
;	with extended error number 19.

CritMsgPtrs	label	word
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21,DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27,DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33,DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39

DataResEnd	label	byte	; end of resident portion if /msg not used



;*	Parse error messages.

	msg	ParsErr01,<"ok fazla parametre">
	msg	ParsErr02,<"Gerekli parametre eksik">
	msg	ParsErr03,<"Geersiz anahtar">
	msg	ParsErr04,<"Geersiz anahtar szck">
	msg	ParsErr05,<" ">
	msg	ParsErr06,<"Parametre deeri izin verilen aralkta deil">
	msg	ParsErr07,<"Parametre deerine izin verilmiyor">
	msg	ParsErr08,<"Parametre deerine izin verilmiyor">
	msg	ParsErr09,<"Parametre biimi doru deil">
	msg	ParsErr10,<"Geersiz parametre">
	msg	ParsErr11,<"Geersiz parametre bileimi">

;	List of ptrs to parse error messages.
;	In order, beginning with parse error number 1.

ParsMsgPtrs	label	word
	dw	DATARES:ParsErr01,DATARES:ParsErr02,DATARES:ParsErr03
	dw	DATARES:ParsErr04,DATARES:ParsErr05,DATARES:ParsErr06
	dw	DATARES:ParsErr07,DATARES:ParsErr08,DATARES:ParsErr09
	dw	DATARES:ParsErr10,DATARES:ParsErr11

NUMPARSMSGS	equ	($ - ParsMsgPtrs) / 2	;M033


;*	Extended error messages.

	msg	ExtErr01,<"Geersiz ilev">
	msg	ExtErr02,<"Dosya bulunamad">
	msg	ExtErr03,<"Yol bulunamad">
	msg	ExtErr04,<"ok fazla ak dosya">
	msg	ExtErr05,<"Eriim engellendi">
	msg	ExtErr06,<"Geersiz ileyici">
	msg	ExtErr07,<"Bellek denetim bloklar bozulmu">
	msg	ExtErr08,<"Yetersiz bellek">
	msg	ExtErr09,<"Geersiz bellek blou adresi">
	msg	ExtErr10,<"Geersiz Ortam">
	msg	ExtErr11,<"Geersiz biim">
	msg	ExtErr12,<"Geersiz ilev parametresi">
	msg	ExtErr13,<"Geersiz veri">

	msg	ExtErr15,<"Geersiz src tanmlamalar">
	msg	ExtErr16,<"Geerli dizini kaldrma giriimi">
	msg	ExtErr17,<"Ayn aygt deil">
	msg	ExtErr18,<"Baka dosya yok">

	msg	ExtErr80,<"Dosya var">

	msg	ExtErr82,<"Dizin girdisi yaplamyor">
	msg	ExtErr83,<"INT 24 iin hata">
	msg	ExtErr84,<"ok fazla yeniden ynlendirme">
	msg	ExtErr85,<"ift yeniden ynlendirme">
	msg	ExtErr86,<"Geersiz parola">
	msg	ExtErr87,<"Geersiz parametre">
	msg	ExtErr88,<"A veri hatas">
	msg	ExtErr89,<"lev a tarafndan desteklenmiyor">
	msg	ExtErr90,<"Gerekli sistem bileeni ykl deil">

;	List of ptrs to extended error messages.
;	In order, beginning with extended error number 1.
;	Critical error messages are included here, as well as in the
;	critical error message list.  
;	Error numbers without messages are included as null ptrs.

ExtMsgPtrs	label	word
	dw	DATARES:ExtErr01,DATARES:ExtErr02,DATARES:ExtErr03
	dw	DATARES:ExtErr04,DATARES:ExtErr05,DATARES:ExtErr06
	dw	DATARES:ExtErr07,DATARES:ExtErr08,DATARES:ExtErr09
	dw	DATARES:ExtErr10,DATARES:ExtErr11,DATARES:ExtErr12
	dw	DATARES:ExtErr13,0,                DATARES:ExtErr15
	dw	DATARES:ExtErr16,DATARES:ExtErr17,DATARES:ExtErr18
	dw	DATARES:ExtErr19,DATARES:ExtErr20,DATARES:ExtErr21
	dw	DATARES:ExtErr22,DATARES:ExtErr23,DATARES:ExtErr24
	dw	DATARES:ExtErr25,DATARES:ExtErr26,DATARES:ExtErr27
	dw	DATARES:ExtErr28,DATARES:ExtErr29,DATARES:ExtErr30
	dw	DATARES:ExtErr31,DATARES:ExtErr32,DATARES:ExtErr33
	dw	DATARES:ExtErr34,DATARES:ExtErr35,DATARES:ExtErr36
	dw	DATARES:ExtErr37,DATARES:ExtErr38,DATARES:ExtErr39
	dw	80-40 dup (0) ; null ptrs for errors 40-79
	dw	DATARES:ExtErr80,0,                DATARES:ExtErr82
	dw	DATARES:ExtErr83,DATARES:ExtErr84,DATARES:ExtErr85
	dw	DATARES:ExtErr86,DATARES:ExtErr87,DATARES:ExtErr88
	dw	DATARES:ExtErr89,DATARES:ExtErr90
ExtMsgPtrsEnd	label	word

NUMEXTMSGS	equ	($ - ExtMsgPtrs) / 2	;M033

ExtMsgEnd	label	byte	; end of extended error messages
				; = end of resident if /msg is used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\fudgedef.inc ===
; this file contains definitions I really need to get from elsewhere, but
; can't be bothered looking for the nonce. Find 'em when everything;s working

if1
%out NB: Included fudgedef.inc: Replace with proper includes at my leisure
endif

cr              equ     0dh
lf              equ     0ah
major_version   equ     30              ; of DOS
LM20_CNLEN      equ     15
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\enumapis.inc ===
;****************************************************************   
;**                  Microsoft LAN Manager                      *   
;**            Copyright(c) Microsoft Corp., 1990               *   
;****************************************************************   
;***    enumapis.h
;*
;*      This file contains the subfunctions for the loadable APIs in the
;*      REDIR 1.5 project
;  
REDIRBASEFUNCTION	EQU	5f00H 
BADFUNCTION	EQU	0FFFFH 
UseWkstaPass	EQU	80H 
Local_API_ReturnMode	EQU	00H 
Local_API_SetMode	EQU	01H 
Local_API_GetAsgList	EQU	02H 
Local_API_Define	EQU	03H 
Local_API_BREAK_MAC	EQU	04H 
Local_API_GetAsgList2	EQU	05H 
Local_API_RedirGetVersion	EQU	30H 
Local_API_NetWkstaSetUID	EQU	31H 
Local_API_DosQNmPipeInfo	EQU	32H 
Local_API_DosQNmPHandState	EQU	33H 
Local_API_DosSetNmPHandState	EQU	34H 
Local_API_DosPeekNmPipe	EQU	35H 
Local_API_DosTransactNmPipe	EQU	36H 
Local_API_DosCallNmPipe	EQU	37H 
Local_API_DosWaitNmPipe	EQU	38H 
Local_API_DosRawReadNmPipe	EQU	39H 
Local_API_DosRawWriteNmPipe	EQU	3aH 
Local_API_NetHandleSetInfo	EQU	3bH 
Local_API_NetHandleGetInfo	EQU	3cH 
Local_API_NetTransact	EQU	3dH 
Local_API_NetSpecialSMB	EQU	3eH 
Local_API_NetIRemoteAPI	EQU	3fH 
Local_API_NetMessageBufferSend	EQU	40H 
Local_API_NetServiceEnum	EQU	41H 
Local_API_NetServiceControl	EQU	42H 
Local_API_DosPrintJobGetID	EQU	43H 
Local_API_NetWkstaGetInfo	EQU	44H 
Local_API_NetWkstaSetInfo	EQU	45H 
Local_API_NetUseEnum	EQU	46H 
Local_API_NetUseAdd	EQU	47H 
Local_API_NetUseDel	EQU	48H 
Local_API_NetUseGetInfo	EQU	49H 
Local_API_NetRemoteCopy	EQU	4aH 
Local_API_NetRemoteMove	EQU	4bH 
Local_API_NetServerEnum	EQU	4cH 
Local_API_DosMakeMailslot	EQU	4dH 
Local_API_DosDeleteMailslot	EQU	4eH 
Local_API_DosMailslotInfo	EQU	4fH 
Local_API_DosReadMailslot	EQU	50H 
Local_API_DosPeekMailslot	EQU	51H 
Local_API_DosWriteMailslot	EQU	52H 
Local_API_NetServerEnum2	EQU	53H 
Local_API_NullTransact	EQU	54H 
;       NOTE:: Remove_Network_Connections is a private call to allow the
;*      NetSetUserName INT 2F to remove network connections.
;  
Local_API_Remove_Network_Connections	EQU	55H 
;       NOTE:: Process_Interrogate is a private call to allow the
;*      redirector to kick itself from INT 28 and INT 8 to process relogon
;*      requests.
;  
Local_API_Periodic_View_Tasks	EQU	56H 
Local_API_Set_LongName	EQU	57H 
Local_API_Start_Redir_On_Net	EQU	58H 
Local_API_Stop_Redir_per_Net	EQU	59H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\debugmac.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    debugmac.inc
;
;Abstract:
;
;    Contains debugging macros:
;
;       DbgBreakPoint
;       DbgUnsupported
;       DbgDEBUG
;       DbgPrint
;       DbgPrintTty
;       DbgPrintString
;       DbgPrintHexDword
;       DbgPrintHexWord
;       DbgPrintHexByte
;       DbgPrintNearPointer
;       DbgPrintFarPointer
;
;Author:
;
;    Richard L Firth (rfirth) 13-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;[Notes:]
;
;    optional-notes
;
;Revision History:
;
;    13-Sep-1991 rfirth
;        Created
;
;--


;***    DbgBreakPoint
;*
;*      Same as NT routine of same name. No-op in non-DEBUG version
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgBreakPoint macro
if DEBUG
        int     3
endif
endm

;***    DbgUnsupported
;*
;*      Causes the 32-bit support code to display a message about an unsupported
;*      service code, and dumps the 16-bit registers. Used to discover when an
;*      unsupported int 2f/11 call or int 21/5f call is being made
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgUnsupported macro
if DEBUG
        SVC     -1
endif
endm

;***    DbgDEBUG
;*
;*      Prints the string "DEBUG: " to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    ax
;*
;*      ASSUMES 286+
;*
;***

DbgDEBUG macro
        mov     ax,(14 shl 8) + 'D'
ifndef NEC_98                ;Delete int 10h
        int     10h
        mov     al,'E'
        int     10h
        mov     al,'B'
        int     10h
        mov     al,'U'
        int     10h
        mov     al,'G'
        int     10h
        mov     al,':'
        int     10h
        mov     al,' '
        int     10h
endif ;NEC_98
endm



;***    DbgCrLf
;*
;*      Prints CR,LF to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgCrLf macro
        push    ax
        mov     ax,(14 shl 8) + 13
ifndef NEC_98
        int     10h
        mov     al,10
        int     10h
endif ;NEC_98
        pop     ax
endm



;***    DbgPrint
;*
;*      Prints an ASCIZ string to console using Bios Int 10h
;*
;*      ENTRY   string  - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrint macro string
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; save regs used by DbgPrintTty
        push    ax
        push    bx
        push    si
        push    ds
        mov     ax,seg string
        mov     ds,ax
        mov     si,offset string;; ds:si = address of string
        DbgPrintTty             ;; display it on console
        pop     ds
        pop     si
        pop     bx
        pop     ax
        popf
endif
endm



;***    DbgPrintTty
;*
;*      Prints an ASCIZ string in ds:si to console using Bios Int 10h
;*
;*      ENTRY   page    - if present defines which Bios video page to use
;*                        Defaults to 0
;*              ds:si   - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    al, bh, si, flags
;*
;*      ASSUMES 286+
;*
;***

DbgPrintTty macro page
        local   l1,l2

if DEBUG                        ;; no macro if not debug version
        mov     ah,14           ;; Bios Int write character as TTY function
ifb <page>
        sub     bh,bh
else
        mov     bh,page
endif
        cld                     ;; autoincrement lodsb
l1:     lodsb                   ;; al := next character; si := next character addr
        or      al,al           ;; eof string?
        jz      l2              ;; yes
ifndef NEC_98
        int     10h             ;; display it to console
endif   ;NEC_98
        jmp     short l1        ;; go round again
l2:
endif
endm



;***    DbgPrintString
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions. The string "DEBUG: " will be
;*      displayed if the banner parm is not blank
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*              banner  - the "DEBUG: " banner will be printed if not blank
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintString macro string, banner
        local   s1
        local   l1

if DEBUG                        ;; no macro if not debug version
        jmp     short l1
s1      db      &string,0
l1:     pushf                   ;; don't destroy direction flag
        pusha                   ;; save gp regs
ifb <banner>
        DbgDEBUG                ;; Display "DEBUG: "
endif
        push    ds              ;; save user's data seg
        push    cs
        pop     ds              ;; ds == cs
        mov     si,offset cs:s1 ;; si := string offset
        DbgPrintTty             ;; display ds:si to console
        pop     ds              ;; restore user's data seg
        popa                    ;; restore gp regs
        popf                    ;; restore direction flag+
endif
endm



;***    DbgPrintHexDword
;*
;*      Prints a dword to console in hex notation using Bios Int 10h
;*
;*      ENTRY   dword   - dword to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexDword macro dword
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexDword not implemented yet",13,10>
endif
endm



;***    DbgPrintHexWord
;*
;*      Prints a word to console in hex notation using Bios Int 10h
;*
;*      ENTRY   word    - to print. Can be memory or register
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexWord macro word
        local   l1, l2
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; don't use any registers
        push    ax
        push    cx
        push    dx
ifdifi <word>,<ax>
        mov     ax,word
endif
        mov     cx,4
l1:     rol     ax,4
        mov     dx,ax
        and     al,0fh
        cmp     al,9
        jle     l2
        add     al,'a'-('9'+1)
l2:     add     al,'0'
        mov     ah,14
ifndef NEC_98
        int     10h
endif ;NEC_98
        mov     ax,dx
        loop    l1
        pop     dx
        pop     cx
        pop     ax
        popf
endif
endm



;***    DbgPrintHexByte
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*
;*      EXIT
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexByte macro byte
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexByte not implemented yet",13,10>
endif
endm



DbgPrintNearPointer macro nearptr
endm



DbgPrintFarPointer macro farptr
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\int2a.asm ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    int2a.asm

Abstract:

    This module contains the int 2a handler for the NT VDM redir TSR

Author:

    Richard L Firth (rfirth) 29-Oct-1991

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

--*/
endif



.xlist
.xcref
include rdrsvc.inc      ; SVC
include debugmac.inc    ; debug display macros
include segorder.inc    ; load order of 'redir' segments
.cref
.list



.286                    ; all code in this module 286 compatible



ResidentCodeStart
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public  Old2aHandler
Old2aHandler    dd      ?

; ***   Int2aHandler
; *
; *     Handles int 2a requests, in which we pretend to be minses and any
; *     other missing parts of the net stack
; *
; *     ENTRY   function code in ah:
; *                 ah = 0, return ah = 1
; *                 ah = 1, Cooked NetBIOS call
; *                 ah = 4, al = 0, same as ah = 1
; *                         al = 1, Raw NetBIOS call
; *                         al = 2, unknown function; we don't handle it
; *                                 See doslan\minses\int2a.inc in LANMAN
; *                                 project for details
; *                 ah = 5, Get Adapter Resources. Returns in CX number of
; *                         available NCBs and in DX the number of available
; *                         sessions. We don't (as yet) handle this
; *
; *             es:bx = NCB
; *
; *     EXIT    See above
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

        public  Int2aHandler
Int2aHandler proc near
        or      ah,ah                   ; installation check
        jz      increment_ah_and_return

;
; not installation. Check for cooked/raw netbios calls
;

        cmp     ah,1
        je      cooked
        cmp     ah,4
        je      cooked_or_raw
        cmp     ah,5
        je      get_adapter_resources

;DbgPrintString "Int2aHandler: unrecognized request: "
;DbgPrintHexWord ax
;DbgCrLf

;
; the call is not for us - chain to the next Int 2A handler
;

chain_next_handler:
        DbgUnsupported
        jmp     Old2aHandler


cooked_or_raw:
        or      al,al                   ; ax = 0x0400?
        jz      cooked                  ; yes - cooked
        cmp     al,1                    ; ax = 0x0401?
        je      raw                     ; yes - raw
        cmp     al,2                    ; ax = 0x0402?
        jne     chain_next_handler      ; yes - same as raw; no - chain next

;
; raw request: just call NetBios via INT 5C and set ah dependent upon whether
; an error was returned from NetBios
;

raw:    int     5ch
        sub     ah,ah
        or      al,al
        jz      @f

increment_ah_and_return:
        inc     ah
@@:     iret

get_adapter_resources:
        mov     ax,1
        mov     bx,16
        mov     cx,128
        mov     dx,64
        iret

;
; 'cooked' call: this tries to convert synchronous NetBios calls to asynchronous
; then spins & beeps until the command has completed. Some commands are retried
; for a certain time or number of retries
;

;
; there is no justification for doing the 'cooked' processing that MINSES proper
; performs: The cooked processing is mainly to give the poor DOS user peace of
; mind when his machine seems dead, by occasionally beeping in a meaningful
; manner. Since we can terminate DOS sessions with impunity, there seems little
; point in letting the user know the machine is still alive, or retrying commands
; for that matter. However, that may change...
;

cooked:
        DbgUnsupported
        jmp     short raw               ; fudge it for now

Int2aHandler endp

ResidentCodeEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\asmmacro.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    asmmacro.inc
;
;Abstract:
;
;    Contains macros to extend masm functionality:
;
;       jmpc
;       jmpnc
;       jmpne
;       jmps
;       _mkjmp
;
;
;Author:
;
;    Richard L Firth (rfirth) 24-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;Revision History:
;
;    24-Sep-1991 rfirth
;        Created
;
;--



DEFINED_BIT=020h
;ISDEFINED equ %(.type <thing> and DEFINED_BIT)
LABEL_DEFINED equ <(.type &label and DEFINED_BIT)>

DEBUG_MACROS    = 0
;DEBUG_MACROS    = 1


;***    jmpa
;*
;*      jump to label if above. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpa    macro   label
        _mkjmp  ja,jna,&label
endm

;***    jmpc
;*
;*      jump to label if below. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpb    macro   label
        _mkjmp  jb,jnb,&label
endm

;***    jmpc
;*
;*      jump to label if carry flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpc    macro   label
        _mkjmp  jc,jnc,&label
endm



;***    jmpnc
;*
;*      jump to label if carry flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpnc   macro   label
        _mkjmp  jnc,jc,&label
endm



;***    jmpne
;*
;*      jump to label if zero flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpne   macro   label
        _mkjmp  jne,je,&label
endm



;***    jmpe
;*
;*      jump to label if zero flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpe    macro   label
        _mkjmp  je,jne,&label
endm



;***    jmps
;*
;*      jump to label. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmps    macro   label
        local   dist

dist=&label-$

if DEBUG
        jmp     &label
else
if (.type label and DEFINED_BIT)
if ((dist gt 129) or (dist lt -126))
        jmp     &label
else
        jmp     short &label
endif
else
        jmp     &label
endif
endif

endm



;***    _mkjmp
;*
;*      Make a jmp<?> macro. Generate instruction sequence for jump with or
;*      without conditional test. Jump may be short (+127/-128 bytes) or near
;*      (+32767/-32768 bytes)
;*
;*      ENTRY   is      - short jump instruction
;*              in      - near jump instruction
;*              label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

_mkjmp  macro   is, in, label
        local   l

if DEBUG
        &in     l
        jmp     &label
else
        &is     &label
endif

l:

endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\int5c.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    int5c.inc

Abstract:

    This module contains the int 5c/Netbios equates

Author:

    Colin Watson (colinw) 5-Dec-1991

Environment:

    Dos mode only

Revision History:

    05-Dec-1991 colinw
        Created

--*/
endif

;
;   Use Irql 14 (normally the hard disk drive) to pretend to be Irql used by the network
;   adapter. Irql 14 is not used for the disk in the emulation system. Utilizing 14 means
;   that there will be no clash of interrupts with user supplied virtual devices.
;

ifdef NEC_98
NETWORK_INTERRUPT equ 0dh
else
NETWORK_INTERRUPT equ 72h
endif

;
; Network Control Block
;

NCBNAMSZ equ 16

ncb     struc
    ncb_command db ?        ; command code
    ncb_retcode db ?        ; return code
    ncb_lsn db ?                    ; local session number
    ncb_num db ?                    ; number of our network name
    ncb_buffer dd ?         ; address of message buffer
    ncb_length dw ?         ; size of message buffer
    ncb_callname db NCBNAMSZ dup (?) ; blank-padded name of remote
    ncb_name db NCBNAMSZ dup (?)     ; our blank-padded netname
    ncb_rto db ?                    ; rcv timeout/retry count
    ncb_sto db ?                    ; send timeout/sys timeout
    ncb_post dd ?                   ; Async notification handle
    ncb_lana_num db ?       ; lana (adapter) number
    ncb_cmd_cplt db ?       ; 0xff => commmand pending
    ncb_reserve db 14 dup (?)       ; reserved, used by BIOS
ncb     ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\int5c.asm ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    int5c.asm

Abstract:

    This module contains the int 5c handler for the NT VDM redir TSR

Author:

    Colin Watson (colinw) 5-Dec-1991

Environment:

    Dos mode only

Revision History:

    05-Dec-1991 colinw
        Created

--*/
endif



.xlist
.xcref
include debugmac.inc    ; debug display macros
include segorder.inc    ; load order of 'redir' segments
include rdrsvc.inc      ; BOP and SVC macros/dispatch codes
include int5c.inc       ; Int to be used for pseudo network adapter
include asmmacro.inc    ; jumps which may be short or near
include vrdlctab.inc    ; VDM_REDIR_DOS_WINDOW
.cref
.list

.286                    ; all code in this module 286 compatible

;
; Misc. local manifests
;

NETBIOS_STACK_SIZE equ     256

ResidentDataStart
NetbiosStack            db      NETBIOS_STACK_SIZE dup( 0 )
NetbiosStackTop         label   word
ResidentDataEnd

pic1    equ 20h
pic2    equ 0a0h

;
; The CCB1 definition
;

CCB     struc

CCB_ADAPTER     db      ?
CCB_COMMAND     db      ?
CCB_RETCODE     db      ?
CCB_WORK        db      ?
CCB_POINTER     dd      ?
CCB_CMD_CMPL    dd      ?
CCB_PARM_TAB    dd      ?

CCB     ends

ResidentCodeStart
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public  Old5cHandler
Old5cHandler            dd      ?
        public  OldNetworkHandler
OldNetworkHandler       dd      ?


; ***   VDM REDIR INFO WINDOW
; *
; *     ABSTRACT:
; *         Used to share data structures between VDM device driver
; *         in 32-bit mode and DOS-VDM.  This data structure must be
; *         excactly same as VDM_REDIR_DOS_WINDOW struct in vdmredir.h.
; *
; ***
        public  dwPostRoutineAddress
dwPostRoutineAddress:    ; async post routine address
        VDM_REDIR_DOS_WINDOW <>

; ***   Int5cHandler
; *
; *     Handles int 5c requests, in which we redirect work to netapi.dll
; *
; *     ENTRY   es:bx = Address of NCB or DLC CCB, if the
; *                     first byte less than 10H.
; *
; *     EXIT    al = NCB_RETCODE for NCB's
; *
; *     RETURNS nothing
; *
; *     USES    nothing
; *
; *     ASSUMES nothing
; *
; ***

        public  Int5cHandler
Int5cHandler proc near

;
; Perform a BOP into 32 bit mode to process the request.
; It's DLC if the first byte in ES:BX is less than 10h.
;

        sti                             ; enable hw interrupts
        cmp     byte ptr es:[bx], 10H
        jb      call_dlc_5c

;
; deferred loading: if this call is from (presumably) DOSX checking to see if
; the 5C support is loaded, return the expected error without calling Netbios
; for real: this allows us to continue installation without having to load
; VDMREDIR.DLL until it is really required
;

        cmp     byte ptr es:[bx],7fh    ; NETBIOS presence check
        je      @f
        cmp     byte ptr es:[bx],0ffh   ; async NETBIOS presence check
        je      @f
        SVC     SVC_NETBIOS5C
        iret
@@:     mov     al,3                    ; INVALID COMMAND error
        mov     es:[bx].ncb_retcode,al  ; returned in NCB_RETCODE && al
        mov     es:[bx].ncb_cmd_cplt,al ; and NCB_CMD_CPLT
        iret

;
; call is for DLC. DLC does not return anything in registers. Command completion
; is either via an 'appendage' (call-back to you and me) or by the app polling
; the CCB_RETCODE field of the CCB in ES:BX for a change from 0xFF
;

call_dlc_5c:

;
; BOP into 32-bit DOS DLC emulator. This will return in AL the status of the
; CCB request: 0xFF if the command will complete asynchronously, else a
; synchrnous completion code
;

        SVC     SVC_DLC_5C

;
; if the CCB completed (synchronously) and there is an 'appendage' (who do IBM
; have writing this stuff?) then we must call it. We check the return code in
; AL since the return in the CCB may be the final code (ie already changed by
; the asynchronous completion thread in 32-bit DOS DLC emulator)
;

        cmp     al,0ffh                 ; is the command active?
        je      @f                      ; yes - return to the app

;
; the 32-bit DOS DLC emulator returned a synchronous completion code. We
; complete the CCB by calling the 'appendage'. The appendage is pointed at
; by the CCB_CMD_CMPL field in the CCB. If this field is 0:0 then the app
; has not provided an 'appendage' and will periodically look at the CCB_RETCODE
; field until the 32-bit emulator's asynchronous completion thread writes
; something there other than 0xFF
;

        pusha                           ; save caller's registers
        mov     cx,word ptr es:[bx].CCB_CMD_CMPL
        or      cx,word ptr es:[bx].CCB_CMD_CMPL[2]
        jz      no_go

;
; we have an appendage. The manual says: cx=adapter #, es:bx=CCB, ss:sp=stack (!)
; cs=appendage cs (!!). Simulate an interrupt (ints off - that's what it says)
;

        mov     cl,byte ptr es:[bx].CCB_ADAPTER
        xor     ch,ch
        xor     ah,ah
        pushf                           ; simulate INT
        cli                             ; all ints are off
        call    dword ptr es:[bx].CCB_CMD_CMPL

;
; appendage irets here, we restore the caller's registers and wend our merry
; walker
;

no_go:  popa                            ; restore caller's context
@@:     iret

Int5cHandler endp

; ***   IntNetworkHandler
; *
; *     Handles int Network requests, in which we redirect work to netapi.dll
; *
; *     NOTE: !!! This routine is NOT re-entrant: it sets up a new stack !!!
; *
; *     ENTRY   nothing
; *
; *     EXIT    nothing
; *
; *     RETURNS nothing
; *
; *     USES    nothing
; *
; *     ASSUMES nothing
; *
; ***

        even

InterruptedStack        dd      ?

if DEBUG
ReEntered       db      0
endif

        public  IntNetworkHandler
IntNetworkHandler proc near

        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

if DEBUG
        cmp     ReEntered,0
        jne     __re_entry
        inc     ReEntered
        jmps    @f

__re_entry:
        DbgPrintString <"ERROR: IntNetworkHandler re-entered",13,10>
        push    ds
        push    es
        push    ax
        sub     ax,ax
        dec     ax
        mov     ds,ax                   ; ds = es = -1 signals re-entrancy
        mov     es,ax
        DbgUnsupported
        DbgBreakPoint
        pop     ax
        pop     es
        pop     ds
@@:
endif

;
; Switch stacks and call the post routine
;

        push    ax                      ; interrupted ax on interrupted stack
;        push    dx                      ;             dx
        mov     word ptr InterruptedStack,sp
        mov     word ptr InterruptedStack[2],ss
        mov     ax,seg NetbiosStack
        mov     ss,ax
        mov     sp,offset NetbiosStackTop

;
; perform a BOP into 32 bit mode to process the request.
;
; 32 bit code returns:
;
;       ZF = 0, CF = 0          nothing to do (2 jumps)
;       ZF = 0, CF = 1          async named pipe post processing (1 jump)
;       ZF = 1, CF = 0          DLC post processing (1 jump)
;       ZF = 1, CF = 1          NCB post processing (0 jumps)
;
; CAVEAT: if we extend this interface to have >3 options + do nothing, then
; we need to change to setting a value in a (unused) register (bp?)
;

        pusha                           ; rest of interrupted registers on our stack
        push    ds
        push    es
        SVC     SVC_NETBIOS5CINTERRUPT
        jmpne   nothing_or_nmpipe
        jmpnc   dlc_processing

;
; Call post routine, it returns with IRET => push flags to stack.
; We must not change any registers between BOP and post routine!
; Note: NCB post processing is currently on fastest path. May need
; to change to DLC. Check it out in performance phase
;

        pushf                           ; fake interrupt call
        call    es:[bx].ncb_post
        jmps    exit_IntNetworkHandler

nothing_or_nmpipe:
        jmpnc   exit_IntNetworkHandler

;
; default is async named-pipe processing. The BOP handler returns us the
; following:
;       AL = 0 => ordinary (not AsyncNmPipe2) call
;       AL != 0 => call is DosReadAsyncNmPipe2 or DosWriteAsyncNmPipe2
;       CX:BX = address of ANR
;       DS:SI = address of data buffer
;       ES:DI = 'semaphore' handle for AsyncNmPipe2 call
;
; if the async name pipe function call didn't specify a semaphore, then don't
; push anything to stack since the ANR itself knows how many parameters will
; be on the stack. We expect it to ret n
;

        DbgPrintString <"AsyncNmPipe callback!", 13, 10>
        or      al,al
        jz      @f
        push    es                      ; semaphore handle for type2 calls
        push    di
@@:     push    ds                      ; buffer address
        push    si

;
; the ANR is a pascal function which will clean the stack before returning. We
; push the ANR address and fake a far call. The ANR will return to
; exit_IntNetworkHandler. We futz the stack anyway, so we may as well avoid
; an extra jump
;

        push    cs                      ; store far return addr on the stack
        push    offset exit_IntNetworkHandler
        push    cx                      ; fake far call to ANR
        push    bx
        retf

;
; DLC post processing: 32-bit code has set relevant registers and put post
; routine address in dwPostRoutineAddress. Must make sure that post address
; (ie 'appendage' address) is not 0:0
;

dlc_processing:
        cmp     word ptr dwPostRoutineAddress,0
        jne     @f
        cmp     word ptr dwPostRoutineAddress[2],0
        je      exit_IntNetworkHandler  ; huh?

;
; there is a non-zero post routine address set in the BOP. Simulate an
; interrupt into the post routine (appendage)
;

@@:     pushf                           ; fake interrupt call
;        cli                             ; manual says ints off
        call    dword ptr dwPostRoutineAddress

;
; restore the interrupted registers and stack
;

exit_IntNetworkHandler:
        pop     es
        pop     ds
        popa
        mov     ss,word ptr InterruptedStack[2]
        mov     sp,word ptr InterruptedStack
;        pop     dx                      ; interrupted dx

;;
;; re-enable the 8259s
;;
;
;        mov al,20h
;
;;
;; Edge triggered assuming interrupt on slave pic as per the AT
;;
;
;        out pic2,al      ; EOI pic 2
;        out pic1,al      ; EOI pic 1
;
;;
;;       Level triggered assuming interrupt on slave pic
;;
;;        out pic1,al      ; EOI pic 1
;;        out pic2,al      ; EOI pic 2
;
;;
;;       assuming interrupt on master pic
;;        out pic1,al      ; EOI pic 1
;;

        pop     ax                      ; interrupted ax

if DEBUG
        dec     ReEntered
endif

        SVC     SVC_RDRINTACK2
        iret                            ; back to interrupted code
;        jmp     dword ptr OldNetworkHandler
IntNetworkHandler endp

ResidentCodeEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\localmac.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    localmac.inc
;
;Abstract:
;
;    Contains various macros to get around various things:
;
;       DosCallBack
;
;
;Author:
;
;    Richard L Firth (rfirth) 27-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;Revision History:
;
;    24-Sep-1991 rfirth
;        Created
;
;--



;***    DosCallBack
;*
;*      Call back into DOS via the int 2f/ah=12 back door. If CALL_DOS defined,
;*      use a call, else s/w interrupt. Using a call means no other TSRs etc.
;*      which load AFTER the redir can hook it, but we DON'T HAVE TO MAKE A
;*      PRIVILEGE TRANSITION ON x86 which speeds things up. This should be safe,
;*      because no other s/w should really be hooking INT 2F/AH=12
;*
;*      ENTRY   FunctionNumber  - dispatch code goes in al
;*              DosAddr         - if present, variable containing address of
;*                                DOS int 2f entry point
;*              OldMultHandler  - this variable contains the address of DOSs
;*                                int 2f back door. Specific to redir code
;*
;*      EXIT    nothing
;*
;*      USES    ax, OldMultHandler
;*
;*      ASSUMES nothing
;*
;***

DosCallBack macro FunctionNumber, DosAddr
        mov     ax,(MultDOS shl 8) + FunctionNumber
ifdef CALL_DOS
        pushf
ifb <DosAddr>
if (((.type OldMultHandler) and 32) eq 0)    ;; OldMultHandler not defined
        extrn   OldMultHandler:dword
endif
        call    OldMultHandler
else
        call    DosAddr
endif
else
        int     2fh
endif
endm



;
; defines for DosCallBack FunctionNumbers
;

SF_FROM_SFN     =       22
GET_USER_STACK  =       24
PJFN_FROM_HANDLE=       32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\msgapi.asm ===
page    ,132
if 0

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgapi.asm

Abstract:

    This module contains the messenger functions that we marginally support
    for VDM

        MessengerDispatch

Author:

    Richard L Firth (rfirth) 21-Sep-1992

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

--*/

endif

.xlist                  ; don't list these include files
.xcref                  ; turn off cross-reference listing
include dosmac.inc      ; Break macro etc (for following include files only)
include error.inc       ; DOS errors - ERROR_INVALID_FUNCTION
include segorder.inc    ; segments
include debugmac.inc    ; DbgPrint macro
include localmac.inc    ; DbgPrint macro
include asmmacro.inc    ; language extensions
include rdrsvc.inc      ; BOP and SVC macros/dispatch codes
include rdrmisc.inc     ; miscellaneous definitions
.cref                   ; switch cross-reference back on
.list                   ; switch listing back on
subttl                  ; kill subtitling started in include file

.286

ResidentCodeStart
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

MessengerDispatchTable label word
        dw      MessageInstalled
        dw      MessageDone
        dw      MessageLogging
        dw      MessageUserFunction
        dw      MessageUnusedFunction
        dw      MessagePauseContinue

LAST_MESSENGER_FUNCTION = (offset $ - offset MessengerDispatchTable)/2 - 1

        public MessengerDispatch
MessengerDispatch proc near
        cmp     al,LAST_MESSENGER_FUNCTION
        jbe     @f
        mov     al,ERROR_INVALID_PARAMETER
        stc
        ret
@@:     cbw
        push    bx
        mov     bx,ax
        shl     bx,1
        mov     ax,MessengerDispatchTable[bx]
        pop     bx
        jmp     ax
MessengerDispatch endp

MessageInstalled:
        dec     al

MessageDone:
        ret

MessageLogging:
MessageUserFunction:
MessageUnusedFunction:
MessagePauseContinue:
;        mov     ax,ERROR_INVALID_FUNCTION
        mov     ax,2142                 ; NERR_InvalidAPI
        stc
        retn

ResidentCodeEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\mailslot.asm ===
page    ,132
if 0

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mailslot.asm

Abstract:

    This module contains the resident code part of the stub redir TSR for NT
    VDM net support. The routines contained herein are the mailslot API stubs:

        DosDeleteMailslot
        DosMailslotInfo
        DosMakeMailslot
        DosPeekMailslot
        DosReadMailslot
        DosWriteMailslot


Author:

    Richard L Firth (rfirth) 05-Sep-1991

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

--*/

endif



.xlist                  ; don't list these include files
.xcref                  ; turn off cross-reference listing
include dosmac.inc      ; Break macro etc (for following include files only)
include dossym.inc      ; User_<Reg> defines
include mult.inc        ; MultNET
include error.inc       ; DOS errors - ERROR_INVALID_FUNCTION
include syscall.inc     ; DOS system call numbers
include rdrint2f.inc    ; redirector Int 2f numbers
include segorder.inc    ; segments
include enumapis.inc    ; dispatch codes
include debugmac.inc    ; DbgPrint macro
include localmac.inc    ; DbgPrint macro
include rdrsvc.inc      ; BOP and SVC macros/dispatch codes
include sf.inc          ; SFT definitions/structure
.cref                   ; switch cross-reference back on
.list                   ; switch listing back on
subttl                  ; kill subtitling started in include file



.286                    ; all code in this module 286 compatible



ResidentCodeStart
        assume  cs:ResidentCode
        assume  ds:nothing

; ***   DosDeleteMailslot
; *
; *     Delete a local mailslot. We must also pass in the current PDB. A
; *     Dos process can only delete mailslots which it has previously
; *     created. We pass the PDB in ax, since it only contains a dispatch
; *     vector
; *
; *     Function = 5F4Eh
; *
; *     ENTRY   BX = Mailslot handle
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 ES:DI = Mailslot buffer address
; *                 DX = Mailslot selector
; *
; *     RETURNS
; *
; *     USES    ax, dx, di, ds, es, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosDeleteMailslot
DosDeleteMailslot proc near
        push    bx
        mov     ah,51h
        int     21h             ; get current PDB
        mov     ax,bx           ; ax := current PDB
        pop     bx              ; bx := mailslot handle
        SVC     SVC_RDRDELETEMAILSLOT
        jc      @f

;
; success - copy returned info in registers to copy of caller's registers in
; DOS segment
;

        DosCallBack GET_USER_STACK
        mov     [si].User_Dx,dx
        mov     [si].User_Es,es
        mov     [si].User_Di,di
        clc
@@:     ret
DosDeleteMailslot endp



; ***   DosMailslotInfo
; *
; *     Retrieves local mailslot info
; *
; *     Function = 5F4Fh
; *
; *     ENTRY   BX = Mailslot handle
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 AX = Message size
; *                 BX = Mailslot size
; *                 CX = Next size
; *                 DX = Next priority
; *                 SI = Message count
; *
; *     USES    ax, bx, cx, dx, si, ds, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosMailslotInfo
DosMailslotInfo proc near
        SVC     SVC_RDRGETMAILSLOTINFO
        jc      @f
        push    si                      ; push returned values on stack
        push    dx
        push    cx
        push    bx
        push    ax
        DosCallBack GET_USER_STACK      ; get caller register frame
        pop     [si].User_Ax            ; set caller's registers to returned values
        pop     [si].User_Bx
        pop     [si].User_Cx
        pop     [si].User_Dx
        pop     [si].User_Si
        clc
@@:     ret
DosMailslotInfo endp



; ***   DosMakeMailslot
; *
; *     Creates a local mailslot. We need to pass in the current PDB as a
; *     process identifier (see DosDeleteMailslot). We use ax since this only
; *     contains a dispatch vector
; *
; *     Function = 5F4Dh
; *
; *     ENTRY   DS:SI =  ASCIZ Name of mailslot to create
; *             BX = Message size (hint)
; *             CX = Mailslot size (hint)
; *             DX = Mailslot selector (for WIN 3 protect mode)
; *             ES:DI = User's data buffer
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 AX = Mailslot handle
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosMakeMailslot
DosMakeMailslot proc near
        push    bx
        mov     ah,51h
        int     21h             ; get current PDB
        mov     ax,bx           ; ax := current PDB
        pop     bx              ; bx := mailslot size
if 0
if DEBUG
        DbgPrintString "DosMakeMailslot: ax="
        DbgPrintHexWord ax
        DbgPrintString <13,10," Message size (bx) =">, NO_BANNER
        DbgPrintHexWord bx
        DbgPrintString <13,10," Mailslot size (cx) =">, NO_BANNER
        DbgPrintHexWord cx
        DbgPrintString <13,10," Mailslot selector (dx) =">, NO_BANNER
        DbgPrintHexWord dx
        DbgPrintString <13,10," User buffer (es:di) =">, NO_BANNER
        DbgPrintHexWord es
        DbgPrintString ":", NO_BANNER
        DbgPrintHexWord di
        DbgPrintString <13,10>,NO_BANNER
endif
endif
        SVC     SVC_RDRMAKEMAILSLOT
        ret
DosMakeMailslot endp



; ***   DosPeekMailslot
; *
; *     Reads a message from a mailslot non-destructively
; *
; *     Function = 5F51h
; *
; *     ENTRY   BX = Mailslot handle
; *             ES:DI = Buffer address
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 AX = Bytes read
; *                 CX = Next size
; *                 DX = Next priority
; *
; *     USES    ax, cx, dx, si, ds, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosPeekMailslot
DosPeekMailslot proc near
        SVC     SVC_RDRPEEKMAILSLOT
        jmp     short common_peek_read  ; jump to common read/peek processing
DosPeekMailslot endp



; ***   DosReadMailslot
; *
; *     Reads the next message from a mailslot
; *
; *     Function = 5F50h
; *
; *     ENTRY   BX = Mailslot handle
; *             ES:DI = Buffer address
; *             DX:CX = Timeout (mSec)
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 AX = Bytes read
; *                 CX = NextSize
; *                 DX = NextPriorty
; *
; *     USES    ax, cx, dx, si, ds, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosReadMailslot
DosReadMailslot proc near
        SVC     SVC_RDRREADMAILSLOT

;
; common read/peek mailslot code - if error return else copy following values
; returned in registers to caller's registers in DOS stack segment
;

common_peek_read:
        jc      @f                      ; error - return
        push    dx
        push    cx
        push    ax
        DosCallBack GET_USER_STACK
        pop     [si].User_Ax            ; # bytes read
        pop     [si].User_Cx            ; byte size of next message
        pop     [si].User_Dx            ; priority of next message
        clc                             ; indicate success
@@:     ret
DosReadMailslot endp



; ***   DosWriteMailslot
; *
; *     Writes a message to a mailslot. The mailslot is identified by a
; *     symbolic name (even if its local)
; *
; *     Function = 5F52h
; *
; *     ENTRY   DS:SI = Destination mailslot name
; *             ES:DI = Pointer to DosWriteMailslotStruct:
; *                         DWORD       Timeout
; *                         char far*   Buffer
; *             CX = Number of bytes in buffer
; *             DX = Message priority
; *             BX = Message class
; *
; *     EXIT    CF = 1
; *                  AX = Error code
; *
; *             CF = 0
; *                  No error
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosWriteMailslot
DosWriteMailslot proc near
        SVC     SVC_RDRWRITEMAILSLOT
        ret
DosWriteMailslot endp

ResidentCodeEnd
end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\namepipe.asm ===
page    ,132
if 0

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    namepipe.asm

Abstract:

    This module contains the resident code part of the stub redir TSR for NT
    VDM net support. The routines contained herein are the named pipe API
    stubs:

        DosQNmPipeInfo
        DosQNmpHandState
        DosSetNmpHandState
        DosPeekNmPipe
        DosTransactNmPipe
        DosCallNmPipe
        DosWaitNmPipe
        NetHandleGetInfo
        NetHandleSetInfo
        DosReadAsyncNmPipe
        DosWriteAsyncNmPipe
        DosReadAsyncNmPipe2
        DosWriteAsyncNmPipe2
        (MapNtHandle)


Author:

    Richard L Firth (rfirth) 05-Sep-1991

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

--*/

endif



.xlist                  ; don't list these include files
.xcref                  ; turn off cross-reference listing
include dosmac.inc      ; Break macro etc (for following include files only)
include dossym.inc      ; User_<Reg> defines
include mult.inc        ; MultNET
include error.inc       ; DOS errors - ERROR_INVALID_FUNCTION
include syscall.inc     ; DOS system call numbers
include rdrint2f.inc    ; redirector Int 2f numbers
include segorder.inc    ; segments
include enumapis.inc    ; dispatch codes
include debugmac.inc    ; DosCallBack macro
include localmac.inc    ; DbgPrint macro
include rdrsvc.inc      ; BOP and SVC macros/dispatch codes
include sf.inc          ; SFT definitions/structure
.cref                   ; switch cross-reference back on
.list                   ; switch listing back on
subttl                  ; kill subtitling started in include file



.286                    ; all code in this module 286 compatible



ResidentCodeStart
        assume  cs:ResidentCode
        assume  ds:nothing

; ***   DosQNmPipeInfo
; *
; *     Implements the DosQNmPipeInfo call by vectoring into the VdmRedir
; *     dispatcher which calls a 32-bit function to do the work
; *
; *     Function = 5F32h
; *
; *     ENTRY   BX = Pipe handle
; *             CX = Buffer size
; *             DX = Info level
; *             DS:SI = Buffer
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 no error
; *                 AX = undefined
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosQNmPipeInfo
DosQNmPipeInfo  proc near
        call    MapNtHandle
        jc      @f                      ; bad handle: ax = error code, cf = 1
        SVC     SVC_RDRQNMPIPEINFO      ; BP:BX is 32-bit handle
@@:     ret
DosQNmPipeInfo  endp



; ***   DosQNmpHandState
; *
; *     Implements the DosQNmpHandState call by vectoring into the VdmRedir
; *     dispatcher which calls a 32-bit function to do the work
; *
; *     Function = 5F33h
; *
; *     ENTRY   BX = Pipe handle
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 AX = Pipe mode:
; *                         BSxxxWxRIIIIIIII
; *
; *                         where:
; *                             B = Blocking mode. If B=1 the pipe is non blocking
; *                             S = Server end of pipe if 1
; *                             W = Pipe is written in message mode if 1 (else byte mode)
; *                             R = Pipe is read in message mode if 1 (else byte mode)
; *                             I = Pipe instances. Unlimited if 0xFF
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosQNmpHandState
DosQNmpHandState proc near
        call    MapNtHandle
        jc      @f                      ; bad handle: ax = error code, cf = 1
        SVC     SVC_RDRQNMPHANDSTATE
@@:     ret
DosQNmpHandState endp



; ***   DosSetNmpHandState
; *
; *     Implements the DosSetNmpHandState call by vectoring into the VdmRedir
; *     dispatcher which calls a 32-bit function to do the work
; *
; *     Function = 5F34h
; *
; *     ENTRY   BX = Pipe handle
; *             CX = Pipe mode to set
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 AX = Pipe mode set
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosSetNmpHandState
DosSetNmpHandState proc near
        call    MapNtHandle
        jc      @f                      ; bad handle: ax = error code, cf = 1
        SVC     SVC_RDRSETNMPHANDSTATE
@@:     ret
DosSetNmpHandState endp



; ***   DosPeekNmPipe
; *
; *     Implements the DosPeekNmPipe call by vectoring into the VdmRedir
; *     dispatcher which calls a 32-bit function to do the work
; *
; *     Function = 5F35h
; *
; *     ENTRY   BX = Pipe handle
; *             CX = Size of buffer for peek
; *             DS:SI = Buffer address
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 AX = Pipe status
; *                 BX = Number of bytes peeked into buffer
; *                 CX = Number of bytes in pipe
; *                 DX = Number of bytes in message
; *                 DI = Pipe status
; *                 DS:SI = Data peeked
; *
; *     USES    ax, bx, cx, dx, si, di, ds, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosPeekNmPipe
DosPeekNmPipe proc near
        call    MapNtHandle
        jc      @f                      ; bad handle: ax = error code, cf = 1
        SVC     SVC_RDRPEEKNMPIPE       ; do the 'bop' (makes the lambada look tame)
        jc      @f                      ; error returned from protect mode

;
; success - set the user's registers to values returned
;

        push    ax                      ; pipe status
        DosCallBack GET_USER_STACK      ; Get_User_Stack
        pop     [si].User_Ax            ; copy saved return code into user's copy
        mov     [si].User_Bx,bx
        mov     [si].User_Cx,cx
        mov     [si].User_Dx,dx
        mov     [si].User_Di,di
        clc                             ; reset cf, just in case
@@:     ret
DosPeekNmPipe endp



; ***   DosTransactNmPipe
; *
; *     Implements the DosTransactNmPipe call by vectoring into the VdmRedir
; *     dispatcher which calls a 32-bit function to do the work
; *
; *     Function = 5F36h
; *
; *     ENTRY   BX = Pipe handle
; *             CX = Transmit buffer length
; *             DX = Receive buffer length
; *             DS:SI = Transmit buffer
; *             ES:DI = Receive buffer
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 CX = Number of bytes in Receive buffer
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosTransactNmPipe
DosTransactNmPipe proc near
        call    MapNtHandle
        jc      @f                      ; bad handle: ax = error code, cf = 1
        SVC     SVC_RDRTRANSACTNMPIPE
        jc      @f                      ; error from protect-mode side

;
; success - copy returned cx value to user's registers in Dos stack seg
;

        DosCallBack GET_USER_STACK
        mov     [si].User_Cx,cx
        clc                             ; reset carry flag, just in case
@@:     ret
DosTransactNmPipe endp



; ***   DosCallNmPipe
; *
; *     Implements the DosCallNmPipe call by vectoring into the VdmRedir
; *     dispatcher which calls a 32-bit function to do the work
; *
; *     Function = 5F37h
; *
; *     ENTRY   DS:SI = Pointer to CallNmPipe structure:
; *                             DWORD   Timeout;                    +0
; *                             LPWORD  lpBytesRead;                +4
; *                             WORD    OutputBufferLen;            +8
; *                             LPBYTE  OutputBuffer;               +10
; *                             WORD    InputBufferLength;          +14
; *                             LPBYTE  InputBuffer;                +16
; *                             LPSTR   PipeName;                   +20
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 CX = Bytes received
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosCallNmPipe
DosCallNmPipe proc near
        SVC     SVC_RDRCALLNMPIPE
        jc      @f                      ; oops - error

;
; success - copy returned ByteRead count in cx to user's cx in Dos stack seg
;

        DosCallBack GET_USER_STACK
        mov     [si].User_Cx,cx
        clc                             ; reset carry flag, just in case
@@:     ret
DosCallNmPipe endp



; ***   DosWaitNmPipe
; *
; *     Implements the DosWaitNmPipe call by vectoring into the VdmRedir
; *     dispatcher which calls a 32-bit function to do the work
; *
; *     Function = 5F38h
; *
; *     ENTRY   BX:CX = Timeout
; *             DS:DX = Pipe name
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 No error
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosWaitNmPipe
DosWaitNmPipe proc near
        SVC     SVC_RDRWAITNMPIPE
        ret
DosWaitNmPipe endp



; ***   NetHandleSetInfo
; *
; *     Function = 5F3Bh
; *
; *     ENTRY   BX = Pipe handle
; *             CX = Buffer length
; *             SI = Level (1)
; *             DI = Parmnum
; *             DS:DX = Buffer
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 Stuff from buffer set
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public NetHandleSetInfo
NetHandleSetInfo proc
        call    MapNtHandle
        jc      @f
        SVC     SVC_RDRHANDLESETINFO
@@:     ret
NetHandleSetInfo endp



; ***   NetHandleGetInfo
; *
; *     Function = 5F3Ch
; *
; *     ENTRY   BX = Pipe handle
; *             CX = Buffer length
; *             SI = Level (1)
; *             DS:DX = Buffer
; *
; *     EXIT    CX = size of required buffer (whether we got it or not)
; *             CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 indicated stuff put in buffer
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public NetHandleGetInfo
NetHandleGetInfo proc
        call    MapNtHandle
        jc      @f
        SVC     SVC_RDRHANDLEGETINFO
        jc      @f
        DosCallBack GET_USER_STACK
        mov     [si].User_Cx,cx
        clc
@@:     ret
NetHandleGetInfo endp



; ***   DosReadAsyncNmPipe/DosReadAsyncNmPipe2
; *     DosWriteAsyncNmPipe/DosWriteAsyncNmPipe2
; *
; *     Implements the AsyncNmPipe calls. 32-bit DLL does all the work
; *
; *     Function = int 2fh/ax=1186h (DosReadAsyncNmPipe)
; *     Function = int 2fh/ax=1190h (DosReadAsyncNmPipe2)
; *     Function = int 2fh/ax=118fh (DosWriteAsyncNmPipe)
; *     Function = int 2fh/ax=1191h (DosWriteAsyncNmPipe2)
; *
; *     ENTRY   DS:SI = DosAsyncNmPipeStruct:
; *                     DD      pBytesRead      +0
; *                     DW      buflen          +4
; *                     DD      pBuffer         +6
; *                     DD      pError          +10
; *                     DD      pAnr            +14
; *                     DW      hPipe           +18
; *
; *             + For DosReadAsyncNmPipe2/DosWriteAsyncNmPipe2
; *                     DD      pSemaphore      +20
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 No error
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public DosReadAsyncNmPipe
DosReadAsyncNmPipe proc near
        Int2fNumber DosReadAsyncNmPipe

async_read_write_common:

;
; since the async named pipe calls arrive via int 2f, we don't have the safety
; blanket of DOS saving our registers
;

        push    bp
        push    bx
        mov     bx,word ptr [si+18]     ; pipe handle
        call    MapNtHandle
        jc      @f
        SVC     SVC_RDRREADASYNCNMPIPE  ; same for Read & Write
@@:     pop     bx
        pop     bp
        ret

        public DosReadAsyncNmPipe2
DosReadAsyncNmPipe2:
        Int2fNumber DosReadAsyncNmPipe2
        jmp     short async_read_write_common

        public DosWriteAsyncNmPipe
DosWriteAsyncNmPipe:
        Int2fNumber DosWriteAsyncNmPipe
        jmp     short async_read_write_common

        public DosWriteAsyncNmPipe2
DosWriteAsyncNmPipe2:
        Int2fNumber DosWriteAsyncNmPipe2
        jmp     short async_read_write_common
DosReadAsyncNmPipe endp



; ***   MapNtHandle
; *
; *     Given a handle in BX, map it to a 32-bit Nt handle from the SFT in
; *     BP:BX
; *
; *     ENTRY   bx = handle to map
; *
; *     EXIT    Success - BP:BX = 32-bit Nt handle from SFT
; *
; *     RETURNS Success - CF = 0
; *             Failure - CF = 1, ax = ERROR_INVALID_HANDLE
; *
; *     USES    ax, bp, bx, flags
; *
; *     ASSUMES nothing
; *
; ***

MapNtHandle proc near
        push    ax                      ; save regs used by Dos call back
        push    cx
        push    dx
        push    ds
        push    si
        push    es
        push    di

;
; call back to Dos to get the pointer to the JFN in our caller's JFT. Remember
; the handle (BX) is an index into the JFT. The byte at this offset in the JFT
; contains the index of the SFT structure we want in the system file table
;

        DosCallBack PJFN_FROM_HANDLE    ; pJfnFromHamdle
        jc      @f                      ; bad handle

;
; we retrieved a pointer to the required byte in the JFT. The byte at this
; pointer is the SFT index which describes our 'file' (named pipe in this
; case). We use this as an argument to the next call back function - get
; Sft from System File Number
;

        mov     bl,es:[di]
        xor     bh,bh
        DosCallBack SF_FROM_SFN         ; SfFromSfn
        jc      @f                      ; oops - bad handle

;
; Ok. We have a pointer to the SFT which describes this named pipe. Get the
; 32-bit Nt handle
;

        mov     bx,word ptr es:[di].sf_NtHandle
        mov     bp,word ptr es:[di].sf_NtHandle[2]

;
; restore all registers used by Dos call back. BX at this point is either
; the low 16-bits of the 32-bit Nt handle or junk. Carry flag is set
; appropriately
;

@@:     pop     di
        pop     es
        pop     si
        pop     ds
        pop     dx
        pop     cx
        pop     ax
        jnc     @f

;
; finally, if there was an error then return a bad handle indication in ax
;

        mov     ax,ERROR_INVALID_HANDLE
@@:     ret
MapNtHandle endp

ResidentCodeEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\rdrmisc.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rdrmisc.inc

Abstract:

    Contains miscellaneous definitions

Author:

    Richard L Firth (rfirth) 05-Sep-1991

Environment:

    Dos mode only

Revision History:

--*/
endif

LM20_CNLEN      equ     15      ; from LMCONS.H!
LM20_UNLEN      equ     20      ; ditto
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\rdrint2f.inc ===
;*****************************************************************; 
;**		     Microsoft LAN Manager			**; 
;**	       Copyright(c) Microsoft Corp., 1990		**; 
;*****************************************************************; 
;*	RDRINT2F.INC - Redirector INT 2F function equates.
;
;	This file contains symbolic definitions of the redirector INT 2F
;	entry points.
;
_2F_NETInstall			equ	0
_2F_NET_RMDIR			equ	1
_2F_NET_SEQ_RMDIR		equ	2
_2F_NET_MKDIR			equ	3
_2F_NET_SEQ_MKDIR		equ	4
_2F_NET_CHDIR			equ	5
_2F_NET_CLOSE			equ	6
_2F_NET_COMMIT			equ	7
_2F_NET_READ			equ	8
_2F_NET_WRITE			equ	9
_2F_NET_LOCK			equ	10
_2F_NET_UNLOCK			equ	11
_2F_NET_DISK_INFO		equ	12
_2F_NET_SET_FILE_ATTRIBUTE	equ	13
_2F_NET_SEQ_SET_FILE_ATTRIBUTE	equ	14
_2F_NET_GET_FILE_INFO		equ	15
_2F_NET_SEQ_GET_FILE_INFO	equ	16
_2F_NET_RENAME			equ	17
_2F_NET_SEQ_RENAME		equ	18
_2F_NET_DELETE			equ	19
_2F_NET_SEQ_DELETE		equ	20
_2F_NET_OPEN			equ	21
_2F_NET_SEQ_OPEN		equ	22
_2F_NET_CREATE			equ	23
_2F_NET_SEQ_CREATE		equ	24
_2F_NET_SEQ_SEARCH_FIRST	equ	25
_2F_NET_SEQ_SEARCH_NEXT 	equ	26
_2F_NET_SEARCH_FIRST		equ	27
_2F_NET_SEARCH_NEXT		equ	28
_2F_NET_ABORT			equ	29
_2F_NET_ASSOPER 		equ	30
_2F_Printer_GETSET_STRING	equ	31
_2F_NetFlushBuf 		equ	32
_2F_NET_LSEEK			equ	33
_2F_NetResetEnvironment 	equ	34
_2F_NetSpoolCheck		equ	35
_2F_NetSpoolClose		equ	36
_2F_NetSpoolOper		equ	37
_2F_NetSpoolEchoCheck		equ	38
ifdef	DOSVER
if	( DOSVER EQ 400 ) OR ( DOSVER EQ 500 )
_2F_NetDeviceIOCTL		EQU	43
_2F_NetUpdateCB 		EQU	44
_2F_NetExtendedAttrib		EQU	45
_2F_NetExtendedOpen		EQU	46
_2F_NetDependantIOCTL		EQU	47
ENDIF
ENDIF
;*	Entry points from here on down are DOS 3 Lan Manager specific.
;
;
_2F_NetGetUserName		equ	80h
_2F_NetSetUserName		equ	81h
_2F_NetServiceNotify		equ	82h
_2F_NetPrintNameEnum		equ	83h
_2F_NetGetEnumInfo		equ	84h
_2F_TestKanjRD			equ	85h
_2F_TestDBCSLB			equ	85h
_2F_DosReadAsyncNmPipe		equ	86h
_2F_DosUnusedFunction1		equ	87h
_2F_DosUnusedFunction2		equ	88h
_2F_NetCalloutNCB		equ	89h
_2F_EncrPasswd			equ	8Ah
_2F_Set_LongName		equ	8Ah
_2F_NetGetLogonServer		equ	8Bh
_2F_NetSetLogonServer		equ	8Ch
_2F_NetGetDomain		equ	8Dh
_2F_NetSetDomain		equ	8Eh
_2F_DosWriteAsyncNmPipe		EQU	8FH
_2F_DosReadAsyncNmPipe2		EQU	90H
_2F_DosWriteAsyncNmPipe2	EQU	91H

;*	Symbolic Defination for Printer API's
;
_2F_Open_Specific_Spool 	equ	0BF02H
_2F_Close_Specific_Spool	equ	0BF03H

CallRedir macro function
	mov	ax,(MultNET shl 8) + _2F_&function
	int	2fh
endm

Int2fNumber macro function
	mov	ax,(MultNET shl 8) + _2F_&function
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\netapis.asm ===
page    ,132
if 0

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netapis.asm

Abstract:

    This module contains the resident code part of the stub redir TSR for NT
    VDM net support. The routines contained herein are the Lan Manager API
    stubs:

        NetIRemoteAPI
        NetMessageBufferSend
        NetNullTransactAPI
        NetServerEnum
        NetServiceControl
        NetTransactAPI
        NetUseAdd
        NetUseDel
        NetUseEnum
        NetUseGetInfo
        NetWkstaGetInfo
        NetWkstaSetInfo

Author:

    Richard L Firth (rfirth) 05-Sep-1991

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

--*/

endif



.xlist                  ; don't list these include files
.xcref                  ; turn off cross-reference listing
include dosmac.inc      ; Break macro etc (for following include files only)
include dossym.inc      ; User_<Reg> defines
include mult.inc        ; MultNET
include error.inc       ; DOS errors - ERROR_INVALID_FUNCTION
include syscall.inc     ; DOS system call numbers
include rdrint2f.inc    ; redirector Int 2f numbers
include segorder.inc    ; segments
include enumapis.inc    ; dispatch codes
include debugmac.inc    ; DbgPrint macro
include localmac.inc    ; DbgPrint macro
include asmmacro.inc    ; language extensions
include rdrsvc.inc      ; BOP and SVC macros/dispatch codes
include sf.inc          ; SFT definitions/structure
.cref                   ; switch cross-reference back on
.list                   ; switch listing back on
subttl                  ; kill subtitling started in include file



.286                    ; all code in this module 286 compatible



ResidentCodeStart
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

extrn   SetNetErrorCodeAx:near

;
; if we are remoting NetUserSetInfo with an unencrypted password, we need
; somewhere in 16-bit memory to store the encrypted password. Hence, this:
;

password_buffer db 16 dup(?)

; ***   NetIRemoteAPI
; *
; *     Remotes API requests to a server. Creates a transaction smb. The
; *     return data buffer address and length are in the caller's parameters.
; *
; *     This is an internal API so the parameters are trusted.
; *
; *     Function = 5F3Fh
; *
; *     ENTRY   CX = API number
; *             ES:BX = pointer to caller parameters
; *             DS:SI = pointer to ASCIZ parameter descriptor string
; *             DS:DI = pointer to ASCIZ data descriptor string
; *             DS:DX = pointer to ASCIZ aux data descriptor string
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 Output depends on type of request
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public NetIRemoteAPI
NetIRemoteAPI proc near
        mov     ax,offset cs:password_buffer
        SVC     SVC_RDRIREMOTEAPI

;
; all routines in this module come here for exit processing
;

common_net_api_exit:
        jc      common_api_error_exit   ; quick return on success
        ret

common_api_error_exit:
        push    ax
        DosCallBack GET_USER_STACK
        pop     [si].User_Ax            ; return failure status in caller's ax
        call    SetNetErrorCodeAx       ; set up to return 16-bit error to app
        stc                             ; failure indication
        ret
NetIRemoteAPI endp



; ***   NetMessageBufferSend
; *
; *     Function = 5F40h
; *
; *     ENTRY   DS:DX = NetMessageBufferSendStruct:
; *
; *                 char FAR *          NMBSS_NetName;  /* asciz net name. */
; *                 char FAR *          NMBSS_Buffer;   /* pointer to buffer. */
; *                 unsigned int        NMBSS_BufSize;  /* size of buffer. */
; *
; *     EXIT    CF = 0
; *                 Success
; *
; *             CF = 1
; *                 AX = Error code
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetMessageBufferSend
NetMessageBufferSend proc
        SVC     SVC_RDRMESSAGEBUFFERSEND
        jmps    common_net_api_exit
NetMessageBufferSend endp



; ***   NetNullTransactApi
; *
; *     Function = 5F54h
; *
; *     ENTRY   DS:SI = transaction packet
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 Success
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetNullTransactAPI
NetNullTransactAPI proc near
        SVC     SVC_RDRNULLTRANSACTAPI
        jmps    common_net_api_exit
NetNullTransactAPI endp



; ***   NetServerEnum
; *
; *     Function = 5F4Ch
; *
; *     ENTRY   BL = level (0 or 1)
; *             CX = size of buffer
; *             ES:DI = buffer
; *
; *     EXIT    CF = 1
; *                 AX = Error code:
; *                     NERR_BufTooSmall
; *                     ERROR_MORE_DATA
; *
; *             CF = 0
; *                 BX = entries read
; *                 CX = total available
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetServerEnum
NetServerEnum proc near
        mov     al,4ch
        jmp     short common_server_enum
NetServerEnum endp



; ***   NetServerEnum2
; *
; *     Function = 5F53h
; *
; *     ENTRY   DS:SI = NetServerEnum2Struct:
; *                 DW  Level
; *                 DD  Buffer
; *                 DW  Buflen
; *                 DD  Type
; *                 DD  Domain
; *
; *     EXIT    CF = 1
; *                 AX = Error code:
; *                     NERR_BufTooSmall
; *                     ERROR_MORE_DATA
; *
; *             CF = 0
; *                 BX = entries read
; *                 CX = total available
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetServerEnum2
NetServerEnum2 proc near
        mov     al,53h
common_server_enum:
        SVC     SVC_RDRSERVERENUM

;
; we are going to set the caller's BX and CX irrespective of whether we have
; meaningful values in them. This function
; is used to unpack a real-mode buffer into a protect-mode buffer, and it uses
; the returned EntriesRead in BX to do so. It's bad because it doesn't
; look at the return code until after its tried to unpack BX elements from its
; buffer. This took me a day to find out why its
; blowing up in 16-bit windows protect-mode netapi.dll, and probably means that
; if the real DOS redir ever returned anything other than a list of servers,
; then windows would fall over too. (Actually, the real redir does the right
; thing. This is what you get for believing comments, and not reading the code
; #^*&^@@*&%!)
;

        pushf
        push    ax
        DosCallBack GET_USER_STACK
        mov     [si].User_Bx,bx
        mov     [si].User_Cx,cx
        pop     ax                      ; error status or XXXX
        popf                            ; error indication
@@:     jmps    common_net_api_exit
NetServerEnum2 endp



; ***   NetServiceControl
; *
; *     Returns information about the state of a service, or applies a control
; *     to a service (and its dependents). We only allow INTERROGATE under NT
; *     since we don't want DOS apps starting and stopping the NT services. In
; *     most cases they couldn't anyway, since a DOS program will most likely
; *     be running in an account with not enough privilege to control the
; *     services (ie an admin is very likely to be using only 32-bit tools
; *     to control services)
; *
; *     Function = 5F42h
; *
; *     ENTRY   ES:BX = NetServiceControlStruct:
; *                 char far* ServiceName
; *                 unsigned short BufLen
; *                 char far* Buffer (service_info_2)
; *             DL = opcode:
; *                 0 = interrogate
; *                 1 = pause
; *                 2 = continue
; *                 3 = uninstall
; *                 4 - 127 = reserved
; *                 128 - 255 = OEM defined
; *
; *     EXIT    CF = 0
; *                 Buffer contains service_info_2 structure for requested service
; *
; *             CF = 1
; *                 AX = error code:
; *                     NERR_ServiceCtlNotValid
; *                     NERR_BufTooSmall
; *                     NERR_ServiceNotInstalled
; *                     ERROR_INVALID_PARAMETER (NEW)
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

public NetServiceControl
NetServiceControl proc near
        SVC     SVC_RDRSERVICECONTROL
        jmps    common_net_api_exit
NetServiceControl endp



; ***   NetTransactAPI
; *
; *     Function = 5F3Dh
; *
; *     ENTRY   DS:SI = transaction packet
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *             CF = 0
; *                 Success
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetTransactAPI
NetTransactAPI proc near
        SVC     SVC_RDRTRANSACTAPI
        jmps    common_net_api_exit
NetTransactAPI endp



; ***   NetUseAdd
; *
; *     Function = 5F47h
; *
; *     ENTRY   BX = level
; *             CX = buffer length
; *             DS:SI = server name for remote call (MBZ)
; *             ES:DI = buffer containing use_info_1 structure
; *
; *     EXIT    CF = 0
; *                 Success
; *
; *             CF = 1
; *                 AX = Error code
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetUseAdd
NetUseAdd proc
        SVC     SVC_RDRUSEADD
        jmps    common_net_api_exit
NetUseAdd endp



; ***   NetUseDel
; *
; *     Function = 5F48h
; *
; *     ENTRY   BX = force flag
; *             DS:SI = server name for remote call (MBZ)
; *             ES:DI = use name
; *
; *     EXIT    CF = 0
; *                 Success
; *
; *             CF = 1
; *                 AX = Error code
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetUseDel
NetUseDel proc
        SVC     SVC_RDRUSEDEL
        jmps    common_net_api_exit
NetUseDel endp



; ***   NetUseEnum
; *
; *     Function = 5F46h
; *
; *     ENTRY   BX = level of info required - 0 or 1
; *             CX = buffer length
; *             ES:DI = buffer for enum info
; *
; *     EXIT    CF = 0
; *                 CX = Entries Read
; *                 DX = Total number of entries available
; *
; *             CF = 1
; *                 AX = Error code
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetUseEnum
NetUseEnum proc
        SVC     SVC_RDRUSEENUM
        pushf                           ; error indication
        push    ax                      ; error code

;
; return EntriesRead and TotalEntries regardless of error
;

        DosCallBack GET_USER_STACK
        mov     [si].User_Cx,cx
        mov     [si].User_Dx,dx
        pop     ax
        popf
        jmpc    common_api_error_exit   ; error
        ret
NetUseEnum endp



; ***   NetUseGetInfo
; *
; *     Function = 5F49h
; *
; *     ENTRY   DS:DX = NetUseGetInfoStruc:
; *
; *                     const char FAR* NUGI_usename;   /* ASCIZ redirected device name */
; *                     short           NUGI_level;     /* level of info */
; *                     char FAR*       NUGI_buffer;    /* buffer for returned info */
; *                     unsigned short  NUGI_buflen;    /* size of buffer */
; *
; *     EXIT    CF = 0
; *                 DX = size of entry returned (or size of buffer required)
; *
; *             CF = 1
; *                 AX = Error code
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetUseGetInfo
NetUseGetInfo proc
        SVC     SVC_RDRUSEGETINFO
        jmpc    common_api_error_exit
        DosCallBack GET_USER_STACK
        mov     [si].User_Dx,dx
        clc
        ret
NetUseGetInfo endp



; ***   NetWkstaGetInfo
; *
; *     Function = 5F44h
; *
; *     ENTRY   BX = level of information - 0, 1, 10
; *             CX = size of caller's buffer
; *             DS:SI = server name for remote call (Must Be Null)
; *             ES:DI = caller's buffer
; *
; *     EXIT    CF = 0
; *                 DX = size of buffer required for request
; *                 AX = NERR_Success (0)
; *
; *             CF = 1
; *                 AX = Error code
; *                 NERR_BufTooSmall (2123)
; *                     Caller's buffer not large enough to hold even fixed
; *                     part of structure
; *
; *                 ERROR_MORE_DATA (234)
; *                     Caller's buffer large enough to hold fixed structure
; *                     part of data, but not all variable parts too
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetWkstaGetInfo
NetWkstaGetInfo proc
        SVC     SVC_RDRWKSTAGETINFO
        pushf                           ; save error indication in carry
        push    ax                      ; save error code
        DosCallBack GET_USER_STACK
        mov     [si].User_Dx,dx         ; user's dx = buffer required
        pop     ax                      ; ax = error code or ?
        popf                            ; carry flag = error (1) or no error
        jmps    common_net_api_exit     ; if error, store it, and return
NetWkstaGetInfo endp



; ***   NetWkstaSetInfo
; *
; *     Function = 5F45h
; *
; *     ENTRY   BX = level - MBZ
; *             CX = buffer size
; *             DX = parm num
; *             DS:SI = server name for remote call (MBZ)
; *             ES:DI = caller's buffer
; *
; *     EXIT    CF = 0
; *                 Success
; *
; *             CF = 1
; *                 AX = Error code
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

public NetWkstaSetInfo
NetWkstaSetInfo proc
        SVC     SVC_RDRWKSTASETINFO
        jmps    common_net_api_exit
NetWkstaSetInfo endp

ResidentCodeEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\neterror.asm ===
page    ,132
if 0

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    neterror.asm

Abstract:

    This module contains error handling code, specifically in order to get
    16-bit errors back to apps - DOS summarily truncates error codes to 8
    bits. The following routines are contained herein:

        SetNetErrorCodeAx
        ReturnNetErrorCodeAx

Author:

    Richard L Firth (rfirth) 05-Sep-1991

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

--*/

endif



.xlist                  ; don't list these include files
.xcref                  ; turn off cross-reference listing
include dosmac.inc      ; Break macro etc (for following include files only)
include dossym.inc      ; User_<Reg> defines
include mult.inc        ; MultNET
include error.inc       ; DOS errors - ERROR_INVALID_FUNCTION
include syscall.inc     ; DOS system call numbers
include rdrint2f.inc    ; redirector Int 2f numbers
include segorder.inc    ; segments
include enumapis.inc    ; dispatch codes
include debugmac.inc    ; DbgPrint macro
include localmac.inc    ; DbgPrint macro
include asmmacro.inc    ; language extensions
include rdrsvc.inc      ; BOP and SVC macros/dispatch codes
include sf.inc          ; SFT definitions/structure
.cref                   ; switch cross-reference back on
.list                   ; switch listing back on
subttl                  ; kill subtitling started in include file



.286                    ; all code in this module 286 compatible



ResidentCodeStart
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing


;
; once again, store the data in the code segment
;

CallerAx        dw      ?               ; where the error code goes
CallerCs        dw      ?               ; far return address to caller
CallerIp        dw      ?



; ***   SetNetErrorCodeAx
; *
; *     Causes a 16-bit error code to be returned in ax to a calling app. This
; *     routine is only called in the case of an error being returned
; *
; *     DOS routinely truncates any error we hand it to 8 bits, since
; *     historically DOS error codes were all <255. We do here the same
; *     execrable fix that the real redir must do - capture the return address
; *     from DOS's stack, set the DOS return address to this routine, store
; *     away the 16-bit error code and return an 8-bit error code to DOS. When
; *     DOS does an iret, we get control, set ax to the real 16-bit error, set
; *     the carry flag and return to the caller for real
; *
; *     ENTRY   AX = error code
; *
; *     EXIT    nothing affected
; *
; *     USES    ds
; *
; *     ASSUMES Not re-entrant
; *
; ***

public SetNetErrorCodeAx
SetNetErrorCodeAx proc
        pushf                           ; don't lose error indication
        push    ax                      ; or error code
        DosCallBack GET_USER_STACK
        mov     ax,[si].User_Cs
        mov     CallerCs,ax
        mov     ax,[si].User_Ip
        mov     CallerIp,ax
        mov     [si].User_Cs,cs
        mov     [si].User_Ip,offset ReturnNetErrorCodeAx
        pop     ax
        popf
        mov     CallerAx,ax
        ret
SetNetErrorCodeAx endp

; ***   ReturnNetErrorCodeAx
; *
; *     This routine is called as a result of SetNetErrorCodeAx being called.
; *     This is on the exit path from DOS to an app which called a redir
; *     entry point which returned an error.
; *     We set the real 16-bit error code that we remembered before, set the
; *     carry flag to indicate an error then iret to the real caller's return
; *     address
; *
; *     ENTRY   user's registers
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *
; *     USES    ax, carry flag
; *
; *     ASSUMES nothing
; *
; ***

public ReturnNetErrorCodeAx
ReturnNetErrorCodeAx proc
        push    CallerCs
        push    CallerIp
        mov     ax,CallerAx
        stc                             ; remember - only called if error
        retf                            ; far return
ReturnNetErrorCodeAx endp

ResidentCodeEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\segorder.inc ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    segorder.inc
;
;Abstract:
;
;    This module contains the segment order and segment macros
;
;Author:
;
;    Richard Firth (rfirth) 05-Sep-1991
;
;Environment:
;
;    Dos mode only
;
;Notes:
;
;    When initially loaded, the NT VDM redir has the following order:
;
;       +----------------------+
;       |                      |
;       |    Resident Code     |
;       |                      |
;       +----------------------+
;       |                      |
;       |    Resident Data     |
;       |                      |
;       +----------------------+ ----------------+
;       |                      |                 |
;       | Initialisation Code  | <- entry point  v
;       |                      |
;       +----------------------+
;       |                      |                 all the stuff between these
;       | Initialisation Data  |                 arrows is discarded if we stay
;       |                      |                 resident. Note that the redir
;       +----------------------+                 does not uninstall
;       |                      |
;       | Initialisation Stack |                 ^
;       |                      |                 |
;       +----------------------+ ----------------+
;
;Revision History:
;
;    05-Sep-1991 rfirth
;        Created
;
;--*/



ResidentStart   segment public para 'code'
ResidentStart   ends

ResidentCode    segment public word 'code'
ResidentCode    ends

ResidentData    segment public word 'data'
ResidentData    ends

ResidentEnd     segment public para 'data'
ResidentEnd     ends

ResidentGroup   group   ResidentStart, ResidentCode, ResidentData, ResidentEnd

InitCode        segment public para 'init'
InitCode        ends

InitData        segment public word 'init'
InitData        ends

InitStack       segment stack para 'stack'
InitStack       ends

;
; macros to avoid having to type in/possibly alter segment header guff
;

ResidentCodeStart macro
ResidentCode    segment public word 'code'
endm

ResidentCodeEnd macro
ResidentCode    ends
endm

ResidentDataStart macro
ResidentData    segment public word 'data'
endm

ResidentDataEnd macro
ResidentData    ends
endm

InitCodeStart   macro
InitCode        segment public para 'init'
endm

InitCodeEnd     macro
InitCode        ends
endm

InitDataStart   macro
InitData        segment public word 'init'
endm

InitDataEnd     macro
InitData        ends
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\br\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "O programa no pode ser executado nesta verso de MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "O Redirecionador Vdm j est carregado", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "O Redirecionador Vdm no pode ser carregado", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\chp\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "The program cannot be run on this version of MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "The Vdm Redirector is already loaded", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\chs\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "The program cannot be run on this version of MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "The Vdm Redirector is already loaded", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\redir.asm ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redir.asm

Abstract:

    This module contains the stub redir TSR code for NT VDM net support

Author:

    Richard L Firth (rfirth) 05-Sep-1991

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

--*/
endif



;
; DOS include files
;

.xlist
.xcref
include dossym.inc      ; includes MS-DOS version etc
include pdb.inc         ; PSP defines
include syscall.inc     ; AssignOper
include enumapis.inc    ; Local_API_GetRedirVersion, etc.
include segorder.inc    ; load order of 'redir' segments
include rdrsvc.inc      ; BOP and SVC macros/dispatch codes
include rdrmisc.inc     ; miscellaneous definitions
include debugmac.inc    ; debug display macros
include asmmacro.inc    ; jumps which may be short or near
include int5c.inc       ; Int to be used for pseudo network adapter
.cref
.list



;
; Misc. local manifests
;

LOAD_STACK_SIZE equ     256



;
; Define externals in resident code and data
;

ResidentCodeStart
        extrn   OldMultHandler:dword
        extrn   MultHandler:near
        extrn   Old2aHandler:dword
        extrn   Int2aHandler:near
        extrn   Old5cHandler:dword
        extrn   Int5cHandler:near
        extrn   OldNetworkHandler:dword
        extrn   IntNetworkHandler:near
        extrn   dwPostRoutineAddress:dword
if DEBUG
        extrn   Old21Handler:dword
        extrn   CheckInt21Function5e:near
endif
ResidentCodeEnd



ResidentDataStart
        extrn   LanRootLength:word
        extrn   LanRoot:byte
ResidentDataEnd



InitStack       segment stack para 'stack'

        dw      LOAD_STACK_SIZE dup (?)

top_of_stack    equ     $

InitStack       ends



InitDataStart

;
; pull in messages. Kept in a separate file to make internationalisation easier
;

include redirmsg.inc

                public ComputerName
ComputerName    db      LM20_CNLEN + 1 dup (?)

DefaultLanRoot  db      "C:\LANMAN.DOS",0
DEFAULT_LANROOT_LENGTH  equ     $-DefaultLanRoot

InitDataEnd



InitCodeStart

        assume  cs:InitCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public  start
start   proc    near

;
; when we start up we could be on any old PC - even an original, so don't
; assume anything other than a model-T processor
;

        .8086

;
; let's do the decent thing and create a stack. This way we're covered
;

        mov     dx,InitStack
        mov     ss,dx                   ; disables ints until after next ins.
        mov     sp,offset top_of_stack

        assume  ss:InitStack

;
; may as well set the data segment while we're at it - all paths set it sooner
; or later. NOTE: es will point to the PSP until we change it!
;

        mov     dx,InitData
        mov     ds,dx

        assume  ds:InitData

;
; first off, get the DOS version. If we're not running on NT (VDM) then this
; TSR's not going to do much, so exit. Exit using various methods, depending
; on the DOS version (don't you hate compatibility?)
;

        mov     ah,30h
        int     21h
        jc      ancient_version         ; version not even supported, forcrissake

;
; version is 2.0 or higher. Check it out. al = major#, ah = minor#
;

        cmp     al,major_version
        jne     invalid_version

;
; what do you know? We're actually running on NT (unless some evil programmer
; has pinched int 21h/30h and done something execrable with it!). We'd better
; do something...
; Also: at this point we know we're on at a 386, so lets enable some 286
; instructions to be generated. Eh? you justifiably ponder - is this a typo?
; Unfortunately, SoftPc only emulates the lowly 286 processor. We need to wait
; until Microsoft has paid Insignia lots of money before they can afford some
; new brains who will then dutifully provide us with full 386+ emulation (maybe)
;

        .286c

        mov     ax,(AssignOper SHL 8) + Local_API_RedirGetVersion
        int     21h                     ; is redir already loaded?
        jnc     already_here            ; yep

;
; OK, the redir is not already loaded - we're in business. Get and set the
; various interrupt vectors, Calculate the amount of space we want to keep,
; free up any unused space (like the environment segment), display a message
; in the DEBUG version, then terminate and stay resident. Remember: at this
; point we expect ES to point at the PSP
;

@@:     call    InstallInterruptHandlers

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;;
;; Initialize VDM DOS memory window address (in virtual DLC driver).
;; The memory window is used for the async Netbios, DLC and
;; named pipe post routines.
;;
;
;        push    es                      ; PSP
;        mov     bx,ResidentCode
;        mov     es,bx
;
;        assume  es:ResidentCode
;
;;
;; now that VDMREDIR support is a DLL, we can fail initialization on the 32-bit
;; side if the DLL cannot be loaded, or the entry points not found. In this case
;; we will fail to load redir.exe, rather than constantly returning
;; ERROR_NOT_SUPPORTED every time we make a redir BOP
;;
;
;        mov     bx,offset dwPostRoutineAddress
;        SVC     SVC_VDM_WINDOW_INIT
;        pop     es                      ; es back to PSP
;        jmpc    initialization_error
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD

        assume  es:nothing

;
; free the environment segment
;

        mov     es,es:[PDB_environ]
        mov     ah,49h
        int     21h                     ; free environment segment

if DEBUG
ifdef PROLIX
        DbgPrintString <"Redir successfully loaded",13,10>
endif
endif

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;;
;; now perform the BOP which will let the 32-bit redir support know that the
;; DOS redirector TSR is successfully loaded. This must be the last action -
;; we cannot fail installation after this point (unless we call the BOP to
;; uninitialize 32-bit VDM redir support
;;
;
;        mov     bx,seg ComputerName
;        mov     es,bx
;
;        assume  es:seg ComputerName
;
;        mov     bx,offset ComputerName  ; initialization returns the computer name
;        mov     cx,size ComputerName    ; which will be gettable using int 21/ah=5e
;        SVC     SVC_RDRINITIALIZE
;        jmpc    initialization_error    ; 32-bit DLL failed (?)
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD

;        DbgBreakPoint                   ; check computer name returned

;
; set the computer name returned from the 32-bit side
;

if DEBUG
ifdef PROLIX
        DbgPrintString <"Set computer name here",13,10>
endif
endif

if 0
        mov     ax,5e01h                ; set machine name
        xor     cx,cx                   ; cx is 'user num'
        int     21h
endif

;
; do initialisation things - set the lanroot to the default if not otherwise
; specified
;

        mov     ax,InitData
        mov     ds,ax

        assume  ds:InitData

        mov     ax,ResidentData
        mov     es,ax

        assume  es:ResidentData

        mov     LanRootLength,DEFAULT_LANROOT_LENGTH
        mov     si,offset DefaultLanRoot
        mov     di,offset LanRoot
        cld
        mov     cx,DEFAULT_LANROOT_LENGTH/2
        rep     movsw
if (DEFAULT_LANROOT_LENGTH and 1)
        movsb
endif

;
; finally terminate and stay resident
;

        mov     dx,ResidentEnd
        sub     dx,ResidentStart        ; number of paragraphs in resident code
        add     dx,10h                  ; additional for PSP (PDB)

;        DbgBreakPoint

if DEBUG
ifdef PROLIX
        DbgPrintString "Staying resident with "
        DbgPrintHexWord dx
        DbgPrintString " paragraphs. Load seg is ",NOBANNER
        mov     ah,62h
        int     21h
        DbgPrintHexWord bx
        DbgPrintString " current seg is ",NOBANNER
        DbgPrintHexWord cs
        DbgCrLf
endif
endif

        mov     ax,3100h
        int     21h                     ; terminate and stay resident

;
; here if the MS-DOS version check (Ah=30h) call is not supported
;

ancient_version:
        mov     dx,InitData
        mov     ds,dx

        assume  ds:InitData

        mov     dx,offset bad_ver_msg
        mov     ah,9                    ; cp/m-style write to output
        int     21h

;
; safe exit: what we really want to do here is INT 20H, but when you do this,
; CS must be the segment of the PSP of this program. Knowing that CD 20 is
; embedded at the start of the PSP, the most foolproof way of doing this is
; to jump (using far return) to the start of the PSP
;

        push    es
        xor     ax,ax
        push    ax
        retf                            ; terminate

;
; we are running on a version of DOS >= 2.00, but its not NT, so we still can't
; help. Display the familiar message and exit, but using a less programmer-
; hostile mechanism
;

invalid_version:
        mov     dx,offset bad_ver_msg
        mov     cx,BAD_VER_MSG_LEN
        jmp     short print_error_message_and_exit

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;;
;; if we cannot initialize 32-bit support (because we can't find/load the DLL)
;; then put back the hooked interrupt vectors as they were when this TSR started,
;; display a message and fail to load the redir TSR
;;
;
;initialization_error:
;        call    RestoreInterruptHandlers
;        mov     dx,offset cannot_load_msg
;        mov     cx,CANNOT_LOAD_MSG_LEN
;        jmps    print_error_message_and_exit
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD

;
; The DOS version's OK, but this TSR is already loaded
;

already_here:
        mov     dx,offset already_loaded_msg
        mov     cx,ALREADY_LOADED_MSG_LEN

print_error_message_and_exit:
        mov     bx,1                    ; bx = stdout handle
        mov     ah,40h                  ; write to handle
        int     21h                     ; write (cx) bytes @ (ds:dx) to stdout
        mov     ax,4c01h                ; terminate program
        int     21h                     ; au revoir, cruel environment

start   endp

;*******************************************************************************
;*
;*  InstallInterruptHandlers
;*
;*      Sets the interrupt handlers for all the ints we use - 2a, 2f, 5c
;*      and NETWORK_INTERRUPT (0e)
;*
;*  ENTRY       es = PSP segment
;*              ds =
;*
;*  EXIT        OldMultHandler contains the original interrupt 2f vector
;*              Old2aHandler contains the original interrupt 2a vector
;*              Old5cHandler contains the original interrupt 5c vector
;*              OldNetworkHandler contains the original interrupt 0e vector
;*
;*  RETURNS     nothing
;*
;*  ASSUMES
;*
;*******************************************************************************

InstallInterruptHandlers proc
        push    es                      ; PSP segment - destroyed by INT 21/35h
        push    ds

;
; note: if we use ResidentCode here, explicitly, instead of seg OldMultHandler,
; then we can leave out an extraneous load of ds for the ISR address
;

        mov     dx,ResidentCode
        mov     ds,dx

        assume  ds:ResidentCode

        mov     ax,352fh                ; get current INT 2Fh vector
        int     21h
        mov     word ptr OldMultHandler,bx
        mov     word ptr OldMultHandler+2,es
        mov     dx,offset ResidentCode:MultHandler
        mov     ax,252fh
        int     21h                     ; set INT 2Fh vector to our handler

;
; we have to pinch int 2a too - certain parts of the net libraries perform a
; net check using a presence check on 2ah
;

        mov     ax,352ah
        int     21h
        mov     word ptr Old2aHandler,bx
        mov     word ptr Old2aHandler+2,es
        mov     dx,offset ResidentCode:Int2aHandler
        mov     ax,252ah
        int     21h

;
; we have to pinch int 5c for Netbios and DLC
;

        mov     ax,355ch
        int     21h
        mov     word ptr Old5cHandler,bx
        mov     word ptr Old5cHandler+2,es
        mov     dx,offset ResidentCode:Int5cHandler
        mov     ax,255ch
        int     21h

;
; we have to pinch int NETWORK_INTERRUPT for Netbios and DLC
;

        mov     ax,3500h OR NETWORK_INTERRUPT
        int     21h
        mov     word ptr OldNetworkHandler,bx
        mov     word ptr OldNetworkHandler+2,es
        mov     dx,offset ResidentCode:IntNetworkHandler
        mov     ax,2500h OR NETWORK_INTERRUPT
        int     21h

;if DEBUG
;;
;; get the int 21 handler too so we can find out if anyone's calling the
;; (unsupported) int 21/ah=5e
;;
;
;        mov     ax,3521h
;        int     21h
;        mov     word ptr Old21Handler,bx
;        mov     word ptr Old21Handler+2,es
;        mov     dx,offset ResidentCode:CheckInt21Function5e
;        mov     ax,2521h
;        int     21h
;endif

        pop     ds                      ; restore segment registers
        pop     es
        ret
InstallInterruptHandlers endp

;*******************************************************************************
;*
;*  RestoreInterruptHandlers
;*
;*      Resets the interrupt handlers for all the ints we use - 2a, 2f, 5c
;*      and NETWORK_INTERRUPT (0e). Called in the event we cannot complete
;*      installation
;*
;*  ENTRY       OldMultHandler, Old2aHandler, Old5cHandler, OldNetworkHandler
;*              contain the interrupt vectors from before redir.exe was loaded
;*
;*  EXIT        Original interrupt vectors are restored
;*
;*  RETURNS     nothing
;*
;*  ASSUMES
;*
;*******************************************************************************

RestoreInterruptHandlers proc
        push    ds

        assume  ds:nothing

        push    es
        mov     dx,ResidentCode
        mov     es,dx

        assume  es:ResidentCode

        lds     dx,OldMultHandler
        mov     ax,252fh
        int     21h                     ; set INT 2Fh vector to previous handler

        lds     dx,Old2aHandler
        mov     ax,252ah
        int     21h

        lds     dx,Old5cHandler
        mov     ax,255ch
        int     21h

        lds     dx,OldNetworkHandler
        mov     ax,2500h OR NETWORK_INTERRUPT
        int     21h

;if DEBUG
;        lds     dx,Old21Handler
;        mov     ax,2521h
;        int     21h
;endif

        pop     es
        pop     ds
        ret
RestoreInterruptHandlers endp

InitCodeEnd
end     start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\resident.asm ===
page    ,132
if 0

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    resident.asm

Abstract:

    This module contains the resident code part of the stub redir TSR for NT
    VDM net support. The routines contained herein are the 2f handler and the
    API support routines:

        MultHandler
        ReturnMode
        SetMode
        GetAssignList
        DefineMacro
        BreakMacro
        GetRedirVersion
        NetGetUserName
        DefaultServiceError
        NetGetEnumInfo
        NetSpoolStuff

Author:

    Richard L Firth (rfirth) 05-Sep-1991

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

--*/

endif



.xlist                  ; don't list these include files
.xcref                  ; turn off cross-reference listing
include dosmac.inc      ; Break macro etc (for following include files only)
include dossym.inc      ; User_<Reg> defines
include mult.inc        ; MultNET
include error.inc       ; DOS errors - ERROR_INVALID_FUNCTION
include syscall.inc     ; DOS system call numbers
include rdrint2f.inc    ; redirector Int 2f numbers
include segorder.inc    ; segments
include enumapis.inc    ; dispatch codes
include debugmac.inc    ; DbgPrint macro
include localmac.inc    ; DbgPrint macro
include asmmacro.inc    ; language extensions
include rdrsvc.inc      ; BOP and SVC macros/dispatch codes
include rdrmisc.inc     ; miscellaneous definitions
include sf.inc          ; SFT definitions/structure
include vrdefld.inc     ; VDM_LOAD_INFO
.cref                   ; switch cross-reference back on
.list                   ; switch listing back on
subttl                  ; kill subtitling started in include file



.286                    ; all code in this module 286 compatible



ResidentDataStart
        public  LanRootLength, LanRoot

LanRootLength   dw      ?       ; can't be >81 bytes anyhow
LanRoot         db      (64+3+1+13) dup (?)

ResidentDataEnd



ResidentCodeStart
        extrn DosQnmPipeInfo:           near
        extrn DosQNmpHandState:         near
        extrn DosSetNmpHandState:       near
        extrn DosPeekNmPipe:            near
        extrn DosTransactNmPipe:        near
        extrn DosCallNmPipe:            near
        extrn DosWaitNmPipe:            near
        extrn NetTransactAPI:           near
        extrn NetIRemoteAPI:            near
        extrn NetUseAdd:                near
        extrn NetUseDel:                near
        extrn NetUseEnum:               near
        extrn NetUseGetInfo:            near
        extrn NetServerEnum:            near
        extrn DosMakeMailslot:          near
        extrn DosDeleteMailslot:        near
        extrn DosMailslotInfo:          near
        extrn DosReadMailslot:          near
        extrn DosPeekMailslot:          near
        extrn DosWriteMailslot:         near
        extrn NetNullTransactAPI:       near
        extrn NetServerEnum2:           near
        extrn NetServiceControl:        near
        extrn NetWkstaGetInfo:          near
        extrn NetWkstaSetInfo:          near
        extrn NetMessageBufferSend:     near
        extrn NetHandleGetInfo:         near
        extrn NetHandleSetInfo:         near
        extrn DosReadAsyncNmPipe:       near
        extrn DosWriteAsyncNmPipe:      near
        extrn DosReadAsyncNmPipe2:      near
        extrn DosWriteAsyncNmPipe2:     near
        extrn MessengerDispatch:        near

;
; IMPORTANT: This structure MUST be the first thing in the resident code segment
;

        extrn dwPostRoutineAddress:     dword

VdmWindowAddr   VDM_LOAD_INFO <dwPostRoutineAddress, 0>

        align 4

;
; Address of previous handler to chain if int 2f not for us
;

        public  OldMultHandler
OldMultHandler  dd      ?

;
; OldFunctionTable is a table of near pointers to handlers for the old 5f
; functions 5f00 through 5f05
;

OldFunctionTable label word
        dw      ReturnMode              ; 5f00
        dw      SetMode                 ; 5f01
        dw      GetAssignList           ; 5f02
        dw      DefineMacro             ; 5f03
        dw      BreakMacro              ; 5f04
        dw      GetAssignList2          ; 5f05

;
; May as well keep this jump table in the code segment - no point in loading
; ds just to get a jump offset
;

MultDispatchTable label   word
        dw      GetRedirVersion         ; 5f30
        dw      DefaultServiceError     ; 5f31 - NetWkstaSetUID
        dw      DosQnmPipeInfo          ; 5f32
        dw      DosQNmpHandState        ; 5f33
        dw      DosSetNmpHandState      ; 5f34
        dw      DosPeekNmPipe           ; 5f35
        dw      DosTransactNmPipe       ; 5f36
        dw      DosCallNmPipe           ; 5f37
        dw      DosWaitNmPipe           ; 5f38
        dw      DefaultServiceError     ; 5f39 - DosRawReadNmPipe
        dw      DefaultServiceError     ; 5f3a - DosRawWriteNmPipe
        dw      NetHandleSetInfo        ; 5f3b
        dw      NetHandleGetInfo        ; 5f3c
        dw      NetTransactAPI          ; 5f3d
        dw      DefaultServiceError     ; 5f3e - NetSpecialSMB
        dw      NetIRemoteAPI           ; 5f3f
        dw      NetMessageBufferSend    ; 5f40
        dw      DefaultServiceError     ; 5f41 - NetServiceEnum
        dw      NetServiceControl       ; 5f42
        dw      DefaultServiceError     ; 5f43 - DosPrintJobGetID
        dw      NetWkstaGetInfo         ; 5f44
        dw      NetWkstaSetInfo         ; 5f45
        dw      NetUseEnum              ; 5f46
        dw      NetUseAdd               ; 5f47
        dw      NetUseDel               ; 5f48
        dw      NetUseGetInfo           ; 5f49
        dw      DefaultServiceError     ; 5f4a - NetRemoteCopy
        dw      DefaultServiceError     ; 5f4b - NetRemoteMove
        dw      NetServerEnum           ; 5f4c
        dw      DosMakeMailslot         ; 5f4d
        dw      DosDeleteMailslot       ; 5f4e
        dw      DosMailslotInfo         ; 5f4f
        dw      DosReadMailslot         ; 5f50
        dw      DosPeekMailslot         ; 5f51
        dw      DosWriteMailslot        ; 5f52
        dw      NetServerEnum2          ; 5f53
        dw      NetNullTransactAPI      ; 5f54 - NullTransaction entrypoint.

MAX_TABLE_ENTRIES       =       (($-MultDispatchTable)/type MultDispatchTable)-1


;
; this next table dispatches the functions that come in through a direct call
; to int 2f, ah=11, al=function code
;

ServiceDispatchTable label word
        dw      NetGetUserName          ; 80h - NetGetUserName          o
        dw      DefaultServiceError     ; 81h - NetSetUserName          x
        dw      DefaultServiceError     ; 82h - NetServiceNotify        x
        dw      DefaultServiceError     ; 83h - NetPrintNameEnum        x
        dw      NetGetEnumInfo          ; 84h - NetGetEnumInfo          o
        dw      DefaultServiceError     ; 85h - TestDBCSLB              x
        dw      DosReadAsyncNmPipe      ; 86h - DosReadAsyncNmPipe      x
        dw      DefaultServiceError     ; 87h - DosUnusedFunction1      x
        dw      DefaultServiceError     ; 88h - DosUnusedFunction2      x
        dw      DefaultServiceError     ; 89h - NetCalloutNCB           x
        dw      DefaultServiceError     ; 8Ah - EncrPasswd              x
        dw      DefaultServiceError     ; 8Bh - NetGetLogonServer       o
        dw      DefaultServiceError     ; 8Ch - NetSetLogonServer       o
        dw      DefaultServiceError     ; 8Dh - NetGetDomain            o
        dw      DefaultServiceError     ; 8Eh - NetSetDomain            o
        dw      DosWriteAsyncNmPipe     ; 8FH - DosWriteAsyncNmPipe     x
        dw      DosReadAsyncNmPipe2     ; 90H - DosReadAsyncNmPipe2     x
        dw      DosWriteAsyncNmPipe2    ; 91H - DosWriteAsyncNmPipe2    x

MAX_SERVICE_ENTRIES     =       (($-ServiceDispatchTable)/type ServiceDispatchTable)-1

page
; ***   MultHandler
; *
; *     Whenever an INT 2F call is made, sooner or later this function will
; *     get control. If the call is actually for the redir, AH will be set
; *     to 11h (MultNET). If it is any other value then we just chain it
; *     along. Note that since there is no MINSES loaded in the NT DOS network
; *     stack, then we need also to fake calls to MINSES. These are made through
; *     INT 2F, with ah = 0xB8. We trap calls AX=B800 (network presence test)
; *     and AX=B809 (network/redir installation test)
; *
; *     ENTRY   ax = (MultNET << 8) | net operation code
; *             Net operation code can be:
; *                     Install check    0
; *                     Assign operation 30
; *             Anything else is DOS/NET specific. We should raise a gorbachev
; *             or rather an error if we receive something else
; *
; *             Stack:  IP      \
; *                     CS       >      From Int 2f
; *                     Flags   /
; *                     Caller's AX     From call to Int 21/ah=5f
; *
; *             We need the caller's AX to dispatch the NetAssOper calls, nothing
; *             more
; *
; *             All the rest of the registers are as per the caller
; *
; *     EXIT    CF = 0
; *                 success
; *             CF = 1
; *                 AX = error
; *
; *     USES    all regs
; *
; *     ASSUMES Earth is flat
; *
; ***

if DEBUG
OriginalAx      dw      ?
OriginalBx      dw      ?
endif

        public  MultHandler
MultHandler     proc    far
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

if DEBUG
        mov     OriginalAx,ax
        mov     OriginalBx,bx
endif
        cmp     ah,MultNET              ; 11h
        je      @f

;
; test for AH=B8 and return network presence indicators if it is. Here we are
; faking calls to MINSES (minimum session layer) and intercept calls AX=B800
; and AX=B809. Any other AH=B8 call must be for a different TSR/driver
;

        cmp     ah,0b8h
        jne     check_messenger
        or      al,al
        jnz     try_9

;
; AX=B800. This is the MinSes installation check. Return the magic numbers
; AL=1 and BX=8 (see doslan\minses\int2f.inc in LANMAN project)
;

        inc     al
        mov     bx,8
do_iret:iret

try_9:
        cmp     al,9
        jne     chain_previous_handler  ; AL not 0 or 9, AH=B8 for somebody else

;
; AX=B809 is a network installation test. Return the magic numbers AL=1, AH=2
; for PC Network version 1.2 (this is what minses does, don't complain to me
; about PC networks, etc, etc)
;

        mov     ax,0201h
        jmp     short do_iret

;
; MESSENGER TSR uses AH=42h
;

check_messenger:
        cmp     ah,42h                  ; multMESSAGE
        jne     chain_previous_handler
        call    MessengerDispatch
        retf    2                       ; return state in flags

chain_previous_handler:
        jmp     OldMultHandler          ; not for us; pass it along

;
; the 2f call is for us. If it is the installation check, return al == -1 else
; dispatch the byte code at sp+6
;

@@:     sti                             ; re-enable interrupts
        or      al,al
        jnz     @f
        or      al,-1                   ; installation check just returns 0xff
        ret     2                       ; 'or' clears carry

@@:     cld                             ; auto-increment string operations

;
; this call is something other than an installation check. I really hope that
; its the AssignOper request, because I don't know what to do if it isn't...
;

        cmp     al,_2F_NET_ASSOPER
        jmpe    is_net_request          ; yes - we can do something

;
; if its the ResetEnvironment request then we have to kill any net state info
; like mailslot info. Return via iret
;

        cmp     al,_2F_NetResetEnvironment
        jmpne   check_service_call

;
; deferred loading: don't load VDMREDIR.DLL for VrTerminateDosProcess if no NET
; calls have been made
;

        cmp     VdmWindowAddr.VrInitialized,1
        je      @f
        iret

if 0
        DbgPrintString "NetResetEnvironment received. PDB="
        push    ax                      ; int 21/51 uses ax,bx
        push    bx
endif

@@:     mov     ah,51h
        int     21h                     ; get current PDB

if 0
        DbgPrintHexWord bx              ; bx contains PSP of current process
        pop     bx
        pop     ax
        DbgCrLf
endif

        mov     ax,bx
        SVC     SVC_RDRTERMINATE
        iret

;
; if this is a net service call (ah=11h, al=function code 80h through 91h) then
; dispatch through the service table
;

check_service_call:
        cmp     al,_2F_NetSpoolOper     ; 25h
        jne     @f
        call    NetSpoolStuff
        jmp     short return_to_dos
@@:     cmp     al,_2F_NetGetUserName   ; 80h
        jmpb    trap_it
        cmp     al,_2F_DosWriteAsyncNmPipe2     ; 91h
        jmpa    trap_it

if 0
        DbgPrintString "Received Service Request: "
        DbgPrintHexWord ax
        DbgCrLf
endif

        sub     ax,(MultNET shl 8) + _2F_NetGetUserName
        xchg    ax,bx
        shl     bx,1
        mov     bx,ServiceDispatchTable[bx]
        xchg    ax,bx
        call    ax

;
; all calls that come through here are expected to have originated in DOS
;

return_to_dos:
        ret     2                       ; with interrupts enabled
;
; if we get anything else, either from DOS, or some - as yet - unknown source,
; then just pass it along to the next handler. In the debug version, we alert
; someone to the fact that we've got an unrecognized call
;

trap_it:
        DbgPrintString "Received unrecognized Service Request: "
        DbgPrintHexWord ax
        DbgCrLf
        DbgBreakPoint

        jmp     OldMultHandler          ; pass it down the chain

;
; get the original dispatch code back off the stack. We no longer require the
; current contents of ax
;

is_net_request:
        push    bp
        mov     bp,sp
        mov     ax,[bp + 8]             ; ax <- original code (5fxx)
        pop     bp

if DEBUG
        mov     OriginalAx,ax
endif

;
; quick sanity check to make sure that we're processing the right call. If we
; were called with ax != 5fxx, assume that somebody else is also using the
; same 2F function call, and chain the next handler. Note: this wouldn't be
; a very smart thing to do
;

        sub     ah,AssignOper           ; ah => 0 it is AssignOper
        jz      @f
        DbgBreakPoint
        mov     ax,(MultNET shl 8) + _2F_NET_ASSOPER    ; restore ax
        jmps    chain_previous_handler

@@:     cmp     al,5                    ; is it 5f00 - 5f05?
        jnbe    @f

;
; if the function is in the range 0 - 5 then its an old function - dispatch
; through the old function table
;

        shl     al,1
        xchg    ax,bx
        mov     bx,OldFunctionTable[bx]
        xchg    ax,bx
        call    ax
        ret     2

@@:     sub     al,Local_API_RedirGetVersion
        jz      @f                      ; function is GetRedirVersion
        cmp     al,MAX_TABLE_ENTRIES
        jbe     @f                      ; UNSIGNED comparison!!!

;
; get 32-bit support code to dump registers to debug terminal
;

if DEBUG
        mov     ax,OriginalAx
        DbgUnsupported
endif

        mov     ax,ERROR_NOT_SUPPORTED
        stc                             ; set error indication
        jmp     short set_ax_exit

;
; the function is within range. Dispatch it. Copy the offset from the dispatch
; table into ax then call through ax. ax was only required to get us this far
; and contains no useful information
;

@@:     xchg    ax,bx                   ; need base register, ax not good enough in 286
        shl     bx,1                    ; bx is now offset in dispatch table
        mov     bx,MultDispatchTable[bx]; bx is offset of handler routine
        xchg    ax,bx                   ; restore caller's bx
        call    ax                      ; go handle it
        ret     2                       ; return without reinstating flags

;
; Return an error in the caller's ax register. To do this we have to ask DOS to
; please give us the address of its copy of the user's registers, which it will
; pass back in DS:SI. We then futz with the copy of the user's reg. Dos will
; restore this before returning control to the user code. Since we know we have
; an error situation set the carry flag
;

set_ax_exit:
        pushf                           ; error indicator
        push    ax                      ; return code
        DosCallBack GET_USER_STACK      ; get pointer to caller's context

        assume  ds:nothing              ; nuked - actually in DOS somewhere (stack)

        pop     [si].User_Ax            ; copy saved return code into user's copy
        popf                            ; restore error indicator
        ret     2                       ; clear caller's flags from int 2f call
MultHandler     endp

page
; ***   ReturnMode
; *
; *     Returns the disk or print redirection flag. Flag is 0 if redirection
; *     is paused, else 1
; *
; *     ENTRY   BL = 3
; *                 Return print redirection
; *
; *             BL = 4
; *                 Return drive redirection
; *
; *     EXIT    CF = 0
; *                  BX = redirection flag: 0 or 1
; *
; *             CF = 1
; *                  error
; *
; *     USES    bx
; *
; *     ASSUMES nothing
; *
; ***

PrintRedirection db 0
DriveRedirection db 0

ReturnMode proc near
        assume  cs:ResidentCode
        assume  ds:nothing

        DbgPrintString <"5f00 called",13,10>
        DbgUnsupported

        cmp     bl,3
        jne     @f
        mov     bh,PrintRedirection
        jmp     short set_info
@@:     cmp     bl,4
        stc
        jnz     @f
        mov     bh,DriveRedirection
set_info:
        and     bh,1
        DosCallBack GET_USER_STACK
        mov     [si].User_Bx,bx
        clc
@@:     ret
ReturnMode endp

page
; ***   SetMode
; *
; *     Pauses or continues drive or printer redirection. Note that we don't
; *     support drive/print pause/continuation from DOS
; *
; *     ENTRY   BL = printer (3) or drive (4) redirection
; *             BH = pause (0) or continue (1)
; *
; *     EXIT    CF = 0
; *                 success
; *             CF = 1
; *                 ax = ERROR_INVALID_PARAMETER
; *
; *     USES    ax, bx
; *
; *     ASSUMES nothing
; *
; ***

SetMode proc near
        assume  cs:ResidentCode
        assume  ds:nothing

        DbgPrintString <"5f01 called",13,10>
        DbgUnsupported

        cmp     bh,1
        jnbe    bad_parm_exit
        dec     bh                      ; convert 0 => ff, 1 => 0
        not     bh                      ; convert ff => 0, 0 => ff
        sub     bl,3
        jnz     try_drive
        mov     PrintRedirection,bh
        jmp     short ok_exit
try_drive:
        dec     bl
        jnz     bad_parm_exit
        mov     DriveRedirection,bh
ok_exit:clc
        ret
bad_parm_exit:
        mov     ax,ERROR_INVALID_PARAMETER
        stc
        ret
SetMode endp

page
; ***   GetAssignList
; *
; *     Returns information on enumerated redirections. Old version of
; *     NetUseGetInfo
; *
; *     ENTRY   BX = which item to return (starts @ 0)
; *             DS:SI points to local redirection name
; *             ES:DI points to remote redirection name
; *             AL != 0 means return LSN in BP (GetAssignList2)? ** UNSUPPORTED **
; *
; *     EXIT    CF = 0
; *                 BL = macro type (3 = printer, 4 = drive)
; *                 BH = 'interesting' bits: 00 = valid, 01 = invalid
; *                 CX = user word
; *                 DS:SI has device type
; *                 ES:DI has net path
; *             CF = 1
; *                 AX = ERROR_NO_MORE_FILES
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

GetAssignList proc near
        assume  cs:ResidentCode
        assume  ds:nothing

        xor     al,al
        jmp     short @f
GetAssignList2:
        or      al,-1
@@:     SVC     SVC_RDRGET_ASG_LIST
        jc      @f
        push    bx
        push    cx
        DosCallBack GET_USER_STACK
        pop     [si].User_Cx
        pop     [si].User_Bx
        clc
@@:     ret
GetAssignList endp

page
; ***   DefineMacro
; *
; *     Old version of NetUseAdd
; *
; *     ENTRY   BL = device type
; *                 3 = printer
; *                 4 = drive
; *             bit 7 on means use the wksta password when connecting
; *             CX = user word
; *             DS:SI = local device
; *                 Can be NUL device name, indicating UNC use
; *             ES:DI = remote name
; *
; *     EXIT    CF = 0
; *                 success
; *
; *             CF = 1
; *                 AX = ERROR_INVALID_PARAMETER (87)
; *                      ERROR_INVALID_PASSWORD (86)
; *                      ERROR_INVALID_DRIVE (15)
; *                      ERROR_ALREADY_ASSIGNED (85)
; *                      ERROR_PATH_NOT_FOUND (3)
; *                      ERROR_ACCESS_DENIED (5)
; *                      ERROR_NOT_ENOUGH_MEMORY (8)
; *                      ERROR_NO_MORE_FILES (18)
; *                      ERROR_REDIR_PAUSED (72)
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

DefineMacro proc near
        assume  cs:ResidentCode
        assume  ds:nothing

        SVC     SVC_RDRDEFINE_MACRO
        ret
DefineMacro endp

page
; ***   BreakMacro
; *
; *     Old version of NetUseDel
; *
; *     ENTRY   DS:SI = buffer containing device name of redirection to break
; *
; *     EXIT
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

BreakMacro proc near
        assume  cs:ResidentCode
        assume  ds:nothing

        SVC     SVC_RDRBREAK_MACRO
        ret
BreakMacro endp

page
; ***   GetRedirVersion
; *
; *     Returns the version number of this redir in ax
; *
; *     ENTRY   none
; *
; *     EXIT    ax = version #
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

GetRedirVersion proc    near
        assume  cs:ResidentCode
        assume  ds:nothing

        mov     ax,300
        clc
        ret
GetRedirVersion endp

page
; ***   NetGetUserName
; *
; *     Returns the current logged on user name (if any)
; *
; *     ENTRY   CX = buffer length
; *             ES:DI = buffer
; *
; *     EXIT    CF = 1
; *                 AX = Error code
; *                 NERR_BufTooSmall
; *                     Buffer not large enough for user name
; *
; *             CF = 0
; *                 CX:BX = UID (ignored)
; *                 ES:DI = user name
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

NetGetUserName proc    near
        assume  cs:ResidentCode
        assume  ds:nothing

        mov     bx,1                    ; bx == 1: check name length against cx
        call    NetGetUserNameSvcCall

        DbgBreakPoint

        jc      @f                      ; error

;
; no error: the user name was copied into ES:DI. Set the caller's cx and bx to
; return a UID. We could leave this as a random number since it is not used,
; but we set it to a known value
;

        DosCallBack GET_USER_STACK
        xor     ax,ax                   ; clears carry again
        mov     [si].User_Cx,ax
        inc     ax
        mov     [si].User_Bx,ax         ; UID = 0x00000001
@@:     ret
NetGetUserName endp

page
; ***   DefaultServiceError
; *
; *     Default error routine - returns ERROR_INVALID_FUNCTION for any API
; *     function which we don't support. Reached exclusively through dispatch
; *     table
; *
; *     ENTRY   none
; *
; *     EXIT    CF = 1
; *                 AX = ERROR_INVALID_FUNCTION
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

DefaultServiceError proc near
        assume  cs:ResidentCode
        assume  ds:nothing

;        DbgPrintString <"DefaultServiceError Ax="
;        DbgPrintHexWord OriginalAx
;        DbgPrintString <" Bx=">,NOBANNER
;        DbgPrintHexWord OriginalBx
;        DbgCrLf

;
; cause debug output to go to debug port: making invalid BOP will dump registers
;

if DEBUG
        mov     ax,OriginalAx
        mov     bx,OriginalBx
        DbgUnsupported
endif
        mov     ax,ERROR_INVALID_FUNCTION
        stc
        ret
DefaultServiceError endp

page
; ***   NetGetEnumInfo
; *
; *     Routine which returns various internal redir variables based on an
; *     index
; *
; *     ENTRY   BL = index
; *              0 = CDNames
; *              1 = Comment (not supported)
; *              2 = LanRoot
; *              3 = ComputerName
; *              4 = UserName
; *              5 = Primary Domain
; *              6 = Logon Server
; *              7 = Mailslots Yes/No
; *              8 = RIPL Yes/No
; *              9 = Get RIPL UNC
; *             10 = Get RIPL drive
; *             11 = Start marking CON_RIPL
; *             12 = Stop marking CON_RIPL
; *             13 = exchange int17 handlers
; *             14 = primary WrkNet
; *
; *             es:di = buffer for returned info
; *
; *     EXIT    CF = 0
; *                 success
; *             CF = 1
; *                 AX = ERROR_INVALID_FUNCTION
; *
; *     USES    ax, flags
; *
; *     ASSUMES nothing
; *
; ***

NetGetEnumInfo proc near
        or      bl,bl
        jnz     @f

;
; CDNames (Computer and Domain Names)
;

;        DbgPrintString <"NetGetEnumInfo: return CDNames", 13, 10>
        SVC     SVC_RDRGETCDNAMES
        ret

;
; Comment - nothing returned by this or the original redir (ax = invalid
; function, but carry clear?)
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: return Comment", 13, 10>
        mov     ax,ERROR_INVALID_FUNCTION
        ret

;
; LanRoot
;

@@:     dec     bl
        jnz     check_computername
        DbgPrintString <"NetGetEnumInfo: return LanRoot", 13, 10>
        pusha                           ; save user gp regs
        push    es                      ; save user seg regs
        push    ds
        mov     si,ResidentData
        mov     ds,si
        assume  ds:ResidentData
        mov     si,offset LanRoot
        mov     cx,LanRootLength
        shr     cx,1                    ; cx = number of words to copy, cf=lsb
        cld
        rep     movsw                   ; copy words
        jnc     @f                      ; if not odd number of bytes skip
        movsb                           ; copy single byte
@@:     pop     ds                      ; restore user seg regs
        pop     es
        popa                            ; restore user gp regs
        ret

;
; ComputerName
;

check_computername:
        dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: return ComputerName", 13, 10>
        SVC     SVC_RDRGETCOMPUTERNAME
        ret
;
; Username
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: return UserName", 13, 10>

;
; This is also the entry point for NetGetUserName, which return some info in
; cx:bx (the (ignored) UID). We could leave this random, but we set it to a
; known value, just in case
;

NetGetUserNameSvcCall:
        SVC     SVC_RDRGETUSERNAME      ; either 0 if for NetGetEnumInfo or 1 if NetGetUserName
        ret

;
; Primary domain name
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: return DomainName", 13, 10>
        SVC     SVC_RDRGETDOMAINNAME
        ret

;
; Logon server name
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: return LogonServerName", 13, 10>
        SVC     SVC_RDRGETLOGONSERVER
        ret

;
; Mailslots YN
;
; Mailslots are always enabled with this redir, so return yes (TRUE, 1)
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: Mailslot check", 13, 10>
        mov     ax,1
        ret

;
; RIPL YN
;
; This redir doesn't know anything about RPL, so return no (FALSE, 0)
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: RIPL check", 13, 10>
        xor     ax,ax
        ret

;
; RIPL UNC
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: return RIPL UNC", 13, 10>
        jmps    DefaultServiceError

;
; RIPL drive
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: return RIPL drive", 13, 10>
        jmps    DefaultServiceError

;
; Start marking CON_RIPL
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: Start marking CON_RIPL", 13, 10>
        jmps    DefaultServiceError

;
; Stop marking CON_RIPL
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: Stop marking CON_RIPL", 13, 10>
        jmps    DefaultServiceError

;
; exchange int 17 handlers
;
; We don't support this so return error
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: exchange int 17 handlers", 13, 10>
        jmps    DefaultServiceError

;
; primary WrkNet
;
; This is transport-specific so we don't return anything except error
;

@@:     dec     bl
        jnz     @f
        DbgPrintString <"NetGetEnumInfo: return primary WrkNet", 13, 10>
        jmps    DefaultServiceError

;
; anything else - return an error
;

@@:     DbgPrintString "NetGetEnumInfo: unknown request: "
        DbgPrintHexWord bx
        DbgCrLf
        jmps    DefaultServiceError
NetGetEnumInfo endp

page
; ***   NetSpoolStuff
; *
; *     Gets control from INT 2f/ax=1125h. This really has no use in NTVDM,
; *     but we supply it because DOS has started making 1125 calls. Spooling
; *     in NTVDM has nothing to do with the Redir TSR. Historically, printing
; *     over the net was handled by the redir & this call was used (amongst
; *     other things) to flush & close all spool files when an app terminated
; *
; *     ENTRY   AL = 7  Return truncate flag in DL (DH destroyed)
; *             AL = 8  Set truncate flag from DL (must be 0 or 1)
; *             AL = 9  Close all spool files
; *
; *     EXIT    CF = 1
; *                 AX = ERROR_INVALID_FUNCTION
; *
; *     USES    ax, dx, si, ds, flags
; *
; *     ASSUMES nothing
; *
; ***

PrintTruncate   db      0

NetSpoolStuff proc near
        sub     al,9                    ; most common case first
        jnz     @f

net_spool_stuff_good_exit:
        xor     ax,ax                   ; nothing to do for CloseAllSpool!
        ret

@@:     inc     al
        jnz     @f                      ; must be get, or invalid
        mov     ax,ERROR_INVALID_PARAMETER
        cmp     dl,1                    ; must be 0 or 1
        ja      net_spool_stuff_error_exit
        mov     PrintTruncate,dl
        jmp     short net_spool_stuff_good_exit
@@:     inc     al
        mov     ax,ERROR_INVALID_FUNCTION
        jnz     net_spool_stuff_error_exit

;
; return PrintTruncate flag to caller (app)
;

        DosCallBack GET_USER_STACK
        mov     dl,PrintTruncate
        xor     dh,dh
        mov     [si].User_Dx,dx
        ret

net_spool_stuff_error_exit:
        stc
        ret
NetSpoolStuff endp

page
if DEBUG
        even

        public  Old21Handler
Old21Handler    dd      ?

        public  CheckInt21Function5e
CheckInt21Function5e    proc    far
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

;        cmp     ah,5eh
;        jnz     @f
;        DbgUnsupported
@@:     jmp     Old21Handler            ; let DOS handle it. DOS returns to caller
CheckInt21Function5e    endp
endif

ResidentCodeEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\cht\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "The program cannot be run on this version of MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "The Vdm Redirector is already loaded", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\cs\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Program nelze na tto verzi systmu MS-DOS spustit", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Redirektor Vdm je ji naten", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\es\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "El programa no se puede ejecutar en esta versin de MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "El Redirector de VDM ya est cargado", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "El Redirector de VDM no puede ser cargado", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\fi\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
	Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Ohjelmaa ei voi kytt tss MS-DOSin versiossa", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
		db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "VD-koneen uudelleenohjaus on jo asennettu", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "VD-koneen uudelleenohjausta ei voi ladata", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\fr\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Le programme ne peut pas tre excut avec cette version de MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Le Redirecteur Vdm est dj charg", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\da\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Programmet kan ikke kres i denne version af MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Vdm-omdirigering er allerede indlst", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "Vdm-omdirigering kan ikke indlses", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\el\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      " 夘      暨    ⡛  MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      " 暨 矬 Vdm ⮜ 㛞 ", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      " 夘     暨 矬 Vdm", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\jpn\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "The program cannot be run on this version of MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "The Vdm Redirector is already loaded", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\kor\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "The program cannot be run on this version of MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "The Vdm Redirector is already loaded", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\ger\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Das Programm kann nicht mit dieser MS-DOS-Version ausgefhrt werden.", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Der Vdm-Redirector ist bereits geladen.", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\psu\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "The program cannot be run on this version of MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "The Vdm Redirector is already loaded", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\it\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg	db	"Programma non eseguibile con questa versione di MS-DOS", CARRIAGE_RETURN, LINE_FEED 
BAD_VER_MSG_LEN equ	$-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg	db	"Il redirector Vdm  gi caricato", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db	 "Il redirector Vdm non pu essere caricato", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\hu\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "A program nem futtathat ez alatt az MS-DOS verzi alatt.", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "A Vdm tirnyt mr be van tltve.", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "A Vdm tirnytt nem lehet betlteni.", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\nec_98\redirmsg.inc ===
include   jpn\redirmsg.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\nl\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
	Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Het programma kan niet uitgevoerd worden onder deze versie van MS-DOS.", CARRIAGE_RETURN, LINE_FEED 
BAD_VER_MSG_LEN equ     $-bad_ver_msg
		db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "De Vdm-redirector is al geladen", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\no\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg	db	"Programmet kan ikke kjres p denne MS-DOS-versjonen", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Vdm-omadressereren er allerede lastet inn.", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "Vdm-omadressereren kan ikke lastes inn.", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\tst\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "The program cannot be run on this version of MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "The Vdm Redirector is already loaded", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\pl\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Program nie moe by uruchomiony w tej wersji systemu MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Readresator Vdm jest ju zaadowany", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "Nie mona zaadowa readresatora Vdm", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\usa\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "The program cannot be run on this version of MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "The Vdm Redirector is already loaded", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\ru\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "   ணࠬ   ᨨ MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Vdm Redirector 㦥 㦥", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "The Vdm Redirector cannot be loaded", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\sv\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg	db	"Det gr inte att kra programmet i den hr versionen av MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "VDM-omdirigeraren r redan inlst", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "Det gr inte att lsa in VDM-omdirigeraren", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\pt\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "O programa no pode ser executado nesta verso do MS-DOS", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "O Vdm Redirector j est carregado", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "O Vdm Redirector no pode ser carregado", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\redir\tr\redirmsg.inc ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    redirmsg.inc

Abstract:

    Contains messages which we might want to internacionalize (geddit senorita?)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    Dos mode

Revision History:

    10-Mar-1993 RFirth
        Created

--*/
endif

CARRIAGE_RETURN equ     13
LINE_FEED       equ     10

bad_ver_msg     db      "Program bu MS-DOS srmnde altrlamaz", CARRIAGE_RETURN, LINE_FEED
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      "Vdm Ynlendiricisi zaten ykl", CARRIAGE_RETURN, LINE_FEED
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
;cannot_load_msg db      "Vdm Ynlendiricisi yklenemiyor", CARRIAGE_RETURN, LINE_FEED
;CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg
; OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\tools\src\buildidx\buildidx.c ===
/*
  PROGRAM NAME	BUILDIDX.C	Program by Sam W  Nunn	  Sep 24 1987

  To create from a file of messages a second file with offsets to the
  message headers of the first file, the quantity of messages with it,
  and update the level of the level of the files unless there are no
  changes to the files ( both files already exist with accurate data
  in the second file ).

  One argument from command line is needed :	  input file spec

  Sudeepb 03-May-1991 Ported for NT DOSEm
*/


#define LINT_ARGS ON                   /* Not needed in final version. */
#include <stdio.h>                     /* Req. for feof, fgets, printf, fputs */
                                       /* rewind. */
#include <stdlib.h>
#include <io.h>                        /* Req. for rename */
#include <process.h>                   /* Req. for exit */
#include <ctype.h>                     /* Req for isdigit, isalpha */
#include <string.h>                    /* Required for strcpy, strcat, */
                                       /* strlen */
#define LNMAX 200                      /* Max length of a line. */
#define LVMAX 4                        /* Max length of the message level. */
#define FNMAX 64                       /* Max length of the file spec. */
#define TEMPFILE "tempfile.msg\0"

  char fnameA[FNMAX];                  /* File spec from command line. */
  char fnameB[FNMAX];                  /* File spec for index file. */

void main(argc, argv)

  int argc;                             /* Quantity of command parms. */
  char *argv[];                         /* Command line input to Message. */

 {
   int  len,                           /* File spec character length */
        comparable,                    /* Comparable %1.IDX and %1.MSG files ? */
        Msg_Tot_Pos,                   /* Position on header line of total. */
        Msg_Cnt_Str,                   /* String converted to int. */
        Msg_Cnt;                       /* Quantity of messages per header. */
   char msgline[LNMAX] ,               /* A line read from message file. */
        filespec[FNMAX],               /* Name and location of final ?.MSG */
        header[10],
        idxline[LNMAX] ;               /* A line read from index file. */
   long header_offset ;                /* Byte count to header line. */
   long header_os_str ;                /* Byte count to header line. */
   long return_offset ;                /* Byte count to header line. */
   FILE *msgfile ,                     /* Message list to be checked */
        *idxfile ;                     /* Index file to the messages. */


   if ( argc != 2 )                     /* Look for file to use */
     {                                  /* from command line.        */
     printf("Incorrect number of parms  given to BUILDIDX.") ;
     return ;                           /* Print error and quit. */
     }
   else
     {
     strcpy(fnameA,argv[1]) ;           /* Get the first file spec. */
     strcpy(fnameB,argv[1]) ;           /* Get the second file spec. */
     len = strlen(fnameB) ;
     fnameB[len-3] = (char)73 ;         /* Put the IDX extension on it. */
     fnameB[len-2] = (char)68 ;
     fnameB[len-1] = (char)88 ;
     }
   if (( msgfile = fopen(fnameA,"r")) != NULL )   /* Exist input file ? */
     if (( idxfile = fopen(fnameB,"r")) != NULL )  /* Exist second file ? */
       comparable = 1 ;
     else
       comparable = 0 ;
   else
      {
      perror("Could't open message data file. \n") ;
      exit(1);
      }
   if ( comparable )
     {                                  /* Test the Message Levels. */
     fgets(msgline,LNMAX,msgfile) ;
     fgets(idxline,LNMAX,idxfile) ;
     if ( strcmp(msgline,idxline) == 0 )
       comparable = 1 ;
     else
       comparable = 0 ;
     }
   else
     printf("Can not find index file of the same message file level.\n") ;
   header_offset = ftell(msgfile) ;     /* Test header offset to the one */
   fscanf(msgfile,"%s",header) ;        /* recorded in the message file. */
   fscanf(msgfile,"%lx",&header_os_str) ;       /* Header offset. */
   fscanf(msgfile,"%d",&Msg_Cnt_Str) ;          /* Total messages. */
   if ( header_offset != header_os_str )
       comparable = 0 ;
   else
     fseek(msgfile,header_offset,0) ;
   fgets(msgline,LNMAX,msgfile) ;     /* Skip to header lines. */
   while ( !feof(msgfile) && !feof(idxfile) && comparable )
     {                                  /* Test the message header lines. */
     fgets(idxline,LNMAX,idxfile) ;
     if( strcmp(idxline, msgline ) == 0 )
       Msg_Cnt = 0 ;                    /* Msg_Cnt reset to count messages. */
     else
       comparable = 0 ;
     header_offset = ftell(msgfile) ;
     fgets(msgline,LNMAX,msgfile) ;
     while ( !isalpha(msgline[0]) && !feof(msgfile) && comparable )
       {
       while ( !isdigit(msgline[0]) && !isalpha(msgline[0]) && !feof(msgfile) )
         {
         header_offset = ftell(msgfile) ;
         fgets(msgline,LNMAX,msgfile) ;
         }
       while ( isdigit(msgline[0]) && !feof(msgfile) )
         {                              /* Check the number of messages. */
         Msg_Cnt++ ;
         header_offset = ftell(msgfile) ;
         fgets(msgline,LNMAX,msgfile) ;
         }
       }
     if ( Msg_Cnt == Msg_Cnt_Str )
       comparable = 1 ;
     else
       {
       comparable = 0 ;
       printf("The number of messages has changed. \n");
       }
     if (!feof(msgfile))
       {                                /* Test header offset to the one */
       return_offset = ftell(msgfile) ; /* recorded in the message file. */
       fseek(msgfile,header_offset,0) ;
       fscanf(msgfile,"%s",header) ;
       fscanf(msgfile,"%lx",&header_os_str) ;
       fscanf(msgfile,"%d",&Msg_Cnt_Str) ;          /* Total messages. */
       if ( header_offset != header_os_str )
           comparable = 0 ;
       else
         fseek(msgfile,return_offset,0) ;
       }
     }
   if ( comparable && feof(msgfile) && !feof(idxfile) )
     {                                 /* The two files compared OK. */
     printf("Message file and index file are not changed.\n") ;
     fclose(msgfile) ;
     fclose(idxfile) ;
     }
   else                         /* Rebuild %1.MSG file then %1.IDX file. */
     {
     fclose(msgfile) ;
     fclose(idxfile) ;
     strcpy(filespec, argv[1]) ;
     printf("Message file and index file will be updated.\n") ;
     updatemsg() ;              /* Make a new %1.MSG from the old. */
     bldindex() ;               /* Make an index file( %1.IDX ). */
     unlink(fnameA) ;           /* Get ridd of the old file. */
     rename(TEMPFILE,filespec) ;  /* Give output file the old file name. */
     }
 }


 updatemsg()
   {
   int  c,                      /* Charactor bucket for temp. storage */
        Message_Level,          /* Level of the message file. */
        File_Offset,            /* Offset to find title. */
        Msg_Cnt,                /* Quantity of messages per title. */
        First_line ,            /* Control recording qty.of prev.msg. */
        blank_line ,            /* A blank line from input sets to 1. */
        title,                  /* Flag to indicate strg. is a title. */
        index;                  /* Index into  array. */
   long bycnt_ot_fl ,           /* Byte count read from output file. */
        MsgCntLoc ,             /* Location of the count of messages. */
        temp_end ;              /* Byte count read from output file. */
   char File_in[LNMAX];         /* A line read from input file. */
   FILE *inpfile ,              /* Message file to be updated. */
        *outfile ;              /* Updated message file. */

   inpfile = fopen(fnameA,"r") ;              /* Open file for input. */
   outfile = fopen(TEMPFILE,"w");             /* Open file for output. */
   Msg_Cnt = 0 ;
   First_line = 1 ;
   title = 0 ;
   blank_line = 0 ;
                      /* Increment the Message level for the output file. */
   fscanf(inpfile,"%d",&Message_Level) ;    /* Read the old level. */
   Message_Level++ ;
   fprintf(outfile,"%04d\n",Message_Level) ; /* Output the new level. */
   fgetc(inpfile);                  /* Skip over eol. */
   while ( !feof(inpfile))          /* Stop when whole file has been read. */
     {
     while (( c = fgetc(inpfile)) == (char)32 ) ;
     while ( c == (char)'\t')
       c = fgetc(inpfile);             /* Skip over leading blank spaces. */
     index = 0 ;
     if ( isdigit(c) )           /* Starting with a number ? */
       {
       File_in[index] = c ;
       Msg_Cnt = Msg_Cnt + 1 ;        /* Add to the quantity of messages. */
       index = index + 1 ;
       while (((c = fgetc(inpfile))!= (char)'\n' ) &&
              ( index < LNMAX ) && !feof(inpfile))
         {                            /* Stop at the end of line char. */
         File_in[index] = c ;
         index++ ;
         }
       File_in[index] = (char)'\n';   /* Add end of line to string. */
       File_in[index+1] = (char)'\0';   /* Add end of string. */
       }
     else
       {
       if ( isalpha(c))
         {                            /* Found the title of the module. */
         if ( First_line )            /* Only on the first header. */
           {
           bycnt_ot_fl = ftell(outfile) ;     /* Locate header offset. */
           First_line = 0 ;
           }
         else
           {                                  /* Go back and update */
           temp_end = ftell(outfile) ;        /* the count of messages */
           fseek(outfile,MsgCntLoc,0) ;       /* under that header. */
           fprintf(outfile,"%04d",Msg_Cnt) ;
           Msg_Cnt = 0 ;                      /* Reset the msg. count. */
           bycnt_ot_fl = temp_end ;           /* Done with that, so off */
           fseek(outfile,temp_end,0) ;        /* to work on the next */
           }                                  /* header. */
         title = 1 ;
         File_in[index] = c ;                 /* Put together the header. */
         index = index +1 ;
         while (((c = fgetc(inpfile)) != (char)32 ) && ( c != (char)'\n') &&
                                              ( c != (char)'\t'))
           {
           File_in[index] = c ;               /* Save only the first str. */
           index++ ;                          /* for the header. */
           }
         File_in[index] = (char)'\0';
                                      /* Get ridd of the rest of the line, */
         while (c != (char)'\n' )     /* we have no use for it. */
           c = fgetc(inpfile) ;
         }
       else                           /* Line is PART of a define msg. */
         {
         while ( c == (char)'\t')        /* Control the number of tabs */
           c = fgetc(inpfile) ;           /* to just one leading tab. */
                                      /* One tab helps to make it visable. */
         if ( c == (char)34 )         /* Looking for a quote mark. */
           {
           File_in[index] = (char)'\t' ;
           index = index + 1 ;          /* Get the whole message line */
           File_in[index] = c ;         /* into the string. */
           index = index + 1 ;
           while (((c = fgetc(inpfile)) != (char)'\n' ) &&
                  ( index < LNMAX ) && !feof(inpfile))
             {
             File_in[index] = c ;
             index++ ;                    /* Stop at the end of line char. */
             }
           File_in[index] = (char)'\n';   /* Add end of line to string. */
           index = index + 1 ;
           File_in[index] = (char)'\0';   /* Add end of string. */
           }
         else
           {                          /* Must not be a line to save. */
           blank_line = 1 ;
                                      /* Get ridd of the rest of the line, */
           while (c != (char)'\n'&& !feof(inpfile) )     /* we have no use for it. */
             c = fgetc(inpfile) ;
           }
         }    /* End test for Alpha char. at the front of the line. */
       }      /* End test for a Digit at the front of the line. */
     if ( title && !feof(inpfile))
       {              /* Output to the new file. */
       fprintf(outfile,"%-8.8s %08lx %04d\n",File_in,bycnt_ot_fl,Msg_Cnt) ;
       MsgCntLoc = ftell(outfile)-6 ;
       title = 0 ;
       }
     else
       {
       title = 0 ;
       if ( !First_line && !blank_line )
         fputs(File_in,outfile) ;     /* Output to the new file. */
       else
         blank_line = 0 ;
       }      /* End test for title line to output. */
     }        /* While not end of file */
   if ( feof(inpfile) && Msg_Cnt > 0 )
     {
     temp_end = ftell(outfile) ;                /* Put down the last */
     fseek(outfile,MsgCntLoc,0) ;               /* update to the quantity */
     fprintf(outfile,"%04d",Msg_Cnt) ;          /* of messages listed. */
     fseek(outfile,temp_end,0) ;
     printf("Message file updated.\n") ;
     }
   else
     {        /* Nothing else to do !   Might as well finish. */
     printf("Message file update completed.\n") ;
     }
   /*cleanx(*inpfile, *outfile) ;*/
   fclose(inpfile) ;
   fclose(outfile) ;
   }      /* End of updatemsg */

 bldindex()
   {
   FILE *msgf ;
   FILE *idxf;
   char msgline[LNMAX] ;                /* A line read from input file. */

   msgf = fopen(TEMPFILE,"r");
   /*msgf = fopen(fnameA,"r"); */
   idxf = fopen(fnameB,"w");            /* Open to write to %1.IDX file */
   fgets(msgline,LNMAX,msgf) ;
   fputs(msgline,idxf) ;                /* Output the message file level. */
   fgets(msgline,LNMAX,msgf) ;
   while ( isalpha(msgline[0]) && !feof(msgf) )
     {
     fputs(msgline,idxf) ;              /* Save header in the index file. */
     fgets(msgline,LNMAX,msgf) ;
     while ( !isalpha(msgline[0]) && !feof(msgf) )
       fgets(msgline,LNMAX,msgf) ;      /* Not saveing non-header lines. */
     }
   printf("Index file updated.\n") ;
   fclose(msgf) ;
   fclose(idxf) ;
   }


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\tools\src\getsize\getsize.c ===
/***************************************************************************

   Module Name: getsize

   Description:
	Obtains BIOS_DATA (bios data size), BIOS_CODE ( bios code size )
	from ..\bios\msbio.map and DOSDATA (dos data size) from msdos.map
	and compares it with existing values in bdsiz.inc. If the values are
	update bdsiz.inc with the new values.

   Sudeepb 03-May-1991 Ported for NT DOSEm.
***************************************************************************/


#include<stdio.h>
#include<process.h>
#include<string.h>
#define	MAXLINE	200
#define	MAXWORD	64

int 	getline(s, lim, fileptr)
char	*s;
int	lim;
FILE	*fileptr;

{

	int	c, i;

	for	(i=0; (i < lim-1) && ((c=fgetc(fileptr)) != EOF) && (c!='\n'); ++i)
			s[i] = c;

	if		(c == '\n')
			s[i++] = c;

	s[i] = '\0';
	return(i);
}

scanline(s, prev, template)
char	*s, *template, *prev ;

{

	char	str[MAXWORD];
	int	i = 0;

	while ( *s == ' ')		
			s++;

	while	( *s != '\n' )
	{
		while( (*s != ' ') && (*s != '\n') && (*s != '\t'))
		{
			str[i++] = *s++;
		}
		str[i] = '\0';

		if ( (*s == ' ') || (*s == '\t') )
			s++;

 /*		printf("%s\n", str); */

		if ( strcmp( str, template) == 0 )
			return(0);

		strcpy(prev, str);

		i = 0;
	}

	return(-1);

}


void main()
{
	FILE	*fp1, *fp2;
	char	buffer[MAXLINE], 
			prev[MAXWORD],
			newdosdata[MAXWORD],
			newbiosdata[MAXWORD],
			newbioscode[MAXWORD],
			olddosdata[MAXWORD],
			oldbiosdata[MAXWORD],
			oldbioscode[MAXWORD];


	int	len, scanres, changed = 0;

	if ( (fp1	= fopen("ntdos.map", "r")) == NULL )
		{
			printf("getsize: cannot open ntdos.map\n");
			exit(0);
		}

	if ( (fp2 = fopen("..\\bios\\ntio.map", "r")) == NULL )
		{
			printf("getsize: cannot open ntio.map\n");
			exit(0);
		}


	/* Look for line containing string DOSDATA in msdos.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp1);
		scanres = scanline(buffer, prev, "DOSDATA");

	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before DOSDATA (dosdata size) in newdosdata. */
	strcpy(newdosdata, prev);	


	/* Look for line containing string BIOS_DATA in msbio.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp2);
		scanres = scanline(buffer, prev, "BIOS_DATA");
	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before BIOS_DATA (biosdata size) in newbiosdata. */
	strcpy(newbiosdata, prev);


	/* Seek back to beginning of MSBIO.MAP */
	if ( fseek(fp2, 0L, SEEK_SET) )
		printf("getsize: fseek failed on msbio.map\n");

	/* Look for line containing string BIOS_CODE in msbio.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp2);
		scanres = scanline(buffer, prev, "BIOS_CODE");
	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before BIOS_CODE (bios code size) in newbioscode. */
	strcpy(newbioscode, prev);

	fclose(fp1);	
	fclose(fp2);

	if ( (fp1 = fopen("..\\..\\inc\\bdsize.inc", "r")) == NULL )
		{
			printf("getsize: cannot open origin.inc\n");
			exit(0);
		}

	/* read in existing values of bios code , bios data and dos data  */
	/* size from bdsize.inc. 														*/

	fscanf(fp1, "%s%s%s", oldbiosdata, oldbiosdata, oldbiosdata);
	fscanf(fp1, "%s%s%s", oldbioscode, oldbioscode, oldbioscode);
	fscanf(fp1, "%s%s%s", olddosdata, olddosdata, olddosdata);

	printf("oldbiosdata=%s newbiosdata=%s\n",oldbiosdata, newbiosdata);
	printf("oldbioscode=%s newbioscode=%s\n",oldbioscode, newbioscode);
	printf("olddosdata=%s newdosdata=%s\n",olddosdata, newdosdata);


	/* Check to see if any one of them has changed */

	if ( strcmp(oldbiosdata, newbiosdata) != 0 )
		changed = 1;
	else if 	( strcmp(oldbioscode, newbioscode) != 0 )
		changed = 1;
	else if 	( strcmp(olddosdata, newdosdata) != 0 )
		changed = 1;

	/* if not changed, done. */

	if	(changed == 0)
		exit(0);
	

	/* One of the values has changed update bdsize.inc */

	fclose(fp1);

	if ( (fp1 = fopen("..\\inc\\bdsize.inc", "w")) == NULL )
		{
			printf("getsize: cannot open origin.inc\n");
			exit(0);
		}

	fprintf(fp1, "%s %s %s\n", "BIODATASIZ", "EQU", newbiosdata);
	fprintf(fp1, "%s %s %s\n", "BIOCODESIZ", "EQU", newbioscode);
	fprintf(fp1, "%s %s %s\n", "DOSDATASIZ", "EQU", newdosdata);
}




	
 

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\tools\src\h2inc\h2inc.c ===
/*static char *SCCSID = "@(#)h2inc.c 13.28 90/08/21";*/

/****************************** Module Header ******************************\
* Module Name: h2inc
*
* .H to .INC file translator
*
* Created: 15-Aug-87
*
* Author:  NeilK
* Modified:Jameelh	25-Jul-88
*		New switches added at command line '-n' & '-c' & '-g'.
*		o '-c' strips off the comments.
*		o Can handle structs without typedefs.
*		o Struct name need not have a prepended '_'.
*		o Don't need a Hungarian tag for it to work.
*		o Added a tag - for ptda_s - to genereate a
*		  named SEGMENT instead of struc. ( if '-g' specified )
*		o Added PUBLIC, INIT, and AINIT directives.
*		o Can handle structs within structs if 'typedef'ed.
*		o Added switch to define int size INT_16 or INT_32.
*		  -  All this works if '-n' switch is used.
*		o Added support for nested structs and bitfields upto
*		  32-bit long.
*		o Added XLATOFF & XLATON directives to switch translation
*		  off and on.
* Modified:  Lindsay Harris [lindsayh] - 13-Dec-88
*		o Remove casts of KNOWN types from #define statements
*		o Bug fix in handling NEAR pointers
* Modified:  Floyd Rogers [floydr] - 02-Jan-89
*		o Added function prototype argument lists for -W3
*		o Modified to use runtime lib declarations
*		o Removed unused variables, routine.
*		o Found bug in GetFieldName that would trash memory.
* Modified:  Floyd Rogers [floydr] - 04-Jan-89
*		o Added -d switch so that pm include files wouldn't break
*		o Added -? switch so that users can see more info about options
*		o gathered all #defines together.
*		o gathered all data declarations together, and alphabetized.
*		o initialize option flags in preset
* Modified:  Floyd Rogers [floydr] - 20-Jan-89
*		o Merged with 1.2 version.
*			Added -d switch:  when not specified, does not emit
*			struc definitions for typedef'd items.  This maintains
*			the 'old' h2inc standard.  1.3 will have to specify -d.
*			See above.
*		o Deleted -n switch
*		o switches now lower case only
* Modified:  Floyd Rogers [floydr] - 17-Apr-89
*		o Merged with 2.0 version.
*		    - Added processing of DEFINESOFF/DEFINESON to 2.0 version.
*		o REALLY removed -n switch
* Modified:  Floyd Rogers [floydr] - 18-Apr-89
*		o Fixed bug in processing fields - must emit DW, not just DD
* Modified:  Floyd Rogers [floydr] - 26-Apr-89
*		o Added code to check for string equates.
* Modified:  Floyd Rogers [floydr] - 10-May-89
*		o Fixed error in FindFieldname where compare was (pch == 0)
*		  rather than (*pch == 0)
*		o changed all character compares and assignments of the null
*		  character from 0 to '\000'
*		o beautified the thing by rationalizing all tabs to be at
*		  4 character increments, fixing up switch statements, moving
*		  all open braces to the end of the preceding if/while/do/for.
* Modified:  JR (John Rogers, JohnRo@Microsoft) - 21-Aug-90
*		o PTR B789499: Allow comment to start right after semicolon
*		  in field definition.
*		o Do real processing of unions.  (Don't use nested unions yet.)
*		o Allow "struct sess2{" (no space before brace).
*		o Allow NOINC and INC as synonyms for XLATOFF and XLATON.
*		o Don't break if keyword is part of a token (e.g. mytypedef).
*		o Improved error reporting on initialization errors.
*		o Hungarianized more of the code.
*		o Fixed trivial portability error which C6 caught (*pch==NULL).
*		o Add version number to help text (run "h2inc -?" to display).
*
* Copyright (c) 1987-1990  Microsoft Corporation
\***************************************************************************/

char	H2i1[]="h2inc - .H to .INC file translator (version 13.28)";
char	H2i2[]="     (C) Microsoft Corp 1987, 1988, 1989, 1990";
#define TRUE	1
#define FALSE	0
#define	IsAlpha(c)	(((c|' ') >= 'a') && ((c|' ') <= 'z'))
#define	IsParen(c)	(c == '(' || c == ')')
#define	IsDec(c)	(c >= '0' && c <= '9')
#define	IsSeparator(c)	(c && c != '_' && !IsDec(c) && !IsAlpha(c))
#define	IsHex(c)	(IsDec(c) || (((c|' ') >= 'a') && ((c|' ') <= 'f')))
#define	IsOct(c)	(c >= '0' && c <= '7')
#define	IsOper(c)	(c && c == '<' || c == '>' || c == '!' || c == '&' || \
			 c == '|' || c == ';' || c == '~')
#define	IsWhite(c)	((c) == ' ' || (c) == '\t' || (c) == '\n')
#define VOID void

#define	HEXCON	4
#define	OCTCON	2
#define	DECCON	1
#define	HEX(c)	(c & HEXCON)
#define	OCT(c)	(c & OCTCON)
#define	DEC(c)	(c & DECCON)


#define CCHMAX	    2048
#define CCHSYMMAX   512

#define ICHEQUTAB   20
#define ICHVALTAB   (ICHEQUTAB+4)
#define ICHCMTTAB   (ICHVALTAB+8)

typedef unsigned short BOOL;	/* f */
typedef char CHAR;
typedef int INT;
typedef long LONG;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef CHAR * PSZ;		/* psz - Pointer to zero-terminated string. */

#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
#include <stdlib.h>
#include <io.h>

/*
 * Structure definition processing stuff
 */
#define CCHALLOCMAX 8192
#define cMaxDD		200
#define cMaxDW		50
#define cMaxDB		20
#define cMaxW_D		20
#define CCHTYPEMAX  512
#define CCHTAGMAX   512
#define CCHINDEXMAX 512
#define CCHNAMEMAX  512
#define CCHBITFIELDMAX	512

#define TYPE_UNKNOWN	0
#define TYPE_DB		1
#define TYPE_DW		2
#define TYPE_DD		3
#define	TYPE_PTR	4

#define COMMENTCHAR ';'

typedef enum {INIT_NONE, INIT_SIMPLE, INIT_ARRAY} INITTYPE;

#define	INT_16	1
#define	INT_32	2

int  cBitfield = 0;
int  cLines = 0;

BOOL fArray = FALSE;
BOOL fcomm_out = FALSE;
BOOL fComment = FALSE;
BOOL fDeftype = FALSE;
BOOL fDefines = FALSE;
BOOL fError = FALSE;
BOOL fIf = FALSE;
BOOL fInTypedef = FALSE;	/* Currently in a typedef? */
BOOL fMac = FALSE;		/* Generate macros for structs */
BOOL fNew = TRUE;		/*	Additions - Jameelh	*/
BOOL fSeg = FALSE;		/* Generate SEGMENTS, if specified */
BOOL fSegAllowed = FALSE;
BOOL fstructtype[32];		/* fTypes if TYPE <..> */
INT  fStruct = 0;
BOOL fUnion  = FALSE;
BOOL fUseIfe = FALSE;
BOOL fWarn = FALSE;

FILE *hfErr = stderr;
FILE *hfIn;
FILE *hfOut = stdout;

INT  int_16_32=0;
INT  ctypeDB=0;
INT  ctypeDD=0;
INT  ctypeDW=0;

CHAR rgchBitfield[CCHBITFIELDMAX];
CHAR rgchIndex[CCHINDEXMAX];
CHAR rgchLine[CCHMAX];
CHAR rgchName[CCHNAMEMAX];
CHAR rgchOut[CCHMAX];
CHAR rgchSave[CCHMAX];
CHAR rgchSym[CCHSYMMAX];
CHAR rgchType[CCHTYPEMAX];
CHAR rgchTag[CCHTAGMAX];
CHAR rgchAlloc[CCHALLOCMAX];
CHAR *pstructname[32];	/* upto 32 nested structs */

CHAR *pchAlloc = rgchAlloc;
CHAR *pchBitfield;
CHAR *pchFileIn;
CHAR *pchFileOut;
CHAR *pchOut;

CHAR *rgpchDD[cMaxDD+1] = {
    "long",
    "unsigned long",
    "LONG",
    "ULONG",
    "ulong_t",
    "FlatAddr",			/* Huh.. */
    NULL
};

CHAR *rgpchDB[cMaxDB+1] = {
    "char",
    "unsigned char",
    "CHAR",
    "BYTE",
    "UCHAR",
    "uchar_t",
    NULL
};

CHAR *rgpchDW[cMaxDW+1] = {
    "short",
    "SHORT",
    "USHORT",
    "ushort_t",
    NULL
};

CHAR *rgpchW_D[cMaxW_D+1] = {		/* DW or DD depending on int_16_32 */
    "int",
    "INT",
    "unsigned",
    "UINT",
    NULL
};

static CHAR *rgpchUsage="Usage: h2inc [-?] [-c] [-d] [-f] [-g] [-m] [-t] [-w] [-s symfile.h] infile.h [-o outfile.inc]\n";

static PSZ pszUnionSizeVar = "?UnionSize";

VOID main(int, unsigned char**);
CHAR *fgetl(CHAR*, int, FILE*);
CHAR *fgetlx(CHAR*, int, FILE*);
VOID OpenFile(CHAR *);
VOID Translate(void);
VOID ProcessLine(void);
VOID PrintString(CHAR *);
PSZ  FindString(PSZ, PSZ, BOOL);
PSZ  FindWord(PSZ, PSZ);
BOOL DoComment(void);
VOID DoAsm(CHAR *);
VOID OutTab(void);
VOID OutString(CHAR *);
CHAR *GetToken(CHAR *, PSZ, INT);
CHAR *SkipWhite(CHAR *);
VOID OutFlush(void);
BOOL IsLongConstant(CHAR *);
VOID Error(PSZ);
VOID Warning(CHAR *);
VOID OutEqu(void);
CHAR *IsBitfield(CHAR *);
VOID DoBitfield(CHAR *, CHAR *);
CHAR **CalcType2(CHAR *, CHAR **);
INT  CalcType(CHAR*);
VOID FixSizeof(CHAR *);
VOID FixCast( CHAR * );
VOID DoIf(CHAR*);
VOID DoIfLine(CHAR*);
VOID DoInclude(CHAR*);
VOID OutBitfield(void);
VOID DoSimpleType(CHAR*);
VOID AddType(CHAR*, CHAR**);
VOID DoDefine(CHAR*);
VOID DoStruct(CHAR*, BOOL);
VOID DoUnionDefn(void);
VOID DoUnionFieldDefn(INT, PSZ, PSZ);
VOID DoDoneUnion(PSZ, BOOL);
VOID DoStructLine(CHAR*);
VOID EmitStrucHeader(PSZ, BOOL);
VOID EmitStrucTrailer(PSZ, PSZ);
VOID EmitSizeAsMod(INT);
VOID EmitSizeAsNum(INT, PSZ);
VOID getInitVal(PSZ, PSZ);
BOOL PublicField(CHAR*);
INITTYPE GetInitType(CHAR*);
BOOL IsStructPtr(CHAR*);
BOOL IsStructDefn(CHAR*);
VOID GetFieldName(CHAR*);
VOID DumpBitfields(void);
VOID OutVal(CHAR *);
VOID OutDiscard(void);
VOID initerror(void);
VOID DoNoInc(void);
VOID DoXlatOff(void);
VOID DoExtern(CHAR*);
VOID DoDefinesOff(void);




VOID main(argc, argv)
int argc;
unsigned char *argv[];
{
    char	*pchtmp;
    BOOL	InpOpened, OtpOpened;
    FILE	*hfOutSave;
#ifdef	DEBUG
    extern	int3();

    int3();
#endif
    InpOpened = OtpOpened = FALSE;

    argc--; argv ++;		/* Skip over invocation */
    while (argc > 0) {
	if (**argv == '-') {
	    switch (*(*argv+1)) {
		case 's':
		    if (argc < 2)
			initerror();
		    OpenFile(*++argv);
		    hfOutSave = hfOut;
		    hfOut = NULL;
		    Translate();
		    argv++; argc -= 2;
		    fclose(hfIn);
		    hfOut = hfOutSave;
		    break;

		case 'd':
		    fDeftype = TRUE;
		    argv++; argc--;
		    break;
		case 'f':
		    int_16_32 = INT_32;
		    argv++; argc--;
		    break;
		case 'g':
		    fSegAllowed = TRUE;
		    argv++; argc--;
		    break;

		case 'm':
		    fMac = TRUE;
		    argv++; argc--;
		    break;

		case 't':
		    fNew = FALSE;
		    argv++; argc--;
		    break;

		case 'c':
		    fcomm_out = TRUE;
		    argv++; argc--;
		    break;

		case 'w':
		    fWarn = TRUE;
		    argv++; argc--;
		    break;

		case 'o':
		    if (argc < 2 || OtpOpened)
			initerror();
		    OtpOpened = TRUE;
		    hfErr = stdout;
		    pchFileOut = *++argv;
		    pchtmp = mktemp("H2XXXXXX");
		    if ((hfOut = fopen(pchtmp, "w")) == NULL) {
			fprintf(hfErr, "Can't open temp file %s\n", pchtmp);
			exit(1);
		    }
		    argv++; argc -= 2;
		    break;

		case '?':
		    fprintf(hfErr, "\n%s\n%s\n\n", H2i1, H2i2);
		    fprintf(hfErr, rgpchUsage);
		    fprintf(hfErr, "\tc - Emit assembler comments (Default no comments)\n");
		    fprintf(hfErr, "\td - Emit DEFTYPE/struc for typedefs\n");
		    fprintf(hfErr, "\tf - Default size of 'int' is 32 bits\n");
		    fprintf(hfErr, "\tg - Segment directives allowed\n");
		    fprintf(hfErr, "\tm - Generate macros for structs\n");
		    fprintf(hfErr, "\tt - Don't handle typedef'd structs\n");
		    fprintf(hfErr, "\to - Output file follows\n");
		    fprintf(hfErr, "\ts - Symbol file follows\n");
		    fprintf(hfErr, "\tw - Emit warnings (default no warnings)\n");
		    fprintf(hfErr, "\t? - Print this message\n");
		    exit(0);
		default:
		    initerror();
		    break;
	    }
	}
	else {
	    if (InpOpened)
		initerror();
	    else {
		OpenFile(*argv);
		argc--; argv++;
		InpOpened = TRUE;
	    }
	}
    }
    if (!InpOpened)
	initerror();

/*
    fprintf(hfErr, "%s\n"%s\n", h2i1, h2i2);
*/

    Translate();
    fclose(hfIn);

    /*
     * Close the files, and then rename temp file to new file
     */
    fflush(hfOut);
    if (ferror(hfOut)) {
	fprintf(hfErr, "Error writing %s\n", pchtmp);
	exit(1);
    }
    fcloseall();

    if (!fError) {
	if ((hfOutSave=fopen(pchFileOut, "r")) > 0) {
	    fclose(hfOutSave);
	    if (unlink(pchFileOut) < 0) {
		unlink(pchtmp);
		fprintf(hfErr, "Can't unlink %s\n", pchFileOut);
		exit(1);
	    }
	}
	rename(pchtmp, pchFileOut);
    }
    exit(fError);

} /* main() */

VOID initerror()
{
    fprintf(hfErr, rgpchUsage);
    exit(1);
}

VOID Translate()
{
    *rgchLine = '\000';
    while (fgetlx(rgchLine, CCHMAX, hfIn))
	ProcessLine();
}

VOID OpenFile(szFilename)
char *szFilename;
{
    pchFileIn = szFilename;
    if ((hfIn = fopen(pchFileIn, "r")) == NULL) {
	fprintf(hfErr, "Can't open input file %s\n", pchFileIn);
	exit(1);
    }
}

/* Process a line, or more than one in some cases. */
VOID ProcessLine()
{
    CHAR *pch;
    CHAR buf[128];

    cLines++;

    pchOut = rgchOut;

    /*
     * Skip white space
     */

    if (*rgchLine == '\000' || ((*rgchLine == '\n') && !fcomm_out))
	return;
    pch = SkipWhite(rgchLine);
    if (*pch == '\000') {
	if (!fcomm_out)
	    return;
	rgchLine[0] = '\0';
    }

    if (DoComment())
	return;
    /*
     * If null comment line, just return
     */

    pch = SkipWhite(rgchLine);

    if (!fComment && *pch == '\000')
	return;

    if (pch[0] == COMMENTCHAR) {
	buf[0] = '\000';
	pch = GetToken(pch, buf, 2);
	if (!strcmp(buf, "ASM") || (fSegAllowed && !strcmp(buf, "GASM")) ||
			(!fSegAllowed  && !strcmp(buf, "!GASM"))) {
	    pch=SkipWhite(pch);
	    DoAsm(pch);
	    return;
	}
	if (!strcmp(buf, "DEFINESOFF")) {
	    DoDefinesOff();
	    return;
	}
	if (!strcmp(buf, "NOINC")) {
	    DoNoInc();
	    return;
	}
	if (!strcmp(buf, "XLATOFF")) {
	    DoXlatOff();
	    return;
	}
	if (!int_16_32) {
	    if (!strcmp(buf, "INT16"))
		int_16_32 = INT_16;
	    else if (!strcmp(buf, "INT32"))
		int_16_32 = INT_32;
	}
	if (fcomm_out) {
	    OutString(rgchLine);
	    OutFlush();
	    return;
	}
	else
	    return;
    }

    if (FindWord("#undef", rgchLine)) {
	return;
    }

    if (FindWord("#include", rgchLine)) {
	DoInclude(rgchLine);
	return;
    }

    if (FindWord("#define", rgchLine)) {
	DoDefine(pch);
	return;
    }

    /*
     * Handle extern before struct/union, so we don't get confused by
     * "extern void flarp(struct x_s x);".
     */
    if (FindWord("extern", rgchLine) != NULL) {
	DoExtern(rgchLine);
	return;
    }

    if (FindWord("union", rgchLine) != NULL) {
	DoStruct(rgchLine, TRUE);
	return;
    }

    if (FindWord("struct", rgchLine) != NULL) {
	DoStruct(rgchLine, FALSE);
	return;
    }

    if (FindWord("typedef", rgchLine) != NULL) {
	DoSimpleType(rgchLine);
	return;
    }

    if (FindWord("#if", rgchLine) != NULL) {
	DoIf(rgchLine);
	return;
    }

    if (fIf)
	DoIfLine(rgchLine);

    /*
     * Handle #ifndef, #else, #endif, etc.
     *
     */
    pch = SkipWhite(rgchLine);
    if (*pch == '#') {
	OutString(pch + 1);
	OutFlush();
	return;
    }

    if (fNew || fStruct)
	DoStructLine(rgchLine);
}

VOID PrintString(pch)
register CHAR *pch;
{
    if (hfOut != NULL) {
	while (*pch != '\000')
	    putc(*pch++, hfOut);
	putc('\n', hfOut);
    }
}

VOID Warning(sz)
CHAR *sz;
{
    if (fWarn) {
	fprintf(hfErr, "\n%s(%d) : Warning: %s:", pchFileIn, cLines, sz);
	fprintf(hfErr, "\n>>> %s <<<\n\n", rgchLine);
    }
}

VOID Error(psz)
PSZ psz;
{
    fprintf(hfErr, "\n%s(%d) : Error: %s:", pchFileIn, cLines, psz);
    fprintf(hfErr, "\n>>> %s <<<\n\n", rgchLine);
    fError = TRUE;
}

VOID OutTab()
{
    *pchOut++ = '\t';
}

VOID OutString(pch)
register CHAR *pch;
{
    while (*pch != '\000' && pchOut < &rgchOut[CCHMAX]) {
	if (*pch == COMMENTCHAR && !fcomm_out)
	    break;
	*pchOut++ = *pch++;
    }

    if (pch == &rgchOut[CCHMAX]) {
	*--pch = '\000';
	Error("Output line too long");
    }
}

VOID OutEqu()
{
    OutString("\tEQU\t");
}

PSZ FindString(pszKey, pchStart, fToken)
PSZ pszKey;
PSZ pchStart;
BOOL fToken;
{
    register INT cch;
    register CHAR *pch;

    pch = pchStart;
    cch = strlen(pszKey);

    while ((pch = strchr(pch, *pszKey)) != NULL) {
	/*
	 * If rest of string matches, then we have a match
	 */
	if (strncmp(pch, pszKey, cch) == 0) {
	    if (!fToken ||
		    ((pch == pchStart || IsWhite(*(pch - 1))) &&
		    (pch[cch] == '\000' || IsWhite(pch[cch])))) {
		return(pch);
	    }
	}
	pch++;
    }
    return(NULL);
}

/*
 * FindWord: Search for a word (not part of another word).
 * Note that this also works for words beginning with "#", e.g. "#define".
 * Unfortunately, this doesn't know about comments or string constants.
 */
PSZ FindWord(pszKey, pszStart)
PSZ pszKey;
PSZ pszStart;
{
    register INT cch;
    register CHAR *pch;

    pch = pszStart;
    cch = strlen(pszKey);

    while ((pch = strchr(pch, *pszKey)) != NULL) {
	/*
	 * If rest of string matches, then we have a match
	 */
	if (strncmp(pch, pszKey, cch) == 0) {
	    /* Insist on this being an exact match. */
	    if ( (pch == pszStart || !iscsymf(*(pch - 1))) &&
		 (pch[cch] == '\000' || !iscsym(pch[cch])) ) {
		return (pch);
	    }
	}
	pch++;
    }
    return (NULL);
}

CHAR *SkipWhite(buf)
register CHAR *buf;
{
    while (isspace(*buf))
	buf++;
    return(buf);
}

VOID OutDiscard()
{
    pchOut = rgchOut;
}

VOID OutFlush()
{
    *pchOut++ = '\000';

    PrintString(rgchOut);

    pchOut = rgchOut;
}

BOOL IsLongConstant(pch)
register CHAR *pch;
{
    while (*pch != '\000' && *pch != COMMENTCHAR) {
	if (*pch == 'L' || *pch == 'l')
	    return(TRUE);
	pch++;
    }
    return(FALSE);
}

CHAR *GetToken(pch, pszToken, cSkip)
register CHAR *pch;
PSZ pszToken;
INT cSkip;
{
    CHAR *pchEnd;
    register CHAR *pchStart;

    pchStart = pchEnd = pch;
    assert(cSkip > 0);
    while (cSkip-- > 0) {
	/*
	 * Skip leading whitespace
	 */
	while (isspace(*pch))
	    pch++;

	pchStart = pch;

	/*
	 * Depending of type of token, scan it.
	 */
	if (iscsymf(*pchStart)) {
	    /* It's an identifier or keyword... */
	    while (*pch != '\000' && iscsym(*pch))
		pch++;

	} else if (*pchStart=='#') {
	    /*
	     * Preprocessor stuff (e.g. "#define") is treated as 1 token here.
	     */
	    pch++;
	    while (*pch != '\000' && iscsym(*pch))
		pch++;

	} else if (IsDec(*pchStart)) {
	    /* Must be a number, e.g. "0xffFF" or "1L". */
	    while (*pch != '\000' && (IsHex(*pch)
				      || ((*pch | ' ') == 'x')
				      || ((*pch | ' ') == 'l')))
		pch++;

	} else if (!strncmp(pch, "!GASM", 5)) {
	    /*
	     * Special case, treat as 1 token.  We might regret this later,
	     * if GASM turns out to be the first 4 letters of a variable.
	     */
	    pch++;
	    while (*pch != '\000' && iscsym(*pch))
		pch++;

	} else {
	    /*
	     * Must be punctuation of some kind.
	     * Look for contiguous puncuation (e.g. "/*" or "*++").
	     */
	    while (*pch != '\000' && (!isspace(*pch)) && IsSeparator(*pch))
		pch++;
	}
	pchEnd = pch;
    }

    while (pchStart != pch)
	*pszToken++ = *pchStart++;

    *pszToken = '\000';
    return(pchEnd);
}

BOOL DoComment()
{
    register CHAR *pch;

    if (fComment && *rgchLine && !(*rgchLine == '*' && rgchLine[1] == '/'))
	rgchLine[0] = COMMENTCHAR;

    if (!fComment && (pch=FindString("//", rgchLine, FALSE))) {
	*pch++ = COMMENTCHAR;
	*pch = ' ';
	return (FALSE);
    }

    if ((pch = FindString("/*", rgchLine, FALSE)) != NULL) {
	pch[0] = COMMENTCHAR;
	if (pch[2] != '*')
	    pch[1] = ' ';
	fComment = TRUE;
    }

    if (pch = FindString("*/", rgchLine, FALSE)) {
	pch[0] = ' ';
	pch[1] = ' ';
	fComment = FALSE;
    }

    return(FALSE);
}


VOID DoDefine(pch)
register CHAR *pch;
{
    register CHAR *pchVal;
    CHAR *pchT;
    CHAR rgchT[128];
    int	fString=FALSE;

    /*
     * Skip "#define" (1 token) and get name (2nd token) being #define'd into
     * rgchSym.
     */
    pchVal = GetToken(pch, rgchSym, 2);
    if ( (*rgchSym) == '\000')
	Error("#define without name");

    /* Make sure this isn't a macro with arguments. */
    if ( (*pchVal) == '(') {
	Warning("Macros with parameters - ignored");
	return;
    }

    pchVal = SkipWhite(pchVal);		/* Skip space (if any) after name. */

    if (*pchVal == '"')
	fString = TRUE;

    if (fDefines) {
	if (IsAlpha(*pchVal) || *pchVal == '_') {
	    Warning("Define of symbol to symbol - ignored");
	    return;
	}
	if (*pchVal == '(') {
	    strcpy(rgchT, pchVal);
	    FixSizeof(rgchT);
	    FixCast(rgchT);
	    pchT = SkipWhite(rgchT);
	    while (*pchT == '(')
		pchT = SkipWhite(++pchT);

	    if (strncmp(pchT,"SIZE ", 5) && (IsAlpha(*pchT) || *pchT == '_')) {
		Warning("Define of symbol to symbol - ignored");
		return;
	    }
	}
    }

    OutString(rgchSym);
    OutEqu();
    if (*pchVal == '\000' || *pchVal == COMMENTCHAR) {
	*pchOut++ = '1';
	OutFlush();
    }
    if (fString) {
	*pchOut++ = '<';
	*pchOut++ = *pchVal++;
	if (*pchVal != '"') {
	    do {
		if (*pchVal == '\\')
		    pchVal++;
		*pchOut++ = *pchVal++;
	    } while (*pchVal != '"');
	}
	*pchOut++ = *pchVal++;
	*pchOut++ = '>';
	OutFlush();
    }
    else
	OutVal(pchVal);		/* process text, skip		*/
}

VOID OutVal(pch)
char	*pch;
{
    BOOL	con;

    FixSizeof(pch);
    FixCast( pch );			/* Remove them */
    while (*pch && *pch != ';') {
	con = DECCON;		/* default decimal */
	if (IsDec(*pch)) {
	    if (*pch == '0') {	/* could be octal or hex */
		pch ++;
		if ((*pch | ' ') == 'x') {
		    con = HEXCON; pch ++;
		    if (!IsDec(*pch))
			*pchOut++ = '0';
		}
		else if (IsOct(*pch))
			con = OCTCON;
		else
		    *pchOut++ = '0';
	    }
	    while ( *pch && ( (HEX(con) && IsHex(*pch)) ||
			      (OCT(con) && IsOct(*pch)) ||
			      (DEC(con) && IsDec(*pch))) )
		*pchOut++ = *pch++;

	    if (OCT(con))
		*pchOut++ = 'Q';
	    else if (HEX(con))
		*pchOut++ = 'H';

	    *pchOut++ = ' ';
	    if (*pch == 'L')
		pch++;
	}
	else if (*pch == '>') {
	    switch (pch[1]) {
		case '>':
		    OutString(" SHR ");
		    pch += 2;
		    break;
		case '=':
		    OutString(" GE ");
		    pch += 2;
		    break;
		default:
		    OutString(" GT ");
		    pch++;
		    break;
	    }
	}
	else if (*pch == '<') {
	    switch (pch[1]) {
		case '<':
		    OutString(" SHL ");
		    pch += 2;
		    break;
		case '=':
		    OutString(" LE ");
		    pch += 2;
		    break;
		default:
		    OutString(" LT ");
		    pch++;
		    break;
	    }
	}
	else if (*pch == '=' && pch[1] == '=') {
	    OutString(" EQ ");
	    pch += 2;
	}
	else if (*pch == '!' && pch[1] == '=') {
	    OutString(" NE ");
	    pch += 2;
	}
	else if (*pch == '!') {
	    OutString(" NOT ");
	    pch ++;
	    Warning("Bitwise NOT used for '!'");
	}
	else if (*pch == '~') {
	    OutString(" NOT ");
	    pch ++;
	}
	else if (*pch == '&' && pch[1] != '&') {
	    OutString(" AND ");
	    pch ++;
	}
	else if (*pch == '|' && pch[1] != '|') {
	    OutString(" OR ");
	    pch ++;
	}
	else {
	    while (*pch && !IsSeparator(*pch))
		*pchOut++ = *pch++;
	    while (*pch && IsSeparator(*pch) && !IsOper(*pch))
		*pchOut++ = *pch++;
	}
    }
    if (*pch == ';' && fcomm_out)
	    OutString(pch);
    OutFlush();
}

VOID DoStruct(pch, fUnionT)
register CHAR *pch;
BOOL fUnionT;
{
    CHAR buf[128];

    if (!IsStructDefn(pch)) {
	if (FindWord("typedef", pch))	/*  || IsStructPtr(pch) */
	    DoSimpleType(pch);
	else
	    DoStructLine(pch);
	return;
    }
    fUnion = fUnionT;
    fInTypedef = (BOOL)FindWord("typedef", rgchLine);
    fSeg = FALSE;
    if (fUnion)
	DoUnionDefn();

     /*	If fNew is set
      * Handle simple structs - i.e. without typedefs now
      * Names are maintained - no prepend tag is necessary
      * Else simple structs - without typedef are ignored
      */
    if (!fNew && !fInTypedef)
	return;

    /*
     * Skip "struct" or "typedef struct" and get structure name
     */
    pch = GetToken(pch, rgchType, (fInTypedef ? 3 : 2));

    *rgchTag = '\000';
    if (!fNew) {
	/*
	 * Skip curly brace & semicolon
	 */
	pch = GetToken(pch, rgchTag, 2);
	if (rgchTag[0] != COMMENTCHAR) {
	    Error("Missing type prefix in structure definition");
	    return;
	}
	/*
	 * Now fetch hungarian tag
	 */
	pch = GetToken(pch, rgchTag, 1);
    }
    else if (fSegAllowed) {	/* check for segment directive */
	pch = GetToken(pch, rgchTag, 2);
	if (rgchTag[0] != COMMENTCHAR) {
	    *rgchTag = '\000';
	    goto go1;
	}
	pch = GetToken(pch, rgchTag, 1);
	if (strcmp(rgchTag, "SEGMENT") != 0) {
	    *rgchTag = '\000';
	    goto go1;
	}
	pch = GetToken(pch, rgchType, 1);
	*rgchTag = '\000';
	sprintf(buf, "%s\tSEGMENT", rgchType);
	OutString(buf);
	OutFlush();
	fSeg = TRUE;
	goto go2;
    }
    if (!fNew && rgchTag[0])
	strcat(rgchTag, "_");
    if (fUnion)
	goto go2;	/* Don't output STRUC/etc yet. */
go1:

    /*
     * Output "TYPE struc"
     */
    if (!fNew)
	sprintf(buf,"\n%s\tSTRUC",(*rgchType == '_')?rgchType+1:rgchType);
    else {
	if (fInTypedef && fMac)
	    sprintf(buf, "\nDEFSTRUC\t,%s", rgchType);
	else
	    sprintf(buf, "\n%s\tSTRUC", rgchType);
    }
    OutString(buf);
    OutFlush();
go2:
    if (fNew) {
	pstructname[fStruct] = malloc(strlen(rgchType)+1);
	if (pstructname[fStruct] == NULL) {
	    Error("Can't allocate memory");
	    exit(2);
	}
	fstructtype[fStruct] = fInTypedef;
	strcpy(pstructname[fStruct++], rgchType); /* save away struct name */
    }
    else
	fStruct = TRUE;
    cBitfield = 0;
    pchBitfield = rgchBitfield;
    return;
}

BOOL	IsStructPtr(pch)
char	*pch;
{
    char	cbuf[128];

    if (GetToken(pch, cbuf, 2) == NULL)
	return (FALSE);
    if (cbuf[0] == '*')
	return (TRUE);
    else
	return (FALSE);
}

BOOL IsStructDefn(pch)
CHAR	*pch;
{
    if (FindString("{", pch, FALSE))
	return (TRUE);
    else
	return (FALSE);
}

VOID DoStructLine(pch)
register CHAR *pch;
{
    CHAR *pchT;
    CHAR *pComm;
    CHAR *pType;
    register INT type;
    INITTYPE InitType;
    char initval[100];

    /*
     * If the line has a colon in it, then we have a bitfield.
     */
    InitType = INIT_NONE;

    if ((pchT = IsBitfield(pch))) {

	if (cBitfield == -1) {
	    Error("Only one set of bitfields per structure allowed");
	    return;
	}

	while ((pchT = IsBitfield(pch))) {
	    DoBitfield(pch, pchT);
	    if (!fgetl(rgchLine, CCHMAX, hfIn))
		break;
	}

	OutTab();
	if (fNew) {
	    OutString(pstructname[fStruct-1]);
	    *pchOut++ = '_';
	}
	else
	    OutString(rgchTag);
	OutString("fs");
	OutTab();
	if (cBitfield <= 16)
	    OutString("DW  ?");
	else
	    OutString("DD  ?");
	OutFlush();
	cBitfield = -1;			/* flag bitfield emitted	*/
	/* Now drop through to process the next line			*/
    }
    pComm = FindString(";", pch, FALSE);

    /*
     * If we find a curly brace, then time for "ends"
     */
    if ((pType = strchr(pch, '}')) != NULL) {
	if (fUnion) {
	    /*
	     * OK, now we finally know how large it is, so we can emit the
	     * STRUC..ENDS stuff.
	     */
	    DoDoneUnion(rgchType,	/* pszTag */
			fInTypedef);
	    fUnion = FALSE;
	    goto out;
	}

	/*
	 * Output "TYPE ends"
	 */
	if (!fNew) {
	    /* remove underscore if one is present */
	    OutString((*rgchType == '_')?rgchType+1:rgchType);
	    OutString("\tENDS");
	    fStruct = FALSE;
	}
	else {
	    if (fstructtype[fStruct-1] && fMac) {
		pType = GetToken(pType, initval, 2);
		OutString("ENDSTRUC\t");
		OutString(initval);
		*pchOut++ = '\n';
		goto out;
	    }
	    else {
		OutString(pstructname[--fStruct]);
		OutString("\tENDS\n");
		free(pstructname[fStruct]);
		goto out;
	    }
	}
    out:
	OutFlush();

	DumpBitfields();

	return;
    }

    /*
     * Figure out what type the thing is.
     */
    type = CalcType(pch);
    /*
     * Get field name and index, if any
     */
    GetFieldName(pch);
    if (fSeg) {
	if (PublicField(pch)) {
	    OutString("\tPUBLIC  ");
	    OutString(rgchName);
	    OutFlush();
	}
	if ( (InitType=GetInitType(pch)) != INIT_NONE )
	    getInitVal(pch, initval);
    }

    if (fUnion == FALSE) {
	OutString(rgchTag);
	OutString(rgchName);
	OutTab();
    } else {
	DoUnionFieldDefn(type,
			rgchSym,	/* pszFieldType (struct/union name). */
			rgchName);	/* pszFieldName */
	goto DoneField;
    }

    switch (type) {
	case TYPE_DB:
	    OutString("DB\t");
	    goto common;
	    break;

	case TYPE_DW:
	    OutString("DW\t");
	    goto common;
	    break;

	case TYPE_DD:
	    OutString("DD\t");
	common:
	    if (fArray && (InitType != INIT_ARRAY))
		OutString(rgchIndex);
	    if (InitType == INIT_NONE) {
		if (fArray)
		    OutString(" DUP (?)");
		else
		    OutString("?");
	    }
	    else {
		if (InitType == INIT_ARRAY) {
		    if (!fArray)
			Error("Initialization error (AINIT on nonarray type)");
		    else
			OutString(initval);
		    }
		else {
		    if (fArray)
			OutString(" DUP (");
		    OutString(initval);
		    if (fArray)
			OutString(")");
		    break;
		}
	    }
	    break;

	case TYPE_UNKNOWN:
	    if (fMac && !FindWord("struct", pch)) {
		OutDiscard();
		OutString(rgchSym);
		OutTab();
		OutString(rgchName);
		if (fArray) {
		    OutString(",,");
		    OutString(rgchIndex);
		}
	    }
	    else {
		if (!fStruct) {
		    OutString(rgchSym);
		    if (!fArray && (InitType==INIT_NONE))
			OutString(" <>");
		    else if ((InitType==INIT_NONE) && fArray) {
			OutString(" * ");
			OutString(rgchIndex);
			OutString("DUP (<>)");
		    }
		    else
			Error("Initialization error (1)");
		}
		else {
		    if (InitType!=INIT_NONE)
			Error("Initialization error (2)");
		    OutString("DB\tSIZE ");
		    OutString(rgchSym);
		    if (fArray) {
			OutString(" * ");
			OutString(rgchIndex);
		    }
		    OutString(" DUP (?)");
		}
	    }
	    break;

	default:
	    break;
    }
DoneField:
    if (fcomm_out) {
	pComm++;
	OutString(pComm);
    }
    OutFlush();
    if ((InitType == INIT_ARRAY) && fArray) {
	sprintf(initval, "\t.ERRNZ  ($-%s) - (%s * %s)", rgchName,
		rgchIndex, type==TYPE_DB?"1":type==TYPE_DW?"2":type==TYPE_DD?
		"4":rgchSym);
	OutString(initval);
	OutFlush();
    }
}

VOID DoUnionDefn(void)
{
    OutString(pszUnionSizeVar);
    OutString(" = 0");
    OutFlush();
}

VOID DoUnionFieldDefn(
    INT type,				/* TYPE_DW, etc. */
    PSZ pszFieldType,
    PSZ pszFieldName)
{
    OutString("if ");
    EmitSizeAsNum(type, pszFieldType);
    OutString(" gt ");
    OutString(pszUnionSizeVar);
    OutFlush();

    OutString("\t");
    OutString(pszUnionSizeVar);
    OutString(" = ");
    EmitSizeAsNum(type, pszFieldType);
    OutFlush();

    OutString("endif");
    OutFlush();

    OutString(pszFieldName);
    OutString("\tequ\t(");
    EmitSizeAsMod(type);		/* Emit "byte" or whatever. */
    OutString(" ptr 0");		/* Fields in unions always offset 0. */
    OutString(")");
    OutFlush();
}

VOID DoDoneUnion(PSZ pszTag, BOOL fTypedef)
{
    /* Generate "flarp STRUC" or whatever line. */
    EmitStrucHeader(pszTag, fTypedef);

    /* Generate single field, of the max size. */
    OutString("\tDB\t");
    OutString(pszUnionSizeVar);
    OutString(" dup(?)");
    OutFlush();

    /* Now generate ENDS or whatever. */
    EmitStrucTrailer(pszTag, (CHAR *)0);
}

/* Generate start of struct/union. */
VOID EmitStrucHeader(PSZ pszTag, BOOL fTypedef)
{
    CHAR buf[128];

    /*
     * Output "TYPE struc"
     */
    if (!fNew)
	sprintf(buf,"\n%s\tSTRUC",(*pszTag == '_')?pszTag+1:pszTag);
    else {
	if (fTypedef && fMac)
	    sprintf(buf, "\nDEFSTRUC\t,%s", pszTag);
	else
	    sprintf(buf, "\n%s\tSTRUC", pszTag);
    }
    OutString(buf);
    OutFlush();
}

/* Generate end of struct/union. */
VOID EmitStrucTrailer(PSZ pszTag, PSZ pszInitval)
{
    if (!fNew) {
	/* remove underscore if one is present */
	OutString((*pszTag == '_')?pszTag+1:pszTag);
	OutString("\tENDS");
    }
    else {
	if (fstructtype[fStruct-1] && fMac) {
	    OutString("ENDSTRUC\t");
	    OutString(pszInitval);
	}
	else {
	    OutString(pszTag);
	    OutString("\tENDS\n");
	}
    }
    OutFlush();
}

/*
 * Generate size of type as modifier, if possible.  (For a structure,
 * generate a "byte" modifier, instead.)
 */
VOID EmitSizeAsMod(INT type)
{
    switch (type) {
	case TYPE_DB:	
	    OutString("byte");
	    break;
	case TYPE_DW:
	    OutString("word");
	    break;
	case TYPE_DD:
	    OutString("dword");
	    break;
	case TYPE_PTR:
	    Warning("assuming pointer is 4 bytes long");
	    OutString("dword");
	    break;
	case TYPE_UNKNOWN:
	    /* Struct, so treat as byte. */
	    OutString("byte");
    }
}

/*
 * Generate size of type as number, if possible.  (For a structure,
 * generate a "size typename" instead.)
 */
VOID EmitSizeAsNum(INT type, PSZ pszTypeName)
{
    switch (type) {
	case TYPE_DB:	
	    OutString("1");
	    break;
	case TYPE_DW:
	    OutString("2");
	    break;
	case TYPE_DD:
	    OutString("4");
	    break;
	case TYPE_PTR:
	    Warning("assuming pointer is 4 bytes long");
	    OutString("4");
	    break;
	case TYPE_UNKNOWN:
	    OutString("size ");
	    OutString(pszTypeName);
    }
}

VOID DoBitfield(pch, pchColon)
register CHAR *pch;
CHAR *pchColon;
{
    register int w;
    int cbit;
    int	temp;

    GetFieldName(pch);
    OutString(rgchTag);
    OutString(rgchName);
    OutEqu();

    /*
     * Skip ':' and any leading whitespace
     */
    pchColon = SkipWhite(pchColon + 1);

    /*
     * Calc number of bits for the field (handle up to 2 digits)
     */
    if (!isdigit(pchColon[0]))
	Error("Illegal bitfield");

    cbit = pchColon[0] - '0';
    if (isdigit(pchColon[1]))
	cbit = cbit * 10 + pchColon[1] - '0';

    if (cbit + cBitfield > 32) {
	Error("Only 32 bitfield bits allowed");
    }

    /*
     * Calculate mask
     * the field should look like this
     *
     * | 0..0 | 11 .. 11 | 00 ....... 00 |
     *     |<- cbit ->|<- cBitfield ->|
     *
     * If we have a 32 bit C compiler the following would produce the
     * reqd. bit field.
     *
     * w = ((1 << cbit) - 1) << cBitfield;
     *
     * But now we have to split this up. If either cbit + cBitfield <= 16
     * then there is no problem, or cBitfield is > 16 so that we just shift
     * everything appropriately. If neither then we have to divide and rule.
     *
     */
    if (cbit + cBitfield <= 16) {
	w = ((1 << cbit) - 1) << cBitfield;
	pchOut += sprintf(pchOut, "0%xh", w);
    }
    else if (cBitfield > 16) {
	w = (((1 << cbit) - 1) << (cBitfield - 16));
	pchOut += sprintf(pchOut, "0%x0000h", w);
    }
    else {
	temp = cbit;
	cbit = cbit + cBitfield - 16;
	w = ((1 << cbit) - 1);
	pchOut += sprintf(pchOut, "0%04x", w);
	cbit = 16 - cBitfield;
	w = ((1 << cbit) - 1) << cBitfield;
	pchOut += sprintf(pchOut, "%04xh", w);
	cbit = temp;
    }

    cBitfield += cbit;

    OutBitfield();
    pchOut = rgchOut;
    return;

}

CHAR *IsBitfield(pch)
register CHAR *pch;
{
    while (*pch != '\000' && *pch != COMMENTCHAR) {
	if (*pch == ':')
	    return(pch);
	pch++;
    }
    return(NULL);
}

/*
 * Figure out the type of the field.
 * If unknown type, this routine leaves the typename in rgchSym[].
 */
INT CalcType(pch)
register CHAR *pch;
{
    register INT i;
    CHAR     chbuf[128];
    CHAR     token[128];

    for (i=0;pch[i] && pch[i] != ';';i++)
	chbuf[i] = pch[i];
    chbuf[i]=0;

    /*
     * If it has a FAR in it, then assume a DD.
     */
    if (FindWord("FAR", chbuf) != NULL ||
		FindWord("far", chbuf) != NULL)
	return(TYPE_DD);

    /*
     * If no FAR, but it has a star, then PTR
     */

    i=2;
    if (FindWord("typedef", chbuf))
	i++;
    if (FindWord("struct", chbuf) || FindWord("union", chbuf))
	i++;
    if (FindWord( "NEAR", chbuf) || FindWord( "near", chbuf))
	i++;
    GetToken(chbuf, token, i);
    if (token[0] == '*') {
	if (int_16_32 == INT_32)
	    return (TYPE_DD);
	else
	    return (TYPE_DW);
    }

    /*
     * Now look up the type in one of the tables.
     * Note that we search the DD and DB tables before
     * we search the DW table, because "unsigned" may be
     * part of "unsigned long" and "unsigned char".
     */
    if (CalcType2(chbuf, rgpchDD) == 0)
	return(TYPE_DD);

    if (CalcType2(chbuf, rgpchDB) == 0)
	return(TYPE_DB);

    if (CalcType2(chbuf, rgpchDW) == 0) {
	return(TYPE_DW);
    }
    if (CalcType2(chbuf, rgpchW_D) == 0) {
	if (int_16_32 == INT_32)
	    return(TYPE_DD);
	else if (!int_16_32)
	    Warning("int/unsigned assumed DW");
	return(TYPE_DW);
    }

    /*
     * An unknown type: must be a structure.
     * Return the type name in rgchSym
     */
    i = 1;
    if (FindWord("typedef", chbuf))
	i++;
    if (FindWord("struct", chbuf))
	i++;
    else if (FindWord("union", chbuf))
	i++;
    GetToken(chbuf, rgchSym, i);

    return(TYPE_UNKNOWN);
}

/*
 * This nifty little function searches the "symbol table"
 * and returns NULL if the thing is found, or the pointer to the
 * end of the symbol table if not.
 */
CHAR **CalcType2(pch, rgpch)
CHAR *pch;
register CHAR **rgpch;
{
    register INT i;

    /*
     * One of the DWORD types?
     */
    for (i=0 ; rgpch[i]!=NULL ; i++) {
	if (FindString(rgpch[i], pch, TRUE) != NULL) {
	    return(NULL);
	}
    }
    return(&rgpch[i]);
}

/*
 * Find name part of field definition, and store in rgchName.
 * Also calculates whether this is an array or not, returning
 * the array index string in rgchIndex.  Sets fArray (global).
 */

VOID GetFieldName(pch)
register CHAR *pch;
{
    register CHAR *pchT;
    CHAR *pchStart;
    CHAR *pchEnd;

    pchStart = pch;
    /*
     * Find name part of field.  We do this by scanning ahead for the
     * semicolon, then backing up to first separator char.
     * Bitfields are handled here too, by stopping if we find a ':'.
     */

    while (*pch != COMMENTCHAR && *pch != ':') {
	if (*pch == '\000') {
	    Error("Missing semicolon");
	    return;
	}
	pch++;
    }

    /*
     * Back up past spaces
     */
    while (*(pch - 1) == ' ')
	pch--;

    fArray = FALSE;

    /*
     * Check for array definition:
     */
    if (*(pch - 1) == ']') {

	fArray = TRUE;

	/*
	 * Back up over array index
	 */
	while (*(pch - 1) != '[' && pch != pchStart)
	    pch--;

	/*
	 * remember pointer to '['..
	 */
	pchEnd = pch - 1;

	/*
	 * Save index string away...
	 */
	for (pchT = rgchIndex; *pch != ']'; )
	    *pchT++ = *pch++;
	*pchT = '\000';

	pch = pchEnd;
	FixSizeof(rgchIndex);
    }

    /*
     * Back up past spaces
     */
    while (*(pch - 1) == ' ')
	pch--;

    /*
     * Skip over proc declaration parameter lists
     */
    if (*(pch - 1) == ')') {
	/*
	 * Skip the parameter list
	 */
	while (*(--pch) != '(' && pch != pchStart)
	    ;
	/*
	 * Skip any leftover trailing parens
	 */
	while (*(pch - 1) == ')')
	    pch--;
    }

    /*
     * Remember the end of the name
     */
    pchEnd = pch;

    /*
     * Scan the rest of the string to see if he has multiple fields on a line
     */
    for (pchT = pchStart; pchT != pchEnd; pchT++) {
	if (*pchT == ',') {
	    Error("Only one field per line allowed");
	    return;
	}
    }

    /*
     * Now find the beginning of the name string...
     */
    while (pch>pchStart &&
	*(pch - 1) != ' ' && *(pch - 1) != '(' && *(pch - 1) != '*') {

	pch--;
	/*
	 * If this is a bitfield guy, then reset pchEnd
	 */
	if (*pch == ':')
	    pchEnd = pch;
    }

    /*
     * Copy the name to rgchName.
     */
    for (pchT = rgchName; pch != pchEnd && pchT<&rgchName[CCHNAMEMAX-1]; )
	*pchT++ = *pch++;
    *pchT++ = '\000';

    return;
}

/*
 * This routine sticks the newly defined type in the appropriate array.
 */

VOID DoSimpleType(pch)
register CHAR *pch;
{
    INT type;
    CHAR **ppch;
    CHAR buf[128];
    char *ptype;

    /*
     * First see if this thing already has a type
     */

    GetFieldName(pch);

    ptype = NULL;
    switch (type = CalcType(pch)) {
	case TYPE_DW:
	    if ((ppch = CalcType2(rgchName, rgpchDW)) != NULL) {
		if (++ctypeDW < cMaxDW)
		    AddType(rgchName, ppch);
		else
		    fprintf(hfErr, "Error - no room in symbol table - type %s not added\n", rgchName);
	    }
	    ptype = "dw";
	    break;
	case TYPE_DD:
	    if ((ppch = CalcType2(rgchName, rgpchDD)) != NULL) {
		if (++ctypeDD < cMaxDD)
		    AddType(rgchName, ppch);
		else
		    fprintf(hfErr, "Error - no room in symbol table - type %s not added\n", rgchName);
	    }
	    ptype = "dd";
	    break;
	case TYPE_DB:
	    if ((ppch = CalcType2(rgchName, rgpchDB)) != NULL) {
		if (++ctypeDB < cMaxDB)
		    AddType(rgchName, ppch);
		else
		    fprintf(hfErr, "Error - no room in symbol table - type %s not added\n", rgchName);
	    }
	    ptype = "db";
	    break;
	case TYPE_UNKNOWN:
	    break;
	default:
	    break;
    }
    if (fDeftype) {
	if (fMac) {
	    sprintf(buf, "DEFTYPE\t%s,%s", rgchName, ptype? ptype : rgchSym);
	}
	else if (ptype) {
	    sprintf(buf, "%s struc\n\t%s ?\n%s ends\n",rgchName,ptype,rgchName);
	}
	else {
	    sprintf(buf, "%s struc\ndb size %s dup(?)\n%s ends\n",
		    rgchName, rgchSym, rgchName);
	}
	OutString(buf);
	OutFlush();
    }
}

VOID AddType(pch, ppch)
register CHAR *pch;
CHAR	**ppch;
{
    INT cch;

    cch = strlen(pch) + 1;

    if (pchAlloc + cch > &rgchAlloc[CCHALLOCMAX]) {
	Error("Symbol table full");
	return;
    }
    strcpy(pchAlloc, pch);
    *ppch = pchAlloc;
    pchAlloc += cch;
    return;
}

/*
 * Because the peice of assembler can't handle EQU's inside of
 * STRUC declarations, we buffer up the bitfield constant definitions
 * in a separate buffer, and dump them out after we output the ENDS.
 */
VOID OutBitfield()
{
    *pchOut = '\000';

    if (pchBitfield-rgchBitfield+strlen(rgchOut) > CCHBITFIELDMAX) {
	Error("Internal error - bitfield name buffer overflow:  bitfield ignored");
	return;
    }
    strcpy(pchBitfield, rgchOut);
    pchBitfield += strlen(rgchOut) + 1;
}

VOID DumpBitfields()
{
    register CHAR *pch;

    for (pch = rgchBitfield; pch != pchBitfield; pch += strlen(pch) + 1) {
	OutString(pch);
	OutFlush();
    }
}

VOID DoInclude(pch)
register char *pch;
{
    register char *pchend;

    OutString("INCLUDE ");
    /*
     * Skip ahead to start of file name
     */
    while (*pch != '\000' && *pch != '"' && *pch != '<')
	pch++;

    /*
     * Skip string delimiter
     */
    pch++;

    /*	pch now points to the beginning of the filename.
     *	scan forward till the delimiter ('"' or '>').
     *	Then scan backwards till a '.' and append it with 'INC'
     */
    pchend = pch;
    while (*pchend != '"' && *pchend != '>')
	pchend++;
    while (*pchend != '.')
	pchend --;
    *++pchend = '\000';
    OutString(pch);
    OutString("INC");
    OutFlush();
}


/*
 * Handle logical ORs...
 */
VOID DoIf(pch)
CHAR *pch;
{
    static cIfTemp = 0;

    if (strchr(pch, '&') != NULL) {
	Error("Can't handle logical ANDs in IFs");
	return;
    }
    if (FindWord("defined", pch) == NULL)
	goto skip;
    strcpy(rgchSym, "IFTEMP00");
    rgchSym[7] += (char)(cIfTemp % 10);
    rgchSym[6] += (char)(cIfTemp / 10);
    cIfTemp++;

    OutString(rgchSym);
    OutString(" = 0");
    OutFlush();
skip:
    fUseIfe = (BOOL)FindString("!(", pch, FALSE);

    fIf = TRUE;

    DoIfLine(pch);
}

VOID DoIfLine(pch)
register CHAR *pch;
{
    BOOL fOutIf;
    BOOL fIfndef;
    BOOL fEx;
    CHAR *pline;

    pline=pch;
    /*
     * If this is the last line of defined()'s, remember to output initial if
     */
    fEx = FALSE;
    fOutIf =  ((strchr(pch, '\\') == NULL));

    if (FindWord("defined", pch) != NULL) {
	while ((pch = FindWord("defined", pch)) != NULL) {

	    /*
	     * If defined is preceded by '!', then use ifndef
	     */
	    fIfndef = (*(pch - 1) == '!');

	    OutString(fIfndef ? "IFNDEF " : "IFDEF ");

	    /* Skip "defined", "(", and get symbol */
	    while (*pch != '\000' && *pch++  != '(')
		;
	    pch = SkipWhite(pch);
	    while (*pch != '\000' && *pch != ' ' && *pch != ')')
		*pchOut++ = *pch++;
	    OutFlush();

	    /*
	     * Now set temporary variable...
	     */
	    OutString(rgchSym);
	    OutString(" = 1");
	    OutFlush();

	    OutString("ENDIF");
	    OutFlush();
	}
    }
    else
	fEx = TRUE;

    if (fOutIf) {
	OutString(fUseIfe ? "IFE " : "IF ");
	if (fEx) {
	    pch = GetToken(pline, rgchSym, 1);
		OutVal(pch);
	}
	else {
	    OutString(rgchSym);
	    OutFlush();
	}
	fIf = FALSE;
    }
}

VOID DoAsm(cline)
char	*cline;
{
    CHAR	line[128];
    CHAR	*pch, *pch1;

    if (fComment) {		/* fComment => that we are still within
			       a comment => its not a single line ASM */
	OutString(cline);
	while (cLines++ && fgetl(line,sizeof(line) , hfIn)) {
	    pch = SkipWhite(line);
	    if (pch1=FindString("*/", pch, FALSE)) {
		*pch1 = '\000';
		OutString(line);
		OutFlush();
		fComment = FALSE;
		return;
	    }
	    else {
		OutString(line);
		OutFlush();
	    }
	}
    }
    else {	/* Single line ASM */
	OutString(cline);
	OutFlush();
	return;
    }
}

BOOL PublicField(Str)
CHAR	*Str;
{
    char	*pch;

    if (pch = FindString(";", Str, FALSE)) {
	if (FindWord("PUBLIC", pch) != NULL)
	    return (TRUE);
	else
	    return (FALSE);
    }
    else
	return (FALSE);
}

INITTYPE GetInitType(pch)
CHAR	*pch;
{
    if (FindWord("AINIT", pch))
	return (INIT_ARRAY);
    if (FindWord("INIT", pch))
	return (INIT_SIMPLE);
    else
	return (INIT_NONE);		/* No init (same value as FALSE). */
}

VOID getInitVal(pch, val)
PSZ	pch;
PSZ	val;
{
    CHAR	*pval;

    pval = val;
    *pval = '\000';
    {
	PSZ pszInitOrAInit;

	pszInitOrAInit = FindWord("INIT", pch);
	if (pszInitOrAInit == NULL)
	    pszInitOrAInit = FindWord("AINIT", pch);
	pch = pszInitOrAInit;
	if (pch == NULL) {
	    Error("Initialization error (bug in getInitVal/caller?)");
	    return;
	}
    }

    pch = FindString("<", pch, FALSE);
    if (pch == NULL) {
	Error("Initialization error (missing '<')");
	return;
    }

    for (pch++; (*pch && *pch != '>') ; pch++, val++)
	*val = *pch;
    if (*pch == '>' && *(pch+1) == '>')
	*val++ = '>';
    if (*pch == '\000') {
	Error("Initialization error (need '>' to end value)");
	*pval = '\000';
	return;
    }
    *val = '\000';
}

/*	Fix sizeof( foo )	 to size foo
**	    sizeof  foo		 to size foo
**	    sizeof( struct foo ) to size foo
*/
VOID FixSizeof(pbuf)
CHAR	*pbuf;
{
    char	*pch;
    char	*s;
    int		i;

    while (TRUE) {
	if ((pch=FindWord("sizeof", pbuf)) == NULL)
	    return;
	s = "SIZE  ";
	for (i=0; i < 6 ; i++)
	    *pch++ = *s++;
	if ((s=FindString("(", pch, FALSE)) == NULL)
	    continue;
	*s++ = ' ';
	i = 0;
	do {
	    if (*s == '(')
		i++;
	    else if (*s == ')') {
		if (i == 0) {
		    *s = ' ';
		    break;
		}
		i--;
	    }
	} while (*++s != '\000');
	if ((pch=FindWord("struct", pch)) == NULL)
	    continue;
	for (i=0; i<6;i++)
	    *pch++ = ' ';
	while (*pch)
	    pch++;
	*pch++ = ';';
	*pch = '\000';
    }
}

VOID FixCast( pch )
CHAR  *pch;
{
    /*
     *	  Look for and remove any casts.  These are defined as (XXX *),
     *	where XXX is a type we know about,  and * may or may not be present.
     *	These are meaningless to assembler,  which is typeless.
     *	  We remove casts by whiting them out.
     */

    register  CHAR  *pchT;
    register  CHAR  *pchT1;

    CHAR  *pchStart;
    CHAR  chBuf[ 128 ];

    /*	 Start looking from the RHS */
    while (pchStart = strchr( pch, '(' ) ) {
	/*  Worth looking - there are candidates */
	while (*pchStart == '(' )
	    ++pchStart;		/* May be nested for other reasons */

	for( pchT = pchStart; *pchT && isspace( *pchT ); ++pchT )
	    ;		/* Scan to start of type */
	pchT1 = chBuf;
	while (*pchT && (isalnum( *pchT ) || *pchT == '_' ) )
	    *pchT1++ = *pchT++;		/* Copy ONLY type to local */
	*pchT1 = '\0';


	/*  Is it a type we have?  */
	if (CalcType2( chBuf, rgpchDD ) == 0 ||
	    CalcType2( chBuf, rgpchDB ) == 0 ||
	    CalcType2( chBuf, rgpchDW ) == 0 ||
	    CalcType2( chBuf, rgpchW_D ) == 0 ) {
	    /*	 Known type - maybe a cast! */
	    while (*pchT && isspace( *pchT ) )
		++pchT;
	    if ( *pchT == '*' ) {
		/*  Pointer - still OK */
		++pchT;
		while (*pchT && isspace( *pchT ) )
		    ++pchT;
	    }
	    if ( *pchT == ')' ) {
		/*  Found all the bits - white them out */
		while (pchT >= pchStart )
		    *pchT-- = ' ';
		*pchT = ' ';		/* Skipped over leading ( */
	    }
	}
	pch = pchStart;			/* Continue from here */
    }

    return;
}

VOID DoDefinesOff()
{
    fDefines = TRUE;
    while (cLines++ && fgetl(rgchLine, CCHMAX, hfIn)) {
	if (FindWord("DEFINESON", rgchLine)) {
	    fDefines = FALSE;
	    return;
	}
	ProcessLine();
    }
    fDefines = FALSE;
    return;
}

VOID DoNoInc()
{
    while (cLines++ && fgetl(rgchLine, CCHMAX, hfIn)) {
	if (FindWord("INC", rgchLine))
	    return;
    }
}

VOID DoXlatOff()
{
    while (cLines++ && fgetl(rgchLine, CCHMAX, hfIn)) {
	if (FindWord("XLATON", rgchLine))
	    return;
    }
}

VOID DoExtern(pline)
char	*pline;
{
    char	*pch;

    while (TRUE) {
	pch = pline;
	while (*pch && *pch != ';')
	    pch++;
	if (*pch == ';')
	    return;
	if (fgetlx(pline, CCHMAX, hfIn))
	    cLines++;
	else
	    return;
    }
}


CHAR	*fgetlx(buffer,buflen,fi)
char	*buffer;
int	buflen;		/* Buffer length */
FILE	*fi;		/* Input file */
{
    int		i, j;
    char	*buf;

    j = buflen;
    buf = buffer;
    while (TRUE) {
	if (fgetl(buf, j, fi) == NULL)
	    return (NULL);
	i = strlen(buf) - 1;
	if (i < 0 || buf[i] != '\\')
	    return (buffer);
	else if (buflen -i >= 40) {
	    j -= i;
	    buf += i;
	}
	else {
	    Error("Line too long");
	    break;
	}
    }
    return (buffer);
}

/*
 *  This function differs from fgets() in the following ways:
 *
 *  (1) It ignores carriage returns.
 *  (2) It expands tabs.
 *  (3) It does NOT include the terminating linefeed in the
 *	string it returns.
 *
 *  I didn't spec the interface to behave this way; it is
 *  some fool PM private incompatible C runtime function.
 */

CHAR			*fgetl(buffer,buflen,fi)
CHAR			*buffer;	/* Buffer pointer */
register int		buflen;		/* Buffer length */
FILE			*fi;		/* Input file */
{
    int			c;		/* A character */
    register CHAR	*cp1;		/* Char pointer */
    int			i;		/* Counter */

    if (buflen-- == 0) return(NULL);	/* NULL if zero-length buffer */
    for(cp1 = buffer; buflen > 0; ) {	/* Loop to get line */
	if ((c = getc(fi)) == EOF) {	/* If end of file */
	    if (cp1 > buffer)
		break;			/* Break if buffer not empty */
	    return(NULL);		/* End of file */
	}
	if (c == '\r')
	    continue;			/* Ignore CRs */
	if (c == '\t') {		/* If tab */
	    i = 8 - ((cp1 - buffer) % 8);
					/* Compute number of spaces to fill */
	    if (i > buflen)
		i = buflen;	/* Don't exceed space remaining */
	    while (i-- > 0) {		/* While spaces remaining */
		*cp1++ = ' ';		/* Fill with space */
		--buflen;		/* Decrement buffer count */
	    }
	    continue;			/* Go get next character */
	}
	if (c == '\n')
	    break;			/* Break if linefeed */
	*cp1++ = (CHAR)c;		/* Copy the character */
	--buflen;			/* Decrement buffer count */
    }
    *cp1 = '\0';			/* Add terminator */
    return(buffer);			/* Return pointer to buffer */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\tools\src\stripz\stripz.c ===
/*
 *	Stripz.c - Strip the header off of a .SYS file
 *
 *	I don't know what this is for, but this program reads a file
 *	of the format
 *
 *	DW	<len>
 *	DB	<len-2> dup (0)
 *	DB	N bytes of data to keep
 *
 *	This program copies argv[1] to argv[2], striping off those leading
 *	bytes of zero and the length word.
 *
 *	We don't check to see if they're really zero, we just discard
 *	the first <len> bytes of argv[1].
 */

#include <stdio.h>
#include <fcntl.h>
#include <sys\types.h>
#include	<sys\stat.h>
#include	<io.h>

char buf[16384];
unsigned int pos;
int rdcnt;
int srcfile, tgtfile ;

main(argc, argv)
int	argc ;
char	*argv[] ;
{
	if ( argc != 3 ) {
		fprintf (stderr, "Usage : stripz src_file trgt_file\n") ;
		exit (1) ;
	}

	if ((srcfile = open(argv[1], (O_BINARY | O_RDONLY))) == -1) {
		fprintf (stderr, "Error opening %s\n", argv[1]) ;
		exit (1) ;
	}

	rdcnt = read (srcfile, buf, 2);
	if (rdcnt != 2) {
		fprintf (stderr, "Can't read %s\n", argv[1]);
		exit(1);
	}

	pos = lseek (srcfile, 0L, SEEK_END ) ;
	if ( (long)(*(unsigned int *)buf) > pos ) {
		fprintf (stderr, "File too short or improper format.\n");
		exit(1);
	}

	lseek(srcfile, (long)(*(unsigned int *)buf), SEEK_SET ) ;

	if ( (tgtfile = open(argv[2], (O_BINARY|O_WRONLY|O_CREAT|O_TRUNC),
											(S_IREAD|S_IWRITE))) == -1) {
		printf ("Error creating %s\n", argv[2]) ;
		close (srcfile) ;
		exit (1) ;
	}

	while ( (rdcnt = read (srcfile, buf, sizeof buf)) > 0)
		write (tgtfile, buf, rdcnt);

	close (srcfile) ;
	close (tgtfile) ;

	return ( 0 ) ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dos\v86\tools\src\stripdd\stripdd.c ===
/***
****
* File : stripdd.c
*	Used to strip out the zeroes in a segment which is orged to a high
*	value. Mostly written for the following scenario. Has not been
*	tested for any other stunts.
*
*
*	/--------------------------------------\  File offset Grows
*	|				       |
*	|				       |
*	| First Segment			       |
*	|				       |
*	|				       |
*	|				       |
*	|--------------------------------------|
*	|				       |
*	|				       |
*	|				       |									|
*	| Zeroes due to the ORG		       |
*	| in the second segment		       |
*	|				       |
*	|				       |
*	|--------------------------------------|
*	|				       |
*	|				       |
*	| data part of 2nd segment	       |
*	|--------------------------------------|
*	|				       |
*	|				       |
*	| Tail for Stripdd		       |
*	|				       |
*	\--------------------------------------/
*
*
*	This utility removes the 'Zeroes' portion from the source file
*
*
*	The Tail is of the following format
*
*	struct Tail {
*		int	TailLen ; len of Tail including len field
*		struct Entry[NUMENTRIES]
*		long	Terminator ; == -1
*		filler
*	}
*
*	struct Entry {
*		long	offset ;	offset of Zeroes from the beg of file
*		int	size ;	number of zeroes to be stripped
*	}
*
*
*	Even though the Tail was designed variable number of entries
*	the utility handles only one entry right now.
*
*	Also the offset field in the Entry structure is being
*	rounded to para boundary, assuming that the 2nd segment
*	starts at a para boundary.
*
*
*	Usage : stripdd <sourcefile> <destfile>
***
***/

#include	<fcntl.h>
#include	<io.h>
#include	<stdio.h>
#include	<sys\types.h>
#include	<sys\stat.h>
#include	<process.h>

int		SrcFile, DstFile ;
unsigned int	HeadLen, *HeadPtr ;
long		FileSize ;

extern	void *malloc() ;

GetHeader ()
{
	char	tempbuf[2] ;
	int	*tptr ;

	fprintf ( stderr, "Reading in Tail Info...\n" ) ;

	if ( (FileSize = lseek (SrcFile, -16L, SEEK_END )) == -1) {
		fprintf ( stderr, "Error while seeking\n" ) ;
		exit (1) ;
	}

	if ( read(SrcFile, tempbuf, 2) != 2 ) {
		fprintf ( stderr, "Error while reading in the header\n" ) ;
		exit ( 1 ) ;
	}
	tptr = (int *)tempbuf ;
	HeadLen = *tptr - 2 ;
	HeadPtr = malloc ( HeadLen ) ;
	if (HeadPtr == NULL) {
		fprintf ( stderr, "Memory allocation error\n" ) ;
		exit (1) ;
	}
	if ( read(SrcFile, (char *)HeadPtr, HeadLen) != HeadLen ) {
		fprintf ( stderr, "Error while reading in the header\n" ) ;
		exit ( 1 ) ;
	}

	if ( lseek (SrcFile, 0L, SEEK_SET ) == -1) {
		fprintf ( stderr, "Error while seeking\n" ) ;
		exit (1) ;
	}

}

Process()
{
	long	offset ;


	offset = * ( (long *)HeadPtr) ;
	offset = (offset + 15) & 0xfffffff0 ;
	fprintf ( stderr, "Copying first segment...\n" ) ;
	copy ( offset ) ;
	FileSize -= offset ;
	HeadPtr += 2 ;
	offset = *HeadPtr ;
	fprintf ( stderr, "Stripping zeroes from the second segment...\n" ) ;
	lseek ( SrcFile, offset, SEEK_CUR ) ;
	FileSize -= offset ;
	fprintf ( stderr, "Copying second segment...\n" ) ;
	copy (FileSize) ;
}
char	buf[4096] ;

copy ( len )
long	len ;

{
	int	readlen ;

	while ( len > 0 ) {
		if ( len > 4096 )
			readlen = 4096 ;
		else
			readlen = len ;

		if ( read (SrcFile, buf, readlen ) != readlen ) {
			fprintf ( stderr, "Error while reading data\n" ) ;
			exit (1) ;
		}

		if ( write (DstFile, buf, readlen ) != readlen ) {
			fprintf ( stderr, "Error while writing data\n" ) ;
			exit (1) ;
		}
		len -= readlen ;
	}
}

main ( argc, argv )
int	argc ;
char	*argv[] ;

{
	if (argc != 3) {
		fprintf ( stderr, "Usage : stripdd infile outfile\n" ) ;
		exit (1) ;
	}

	SrcFile = open ( argv[1], O_BINARY ) ;
	if ( SrcFile == -1 ) {
		fprintf ( stderr, "Error opening %s\n", argv[1] ) ;
		exit (1) ;
	}

	DstFile = open ( argv[2], O_RDWR | O_CREAT | O_TRUNC | O_BINARY,
														S_IREAD | S_IWRITE ) ;

	GetHeader() ;
	Process() ;
	fprintf ( stderr, "%s stripped to %s\n", argv[1], argv[2] ) ;
	return(0) ;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxboot.asm ===
PAGE    ,132
        TITLE   DXBOOT.ASM -- Dos Extender Startup Code

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXBOOT.ASM      -   Dos Extender Startup Code           *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains real mode initialization code that     *
;*  initializes the dos extender itself.  This includes         *
;*  allocating and initializing the descriptor tables, and      *
;*  relocating the dos extender for protected mode operation.   *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  01/29/92 mattfe Build for MIPS                              *
;*  12/19/90 amitc  NetHeapSize default made 4k from 8k         *
;*  12/03/90 amitc  Added support for 'Win30CommDriver' switch  *
;                   in system.ini                               *
;*  10/09/90 earleh split LDT from GDT and reduced XMS handles  *
;*                  needed to boot program to 1                 *
;*  08/08/90 earleh DOSX and client privilege ring determined   *
;*                  by equate in pmdefs.inc                     *
;*  05/07/90 jimmat Started VCPI related changes.               *
;*  04/09/90 jimmat Detect if on 286 & 287 installed.           *
;*  04/02/90 jimmat Added PM Int 70h handler.                   *
;*  09/27/89 jimmat Changes to use FindFile to locate child     *
;*                  program.                                    *
;*  08/29/89 jimmat Now hooks real mode Int 2Fh chain.          *
;*  08/20/89 jimmat Removed A20 code since HIMEM version 2.07   *
;*                  now works properly across processor resets. *
;*  07/28/89 jimmat Int PM Int 30h & 41h to be ignored, not     *
;*                  reflected to real mode.                     *
;*  07/14/89 jimmat Added call to EMMDisable                    *
;*  06/16/89 jimmat Ifdef'd combined DOSX/child .EXE code       *
;*  05/22/89 jimmat Added Int 13h/25h/26h/67h hooks.            *
;*  05/18/89 jimmat Added setting of real mode Int 30h hook.    *
;*  03/31/89 jimmat Added Priv Level to selectors during        *
;*                  relocation and removed some dead code.      *
;*  03/15/89 jimmat Added INT 31h hook                          *
;*  03/11/89 jimmat Added support for TSS & LDT & ring 1        *
;*  03/07/89 jimmat Converted to use WDEB386 debugger           *
;*  02/25/89 (GeneA): added support for combined exe file where *
;*      the Dos Extender and the child reside in the same exe   *
;*      file.                                                   *
;*  02/17/89 (GeneA): fixed error handling code during init.    *
;*  02/14/89 (GeneA): added initialization of INT15h vector,    *
;*      and changed segment limit of BIOS_CODE segment to       *
;*      64k.                                                    *
;*  02/14/89 (GeneA): added code to copy protected mode code    *
;*      segment up into extended memory.  Also code to allocate *
;*      and copy GDT and IDT in extended memory.                *
;*  01/31/89 (GeneA): reorganization of code.  This module now  *
;*      contains only code for initializing the Dos Extender    *
;*      itself.                                                 *
;*  01/25/89 (GeneA): moved code for loading and relocating     *
;*      the child program here from dxinit.asm                  *
;*  01/24/89 (Genea): removed routines for hooking into real    *
;*      mode int 2Fh.  (part of removing real mode int 2Fh      *
;*      interface from the dos extender).                       *
;*  12/13/88 (GeneA): created by moving code from DXINIT.ASM    *
;*                                                              *
;****************************************************************

.286p
.287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

.xlist
.sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include dpmi.inc
ifdef WOW_x86
include vdmtib.inc
endif
include intmac.inc
include dbgsvc.inc
.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

;
; This structure defines the format of the EXE file header.

EXEHDR  struc

idExeFile       dw      ?       ;magic number to identify EXE file
cbLastPage      dw      ?       ;number of bytes in last page of the file
crgbFileLen     dw      ?       ;number of 512 byte pages in the file
clpRelocLen     dw      ?       ;number of relocation entries in the table
cparHdrSize     dw      ?       ;number of 16 byte paragraphs in header
cparMinAlloc    dw      ?
cparMaxAlloc    dw      ?
segStackInit    dw      ?       ;initial stack segment
offStackInit    dw      ?       ;initial stack pointer
wCheckSum       dw      ?
offCodeInit     dw      ?       ;initial program counter
segCodeInit     dw      ?       ;initial code segment
wRelocOffset    dw      ?       ;byte offset of relocation table
idOverlay       dw      ?       ;overlay number

EXEHDR  ends

;
; This structure defines the parameter block to the XMS driver block
; move function.

XMSMOVE struc

cbxmsLen        dd      ?       ;length of memory block
hxmsSource      dw      ?       ;XMS source block handle
oxmsSource      dd      ?       ;source offset
hxmsDest        dw      ?       ;XMS destination block handle
oxmsDest        dd      ?       ;destination offset

XMSMOVE ends

NOP_OPCODE      equ     090h            ; NO-OP opcode
IRET_OPCODE     equ     0CFh            ; IRET opcode
FAR_JMP_OPCODE  equ     0EAh            ; JMP FAR opcode
SHORT_JMP_OPCODE equ    0EBh            ; JMP SHORT opcode

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   PMIntr31:NEAR
        extrn   PMIntr13:NEAR
        extrn   PMIntr19:NEAR
        extrn   PMIntr28:NEAR
        extrn   PMIntr25:NEAR
        extrn   PMIntr26:NEAR
        extrn   PMIntr4B:NEAR
        extrn   PMIntrDos:NEAR
        extrn   PMIntrMisc:NEAR
        extrn   PMIntrVideo:NEAR
        extrn   PMIntrMouse:NEAR
        extrn   PMIntrIgnore:NEAR
        extrn   PMIntrEntryVector:NEAR
        extrn   PMFaultEntryVector:NEAR
        extrn   ReadINIFile:NEAR
ifdef      NEC_98    ;
        extrn   PMIntrSound:NEAR                ; for Sound Bios
        extrn   PMIntrExDos:NEAR                ; for Extend Dos Function
        extrn   PMIntr11dummy:NEAR
        extrn   PMIntrPrinter:NEAR
        extrn   PMIntrCalTi:NEAR
        extrn   PMIntrGraph:NEAR
endif   ;NEC_98   ;

        extrn   EMMDisable:NEAR
        extrn   FindFIle:NEAR

ifdef WOW_x86
        extrn   NpxExceptionHandler:near
        extrn   EndNpxExceptionHandler:near
endif

        extrn   RmUnsimulateProc:FAR
        extrn   PmUnsimulateProc:FAR

        extrn   PMFaultHandlerIRET:NEAR
        extrn   PMFaultHandlerIRETD:NEAR
        extrn   PMIntHandlerIRET:NEAR
        extrn   PMIntHandlerIRETD:NEAR
        extrn   PMDosxIret:NEAR
        extrn   PMDosxIretd:NEAR

        extrn   RMCallBackBop:FAR
        extrn   RMtoPMReflector:FAR

        extrn   RmSaveRestoreState:far
        extrn   PmSaveRestoreState:far
        extrn   RmRawModeSwitch:far
        extrn   PmRawModeSwitch:far
        extrn   DPMI_MsDos_API:far
        extrn   VCD_PM_Svc_Call:far
        extrn   XmsControl:far
        extrn   HungAppExit:far

DXPMCODE    segment
        extrn   CodeEndPM:NEAR
externFP        NSetSegmentDscr
DXPMCODE    ends

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   selGDT:WORD
        extrn   segGDT:WORD
        extrn   selIDT:WORD
        extrn   segIDT:WORD
        extrn   bpGDT:FWORD
        extrn   bpIDT:FWORD
        extrn   sysTSS:WORD
        extrn   segPSP:WORD
        extrn   selPSP:WORD
        extrn   hmemDOSX:WORD
        extrn   f286_287:BYTE
        extrn   bpRmIVT:FWORD
        extrn   fhExeFile:WORD
        extrn   idCpuType:WORD
        extrn   cdscGDTMax:WORD
        extrn   rgbXfrBuf0:BYTE
        extrn   rgbXfrBuf1:BYTE
        extrn   clpRelocItem:WORD
        extrn   plpRelocItem:WORD
        extrn   lpfnXMSFunc:DWORD
ifdef      NEC_98    ;
        extrn   fPCH98:BYTE                     ; PC-H98 flag
        extrn   fNHmode:BYTE                    ; NHmode flag
endif   ;NEC_98   ;
        extrn   lpfnUserMouseHandler:DWORD
        extrn   fUsingHMA:BYTE
ifdef WOW_x86
        extrn   rgwWowStack:word
        extrn   FastBop:fword
endif
        extrn   pbHwIntrStack:word

IFNDEF WOW_x86
        extrn   IretBopTable:BYTE
ENDIF

        public  fDebug
fDebug   db     0

szModName db    'DOSX',0        ;Our module name for use by WDEB386


if DEBUG
        public  lpchFileName
lpchFileName    dd  ?
endif


INIFileName     db      'SYSTEM.INI',0  ;.INI file to read

        public  NetHeapSize, Int28Filter

INIKeywords     label   byte
                db      '[standard]',0
                db      'netheapsize',0
NetHeapSize     dw      4                       ;default is 8k
                db      'int28filter',0
Int28Filter     dw      10                      ;default is every 10th

if DEBUG   ;------------------------------------------------------------
                public  fTraceDOS
                db      'tracedos',0
fTraceDOS       dw      0
                public  fTraceFault
                db      'tracefault',0
fTraceFault     dw      0
                public  fTraceA20
                db      'tracea20',0
fTraceA20       dw      1
                public  TrapDOS
                db      'trapdos',0
TrapDOS         dw      0
                db      'tableslow',0
fTablesLow      dw      0
                public  fTraceReflect
                db      'tracereflect',0
fTraceReflect   dw      0
                public  fTraceMode
                db      'tracemode',0
fTraceMode      dw      0
endif   ;DEBUG  --------------------------------------------------------
                db      0

szExeExtension  db      '.exe',0


; The following set of variables are used when copying our Pmode data
; structures into a HIMEM-allocated block.

        public lmaIDT,lmaGDT,lmaDXPMCODE

CBIDTOFF        = 0
CBGDTOFF        = CDSCIDTDEFAULT * 8
IFNDEF WOW_x86
CBDXPMCODEOFF   = CBGDTOFF + GDT_SIZE
ELSE
;
; Since we have no GDT for wow, we do not need space for it.
;
CBDXPMCODEOFF   = CBGDTOFF
ENDIF
CBTABLESIZE     = CBDXPMCODEOFF

.errnz  CBIDTOFF and 0fh
.errnz  CBGDTOFF and 0fh
.errnz  CBDXPMCODEOFF and 0fh

lmaIDT      dd  CBIDTOFF
lmaGDT      dd  CBGDTOFF
lmaDXPMCODE dd  CBDXPMCODEOFF
lmaLDT      dd  CBDXPMCODEOFF


        extrn   rgwStack:WORD
DXDATA  ends


DXSTACK segment
        extrn   ResetStack:WORD
DXSTACK ends

; -------------------------------------------------------
        page
; -------------------------------------------------------
;               CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

;************************************************************************
;
;       REMEMBER... any code segment variables defined in this file
;                   will be discarded after initialization.
;
;************************************************************************

        extrn   CodeEnd:NEAR
        extrn   segDXCode:WORD
        extrn   segDXData:WORD
        extrn   selDgroup:WORD

ErrMsg  MACRO   name
        extrn   ER_&name:BYTE
ERC_&name       equ offset ER_&name
        ENDM

        ErrMsg  CPUTYPE
        ErrMsg  DXINIT
        ErrMsg  PROTMODE
        ErrMsg  NOHIMEM
        ErrMsg  EXTMEM
        ErrMsg  NOEXE

        extrn   RMInt2FHandler:NEAR

        extrn   PrevInt2FHandler:DWORD

szWinKernel     db      'krnl386.exe',0

lpfnPrevXMS     dd      0


DXCODE  ends


DXPMCODE    segment

        extrn   selDgroupPM:WORD

        extrn   segDXCodePM:WORD
        extrn   segDXDataPM:WORD

DXPMCODE    ends

; -------------------------------------------------------
        page

DXCODE  segment
        assume  cs:DXCODE
; -------------------------------------------------------
;               MAIN INITIALIZATION ROUTINES
; -------------------------------------------------------

;   InitDosExtender     -- This routine is the executive
;       for initializing the dos extender.
;
;   Input:  none
;   Output: various global tables and variables initialized.
;           Dos Extender relocated for protected mode execution
;           and moved into extended memory.
;   Errors: returns CY set if error occurs, pointer to error message
;           in DX
;   Uses:

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitDosExtender

InitDosExtender:

; Init the key code & data segment variables.

        mov     ax,cs
        mov     segDXCode,ax

        mov     ax,ds
        mov     segDXData,ax
        mov     selDgroup,ax

        push    es
        mov     ax,seg DXPMCODE
        mov     es,ax
        assume  es:DXPMCODE

        mov     selDgroupPM,SEL_DXDATA or STD_RING
        mov     segDXCodePM,cs
        mov     segDXDataPM,ds
        pop     es
        assume  es:DGROUP



; Do an initial shrink of our program memory.  This assumes that DXPMCODE
; is the last segment in program.

        mov     bx,(offset DXPMCODE:CodeEndPM) + 10h
        shr     bx,4
        add     bx,seg DXPMCODE
        sub     bx,segPSP
        mov     es,segPSP
        dossvc  4Ah

        push    ds
        pop     es


; Determine the type of CPU we are running on and make sure it is
; at least an 80286.

        call    CheckCPUType
        cmp     ax,2
        jae     indx14
        mov     ax,ERC_CPUTYPE
        jmp     indx80
indx14:


; If running on a 286, see if there is a 287 coprocessor installed

ifdef      NEC_98    ;
;------------------- 90/08/15 --------------------
;check N/H at system area BIOS_FLAG(0:501h)
;if H mode, fNHmode bit on.
        push    es
        push    ax
        mov     ax,0
        mov     es,ax
        test    byte ptr es:[501h],8h   ;if Hmode 
        jz      not_Hmode
        mov     fNHmode,0FFh    ;Now! Running on Hmode!!! 90/07/07
not_Hmode:
        pop     ax
        pop     es
;------------------- 90/08/15 --------------------
; If running on a 286, see if there is a 287 coprocessor installed
        cmp     al,2            ;286 processor?
        jnz     EMM_Disable
        test    fNHmode,0FFh
        jz      Copro_Nmode
;----- 90/07/04 in -----
;  check co-processor exist at memory-switch
;----------------- Hmode -----------------
        push    ds
        push    bx
;;;;;;;;        mov     bx,0Eh
        mov     bx,0E000h               ;90/10/04 bug
        mov     ds,bx
        mov     bx,3FEAh
        mov     al,byte ptr ds:[bx]
        pop     bx
        pop     ds
        test    al,08h          ;0=none,1=exists
        jmp     Coprocessor
Copro_Nmode:
;----------------- Nmode -----------------
        push    ds
        push    bx
;;;;;;;;        mov     bx,0Ah
        mov     bx,0A000h               ;90/10/04 bug
        mov     ds,bx
        mov     bx,3FEAh
        mov     al,byte ptr ds:[bx]
        pop     bx
        pop     ds
        test    al,08h          ;0=none,1=exists
Coprocessor:
        jz      EMM_Disable
        inc     f286_287        ;  yup, 286 & 287
EMM_Disable:
else    ;NEC_98   ;
        cmp     al,2            ;286 processor?
        jnz     @f

        int     11h             ;math coprocessor installed?
        test    al,2
        jz      @f
ifndef WOW_x86
        inc     f286_287        ;  yup, 286 & 287
endif
@@:
endif   ;NEC_98   ;

; If on a 386 or greater, try to disable the EMM drivers we know about

          call    EMMDisable

; Check if the machine is already running in protected mode.  If so, we
; can't run.
ifndef WOW_x86
        smsw    ax
        test    ax,1        ;check the protected mode bit
        jz      @f
        mov     ax,ERC_PROTMODE
        jmp     indx80
endif
@@:

; Get the full pathname of our EXE file, it's needed in a couple of places

        call    GetExeName
        jnc     @F
        mov     ax,ERC_DXINIT
        jmp     indx80
@@:

; Determine if the real mode Int 28h vector points anywhere.  If it doesn't
; then we don't need to reflect Int 28h calls from protected to real mode.
; The user can still override this by putting a Int28Filter= entry in
; SYSTEM.INI.

        push    es
        mov     ax,3528h
        int     21h
        assume  es:NOTHING

        cmp     byte ptr es:[bx],IRET_OPCODE    ;Int 28h -> IRET?
        jne     @f
        mov     Int28Filter,0                   ;  yes, don't need to reflect
@@:
        pop     es
        assume  es:DGROUP

; Read SYSTEM.INI for any parameter overrides - NOTE: requires GetExeName
; having been run first!

        mov     bx,offset INIKeywords
        mov     dx,offset INIFileName
        call    ReadINIFile

; Check that the HIMEM.SYS driver is installed so that we can use it
; for extended memory management.

        call    SetupHimemDriver
        jnc     @F                              ; Himem is OK.
        mov     ax,ERC_NOHIMEM
        jmp     indx80
@@:

ifdef      NEC_98    ;
        push    es
        xor     ax, ax
        mov     es, ax
        test    byte ptr es:[458h], 80h         ; if NESA
        jz      not_MC
        mov     fPCH98, 0FFh                    ; it's a NPC NESA
not_MC:
        pop     es
        assume  es:DGROUP
endif   ;NEC_98   ;

; Hook the real mode int vectors

        mov     ax,352Fh                        ;get previous Int 2Fh vector
        int     21h
        assume  es:NOTHING

        mov     word ptr [PrevInt2FHandler],bx
        mov     word ptr [PrevInt2FHandler+2],es

        push    ds
        pop     es
        assume  es:DGROUP

        mov     ax,cs                           ;point to our rMode Int 2Fh
        mov     ds,ax
        assume  ds:NOTHING
        mov     dx,offset DXCODE:RMInt2FHandler
        mov     ax,252Fh
        int     21h

        push    es
        pop     ds
        assume  ds:DGROUP

; Allocate and initialize the descriptor tables and TSS.

        cCall   AllocateExtMem
        jnc     indx20
        mov     ax,ERC_EXTMEM
        jmp     indx80
indx20:

        push    es
        push    bx
        push    dx
        push    di
        push    si

;
; Bop to initialize 32 bit support.
;

        mov     di, sp                          ;original stack offset

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:HungAppExit

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:XmsControl
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:DPMI_MsDos_API
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:VCD_PM_Svc_Call

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PmRawModeSwitch
        push    segDXCode
        push    offset DXCODE:RmRawModeSwitch

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PmSaveRestoreState
        push    segDXCode
        push    offset DXCODE:RmSaveRestoreState

        mov     bx,cdscGDTMax
        shl     bx,3
        dec     bx
        push    bx                              ;Initial LDT size
        push    selGDT

        push    SEL_DXPMCODE OR STD_RING        ;pm reflector seg

        push    segDXCode
        push    offset DXCODE:RMtoPMReflector
        push    segDXCode
        push    offset DXCODE:RMCallBackBop

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMDosxIretd
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMDosxIret

        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMIntHandlerIRETD
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMIntHandlerIRET
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMFaultHandlerIRETD
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PMFaultHandlerIRET

        push    SEL_DXCODE OR STD_RING
        push    segDXCode
        push    SEL_DXPMCODE OR STD_RING
        push    offset DXPMCODE:PmUnsimulateProc
        push    segDXCode
        push    offset DXCODE:RmUnsimulateProc
        push    word ptr CB_STKFRAME
        push    segDXData
        mov     si,sp                           ;pass stack offset
        DPMIBOP InitDosxRM
        mov     sp, di                          ;restore stack

ifdef WOW_x86
        mov     word ptr [FastBop],bx
        mov     word ptr [FastBop + 2],dx
        mov     word ptr [FastBop + 4],es
endif

        pop     si
        pop     di
        pop     dx
        pop     bx
        pop     es

        call    InitGlobalDscrTable     ;set up the GDT

        call    SendDbgNotification     ;tell NTSD about our segments

        call    InitIntrDscrTable       ;set up the IDT

ifndef WOW_x86              ;bugbug
        call    InitTaskStateSeg        ;set up the TSS
endif

if DEBUG

; DOSX is written such that it does not require any segment fix ups for
; protected mode operation.  This wasn't always the case, and it's easy
; to make create dependencies so the routine CheckDOSXFixUps exists in
; the debug version to check for segment fix ups in non-initialization
; code.

        call    CheckDOSXFixUps
        jnc     @F
        mov     ax,ERC_DXINIT
        jmp     short indx80
@@:
endif   ;DEBUG

; Move the Extended memory segment up into extended memory.

        mov     dx,seg DXPMCODE
        call    MoveDosExtender
        jc      indx80


; Move the GDT and IDT up into extended memory.

        call    MoveDscrTables

; Parse the command line, and locate the child exe file

        call    ParseCommandLine

IFNDEF WHEN_COMMAND_COM_WORKS
if WINDOWS      ;--------------------------------------------------------

; If this is a Windows specific version of DOSX, we only run one child EXE
; (krnl?86.exe).

        push    ds
        push    cs
        pop     ds
        assume  ds:NOTHING

        mov     si,offset DXCODE:szWinKernel
        mov     di,offset RELOC_BUFFER

        call    strcpy

        pop     ds
        assume  ds:DGROUP

endif   ;WINDOWS        -------------------------------------------------

        call    FindFile                ;setup done by ParseCommandLine
        jnc     indx70
        mov     ax,ERC_NOEXE
        jmp     short indx80
indx70:
ENDIF

; Initialized okay!

        clc
        jmp     short indx90

; Error occured.  Free any extended memory blocks allocated and then
; return the error code.

indx80: push    ax              ;save the error code

;
; If we have allocated an extended memory block, then free it.
; If we have allocated the HMA, then free it.
;
        mov     dx,hmemDOSX
        or      dx,dx
        jz      @F
        xmssvc  0Dh
        xmssvc  0Ah

@@:
        cmp     fUsingHMA,0
        je      @F
        xmssvc  2
@@:

indxEXIT:
        pop     ax              ;restore the error code

        stc                     ;set error flag

indx90: ret


; -------------------------------------------------------
;   AllocateExtMem  --  Allocates memory used by DOSX for
;                       system tables and protected mode
;                       code.
;                       Allocates a temporary buffer in
;                       DOS memory for building the
;                       IDT and GDT.
; Input: none
; Output: none
; Uses: Flags
; Error: Carry set if cannot allocate memory.
;
; History:
;       10/05/90 - earleh wrote it

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

cProc   AllocateExtMem,<PUBLIC,NEAR>,<ax,bx,dx>
cBegin

; If there is sufficient XMS memory, increase the size of the GDT/LDT
; up to the max of 8k selectors.

        add     word ptr lmaLDT,offset DXPMCODE:CodeEndPM
        adc     word ptr lmaLDT+2,0
        add     word ptr lmaLDT,0Fh     ;make sure LDT is para aligned
        adc     word ptr lmaLDT+2,0
        and     word ptr lmaLDT,0FFF0h

@@:

        xmssvc  08h             ;Query Free Extended memory
        cmp     dx,1024         ;is there more than 1 meg available?
        jb      @f
        mov     cdscGDTMax,CDSCMAXLDT   ; yes, max out the GDT size
@@:
        mov     ax,cdscGDTMax
        xor     dx,dx
        shl     ax,3
        adc     dx,0
        add     ax,word ptr lmaLDT
        adc     dx,word ptr lmaLDT+2
        add     ax,1023d
        adc     dx,0                    ; DX:AX = total extended memory needed
        shl     dx,6
        shr     ax,10d
        or      dx,ax                   ; DX = kbytes needed
        mov     si,dx                   ; SI = kbytes needed
        xmssvc  09h                     ; allocate the XMS block
        or      ax,ax
        jz      axm_error
        mov     hmemDOSX,dx
        xmssvc  0Ch                     ; lock it, DX:BX = address
        or      ax,ax
        jz      axm_error

axm_address:

        add     word ptr lmaIDT,bx      ; relocate tables & Pmode code
        adc     word ptr lmaIDT+2,dx
        add     word ptr lmaGDT,bx
        adc     word ptr lmaGDT+2,dx
        add     word ptr lmaDXPMCODE,bx
        adc     word ptr lmaDXPMCODE+2,dx
        add     word ptr lmaLDT,bx
        adc     word ptr lmaLDT+2,dx
        mov     bx,(CDSCIDTDEFAULT + GDT_SELECTORS + 1) shr 1
        dossvc  48h                     ; get a DOS block for building tables
        jc      axm_error               ; abort if error

        mov     segIDT,ax
        mov     selIDT,ax
        add     ax,CDSCIDTDEFAULT shr 1
        mov     segGDT,ax
        mov     selGDT,ax

        clc
        jmp     axm_exit
axm_error:
        stc
axm_exit:
cEnd


; -------------------------------------------------------
; SetupHimemDriver      -- This routine checks that an XMS driver
;       is installed and sets up for calling it.
;
;   Input:  none
;   Output: none
;   Errors: returns CY set if no driver available
;   Uses:   AX, all other registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  SetupHimemDriver

SetupHimemDriver proc   near


        push    bx
        push    es

; Check to see if there is an XMS driver resident.

        mov     ax,4300h
        int     2Fh
        cmp     al,80h
        jnz     sthd80

; There is an XMS driver resident, so init for calling it.

        mov     ax,4310h
        int     2Fh
        mov     word ptr [lpfnXMSFunc],bx
        mov     word ptr [lpfnXMSFunc+2],es

; Make sure this is the proper XMS/driver version

        xmssvc  0               ;returns XMS vers in ax, driver vers in bx
        cmp     ax,300h         ;assume okay if XMS 3.0 or above
        jae     @f
        cmp     ax,200h         ;require at least XMS 2.00
        jb      sthd80
        cmp     bx,21Ch         ;if XMS 2.x, require driver version 2.28+
        jb      sthd80          ; (himem used to have minor vers in decimal)
@@:

; Verify that the XMS driver's A20 functions work

        xmssvc  5                       ;local enable
        or      ax,ax
        jz      sthd80

        xmssvc  7                       ;query A20
        push    ax

        xmssvc  6                       ;local disable
        or      ax,ax

        pop     ax                      ;recover query status
        jz      sthd80

        or      ax,ax                   ;should be NZ, (A20 enabled status)
        jz      sthd80

; Looks good to me...

        clc
        jmp     short sthd90

; No XMS driver resident or wrong version or we couldn't enable A20.

sthd80: stc

sthd90: pop     es
        pop     bx
        ret

SetupHimemDriver endp


; -------------------------------------------------------
;   MoveDosExtender     -- This routine will move the Dos Extender
;       protected mode segment up into extended memory.
;       The himem driver function for moving memory blocks is used.
;       The parameter block for this function is built in rgbXfrBuf0.
;
;   Input:  DX      - real mode segment address of the segment to move
;   Output: none
;   Errors: returns CY set if error, Error code in AX
;   Uses:   AX used, all else preserved
;           modifies rgbXfrBuf0

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  MoveDosExtender

MoveDosExtender proc    near

        push    bx
        push    cx
        push    dx
        push    si

        cmp     fUsingHMA,0
        je      mvdx40

;
; Our extended memory block is actually the HMA.  Enable A20 and do
; the move ourselves.
;

        xmssvc  5                       ;local enable

        push    di
        push    ds
        push    es
        mov     cx,offset DXPMCODE:CodeEndPM
        inc     cx
        and     cx,0FFFEh
        mov     di,CBDXPMCODEOFF+10h
        xor     si,si
        dec     si
        mov     es,si
        inc     si
        mov     ds,dx
        assume  ds:NOTHING
;
; DS:SI = segIDT:0
; ES:DI = 0FFFF:CBDXPMCODEOFF+10h
; CX = code size
;
        cld
        rep     movsb
        pop     es
        assume  ds:DGROUP
        pop     ds
        pop     di

        xmssvc  6                       ;local disable

        jmp     mvdx65
mvdx40:
; Move the data up into extended memory using the XMS driver's function.

        mov     si,offset DGROUP:rgbXfrBuf0
        mov     cx,offset DXPMCODE:CodeEndPM
        inc     cx
        and     cx,0FFFEh
        mov     word ptr [si].cbxmsLen,cx
        mov     word ptr [si].oxmsSource+2,dx   ;real mode code segment address
        mov     ax,hmemDOSX
        mov     word ptr [si].hxmsDest,ax
        xor     ax,ax
        mov     word ptr [si].cbxmsLen+2,ax
        mov     [si].hxmsSource,ax
        mov     word ptr [si].oxmsSource,ax
        mov     word ptr [si].oxmsDest,CBDXPMCODEOFF
        mov     word ptr [si].oxmsDest+2,ax

        xmssvc  0Bh

mvdx65:
        clc
        jmp     short mvdx90

; Error occured

mvdx80: stc

mvdx90: pop     si
        pop     dx
        pop     cx
        pop     bx
        ret

MoveDosExtender endp


; -------------------------------------------------------
;   MoveDscrTables      -- This routine will move the GDT
;       and IDT up into extended memory.  The himem driver
;       function for moving memory blocks is used.  The parameter
;       block for this function is built in rgbXfrBuf0.
;
;   Input:  none
;   Output: none
;   Errors: returns CY set if error occurs.  Error code in AX
;   Uses:   AX, all else preserved
;           modifies rgbXfrBuf0

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  MoveDscrTables

MoveDscrTables  proc    near

        push    bx
        push    si
        push    es

        cmp     fUsingHMA,0
        je      @F

;
; Our extended memory block is actually the HMA.  Enable A20 and do
; the move ourselves.
;

        xmssvc  5                       ;local enable

        push    ds
        push    di
        push    cx

        mov     cx,CBTABLESIZE
        mov     di,10h
        xor     si,si
        dec     si
        mov     es,si
        inc     si
        mov     ds,segIDT
        assume  ds:NOTHING
;
; DS:SI = segIDT:0
; ES:DI = 0FFFF:10
; CX = tables size
;
        cld
        rep     movsb
        pop     cx
        pop     di
        pop     ds
        assume  ds:DGROUP

        xmssvc  6                       ;local disable

        clc
        jmp     mvdt_ret

@@:

; Move the GDT and IDT together.

        mov     si,offset DGROUP:rgbXfrBuf0

        mov     word ptr [si].cbxmsLen,CBTABLESIZE
        mov     word ptr [si].cbxmsLen+2,0
        mov     ax,segIDT
        mov     word ptr [si].oxmsSource+2,ax
        mov     ax,hmemDOSX
        mov     word ptr [si].hxmsDest,ax
        xor     ax,ax
        mov     [si].hxmsSource,ax
        mov     word ptr [si].oxmsSource,ax
        mov     word ptr [si].oxmsDest,ax
        mov     word ptr [si].oxmsDest+2,ax

        xmssvc  0Bh
IFDEF WOW
;
; Move the initialized selectors from the gdt to the ldt
;
        mov     word ptr [si].cbxmsLen,GDT_SIZE
        mov     word ptr [si].cbxmsLen+2,0
        mov     ax,segGDT
        mov     word ptr [si].oxmsSource+2,ax
        mov     ax,hmemDOSX
        mov     word ptr [si].hxmsDest,ax
        xor     ax,ax
        mov     word ptr [si].hxmsSource,ax
        mov     word ptr [si].oxmsSource,ax
        mov     word ptr [si].oxmsDest+2,ax
        mov     word ptr [si].oxmsDest,CBTABLESIZE + offset DXPMCODE:CodeEndPM

        xmssvc  0Bh
ENDIF

mvdt_ret:

        mov     es,segIDT                       ;free the low memory copy
        dossvc  49h

        pop     es
        pop     si
        pop     bx

        ret

MoveDscrTables  endp

; -------------------------------------------------------
; Send Debugger Notification

SendDbgNotification proc near
IFDEF WOW
;
; Send load notification to the debugger for DXDATA
;
        push    1                       ; data
        push    ds                      ; exe name
        push    offset EXEC_DXNAME
        push    ds                      ; module name
        push    offset szModName
        push    0
        push    SEL_DXDATA OR STD_RING
        push    DBG_SEGLOAD
        BOP     BOP_DEBUGGER
        add     sp,16
;
; Send load notification to the debugger for DXCODE
;
        push    0                       ; code
        push    ds                      ; exe name
        push    offset EXEC_DXNAME
        push    ds                      ; module name
        push    offset szModName
        push    1
        push    SEL_DXCODE OR STD_RING
        push    DBG_SEGLOAD
        BOP     BOP_DEBUGGER
        add     sp,16
;
; Send load notification to the debugger
;
        push    0                       ; code
        push    ds                      ; exe name
        push    offset EXEC_DXNAME
        push    ds                      ; module name
        push    offset szModName
        push    2
        push    SEL_DXPMCODE OR STD_RING
        push    DBG_SEGLOAD
        BOP     BOP_DEBUGGER
        add     sp,16
ENDIF
        ret
SendDbgNotification endp


; -------------------------------------------------------
;   InitGlobalDscrTable -- This function will allocate a memory
;       buffer from DOS and then initialize it as a global
;       descriptor table.  It will also initialize all global
;       variables associated with GDT management.
;       Descriptors in the range 0 - SEL_USER are given statically
;       defined meanings.  Descriptors from SEL_USER up are defined
;       dynamically when a program is loaded or when dynamic memory
;       management calls occur.
;
;   NOTE:   This routine works in real mode.  The buffer where
;           the GDT is built is in low memory.
;
;   Input:  AX      - number of descriptors to initialize
;   Output: none
;   Errors: CY set if unable to obtain memory for the GDT
;   Uses:   AX used, all other registers preserved
;           bpGDT initialized.

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitGlobalDscrTable

InitGlobalDscrTable     proc    near

        push    bx
        push    cx
        push    dx
        push    di
        push    es

        mov     word ptr [bpGDT+0],GDT_SIZE - 1
        mov     ax,word ptr lmaGDT
        mov     word ptr [bpGDT+2],ax
        mov     ax,word ptr lmaGDT+2
        mov     word ptr [bpGDT+4],ax
;
; Start by initializing the GDT to 0.
;
        mov     cx,GDT_SIZE shr 1
        mov     es,segGDT
        assume  es:NOTHING
        xor     ax,ax
        mov     di,ax
        rep     stosw

; Next, initialize the statically defined descriptors.
;
; Set up a descriptor for our protected mode code.

        xor     ax,ax                   ;AX = 0
        mov     dx,cs                   ;our code segment paragraph address
        call    B_ParaToLinear          ;convert to linear byte address
        mov     cx,offset CodeEnd
        cCall   NSetSegmentDscr,<SEL_DXCODE,bx,dx,ax,cx,STD_CODE>

; Set up another one, but ring 0 this time.  Limit should be 0FFFFh
; or 386 reset to real mode will not work properly.

        mov     cx,0FFFFh
        cCall   NSetSegmentDscr,<SEL_DXCODE0,bx,dx,ax,cx,ARB_CODE0>
;
; Set up one for the other segment, and a Ring 0 alias.
;
        mov     cx,offset CodeEndPM
        mov     bx,word ptr lmaDXPMCODE
        mov     dx,word ptr lmaDXPMCODE+2
        cCall   NSetSegmentDscr,<SEL_DXPMCODE,dx,bx,0,cx,STD_CODE>
        cCall   NSetSegmentDscr,<SEL_NBPMCODE,dx,bx,0,cx,STD_CODE>


ifndef WOW_x86
        cCall   NSetSegmentDscr,<SEL_EH,dx,bx,0,cx,EH_CODE>
else
        cCall   NSetSegmentDscr,<SEL_EH,dx,bx,0,cx,STD_CODE>
endif
        mov     cx,0FFFFh

; Set up a descriptor for our protected mode data and stack area.

        mov     dx,ds                   ;our data segment paragraph address
        call    B_ParaToLinear          ;convert to linear byte address
        cCall   NSetSegmentDscr,<SEL_DXDATA,bx,dx,ax,cx,STD_DATA>

IFNDEF WOW_x86
; Set up descriptor for IRET HOOKS
        push    dx
        push    bx
        add     dx,offset IretBopTable
        adc     bx,0
        cCall   NSetSegmentDscr,<SEL_IRETHOOK,bx,dx,ax,cx,STD_CODE>
        pop     bx
        pop     dx
ELSE
; Set up descriptor for IRET HOOKS
        push    dx
        push    bx
        add     dx,offset FastBop
        adc     bx,0
        cCall   NSetSegmentDscr,<SEL_IRETHOOK,bx,dx,ax,cx,STD_CODE>
        pop     bx
        pop     dx
ENDIF

IFNDEF WOW_x86
; And another one of those for ring 0

        cCall   NSetSegmentDscr,<SEL_DXDATA0,bx,dx,ax,cx,ARB_DATA0>
ENDIF
;
; Set up descriptors pointing to our PSP and environment.

        mov     dx,segPSP               ;segment address of the PSP
        call    B_ParaToLinear          ;convert to linear byte address
        cCall   NSetSegmentDscr,<SEL_PSP,bx,dx,ax,cx,STD_DATA>
        mov     selPSP,SEL_PSP
;
        push    es
        mov     es,segPSP
        assume  es:PSPSEG
        mov     dx,segEnviron
        call    B_ParaToLinear
        cCall   NSetSegmentDscr,<SEL_ENVIRON,bx,dx,ax,7FFFH,STD_DATA>
        pop     es
        assume  es:nothing

; Set up a descriptor that points to the GDT.

        mov     dx,word ptr [bpGDT+2]   ;get the GDT linear byte address
        mov     bx,word ptr [bpGDT+4]
        mov     cx,word ptr [bpGDT+0]    ;get the GDT segment size
        cCall   NSetSegmentDscr,<SEL_GDT,bx,dx,ax,cx,STD_DATA>


; Set up a descriptor for the LDT and an LDT data alias.

        mov     cx,cdscGDTMax           ;get count of descriptors
        shl     cx,3
        dec     cx
        mov     dx,word ptr lmaLDT
        mov     bx,word ptr lmaLDT+2
IFNDEF WOW_x86
        cCall   NSetSegmentDscr,<SEL_LDT,bx,dx,ax,cx,STD_LDT>
ENDIF
        cCall   NSetSegmentDscr,<SEL_LDT_ALIAS,bx,dx,ax,cx,STD_DATA>

        ; set up a readonly selector to the LDT for the wow kernel
        cCall   NSetSegmentDscr,<SEL_WOW_LDT,bx,dx,ax,cx,STD_DATA>

; Set up descriptors pointing to the BIOS code and data areas

        mov     cx,0FFFFH               ; CX = 0FFFFH
        cCall   NSetSegmentDscr,<SEL_BIOSCODE,000fh,ax,ax,cx,STD_CODE>

        mov     dx,40h*16
        cCall   NSetSegmentDscr,<SEL_BIOSDATA,ax,dx,ax,cx,STD_DATA>

; Set up a descriptor pointing to the real mode interrupt vector table.

        cCall   NSetSegmentDscr,<SEL_RMIVT,ax,ax,ax,cx,STD_DATA>

IFNDEF WOW_x86
; Setup a selector and data alias for the TSS

        mov     dx,ds                           ;get base address of TSS
        call    B_ParaToLinear                  ;  (it may not be para aligned)
        add     dx,offset DGROUP:sysTSS
        adc     bx,ax

        mov     cx,(TYPE TSS286) - 1
        cCall   NSetSegmentDscr,<SEL_TSS,bx,dx,ax,cx,STD_TSS>
        cCall   NSetSegmentDscr,<SEL_TSS_ALIAS,bx,dx,ax,cx,STD_DATA>

ENDIF

;
;       Pass address of HwIntr stack, and form pointer to lockcount in
;       VdmTib. This enables us to coordinate stack switching with
;       the nt kernel and the monitor. These components will switch
;       the stack on Hw Interrupt reflection, dosx will switch it
;       back at iret.
;

        push    es
        mov     ax,SEL_DXDATA or STD_RING
        mov     es, ax
        mov     bx, pbHwIntrStack
        DPMIBOP InitPmStackInfo
        pop     es

IFDEF WOW_x86
;
;       Create a code selector for the NPX emulation exception handler
;
        mov     ax,offset EndNpxExceptionHandler
        sub     ax,offset NpxExceptionHandler
        mov     bx,offset DXPMCODE:NpxExceptionHandler
        add     bx,word ptr lmaDXPMCODE
        mov     dx,word ptr lmaDXPMCODE + 2
        cCall   NSetSegmentDscr,<SEL_NPXHDLR,dx,bx,0,ax,STD_CODE>
ENDIF

        clc                             ;worked! make sure CY is clear


; All done

igdt90: pop     es
        pop     di
        pop     dx
        pop     cx
        pop     bx
        ret

InitGlobalDscrTable     endp


; -------------------------------------------------------
;   InitIntrDscrTable   -- This function will initialize the
;       specified memory buffer as an Interrupt Descriptor Table,
;       and set up all of the control variables associated with
;       the IDT.
;
;   NOTE:   This routine works in real mode.  The buffer where
;           the IDT is built is in low memory.
;   NOTE:   The InitGlobalDscrTable function must be called before
;           this function can be called.
;
;   Input:  AX      - number of descriptors to initialize
;   Output: none
;   Errors: CY set if unable to obtain the memory required
;   Uses:   AX, all other registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitIntrDscrTable

InitIntrDscrTable  proc near

        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    es

ifndef WOW_x86
; Save the current pointer to the real mode interrupt vector table.

        sidt    fword ptr bpRmIVT
endif
        mov     es,selIDT
        assume  es:NOTHING

        mov     cx,256              ;number of descriptors in table
        shl     cx,3                ;convert to count of bytes
        dec     cx                  ;compute segment size limit

        mov     word ptr [bpIDT+0],cx
        mov     dx,word ptr lmaIDT
        mov     word ptr [bpIDT+2],dx
        mov     bx,word ptr lmaIDT+2
        mov     word ptr [bpIDT+4],bx
        cCall   NSetSegmentDscr,<SEL_IDT,bx,dx,0,cx,STD_DATA>

; Fill the IDT with interrupt gates that point to the fault handler and
; interrupt reflector entry vector.

        xor     di,di

        mov     dx,offset DXPMCODE:PmIntrEntryVector
        mov     cx,256
iidt23: mov     es:[di].offDest,dx
        mov     es:[di].selDest,SEL_DXPMCODE or STD_RING
        mov     es:[di].cwParam,0
        mov     es:[di].arbGate,STD_TRAP   ; BUGBUG- int gates not set up
        mov     es:[di].rsvdGate,0
        add     dx,5
        add     di,8
        loop    iidt23

; Now, fix up the ones that don't point to the interrupt reflector.

; BUGBUG In dxstrt.asm, these are x86 ONLY.
        mov     es:[1h*8].offDest,offset PMIntrIgnore
        mov     es:[3h*8].offDest,offset PMIntrIgnore
ifdef      NEC_98                                          ;
        mov     es:[11h*8].offDest,offset PMIntr11dummy
        mov     es:[18h*8].offDest,offset PMIntrVideo
        mov     es:[1ah*8].offDest,offset PMIntrPrinter
        mov     es:[1bh*8].offDest,offset PMIntr13
        mov     es:[1ch*8].offDest,offset PMIntrCalTi
        mov     es:[1dh*8].offDest,offset PMIntrGraph
        mov     es:[1fh*8].offDest,offset PMIntrMisc
else    ;NEC_98                                         ;
        mov     es:[10h*8].offDest,offset PMIntrVideo
        mov     es:[13h*8].offDest,offset PMIntr13
        mov     es:[15h*8].offDest,offset PMIntrMisc
        mov     es:[19h*8].offDest,offset PMIntr19
endif   ;NEC_98                                         ;

        mov     es:[21h*8].offDest,offset DXPMCODE:PMIntrDos
        mov     es:[25h*8].offDest,offset DXPMCODE:PMIntr25
        mov     es:[26h*8].offDest,offset DXPMCODE:PMIntr26
        mov     es:[28h*8].offDest,offset DXPMCODE:PMIntr28
        mov     es:[30h*8].offDest,offset DXPMCODE:PMIntrIgnore
        mov     es:[31h*8].offDest,offset DXPMCODE:PMIntr31
        mov     es:[33h*8].offDest,offset DXPMCODE:PMIntrMouse
        mov     es:[41h*8].offDest,offset DXPMCODE:PMIntrIgnore

ifndef WOW_x86
        mov     es:[4Bh*8].offDest,offset DXPMCODE:PMIntr4B
ifdef      NEC_98    ;
;  Sound BIOS Int D2h handler
        mov     es:[0D2h*8].offDest,offset DXPMCODE:PMIntrSound

;  Extended DOS Int DCh handler (KANA/KANJI)
        mov     es:[0DCh*8].offDest,offset DXPMCODE:PMIntrExDos
endif   ;NEC_98   ;
endif

;
; Set up the IDT, and dpmi32 state
;
        mov     ax,es                   ; Idt selector
        mov     bx,VDM_INT_16
        DPMIBOP InitIDT

        mov     ax,5                    ; handler increment
        mov     cx,SEL_DXPMCODE OR STD_RING
        mov     dx,offset DXPMCODE:PmFaultEntryVector

        DPMIBOP InitExceptionHandlers


        .286p
; All done

iidt90: pop     es
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        ret

InitIntrDscrTable endp

; -------------------------------------------------------
;
;   InitTaskStateSeg    -- This function initializes the
;       TSS for the DOS Extender.
;
;   Input:  none
;   Output: none
;   Errors: returns CY if unable to allocate memory
;   Uses:   all registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitTaskStateSeg

InitTaskStateSeg  proc  near

        push    ax
        push    cx
        push    di

; As a start, zero out the TSS

        xor     al,al
        mov     cx,type TSS286
        mov     di,offset DGROUP:sysTSS
        rep stosb

; Set the LDT selector

        mov     sysTSS.tss_ldt,SEL_LDT

; Set the ring 0 stack seg/pointer, we don't bother to set the others
; since nothing runs below DOSX's ring.  Currently very little code runs
; ring 0 - just when switching between real/proteted modes.

        mov     sysTSS.tss_ss0,SEL_DXDATA0
        mov     sysTSS.tss_sp0,offset DGROUP:ResetStack

; That's all it takes

        pop     di
        pop     cx
        pop     ax

        clc
        ret

InitTaskStateSeg  endp

; -------------------------------------------------------
;               MISC. STARTUP ROUTINES
; -------------------------------------------------------

; *** CheckCPUType - Set global variable for CPU type
;
;       This routine relies on Intel-approved code that takes advantage
;       of the documented behavior of the high nibble of the flag word
;       in the REAL MODE of the various processors.  The MSB (bit 15)
;       is always a one on the 8086 and 8088 and a zero on the 286 and
;       386.  Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are
;       always zero on the 286, but can be set on the 386.
;
;       For future compatibility of this test, it is strongly recommended
;       that this specific instruction sequence be used.  The exit codes
;       can of course be changed to fit a particular need.
;
;       CALLABLE FROM REAL MODE ONLY
;
;       ENTRY:  NONE
;
;       EXIT:   AX holds CPU type ( 0=8086,80186; 2=80286; 3=80386; 4=80486 )
;
;       USES:   AX, DS must point to DX data segment
;               idCpuType initialized
;
;       Modified: 07-31-90 Earleh added code from Kernel, originally
;               supplied by Intel, to check for 80486.  Added check
;               for V86 mode just in case a Limulator or something
;               is active.
;
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  CheckCPUType

CheckCPUType    proc  near

.8086

        pushf                           ; save flags during cpu test

        pushf
        pop     ax                      ; flags to ax

        and     ax, 0fffh               ; clear bits 12-15

        push    ax                      ; push immediate is bad op-code on 8086
        npopf                           ; try to put that in the flags

        pushf
        pop     ax                      ; look at what really went into flags

        and     ah,0f0h                 ; mask off high flag bits
        cmp     ah,0f0h                 ; Q: was high nibble all ones ?
        mov     ax, 0
        jz      cidx                    ;   Y: 8086
.286p
        smsw    ax
        test    ax,1                    ; Protected mode?
        jnz     cid386                  ; V86!  Gotta be at least a 386.

        push    0f000h                  ;   N: try to set the high bits
        npopf                           ;      ... in the flags

        pushf
        pop     ax                      ; look at actual flags

        and     ah,0f0h                 ; Q: any high bits set ?
        mov     ax, 2                   ; at least 286
        jz      cidx                    ;   N: 80286 - exit w/ Z flag set
                                        ;   Y: 80386 - Z flag reset

; 386 or 486? See if we can set the AC (Alignment check) bit in Eflags
;   Need to insure stack is DWORD aligned for this to work properly

.386
cid386:
        mov     ax, 3

        push    cx
        push    ebx

        mov     cx,sp                   ; Assume stack aligned
        and     cx,0011b                ; set "pop" count
        sub     sp,cx                   ; Move to DWORD aligned
        pushfd                          ; save entry flags (DWORD)
        push    dword ptr 40000h        ; AC bit
        popfd
        pushfd
        pop     ebx
        popfd                           ; Recover entry flags (DWORD)
        add     sp,cx                   ; pop off alignment bytes
        test    ebx,40000h              ; Did AC bit set?

        pop     ebx
        pop     cx

        jz      short cidx              ; No, 386
.286p
        inc     ax                      ; At least 80486...

cidx:
        mov     idCpuType,ax            ;store CPU type in global
        npopf                           ; restore flags after cpu test

CheckCPUType    endp

; -------------------------------------------------------
;   B_ParaToLinear
;
;   This function will convert a paragraph address in the lower
;   megabyte of memory space into a linear address for use in
;   a descriptor table.  This is a local duplicate of the function
;   ParaToLinear in DXUTIL.ASM.  This is duplicated here to avoid
;   having to make far calls to it during the initialization.
;
;   Input:  DX      - paragraph address
;   Output: DX      - lower word of linear address
;           BX     - high word of linear address
;   Errors: none
;   Uses:   DX, BX used, all else preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

B_ParaToLinear  proc  near

        xor     bh,bh
        mov     bl,dh
        shr     bl,4
        shl     dx,4
        ret

B_ParaToLinear  endp


if DEBUG        ;-------------------------------------------------------

; -------------------------------------------------------
;   CheckDOSXFixUps -- This routine will check for segment fix ups
;       in non-initialization code that need to be converted from
;       a segment to selector.
;
;       This routine works by opening the EXE file that we were
;       loaded from and examining the relocation table.
;
;       10-09-90 Earleh modified so that references in initialization
;       code are not edited.
;
;       11-12-90 JimMat renamed from RelocateDosExtender and it now
;       only checks for fix ups in DEBUG version since all fix ups
;       in post-initialization code have been removed.
;
;   Input:  none
;   Output: none
;   Errors: returns CY set if error occurs
;   Uses:   AX, all else preserved
;           modifies lpchFileName

        assume  ds:DGROUP,es:NOTHING,ss:DGROUP
        public  CheckDOSXFixUps

CheckDOSXFixUps proc    near

        push    bp
        mov     bp,sp
        push    bx
        push    dx
        push    si
        push    di
        push    es

; Find the path to our exe fie.

        mov     word ptr [lpchFileName],offset EXEC_DXNAME
        mov     word ptr [lpchFileName+2],ds

; Set up for reading the relocation table from the exe file.

        call    B_InitRelocBuffer
        jc      rldx90              ;get out if error

; Go down through the relocation table and for each fixup item,
; patch in our selector.

        mov     bx,segPSP
        add     bx,10h          ;the relocation table items are relative
                                ; to the initial load address of our program
                                ; image which is immediately after the PSP

rldx40: call    B_GetRelocationItem   ;get next relocation table entry
        jz      rldx60          ;if end of table, get out
        mov     di,ax           ;offset of relocation item
        add     dx,bx           ;adjust relocation item segment for our load
                                ; address
        mov     es,dx           ;

;
; Do not fixup instructions in initialization code.
;
        cmp     dx,seg DXCODE
        jne     rldx41
        cmp     di,offset DXCODE:CodeEnd
        jnc     rldx40
rldx41:
        cmp     dx,seg DXPMCODE
        jne     rldx42
        cmp     di,offset DXPMCODE:CodeEndPM
        jnc     rldx40
rldx42:

        mov     ax,es:[di]      ;get the current fixup contents
        cmp     ax,seg DXCODE   ;is it the mixed mode segment?
        jnz     rldx44

        extrn   lCodeSegLoc:WORD
        cmp     di,offset DXCODE:lCodeSegLoc    ;special far jmp to flush
        jz      rldx40                          ;  pre-fetch queue?  ok if so.

; Shouldn't get here--tell developer he messed something up!

        int     3       ;****************************************

        mov     word ptr es:[di],SEL_DXCODE or STD_RING
        jmp     short rldx40

rldx44: cmp     ax,seg DXPMCODE   ;is it the protected mode only segment
        jnz     rldx40

; Shouldn't get here--tell developer he messed something up!

        int     3       ;****************************************

        mov     word ptr es:[di],SEL_DXPMCODE or STD_RING
        jmp     rldx40          ;and repeat for the next one

; We have gone through the entire relocation table, so close up the exe file

rldx60: mov     bx,fhExeFile
        dossvc  3Eh
;
        clc
        jmp     short rldx90
;
; Error occured
rldx80: stc
;
; All done
rldx90: pop     es
        pop     di
        pop     si
        pop     dx
        pop     bx
        mov     sp,bp
        pop     bp
        ret

CheckDOSXFixUps endp


; -------------------------------------------------------
;   B_InitRelocBuffer     -- This routine will open the EXE
;       file and initialize for reading the relocation table
;       as part of relocating the program for protected mode
;       execution.
;
;   Input:  lpchFileName    - pointer to exe file name
;   Output: none
;   Errors: returns CY set if error occurs
;   Uses:   AX modified, all other registers preserved
;           sets up static variables:
;               clpRelocItem, plpRelocItem, fhExeFile
;           modifies rgbXfrBuf1 at offset RELOC_BUFFER

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  B_InitRelocBuffer

B_InitRelocBuffer  proc  near

        push    bx
        push    cx
        push    dx
        push    si
;
; Open the EXE file.
        push    ds
        lds     dx,lpchFileName
        mov     al,0
        dossvc  3Dh             ;attempt to open the exe file
        pop     ds
        jc      inrl80          ;get out if error occurs
;
        mov     fhExeFile,ax    ;store the file handle
        mov     bx,ax           ;file handle to BX also

; Read the EXE file header, so that we can get information about
; the relocation table.
        mov     dx,offset RELOC_BUFFER
        mov     si,dx
        mov     cx,32
        dossvc  3Fh
        jc      inrl80          ;get out if error
        cmp     ax,32
        jnz     inrl80
;
; Get the important values from the exe file header.
        cmp     [si].idExeFile,5A4Dh    ;make sure it is an EXE file
        jnz     inrl80

        mov     ax,[si].clpRelocLen ;number of relocation items
        mov     clpRelocItem,ax
        mov     plpRelocItem,0FFFFh ;init the pointer to the first one
                                    ; to a bogus value to force the initial
                                    ; buffer to be loaded
;
; Get the location of the relocation table, and move the file pointer
; to its start.

        xor     cx,cx
        mov     dx,[si].wRelocOffset

        mov     al,cl
        dossvc  42h
        jnc     inrl90
;
; Error occured
inrl80: stc
;
; All done
inrl90: pop     si
        pop     dx
        pop     cx
        pop     bx
        ret

B_InitRelocBuffer  endp


; -------------------------------------------------------
;   B_GetRelocationItem   -- This routine will return the next
;       relocation table entry from the exe file being relocated.
;
;   Input:  none
;   Output: AX      - offset of relocation item pointer
;           DX      - segment of relocation item pointer
;   Errors: returns ZR true if end of table and no more items
;   Uses:   AX, DX modified, all other registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  B_GetRelocationItem

B_GetRelocationItem  proc  near

        push    si
;
        cmp     clpRelocItem,0  ;are there any relocation items left?
        jz      gtrl90          ;get out if not
;
; Check if the buffer is empty.  The buffer for the relocation table is
; at offset RELOC_BUFFER in the buffer rgbXfrBuf1, and is 512 bytes long.
        cmp     plpRelocItem,offset RELOC_BUFFER + 512
        jc      gtrl40
;
; The buffer is empty, so we need to read the next part of it in.
        push    cx
        push    bx
        push    dx
        mov     ax,clpRelocItem ;number of items left in file
        shl     ax,2            ;multiply by size of relocation item
        jc      gtrl22          ;check for overflow
        cmp     ax,512          ;check if bigger than the buffer
        jc      gtrl24
gtrl22: mov     ax,512          ;use buffer size as size of transfer
gtrl24: mov     cx,ax
        mov     dx,offset RELOC_BUFFER
        mov     plpRelocItem,dx ;pointer to next reloc item to return
        mov     bx,fhExeFile
        dossvc  3Fh
        pop     dx
        pop     bx
        jc      gtrl28          ;if error occured
        cmp     ax,cx           ;or, if we didn't get as much as we asked
        jnz     gtrl28          ; for, we have an error
        pop     cx
        jmp     short gtrl40
;
gtrl28: pop     cx
        stc
        jmp     short gtrl90
;
; Get the next relocation item from the buffer.
gtrl40: mov     si,plpRelocItem
        lods    word ptr [si]   ;get the offset part of the reloc item
        mov     dx,ax
        lods    word ptr [si]   ;get the segment part of the reloc item
        xchg    dx,ax           ;put offset in AX, and segment in DX
        mov     plpRelocItem,si ;store the updated pointer
        dec     clpRelocItem    ;and bump the count down by 1
        or      si,si           ;clear the zero flag
;
; All done.
gtrl90: pop     si
        ret

B_GetRelocationItem  endp

endif   ;DEBUG  --------------------------------------------------------


; -------------------------------------------------------
;   GetExeName  -- This routine will put a copy of the complete
;       path name to the dos extender's exe file.  In a name
;       buffer in rgbXfrBuf1.
;
;   Input:  none
;   Output: EXEC_DXNAME buffer updated with complete pathname.
;   Errors: returns CY set if environment not correctly built.
;   Uses:   all preserved

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  GetExeName

GetExeName proc near

        push    ax
        push    si
        push    di
        push    ds

; The name of the current program is stored at the end of the environment
; table.  There are two bytes of 0 to indicate end of table, a byte
; with a 1 in it followed by another byte of 0 and then the null terminated
; string with the current program name.

gtxe20: mov     ds,segPSP
        assume  ds:PSPSEG
        mov     ds,segEnviron
        assume  ds:NOTHING
        xor     si,si
gtxe22: lods    byte ptr [si]       ;get next byte from environment
        or      al,al               ;test if 0
        jnz     gtxe22              ;if not, keep looking
        lods    byte ptr [si]       ;get next byte
        or      al,al               ;see if it is 0 also
        jnz     gtxe22

; We have found the double 0 at the end of the environment.  So
; we can now get the name.  At the end of the environment is an
; argc, argv construct.  (i.e. a word giving the count of strings
; followed by an array of strings).  Under DOS, argc is always 1,
; so check that there is a word of 1 here.  If not, this environment
; wasn't built correctly and we don't know what is here.

        lods    word ptr [si]
        cmp     ax,1
        jnz     gtxe80


; We have the pointer to the name, now copy it.

        mov     di,offset EXEC_DXNAME
        call    strcpy
        clc
        jmp     short gtxe90

; We have an error.

gtxe80: stc                         ;set error condition flag

gtxe90: pop     ds
        pop     di
        pop     si
        pop     ax
        ret

GetExeName endp


; -------------------------------------------------------
;           COMMAND LINE PARSING ROUTINES
; -------------------------------------------------------
;   ParseCommandLine    -- This function will examine the dos
;       command line that caused the Dos Extender to be exec'd
;       and determine what the user wants done.  It will set
;       up the various buffers required for the child program
;       to be loaded.
;
;       NOTE: the child exe file name read from the command line
;       is placed in RELOC_BUFFER in the case where the child
;       name is specified on the command line.  This buffer is
;       used later when reading the relocation table while
;       performing the fixups on the child.
;
;   Input:  none
;   Output: AL      - 0 if empty command line, else non-zero
;           parse buffers in rgbXfrBuf1 set up.
;   Errors: none
;   Uses:   AX, all else preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  ParseCommandLine

ParseCommandLine proc near

        push    si
        push    di
        push    ds

        mov     ds,segPSP
        assume  ds:PSPSEG
        mov     si,81h          ;pointer to command line in PSP

; Skip any white space in front of the child program name.

prsc12: lods    byte ptr [si]
        cmp     al,' '
        jz      prsc12

        dec     si

; Copy the command line tail following the program name to the command
; line buffer for use when we load the child.

prsc40: push    si              ;save current point in parse
        mov     di,offset EXEC_CMNDLINE + 1
        xor     dl,dl           ;count characters in command line tail
prsc42: lods    byte ptr [si]   ;get the next character
        stos    byte ptr [di]   ;store it into the output buffer
        cmp     al,0Dh          ;is it the end of the line?
        jz      prsc44
        inc     dl              ;count the character
        jmp     prsc42

prsc44: mov     es:[EXEC_CMNDLINE],dl   ;store the character count
        pop     si              ;restore the buffer pointer

; Now we want to set up the two default FCB's by letting DOS parse the
; first two parameters on the command line.

        mov     di,offset EXEC_FCB0
        mov     al,1
        dossvc  29h
        mov     di,offset EXEC_FCB1
        mov     al,1
        dossvc  29h

prsc90:
        pop     ds
        pop     di
        pop     si
        ret

ParseCommandLine endp


; -------------------------------------------------------
;   strcpy      -- copy a null terminated string.
;
;   Input:  DS:SI       - pointer to source string
;           ES:DI       - pointer to destination buffer
;   Output: ES:DI       - pointer to end of destination string
;   Errors: none
;   Uses:   DI modified, all else preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  strcpy

strcpy  proc   near

        push    ax
        push    si
stcp10: lods    byte ptr [si]
        stos    byte ptr [di]
        or      al,al
        jnz     stcp10
        dec     di
        pop     si
        pop     ax
        ret

strcpy  endp


; -------------------------------------------------------
;   strcmpi     -- This function will perform a case insensitive
;       comparison of two null terminated strings.
;
;   Input:  DS:SI       -   string 1
;           ES:DI       -   string 2
;   Output: ZR if the strings match, else NZ
;           CY set if string 1 less than string 2
;   Errors: none
;   Uses:   all registers preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  strcmpi

strcmpi proc    near

        push    si
        push    di
stcm20: mov     al,byte ptr ds:[si]
        call    toupper
        mov     ah,al
        mov     al,byte ptr es:[di]
        call    toupper
        cmp     ah,al
        jnz     stcm90
        or      al,ah
        jz      stcm90
        inc     si
        inc     di
        jmp     stcm20
stcm90: pop     di
        pop     si
        ret

strcmpi endp


; -------------------------------------------------------
;   IsFileNameChar      -- This function will examine the
;       character in AL and determine if it is a legal character
;       in an MS-DOS file name.
;
;   Input:  AL      - character to test
;   Output: ZR true if character is legal in a file name
;   Errors: none
;   Uses:   all registers preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

IsFileNameChar  proc    near

        push    ax
        cmp     al,20h          ;is it a control character
        jbe     isfc80          ;if so, it isn't valid

        cmp     al,':'
        jz      isfc80
        cmp     al,';'
        jz      isfc80
        cmp     al,','
        jz      isfc80
        cmp     al,'='
        jz      isfc80
        cmp     al,'+'
        jz      isfc80
        cmp     al,'<'
        jz      isfc80
        cmp     al,'>'
        jz      isfc80
        cmp     al,'|'
        jz      isfc80
        cmp     al,'/'
        jz      isfc80
        cmp     al,'"'
        jz      isfc80
        cmp     al,'['
        jz      isfc80
        cmp     al,']'
        jz      isfc80

        xor     al,al
        jmp     short isfc90

; Not a valid file name character

isfc80: or      al,0FFh

isfc90: pop     ax
        ret

IsFileNameChar  endp


; -------------------------------------------------------
;   toupper   -- This function will convert the character
;       in AL into upper case.
;
;   Input:  AL      - character to convert
;   Output: AL      - upper case character
;   Errors: none
;   Uses:   AL modified, all else preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  toupper

toupper proc    near

        cmp     al,'a'
        jb      toup90
        cmp     al,'z'
        ja      toup90
        sub     al,'a'-'A'
toup90:
        ret

toupper endp

; -------------------------------------------------------

DXCODE  ends

;
;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxdisk.asm ===
PAGE    ,132
        TITLE   DXDISK.ASM  -- Dos Extender Low Level Disk Interface

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;***********************************************************************
;
;       DXDISK.ASM      -- Dos Extender Low Level Disk Interface
;
;-----------------------------------------------------------------------
;
; This module provides the 286 DOS extender's low level protected-to-
; real mode disk interface.  It supports a subset of the BIOS Int 13h
; and DOS Int 25h/26h services.
;
;-----------------------------------------------------------------------
;
;  05/22/89 jimmat  Original version
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include interupt.inc
include intmac.inc

        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterIntHandler:NEAR
        extrn   LeaveIntHandler:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   GetSegmentAddress:NEAR
        extrn   SetSegmentAddress:NEAR
externFP        NSetSegmentDscr
        extrn   FreeSelector:NEAR
        extrn   AllocateSelector:NEAR
        extrn   ParaToLDTSelector:NEAR

ifdef     NEC_98    ;
        extrn   IncInBios:NEAR          ; 
        extrn   DecInBios:NEAR          ;
endif  ;NEC_98   ;

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   rgbXfrBuf0:BYTE
        extrn   rgbXfrBuf1:BYTE
ifdef    NEC_98
        extrn   rglpfnRmISR:DWORD
endif

cbSectorSize            dw      ?       ;sector size for target drive
cSectorsTransfered      dw      ?       ;# sectors transfered so far
cSectorsToTransfer      dw      ?       ;# sectors to read/write
cSectorsPerTransfer     dw      ?       ;# sectors to R/W at a time
cSectorsThisTransfer    dw      ?       ;# sectors to R/W this time
lpSectorData            dd      ?       ;far pointer to caller's buffer

ifdef      NEC_98    ;
public  lpRmISR
endif   ;NEC_98   ;
lpRmISR                 dd      ?       ;real mode int service rtn to invoke

ifdef      NEC_98    ;
sensedata1              dw      ?       ;sector length
sensedata2              dw      ?       ;cylinder
sensedata3              dd      ?       ;head
sensedata4              dd      ?       ;sector num

        extrn   fPCH98:BYTE     ;for PC_H98
endif   ;NEC_98   ;
DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

DXCODE  ends


DXPMCODE segment

        extrn   segDXDataPM:WORD

DXPMCODE ends


; -------------------------------------------------------
        subttl  INT 13h Mapping Services
        page
; -------------------------------------------------------
;             INT 13h MAPPING SERVICES
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr13 -- Service routine for the Protect Mode INT 13h
;       interface to the real mode BIOS.
;
;   Input:  Various registers
;   Output: Various registers
;   Errors:
;   Uses:   All registers preserved, other than return values
;
;   Currently, the following Int 13h services are supported:
;
;   ah= 0 - Reset Disk System                   (no mapping required)
;       1 - Get Disk System Status              (no mapping required)
;       2 - Read Sector                         (mapping required)
;       3 - Write Sector                        (mapping required)
;       4 - Verify Sector                       (mapping required)
;       5 - Fromat Track                        (mapping required)
;       6 - Format Bad Track                    (no mapping required)
;       7 - Format Drive                        (no mapping required)
;       8 - Get Drive Parameters                (mapping required)
;       9 - Init Fixed Disk Characteristics     (no mapping required)
;       C - Seek                                (no mapping required)
;       D - Reset Disk System                   (no mapping required)
;      10 - Get Drive Status                    (no mapping required)
;      11 - Recalibrate Drive                   (no mapping required)
;      12 - Controller RAM Diagnostic           (no mapping required)
;      13 - Controller Drive Diagnostic         (no mapping required)
;      14 - Controller Internal Diagnostic      (no mapping required)
;      15 - Get Disk Type                       (no mapping required)
;      16 - Get Disk Change Status              (no mapping required)
;      17 - Set Disk Type                       (no mapping required)
;      18 - Set Media Type for Format           (mapping required)
;      19 - Park Heads                          (no mapping required)
;
;   Functions not listed above will most likely not work properly!
;
;   NOTE: several functions take 2 bits of the cylinder number in CL
;         if the operation is on a fixed disk.  The code currently does
;         not account for these bits, and may not work properly if
;         the request must be split into smaller operations for real/
;         extended memory buffering.
;

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr13

PMIntr13        proc    near

ifdef      NEC_98    ;
        call    IncInBios               ; 
endif   ;NEC_98   ;
        cld                             ;cya...

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        FSTI                             ;allow HW interrupts

        call    IntEntry13              ;perform translations/buffering

; Execute the real mode BIOS routine
ifdef      NEC_98    ;
        push    es
        assume es:nothing
        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        mov     ax,word ptr es:[4*1bh]  ;move real mode Int 13h
        mov     word ptr [bp].lParam,ax         ;  handler address to
        mov     ax,word ptr es:[4*1bh+2];  lParam on stack frame
        mov     word ptr [bp].lParam+2,ax
        pop     es
        assume es:DGROUP

        mov     ah,1bh                          ;wParam1 = int #, function
else    ;NEC_98   ;

        push    es
        assume es:nothing
        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        mov     ax,word ptr es:[4*13h]  ;move real mode Int 13h
        mov     word ptr [bp].lParam,ax         ;  handler address to
        mov     ax,word ptr es:[4*13h+2];  lParam on stack frame
        mov     word ptr [bp].lParam+2,ax
        pop     es
        assume es:DGROUP

        mov     ah,13h                          ;wParam1 = int #, function
endif   ;NEC_98   ;
        mov     al,byte ptr [bp].intUserAX+1
        mov     [bp].wParam1,ax

ifdef      NEC_98    ;
        and     al,0fh
        cmp     al,05           ;write data?
        jb      i13_not_rw
        cmp     al,06           ;read data?
        ja      i13_not_rw
else    ;NEC_98   ;
        cmp     al,02                   ;call special read/write routine
        jb      i13_not_rw              ;  if this is a read/write sectors
        cmp     al,03                   ;  request
        ja      i13_not_rw
endif   ;NEC_98   ;

        call    ReadWriteSectors        ;common Int 13h/25h/26h read/write code
        jmp     short i13_done

i13_not_rw:
        SwitchToRealMode                ;otherwise, do the service ourself
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset i13_10)
ifdef      NEC_98    ;
        mov     ax,es:[1Bh*4]
        mov     [bp + 2],ax
        mov     ax,es:[1Bh*4 + 2]
else    ;NEC_98   ;
        mov     ax,es:[13h*4]
        mov     [bp + 2],ax
        mov     ax,es:[13h*4 + 2]
endif   ;NEC_98   ;
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

i13_10: pushf
        FCLI
        pusha
        push    ds
        push    es
        mov     bp,sp                   ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI                             ;allow HW interrupts

; Perform fixups on the return register values.

i13_done:
        mov     ax,[bp].pmUserAX        ;get original function code
        call    IntExit13

        FCLI                             ;LeaveIntHandler requires ints off
        call    LeaveIntHandler         ;restore caller's registers, stack
        assume  ds:NOTHING,es:NOTHING

ifdef      NEC_98    ;
        call    DecInBios               ; 
endif   ;NEC_98   ;
        riret

PMIntr13        endp


; -------------------------------------------------------
;  IntEntry13 -- This routine performs translations and
;       buffering of Int 13h requests on entry.
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntry13

IntEntry13      proc    near

ifdef      NEC_98    ;
        and     ah,0fh

        cmp     ah,05                   ;Write sectors? 
        jb      @f
        cmp     ah,06                   ;Read sectors?  
        ja      @f

;----------- 90/08/13  copy segment address from ds -------
        push    ax                      
        mov     ax,segDXDataPM
        mov     [bp].intUserES,ax       ;segment address
        pop     ax
;------------------------------------------------------------
        mov     [bp].intUserBP,offset DGROUP:rgbXfrBuf1 ;use DOSX buffer 90/07/13 
        ret
@@:
        cmp     ah,01h                  ;Verify sectors? 
        jnz     @f

        mov     [bp].intUserES,0F000h   ;older versions of verify need a buff,
        mov     [bp].intUserBP,0        ; offset adress 90/07/12  change
        ret
@@:
        cmp     ah,0Dh                  ;Format track? 
        jnz     @f

;------ 90/11/08  debug -----

        push    ds
        mov     si,[bp].pmUserBP        ;es:bx -> 512 byte buffer to copy down
        mov     ds,[bp].pmUserES
        mov     di,offset DGROUP:rgbXfrBuf1
        mov     cx,128                  ;might be good to check segment limit
        cld                             ;  on callers source!
        rep     movsw
        pop     ds
        
        push    ax                      
        mov     ax,segDXDataPM
        mov     [bp].intUserES,ax       ;segment address
        pop     ax
        mov     [bp].intUserBP,offset DGROUP:rgbXfrBuf1

        push    es
        pop     ds

        ret
@@:
;///// 90/09/04  PC_H98 DISK BIOS command(Read Defect Data) support/////
        test    fPCH98,0FFh
        jz      @f
        cmp     ah,0Ch
        jz      ReadDD
        cmp     ah,2Ch
        jz      ReadDD
        jmp     @f

ReadDD:
        push    ax
        mov     ax,segDXDataPM
        mov     [bp].intUserES,ax       ;segment address
        pop     ax
        mov     [bp].intUserBP,offset DGROUP:rgbXfrBuf1 ;use DOSX buffer 90/07/13 
;///// 90/09/04  PC_H98 DISK BIOS command(Read Defect Data) support/////

@@:
        ret

else    ;NEC_98   ;
        cmp     ah,02                   ;Read sectors?
        jb      @f
        cmp     ah,03                   ;Write sectors?
        ja      @f

        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 ;use DOSX buffer
        ret
@@:
        cmp     ah,04h                  ;Verify sectors?
        jnz     @f

        mov     [bp].intUserES,0F000h   ;older versions of verify need a buff,
        mov     [bp].intUserBX,0        ;  we just point them at the BIOS!
        ret
@@:
        cmp     ah,05h                  ;Format track?
        jnz     @f

        mov     si,bx                   ;es:bx -> 512 byte buffer to copy down
        mov     di,offset DGROUP:rgbXfrBuf1
        mov     [bp].intUserBX,di
        mov     ds,[bp].pmUserES
        mov     cx,256                  ;might be good to check segment limit
        cld                             ;  on callers source!
        rep movsw

        push    es
        pop     ds

        ret
@@:

        ret
endif   ;NEC_98   ;

IntEntry13      endp


; -------------------------------------------------------
;  IntExit13 -- This routine performs translations and
;       buffering of Int 13h requests on exit.
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExit13

IntExit13       proc    near

ifdef      NEC_98    ;
; Functions 06h (Read sectors) and 05h (Write sectors) return a count of
; sectors transfered in AL.  Since we may break the transfer up into a
; number of transfers, we have to return the total # that we transfered,
; not the number of the last bios request.

;----- 90/11/08 debug -----
        and     ah,0fh
;----- 90/11/08 debug -----

;----- 90/07/06 change -----
        cmp     ah,05h          ;Write data 
        jb      @f
        cmp     ah,06h          ;Read data 
        ja      @f

        mov     al,byte ptr cSectorsTransfered
        mov     byte ptr [bp].intUserAX,al
@@:

; Functions 06h (Read sectors), 05h (Write sectors), 01h (Verify sectors),
; and 0Dh (Format track) need to have the caller's value of bx restored.

;----- 90/07/06 change -----

        cmp     ah,01h                  ;Verify sectors? 
        je      @f
        cmp     ah,05h                  ;Write sectors? 
        je      @f
        cmp     ah,06h                  ;Read sectors? 
        je      @f
        cmp     ah,0Dh                  ;Format track? 
        jne     other
        
;offset adress 90/07/12 change
;----------- 90/08/13 copy segment address from ES -------
        mov     ax,[bp].pmUserES
        mov     [bp].intUserES,ax
;------------------------------------------------------------
@@:     mov     ax,[bp].pmUserBP        ;restore caller's BP value
        mov     [bp].intUserBP,ax
other:
        ret

else    ;NEC_98   ;
; Functions 02h (Read sectors) and 03h (Write sectors) return a count of
; sectors transfered in AL.  Since we may break the transfer up into a
; number of transfers, we have to return the total # that we transfered,
; not the number of the last bios request.

        cmp     ah,02h
        jb      @f
        cmp     ah,03h
        ja      @f

        mov     al,byte ptr cSectorsTransfered
        mov     byte ptr [bp].intUserAX,al
@@:

; Functions 02h (Read sectors), 03h (Write sectors), 04h (Verify sectors),
; and 05h (Format track) need to have the caller's value of bx restored.

        cmp     ah,02h                  ;Read sectors?
        jb      @f
        cmp     ah,05                   ;Format track?
        ja      @f

        mov     ax,[bp].pmUserBX        ;restore caller's BX value
        mov     [bp].intUserBX,ax
        ret
@@:

; Functions 08h (Get Drive Parameters) and 18h (Set Drive Type for Format)
; return a pointer in ES:DI.  Map the segment in ES to a selector

        cmp     ah,08h                  ;Get Drive Parameters
        jz      i13_map_es
        cmp     ah,18h
        jnz     @f

i13_map_es:
        test    byte ptr [bp].intUserFL,1       ;don't bother to map ES if
        jnz     @f                              ;  function failed (carry set)

i13_do_it:
        mov     ax,[bp].intUserES       ;returns a pointer in ES:DI, get
        mov     bx,STD_DATA             ;  a selector for it
        call    ParaToLDTSelector
        mov     [bp].pmUserES,ax
        ret
@@:

        ret
endif   ;NEC_98   ;

IntExit13       endp


; -------------------------------------------------------
        subttl  INT 25h/26h Absolute Disk Read/Write
        page
; -------------------------------------------------------
;        INT 25h/26h ABSOLUTE DISK READ/WRITE
; -------------------------------------------------------
;  PMIntr25 -- This routine provides the protected-to-real
;       mode mapping for Int 25h (Absolute Disk Read)
;
;       In:     al    - drive # (0 = A, 1 = B, ...)
;               cx    - # of sectors to read
;               dx    - starting sector #
;               ds:bx - selector:offset of buffer
;
;                        -- or --
;
;               al    - drive #
;               cx    - -1
;               ds:bx - pointer to 5 word parameter block
;
;       Out:    if successful, carry clear
;               if unsuccessful, carry set and
;                       ax - error code

        assume  ds:DGROUP,es:DGROUP
        public  PMIntr25

PMIntr25        proc    near

ifdef      NEC_98    ;
        call    IncInBios               ; 
endif   ;NEC_98   ;
        cld                             ;cya...

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        FSTI                             ;allow HW interrupts

        mov     ah,25h
        call    IntEntry2X              ;perform translations/buffering

; Do the read

        push    es
        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        assume  es:nothing
        mov     ax,word ptr es:[4*25h]  ;move real mode Int 25h
        mov     word ptr [bp].lParam,ax         ;  handler address to
        mov     ax,word ptr es:[4*25h+2];  lParam on stack frame
        mov     word ptr [bp].lParam+2,ax
        pop     es
        assume  es:DGROUP

        mov     ah,25h                          ;wParam1 = int #
        mov     [bp].wParam1,ax

        call    ReadWriteSectors        ;common Int 13h/25h/26h read/write code

; Perform fixups on the return register values.

        mov     ah,25h
        call    IntExit2X               ;perform translations/buffering

        FCLI
        call    LeaveIntHandler         ;restore caller's registers, stack
        assume  ds:NOTHING,es:NOTHING

; Int 25 & 26 leave the caller's flags on the stack, but we want to return
; with the flags returned by the real mode ISR (which LeaveIntHandler has
; incorporated into the caller's flags), so make a copy of the flags and
; pop them into the flags register before returning.

        push    ax
        push    bp
        mov     bp,sp                   ;bp -> BP  AX  IP  CS  FL
        mov     ax,[bp+8]
        xchg    ax,[bp+2]               ;bp -> BP  FL  IP  CS  FL
        pop     bp
ifdef      NEC_98    ;
        call    DecInBios               ; 
endif   ;NEC_98   ;
        npopf

        retf

PMIntr25        endp


; -------------------------------------------------------
;  PMIntr26 -- This routine provides the protected-to-real
;       mode mapping for Int 26h (Absolute Disk Write)
;
;       In:     al    - drive # (0 = A, 1 = B, ...)
;               cx    - # of sectors to write
;               dx    - starting sector #
;               ds:bx - selector:offset of buffer
;
;                        -- or --
;
;               al    - drive #
;               cx    - -1
;               ds:bx - pointer to 5 word parameter block
;
;       Out:    if successful, carry clear
;               if unsuccessful, carry set and
;                       ax - error code

        assume  ds:DGROUP,es:DGROUP
        public  PMIntr26

PMIntr26        proc    near

ifdef      NEC_98    ;
        call    IncInBios               ; 
endif   ;NEC_98   ;
        cld                             ;cya...

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        FSTI                             ;allow HW interrupts

        mov     ah,26h
        call    IntEntry2X              ;perform translations/buffering

; Do the write

        push    es
        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        assume  es:nothing
        mov     ax,word ptr es:[4*26h]  ;move real mode Int 25h
        mov     word ptr [bp].lParam,ax         ;  handler address to
        mov     ax,word ptr es:[4*26h+2];  lParam on stack frame
        mov     word ptr [bp].lParam+2,ax
        pop     es
        assume es:DGROUP

        mov     ah,26h                          ;wParam1 = int #
        mov     [bp].wParam1,ax

        call    ReadWriteSectors        ;common Int 13h/25h/26h read/write code

; Perform fixups on the return register values.

        mov     ah,26h
        call    IntExit2X               ;perform translations/buffering

        FCLI
        call    LeaveIntHandler         ;restore caller's registers, stack
        assume  ds:NOTHING,es:NOTHING

; Int 25 & 26 leave the caller's flags on the stack, but we want to return
; with the flags returned by the real mode ISR (which LeaveIntHandler has
; incorporated into the caller's flags), so make a copy of the flags and
; pop them into the flags register before returning.

        push    ax
        push    bp
        mov     bp,sp                   ;bp -> BP  AX  IP  CS  FL
        mov     ax,[bp+8]
        xchg    ax,[bp+2]               ;bp -> BP  FL  IP  CS  FL
        pop     bp
ifdef      NEC_98    ;
        call    DecInBios               ; 
endif   ;NEC_98   ;
        npopf

        retf

PMIntr26        endp


; -------------------------------------------------------
;  IntEntry2X -- This routine performs translations and
;       buffering of Int 25h and 26h requests on entry.
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntry2X

IntEntry2X      proc    near

        cmp     [bp].intUserCX,-1               ;DOS 4.0 extended read/write?
        jnz     e2x_dsbx                        ;  no, just go map DS:BX

        mov     ds,[bp].pmUserDS                ;  yes, copy down parameter blk
        assume  ds:NOTHING
        mov     si,[bp].pmUserBX
        mov     di,offset rgbXfrBuf0
        cld
        movsw                                   ;32-bit sector #
        movsw
        movsw                                   ;# sectors to read/write

        mov     ax,offset rgbXfrBuf1            ;replace pointer with addr of
        stosw                                   ;  our own low buffer
        mov     ax,segDXDataPM                  ;segment, not selector
        stosw

        push    es
        pop     ds
        assume  ds:DGROUP

        mov     [bp].intUserBX,offset rgbXfrBuf0

        ret

e2x_dsbx:                       ;standard read/write, just redirect DS:BX

        mov     [bp].intUserBX,offset rgbXfrBuf1

        ret

IntEntry2X      endp


; -------------------------------------------------------
;  IntExit2X -- This routine performs translations and
;       buffering of Int 25h and 26h requests on exit.
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExit2X

IntExit2X       proc    near


        mov     ax,[bp].pmUserBX                ;restore caller's BX
        mov     [bp].intUserBX,ax

        ret

IntExit2X       endp


; -------------------------------------------------------
        subttl  Disk Utility Routines
        page
; -------------------------------------------------------
;               DISK UTILITY ROUTINES
; -------------------------------------------------------
;  ReadWriteSectors -- Common code to read/write disk sectors for
;       Int 13h/25h/26h.
;
;       In:     lParam  - seg:off of real mode interrupt handler
;               wParam1 - int #, and possible subfunction
;               regs on stack


        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  ReadWriteSectors

ReadWriteSectors  proc  near

ifdef      NEC_98    ;
        pop     [bp].wParam2            ;save return addr higher on stack

; Setup the global data items for the read/write--pointer to caller's
; buffer, # sectors to read/write, and sector size.

        cmp     byte ptr [bp].wParam1+1,1Bh     ;Int 1Bh?
        jz      DISK_BIOS
        jmp     DOSReadWriteSectors
;;;;;;;;        jmp     rws_dos_size

DISK_BIOS:
;offset adress 90/07/12 change
        mov     ax,[bp].pmUserBP                ;ES:BP points to caller's buf  
        mov     word ptr lpSectorData,ax
        mov     ax,[bp].pmUserES
        mov     word ptr [lpSectorData+2],ax

;US:sector num, but :data length 90/07/13 

;-------------------------- 90/07/23 in ---------------------------
;       to adjust to US, we get a data with sense command on HDD,
;       and set a data with 1MB/640KB on FDD.
;----------------------------------------------------------------------
        mov     al,byte ptr [bp].intUserAX      ;
                                                ;
        push    ax
        and     al,10h                  ;DA:4th bit on :FDD
        pop     ax
        jnz     FDBIOS
        
        mov     ah,84h                  ;SENSE command

        push    ax
        SwitchToRealMode
        pop     ax

        pushf                           ;have BIOS get the drive data
        call    rglpfnRmISR[1Bh*4]      ;90/07/04 

        mov     sensedata1,bx           ;sector length
        mov     sensedata2,cx           ;cylinder
        mov     byte ptr sensedata3,dh          ;DH = head
        mov     byte ptr sensedata4,dl          ;DL = sector num

        SwitchToProtectedMode
        jmp     SECTOR

        
FDBIOS: 

        push    ax
        mov     cx,[bp].intUserCX       ;sector size shift factor (0,1,2,3)
;;;;;;;;        mov     cl,byte ptr [bp].intUserCX      ;sector size shift factor (0,1,2,3)
        mov     ax,128
        xchg    ch,cl
        shl     ax,cl                   ;ax now = sector size
        mov     cx,ax
        mov     sensedata1,cx           ;sector length
        pop     ax
        
        cmp     al,90h                  ;1MB floppy disk,1MB/640KBdual modefloppy disk(1MB FD access)
        jb      fd640k
        cmp     al,93h
        ja      fd640k
        
;set the max value to the buffer with 1MBFD
        mov     sensedata2,77           ;cylinder
        mov     word ptr sensedata3,1           ;head
        mov     word ptr sensedata4,26          ;sector num
        jmp     SECTOR

fd640k:
        cmp     al,70h                  ;640KB floppy disk
        jb      @f
        cmp     al,73h
        ja      @f
        mov     sensedata2,79           ;cylinder
        mov     word ptr sensedata3,1           ;head
        mov     word ptr sensedata4,16          ;sector num
        jmp     SECTOR
@@:
        cmp     al,10h                  ;1MB/640KB dual modefloppy disk(640KB FD access)
        jb      @f
        cmp     al,13h
        ja      @f
        mov     sensedata2,79           ;cylinder
        mov     word ptr sensedata3,1           ;head
        mov     word ptr sensedata4,16          ;sector num
        jmp     SECTOR
@@:
        cmp     al,30h                  ;1.44MBfloppy disk '93 1/5 By S.Kurokawa
        jb      fdother
        cmp     al,33h
        ja      fdother
        mov     sensedata2,79           ;cylinder
        mov     word ptr sensedata3,1           ;head
        mov     word ptr sensedata4,18          ;sector num
        jmp     SECTOR


;------------------------ 90/07/23 ------------------------------
;       for the media except for 1MB FD,640KB FD ::i10MB FDj
;       we do not know that we can certainly issue a sense command
;--------------------------------------------------------------------
fdother:
        mov     ah,84h                  ;SENSE command

        push    ax
        SwitchToRealMode
        pop     ax

        pushf                           ;have BIOS get the drive data
        call    rglpfnRmISR[1Bh*4]      ;90/07/04 

        mov     sensedata1,bx           ;sector length
        mov     sensedata2,cx           ;cylinder
        mov     byte ptr sensedata3,dh          ;DH = head
        mov     byte ptr sensedata4,dl          ;DL = sector num

        SwitchToProtectedMode


SECTOR:
        push    dx
        xor     dx,dx
        mov     cx,sensedata1                   ;sector length
        mov     ax,[bp].intUserBX       ;# sectors caller wants to
        div     cx
        mov     cSectorsToTransfer,ax           ;bytes^sector lensector num
        pop     dx

;;;;    mov     cx,1                    ;90/07/13  
        
	FSTI                             ;don't need them disabled

if DEBUG   ;------------------------------------------------------------

        cmp     cx