     *movieImage, 
                          Real            time,
                          MovieImagePerf *perf, 
                          bool            forceFallback,
                          DDSurface      *forceDDSurf = NULL);
    void RenderGradientImage(GradientImage *img,
                             int numPts,
                             Point2Value **pts,
                             Color **clrs);
    void RenderMulticolorGradientImage(
        MulticolorGradientImage *gradImg,
        int numOffsets,
        double offsets[],
        Color **clrs);
    void RenderColorKeyedImage(ColorKeyedImage *);

    // -- End: image value rendering calls.

    

    void SmartRender(Image *image, int attrib);
    void RenderComplexTransformCrop(DDSurface *srcDDSurf,
                                    DDSurface *destDDSurf,
                                    BoundingPolygon &destPolygon,
                                    DiscreteImage *image=NULL);

    void RenderSimpleTransformCrop(DDSurface *srcDDSurf,
                                   DDSurface *destDDSurf,
                                   bool useSrcSurfClrKey = true);
        
    void Render3DPolygon(DDSurface *srcDDSurf,
                         DDSurface *destDDSurf,
                         BoundingPolygon *destPolygon,
                         DiscreteImage *image,
                         Color **clrs,
                         bool bUseFirstColor);

    //
    // Utility functions for Images to get information
    //
    DDSurface *LookupSurfaceFromDiscreteImage(DiscreteImage *image,
                                              bool bForCaching = false,
                                              Image **pImageKeyToUse = NULL,
                                              bool bAlphaSurface = false);

    // Given an hdc, font and str, it returns all the
    // points, the types array, number of points,
    // the hiight of the text, the center (Real),
    // the min and max pts (int bbox basically).
    void GetTextPoints(
        HDC hDC,
        HFONT font,
        WideString str,  
        POINT **points,   // out
        TextPoints& txtPts,
        UINT bUnderline,
        UINT bStrikeout,
        bool doGlyphMetrics
        );

    // Render a string using according to the current text context.
    void RenderText(TextCtx& textCtx,
                    WideString str,
                    Image *textImg);



    //////////////////// DYNAMIC TEXT ////////////////////

    // Get text bbox
    virtual const Bbox2 DeriveDynamicTextBbox(TextCtx& textCtx, WideString str, bool bCharBox);    

    // Renders a string on a dc or on an image
    // and overrides the transform if there is one.
    // Calls to render normal text string or render individual
    // characters depending on textCtx <the helper methods are below>
    void RenderDynamicTextOrCharacter(
        TextCtx& textCtx, 
        WideString str, 
        Image *textImg,
        Transform2 *overridingXf,
        textRenderStyle textStyle,
        RenderStringTargetCtx *targetCtx,
        DAGDI &myGDI);

  private:
    // these two are internal helpers

    // Renders DynamicText strings 
    void _RenderDynamicText(TextCtx& textCtx, 
                           WideString str, 
                           Image *textImg,
                           Transform2 *overridingXf,
                           textRenderStyle textStyle,
                           RenderStringTargetCtx *targetCtx,
                           DAGDI &myGDI);
    
    // Renders DynamicText strings, but allows for individually
    // transformed characters within that string
    void _RenderDynamicTextCharacter(TextCtx& textCtx, 
                                    WideString str, 
                                    Image *textImg,
                                    Transform2 *overridingXf,
                                    textRenderStyle textStyle,
                                    RenderStringTargetCtx *targetCtx,
                                    DAGDI &myGDI);
  public:

    
    void RenderDynamicTextOnDC(TextCtx& textCtx,
                               WideString str,
                               HDC dc,
                               Transform2 *xform) {
        RenderStringTargetCtx ctx(dc);
        RenderDynamicTextOrCharacter(textCtx,
                                     str,
                                     NULL,
                                     xform,
                                     textRenderStyle_invalid,
                                     &ctx,
                                     *GetDaGdi());
    }

    // helper should be used for caching
    void GenerateTextPoints(
        // IN
        TextCtx& textCtx, 
        WideString str, 
        DDSurface *targDDSurf,
        HDC optionalDC,
        bool doGlyphMetrics,
        
        // OUT
        TextPoints& txtPts);
    
    //////////////////// STATIC TEXT ////////////////////

    // Clients of RenderStaticTextOnDC must do there own cropping
    // wince it no longer does it.
    void RenderStaticTextOnDC(TextCtx& textCtx,
                              WideString str,
                              HDC dc,
                              Transform2 *xform);

    void RenderStaticText(TextCtx& textCtx, 
                          WideString str, 
                          Image *textImg,
                          DDSurface *targDDSurf,
                          DAGDI &myGDI);
    
    virtual const Bbox2 DeriveStaticTextBbox(TextCtx& textCtx, WideString str);


    
    // Renders tiled image using tileSrcImage
    // see imgdev.h for more detail.
    void RenderTiledImage(
        const Point2 &min,
        const Point2 &max,
        Image *tileSrcImage);

    // Renders the given image, from the given region,
    // to a surface, in the returned outRect.
    DDSurface *RenderImageForTexture(
        Image * image,
        int pixelsWide,
        int pixelsHigh,
        DWORD *colorKey,
        bool *clrKeyIsValid,
        bool &old_static_image,
        bool doFitToDimensions,
        SurfacePool *srcPool,
        SurfacePool *dstPool,
        DDSurface   *preferredSurf,
        bool        *pChosenSurfFromPool,    // out
        DDSurface  **pDropSurfHereWithRefCount, // out
        bool         upsideDown         
        );


    int GetWidth() { return _viewport.Width(); }
    int GetHeight() { return _viewport.Height(); }

    // Return resolution, in pixels per meter.
    Real GetResolution() { return _viewport.GetResolution(); }

    inline DirectDrawViewport* Viewport() { return &_viewport; }

    Transform2 *GetOffsetTransform() { return _offsetXf; };

    void WindowResizeEvent(int width, int height){
        _viewport.WindowResizeEvent(width, height); }

    // -- GDI Specific
    // XXX both of these should disappear soon unless they're useful for the new 2d prims
    HRGN CreateRegion(int numPts, Point2Value **pts, Transform2 *xform);
    void CreateRegion(HDC dc, int numPts, Point2Value **pts, Transform2 *xform);

    Bool DetectHit(HRGN region, Point2Value *pt);

    // -- used by GeomRenderer --

    void BeginEnumTextureFormats();
    void EndEnumTextureFormats();
    void EnumTextureFormats(LPDDSURFACEDESC desc);

    void RenderImageOnDDSurface(Image *image,
                                DDSurface *ddSurf,
                                Real opacity=1.0,
                                Bool pushClipper = TRUE,
                                bool inheritContext = false,
                                DirectDrawImageDevice **usedDev = NULL);

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "(DirectDraw Device)";
    }

#endif
    HDC RenderGetDC(char *errStr) {
        return _compositingStack->TargetDDSurface()->GetDC(errStr);
    }

    void RenderReleaseDC(char *errStr) {
        _compositingStack->TargetDDSurface()->ReleaseDC(errStr);
    }

    /* returns true if any dimension of the matrix is being
       scaled by x or more */

    Bool IsScale(double x) {
        Real m[6];
        _xform->GetMatrix(m);
        return (fabs(m[0]) >= x  || fabs(m[1]) >= x ||
                fabs(m[3]) >= x || fabs(m[4]) >= x);
    }
    
    void DestroyTextureSurfaces (void);

    void DoDestRectScale(
        RECT *destRect,
        Real destRes,
        const Bbox2 &box,
        DDSurface *destSurf=NULL);

    DAGDI *GetDaGdi() { return _daGdi; }

  protected:
    DDSurface *NewSurfaceHelper();
    
  private:

    DAGDI *_daGdi;

    // Helper function
    Transform2 *CenterAndScaleRegion( const Bbox2 &regionBox, DWORD pixelW, DWORD pixelH );
    
    void SmartDestRect(RECT *destRect,
                       Real destRes,
                       const Bbox2 &box,
                       DDSurface *destSurf,
                       RECT *srcRect=NULL);
        

    Bool DoSrcRect(
        RECT *srcRect,
        const Bbox2 &box,
        Real srcRes,
        LONG srcWidth,
        LONG srcHeight);

    const Bbox2 DoBoundingBox(const Bbox2 &firstBox, DoBboxFlags_t flags = do_all);
    void DoBoundingPolygon(BoundingPolygon &polygon,
                           bool doInclusiveCrop = false,
                           DoBboxFlags_t flags = do_all);

    //----------------------------------------
    // Texture Management
    //----------------------------------------
    void PrepareD3DTextureSurface(
        LPDDRAWSURFACE *surf,
        RECT *rect,
        DDPIXELFORMAT &pf,
        DDSURFACEDESC *desc=NULL,
        bool attachClipper=true);

    // Return new texture surface, addref'd
    void GetTextureDDSurface(DDSurface *preferredSurf,
                             SurfacePool *srcPool,
                             SurfacePool *destPool,
                             DWORD prefWidth,
                             DWORD prefHeight,
                             vidmem_enum vid,
                             bool usePreferedDimensions,
                             DDSurface **pResult);
                                   

    void       ReturnTextureSurfaces(SurfacePool *toPool,
                                     SurfacePool *fromPool);

    // Reformats the src surface to be of the same format as the destination surface.
    // destSurf will be srcSurf with the new format (i.e.: different bit depth)
    Bool ReformatSurface(
        LPDDRAWSURFACE destSurf, LONG destWidth, LONG destHeight,
        LPDDRAWSURFACE srcSurf, LONG srcWidth, LONG srcHeight,
        DDSURFACEDESC *srcDesc);

    void ColorKeyBlit(destPkg_t *destPkg,
                      RECT *srcRect,
                      LPDDRAWSURFACE srcSurf, 
                      DWORD clrKey,
                      RECT *clipRect,
                      RECT *destRect);

    void Get32Surf(IDDrawSurface **surf32,
                   LONG width, LONG height);
                   
    
    //
    // Does alpha blitting from the srcSurface to the destination surface
    // within the given rectangle and the of the give opacity
    // .. the dest rectangle can be offset by xOffset,y...
    //
    void AlphaBlit(destPkg_t *destPkg,
                   RECT *srcRect,
                   LPDDRAWSURFACE srcSurf,
                   Real opacity,
                   Bool doClrKey,
                   DWORD clrKey,
                   RECT *clipRect=NULL,
                   RECT *destRect=NULL);


    //
    // Does alpha blitting using the 'src' word and the destination surface
    // within the given rectangle and the of the give opacity
    //
    void AlphaBlit(LPDDRAWSURFACE destSurf,
                   RECT *rect,
                   Real opacity,
                   DWORD src);

    //
    // Does alpha blending given the two pixels & two opacities
    //
    inline WORD BlendWORD(WORD dest, int destOpac, WORD src, int opac,
                          DWORD redShift, DWORD greenShift, DWORD blueShift,
                          WORD redMask, WORD greenMask, WORD blueMask,
                          WORD redBlueMask);


    //
    // Does alpha blending given the two pixels & two opacities
    //
    inline DWORD BlendDWORD(DWORD dest, int destOpac, DWORD src, int opac,
                            DWORD redShift, DWORD greenShift, DWORD blueShift,
                            DWORD redMask, DWORD greenMask, DWORD blueMask,
                            DWORD redBlueMask);

    //
    // Alpha blend a premultiplied word
    //
    inline WORD BlendPremulWORD(WORD dest, int destOpac, WORD src,
                                DWORD redShift, DWORD greenShift, DWORD blueShift,
                                WORD redMask, WORD greenMask, WORD blueMask,
                                WORD redBlueMask);

    //
    // Alpha blend a premultiplied double word
    //
    inline DWORD BlendPremulDWORD(DWORD dest, int destOpac, DWORD src,
                                  DWORD redShift, DWORD greenShift, DWORD blueShift,
                                  DWORD redMask, DWORD greenMask, DWORD blueMask,
                                  DWORD redBlueMask);

    #if 0
    //
    // Final alpha composite utils
    //
    Real GetFinalOpacity() { return _finalOpacity; }
    void SetFinalOpacity(Real op) { _finalOpacity = op; }
    Real _finalOpacity;
    #endif
    
    // Decomposes matrix into its components.  NULL args signify
    // disinterest in that part of the matrix.
    // FUTURE: add rotation angle, translation, & shears.
    // Note: scale, shear, rotate must be performed in a certain order
    void     DecomposeMatrix(Transform2 *xform, Real *xScale, Real *yScale, Real *rot);

    Bool IsComplexTransform() {
        Real m[6];
        _xform->GetMatrix(m);
        return (m[1] != 0  ||  m[3] !=0);
    }
    Bool IsFlipTranslateTransform() {
        Real m[6];
        _xform->GetMatrix(m);
        return (m[1] == 0  &&  m[3] == 0) &&
            fabs(m[0])==1 && fabs(m[4])==1;
    }
    bool IsNegScaleTransform() {
        Real m[6];
        GetTransform()->GetMatrix(m);
        return (m[0] < 0) || (m[4] < 0);
    }

    typedef struct {
        Bool isEnumerating;
        Bool descIsSet;
        Bool sizeIsSet;
        Bool useDeviceFormat;
        Bool isValid;
        DDSURFACEDESC ddsd;
    } _textureContext_t;

    _textureContext_t  _textureContext;

    // Scratch texture surfaces that aren't associated
    // with any specific image, but are needed for holding
    // images. recycled every frame.  per image device
    // (that's why they're not in viewport.cpp
    SurfaceManager *_textureSurfaceManager;
    SurfacePool *_usedTextureSurfacePool;
    SurfacePool *_intraFrameUsedTextureSurfacePool;
    SurfacePool *_freeTextureSurfacePool;

    SurfacePool *_surfacePool;
    SurfaceMap  *_surfaceMap;
    SurfaceMap  *_intraFrameTextureSurfaceMap;
    SurfaceMap  *_intraFrameUpsideDownTextureSurfaceMap;
    
    CompositingStack *_compositingStack;

    inline SurfacePool *GetSurfacePool() { return _surfacePool; }
    inline SurfaceMap  *GetSurfaceMap() { return _surfaceMap; }
    inline CompositingStack *GetCompositingStack() { return _compositingStack; }

    void SetSurfacePool(SurfacePool *sp) { _surfacePool = sp; }
    void SetSurfaceMap(SurfaceMap *sm) {  _surfaceMap = sm; }
    void SetCompositingStack(CompositingStack *cs) {  _compositingStack = cs; }

    //
    // This pointer is set to a texture surface when
    // some leaf's rendering can handle complex
    // transforms and does so to a texture capable surface
    //
    DDSurface *_currentScratchDDTexture;

    //
    // These members hold texture info for the intermediate
    // texture surface.  This surface will be color converted
    // blit to a surface conforming to one of D3D's prefered
    // texture formats.  Note that this surface may never be
    // used if the device format is identical to the required
    // texture format.
    //
    LPDIRECTDRAWCLIPPER _textureClipper;        // Clipper on texture surface
    DDSurface          *_textureDDZBuffer;        // Zbuffer for rendering geom on txtr

    LONG _textureWidth,    _textureHeight;
    RECT _textureRect;

    LPDIRECTDRAWCLIPPER _tileClipper;           // Clipper that tileImage uses

    // Temp font holder
    LOGFONTW      _logicalFont;

    // scratch pen
    HPEN         _pen;
    
    DirectDrawViewport &_viewport;
    Bool                _deviceInitialized;
    
    //
    // Memory management
    //
    void *AllocateFromMyStore(size_t size)
    { return StoreAllocate(*_scratchHeap, size); }

    DynamicHeap * _scratchHeap;

    HRESULT  _ddrval;
    DDBLTFX _bltFx;
    unsigned int _randSeed;

    TextPtsCacheEntry *_textPtsCache[TEXTPTSCACHESIZE];
    int _textPtsCacheIndex;

    // global offset for images.  motivated by compositeDirectlyToTarget
    Real _tx;   Real _ty;
    Transform2 *_offsetXf;
    bool _doOffset;
    POINT _pixOffsetPt;

    // Antialiasing related member vars
    bool _renderForAntiAliasing;

    bool _alreadyDisabledDirtyRects;
};


// --------------------------------------------------
// Local helper classes
// --------------------------------------------------

// This class knows how to release a DC.
// Used when grabbing a DC.
// Guaranteed to release the DC exactly ONCE.
// Can be forced to release

class DCReleaser {

  public:
    DCReleaser(DDSurface *dds, char *str)
    : _surf(dds),
      _str(str)
    {
        Assert(_str);
    }
    
    ~DCReleaser() {   Release();  }

    void Release() {
        if(_surf) {
            _surf->ReleaseDC(_str);
            _surf = NULL;
        }
    }

    DDSurface *_surf;
    char *_str;
};


// This class knows how to release a GDI object.
class GDI_Deleter {

  public:
    GDI_Deleter(HGDIOBJ hobj) : _hobj(hobj) {}

    ~GDI_Deleter() {
        DeleteObject(_hobj);
    }

  protected:
    HGDIOBJ _hobj;
};


// This class knows how to release a GDI object.
class ObjectSelector {

  public:
    ObjectSelector(HDC dc, HGDIOBJ newObj) :
    _newObj(newObj), _dc(dc) {
        Assert(_dc && "NULL dc in ObjectSelector");
        Assert(_newObj && "NULL newObj in ObjectSelector");
        TIME_GDI( _oldObj = (HGDIOBJ)SelectObject(_dc, _newObj) );
    }

    ~ObjectSelector() { Release(); }

    void Release() {
        if(_oldObj) {
            HGDIOBJ f;
            TIME_GDI( f = (HGDIOBJ)SelectObject(_dc, _oldObj) );
            Assert(f == _newObj && "bad scoping of ObjectSelector");
            TIME_GDI( DeleteObject(_newObj) );
            _oldObj = NULL;
        }
    }
        
    bool Success() { return _oldObj != NULL; }

  protected:
    HGDIOBJ _newObj;
    HGDIOBJ _oldObj;
    HDC _dc;
};


// This class knows how to reset a heap
class HeapReseter {

  public:
    HeapReseter(DynamicHeap &heap) : _heap(heap) {}

    ~HeapReseter() {
        //printf("reseting imgdev heap!\n"); fflush(stdout);
        ResetDynamicHeap(_heap);
    }

  protected:
    DynamicHeap &_heap;
};



class CompositingSurfaceReturner {
  public:
    CompositingSurfaceReturner(CompositingStack *cs,
                               DDSurface *ddSurf,
                               bool ownRef)
    {
        _stack = cs;
        _ddSurf = ddSurf;
        _ownRef = ownRef;
    }
    ~CompositingSurfaceReturner() {
        if(_ownRef && _ddSurf) {
            _stack->ReturnSurfaceToFreePool(_ddSurf);
            RELEASE_DDSURF(_ddSurf, "~CompositingSurfaceReturner", this);
        }
    }
    CompositingStack *_stack;
    DDSurface *_ddSurf;
    bool _ownRef;
};


//---------------------------------------------------------
// Local helper functions
//---------------------------------------------------------
static LONG CeilingPowerOf2(LONG num);
Real Pix2Real(LONG pixel, Real res);
Real Round(Real x);
extern LONG Real2Pix(Real imgCoord, Real res);

void ComputeLeftRightProj(Transform2 *charXf,
                          TextPoints::DAGLYPHMETRICS &daGm,
                          Real *leftProj,
                          Real *rightProj);

// Global Variables

extern bool g_preference_UseVideoMemory;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\debug.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Declarations and definitions for debugging.

*******************************************************************************/

#if !defined(_AP_DEBUG_H) && ((_DEBUG != 0) || (_MEMORY_TRACKING !=0))
#define _AP_DEBUG_H


    /*** Tag Declarations & Definitions ***/

#if DEFINE_TAGS
    #define TAGDECL(tag,owner,desc)   DeclareTag(tag,owner,desc)
#else
    #define TAGDECL(tag,owner,desc)   extern TAG tag
#endif 

TAGDECL (tagAntialiasingOn, "2D", "Turn Anti-Alising ON (override)");
TAGDECL (tagAntialiasingOff,"2D", "Turn Anti-Alising OFF (override)");
TAGDECL (tagAAScaleOff,     "2D", "Turn Off Scale for Anti-Alising");

TAGDECL (tagGRenderObj,     "3D", "GeomRenderer Objects");
TAGDECL (tagGRendering,     "3D", "Rendering Trace");
TAGDECL (tagGTextureInfo,   "3D", "Texture Informative");
TAGDECL (tagForceTexUpd,    "3D", "Force Texture Update");
TAGDECL (tag3DDevSelect,    "3D", "Device Selection");
TAGDECL (tagD3DCallTrace,   "3D", "D3D Call Trace");

TAGDECL (tagAPIEntry, "API",  "C Entry");
TAGDECL (tagCOMEntry, "API",  "COM Entry");

TAGDECL (tagNetIO, "CNetIO", "CNetIO Methods");

TAGDECL (tagCOMCallback, "COMCallback", "COMCallback Methods");

TAGDECL (tagControlLifecycle, "Control", "Lifecycle");

TAGDECL (tagDDSurfaceRef,  "DDSurface", "Surfaces: Ref count tracing");
TAGDECL (tagDDSurfaceLeak, "DDSurface", "Surfaces: Leak reporting");

TAGDECL (tagDibImageInformative, "DibImage", "Informative Messages");

TAGDECL (tagDirectDrawObject, "DirectDraw", "IDirectDraw Object tracing");

TAGDECL (tagDiscreteImageInformative, "DiscreteImage", "Informative Messages");

TAGDECL (tagEngNoSRender,      "Engine", "Turn Off Top-Level Smart Render");
TAGDECL (tagNoApplyFolding,    "Engine", "Turn Off Apply Creation Constant Fold");
TAGDECL (tagNoTimeXformFolding,"Engine", "Turn Off TimeXform Constant Fold");
TAGDECL (tagAppTrigger,        "Engine", "AppTriggerEvent Trace");
TAGDECL (tagSwitcher,          "Engine", "Switcher Trace");
TAGDECL (tagPureFunc,          "Engine", "Disable Pure Function Detection");
TAGDECL (tagDCFold,            "Engine", "Turn Off Dynamic Constant Folding");
TAGDECL (tagDCFoldTrace,       "Engine", "Turn On Trace on Dynamic Constant Folding");
TAGDECL (tagDCFoldTrace2,      "Engine", "Turn On Per Sample Trace on Dynamic Constant Folding");
TAGDECL (tagOldTimeXform,      "Engine", "Turn on old TimeXform semantics");
TAGDECL (tagCycleCheck,        "Engine", "Cycle Checking");

TAGDECL (tagFail_InternalError, "Error failures", "Fail: InternalError");
TAGDECL (tagFail_InternalErrorCode, "Error failures", "Fail: InternalErrorCode");
TAGDECL (tagFail_UserError, "Error failures", "Fail: UserError");
TAGDECL (tagFail_UserError1, "Error failures", "Fail: UserError RESID");
TAGDECL (tagFail_UserError2, "Error failures", "Fail: UserError HR RESID");
TAGDECL (tagFail_ResourceError, "Error failures", "Fail: ResourceError");
TAGDECL (tagFail_ResourceError1, "Error failures", "Fail: ResourceError str");
TAGDECL (tagFail_ResourceError2, "Error failures", "Fail: ResourceError RESID");
TAGDECL (tagFail_StackFault, "Error failures", "Fail: StackFault");
TAGDECL (tagFail_DividebyZero, "Error failures", "Fail: DivideByZero");
TAGDECL (tagFail_OutOfMemory, "Error failures", "Fail: OutOfMemory");

TAGDECL (tagDXTransforms, "DXTransforms", "General");
TAGDECL (tagDXTransformsImg0, "DXTransforms", "Disp Img 0");
TAGDECL (tagDXTransformsImg1, "DXTransforms", "Disp Img 1");
TAGDECL (tagDXTransformsImgOut, "DXTransforms", "Disp Img Out");

TAGDECL (tagGCStat,   "GC", "Statistics");
TAGDECL (tagGCDebug,  "GC", "Debug: No Reuse Of Free Objs");
TAGDECL (tagGCMedia,  "GC", "Trace GC Static Value - Media");
TAGDECL (tagGCStress, "GC", "Doing GC all every 100ms");

TAGDECL (tagImageDecode, "Image Decode", "Image Decode Filters");

TAGDECL (tagImageDeviceInformative,  "ImageDevice", "Informative Messages");
TAGDECL (tagImageDeviceOptimization, "ImageDevice", "Optimization Messages");
TAGDECL (tagImageDeviceAlgebra,      "ImageDevice", "Algebra Messages");
TAGDECL (tagImageDeviceAlpha,        "ImageDevice", "Alpha Messages");
TAGDECL (tagImageDeviceQualityScaleOff, "ImageDevice", "Turn off Quality Scale (GDI)");

TAGDECL (tagImport,              "Import", "General Importation Status");
TAGDECL (tagReadVrml,            "Import", "VRML - General Status");
TAGDECL (tagReadVrmlFaceIndices, "Import", "VRML - Face Indices");
TAGDECL (tagReadX,               "Import", "X File Importation");

TAGDECL (tagMathMatrixInvalid, "Math", "Break on Invalid Matrices");

TAGDECL (tagCacheOpt, "Optimizations", "Report on caching constant images");
TAGDECL (tagDirtyRectsVisuals ,"Optimizations", "Dirty rects - Visual trace");
TAGDECL (tagCachedImagesVisuals ,"Optimizations", "Cached images - Visual trace");

TAGDECL (tagPickOptOff,    "Picking", "Disable Picking Optimizations");
TAGDECL (tagPick2,         "Picking", "2D Images");
TAGDECL (tagPick2Hit,      "Picking", "2D Stuff result & image hit");
TAGDECL (tagPick3,         "Picking", "3D General");
TAGDECL (tagPick3Geometry, "Picking", "3D Geometry");
TAGDECL (tagPick3Bbox,     "Picking", "3D Bbox Testing");
TAGDECL (tagPick3Offset,   "Picking", "3D Local Coord Offset");

TAGDECL (tagServerCtx,  "Server", "Context");
TAGDECL (tagServerView, "Server", "View");

TAGDECL (tagSoundDevLife, "Sound", "Device Life");
TAGDECL (tagSoundDebug,   "Sound", "Current Debug");
TAGDECL (tagSoundErrors,  "Sound", "Errors");
TAGDECL (tagSoundLoads,   "Sound", "Media File Reading");
TAGDECL (tagSoundRenders, "Sound", "Renders");
TAGDECL (tagSoundReaper1, "Sound", "Reaper Events");
TAGDECL (tagSoundReaper2, "Sound", "Reaper Operation");
TAGDECL (tagSoundStats,   "Sound", "Dsound Statistics");
TAGDECL (tagSoundDSound,  "Sound", "Dsound Details");
TAGDECL (tagSoundStubALL, "Sound", "Return in Display");
TAGDECL (tagSoundStop,    "Sound", "Stop Sound");
TAGDECL (tagMovieStall,   "Sound", "stub out movie Stall()");
TAGDECL (tagAVmodeDebug,  "Sound", "output avmode messages");
TAGDECL (tagAMStreamLeak, "Sound", "output amstream create/releases");

TAGDECL (tagSplineEval, "Splines", "Evaluation");

TAGDECL (tagTextPtsCache,    "Text", "Text Points Cache Info");
TAGDECL (tagTextBoxes,       "Text", "Text Box Outlines");

TAGDECL (tagTransientHeapDynamic,  "TransientHeap", "Dynamic Status");
TAGDECL (tagTransientHeapLifetime, "TransientHeap", "Lifetime Status");

TAGDECL (tagViewportInformative, "Viewport", "Informative Messages");
TAGDECL (tagViewportMemory,      "Viewport", "viewport: Memory tracing");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\ddsurf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DDSURF_H
#define _DDSURF_H

#include "ddraw.h"

#include "privinc/ddutil.h"
#include "privinc/bbox2i.h"
#include "privinc/error.h"
#include "privinc/ddrender.h"
#include "privinc/debug.h"
#include "privinc/imgdev.h"
#include "privinc/comutil.h"


// forward decls
class GeomRenderer;
enum targetEnum;
class SurfacePool;

// Given a DDSurface, returns an IDXSurface
HRESULT CreateFromDDSurface(
    IDXSurfaceFactory *sf,
    DDSurface *dds,
    const GUID *pFormatID,
    IDXSurface **outDXSurf );

#if _DEBUG
#define NEWDDSURF(outdds, surf, box, rect, res, clrk1, clrk2, a, b, str) \
DDSurface::CreateSurface(outdds, surf, box, rect, res, clrk1, clrk2, a, b, str);
#else
#define NEWDDSURF(outdds, surf, box, rect, res, clrk1, clrk2, a, b, str) \
DDSurface::CreateSurface(outdds, surf, box, rect, res, clrk1, clrk2, a, b);
#endif



#if _DEBUG

#define ADDREF_DDSURF(ddsurf, reason, clientPtr) \
        (ddsurf)->AddRef((ddsurf), reason, clientPtr, __FILE__, __LINE__);

#define RELEASE_DDSURF(ddsurf, reason, clientPtr) \
        (ddsurf)->Release((ddsurf), reason, clientPtr, __FILE__, __LINE__);

#else

#define ADDREF_DDSURF(ddsurf, reason, clientPtr) \
        (ddsurf)->AddRef((ddsurf));

#define RELEASE_DDSURF(ddsurf, reason, clientPtr) \
        (ddsurf)->Release((ddsurf));

#endif


#if _DEBUG
#define INIT {_reason="<>"; _client=NULL;}
#else
#define INIT
#endif

template <class T>
class DDSurfPtr
{
  public:
    typedef T _PtrClass;
    DDSurfPtr() { p = NULL; INIT }
    DDSurfPtr(T* lp)
    {
        INIT
        p = lp;
        if (p != NULL) {
            #if _DEBUG
            ADDREF_DDSURF(p, _reason, _client);
            #else
            ADDREF_DDSURF(p, NULL, NULL);
            #endif
        }
    }
    // for DDSurface auto addref/release tracking...
    #if _DEBUG
    DDSurfPtr(T* lp, char *reason, void *client)
    {
        _reason = reason;
        _client = client;

        p = lp;
        if (p != NULL) {
            ADDREF_DDSURF(p, _reason, _client);
        }
    }
    DDSurfPtr(char *reason, void *client)
    {
        _reason = reason;
        _client = client;
        p = NULL;
    }
    #endif

    ~DDSurfPtr() {
        if (p) {
            RELEASE_DDSURF(p, _reason, _client);
        }
    }
    void Release() {
        if (p) {
            RELEASE_DDSURF(p, _reason, _client);
        }
        p = NULL;
    }

    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DDSurfPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;

    #if _DEBUG
    char *_reason;
    void *_client;
    #endif
  protected:
    T* Assign(T* lp) {
        if (lp != NULL) {
            ADDREF_DDSURF(lp, _reason, _client);
        }
        if (p) {
            RELEASE_DDSURF(p, _reason, _client);
        }

        p = lp;

        return lp;
    }
};

#if _DEBUG
#define DEBUG_ARG1(x)   ,x
#define DEBUG_ARG4(a, b, c, d)   ,a,b,c,d
#else
#define DEBUG_ARG1(x)
#define DEBUG_ARG4(a, b, c, d)
#endif

class GenericSurface : public AxAThrowingAllocatorClass {
  public:
    GenericSurface();

    virtual ~GenericSurface() {}

    inline static void AddRef(GenericSurface *ddsurf
                              DEBUG_ARG4(char *reason,
                                         void *clientPtr,
                                         char *file,
                                         int   line))
    {
        ddsurf->_ref++;

        // print out loads of info if needed...
        TraceTag((tagDDSurfaceRef,
                  "+++surf(%x, new ref:%d): purpose:%s context:%s  by: %x in %s, line %d",
                  ddsurf, ddsurf->_ref, ddsurf->_explanation, reason, clientPtr, file, line));
    }

    inline static void Release(GenericSurface *ddsurf
                               DEBUG_ARG4(char *reason,
                                          void *clientPtr,
                                          char *file,
                                          int   line))
    {
        // print out loads of info if needed...
        TraceTag((tagDDSurfaceRef,
                  "---surf(%x, new ref:%d) purpose:%s context: %s  by: %x in %s, line %d",
                  ddsurf, ddsurf->_ref-1, ddsurf->_explanation, reason, clientPtr, file, line));

        Assert(ddsurf->_ref > 0);
        if( --(ddsurf->_ref) == 0) {
            delete ddsurf;
        }
    }

    #if _DEBUG
    char         *_explanation;
    #endif

    inline int GetRef() { return _ref; }

    enum surfaceTypeEnum {
        invalidSurface,
        gdiSurface,
        ddrawSurface
    };

    virtual void SetSurfacePtr(void *surface) = 0;
    virtual void *GetSurfacePtr() = 0;
    virtual HDC GetDC(char *errStr) = 0;
    virtual void ReleaseDC(char *errStr) = 0;

    virtual RECT *GetSurfRect(void) = 0;

    #if DEVELOPER_DEBUG
    bool debugonly_IsDdrawSurf() { return _surfaceType == ddrawSurface; }
    #endif

  protected:

    surfaceTypeEnum _surfaceType;

    virtual void SetSurfaceType(surfaceTypeEnum type) {
        _surfaceType = type;
    }

    int _ref;
};

class GDISurface : public GenericSurface {
  public:

    GDISurface(HDC target) {
        SetSurfacePtr((void *)target);
        SetSurfaceType(GenericSurface::gdiSurface);
    }

    void SetSurfacePtr(void *surface) {
        _targetDC = (HDC)surface;
    }
    void *GetSurfacePtr() { return (void *)_targetDC; }

    HDC GetDC(char *) {

        Assert(_targetDC);
        return _targetDC;
    }

    void ReleaseDC(char *errStr) {}

    RECT *GetSurfRect(void);

  private:
    HDC _targetDC;
    RECT _surfRect;
};


struct DDSurface : public GenericSurface {

    friend class SurfacePool;

    enum scratchStateEnum {
        scratch_Invalid,
        scratch_Dest,
        scratch_Src
    };

    //
    // Static member that instantiates a DDSurface class
    //
    inline static void CreateSurface(DDSurface **outDDSurf,
                                     IDDrawSurface *surface,
                                     const Bbox2 &box,
                                     RECT *rect,
                                     Real res,
                                     DWORD colorKey,
                                     bool colorKeyIsValid,
                                     bool isWrapper,
                                     bool isTexture
                                     DEBUG_ARG1( char *explanation ))
    {
        Assert(outDDSurf);
        *outDDSurf = NEW DDSurface(surface, box, rect, res,
                                   colorKey, colorKeyIsValid,
                                   isWrapper, isTexture
                                   DEBUG_ARG1(explanation));
    }



    DDSurface(IDDrawSurface *surface,
              const Bbox2 &box,
              RECT *rect,
              Real res,
              DWORD colorKey,
              bool colorKeyIsValid,
              bool isWrapper,
              bool isTexture
              DEBUG_ARG1( char *explanation ));

    virtual ~DDSurface();

    // Blits using the underlying direct draw surface.  raw blit
    HRESULT Blt (RECT *destRect,
                 IDDrawSurface *rawSrcSurf,
                 RECT *srcRect,
                 DWORD dwFlags,
                       DDBLTFX *bltFx)
    {
        if( IsScratchSurface() ) {
            SetScratchState( scratch_Dest );
        }
        HRESULT result =
            IDDSurface()->Blt(destRect, rawSrcSurf, srcRect, dwFlags, bltFx);

        if( result == DDERR_SURFACEBUSY ) {
            RaiseException_UserError
                (DAERR_VIEW_SURFACE_BUSY, IDS_ERR_IMG_SURFACE_BUSY);
        }

        return result;
    }

    // blitter in terms of DDSurface.  uses raw Blt(....) above
    inline HRESULT Blt(RECT *destRect,
                       DDSurface *srcDDSurf,
                       RECT *srcRect,
                       DWORD dwFlags,
                       DDBLTFX *bltFx)
    {

        Assert(srcDDSurf);

        if( srcDDSurf->IsScratchSurface() ) {
            srcDDSurf->SetScratchState( scratch_Src );
        }
        return this->Blt(destRect, srcDDSurf->IDDSurface(), srcRect, dwFlags, bltFx);
    }

    HRESULT MirrorUpDown(void);

    // color fill blitter.  in terms of raw Blt(...) above
    inline HRESULT ColorFillBlt(RECT *destRect,
                                DWORD dwFlags,
                                DDBLTFX *bltFx)
    {
        return this->Blt(destRect, (IDDrawSurface*)NULL, NULL, dwFlags, bltFx);
    }

    inline void _ReleaseDerivativeSurfaces() {
        _ddsurf_iunk.Release();
        _IDXSurface.Release();
    }

    inline void SetSurfacePtr(void *surface) {
        // implicit addref
        _capsReady = false;
        _ddsurf = (IDDrawSurface *)surface;
        _ReleaseDerivativeSurfaces();
        _UpdateSurfCaps();
    }
    inline void *GetSurfacePtr() {  return (void *)IDDSurface();  }

    LPDDRAWSURFACE IDDSurface_IUnk() {
        if( !_ddsurf_iunk ) {
            _ddrval = IDDSurface()->QueryInterface(IID_IUnknown, (void **) &_ddsurf_iunk);
            Assert(_ddrval == S_OK && "QI for IUnknown failed in ddsurf");
        }
        return _ddsurf_iunk;
    }

    inline LPDDRAWSURFACE IDDSurface() {

        Assert( debugonly_IsDdrawSurf() );

        return _ddsurf;
    }

    IDXSurface *GetIDXSurface(IDXSurfaceFactory *sf)
    {
        Assert(sf);
        _MakeSureIDXSurface(sf);
        return _IDXSurface;
    }
    bool HasIDXSurface() { return _IDXSurface.p != NULL; }
    void SetIDXSurface( IDXSurface *idxs )
    {
        Assert( _IDXSurface.p == NULL );
        _IDXSurface = idxs;
    }

    inline void SetSurface(IDDrawSurface *surf) {
        _capsReady = false;
        _ddsurf = surf;
        _ReleaseDerivativeSurfaces();
        _UpdateSurfCaps();
    }
    inline LPDDRAWSURFACE ConvertedSurface() {
        return _2ndSurface;
    }
    inline void SetConvertedSurface(LPDDRAWSURFACE s) {
        _2ndSurface = s;
    }

    // NOTE: these zbuffers are shared among multiple
    // surfaces
    inline DDSurface *GetZBuffer() {  return _zbuffer;  }

    HRESULT SetZBuffer(DDSurface *zb);

    HDC GetDC(char *errStr);
    void ReleaseDC(char *errStr);
    void _hack_ReleaseDCIfYouHaveOne();

    #if _DEBUG
    bool _debugonly_IsDCReleased() {
        return (_dcRef==0 && !_dc);
    }
    #endif

    inline void SetIsTextureSurf(bool val) {
        _isTextureSurf = val;
    }
    inline bool IsTextureSurf() {  return _isTextureSurf; }

    inline void SetGeomDevice (GeomRenderer *gdev) {
        _associatedGeomDev = gdev;
    }
    inline GeomRenderer *GeomDevice() {
        return _associatedGeomDev;
    }
    void DestroyGeomDevice();

    inline RECT *GetSurfRect(void) {        return &_surfRect;   }
    inline void SetSurfRect(RECT *rect) {        CopyRect(&_surfRect, rect);    }

    inline RECT *GetInterestingSurfRect() {        return &_interestingRect;    }
    inline void SetInterestingSurfRect(RECT *rect) {

        IntersectRect(&_interestingRect, &_surfRect, rect);
        #if _DEBUG
        RECT foo;
        IntersectRect(&foo, rect, &_surfRect);
        /*
        if(! EqualRect(&foo, rect)) {
            TraceTag((tagViewportInformative,
                      "given rect lies outside surfRect"
                      "in DDSurface::SetInterestingSurfRect()"));
        }
        */
        #endif
    }
    void UnionInterestingRect(RECT *rect);
    void ClearInterestingRect() { SetRect(&_interestingRect,0,0,0,0);}

    HRGN GetClipRgn();

    inline const Bbox2& Bbox()
    {
        return _bbox;
    }

    void SetBbox(const Bbox2 &b)
    {
        _bbox = b;
    }

    void SetBbox(Real minx, Real miny, Real maxx, Real maxy) {
        _bbox.min.Set(minx, miny);
        _bbox.max.Set(maxx, maxy);
    }
    void SetBboxFromSurfaceDimensions(
        const Real res,
        const bool center);

    void UnSetColorKey();
    void SetColorKey(DWORD key);

    inline DWORD ColorKey() {

        Assert(_colorKeyIsValid && "DDSurface::ColorKey() called when key invalid");
        return _colorKey;
    }
    inline bool ColorKeyIsValid() {        return _colorKeyIsValid;    }

    inline Real Resolution() {        return _res;    }
    inline LONG Width() {        return _surfRect.right - _surfRect.left;    }
    inline LONG Height() {        return _surfRect.bottom - _surfRect.top;    }

    inline void SetTimeStamp(Real time) {        _timeStamp = time;    }
    inline Real GetTimeStamp() {        return _timeStamp;    }
    inline bool IsSystemMemory() {   return _systemMemorySurface;    }
    inline bool IsZBuffer() {        return _isZBufferSurface;    }

    inline void SetScratchState(scratchStateEnum st) {        _scratchState = st;    }
    inline scratchStateEnum GetScratchState() {        return _scratchState;    }
    inline bool IsScratchSurface() {        return _scratchState != scratch_Invalid;    }

    inline DWORD GetBitDepth() {

        Assert(_capsReady);

        Assert( ((_pixelFormat.dwFlags & DDPF_PALETTEINDEXED8) &&
                 (_pixelFormat.dwRGBBitCount == 8 )) ||
                (!(_pixelFormat.dwFlags & DDPF_PALETTEINDEXED8) &&
                 !(_pixelFormat.dwRGBBitCount == 8 )) );

        return _pixelFormat.dwRGBBitCount;
    }


    inline DDPIXELFORMAT &GetPixelFormat() {  return _pixelFormat; }

    #if _DEBUG
    void Report() {
        TraceTag((tagDDSurfaceLeak,
                  "%x: %s (ref:%d): %s memory. size=(%d,%d)",
                  this,
                  _explanation,
                  _ref,
                  IsSystemMemory() ? "system" : "video",
                  Width(), Height()));
    }

    #endif

  private:

    void _Init(
        IDDrawSurface *surface,
        const Bbox2 &box,
        RECT *rect,
        Real res,
        DWORD colorKey,
        bool colorKeyIsValid,
        bool isWrapper,
        bool isTexture);

    void _UpdateSurfCaps (void);

    void _MakeSureIDXSurface(IDXSurfaceFactory *sf);

    void SetTargetHDC(HDC dc) { _targetDC = dc; }

    int _dcRef;

    // Source (main) surface
    HDC _targetDC;
    DAComPtr<IDDrawSurface> _ddsurf;
    DAComPtr<IDDrawSurface> _ddsurf_iunk; // IUnknown intfc
    DAComPtr<IDXSurface>    _IDXSurface;

    // Converted (2ndary) surface
    DAComPtr<IDDrawSurface> _2ndSurface;

    // ZBuffer surface
    DDSurfPtr<DDSurface> _zbuffer;

    HDC _dc;  // current dc
    HRESULT _ddrval;
    bool _isWrapper;
    GeomRenderer *_associatedGeomDev;

    bool _isTextureSurf;
    Bbox2 _bbox;
    RECT _surfRect;
    RECT _interestingRect;
    Real _res;
    DWORD _colorKey;
    bool _colorKeyIsValid;
    bool _systemMemorySurface;
    bool _isZBufferSurface;
    Real _timeStamp;
    scratchStateEnum _scratchState;

    DDPIXELFORMAT _pixelFormat;

    bool _capsReady;
};

#endif /* _DDSURF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dibimage.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Header for DibImage, containing a DIB-style bitmap.
*******************************************************************************/

#ifndef _DIBIMAGE_H
#define _DIBIMAGE_H

#include "ddraw.h"

#include "privinc/imagei.h"
#include "privinc/DiscImg.h"
#include "privinc/vec2i.h"
#include "privinc/ddutil.h"

class DirectDrawViewport;

class DibImageClass : public DiscreteImage {
  public:
    DibImageClass(HBITMAP hbm, 
                  COLORREF colorKey=INVALID_COLORKEY, 
                  Real resolution=-1);
    
    virtual ~DibImageClass() { CleanUp(); }
    virtual void CleanUp();

    void Render(GenericDevice& dev) {
        Assert(!_noDib && "No dib in DibImageClass::Render()");

        DiscreteImage::Render(dev);
    }
        
    Bool  DetectHit(PointIntersectCtx& ctx);

    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev);
    
    bool ValidColorKey(LPDDRAWSURFACE surface, DWORD *colorKey) {
        if(_colorRef != INVALID_COLORKEY) {
            *colorKey = DDColorMatch(surface, _colorRef);
            return TRUE;
        } else {
            *colorKey = INVALID_COLORKEY;  // xxx: won't work for argb
            return FALSE;
        }
    }
           
    virtual bool HasSecondaryColorKey() { return _2ndCkValid; }
    virtual void SetSecondaryColorKey(DWORD ck) {
        _2ndCkValid = true;
        _2ndClrKey = ck;
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(BitmapImage @ " << (void *)this << ")";
    }   
#endif

    virtual VALTYPEID GetValTypeId() { return DIBIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == DibImageClass::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }
  protected:

    // TODO:  Unclear if this stuff is appropriate for rendering
    // through non-GDI renderers like DirectDraw.  If not, we may need
    // to have some sort of multiple dispatching representation.
    
    HBITMAP             _hbm;
    COLORREF            _colorRef;

    // These are for Direct Draw
    Bool                _noDib;
  private:
    void ConstructWithHBM();

    bool  _2ndCkValid;
    DWORD _2ndClrKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\ddutil.h ===
#pragma once
#ifndef _DDUTIL_H
#define _DDUTIL_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    DirectDraw utility routines and functions.
*******************************************************************************/

//
// These typedef abstracts away the current IDirectDrawSurface
// interface we're using (1, 2, or 3)
//

/*
  typedef IDirectDrawSurface2 *LPDDRAWSURFACE;
typedef IDirectDrawSurface2 IDDrawSurface;
*/

typedef IDirectDrawSurface *LPDDRAWSURFACE;
typedef IDirectDrawSurface IDDrawSurface;

HRESULT DDCopyBitmap (IDDrawSurface*,HBITMAP, int x,int y, int dx,int dy);
DWORD   DDColorMatch (IDDrawSurface*, COLORREF);

LARGE_INTEGER GetFileVersion(LPSTR szPath);

#if DEVELOPER_DEBUG
    void hresult( HRESULT );
    VOID    reallyPrintDDError (HRESULT, const char *, int);
    #define printDDError(err)  reallyPrintDDError(err, __FILE__, __LINE__);
    void PalCRCs (PALETTEENTRY [], unsigned int &total, unsigned int &color);
    void DDObjFromSurface(
        IDirectDrawSurface *lpdds,
        IUnknown **lplpDD,
        bool doTrace,
        bool forceTrace = false);

    struct DDSurface;
    void showme(DDSurface *surf);    
    void showme2(IDirectDrawSurface *surf);    
    void showmerect(IDirectDrawSurface *surf,
                    RECT *r,
                    POINT offset);
#else
    VOID    reallyPrintDDError (HRESULT);
    #define printDDError(err)  reallyPrintDDError(err);
#endif

int     BPPtoDDBD (int bitsPerPixel); // XXX: DDRAW provides this function!
void    GetSurfaceSize(IDDrawSurface *surf,
                       LONG *width,
                       LONG *height);

IDirectDrawSurface  *DDSurf2to1(IDirectDrawSurface2 *dds);
IDirectDrawSurface2 *DDSurf1to2(IDirectDrawSurface  *dds);

// General conversion function that takes the source surface and
// copies to the destination surface.  This assumes that the two of
// are differing bit depths.  If they're not, it works anyhow.  If the
// writeToAlphaChannel flag is set, and the destination surface is 32
// bits, then we write in an 0xff to the alpha channel for the pixels
// that don't match the color key (if color key is specified) or all
// pixels (if color key isn't specified).
void
PixelFormatConvert(IDirectDrawSurface *srcSurf,
                   IDirectDrawSurface *dstSurf,
                   LONG width,
                   LONG height,
                   DWORD *sourceColorKey, // NULL if no color key
                   bool writeAlphaChannel);


/*****************************************************************************
Hacked workaround for Permedia cards, which have a primary pixel format
with alpha per pixel.  If we're in 16-bit, then we need to set the alpha
bits to opaque before using the surface as a texture.  For some reason,
an analogous hack for 32-bit surfaces has no effect on Permedia hardware
rendering, so we rely on hardware being disabled for such a scenario.
*****************************************************************************/
void SetSurfaceAlphaBitsToOpaque(IDirectDrawSurface *imsurf,
                                 DWORD colorKey,
                                 bool keyIsValid);


/////  Not-necessarily DDraw utilities.

#define INVALID_COLORKEY 0xFFFFFFFF

HBITMAP *UtilLoadImage(LPCSTR szFileName,
                       IStream * pstream,
                       int dx, int dy,
                       COLORREF **colorKeys, 
                       int *numBitmaps, 
                       int **delays,
                       int *loop);


// Convert a DA Point to a discrete integer based point assuming that
// we have an image centered about the DA origin, and that the pixel
// width and height are as given.
void CenteredImagePoint2ToPOINT(Point2Value	*point, // in
                                LONG		 width, // in
                                LONG		 height, // in
                                POINT		*pPOINT); // out

void CenteredImagePOINTToPoint2(POINT		*pPOINT, // in
                                LONG		 width, // in
                                LONG		 height, // in
                                Image		*referenceImg, // in
                                Point2Value	*pPoint2); // out

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dispdevi.h ===
#ifndef _DISPDEVI_H
#define _DISPDEVI_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Specify generic picture display device class and operations.

--*/

#include "appelles/dispdev.h"
#include "appelles/common.h"
#include "privinc/storeobj.h"
#include "privinc/drect.h"
#include "privinc/gendev.h"      // DeviceType

////////////////////////////////////////////////////////////////////
//
//  Generic display device class, meant to display either image or
//  geometry. 
//
////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE DisplayDev : public GenericDevice {
  public:
    virtual ~DisplayDev() {}

    // Beginning and ending of rendering an image often mean
    // operations
    virtual void BeginRendering(Image *img, Real opacity) = 0;
    virtual void EndRendering(DirtyRectState &d) = 0;

    DeviceType GetDeviceType() { return(IMAGE_DEVICE); }
    
    // Use these to retrieve the dimensions of the device
    virtual int GetWidth()  = 0;
    virtual int GetHeight() = 0;

#if _USE_PRINT
    virtual ostream& Print(ostream& os) const = 0;
#endif
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\discimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

     The Discrete Image class represents a constant image whose scope
     is much more than one frame and whose bits are cached in a
     surface kept by the device and are associate with the discrete image.

*******************************************************************************/


#ifndef _DISCIMG_H
#define _DISCIMG_H

#include "privinc/ddutil.h"
#include "privinc/probe.h"
#include "privinc/bbox2i.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"

struct DDSurface;
class Transform2;
class Bbox2;
class DirectDrawImageDevice;

class DiscreteImage : public Image {
  public:
    DiscreteImage() : _myHeap(GetHeapOnTopOfStack())  {
        _bboxReady = FALSE;
        _membersReady = FALSE;
        _resolution = -1;
        _width = _height = -1;
        _dev = NULL;
    }
    virtual ~DiscreteImage() {}
    
    virtual void Render(GenericDevice& dev) {
        //Assert( (_dev!=NULL) && "NULL _dev in DiscreteImage render");
        //Assert( (&dev == (GenericDevice *)_dev) &&  "Can only use DicreteImage with ONE dev");
        
        ImageDisplayDev &idev = (ImageDisplayDev &)dev;
        idev.RenderDiscreteImage(this);
    }

    const Bbox2 BoundingBox(void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, BoundingBox());
    }
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx) {
        Point2Value *lcPt = ctx.GetLcPoint();

        if (!lcPt) return FALSE; // singular transform
        
        return BoundingBox().Contains(Demote(*lcPt));
    }

    RECT *GetRectPtr() {
        Assert(_membersReady && "GetRectPtr called when members not ready");
        return &_rect;
    }
    
    const Bbox2 OperateOn(const Bbox2 &box) { return box; }

    virtual LONG GetPixelWidth() {
        Assert(_membersReady && "GetPixelWidth called when members not ready");
        return _width;
    }
    virtual LONG GetPixelHeight() {
        Assert(_membersReady && "GetPixelHeight called when members not ready");
        return _height;
    }

    Real  GetResolution() {
        Assert(_resolution>0 && "Invalid _resolution in DiscreteImage::GetResolution()");
        return _resolution;
    }

    virtual Bool NeedColorKeySetForMe() { return FALSE; }

    virtual bool ValidColorKey(LPDDRAWSURFACE surface,
                               DWORD *colorKey) {
        return FALSE;
    }

    virtual bool HasSecondaryColorKey() { return false; }
    virtual void SetSecondaryColorKey(DWORD ck) {}
    
    virtual void InitializeWithDevice(ImageDisplayDev *dev, Real res) {
        _dev = (DirectDrawImageDevice *)dev;
        if(_resolution < 0) _resolution = res;
    }

    virtual void InitIntoDDSurface(DDSurface *ddSurf,
                                   ImageDisplayDev *dev) = 0;

    virtual void GetIDDrawSurface(IDDrawSurface **os) { *os = NULL; }

    virtual DiscreteImage *IsPurelyTransformedDiscrete(Transform2 **theXform) {
        *theXform = identityTransform2;
        return this;
    }

    void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
    }

    virtual VALTYPEID GetValTypeId() { return DISCRETEIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == DiscreteImage::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }
  protected:

    DirectDrawImageDevice *GetMyImageRenderer() { return _dev; }

    // these all might need to go into the DDSurface class...
    Bbox2               _bbox;             // in meters
    Real                _resolution;       // in pixels per meter

    LONG                _width, _height;
    RECT                _rect;

    Bool                _bboxReady;
    Bool                _membersReady;
    
    DynamicHeap        &_myHeap;

    DirectDrawImageDevice *_dev;
};

#endif /* _DISCIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\drect.h ===
/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

     Header file for dirty rectangle implementation.

*******************************************************************************/

#ifndef _DRECT_H
#define _DRECT_H

#include "privinc/bbox2i.h"

class ImageWithBox {
  public:
    ImageWithBox() {
        // Default constructor needed for compiling under NT5 because
        // of usage in STL vectors.  Don't ever expect to use it. 
        Assert(!"Shouldn't be here.");
    }
    
    ImageWithBox(Image *img,
                 Bbox2& boxToCopy)
    {
        _image  = img;
        _box    = boxToCopy;
    }

    inline int operator==(ImageWithBox &m) {
        return (_image == m._image) && (_box == m._box);
    }

    Image *_image;
    Bbox2  _box; 
};

class BboxList {
  public:
    BboxList();
    ~BboxList();
    void Add(const Bbox2 box);
    void Add(ImageWithBox &ib);
    void Clear();

#if _DEBUG
    void Dump();
#endif  

    int             _count;
    vector<Bbox2>   _boxes;
};


class ConstImageList {
  public:
    ConstImageList();
    ~ConstImageList();
    void Add(Image *img, Bbox2& boxToCopy);
    void Clear();

#if _DEBUG
    void Dump();
#endif  

    int                   _count;
    vector<ImageWithBox>  _images;
};

// Traversal context
class DirtyRectCtx {
  public:
    DirtyRectCtx(BboxList        &dirtyRects,
                 int              lastSampleId,
                 ConstImageList  &constImages,
                 Bbox2&           targetBox);
    
    void AddDirtyRect(const Bbox2 rect);

    void AddToConstantImageList(Image *img,
                                Bbox2& boxToCopy);

    // fold in new box, return the old one.
    void   AccumulateClipBox(const Bbox2 clipBox);
    void   SetClipBox(const Bbox2 clipBox);
    Bbox2  GetClipBox();

    Transform2      *_accumXform;
    bool             _processEverything;
    int              _lastSampleId;
    BboxList&        _dirtyRects;
    ConstImageList&  _constImages;

  protected:
    Bbox2           _accumulatedClipBox;
    
};

// State maintained with the view.
class DirtyRectState {
  public:
    DirtyRectState();
    void Clear();
    void Swap();
    void CalculateDirtyRects(Image *theImage,
                             int lastSampleId,
                             Bbox2& targetBox);
    void ComputeMergedBoxes();
    Image *RewriteAsCrops(Image *origImage);

    int GetMergedBoxes(vector<Bbox2> **ppBbox2PtrList);

    Image *Process(Image *theImage,
                   int lastSampleId,
                   Bbox2 targetBox);

#if _DEBUG
    void Dump();
#endif  

  protected:
    void MergeDiffConstImages();

    bool           _drectsAisOld;
    bool           _lastMergedToOne;
    bool           _thisMergedToOne;
    Bbox2          _mergedBox;
    BboxList       _drectsA;
    BboxList       _drectsB;
    ConstImageList _constImagesA;
    ConstImageList _constImagesB;
    BboxList       _mergedBoxes;
};


#endif /* _DRECT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\error.h ===
#ifndef _ERROR_H
#define _ERROR_H

/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    This file is included for common
    inlined error functions

-------------------------------------*/
#include <ddraw.h>
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/ddutil.h"


#if _DEBUG

#define IfDDErrorInternal(ddrval,str) IfDDErrorInternalImpl(ddrval,str)
#define IfErrorInternal(cond,str) IfErrorInternalImpl(cond,str)

#else

#define IfDDErrorInternal(ddrval,str) IfDDErrorInternalImpl(ddrval)
#define IfErrorInternal(cond,str) IfErrorInternalImpl(cond)

#endif

inline void IfDDErrorInternalImpl(HRESULT ddrval DEBUGARG1(char *str))
{
    if (ddrval != DD_OK) {

        if (ddrval == DDERR_SURFACEBUSY || 
            ddrval == DDERR_CANTCREATEDC)
        {   RaiseException_UserError
                (DAERR_VIEW_SURFACE_BUSY, IDS_ERR_IMG_SURFACE_BUSY);
        }

        TraceTag((tagError, "Internal DDraw exception: %s", str)); 
        DebugCode(hresult(ddrval));
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_SURFACE_BUSY);
    }
}


inline void IfErrorInternalImpl(Bool cond DEBUGARG1(char *str))
{
    if(cond) {
        TraceTag((tagError, "Internal exception: %s", str)); 
        RaiseException_InternalError(DEBUGARG(str));
    }
}


#endif /* _ERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dsdev.h ===
#ifndef _DSDEV_H
#define _DSDEV_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    DirectSound device interface.

*******************************************************************************/
#include <privinc/soundi.h>
#include <privinc/snddev.h>
#include <privinc/bground.h>

class DSprimaryBuffer;
class DirectSoundProxy;
class DSstaticBuffer;

typedef map<Sound*, DSstaticBuffer*, less<Sound*> > DSMasterBufferList;
typedef map<Sound*, CComPtr<IStream>, less<Sound*> >
StreamFileList;

DirectSoundProxy *CreateProxy(DirectSoundDev *dsDev);

class DirectSoundProxy : public AxAThrowingAllocatorClass {
  public:
    ~DirectSoundProxy();
    static void Configure();   // called ONCE (by initModule) to setup
    static void UnConfigure(); // called ONCE (by DeinitModule) to tear down
    static DirectSoundProxy *CreateProxy(HWND hwnd);
    DSprimaryBuffer *GetPrimaryBuffer() { return(_primaryBuffer); }

    // expose the LPDIRECTSOUND interface!
    HRESULT CreateSoundBuffer(LPDSBUFFERDESC,
        LPLPDIRECTSOUNDBUFFER, IUnknown FAR *);
    HRESULT GetCaps(LPDSCAPS);
    HRESULT DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER, LPLPDIRECTSOUNDBUFFER);
    HRESULT SetCooperativeLevel(HWND, DWORD);
    HRESULT Compact();
    HRESULT GetSpeakerConfig(LPDWORD);
    HRESULT SetSpeakerConfig(DWORD);
    HRESULT Initialize(GUID *);

  private:
    static void CreateCom(HWND hwnd);
    void DestroyCom();

    static        CritSect *_mutex;
    static             int  _refCount;
    static    IDirectSound *_lpDirectSound;
    static DSprimaryBuffer *_primaryBuffer;  // keep so we may query format
    static       HINSTANCE  _hinst;          // library handle
};

class DSstreamingBufferElement;

class DirectSoundDev : public GenericDevice{
  public:
    friend SoundDisplayEffect;

    static void Configure();   // called ONCE (by initModule) to setup
    static void UnConfigure(); // called ONCE (by DeinitModule) to tear down
    DirectSoundDev(HWND hwnd, Real latentsy);
    ~DirectSoundDev();
    HWND GetHWND() { return(_hwnd); }
    void SetAvailability(bool available) { _dsoundAvailable = available; }
    void AddSound(LeafSound *sound, MetaSoundDevice *, DSstreamingBufferElement *);
    void RemoveSounds(MetaSoundDevice *devkey);
    void SetParams(DSstreamingBufferElement *ds,
                   double rate, bool doSeek, double seek, bool loop);

    DSstaticBuffer *GetDSMasterBuffer(Sound *snd);
    void RemoveDSMasterBuffer(Sound *snd);
    void AddDSMasterBuffer(Sound *snd, DSstaticBuffer *dsMasterBuffer);
    bool ReapElderlyMasterBuffers();

    void RemoveStreamFile(Sound *snd);
    void AddStreamFile(Sound *snd, CComPtr<IStream> istream);
    
    DeviceType GetDeviceType() { return(SOUND_DEVICE); }

    int              _latentsy;
    int              _jitter;
    int              _nap;             // length of time to nap between renders

    // render methods
    void RenderSound(Sound *snd);
    void BeginRendering();
    void EndRendering();
    
    bool               _dsoundAvailable; // keep track of resource

  protected:
    HWND             _hwnd;

  private:
    static BackGround      *_backGround;      // background synth renderer

    DSMasterBufferList     _dsMasterBufferList;
    StreamFileList         _streamList;
    CritSect               _dsMasterCS;
};

#endif /* _DSDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dxmatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DXMATL_H
#define _DXMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#if DEBUG || _MEMORY_TRACKING
#include "../../apeldbg/apeldbg.h"
#endif

#ifndef _DEBUGMEM
// Need this for _ASSERTE macro so we can specify no debug crt

#define _ATL_NO_DEBUG_CRT 1

#if _DEBUG //|| _MEMORY_TRACKING - this commenting is temporary (ref: BUG#15391)
#undef _ASSERTE
#define _ASSERTE(expr) \
        do { if (!(expr) && AssertImpl(__FILE__, __LINE__, #expr))\
             F3DebugBreak(); } while (0)
#else
#define _ASSERTE(expr) ((void)0)
#endif
#endif


#define _ATL_STATIC_REGISTRY 1

#ifdef _DEBUG

extern TAG tagATL;

inline void _cdecl AtlTrace2(LPCTSTR fmt, ...) {
    va_list args;
    va_start(args, fmt) ;
    if (TaggedTraceListEx (tagATL, 0, (char *)fmt, args)) {
        F3DebugBreak();
    }
}
#define ATLTRACE            AtlTrace2
#endif

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DACComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DEVELOPER_DEBUG
    void AddComPtr(void *ptr, const char * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DACComModule _Module;


#undef  min
#define min(a,b)  (((a) < (b)) ? (a) : (b))

#undef  max
#define max(a,b)  (((a) > (b)) ? (a) : (b))

#include <atlcom.h>
#include <atlctl.h>

#if _DEBUG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DEVELOPER_DEBUG
#if _DEBUG
        _Module.AddComPtr(this, GetName());
#else
        _Module.AddComPtr(this, NULL);
#endif
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DEVELOPER_DEBUG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;
// END OF COPIED CODE

// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

#endif /* _DXMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\dxxf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    DirectAnimation support for DXTransforms

*******************************************************************************/


#ifndef _DXXF_H
#define _DXXF_H

#include <dxtrans.h>

Bvr ConstructDXTransformApplier(IDXTransform *theXf,
                                IDispatch *theXfAsDispatch,
                                LONG numInputs,
                                Bvr *inputs,
                                Bvr  evaluator);

HRESULT DXXFAddBehaviorPropertyToDXTransformApplier(BSTR property,
                                                    Bvr  bvrToAdd,
                                                    Bvr  bvrToAddTo);

#endif /* _DXXF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\except.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Exception hierarchy

*******************************************************************************/


#ifndef _EXCEPT_H
#define _EXCEPT_H

#include "appelles/common.h"
#include <stdarg.h>

// useful defines...
#if _DEBUG    
#define DEBUGARG(x) x
#define DEBUGARG1(x) ,x
#define DEBUGARG2(a,b) a,b
#else
#define DEBUGARG(x)
#define DEBUGARG1(x)
#define DEBUGARG2(a,b)
#endif

//////////////////////////////////////////////////////////////////////
////   SEH DEFINES
//////////////////////////////////////////////////////////////////////

typedef DWORD daExc;

#define      _EXC_CODES_BASE                  0xE0000000

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// IF YOU ADD AN EXCEPTION BELOW YOU MUST UPDATE THE
// _EXC_CODES_END DEFINE
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

const daExc  EXCEPTION_DANIM_INTERNAL=        _EXC_CODES_BASE + 0x0;
const daExc  EXCEPTION_DANIM_USER=            _EXC_CODES_BASE + 0x1;
const daExc  EXCEPTION_DANIM_RESOURCE=        _EXC_CODES_BASE + 0x2;
const daExc  EXCEPTION_DANIM_OUTOFMEMORY=     _EXC_CODES_BASE + 0x3;
const daExc  EXCEPTION_DANIM_DIVIDE_BY_ZERO=  _EXC_CODES_BASE + 0x4;
const daExc  EXCEPTION_DANIM_STACK_FAULT=     _EXC_CODES_BASE + 0x5;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// IF YOU ADD AN EXCEPTION ABOVE YOU MUST UPDATE THE
// _EXC_CODES_END DEFINE
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#define      _EXC_CODES_END                   _EXC_CODES_BASE + 0x5



#define EXCEPTION(t) (GetExceptionCode() == t ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
#define RETHROW  RaiseException( GetExceptionCode(),0,0,0 )
#define HANDLE_ANY_DA_EXCEPTION ( \
  GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ?  \
  EXCEPTION_CONTINUE_SEARCH : \
  _HandleAnyDaException( GetExceptionCode() ) )

DWORD _HandleAnyDaException( DWORD );


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


/**************************   Exception Raising functions  ****************/
// Internal
#if _DEBUG
#define RaiseException_InternalError(str)  _RaiseException_InternalError(str)
#define RaiseException_InternalErrorCode(code, str) _RaiseException_InternalErrorCode(code, str)
#else
#define RaiseException_InternalError(str)  _RaiseException_InternalError()
#define RaiseException_InternalErrorCode(code, str) _RaiseException_InternalErrorCode(code)
#endif

void _RaiseException_InternalError(DEBUGARG(char *m));
void _RaiseException_InternalErrorCode(HRESULT code DEBUGARG1(char *m));

// User
void RaiseException_UserError();
void RaiseException_UserError(HRESULT result, int resid, ...);

// Resource
void RaiseException_ResourceError();
void RaiseException_ResourceError(char *m);
void RaiseException_ResourceError(int resid, ...);

// Surface Cache 
void RaiseException_SurfaceCacheError(char *m);

// Hardware
void RaiseException_StackFault();
void RaiseException_DivideByZero();

// Memory
#if _DEBUG
#define RaiseException_OutOfMemory(msg, size) _RaiseException_OutOfMemory(msg, size)
#else
#define RaiseException_OutOfMemory(msg, size) _RaiseException_OutOfMemory()
#endif

void _RaiseException_OutOfMemory(DEBUGARG2(char *msg, int size));

/////////////////////// Functions /////////////////////////

/*********************   Memory Allocators   ************************/

/*** Usage

  Here's the deal.  In general, we want to be able to call "new"
  without having to check the return value, and be confident in its
  success, or, otherwise, it will raise an exception.

  The problem with overriding the global new handler to do this is
  that some legacy code may count on NULL being returned, yet we would
  throw an exception, not giving a chance to the code that checks the
  return value.

  Here is how we resolve this problem:

  Note that there are these classes of objects that you allocate: 
  
  - AxAValue's -- on our own transient heap, caller can ignore result
    of "new" 
  - GCObj -- overrides new and delete for free list, call can ignore
    result. 
  - Other AxA objects that we define... we can derive these for our
    own class that overrides "new" to make it throw.  This class is
    AxAThrowingClass, as defined below.  Caller can ignore this result
    as well.
  - External classes that we don't originally provide (don't derive
    from AxAThrowingClass, or primitive types (like char, int).  These
    need to use the following special macros that behave just like
    "new" does, but they throw an ExcOutOfMemory exception if they
    fail.  Here are some examples:
    
       char *c = THROWING_ARRAY_ALLOCATOR(char, 50);
       WeirdExternalClass *w = THROWING_ALLOCATOR(WeirdExternalClass);

  Finally, legacy or inherited code can just go on calling "new" and
  checking the return type as they normally would.

  So, all of the above boils down to the following rules for our
  development methodology:

  * If you see a call to "new", and the return value is not checked to
    be sure it's not NULL, then the object being allocated had better:
       - derive from AxAValue
       - derive from GCObj
       - derive from AxAThrowingClass
    if it doesn't, then the code is bogus.

  * If you want to allocate an object that isn't one of the three
    classes above, and don't want to check the return type, then you
    had better use the THROWING_ALLOCATOR or THROWING_ARRAY_ALLOCATOR
    macros.
    
***/

// Derive classes from this class that should throw an exception when
// they cannot be allocated because the free store is exhausted.
class AxAThrowingAllocatorClass {
  public:
#if _DEBUGMEM     
    void *operator new(size_t s, int block, char *filename, int line );
#endif    

    void *operator new(size_t s);
    void *operator new(size_t s, void *ptr);
};

// Throws an out of memory exception if the ptr is NULL, else returns
// ptr. 
extern void *ThrowIfFailed(void *ptr);

#define THROWING_ALLOCATOR(type) \
  (type *)(ThrowIfFailed((void *)(NEW type)))
  
#define THROWING_ARRAY_ALLOCATOR(type, num) \
  (type *)(ThrowIfFailed((void *)(NEW type[num])))

/*********************   Resource Grabbers   ************************/

// There are no common classes for resource grabbers.  See
// dddevice.cpp, and look for DCReleaser.  This is the model to
// follow, and there is no need for any other levels.

/*********************   Resource Grabbers   ************************/

// Thread local storage of error codes - once error is reported the
// error should be clear so the memory is freed
      
HRESULT DAGetLastError();
LPCWSTR DAGetLastErrorString();
void DAClearLastError();
void DASetLastError(HRESULT reason, LPCWSTR msg);
inline void DASetLastError(HRESULT reason, LPCSTR msg)
{ USES_CONVERSION; DASetLastError(reason, A2W(msg)); }
void DASetLastError(HRESULT reason, int resid, ...);

#endif /* _EXCEPT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\fileutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    General file utilities

*******************************************************************************/

#ifndef _FILEUTIL_H
#define _FILEUTIL_H

// Decompress GZipped files, from the input file to the output file
// (output file will be newly created).  Return TRUE or FALSE.  Note
// that this only succeeds if GZIP used the "DEFLATE" compression
// style, which it doesn't always do.  The outfile name is a temporary
// filename that's created by the routine.  Need to pass in a big
// enough buffer to hold the name (1024 should do it).

BOOL MSDecompress(LPSTR pszInFile, LPSTR pszOutFile);

#endif /* _FILEUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\gendev.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Generic Device

*******************************************************************************/


#ifndef _GENDEV_H
#define _GENDEV_H

#include "except.h"

enum DeviceType {
    SOUND_DEVICE,
    IMAGE_DEVICE,
    GEOMETRY_DEVICE
};


// forward decls
class DynamicHeap;
extern DynamicHeap &GetHeapOnTopOfStack();

class GenericDevice : public AxAThrowingAllocatorClass {
  public:
    GenericDevice() {}

    virtual ~GenericDevice() {}

    // query defaults to false except for audio devices which overload it
    // XXX  Maybe we should return an enum one day?
    //virtual bool SoundDevice() { return FALSE; }
    virtual DeviceType GetDeviceType() = 0;

    void ResetContext() {
    }
};


#endif /* _GENDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\geometry.h ===
#ifndef _GEOMETRY_H
#define _GEOMETRY_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Definitions and declarations for geometric utility functions.

*******************************************************************************/

#include "d3drmdef.h"

    // Referenced Structures

class Point3Value;
class Vector3Value;
class HitInfo;

    // This function, given three triangle vertices and a point P guaranteed to
    // be inside the triangle, returns the barycentric coordinates of that
    // point with respect to the vertices.

void GetContainedBarycentricCoords
    (    Point3Value vertices[3],     // Triangle Vertices Containing P
         Point3Value P,
         Real barycoords[3]);


/*****************************************************************************
This routine starts with a facet defined by a triangle fan about the first
vertex, and a point P on the face.  It determines which triangle in the face
contains the point P, and returns the three vertex positions and vertex
surface coordinates in the triPos[] and triUV[] arguments, respectively.
*****************************************************************************/

int GetFacetTriangle (
    Point3Value   P,           // Point In Facet
    unsigned int  N,           // Number of Facet Vertices
    D3DRMVERTEX  *fVerts,      // Facet Vertices
    Point3Value   triPos[3],
    Point2Value  *triUV);		// Containing-Triangle Surface Coordinates

void GetTriFanBaryCoords(
    Point3Value   P,           // Point In Facet
    unsigned int  N,           // Number of Facet Vertices
    D3DRMVERTEX  *fVerts,      // Facet Vertices
    Real          barycoords[3],
    int          *index);

// Get the image coordinates of the picked texture map.

Point2Value *GetTexmapPoint (HitInfo &hit);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\geomimg.h ===
#ifndef _GEOMIMG_H
#define _GEOMIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

Projected Geometry Image class declaration

-------------------------------------*/

#include <appelles/geom.h>
#include <privinc/geomi.h>

//////////////  Image from projected geometry  ////////////////////

class ProjectedGeomImage : public Image {
  public:

    ProjectedGeomImage(Geometry *g, Camera *cam);

    virtual void Render(GenericDevice& dev);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, BoundingBox());
    }
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 BoundingBox(void);
    
    // identity operation
    const Bbox2 OperateOn(const Bbox2 &box) { return box; }

    Bool  DetectHit(PointIntersectCtx& ctx);

#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "ProjectedGeomImage (" << _geo << ", <TODO: CAMERA>)";
    }
#endif

    int Savings(CacheParam& p);

    virtual VALTYPEID GetValTypeId() { return PROJECTEDGEOMIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == ProjectedGeomImage::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc);

    AxAValue _Cache(CacheParam &p);
    
  protected:
    Geometry *_geo;
    Camera   *_camera;
    Bbox2     _bbox;
    bool      _bboxIsSet;
};


#endif /* _GEOMIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\helpm.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\gradimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _GRADIMG_H
#define _GRADIMG_H

extern Image *NewMulticolorGradientImage(int num, double *offsets, Color **clrs);

class MulticolorGradientImage : public Image {
  public:
    enum gradientType {
        radial,
        linear
    };
    
    friend Image *NewMulticolorGradientImage(
        int numOffsets,
        double *offsets,
        Color **clrs,
        MulticolorGradientImage::gradientType type);

  protected:
    ~MulticolorGradientImage() {
        DeallocateFromStore(_offsets);
        DeallocateFromStore(_clrs);
    }

    MulticolorGradientImage() {
        _flags |= IMGFLAG_CONTAINS_GRADIENT;
    }

    void PostConstructorInitialize(int num, double *offsets, Color **clrs)
    {
        _numOffsets = num;
        _offsets = offsets;
        _clrs = clrs;

        //Real extent = _offsets[_numOffsets-1];
        // TODO: hm... should this be universe bbox2 ??
        // if so, return universeBbox2 from BoundingBox(){}
        //_bbox = NEW Bbox2(-extent, -extent, extent, extent);
    }
    
  public:

    void Render(GenericDevice& dev) {
        ImageDisplayDev &idev = SAFE_CAST(ImageDisplayDev &, dev);
        idev.RenderMulticolorGradientImage(this, _numOffsets, _offsets, _clrs);
    }

    const Bbox2 BoundingBox(void) {
        //return _bbox;
        return UniverseBbox2;
    }

    #if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        //return _bbox;
        return UniverseBbox2;
    }
    #endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {
        return box;
    }

    Bool  DetectHit(PointIntersectCtx& ctx) {
        return TRUE;  // we're infinite extent!
    }

    int Savings(CacheParam& p) { return 2; }
    
    #if _USE_PRINT
    ostream& Print(ostream& os) { return os << "MulticolorGradientImage"; }
    #endif
    
    virtual void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
        for (int i=0; i<_numOffsets; i++) {
            (*proc)(_clrs[i]);
        }
    }

    // OK, I'm cheating here.  what *should* happen is the image
    // device gets passed down, the leaf ASKS the image device if IT
    // can render the leaf image clipped natively!
    virtual bool CanClipNatively() { return true; }


    virtual gradientType GetType()=0;
    
  private:
    //Bbox2 _bbox;
    int _numOffsets;
    Color **_clrs;
    double *_offsets;
};


class RadialMulticolorGradientImage : public MulticolorGradientImage {

    friend Image *NewMulticolorGradientImage(
        int numOffsets,
        double *offsets,
        Color **clrs,
        MulticolorGradientImage::gradientType type);
    
  private:
    RadialMulticolorGradientImage() {}
    
  public:
    gradientType GetType() { return MulticolorGradientImage::radial; }
};

class LinearMulticolorGradientImage : public MulticolorGradientImage {

    friend Image *NewMulticolorGradientImage(
        int numOffsets,
        double *offsets,
        Color **clrs,
        MulticolorGradientImage::gradientType type);

  private:
    LinearMulticolorGradientImage() {}

  public:
    gradientType GetType() { return MulticolorGradientImage::linear; }
};


#endif /* _GRADIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\geomi.h ===
#pragma once
#ifndef _GEOMI_H
#define _GEOMI_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Abstract implementation class for the Geometry *type

*******************************************************************************/

#include "appelles/geom.h"
#include "appelles/sound.h"
#include "privinc/storeobj.h"
#include "privinc/vec3i.h"
#include "privinc/bbox3i.h"


    // Forward Declarations

class GeomRenderer;
class LightContext;
class SoundTraversalContext;
class RayIntersectCtx;
class FramesWithMaterials;

    // Geometry Flags

    // When adding new flags, update GEOFLAG_ALL as well.

const int GEOFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT = (1L << 0);
const int GEOFLAG_CONTAINS_OPACITY                = (1L << 1);
const int GEOFLAG_CONTAINS_LIGHTS                 = (1L << 2);

const int GEOFLAG_ALL                             = (1L << 3) - 1;


class ATL_NO_VTABLE Geometry : public AxAValueObj
{
  public:

    Geometry ();
    virtual ~Geometry() {}  // Needed to ensure proper hierachical destruction.

    // Collect all light sources in a geometry.
    virtual void CollectLights (LightContext &context) = 0;

    // Collect all sound sources in a geometry.
    virtual void  CollectSounds (SoundTraversalContext &context) = 0;

    // Pre derive all textures in scene graph to cached in
    // texturedGeometry classes
    virtual void  CollectTextures(GeomRenderer &device) = 0;

    // Using the ray in the context, intersect with the geometry, side
    // effecting the context as appropriate.
    virtual void  RayIntersect (RayIntersectCtx &context) = 0;

    // Produces a printed representation on the debugger.
    #if _USE_PRINT
        virtual ostream& Print(ostream& os) = 0;
    #endif

    // extract the bounding volume of the object.  By default, this is
    // the "all encompassing" bounding volume, that says nothing about
    // the true bounds of the geometry.  Subclasses that do things
    // differently will supply different bounding volumes.
    virtual Bbox3 *BoundingVol() = 0;

    // TODO: Because we don't have multiple dispatching, we may need
    // to add more methods here later as we come up with more
    // operations.  Or we may want to adopt multiple dispatching to
    // make the system more extensible for the addition of operations.

    virtual DXMTypeInfo GetTypeInfo() { return GeometryType; }

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val);

    VALTYPEID GetValTypeId() { return GEOMETRY_VTYPEID; }

    void SetCreationID(long t) { _creationID = t; }
    long GetCreationID() { return _creationID; }

    DWORD GetFlags (void);

  protected:
    DWORD _flags;
    long  _creationID;
};


inline DWORD Geometry::GetFlags (void)
{
    return _flags;
}


    // Print a representation of a representation to the debugger.

#if _USE_PRINT
    ostream& operator<< (ostream& os,  Geometry &geometry);
#endif

    // Wrap a bounding volume around a geometry.

Geometry *BoundedGeometry (Bbox3 *bvol, Geometry *geom);



/*****************************************************************************
This class can be subclassed to specify attribution data for a particular
geometry.  This superclass encompasses, for example, material, light and sound
attribution.
*****************************************************************************/

class AttributedGeom : public Geometry
{
  public:

    AttributedGeom (Geometry *geometry);

    // The Render() method may be invoked for several different reasons,
    // including sound start, sound stop, and 3D rendering.
    void Render (GenericDevice& device);

    // This method is used to do 3D rendering on the attributed geometry.
    virtual void Render3D (GeomRenderer&);

    // The default behavior for sound-rendering the attributed geometry is to
    // ignore the attribute and just render the geometry.  This case will be
    // used, for example, if color attributes are applied to the geometry.
    void CollectSounds (SoundTraversalContext &context);

    // The default case to collect the lights from the geometry is to ignore
    // the attribute and collect the lights from the geometry.  This should
    // happen when the attribute does not affect lights in any way (e.g.
    // specular color, or pitch).
    void CollectLights (LightContext &context);

    // Default is to collect textures in member geometry
    void  CollectTextures(GeomRenderer &device) {
        _geometry->CollectTextures(device);
    }

    // The default case for performing ray intersection simply ignores
    // the attribute and proceeds on the geometry.  This is
    // overridden by some attributes.
    void RayIntersect (RayIntersectCtx &context);

    // The default action for the BoundingVol method is to ignore the attribute
    // and just get the bounding volume of the geometry.  This applies for
    // attributes like diffuse color or pitch.
    virtual Bbox3 *BoundingVol (void);

    AxAValue _Cache(CacheParam &p);

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_geometry);
    }

  protected:

    Geometry *_geometry;     // The attributed geometry.
};



/*****************************************************************************
This structure is used to encapsulate the data needed to construct a TriMesh.
Note that only one of the float/Bvr pairs for each vertex property should be
non-null.
*****************************************************************************/

class TriMeshData
{
  public:

    TriMeshData (void)
        : numTris(0), numIndices(0), indices(NULL),
          numPos(0),  vPosFloat(NULL),  vPosPoint3(NULL),
          numNorm(0), vNormFloat(NULL), vNormVector3(NULL),
          numUV(0),   vUVFloat(NULL),   vUVPoint2(NULL)
    {
    }

    int    numTris;        // Number of Triangles in Mesh

    int    numIndices;     // Number of Triangle Vertex Indices
    int   *indices;        // Triangle Vertex Indices

    int    numPos;         // Number of Vertex Positions
    float *vPosFloat;      // Vertex Positions (array of Float Triple)
    Bvr   *vPosPoint3;     // Vertex Positions (array of Point3)

    int    numNorm;        // Number of Vertex Normals
    float *vNormFloat;     // Vertex Normals (array of Float Triple)
    Bvr   *vNormVector3;   // Vertex Normals (array of Vector3)

    int    numUV;          // Number of Vertex Surface Coords
    float *vUVFloat;       // Vertex Surface Coords (array of Float Tuple)
    Bvr   *vUVPoint2;      // Vertex Surface Coords (array of Point2)
};

Bvr TriMeshBvr (TriMeshData&);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\frontend.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Frontend Declarations

*******************************************************************************/


#ifndef _FRONTEND_H
#define _FRONTEND_H

class ExpImpl ;
typedef ExpImpl * Exp ;

class IncludeImpl ;
typedef IncludeImpl * Include ;

class AstImpl ;
typedef AstImpl * Ast ;

class TypeExpImpl ;
typedef TypeExpImpl * TypeExp ;

class AxAModuleImpl;
typedef AxAModuleImpl *AxAModule;

// Identifiers

typedef char * Ident;
#define IDEQ(s1, s2) (s1 == s2)
#define IdentToStr(id) ((char *) id)

Ident MakeIdent(char *str);

class idcmp {
public: 
  bool operator() (const char *x,const char *y) const
          { return(strcmp(x,y) < 0); }
};
 
typedef set <char *,idcmp> IdSet ;

typedef list <char *> IdList;

extern Ident underscoreId ;

struct LocInfoImpl : public StoreObj
{
    LocInfoImpl(char * url,
                DWORD startline,
                DWORD startcol,
                DWORD endline,
                DWORD endcol)
    : _url(url),
      _startLine(startline),
      _startCol(startcol),
      _endLine(endline),
      _endCol(endcol)
    {}
    
    ostream& Print(ostream& os) ;
    
    friend ostream& operator<<(ostream& os, LocInfoImpl & loc)
    { return loc.Print(os) ; }
    
    char * _url ;
    DWORD _startLine ;
    DWORD _startCol ;
    DWORD _endLine ;
    DWORD _endCol ;
} ;

typedef LocInfoImpl * LocInfo ;

// This can handle a NULL locinfo
ostream& operator<<(ostream& os, LocInfo locinfo);

TypeExp ParseTypeExp (char * typeString) ;

// Module functions

enum SourceType {
    ST_STRING  = 0,
    ST_FILE    = 1,
    ST_URL     = 2,
    ST_STREAM  = 3,
} ;

struct Source
{
    SourceType sourceType ;
    char * name ;
    void * src ;
} ;

AxAModule EmptyAxAModule() ;
AxAModule AxALoadURL (AxAModule module, char * url) ;
AxAModule AxALoadFile (AxAModule module, char * filename) ;
AxAModule AxALoadString (AxAModule module, char * name, char * str) ;
AxAModule AxALoadStream (AxAModule module, char * name, istream & stream) ;
AxAModule AxALoad (AxAModule module, Source & src) ;
TypeExp AxAGetTypeExp (AxAModule module, Ident id) ;
IR AxAGetIR (AxAModule module, Ident id) ;
IR AxAMakeExp (AxAModule module, IR exp) ;
void AxAAddOverloads (AxAModule mod) ;

// If the callback returns non-zero the function returns the same
// value 
typedef HRESULT (* AxAEnumModuleCB)(AxAModule module, LPVOID userdata) ;

// Enumerates all loaded modules - the current one is always first
HRESULT AxAEnumModule (AxAModule module,
                    AxAEnumModuleCB cb,
                    LPVOID userdata) ;

// If the callback returns non-zero the function returns the same
// value 
typedef HRESULT (* AxAEnumEnvCB)(char * name,
                                 Ident id,
                                 TypeExp typeexp,
                                 IR ir,
                                 LPVOID userdata) ;

HRESULT AxAEnumEnv (AxAModule module,
                    AxAEnumEnvCB cb,
                    LPVOID userdata) ;

ostream& operator<<(ostream& os, AxAModule mod);

// Type functions

// If both are NULL this returns TRUE
BOOL EqualTypes (TypeExp t1, TypeExp t2) ;
ostream& operator<<(ostream& os, TypeExp typeexp);

// This returns only the toplevel type and does not traverse 
// type operators
char * GetSimpleTypeString(TypeExp typeexp);

#endif /* _FRONTEND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\heaper.h ===
#ifndef _HEAPER_H
#define _HEAPER_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

__*/

#include <privinc/storeobj.h>

// This class is a sort of container for dynamic heaps (see storage.h)
// and it's primary use it to allow automatic destruction and construction
// of heaps (heap references actually) on the stack.  Before, if
// you allocate a heap and some function you call throws an exception
// your heap will not be deallocated.  But if you heap lives on the
// stack as an automatic variable, an exception unravels the stack
// and calls the destructor on your heap.
// It is the user's responsibility to ensure that the heap
// stack is consistent upon exit (i.e.: the heap is popped
// off)

class Heaper {

  public:
    Heaper(DynamicHeap *_heap, Bool del=FALSE) : heap(_heap), deleteOnExit(del) {}
    ~Heaper() { 
        if(heap != NULL)
            if(deleteOnExit==TRUE) delete heap; 
            else heap->Reset(TRUE);
    }

  private:               
    DynamicHeap *heap;
    Bool deleteOnExit;
};

#endif /* _HEAPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\helpds.h ===
#ifndef _HELPDS_H
#define _HELPDS_H

#include <wtypes.h>
#include <dsound.h>
#include "privinc/mutex.h"
#include "privinc/hresinfo.h"
#include "privinc/dsdev.h"
#include "privinc/pcm.h"
#include "privinc/util.h"    // TIME_DSOUND
#include "privinc/server.h"  // GetCurrentTimers
#include "privinc/htimer.h"  // TimeStamp


// Use TDSOUND for checking DirectSound error return codes.
#if _DEBUG
    #define TDSOUND(x) TIME_DSOUND (CheckReturnCode(x,__FILE__,__LINE__,true))
#else
    #define TDSOUND(x) TIME_DSOUND (CheckReturnCode (x,true))
#endif

class DirectSoundProxy;

class DSbuffer : public AxAThrowingAllocatorClass {
  public:
    PCM pcm;
    DSbuffer() {initialize();}
    virtual ~DSbuffer();
    void initialize();  // NOTE: must be called after wavSampleRate is set!
    void updateStats();

    void writeBytes(void *buffer, int bytes);
    void writeFrames(void *buffer, int frameCount) {
        writeBytes(buffer, pcm.FramesToBytes(frameCount)); }

    void writeSilentBytes(int byteCount);
    void writeSilentFrames(int frameCount){
        writeSilentBytes(pcm.FramesToBytes(frameCount)); }

    // queries
    int bytesFree();
    int framesFree() { return(pcm.BytesToFrames(bytesFree())); }

    //int isPlaying(){return(playing);}
    int isPlaying();
    Real getMediaTime();
    int getSampleRate() { return(pcm.GetFrameRate()); }
    IDirectSoundBuffer *getBuffer() { return(_dsBuffer); }
    int TotalFrames() { return(pcm.GetNumberFrames()); }

    // controls
    void SetGain(double gain);
    void SetPan(double pan, int direction);
    void setPitchShift(int frequency);
    virtual void setPtr(int bytePosition);
    void play(int loop);
    void stop();

    static int _minDSfreq;
    static int _maxDSfreq;
    static int _minDSpan;
    static int _maxDSpan;
    static int _minDSgain;
    static int _maxDSgain;

    // misc
#if _DEBUG
    void printBufferCapabilities();
#endif

    IDirectSoundBuffer *_dsBuffer; // the sound's dsBuffer (2ndry, or duplicate)
    static int canonicalSampleRate;
    static int canonicalSampleBytes;

    BOOL  _allocated;              // has the buffer been allocated
    BOOL   playing;                // has the sound buffer been Played yet?
    BOOL   duplicate;              // secondary buffer or a duplicate
    BOOL  _paused;                 // this is needed to dissambiguate ended
    int   _loopMode;               // so we know what loopmode to restore
    int   _flushing;               // how many frames flushed in flush mode

    DWORD  tail;  // XXX move this to the streaming buffer!

    int    outputFrequency;

    int    _currentAttenuation;
    int    _currentFrequency;
    double _currentPan;

  protected:
    void CreateDirectSoundBuffer(DirectSoundProxy *dsProxy, bool primary);
    void CopyToDSbuffer(void *frames, int tail, int numBytes); 
    void ClearDSbuffer(int numBytes, char value);
    int  dBToDSounddB(double dB);

  private:
    void FillDSbuffer(int tail, int numBytes, char value);

    // buffer statistics (used to keep track of the media time)
    Bool     _firstStat;
    int      _lastHead;           // position of the head ptr on the last poll
    LONGLONG _bytesConsumed;      // frames consumed by dsound so far
    Mutex    _byteCountLock;      // mutex protecting the stats!
};


class DSstreamingBuffer : public DSbuffer {
  public:
    DSstreamingBuffer(DirectSoundProxy *dsProxy, PCM *pcm);
};


class DSprimaryBuffer : public DSbuffer {
  public:
    DSprimaryBuffer(HWND hwnd, DirectSoundProxy *dsProxy);
};


class DSstaticBuffer : public DSbuffer {
  public:
    // standard
    DSstaticBuffer(DirectSoundProxy *dsProxy, PCM *pcm, unsigned char *bufr);

    // duplicate
    DSstaticBuffer(DirectSoundProxy *dsProxy, IDirectSoundBuffer *dsBuffer);

    DirectSoundProxy *GetDSProxy() { return _dsProxy; }

    virtual void setPtr(int bytePosition);

    void   ResetTimeStamp() { _timeStamp.Reset(); }
    double GetAge()         { return(_timeStamp.GetAge()); }
    
  private:
    DirectSoundProxy *_dsProxy;
    TimeStamp         _timeStamp; // not initialized till first use
};


extern "C" {

// helper functions

// XXX move this to the device class dsdev!
#if _DEBUG
void printDScapabilities(DirectSoundProxy *dsProxy);
#endif


void
DSbufferCapabilities(DirectSoundProxy *dsProxy, int *channels,
    int *sampleBytes,  int *sampleRate);

}   //extern "C"


#endif /* _HELPDS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\helpaa.h ===
/**********************************************************************
AudioActive helped functions
**********************************************************************/
#ifndef _HELPAA_H
#define _HELPAA_H

#include <wtypes.h>
#include <msimusic.h>
#include "privinc/aadev.h"

// signature for fns we need to loadLibrary...
typedef HRESULT (WINAPI *SimpleInitFn) 
    (IAAEngine **engine, IAANotifySink *notifySink, IAALoader *loader);
typedef HRESULT (WINAPI *LoadSectionFn)
    (IAAEngine *engine, LPCTSTR pszFileName, IAASection **section);
typedef void (WINAPI *SetAAdebugFn) (WORD debugLevel);
typedef HRESULT (WINAPI *PanicFn) (IAAEngine *engine);

class AAengine {
  public:
    AAengine();
    ~AAengine();
    void SetRate(double rate);
    void SetGain(double gain);
    void Stop();
    void Pause();    // stop the realTime object
    void Resume();   // start/resume the realTime object
    void RegisterSink(IAANotifySink *sink);
    void LoadSectionFile(char *fileName, IAASection **section);
    void PlaySection(IAASection *section);
    void AllNotesOff();

  private:
    HINSTANCE       _aaLibrary;   // handle to aactive dll

    IAARealTime    *_realTime;
    //IClock       *_clock;
    IAAMIDIOut     *_MIDIout;
    // AudioActiveDev *_aadev;    // keep this around so we may return the eng
    IAAEngine      *_engine;
    double          _currentRate; // current rate being used
    Bool            _paused;      // determine playing but paused state rate(0)

    // fn pointers for msimusic entrypoints
    SimpleInitFn    _simpleInit;
    LoadSectionFn   _loadSectionFile;
    SetAAdebugFn    _setAAdebug;
    PanicFn         _panic;

    void SimpleInit();
    void LoadDLL(); // cause the msimusic dll to be loaded
};

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// helper functions
void stopAAengine(IAAEngine *engine, AAFlags mode);
void registerAAsink(IAAEngine *realTime, IAANotifySink *sink);
void playAAsection(IAAEngine *engine, IAASection *section);
void setAArelTempo(IAARealTime *realTime, double tempo);
void setAArelVolume(IAARealTime *realTime, double volume);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */


#endif /* _HELPAA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\htimer.h ===
#ifndef _HTIMER_H
#define _HTIMER_H

/*-------------------------------------

Copyright (c) 1996-98 Microsoft Corporation

Abstract:

    HiresTimer Class

-------------------------------------*/

#include "privinc/util.h" // GetPerfTimeCount, Tick2Sec

class ATL_NO_VTABLE HiresTimer : public AxAThrowingAllocatorClass
{
  public:
    HiresTimer() {}
    virtual ~HiresTimer() {}
    virtual double GetTime()      = 0;
    virtual double GetFrequency() = 0;
    virtual void   Reset()        = 0;
};


HiresTimer& CreateHiresTimer();


class TimeStamp
{
  public:
    TimeStamp() : _timeStamp(-1.0) {} // initialy set to 'illegal value'
    void   Reset();          // resets timestamp to present time
    double GetTimeStamp();
    double GetAge();

  private:
    //double GetCurrentTime() { return(Tick2Sec(GetPerfTickCount())); }
    double GetCurrentTime() { return(GetLastSampleTime()); }
    double _timeStamp;
};

#endif /* _HTIMER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\hresinfo.h ===
#ifndef _HRESINFO_H
#define _HRESINFO_H
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Convert HRESULT to English error string.  Only used in DEBUG builds

*******************************************************************************/

#include "winerror.h"

#if DEVELOPER_DEBUG 

        // Error Information Structure

    struct HresultInfo
    {   HRESULT  hresult;       // HRESULT Value
        char    *hresult_str;   // HRESULT Macro As String
        char    *explanation;   // Explanation String
    };

        // Error Information Query

    HresultInfo *GetHresultInfo (HRESULT code);

#endif

    // HRESULT standard check routine.  If HRESULT indicates error, this
    // function decodes the value and throws an exception if except is true
    // or just dumps the result to the debug output stream if except is false.

#if _DEBUG

    HRESULT CheckReturnImpl (HRESULT, char *file, int line, bool except);

    inline HRESULT CheckReturnCode (HRESULT H, char *F, int L, bool E=false)
    {   if (FAILED(H)) CheckReturnImpl (H,F,L,E);
        return H;
    }

#else

    HRESULT CheckReturnImpl (HRESULT, bool except);

    inline HRESULT CheckReturnCode (HRESULT H, bool E=false)
    {   if (FAILED(H)) CheckReturnImpl (H,E);
        return H;
    }

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\helps.h ===
#ifndef _HELPS_H
#define _HELPS_H

#include <wtypes.h>
#include <math.h>
#include "privinc/util.h"

inline unsigned int
SecondsToBytes(Real seconds, int sampleRate,
               int numChannels, int bytesPerSample);

inline Real
FramesToSeconds(int frames, int sampleRate);


inline Real
BytesToSeconds(unsigned int bytes, int sampleRate,
               int numChannels, int bytesPerSample);

inline unsigned int
BytesToFrames(unsigned int bytes, int numChannels, int bytesPerSample);

inline unsigned int
SamplesToBytes(unsigned int samples, int numChannels, int bytesPerSample);

inline unsigned int
FramesToBytes(unsigned int frames, int numChannels, int bytesPerSample);

double LinearTodB(double linear);

double DBToLinear(double db);

class Pan {
  public:
    Pan(Pan *pan) : _direction(pan->GetDirection()),
        _dBmagnitude(pan->GetdBmagnitude()) {}
    Pan(double linearPan=0.0) { SetLinear(linearPan); }
    Pan(double dBmagnitude, int rightDirection) : _dBmagnitude(dBmagnitude),
        _direction(rightDirection) {}

    void SetPan(Pan *pan) { _direction   = pan->GetDirection();
                            _dBmagnitude = pan->GetdBmagnitude(); }

    int GetDirection() { return(_direction); }
    double GetdBmagnitude() { return(_dBmagnitude); }
    double GetLinear() 
        { return(_direction * -1.0 * (pow(10, _dBmagnitude/20.0) - 1.0)); }
    void SetLinear(double linearPan);
    void Add(Pan *pan) { SetLinear(pan->GetLinear() + GetLinear()); }

    void GetLRGain(double gainDb, double& lgainDb, double& rgainDb);

    // cheaper for reset than SetLinear(0.0)
    void SetMagnitude(double dBmagnitude, int rightDirection) {
        _dBmagnitude = dBmagnitude;
        _direction = rightDirection;
    }
    
  private:
    double _dBmagnitude;
    int    _direction;     // 1 if right facing, -1 if left
};

void
PanGainToLRGain(double pan, double gain,
                double& lgain, double& rgain);

void
SetPanGain(double lgainDb, double rgainDb, Pan& pan, double& gainDb);

#endif /* _HELPS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\helpq.h ===
#ifndef _HELPQ_H
#define _HELPQ_H

#include <windows.h>
#include <objbase.h>
#include <strmif.h>
#include "control.h"
#include <evcode.h>
#include <uuids.h>
#include "privinc/pcm.h"
#include "privinc/util.h"
#include "ddraw.h"
#include <amstream.h>
#include "privinc/hresinfo.h"
#include "privinc/mutex.h"
#include "privinc/ddsurf.h"
#include "ddraw.h"

typedef enum { MEDIASTREAM, ASTREAM, VSTREAM, AVSTREAM } StreamType;

// Use TDSOUND for checking DirectSound error return codes.
#if _DEBUG
    #define TQUARTZ(x) CheckReturnCode( x, __FILE__, __LINE__, true)
#else
    #define TQUARTZ(x) CheckReturnCode (x, true)
#endif

// handles the lone MIDI case where we allow amstream to render instead of
// deliver audio and video bits
class QuartzRenderer : public AxAThrowingAllocatorClass {
  public:
    QuartzRenderer();
    ~QuartzRenderer() { CleanUp(); }
    void Open(char *fileName);
    void CleanUp();
    void Play();
    void Pause();
    void Seek();
    void Stop();
    void SetRate(double rate);
    void SetGain(double gain);
    void SetPan(double  pan, int direction);
    double GetLength();
    bool QueryDone();
    void Position(double seconds);

  protected:
    int dBToQuartzdB(double dB);

  private:
    IGraphBuilder   *_MIDIgraph;     // pointer to the quartz MIDI graph
    IBasicAudio     *_audioControl;  // used to control the rate, pan, etc.
    IMediaControl   *_mediaControl;  // used to control start/stop, etc.
    IMediaPosition  *_mediaPosition; // used to set rate/phase
    HANDLE          *_oaEvent;
    IMediaEventEx   *_mediaEvent;
    TimeClass        _time;          // handy for time conversions

    bool             _rate0paused;   // have we paused for rate 0 emulation
    bool             _playing;       // are we requested to be playing
};


// class which knows how to instantiate an amstream multimedia stream!
class QuartzMediaStream : public AxAThrowingAllocatorClass {
  public:
    QuartzMediaStream();
    virtual ~QuartzMediaStream() { CleanUp(); }
    virtual bool SafeToContinue()      = 0;

  protected:
    void CleanUp();
    IAMMultiMediaStream *_multiMediaStream;
    IAMClockAdjust      *_clockAdjust;
};


// contains the stuff common to audio and video quartz readers
class QuartzReader : public AxAThrowingAllocatorClass {
  public:
    QuartzReader(char *url, StreamType streamType);
    virtual ~QuartzReader() { CleanUp(); }
    virtual void Release();
    virtual void CleanUp();
    double  GetDuration();
    bool    IsInitialized() { return(_initialized); }
    bool    IsDeleteable()  { return(_deleteable);  }
    void    SetDeleteable(bool deleteable) { _deleteable= deleteable; }
    PCM     pcm;
    void    AddReadTime(double addition)   { _secondsRead+=addition;  }
    double  GetSecondsRead()               { return(_secondsRead);    }
    virtual bool SafeToContinue() { return(true); }
            bool Stall();  // self resetting!
            void SetStall();
    virtual void Disable() = 0;
    char    *GetURL()          { return(_url);                                 }
    WCHAR   *GetQURL()         { return(_qURL);                                }
    long    GetNextFrame()     { return(_nextFrame);                           }
    StreamType GetStreamType() { return(_streamType);                          }
    void    Run()              { _multiMediaStream->SetState(STREAMSTATE_RUN); }
    bool    QueryPlaying();

    virtual bool AlreadySeekedInSameTick() { return false; }
    virtual void SetTickID(DWORD id) {}

  protected:
    IAMMultiMediaStream *_multiMediaStream; // don't delete, we are sharing it!
    IAMClockAdjust      *_clockAdjust;      // don't delete, we are sharing it!
    IMediaStream        *_mediaStream;
    bool                 _initialized;
    bool                 _deleteable;
    double               _secondsRead;
    bool                 _stall;    // set if a read stalls
    Mutex                _readerMutex;
    char                *_url;
    WCHAR               *_qURL;
    long                 _nextFrame;
    StreamType           _streamType;
};


// knows how to read audio out of amstream
class QuartzAudioReader : public QuartzReader {
  public:
    QuartzAudioReader(char *url, StreamType streamType);
    virtual ~QuartzAudioReader() { CleanUp(); }
    virtual void     Release();
    virtual int      ReadFrames(int numSamples, unsigned char *buffer, 
        bool blocking=false);
    void     SeekFrames(long frames);
    bool     AudioInitReader(IAMMultiMediaStream *_multiMediaStream,
                             IAMClockAdjust *_clockAdjust);
    bool     Completed() { return(_completed); }
    virtual void Disable();

    virtual void InitializeStream() {}

  protected:
    void     CleanUp();

  private:
    IAudioData          *_audioData;
    IAudioMediaStream   *_audioStream;
    IAudioStreamSample  *_audioSample;
    bool                 _completed;
};


class AVquartzAudioReader : public QuartzAudioReader
{
  public:
    AVquartzAudioReader(char *url, StreamType streamType) : 
        QuartzAudioReader(url, streamType) {}
    virtual int      ReadFrames(int numSamples, unsigned char *buffer, 
        bool blocking=false);
};


// knows how to read video out of amstream
class QuartzVideoReader : public QuartzReader {
  public:
    QuartzVideoReader(char *url, StreamType streamType);
    ~QuartzVideoReader() { CleanUp(); }
    bool   VideoSetupReader(IAMMultiMediaStream *multiMediaStream,
                            IAMClockAdjust      *clockAdjust, 
                            DDSurface           *surface, 
                            bool                 mode);
    virtual void Release();
    virtual void Disable();

    void Seek(double time);

    long GetHeight() { return _height; } // prefered pixel dimensions
    long GetWidth()  { return _width;  }
    virtual HRESULT     GetFrame(double time, IDirectDrawSurface **ppSurface);
    virtual bool        SafeToContinue() { return(true);          }

  protected:
    void UpdateTimes(bool bJustSeeked, STREAM_TIME SeekTime);
    void CleanUp(); // releases all com objects

    void                     VideoInitReader(DDPIXELFORMAT pixelFormat);

  private:
    IDirectDrawMediaStream  *_ddrawStream;
    long                     _height, _width;
    bool                     _async;
    bool                     _seekable;
    HRESULT                  _hrCompStatus;
    IDirectDrawSurface      *_ddrawSurface;

    bool                     _curSampleValid;
    STREAM_TIME              _curSampleStart;
    STREAM_TIME              _curSampleEnd;

    IDirectDrawStreamSample *_ddrawSample;
    DDSurfPtr<DDSurface>     _surface;
};


class AVquartzVideoReader : public QuartzVideoReader
{
  public:
    AVquartzVideoReader(char *url, StreamType streamType) : 
        QuartzVideoReader(url, streamType) {}
    virtual HRESULT GetFrame(double time, IDirectDrawSurface **ppSurface);
};


class QuartzAVstream : public QuartzMediaStream,
    public AVquartzAudioReader, public AVquartzVideoReader {
  public:
    virtual void    Release();
    virtual bool    SafeToContinue();
    virtual int     ReadFrames(int numSamples, unsigned char *buffer, 
        bool blocking=false);
    virtual HRESULT GetFrame(double time, IDirectDrawSurface **ppSurface);

    // XXX really should pass in latentcy with a default!
    QuartzAVstream(char *url);
    virtual ~QuartzAVstream() { CleanUp(); }
    bool GetAudioValid(){return(_audioValid);}
    bool GetVideoValid(){return(_videoValid);}

#if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine) {
        return(QuartzMediaStream::operator new(s, blockType, szFileName, nLine)); 
    }
#else
    void *operator new(size_t s) { return(QuartzMediaStream::operator new(s)); }
#endif

    // need to init the video first before priming sound buffer
    // for SetPixelFormat
    virtual void InitializeStream();

    // this is to ensure we only seek once per tick
    virtual bool AlreadySeekedInSameTick();
    virtual void SetTickID(DWORD id);

  private:
    void CleanUp(); // releases all com objects
    Mutex _avMutex;
    DWORD _tickID, _seeked;
    bool  _audioValid, _videoValid;
};


class QuartzAudioStream : public QuartzMediaStream, public QuartzAudioReader {
  public:
    // XXX really should pass in latentcy with a default!
                   QuartzAudioStream(char *url);
    virtual       ~QuartzAudioStream();
    virtual void   Release();
    virtual bool   SafeToContinue() { return(true); } // XXX obsolete
    virtual int    ReadFrames(int numSamples, unsigned char *buffer, 
                       bool blocking);
#if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine) {
        return(QuartzMediaStream::operator new(s, blockType, szFileName, nLine)); 
    }
#else
    void *operator new(size_t s) { return(QuartzMediaStream::operator new(s)); }
#endif

  private:
    void CleanUp(); // releases all com objects
};


class QuartzVideoStream : public QuartzMediaStream, public QuartzVideoReader {
  public:
    QuartzVideoStream(char *url, bool seekable = false) :
        QuartzVideoReader(url, VSTREAM), QuartzMediaStream(), _ddraw(NULL)
        { Initialize(url, NULL, seekable); }

    QuartzVideoStream(char *url, DDSurface *surface, bool seekable = false) :
        QuartzVideoReader(url, VSTREAM), QuartzMediaStream(), _ddraw(NULL)
        { Initialize(url, surface, seekable); }

    virtual ~QuartzVideoStream() { CleanUp(); }
    virtual void   Release();
    virtual bool   SafeToContinue() { return(true); }

#if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine) {
        return(QuartzMediaStream::operator new(s, blockType, szFileName, nLine)); 
    }
#else
    void *operator new(size_t s) { return(QuartzMediaStream::operator new(s)); }
#endif

  private:
    void Initialize(char *url, DDSurface *surface, bool seekable);
    IDirectDraw *_ddraw;
    void CleanUp(); // releases all com objects
};

bool QuartzAVmodeSupport(); // check for post 4.0.1 amstream support of clockadjust

#endif /* _HELPQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\imagei.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Specify generic image class and operations.

--*/

#ifndef _IMAGEI_H
#define _IMAGEI_H

#include "appelles/image.h"
#include "privinc/storeobj.h"
#include "privinc/except.h"
#include "privinc/vec2i.h"
#include "privinc/bbox2i.h"


// forward decls
class ImageDisplayDev;
class PointIntersectCtx;
class DiscreteImage;
class Bbox2Ctx;

////////////////////////////
//     The Image type     //
////////////////////////////

class DisjointCalcParam;
class DirtyRectCtx;

// Image flags
#define IMGFLAG_CONTAINS_OVERLAY                      (1L << 0)
#define IMGFLAG_CONTAINS_DESIRED_RENDERING_RESOLUTION (1L << 1)
#define IMGFLAG_CONTAINS_PICK_DATA                    (1L << 2)
#define IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT       (1L << 3)
#define IMGFLAG_CONTAINS_OPACITY                      (1L << 4)
#define IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX        (1L << 5)
#define IMGFLAG_IS_RENDERABLE                         (1L << 6)
// HACK!!  This one is pretty hacky... used because caching gradient
// images (when used as textures) is faulty, so we want to find out if
// the image contains a gradient until we can fix this problem.
#define IMGFLAG_CONTAINS_GRADIENT                     (1L << 7)


// Without multiple dispatching, this class will need to be extended
// with methods to render on different types of devices.
class ATL_NO_VTABLE Image : public AxAValueObj {
  public:

    class TraversalContext
    {
      public:
        TraversalContext() {
            Reset();
        }
        void Reset() {
            _other = _solidMatte = _line = false;
        }

        void SetContainsOther() { _other = true; }
        void SetContainsSolidMatte() { _solidMatte = true; }
        void SetContainsLine() { _line = true; }

        bool ContainsOther() { return _other; }
        bool ContainsLine() { return _line; }
        bool ContainsSolidMatte() { return _solidMatte; }
        
        bool _other;
        bool _solidMatte;
        bool _line;
    };
    
    Image();

    // Extract a bounding box from this image, outside of which
    // everything is transparent.
    virtual const Bbox2 BoundingBox(void) = 0;

    virtual const Bbox2 _BoundingBox() { return NullBbox2; }

    // Return the areas of all the individual bboxes of the image.
    // Note this is different than the area of the bbox of the image
    // itself.  That is, for (a over b), we want area(a) + area(b),
    // and not area(a over b).  The default method just calls bbox and
    // gets area on it.  Overlay's override.
    virtual Real DisjointBBoxAreas(DisjointCalcParam &param);

    // Collect up dirty rectangles in the tree.

    // This is the method that users and implementations should call, but
    // shouldn't implement.  Note that it's a static so people won't
    // override it.
    static void CollectDirtyRects(Image *img, DirtyRectCtx &ctx);

    #if BOUNDINGBOX_TIGHTER
        virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) = 0;
    #endif  // BOUNDINGBOX_TIGHTER

    // apply whatever to a bbox
    virtual const Bbox2 OperateOn(const Bbox2 &box) = 0;

    // Process an image for hit detection
    virtual Bool  DetectHit(PointIntersectCtx& ctx) = 0;

    virtual void DoKids(GCFuncObj proc);

    // Is this either a pure bitmap or a transformed bitmap.  This is
    // needed for some texture mapping optimizations.  If it is a pure
    // or transformed bitmap, the return value will be that bitmap,
    // else NULL.  If it is a pure bitmap, theXform will be filled
    // with NULL, else if it is a transformed bitmap, it will be
    // filled with the transform applied to the bitmap.
    virtual DiscreteImage *IsPurelyTransformedDiscrete(Transform2 **theXform) {
        return NULL;
    }

    // OK, I'm cheating here.  what *should* happen is the image
    // device gets passed down, the leaf ASKS the image device if IT
    // can render the leaf image clipped natively!
    virtual bool CanClipNatively() { return false; }
    
    // Print a representation to a stream.

    #if _USE_PRINT
        virtual ostream& Print(ostream& os) = 0;
    #endif

    virtual Bool GetColor(Color **color) { return FALSE; }

    // Some images are logical images that aren't renderable...
    Bool IsRenderable() {
        return _flags & IMGFLAG_IS_RENDERABLE;
    }

    // each image has an opacity... opacities float up.
    Real GetOpacity() { return _opacity; }
    void SetOpacity(Real op) { _opacity = op; }

    virtual int Savings(CacheParam& p) { return 0; }
    virtual AxAValue _Cache(CacheParam &p);

    virtual DXMTypeInfo GetTypeInfo() { return ImageType; }

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val);
    
    virtual VALTYPEID GetValTypeId() { return IMAGE_VTYPEID; }

    virtual bool CheckImageTypeId(VALTYPEID type) {
        return type == Image::GetValTypeId();
    }

    virtual bool ContainsOcclusionIgnorer() {
        return false;
    }

    void SetCreationID(long t) { _creationID = t; }
    long GetCreationID() { return _creationID; }

    void SetOldestConstituentID(long t) { _oldestConstituentSampleId = t; }
    long GetOldestConstituentID() { return _oldestConstituentSampleId; }

    DWORD GetFlags() { return _flags; }

    Image *GetCachedImage() { return _cachedImage; }
    void   SetCachedImage(Image *im) { _cachedImage = im; }

    void ExtractRenderResolution(short *width,
                                 short *height,
                                 bool   negOne);

    inline long Id(void) { return _id; }

    virtual void Traverse(TraversalContext &ctx) {
        ctx.SetContainsOther();
    }
    
  protected:

    static long _id_next;  // ID Generator
           long _id;       // Per-Image Unique Identifier

    // This should never be called directly, but it is what subclasses
    // should implement;
    virtual void _CollectDirtyRects(DirtyRectCtx &ctx);

    void SetIsRenderable(Bool r) {
        if (r) {
            _flags |= IMGFLAG_IS_RENDERABLE;
        } else {
            _flags &= ~IMGFLAG_IS_RENDERABLE;
        }
    }

    Real  _opacity;
    DWORD _flags;
    long  _creationID;
    long  _oldestConstituentSampleId;

    unsigned short _desiredRenderingWidth;
    unsigned short _desiredRenderingHeight;

    Image *_cachedImage;
};


//////////////  UNRenderable Image ////////////////////
class UnrenderableImage : public Image {
  public:
    // setting opacity to 0 guarantees this won't be
    // rendered.
    UnrenderableImage() {
        SetIsRenderable(FALSE);
    }

    // Has no bounding box
    virtual const Bbox2 BoundingBox(void) { return NullBbox2; }
#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) { return NullBbox2; }
#endif  // BOUNDINGBOX_TIGHTER

    virtual const Bbox2 OperateOn(const Bbox2 &box) { return box; }

    // This image is never hit
    virtual Bool  DetectHit(PointIntersectCtx& ctx) { return FALSE; }

    virtual void Render(GenericDevice& dev) {}

#if _USE_PRINT
    virtual ostream& Print(ostream& os) = 0;
#endif

    // important to leave this here because it overrides base class's
    // definition and NOT setting something in the context is important
    virtual void Traverse(TraversalContext &ctx) {}
};


//////////////  Attributed Image *////////////////////

// Attributed images always consist of an image and some
// attribution information.  Thus, methods can have default bvr that
// can be overridden.

class AttributedImage : public Image {
  public:
    AttributedImage(Image *image);
    virtual void Render(GenericDevice& dev);

    // ---
    // These methods all delegate to the image.  They can all be
    // overridden in subclasses.
    // ---

    // Extract a bounding box from this image, outside of which
    // everything is transparent.
    virtual const Bbox2 BoundingBox(void);
    virtual Real DisjointBBoxAreas(DisjointCalcParam &param);
    void _CollectDirtyRects(DirtyRectCtx &ctx);

#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    // Process an image for hit detection
    virtual Bool   DetectHit(PointIntersectCtx& ctx);

    virtual int Savings(CacheParam& p);
    virtual AxAValue _Cache(CacheParam &p);

    // This, by default, just returns the box.  Certain classes will
    // override.
    const Bbox2 OperateOn(const Bbox2 &box);

    virtual void DoKids(GCFuncObj proc);

    bool ContainsOcclusionIgnorer();

    inline Image *GetUnderlyingImage() { return _image; }


    virtual bool CanClipNatively() {
        return _image->CanClipNatively();
    }

    virtual void Traverse(TraversalContext &ctx) {
        _image->Traverse(ctx);
    }

  protected:
    Image *_image;
};

//
// O P A Q U E   I M A G E   C L A S S
//
class OpaqueImageClass : public AttributedImage {
  public:

    OpaqueImageClass(Real o, Image *img)
        : AttributedImage(img) {
            //
            // Our opacity is the composition of the underlying
            // image's opacity and the given opacity
            //
            SetOpacity( o * img->GetOpacity() );

            _flags |= IMGFLAG_CONTAINS_OPACITY;

        }

    //
    // the logic for opaque rendering is implemented in OverlayedImage
    // because we need the opacity value to float to the top (up to an
    // overlay branch) since it should be the last opearation performed
    // when compositing images and since opacity is implicitly a tertiary
    // operations: (opacity, image1, image2) where image1 is partly
    // transparent and lets you see image2 which is underneath.
    //
    // this method is implemented in the superclass
    //virtual void Render(GenericDevice& dev)

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "OpaqueImageClass" << _opacity << _image;
    }
#endif

    int Savings(CacheParam& p) { return 0; }   /* never cache opaque images */

    virtual VALTYPEID GetValTypeId() { return OPAQUEIMAGE_VTYPEID; }

    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == OpaqueImageClass::GetValTypeId() ||
                AttributedImage::CheckImageTypeId(type));
    }
};

Image *LineImageConstructor(LineStyle *style, Path2 *path);

// This calls _BoundingBox if cached is false, set cached, stashed the
// bbox points into cachedBox.  It returns a new Bbox2 of the same
// value of cachedBox.
// TODO: This is temp until we deal with the sharing issues later
const Bbox2 CacheImageBbox2(Image *img, bool& cached, Bbox2 &cachedBox);

Image *CacheHelper(Image *imgToCache, CacheParam &p);


// These are the internal versions of functions that build objects, that take
// lightweight types instead of the heavy AxAValue-based types coming from the
// behavior layer.

Image *CreateCropImage(const Point2 &, const Point2 &, Image *);


#endif /* _IMAGEI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\importgeo.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

Abstract:

    header containing classes needed for geometry importation

Revision:

--*/

#ifndef _IMPORTGEO_H_
#define _IMPORTGEO_H_

#include "privinc/vec2i.h"
#include "privinc/vec3i.h"

//-------------------------------------------
// info needed to apply texture wraps 
// to imported geometry 
//-------------------------------------------
class TextureWrapInfo {
  public:
    LONG            type;
    Point3Value     origin;
    Vector3Value    z,
                    y;
    Point2          texOrigin;
    Vector2         texScale;
    bool            relative;
    bool            wrapU;
    bool            wrapV;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\imgdev.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Generic device for rendering images.

*******************************************************************************/

#ifndef _IMGDEV_H
#define _IMGDEV_H

#include "privinc/dispdevi.h"
#include "privinc/debug.h"
#include "appelles/bbox2.h"
#include "privinc/imagei.h"
#include "privinc/drect.h"
#include <htmlfilter.h> // trident stuff.  IBitmapSurface
#include "ddraw.h"

// doesn't set x to NULL
#define FASTRELEASE(x) if(x) x->Release();

//
// Rendering target structure
//
enum targetEnum { target_invalid,
                  target_ddsurf,
                  target_hwnd,
                  target_hdc };
                                    

class targetPackage_t
{
    friend class View;
    
  public:

    IDirectDrawSurface *GetIDDSurface() { return _ddsurf; }
    HDC                 GetHDC() { return _hdc; }
    HWND                GetHWND() { return _hwnd; }
    HDC                 GetParentHDC() { return _parentHDC; }

    targetEnum          GetTargetType() { return _targetType; }
    
    void  SetIDDSurface(IDirectDrawSurface *dds,
                        HDC parentHDC = NULL)
    {
        _targetType = target_ddsurf;
        _ddsurf = dds;
        _parentHDC = parentHDC;
    }

    void SetHDC(HDC hdc) {
        _targetType = target_hdc;
        _hdc = hdc;
    }

    void SetHWND( HWND hwnd ) {
        _targetType = target_hwnd;
        _hwnd = hwnd;
    }

    bool IsValid() { return _targetType != target_invalid; }
    bool IsHWND() { return _targetType == target_hwnd; }
    bool IsHDC() { return _targetType == target_hdc; }
    bool IsDdsurf() { return _targetType == target_ddsurf; }
    
    void Reset()
    {
        _ddsurf.Release();
        _hdc = NULL;
        _hwnd = NULL;
        _parentHDC = NULL;
        _targetType = target_invalid;
        _composeToTarget = false;
        _alreadyOffset = false;

        _isValid_ViewportRect = false;
        _isValid_ClipRect = false;
        _isValid_InvalidRect = false;

        _isValid_rawViewportRect = false;
        _isValid_rawClipRect = false;
        _isValid_rawInvalidRect = false;
        
        ::FillMemory((void *)&_rawViewportRect, sizeof(RECT), 0xff);
        ::FillMemory((void *)&_rawClipRect, sizeof(RECT), 0xff);
        ::FillMemory((void *)&_rawInvalidRect, sizeof(RECT), 0xff);
    }

    void Copy( targetPackage_t &src )
    {
        // can't do a memcopy because ddsurf is a reference class and
        // the = operator does work.
        _ddsurf = src._ddsurf;
        _hdc =    src._hdc;
        _hwnd =   src._hwnd;
        _parentHDC = src._parentHDC;
        
        _targetType = src.GetTargetType();

        _composeToTarget      = src.GetComposeToTarget();
        _alreadyOffset        = src.GetAlreadyOffset();

        _viewportRect         = src.GetViewportRect();
        _clipRect             = src.GetClipRect();
        _invalidRect          = src.GetInvalidRect();

        _isValid_ViewportRect = src.IsValid_ViewportRect();
        _isValid_ClipRect     = src.IsValid_ClipRect();
        _isValid_InvalidRect  = src.IsValid_InvalidRect();

        _rawViewportRect      = src._GetRawViewportRect();
        _rawClipRect          = src._GetRawClipRect();
        _rawInvalidRect       = src._GetRawInvalidRect();

        _isValid_rawViewportRect = src._IsValid_RawViewportRect();
        _isValid_rawClipRect     = src._IsValid_RawClipRect();
        _isValid_rawInvalidRect  = src._IsValid_RawInvalidRect();
    }

    bool IsValid_ViewportRect() { return _isValid_ViewportRect; }
    bool IsValid_ClipRect()     { return _isValid_ClipRect; }
    bool IsValid_InvalidRect()  { return _isValid_InvalidRect; }

    const RECT &GetViewportRect() { return _viewportRect; }
    const RECT &GetClipRect() { return _clipRect; }
    const RECT &GetInvalidRect() { return _invalidRect; }
    
    bool GetComposeToTarget() { return _composeToTarget; }
    void SetComposeToTarget( bool c ) { _composeToTarget = c; }

    bool GetAlreadyOffset()  { return _alreadyOffset; }
    void SetAlreadyOffset() { _alreadyOffset = true; }

    void SetViewportRect(const RECT &r) {
        _viewportRect = r;
        _isValid_ViewportRect = true;
    }
    void SetClipRect(const RECT &r)     {
        _clipRect = r;
        _isValid_ClipRect = true;
    }
    void SetInvalidRect(const RECT &r)  {
        _invalidRect = r;
        _isValid_InvalidRect = true;
    }

    void SetRawViewportRect(const RECT &r) {
        _rawViewportRect = r;
        _isValid_rawViewportRect = true;
        _isValid_ViewportRect = false;
    }
    void SetRawClipRect(const RECT &r) {
        _rawClipRect = r;
        _isValid_rawClipRect = true;
        _isValid_ClipRect = false;
    }
    void SetRawInvalidRect(const RECT &r) {
        _rawInvalidRect = r;
        _isValid_rawInvalidRect = true;
        _isValid_InvalidRect = false;
    }

    
  private:

    CComPtr<IDirectDrawSurface> _ddsurf;
    HDC                _hdc;
    HWND               _hwnd;
    HDC                _parentHDC;
    
    targetEnum         _targetType;


    const RECT &_GetRawViewportRect() { return _rawViewportRect; }
    const RECT &_GetRawClipRect() { return _rawClipRect; }
    const RECT &_GetRawInvalidRect() { return _rawInvalidRect; }
    
    bool _IsValid_RawViewportRect() { return _isValid_rawViewportRect; }
    bool _IsValid_RawClipRect()     { return _isValid_rawClipRect; }
    bool _IsValid_RawInvalidRect()  { return _isValid_rawInvalidRect; }

    
    // These are 'raw' which means that they are in terms of the
    // parentDC or the surface and may (or may not) need to be
    // reinterpreted into the non-raw counterparts (_viewportRect)
    // which need to be guaranteed to be in device coords of the
    // target
    
    RECT _rawViewportRect;
    RECT _rawClipRect;    
    RECT _rawInvalidRect; 

    bool _isValid_rawViewportRect;
    bool _isValid_rawClipRect;
    bool _isValid_rawInvalidRect;

    
    // These are the final rects, if the hese rects are 'valid', then
    // they are guaranteed to be in device coordinates
    
    RECT _viewportRect;// viewport rect:  relative to target surface
    RECT _clipRect;    // clip rect:  relative to target surface
    RECT _invalidRect; // invalid rect: relative to target surface.                    

    bool _isValid_ViewportRect;
    bool _isValid_ClipRect;
    bool _isValid_InvalidRect;

    bool _composeToTarget;  // paint to target directly, or backbuffer?
    bool _alreadyOffset;

};  // targetPackage_t class

////////////////////////////////////////////////////////////////////
//
//  Image rendering device
//
////////////////////////////////////////////////////////////////////

// ----------------------------------------
// forward decls
// ----------------------------------------
class TextCtx;            
class SolidColorImageClass;
class DiscreteImage;
class ProjectedGeomImage;
class MovieImage;
class MovieImageFrame;
class GradientImage;
class ColorKeyedImage;
class DirectDrawSurfaceImage;
struct IDirectDrawSurface;
struct DDSurface;
class MovieImagePerf;
class MulticolorGradientImage;
class Path2;
class CacheParam;

#define NUM_ATTRIBS          4

#define ATTRIB_XFORM_SIMPLE  0
#define ATTRIB_XFORM_COMPLEX 1
#define ATTRIB_CROP          2
#define ATTRIB_OPAC          3

#define ATTRIB_STRING(attrib)  (attrib==ATTRIB_XFORM_COMPLEX ? "ATTRIB_XFORM_COMPLEX" : (attrib==ATTRIB_XFORM_SIMPLE ? "ATTRIB_XFORM_SIMPLE" : (attrib==ATTRIB_CROP ? "ATTRIB_CROP" : (attrib==ATTRIB_OPAC ? "ATTRIB_OPAC" : "UNKNOWN ATTRIB!"))))

class ATL_NO_VTABLE ImageDisplayDev : public DisplayDev {
  public:

    ImageDisplayDev();
    virtual ~ImageDisplayDev();

    virtual void BeginRendering(Image *img, Real opacity) {}
    virtual void EndRendering(DirtyRectState &d) {}

    virtual void WindowResizeEvent(int width, int height) = 0;

    virtual Image *CanCacheImage(Image  *image,
                                 Image **pImageCacheBase,
                                 const CacheParam &p) = 0;
    
    virtual Bool CanDisplay() = 0;
    
    virtual bool SetTargetPackage(targetPackage_t *targetPackage) = 0;
        
    virtual void RenderImage(Image *img);

    // compositing render based on attrib
    virtual void SmartRender(Image *image, int attrib) = 0;

    // Subclasses implement this method to render the specified 
    // dicrete image with the currently accumulated attributes
    virtual void RenderDiscreteImage(DiscreteImage *image) = 0;

    virtual void RenderDirectDrawSurfaceImage(DirectDrawSurfaceImage *ddsimg) = 0;
    
    // Render a solid colored, infinite image
    virtual void RenderSolidColorImage(SolidColorImageClass& img) = 0;

    // Render a string onto the image according to the current text
    // context.
    virtual void RenderText(TextCtx& textCtx, 
                            WideString str,
                            Image *textImg) = 0;
    
    // Render a tiled image based on image tile derived from
    // min/max delimiters applied to 'image'.  This uses the
    // 'imageToTile' as a place holder for efficiency.
    // The calling class keeps this opaque pointer, this class
    // manages and creates it.
    virtual void RenderTiledImage(const Point2& min, 
                                  const Point2& max, 
                                  Image *tileSrcImage) = 0;


    // Render an image using geo and cam and all the
    // current transforms as well as whatever infor
    // 'img' can provide.
    virtual void RenderProjectedGeomImage(ProjectedGeomImage *img,
                                          Geometry *geo,
                                          Camera *cam) = 0; 

    virtual void RenderMovieImage(MovieImage     *movieImage,
                                  Real            time,
                                  MovieImagePerf *perf,
                                  bool            forceFallback,
                                  DDSurface      *targDDSurf = NULL) = 0;

    void StashMovieImageFrame(MovieImageFrame *f)
    { _movieImageFrame = f; }

    MovieImageFrame *GetMovieImageFrame()
    { return _movieImageFrame; }
    
    virtual void RenderGradientImage(GradientImage *img,
                                     int numPts,
                                     Point2Value **pts,
                                     Color **clrs) = 0;
    virtual void RenderMulticolorGradientImage(
        MulticolorGradientImage *gradImg,
        int numOffsets,
        double offsets[],
        Color **clrs) = 0;

    virtual void RenderColorKeyedImage(ColorKeyedImage *)=0;
    
    // -- Device Specific Calls --
    // -- May want to move into viewport --

    // Use these to retrieve the dimensions (in pixels) of the device
    virtual int GetWidth() = 0;
    virtual int GetHeight() = 0;

    // Return resolution, in pixels per meter.
    virtual Real GetResolution() = 0;

    // -- Context Accumulation Calls --

    void       PushCroppedImage(Image *image) {
        _cropRef++;
        _imageQueue.push_back(image);
    }
    void       PopCroppedImage() {
        _cropRef--;
        _imageQueue.pop_back();
    }
    Bool       IsCropped() { return _cropRef > 0;  }

    // -- Clipping --
    
    inline void   SetClippingPath(Path2 *path, Transform2 *cpxf) {
        _clippingPath = path;
        _clippingPathXf = cpxf;
    }
    inline void   GetClippingPath(Path2 **path, Transform2 **cpxf) {
        Assert( path && cpxf );
        *path = _clippingPath;
        *cpxf = _clippingPathXf;
    }
        
    
    

    void       PushTransform2Image(Image *image) {
        BEGIN_LEAK
        _imageQueue.push_back(image);
        END_LEAK
    }
    void       PopTransform2Image() {
        _imageQueue.pop_back();
    }

    
    // ----------------------------
    // Attributor state members
    // ----------------------------    
    Bool GetDealtWithAttrib(int attrib) {
        Assert( (attrib >=0) && (attrib<_numAttribs) &&
                "Bad attrib index");
        Assert(((_attributorStateArray[attrib] == TRUE) ||
                (_attributorStateArray[attrib] == FALSE)) &&
               "Trying to get bad val for attrib");
        return _attributorStateArray[attrib];
    }
    
    void SetDealtWithAttrib(int attrib, Bool val) {
        TraceTag((tagImageDeviceAlgebra, 
                  "SetDealtWithAttrib: %s=%d",
                  ATTRIB_STRING(attrib), val));
        Assert( ((val == TRUE) || (val == FALSE)) && "Bad val passed to SetDealtWithAttrib");
        _attributorStateArray[attrib] = val;
    }

    Bool AllAttributorsTrue() {
        Bool ret = TRUE;
        for(int i=0; i < _numAttribs; i++) {
            ret = ret && _attributorStateArray[i];
        }
        return ret;
    }


    // ----------------------------
    // Context accessing functions.
    // ----------------------------
    
    // Opacity accessor
    Real  GetOpacity()       { return _opacity; }
    void  SetOpacity(Real o) { _opacity = o; }

    // Image quality accessors
    DWORD GetImageQualityFlags() { return _imgQualFlags; }
    void  SetImageQualityFlags(DWORD flags) { _imgQualFlags = flags; }
    bool  UseImageQualityFlags(DWORD dwAllFlags, 
                               DWORD dwSetFlags, bool bCurrent);

    void  GetRenderResolution(long *outWidth,
                              long *outHeight) {
        *outWidth = _imgRenderResolutionWidth;
        *outHeight = _imgRenderResolutionHeight;
    }
    void  SetRenderResolution(long inWidth,
                              long inHeight) {
        _imgRenderResolutionWidth = inWidth;
        _imgRenderResolutionHeight = inHeight;
    }

    void  SetSampleResolution(int s) { _sampleResolution = s; }
    int   GetSampleResolution() { return _sampleResolution; }

    //
    // Alpha blend util functions
    //
    Bool IsFullyClear() { return _opacity < _minOpacity; }
    Bool IsFullyOpaque() { return _opacity >= _maxOpacity; }
    Bool IsTransparent() { return !IsFullyClear() && !IsFullyOpaque(); }

    Bool IsFullyClear(Real o) { return o < _minOpacity; }
    Bool IsFullyOpaque(Real o) { return o >= _maxOpacity; }
    Bool IsTransparent(Real o) { return !IsFullyClear(o) && !IsFullyOpaque(o); }


    Transform2 *GetTransform() { return _xform; }
    void       SetTransform(Transform2 *xf) { _xform = xf; }

    // Color keys
    bool ColorKeyIsSet() { return _colorKeyIsSet; }
    void UnsetColorKey() { _colorKeyIsSet = false; }
    void SetColorKey(Color *key) { 
        _colorKey = key; 
        _colorKeyIsSet = true;
    }
    Color *GetColorKey() { return _colorKey; }
    
    void ResetAttributors() {
        for(int i=0; i<_numAttribs; i++) {
            SetDealtWithAttrib(i, TRUE);
        }
    }

    void ResetContextMembers() {
        _numAttribs = NUM_ATTRIBS;
        _cropRef = 0;
        _boundingBox = UniverseBbox2;
        _clippingPath = NULL;
        _clippingPathXf = NULL;
        _opacity = 1.0;
        _xform = identityTransform2;
        _colorKeyIsSet  = FALSE;
        _colorKey = NULL;
        _imageQueue.erase(_imageQueue.begin(),_imageQueue.end());
        _imgQualFlags = 0;
        _imgRenderResolutionWidth = -1;
        _imgRenderResolutionHeight = -1;
        SetSampleResolution(-1);
        ResetAttributors();
    }

    void InheritContextMembers( ImageDisplayDev *srcDev )
    {
        Assert( srcDev );
        
        _numAttribs = srcDev->_numAttribs;
        _cropRef =    srcDev->_cropRef;
        _boundingBox = srcDev->_boundingBox;
        
        SetOpacity( srcDev->_opacity );
        _minOpacity = srcDev->_minOpacity;
        _maxOpacity = srcDev->_maxOpacity;
        
        SetTransform( srcDev->_xform );
        _colorKeyIsSet  = srcDev->_colorKeyIsSet;
        _colorKey = srcDev->_colorKey;
        
        _imageQueue.erase(_imageQueue.begin(),_imageQueue.end());
        // copy constructor
        _imageQueue = srcDev->_imageQueue;

        SetImageQualityFlags( srcDev->GetImageQualityFlags() );
        SetSampleResolution( srcDev->GetSampleResolution() );
        
        long w,h;
        srcDev->GetRenderResolution( &w, &h );
        SetRenderResolution( w, h );

        InheritAttributorStateArray( srcDev );
    }
    
    void InheritAttributorStateArray( ImageDisplayDev *srcDev )
    {
        CopyMemory( _attributorStateArray,
                    srcDev->_attributorStateArray,
                    NUM_ATTRIBS * sizeof(int) );
    }   

  protected:

    int           _numAttribs;
    int           _attributorStateArray[NUM_ATTRIBS];

    int           _cropRef;
    Bbox2         _boundingBox;

    Path2        *_clippingPath;
    Transform2   *_clippingPathXf;
    
    // temp val for rendering
    MovieImageFrame *_movieImageFrame;

    //
    // Alpha blending data members
    //
    Real          _opacity;
    Real          _minOpacity;
    Real          _maxOpacity;

    Transform2   *_xform;
    bool          _colorKeyIsSet;
    Color        *_colorKey;

    DWORD          _imgQualFlags;
    long           _imgRenderResolutionWidth;
    long           _imgRenderResolutionHeight;
    int            _sampleResolution;
    
    list<Image*> _imageQueue;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\linei.h ===
#ifndef _LINEI_H
#define _LINEI_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

-------------------------------------*/

#include <appelles/linestyl.h>
#include <privinc/colori.h>
#include "dartapi.h"
/*
This is now defined in  src/prims/dartapipost.h

typedef enum  {
    es_Round  = PS_ENDCAP_ROUND,  // 0x00000000
    es_Square = PS_ENDCAP_SQUARE, // 0x00000100
    es_Flat   = PS_ENDCAP_FLAT    // 0x00000200
    } EndStyleEnum;

typedef enum  {
    js_Round = PS_JOIN_ROUND,  // 0x00000000
    js_Bevel = PS_JOIN_BEVEL,  // 0x00001000
    js_Miter = PS_JOIN_MITER   // 0x00002000
    } JoinStyleEnum;

typedef enum  {
    ds_Solid        = PS_SOLID,     // 0
    ds_Dashed       = PS_DASH,      // 1
    ds_Dot          = PS_DOT,       // 2
    ds_Dashdot      = PS_DASHDOT,   // 3
    ds_Dashdotdot   = PS_DASHDOTDOT,// 4
    ds_Null         = PS_NULL,      // 5
} DashStyleEnum;
*/

#if 0
/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1       /* -------  */
#define PS_DOT              2       /* .......  */
#define PS_DASHDOT          3       /* _._._._  */
#define PS_DASHDOTDOT       4       /* _.._.._  */
#define PS_NULL             5
#define PS_INSIDEFRAME      6
#define PS_USERSTYLE        7
#define PS_ALTERNATE        8
#define PS_STYLE_MASK       0x0000000F
#endif

#define STYLE_CLASS(_type_)  \
class _type_##Style : public AxAValueObj { \
  public:                                 \
    _type_##Style(_type_##StyleEnum style) : _style(style) {}    \
    _type_##StyleEnum _style;                                     \
\
    virtual DXMTypeInfo GetTypeInfo() { return _type_##StyleType; }\
};

STYLE_CLASS(End)

STYLE_CLASS(Join)

STYLE_CLASS(Dash)


class LineStyle : public AxAValueObj {
  public:

    LineStyle() {}

    virtual DashStyleEnum GetDashStyle() { return ds_Solid; }
    virtual EndStyleEnum GetEndStyle()  { return es_Flat; }
    virtual JoinStyleEnum GetJoinStyle() { return js_Bevel; }
    virtual bool       GetVisible()   { return true; }

    virtual Real      Width() {
        Assert(FALSE && "LineStyle::Width should never be called on defaultLineStyle!");
        // Should never be used since default line style is detail,
        // just return a canonical value.
        return 1.0;
    }
    virtual Color     *GetColor()   { return black; }

    // By default, the line style is detail (one pixel wide)
    virtual bool      Detail() { return true; }

    // by default: no antialiasing.
    virtual bool      GetAntiAlias() { return false; }

    virtual float     GetMiterLimit() {
        return -1;
    }
    
    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return LineStyleType; }
};

class AttributedLineStyle : public LineStyle {
  public:
    AttributedLineStyle(LineStyle *lineStyle) : _lineStyle(lineStyle) {}

    virtual DashStyleEnum GetDashStyle() { return _lineStyle->GetDashStyle(); }
    virtual EndStyleEnum  GetEndStyle()  { return _lineStyle->GetEndStyle(); }
    virtual JoinStyleEnum GetJoinStyle() { return _lineStyle->GetJoinStyle(); }
    virtual Real       Width() { return _lineStyle->Width(); }
    virtual bool       Detail() { return _lineStyle->Detail(); }
    virtual Color     *GetColor() { return _lineStyle->GetColor(); }
    virtual bool       GetVisible() { return _lineStyle->GetVisible(); }
    virtual bool       GetAntiAlias() { return _lineStyle->GetAntiAlias(); }
    virtual float      GetMiterLimit() { return _lineStyle->GetMiterLimit(); }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_lineStyle);
    }

    LineStyle *_lineStyle;
};


#define LINE_TYPE_CLASS(_type_) \
class Line##_type_##StyleClass : public AttributedLineStyle {                   \
  public:                                                                       \
    Line##_type_##StyleClass( _type_##StyleEnum theStyle, LineStyle *lineStyle)    \
        : _theStyle(theStyle), AttributedLineStyle(lineStyle) {}                \
    _type_##StyleEnum Get##_type_##Style()  { return _theStyle; }                  \
  protected:                                                                    \
    _type_##StyleEnum _theStyle;                                                   \
};

LINE_TYPE_CLASS(End)

LINE_TYPE_CLASS(Join)

LINE_TYPE_CLASS(Dash)

    
class LineWidthStyleClass : public AttributedLineStyle {
  public:
    LineWidthStyleClass(Real width, bool detail, LineStyle *lineStyle)
        : AttributedLineStyle(lineStyle), _width(width), _detail(detail) {}

    Real      Width() { return _width; }
    bool      Detail() { return _detail; }

  protected:
    Real _width;
    bool _detail;
};

class LineColorStyleClass : public AttributedLineStyle {
  public:
    LineColorStyleClass(Color *color, LineStyle *lineStyle)
        : AttributedLineStyle(lineStyle), _color(color) {}

    Color     *GetColor() { return _color; }

    virtual void DoKids(GCFuncObj proc) {
        AttributedLineStyle::DoKids(proc);
        (*proc)(_color);
    }

  protected:
    Color   *_color;
};

class LineAntiAliasedStyleClass : public AttributedLineStyle {
  public:
    LineAntiAliasedStyleClass(bool antiAlias, LineStyle *lineStyle)
        : AttributedLineStyle(lineStyle), _antiAlias(antiAlias) {}

    bool GetAntiAlias() { return _antiAlias; }

  protected:
    bool _antiAlias;
};

class LineMiterLimitClass : public AttributedLineStyle {
  public:
    LineMiterLimitClass(float limit, LineStyle *lineStyle)
        : AttributedLineStyle(lineStyle), _limit(limit) {}

    float GetMiterLimit() { return _limit; }

  protected:
    float _limit;
};


class EmptyLineStyle : public AttributedLineStyle {
  public:
      EmptyLineStyle() : AttributedLineStyle(NEW LineStyle()) {};
    virtual bool GetVisible()   { return false; }
};

#endif /* _LINEI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\lighti.h ===
#pragma once
#ifndef _AV_LIGHTI_H
#define _AV_LIGHTI_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Private include file for defining lights and light traversal context.

*******************************************************************************/

#include "appelles/color.h"
#include "appelles/light.h"

#include "privinc/geomi.h"
#include "privinc/bbox3i.h"


    // This enumeration indicates the type of light source.

enum LightType
{
    Ltype_Ambient,
    Ltype_Directional,
    Ltype_Point,
    Ltype_Spot,
    Ltype_MAX
};


    // The light context class maintains traversal context while gathering
    // lights from the geometry tree.

class Light;
class GeomRenderer;

typedef void (LightCallback)(LightContext&, Light&, void*);

class LightContext
{
  public:

    LightContext (GeomRenderer *rdev);
    LightContext (LightCallback *callback, void *callback_data);

    // Set/Query functions for light attributes.

    void        SetTransform (Transform3 *transform);
    Transform3 *GetTransform (void);

    void   PushColor (Color*);
    void   PopColor  (void);
    Color *GetColor  (void);

    void PushRange (Real);
    void PopRange  (void);
    Real GetRange  (void);

    void PushAttenuation (Real a0, Real a1, Real a2);
    void PopAttenuation  (void);
    void GetAttenuation  (Real &a0, Real &a1, Real &a2);

    void AddLight (Light &light);

    GeomRenderer* Renderer (void);

  private:

    void Initialize (GeomRenderer*, LightCallback*, void*);

    GeomRenderer     *_rdev;        // Rendering Device

    short _depthAtten;   // Attribute Depth Counters
    short _depthColor;
    short _depthRange;

    Transform3 *_transform;                 // Current Accumulated Transform
    Color      *_color;                     // Light Color
    Real        _range;                     // Light Range in World Coords
    Real        _atten0, _atten1, _atten2;  // Light Attenuation

    LightCallback *_callback;               // Light Collection Callback
    void          *_callback_data;
};

inline GeomRenderer* LightContext::Renderer (void)
{
    return _rdev;
}



    // The light superclass specifies the trivial default values for most
    // traversal methods.  Specific types of lights subclass from this and
    // define the data & methods particular to their type.

class Light : public Geometry
{
  public:

    // This constructor creates a light of the given type.  Spotlights should
    // use the constructor that takes the spotlight parameters.

    Light (LightType type)
        : _type(type), _cutoff(1), _fullcone(1) {}

    // This creates a light and initializes the spotlight parameters.

    Light (LightType type, Real fullcone, Real cutoff)
    :   _type(type),
        _fullcone(fullcone), _cutoff(cutoff)
    {}

    // Lights have no sound, no volume, can't be rendered or picked.

    void   Render          (GenericDevice& dev)   {}
    void   CollectSounds   (SoundTraversalContext &context) {}
    void   CollectTextures (GeomRenderer &device) {}
    Bbox3 *BoundingVol     (void)  { return nullBbox3; }
    void   RayIntersect    (RayIntersectCtx &context) {}

    // When a light is collected, it adds itself to the context.

    void CollectLights (LightContext &context) { context.AddLight (*this); }

    // This function returns the type of light source.

    LightType Type (void) { return _type; }

    // This function gets the spotlight parameters.

    void GetSpotlightParams (Real &cutoff, Real &fullcone)
        { cutoff = _cutoff; fullcone = _fullcone; }

    #if _USE_PRINT
        ostream &Print (ostream &os);
    #endif

    VALTYPEID GetValTypeId() { return LIGHTGEOM_VTYPEID; }

  private:

    LightType  _type;   // Light Source Type

    // Spotlight Parameters

    Real _cutoff;      // Angle of Light Cutoff (Radians)
    Real _fullcone;    // Cone Angle of Full Intensity Illumination
};


    // This function constructs spotlights with Real values.

Geometry *SpotLight (Real fullcone, Real cutoff);

    // Light Attributers

Geometry *applyLightAttenuation (Real A0, Real A1, Real A2, Geometry*);
Geometry *applyLightRange (Real range, Geometry *geometry);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\ipc.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _IPC_H
#define _IPC_H

#define DAT_TERMINATE 0xffffffff

extern UINT DAMessageId;

#pragma warning(disable:4200)  

class DAIPCWorker :
    public AxAThrowingAllocatorClass
{
  public:
    DAIPCWorker() : _hwnd(NULL) {}
    ~DAIPCWorker() { DetachFromThread(); }
    
    bool AttachToThread();
    void DetachFromThread();

    bool IsAttached() { return _hwnd != NULL; }
    
    bool SendAsyncMsg(DWORD dwMsg, DWORD dwNum = 0, ...) {
        va_list args;
        va_start(args, dwNum);

        return SendMsg(dwMsg, 0, dwNum, args);
    }
    
    bool SendSyncMsg(DWORD dwMsg,
                     DWORD dwTimeout = INFINITE,
                     DWORD dwNum = 0, ...) {
        va_list args;
        va_start(args, dwNum);

        return SendMsg(dwMsg, dwTimeout, dwNum, args);
    }

    ULONG AddRef() { return InterlockedIncrement(&m_cRef); }
    ULONG Release() {
        ULONG ul = InterlockedDecrement(&m_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
  protected:
    long m_cRef;
    HWND _hwnd;
    DWORD _dwThreadId;
    class DAIPCPacket {
      public:
        DAIPCPacket() : _cRef(1) {}
        ~DAIPCPacket() { if (_hSync) CloseHandle(_hSync); }
        
        ULONG AddRef() { return InterlockedIncrement(&_cRef); }
        ULONG Release() {
            LONG l = InterlockedDecrement(&_cRef) ;
            Assert (l >= 0);
            
            if (l == 0) delete this;
            return (ULONG) l;
        }

        bool Init(DWORD dwMsg, bool sync = false) {
            Assert (_dwMsg == 0);
            
            _dwMsg = dwMsg;

            Assert (_hSync == NULL);
            
            if (!sync) return true;
            
            _hSync = CreateEvent(NULL,TRUE,FALSE,NULL);

            return (_hSync != NULL);
        }

        void *operator new(size_t s, DWORD dwNumParams)
        {
            DWORD size = s + (sizeof(DWORD) * dwNumParams);
            
            DAIPCPacket * p = (DAIPCPacket *) ThrowIfFailed(malloc(size));
            if (p) {
                ZeroMemory(p,size);
                p->_dwNum = dwNumParams;
            }

            return p;
        }

        void *operator new(size_t s) { return operator new(s,0); }
        
        void  operator delete(void *p) { free(p); }

        // Accessors
        DWORD GetMsg() { return _dwMsg; }
        HANDLE GetSync() { return _hSync; }
        DWORD GetNumParam() { return _dwNum; }
        DWORD * GetParams() { return _dwParams; }
        DWORD & GetParam(int i) { Assert (i < _dwNum); return _dwParams[i]; }

        DWORD & operator[](int i) { return GetParam(i); }
        bool IsSync() { return _hSync != NULL; }
      protected:
        LONG       _cRef;        // The reference count
        DWORD      _dwMsg;       // The message to send
        HANDLE     _hSync;       // If non-null the event to signal on completion
        DWORD      _dwNum;       // The number of parameters
        DWORD      _dwParams[];  // The parameter array

    };

    // This is the main function for processing messages
    // override this to change how messages are dispatched or to
    // process messages before they are dispatched
    
    virtual bool IPCProc (HWND hwnd,
                          UINT msg,
                          WPARAM wParam,
                          LPARAM lParam,
                          LRESULT & res);

    // The main message processing routine.  Each class should
    // override this and process messages as needed
    virtual void ProcessMsg(DWORD dwMsg,
                            DWORD dwNumParams,
                            DWORD dwParams[]) {}

    // This will ensure the packet is deleted
    bool SendPacket(DAIPCPacket & packet,
                    DWORD dwTimeout);
    bool SendMsg(DWORD dwMsg,
                 DWORD dwTimeout,
                 DWORD dwNum,
                 va_list args);
    
    DAIPCPacket * MakePacket(DWORD dwMsg,
                             bool bSync,
                             DWORD dwNum,
                             va_list args);
#if DEVELOPER_DEBUG
    virtual char * GetName() { return "DAIPCWorker"; }
#endif

  public:
    static LRESULT CALLBACK WindowProc (HWND   hwnd,
                                        UINT   msg,
                                        WPARAM wParam,
                                        LPARAM lParam);
};

class DAThread :
    public DAIPCWorker
{
  public:
    DAThread();
    ~DAThread();

    // Returns true if successful
    bool Start();

    // Return true if the process terminated w/o being forced
    bool Stop() { return Terminate(false); }
    void Kill() { Terminate(true); }
    
    bool Terminate(bool bKill);

    bool IsStarted() { return IsAttached(); }
  protected:
    HANDLE _hThread;                // The thread handle
    DWORD _dwThreadId;              // The thread id

    // We need to ensure the message queue is created before we can
    // communicate with the thread (since one is not created until a
    // PeekMessage is done from the new thread).  This is freed as
    // soon as the thread signals is and so is only temporary.
    
    HANDLE _hMsgQEvent;

    // This is set to true to indicate that the worker is currently
    // handling a work request which may take some time but will
    // immediately check for termination when complete.
    
    bool _bDoingWork;
    
    // The entry point for the worker thread
    virtual int workerRoutine();

    virtual bool InitThread();
    virtual bool DeinitThread();

    static int DAWorker(DAThread * t) { Assert(t); return t->workerRoutine(); }

#if DEVELOPER_DEBUG
    virtual char * GetName() { return "DAThread"; }
#endif
    static bool AddRefDLL();
    static void ReleaseDLL();
};

extern DAThread * GetCurrentDAThread();

#pragma warning(default:4200)  

#endif /* _IPC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\matteimg.h ===
#ifndef _MATTEIMG_H
#define _MATTEIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

-------------------------------------*/

#include "privinc/imagei.h"
#include "privinc/mattei.h"

class MatteImage : public AttributedImage {
  public:
    MatteImage(Matte *matte, Image *imgToStencil);

    void   Render(GenericDevice& dev);

    inline const Bbox2 BoundingBox(void) {
        return _box;
    }

    Real DisjointBBoxAreas(DisjointCalcParam &param);
        
    void _CollectDirtyRects(DirtyRectCtx &ctx);
    
#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return IntersectBbox2Bbox2(_matte->BoundingBoxTighter(bbctx), _image->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

    Bool   DetectHit(PointIntersectCtx& ctx);

    Bool RenderWithCallBack(
        callBackPtr_t callBack,
        void *callBackCtx,
        HRGN *regionPtr,
        Transform2 *xform,
        bool justDoPath);
    
    int  Savings(CacheParam &p);
    
    virtual void DoKids(GCFuncObj proc) { 
        AttributedImage::DoKids(proc);
        (*proc)(_matte); 
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "MatteImage(" << _matte << "," << _box << ")";
    }
#endif

    virtual void Traverse(TraversalContext &ctx) {
        if( _image->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID) )
            ctx.SetContainsSolidMatte();
        else 
            ctx.SetContainsOther();
    }
    
  protected:
    Matte  *_matte;
    Bbox2   _box;
};


#endif /* _MATTEIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\mici.h ===
#ifndef _MICI_H
#define _MICI_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Microphone *implementation class

--*/

#include "appelles/mic.h"

class ATL_NO_VTABLE Microphone : public AxAValueObj {
  public:
    // For now, just identify the microphone with a transform.  Will
    // want to add other stuff.
    virtual Transform3 *GetTransform() const = 0;
#if _USE_PRINT
    virtual ostream& Print(ostream& os) const = 0;
#endif

    virtual DXMTypeInfo GetTypeInfo() { return MicrophoneType; }
};

#endif /* _MICI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\mattei.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Mattes

*******************************************************************************/


#ifndef _MATTEI_H
#define _MATTEI_H

#include "include/appelles/matte.h"
#include "privinc/storeobj.h"
#include "privinc/util.h"
#include "privinc/server.h"

typedef HDC (*callBackPtr_t)(void *);

class MatteCtx;
class BoundingPolygon;


////////////////////////////////////////////////////////
//////////// Matte class
////////////////////////////////////////////////////////

class ATL_NO_VTABLE Matte : public AxAValueObj {
  public:

    // Note that for mattes, the presence of stuff implies "clear"
    // rather than "opaque".  That is, if we union two mattes, the
    // result is the same or more "clear" than the parts.  If we
    // intersect them, the result is the same or less "clear" (or, the
    // same or more "opaque"). 
    
    enum MatteType {

        // fully opaque or clear mattes
        fullyOpaque,
        fullyClear,

        // non-trivially shaped, 'hard' mattes, meaning all alpha
        // values are either 0 or 1.
        nonTrivialHardMatte,
        
        // add more when we add more alpha alternatives
    };

    // TODO: We may want to separate out type classification from HRGN
    // generation, especially when we add alphas and not all mattes
    // will be representable via HRGNs.
    MatteType   GenerateHRGN(HDC dc,
                             callBackPtr_t devCallBack,
                             void *devCtxPtr,
                             Transform2 *initXform,
                             HRGN *rgnOut,             // Output
                             bool justDoPath
                             );

    MatteType   GenerateHRGN(MatteCtx &inCtx,
                             HRGN *hrgnOut);

    virtual void Accumulate(MatteCtx& ctx) = 0;

    virtual const Bbox2 BoundingBox(void) = 0;
#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) = 0;
#endif  // BOUNDINGBOX_TIGHTER

    // Return TRUE (and fill in parameters) if we can pull out points
    // for a single polygon or polybezier.  By default, assume we
    // cannot, and return false.
    virtual Bool ExtractAsSingleContour(
        Transform2 *initXform,
        int *numPts,            // out
        POINT **gdiPts,          // out
        Bool *isPolyline        // out (true = polyline, false = polybezier)
        ) {

        return FALSE;
    }

//    virtual void BoundingPgon(BoundingPolygon &pgon) = 0;

    virtual Path2 *IsPathRepresentableMatte() { return NULL; }
    
    virtual DXMTypeInfo GetTypeInfo() { return ::MatteType; }
};

//////////////////////  Matte Accumulation Ctx  //////////////////////////

class MatteCtx {
    friend class Matte;
  public:

    MatteCtx(HDC dc,
             callBackPtr_t devCallBack,
             void *devCtxPtr,
             Transform2 *initXform,
             bool justDoPath) {
        Init();
        _dc = dc;
        _devCallBack = devCallBack;
        _devCtxPtr = devCtxPtr;
        _xf = initXform;
        _justDoPath = justDoPath;

        // The maximum extent value is the following magic number.  This is
        // empircally the largest we can set it to without introducing various
        // artifacts on Win95.  WinNT seems to behave differently and can
        // accomodate a larger value, for what it's worth.

        const int max = 0x3FFF;
        
        TIME_GDI (_bigRegion = CreateRectRgn(-max, -max, max, max));
    }

    ~MatteCtx() {
        if(_bigRegion) DeleteObject(_bigRegion);
    }

    // Subtract the provided rgn from the one we're accumulating. 
    void        SubtractHRGN(HRGN r1) {
        
        Assert( !_justDoPath );
        
        int ret;

        Assert(_anyAccumulated != FALSE);

        switch (_accumulatedType) {
            
          case Matte::fullyOpaque:
            // Subtracting "clearness" from an opaque matte just
            // leaves it opaque, so don't do anything.
            break;

          case Matte::fullyClear:

            // Subtracting "clearness" from a clear matte will
            // involves inverting what we're subtracting: invert r1

            // fully clear means _hrgn is NULL.  create it.
            TIME_GDI (_hrgn = CreateRectRgn(-1,-1,1,1));
            
            Assert(_hrgn && "_hrgn NULL in SubtractMatte");
            Assert(_bigRegion && "_bigRegion NULL in SubtractMatte");
            Assert(r1 && "r1 NULL in SubtractMatte");

            TIME_GDI (ret = CombineRgn(_hrgn, _bigRegion, r1, RGN_DIFF));
            if (ret == ERROR) {
                    RaiseException_InternalError("Region intersection failed: subtract fullyClear");
            }
                
            _accumulatedType = Matte::nonTrivialHardMatte;

            break;

          case Matte::nonTrivialHardMatte:
            Assert(_hrgn != NULL);

            // Subtract r1 from _hrgn and leave result in _hrgn.
            {
                int ret;
                TIME_GDI (ret = CombineRgn(_hrgn, _hrgn, r1, RGN_DIFF));
                if( ret == ERROR) {
                    RaiseException_InternalError("Region intersection failed: subtract nonTrivial");
                } else if( ret == NULLREGION ) {
                    _accumulatedType = Matte::fullyOpaque;
                    TIME_GDI (if(_hrgn) DeleteObject(_hrgn));
                    _hrgn = NULL;
                }
            }     
            break;

          default:
            Assert(FALSE && "Not all cases dealt with");
            break;
        }

        //
        // In all cases, we should dump r1
        //
        DeleteObject(r1);
    }
    
    void        AddHRGN(HRGN r1, 
                        Matte::MatteType mType) {
        
        if (_anyAccumulated == FALSE) {

            Assert(!_hrgn);

            // nothing is accumulated, copy incoming type
            switch(mType) {
              case Matte::fullyOpaque:
              case Matte::fullyClear:
                break;

              case Matte::nonTrivialHardMatte:
                _hrgn = r1;
                break;
              default:
                Assert(FALSE && "Not all cases dealt with");
                break;
            }
            _accumulatedType = mType;
            _anyAccumulated = TRUE;
            
        } else {

            int ret;
            switch (_accumulatedType) {

              case Matte::fullyOpaque:

                Assert(!_hrgn &&
                       "_hrgn NOT NULL in AddHRGN opaque");

                // Adding anything to an opaque matte just
                // makes it the thing we're adding.
                _accumulatedType = mType;
                if(mType == Matte::nonTrivialHardMatte) {
                    _hrgn = r1;
                } 
                break;

              case Matte::fullyClear:

                Assert((_hrgn == NULL) && 
                       "_hrgn NOT NULL in AddHRGN clear");

                // Adding anything to a clear matte just leaves it
                // clear 
                TIME_GDI (DeleteObject(r1));
                break;

              case Matte::nonTrivialHardMatte:
                Assert(_hrgn != NULL);

                switch(mType) {
                  case Matte::fullyClear:
                    // clear everything
                    AddInfinitelyClearRegion();
                    break;
                  case Matte::fullyOpaque:
                    // no op
                    break;
                  case Matte::nonTrivialHardMatte:
                    // Add r1 to _hrgn and leave result in _hrgn.
                    TIME_GDI (ret = CombineRgn(_hrgn, _hrgn, r1, RGN_OR));
                    if (ret == ERROR ) {
                        RaiseException_InternalError("Region union failed");
                    }
                    break;
                }

                TIME_GDI (DeleteObject(r1));
                break;

              default:
                Assert(FALSE && "Not all cases dealt with");
                break;
            }       
        }
    }

    // Take the two regions, intersect them, add the result in.  Note
    // that this destructively modifies provided regions.
    void        IntersectAndAddHRGNS(HRGN r1, HRGN r2) {

        Assert( !_justDoPath );
            
        //
        // Combine intersection into r1 and add if
        // and add if not an empty region
        //
        int ret;
        TIME_GDI (ret = CombineRgn(r1, r1, r2, RGN_AND));
        Matte::MatteType accumType;

        if (ret == ERROR) {
            RaiseException_InternalError("Region intersection failed: regular");
        } else if (ret == NULLREGION) {
            accumType = Matte::fullyOpaque;
        } else {
            //
            // reasonable region
            //
            accumType = Matte::nonTrivialHardMatte;
        }

        AddHRGN(r1, accumType);
        DeleteObject(r2);
    }
    
    void        AddInfinitelyClearRegion() {
        // Just clear out existing HRGN, and make fullyClear.

        TIME_GDI (if(_hrgn) DeleteObject(_hrgn));
        _hrgn = NULL;
        _accumulatedType = Matte::fullyClear;
        _anyAccumulated = TRUE;
    }


    void        AddHalfClearRegion() {
        // Just clear out existing HRGN, and make fullyClear.
        Assert(FALSE && "HalfMatte not implemented!");

        TIME_GDI (if(_hrgn) DeleteObject(_hrgn));
        _hrgn = NULL;
        _accumulatedType = Matte::fullyClear;
    }

    
    void             SetTransform(Transform2 *xf) { _xf = xf; }
    Transform2      *GetTransform() { return _xf; }

    HDC              GetDC() { 
        if(!_dc) {
            Assert(_devCtxPtr && "_devCtxPtr NOT set in GetDC in MatteCtx");
            Assert(_devCallBack && "_devCallBack NOT set in GetDC in MatteCtx");
            _dc = _devCallBack(_devCtxPtr); 
        }
        return _dc;
    }

    HRGN             GetHRGN() { return _hrgn; }

    Matte::MatteType GetMatteType() { 
        return _anyAccumulated ? _accumulatedType : Matte::fullyOpaque;
    }

    callBackPtr_t    GetCallBack() { return _devCallBack; }
    void            *GetCallBackCtx() { return _devCtxPtr; }

    bool             JustDoPath() { return _justDoPath; }
  protected:
    void Init() {
        _xf = NULL;
        _devCallBack = NULL;
        _devCtxPtr = NULL;
        _dc = NULL;
        _hrgn = NULL;
        _anyAccumulated = FALSE;
        _justDoPath = false;
    }

    Transform2        *_xf;
    callBackPtr_t      _devCallBack;
    void              *_devCtxPtr;
    HDC                _dc;
    HRGN               _hrgn;
    bool               _justDoPath;
    HRGN               _bigRegion;
    HRGN               _fooRgn;
    Bool               _anyAccumulated;
    Matte::MatteType   _accumulatedType;
};

#endif /* _MATTEI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\matutil.h ===
#ifndef _MATUTIL_H
#define _MATUTIL_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Utility for 4x4 transformation matrices.  These are pre-multiply
transformation matrices:  Ax=y.  Unlike OpenGL, it is indexed in the standard
way, i.e. the translation component is (a(0,3), a(1,3), a(2,3)).  Conversion
functions are supplied for OpenGL compatibility.

*******************************************************************************/

#include "privinc/vecutil.h"
#include "privinc/vec3i.h"


typedef Real Apu4x4MatrixArray_t[4][4];


class Apu4x4Matrix
{
  public:
    enum form_e           // special form of transformation
    {
        UNINITIALIZED_E,
        IDENTITY_E,       // identity
        TRANSLATE_E,      // 3 x 1
        UPPER_3X3_E,      // 3 x 3
        AFFINE_E,         // 3 x 4
        PERSPECTIVE_E,    // 4 x 4
        END_OF_FORM_E
    };

    // An array of matrix form types resulting from multiplication.

    static const form_e MultiplyReturnTypes[END_OF_FORM_E][END_OF_FORM_E];

    // An array of strings for each of the matrix form types.

    static const char * const form_s [END_OF_FORM_E];

    // The actual matrix array.

    Apu4x4MatrixArray_t m;
    form_e form;
    bool is_rigid;              // true if special orthogonal
    bool pixelMode;

    // Member Functions

    // These methods return the transform origin and basis vectors.

    Point3Value  Origin (void) const;
    Vector3Value BasisX (void) const;
    Vector3Value BasisY (void) const;
    Vector3Value BasisZ (void) const;

    Real *operator[] (int i) { return m[i]; }
    const Real *operator[] (int i) const { return m[i]; }

    void SetIdentity();
    void SetType (void);       // Autoset Matrix Type

    void PostTranslate (Real x, Real y, Real z);
    void PostScale     (Real x, Real y, Real z);

    // These transform an ApuVector3 interpreted as either a point or
    // a vector.  The interpretation as a vector ignores the
    // translational component of the transformation.

    void ApplyAsPoint (const ApuVector3& x, ApuVector3& result) const;
    void ApplyAsVector (const ApuVector3& x, ApuVector3& result) const;

    // Transform the given plane.  NOTE: This method will return true
    // if the matrix is not invertable.

    bool TransformPlane (Real A, Real B, Real C, Real D, Real result[4]) const;

    // Returns the determinant of the matrix.

    Real Determinant (void) const;

    // Returns whether the matrix is orthogonal or not.

    bool Orthogonal (void) const;

    #if _USE_PRINT
        ostream& Print (ostream& os) const;
    #endif
};


inline Vector3Value Apu4x4Matrix::BasisX (void) const
{
    return Vector3Value (m[0][0], m[1][0], m[2][0]);
}


inline Vector3Value Apu4x4Matrix::BasisY (void) const
{
    return Vector3Value (m[0][1], m[1][1], m[2][1]);
}


inline Vector3Value Apu4x4Matrix::BasisZ (void) const
{
    return Vector3Value (m[0][2], m[1][2], m[2][2]);
}


inline Point3Value Apu4x4Matrix::Origin (void) const
{
    return Point3Value (m[0][3], m[1][3], m[2][3]);
}


    // Equality Operators Between Transforms

bool operator== (const Apu4x4Matrix &lhs, const Apu4x4Matrix &rhs);

inline bool operator!= (const Apu4x4Matrix &lhs, const Apu4x4Matrix &rhs)
{
    return !(lhs == rhs);
}





extern const Apu4x4Matrix apuIdentityMatrix;


void ApuTranslate (Real Dx, Real Dy, Real Dz, bool pixelMode, Apu4x4Matrix& result);

void ApuScale (Real Sx, Real Sy, Real Sz, Apu4x4Matrix& result);

void ApuRotate (Real angle, Real Ax, Real Ay, Real Az, Apu4x4Matrix& result);

void ApuRotateX (Real angle, Apu4x4Matrix& result);
void ApuRotateY (Real angle, Apu4x4Matrix& result);
void ApuRotateZ (Real angle, Apu4x4Matrix& result);

void ApuShear (Real,Real, Real,Real, Real,Real, Apu4x4Matrix& result);

void ApuMultiply
    (const Apu4x4Matrix& a, const Apu4x4Matrix& b, Apu4x4Matrix& result);

// Return false if not invertible
bool ApuInverse
    (const Apu4x4Matrix& m, Apu4x4Matrix& result);

void ApuTranspose
    (const Apu4x4Matrix& m, Apu4x4Matrix& result, int order=4);

Real ApuDeterminant (const Apu4x4Matrix& m);

bool ApuIsSingular (const Apu4x4Matrix& m);

// Validity checking for matrices

bool Valid (const Apu4x4Matrix&);
void CheckMatrix (const Apu4x4Matrix&, char *filename, int line);

#if _DEBUG
    #define CHECK_MATRIX(m) CheckMatrix(m,__FILE__,__LINE__)
#else
    #define CHECK_MATRIX(m) // Nothing if not in debug
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\miscpref.h ===
#ifndef _MISCPREFS_H
#define _MISCPREFS_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Misc Prefs structure
*******************************************************************************/

typedef struct {
// misc

// audio
   bool _synchronize;        // use servo and phase to sync
   bool _disableAudio;       // force dsound audio to be dissabled
   int  _frameRate;          // number of frames per second
   int  _sampleBytes;        // number of bytes per sample
#ifdef REGISTRY_MIDI
   bool _qMIDI;              // use quartz MIDI audioActive MIDI
#endif
} miscPrefType;

#endif /* _MISCPREFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\meshmaker.h ===
#pragma once
#ifndef _MESHMAKER_H
#define _MESHMAKER_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    For constructing a meshbuilder out of a constant geometry subgraph

*******************************************************************************/

#include "privinc/ddrender.h"
#include "privinc/comutil.h"

class MeshMaker : public GeomRenderer {
  public:

    MeshMaker(DirectDrawImageDevice *dev, int count);
    ~MeshMaker();

    void GrabResultBuilder(IDirect3DRMMeshBuilder3 **ppResult);
    int  GetCount() { return _numPrims; }
    void RenderHelper(RMVisualGeo *geo);


    HRESULT Initialize (
        DirectDrawViewport *viewport,
        DDSurface          *ddsurf)
    {
        Assert(!"Don't expect to be here");
        return E_FAIL;
    }

    void RenderGeometry (
        DirectDrawImageDevice *imgDev,
        RECT      target_region,  // Target Region on Rendering Surface
        Geometry *geometry,       // Geometry To Render
        Camera   *camera,         // Viewing Camera
        const Bbox2 &region)    // Source Region in Camera Coords
    {
        Assert(!"Don't expect to be here");
    }

    void* LookupTextureHandle (IDirectDrawSurface*, DWORD, bool, bool)
    {
        Assert (!"Don't expect to be here");
        return NULL;
    }

    void SurfaceGoingAway (IDirectDrawSurface *surface) {
        Assert(!"Don't expect to be here");
    }

    void AddLight (LightContext &context, Light &light);

    // The following methods submit a geometric primitive for rendering with
    // the current attribute state.

    void Render (RM1VisualGeo *geo);
    void Render (RM3VisualGeo *geo);

    void RenderTexMesh (void *texture,
#ifndef BUILD_USING_CRRM
                        IDirect3DRMMesh  *mesh,
                        long              groupId,
#else
                        int vCount,
                        D3DRMVERTEX *d3dVertArray,
                        unsigned *vIndicies,
                        BOOL doTexture,
#endif
                        const Bbox2 &box,
                        RECT *destRect,
                        bool bDither) {
        Assert(!"Don't expect to be here");
    }

    // SetView takes the given camera and sets the orienting and projection
    // transforms for the image viewport and volume.

    void SetView(RECT *target, const Bbox2 &viewport, Bbox3 *volume) {
        Assert(!"Don't expect to be here");
    }

    void GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum) {
        Assert(!"Don't expect to be here");
    }

    void RenderMeshBuilderWithDeviceState(IDirect3DRMMeshBuilder3 *mb);

    bool PickReady (void) {
        Assert(!"Don't expect to be here");
        return false;
    }

    DirectDrawImageDevice& GetImageDevice (void) {
        return *_imgDev;
    }

    // If we're counting, increment our count and return true, else
    // return false.
    bool CountingPrimitivesOnly_DoIncrement() {
        if (_countingOnly) {
            _numPrims++;
        }
        return _countingOnly;
    }

    bool IsMeshmaker() { return true; }

  protected:
    // Member data
    DAComPtr<IDirect3DRMMeshBuilder3> _resultBuilder;
    DirectDrawImageDevice            *_imgDev;
    int                               _numPrims;
    int                               _expectedCount;
    bool                              _countingOnly;
};

void
DumpGeomIntoBuilder(Geometry *geo,
                    DirectDrawImageDevice *dev,
                    IDirect3DRMMeshBuilder3 **ppResult);

#endif /* _MESHMAKER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\midi.h ===
#ifndef _MIDI_H
#define _MIDI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Defines the MIDI base class
*******************************************************************************/


#include "appelles/sound.h"

#include "privinc/storeobj.h"
#include "privinc/geomi.h"
#include "privinc/path.h"
#include "privinc/helpds.h"
#include "privinc/dsdev.h"
#include "privinc/snddev.h"


class MIDIsound : public LeafSound {
  public:
    //MIDIsound();
    virtual ~MIDIsound() {}
    virtual void Open(char * fileName) = 0;
#if _USE_PRINT
    virtual ostream& Print(ostream& s) { return s << "MIDI"; }
#endif

    virtual bool RenderAvailable(MetaSoundDevice *)                      = 0;
    virtual void RenderNewBuffer(MetaSoundDevice *)                      = 0;
    virtual void RenderAttributes(MetaSoundDevice *, BufferElement *,
        double rate, bool doSeek, double seek)                           = 0;
    virtual void RenderStartAtLocation(MetaSoundDevice *,
        BufferElement *bufferElement, double phase, Bool looping)        = 0;
    virtual void RenderStop(MetaSoundDevice *, BufferElement *)          = 0;
    virtual void RenderSamples(MetaSoundDevice *, BufferElement *) {}
    virtual void RenderSetMute(MetaSoundDevice *, BufferElement *)       = 0;
    virtual Bool RenderCheckComplete(MetaSoundDevice *, BufferElement *) = 0;
    virtual void RenderCleanupBuffer(MetaSoundDevice *, BufferElement *) = 0;
    virtual double GetLength()                                           = 0;

  protected:
    char       *fileName;
    Bool        _started;
    Bool        _ended;
    Bool        _looping;
};


#endif /* _MIDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\movieimg.h ===
#ifndef _MOVIEIMG_H
#define _MOVIEIMG_H


/*-------------------------------------
Copyright (c) 1996 Microsoft Corporation

Abstract:

Projected Geometry Image class declaration
-------------------------------------*/

#include "privinc/imgdev.h"
#include "privinc/imagei.h"
#include "privinc/dibimage.h"
#include "privinc/storeobj.h"
#include "privinc/bbox2i.h"
#include "privinc/helpq.h"
#include "privinc/bufferl.h"
#include "backend/moviebvr.h"

class MovieImageFrame; // forward decl

//////////////  Image from Movie  ////////////////////
class MovieImage : public DiscreteImage {
  public:
    MovieImage(QuartzVideoReader *videoReader, Real res);
    virtual ~MovieImage() { CleanUp(); }
    virtual void CleanUp();
        
    virtual void Render(GenericDevice& dev) {
        Assert(FALSE && "Shouldn't be rendering on MovieImage");
    }

    Real GetLength() { return _length; }

    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev)
    {
        if(!_dev)
            dev = _dev;
        else if(_dev != dev)
            RaiseException_UserError(E_FAIL, IDS_ERR_IMG_MULTI_MOVIE);
    }
    
    char *GetURL() { return(_url); }

#if _USE_PRINT
    ostream& Print (ostream &os) { return os << "MovieImage" ; }
#endif

    virtual VALTYPEID GetValTypeId() { return MOVIEIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == MovieImage::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }

  protected:
    ImageDisplayDev    *_dev;
    Real                _length;

  private:
    char               *_url;
};

class MovieImagePerf;

// the MovieImageFrame subclasses from a DiscreteImage.
// This image subclasses from DiscreteImage
// so that we get discrete image optimizations
// This class is intended to last one frame.  it's an
// instance of the movie: (movie X time)
class MovieImageFrame : public DiscreteImage {
  public:
    MovieImageFrame(Real time, MovieImagePerf *p);

    Real GetTime() { return _time; }
    MovieImage *GetMovieImage() {  return _movieImage; }
    void InitIntoDDSurface(DDSurface *, ImageDisplayDev *) { Assert(FALSE); }
    void Render(GenericDevice& _dev);
    virtual void DoKids(GCFuncObj proc);
    MovieImagePerf *GetPerf() { return _perf; }
    
    virtual VALTYPEID GetValTypeId() { return MOVIEIMAGEFRAME_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == MovieImageFrame::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "MovieImageFrame(" << _time << ")" ;
    }
#endif

  private:
    MovieImage *_movieImage;
    Real        _time;
    MovieImagePerf *_perf;
};

#endif /* _MOVIEIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\opt.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    General header for optimizations done in the engine

*******************************************************************************/

#ifndef _ENGINEOPT_H
#define _ENGINEOPT_H

#include "server/view.h"

#define CONSTANT_FOLD_OPT 2
#define CACHE_IMAGE_OPT   4
#define DRECT_OPT         8

extern BOOL engineOptimization;

#define REGISTRYENGINEOPT(opttype) (engineOptimization==1 || (engineOptimization & opttype))

// BUGBUG: neither of these macros checks if GetCurrentView/Prefs returns NULL

#define PERVIEW_DRECTS_ON  (REGISTRYENGINEOPT(DRECT_OPT) && GetCurrentView().GetPreferences()._dirtyRectsOn)
#define PERVIEW_BITMAPCACHING_ON  (REGISTRYENGINEOPT(CACHE_IMAGE_OPT) && GetCurrentView().GetPreferences()._BitmapCachingOn)

class RewriteOptimizationParam {
  public:
    int _dummy;
};

class DisjointCalcParam {
  public:
    Transform2 *_accumXform;
    Bbox2      _accumulatedClipBox;

    void CalcNewParamFromBox(const Bbox2 &box, DisjointCalcParam *outParam)
    {
        Bbox2 xfdBox = TransformBbox2(_accumXform, box);
        Bbox2 newBox = IntersectBbox2Bbox2(_accumulatedClipBox,
                                            xfdBox);
        outParam->_accumXform = _accumXform;
        outParam->_accumulatedClipBox = newBox;
    }
};

class CacheParam {
  public:
    CacheParam() :
        _isTexture(false),
        _pCacheToReuse(NULL),
        _cacheWithAlpha(false)
    {}

    ImageDisplayDev *_idev;
    AxAValue        *_pCacheToReuse;
    bool             _isTexture;
    bool             _cacheWithAlpha;
};

// For things to work, these should all be negative
#define PERF_CREATION_ID_FULLY_CONSTANT   -222
#define PERF_CREATION_ID_BUILT_EACH_FRAME -333

// This should be less than PERF_CREATION_ID_FULLY_CONSTANT.
#define PERF_CREATION_INITIAL_LAST_SAMPLE_ID -444

#endif  /* _ENGINEOPT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\overimg.h ===
#ifndef _OVERIMG_H
#define _OVERIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

-------------------------------------*/

#include "privinc/imagei.h"
#include "privinc/bbox2i.h"

class OverlayedImage : public Image {
    friend class DirectDrawImageDevice;

  public:

    OverlayedImage(Image *top, Image *bottom);

    void SetTopBottom(Image *top, Image *bottom) {
        _top = top; 
        _bottom = bottom;
    }

    Image *Top() { return _top; }
    Image *Bottom() { return _bottom; }

    // Rendering an overlayed image uses a painter's algorithm:
    // Render the bottom first, then the top.
    void Render(GenericDevice& _dev);

    // This function will be used by Render(), and by the
    // OverlayArrayImage::Render method as well, thus it's broken out
    // into a static method.
    static void OverlayPairRender(Image *top,
                                  Image *bottom,
                                  GenericDevice& dev);

    const Bbox2 _BoundingBox();

    const Bbox2 BoundingBox() {
        return CacheImageBbox2(this, _cached, _cachedBbox);
    }

    Real DisjointBBoxAreas(DisjointCalcParam &param);
    
    void _CollectDirtyRects(DirtyRectCtx &ctx);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return UnionBbox2Bbox2(_top->BoundingBoxTighter(bbctx),
                               _bottom->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {
        return IntersectBbox2Bbox2(box, BoundingBox());
    }

    Bool  DetectHit(PointIntersectCtx& ctx);

#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "Overlay(" << _top << ", " << _bottom << ")";
    }
#endif

    int  Savings(CacheParam& p);
    
    /* treat caching for overlays specially */
    AxAValue _Cache(CacheParam &p);  

    virtual VALTYPEID GetValTypeId() { return OVERLAYEDIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == OverlayedImage::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc);

    bool ContainsOcclusionIgnorer() {
        return _containsOcclusionIgnorer;
    }

    virtual void Traverse(TraversalContext &ctx) {
        _bottom->Traverse(ctx);
        _top->Traverse(ctx);
    }
    
  protected:

    static void DoOpacity(Image *image, ImageDisplayDev &dev);
    Image *_top;
    Image *_bottom;
    bool  _cached;
    Bbox2 _cachedBbox;
    Real  _cachedDisjointArea;
    bool  _containsOcclusionIgnorer;
};

Bool DetectHitOnOverlaidArray(PointIntersectCtx& ctx,
                              LONG               numImages,
                              Image            **images,
                              bool               containsOcclusionIgnorer);

#endif /* _OVERIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\mutex.h ===
#ifndef _MUTEX_H
#define _MUTEX_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    A simple mutex abstraction for use in Appelles.  This supports a
    Grab() method as well as a Release() method.  Additionally, there
    is another class whose constructor grabs a mutex, and whose
    destructor automatically releases it, thus freeing the programmer
    from having to remember to release the mutex, as well as allowing
    exceptions that are thrown to result in a release of the mutex,
    due to stack unwinding.


--*/

#include "appelles/common.h"

/////////////////////////  Mutexes  //////////////////////

// Simple encapsulation of a mutex with Grab and Release operations.
// The constructor creates the mutex, and the destructor destroys it.
// Grab() is a blocking function that acquires the mutex when it is
// available.  Release() releases the mutex.  An exception is thrown
// if Release() is called by a thread that doesn't own the mutex.
class Mutex {
  public:
    Mutex();
    ~Mutex();
    void Grab();
    void Release();

  protected:
    void *mutex;                // opaque pointer to actual mutex
};

// Use this class in a lexical scope that requires grabbing of a
// mutex, doing some processing, and then releasing it.  Grab by
// creating one of these objects with the desired mutex.  Exiting the
// scope implicitly will release it.
// The dontGrab parameter is here because we don't have conditional
// scope.
class MutexGrabber {
  public:
    MutexGrabber(Mutex& mutex, Bool grabIt = TRUE);
    ~MutexGrabber();

  protected:
    Mutex& mutex;
    Bool grabbed;
};

/////////////////////////  CriticalSections  //////////////////////

// This is exactly like mutex except it uses the faster critical sections

class CritSect {
  public:
    CritSect();
    ~CritSect();
    void Grab();
    void Release();

  protected:
    CRITICAL_SECTION _cs;
};

// Same as MutexGrabber

class CritSectGrabber {
  public:
    CritSectGrabber(CritSect& cs, Bool grabIt = TRUE);
    ~CritSectGrabber();

  protected:
    CritSect& _cs;
    Bool grabbed;
};

/////////////////////////  Semaphores  //////////////////////

// Simple encapsulation of a semaphore object.  Initialize with the
// semaphore's maximum count, and grab and release can specify a
// number of times to grab or release the semaphore.  Upon
// initialization, the semaphore starts out with the maximum count.
// See general documentation on semaphores to understand what these
// mean.
class Semaphore {
  public:
    Semaphore(int initialCount = 1, int maxCount = 1);
    ~Semaphore();
    void Decrement(int times = 1);

    // This returns the count *after* the increment took place. 
    int  Increment(int times = 1);

#if _DEBUG
    int _count;
    int _maxCount;
#endif
    
  protected:
    void *_semaphore;
    
};

class SemaphoreGrabber {
  public:
    SemaphoreGrabber(Semaphore& s, int times) : _s(s),_times(times) {
        _s.Decrement(_times);
    }
    ~SemaphoreGrabber() {
        _s.Increment(_times);
    }

  protected:
    Semaphore & _s;
    int _times;
};

/////////////////////////  Events  //////////////////////
// Simple encapsulation of an event object.

class Win32Event
{
  public:
    Win32Event(bool bManualReset = FALSE,bool bInitState = FALSE);
    ~Win32Event();

    void Signal() { SetEvent(_hEvent); }
    void Reset() { ResetEvent(_hEvent); }
    void Wait();

    bool IsManual() { return _bManual;}
  protected:
    HANDLE _hEvent;
    bool _bManual;
};

class EventGrabber
{
  public:
    EventGrabber(Win32Event & event)
    : _e(event) { _e.Wait(); }
    ~EventGrabber()
    { if (!_e.IsManual()) _e.Signal(); }
  protected:
    Win32Event & _e;
};

#endif /* _MUTEX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\path.h ===
#ifndef _PATH_H
#define _PATH_H

/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Static tree path class

    We need to form addresses based on ID'd nodes in the performance tree.
    "C" wrappers are provided so methods may be accessed from ML.

    NOTE:  This is a brute force first pass implementation
*******************************************************************************/

class AVPathImpl;
typedef AVPathImpl* AVPath;

const int SNAPSHOT_NODE = 0; // identifies a path as resulting from snapshot
const int RUNONCE_NODE = -1; // identifies a path as resulting from runOnce

AVPath AVPathCreate();
void AVPathDelete(AVPath);
void AVPathPush(int, AVPath);
void AVPathPop(AVPath);
int AVPathEqual(AVPath, AVPath);
AVPath AVPathCopy(AVPath);
void AVPathPrint(AVPath);
void AVPathPrintString(AVPath, char *);
char* AVPathPrintString2(AVPath);
int AVPathContainsPostfix(AVPath, AVPath postfix);
bool AVPathContains(AVPath, int value);
AVPath AVPathCopyFromLast(AVPath, int);

class AVPathListImpl;
typedef AVPathListImpl* AVPathList;

AVPathList AVPathListCreate();
void AVPathListDelete(AVPathList);
void AVPathListPush(AVPath, AVPathList);
int AVPathListFind(AVPath, AVPathList);
AVPathList AVEmptyPathList();
int AVPathListIsEmpty(AVPathList);

#endif /* _PATH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\pcm.h ===
#ifndef _PCM_H
#define _PCM_H


/**********************************************************************
The PCM class is intended to be a base class which other classes will
derive from to have PCM 'smarts'

In this way we define the math and meaning of terms only once and never
have the problems with inconsistancies which plague this type of code!
**********************************************************************/
class TimeClass {
  public:
    TimeClass() : _numSeconds(0) {}

    // queries
    virtual double GetNumberSeconds() { return(_numSeconds); }
    virtual void SetNumberSeconds(double seconds) { _numSeconds = seconds; }

    LONGLONG SecondsToQuartzTime(double seconds)
        { return((LONGLONG)(seconds * 10000000.0)); }
    double QuartzTimeToSeconds(LONGLONG qTime)
        { return((double)qTime / 10000000.0); }

  private:
    double _numSeconds;
};

class PCM : public TimeClass {
  public:
    PCM() : _sampleByteWidth(0), _numChannels(0), _frameRate(0), _numBytes(0) {}

    // conversions
    long BytesToFrames(long bytes)
        { return(bytes / _sampleByteWidth / _numChannels); }
    double BytesToSeconds(long bytes)
        { return((double)bytes / _frameRate / _sampleByteWidth /  _numChannels); }

    long FramesToBytes(long frames)
        { return(frames * _sampleByteWidth * _numChannels); }
    double FramesToSeconds(long frames)
        { return((double)frames / _frameRate); }
    LONGLONG FramesToQuartzTime(long frames)
        { return(SecondsToQuartzTime(FramesToSeconds(frames))); }

    long SecondsToFrames(double seconds)
        { return(long)(seconds * _frameRate); }
    long SecondsToBytes(double seconds)
        { return(long)(seconds * _frameRate * _sampleByteWidth * _numChannels); }


    // duration setting
    void SetNumberFrames(long frames) { _numBytes = FramesToBytes(frames); }
    void SetNumberBytes( long  bytes) { _numBytes = bytes; }
    void SetNumberSeconds(double seconds) 
        { _numBytes = SecondsToBytes(seconds); }

    // format setting (do we need individual calls in case things change?)
    void SetPCMformat(int bw, int nc, int fr)
    { _sampleByteWidth = bw; _numChannels = nc; _frameRate = fr; }

    void SetPCMformat(WAVEFORMATEX format) {
        _numChannels     = format.nChannels;
        _frameRate       = format.nSamplesPerSec;
        _sampleByteWidth = format.wBitsPerSample/8;
    }

    void SetPCMformat(PCM *pcm) {
        // for now copy fields, but maybe it can be better done with assignment
        Assert(pcm);

        _numChannels     = pcm->GetNumberChannels();
        _frameRate       = pcm->GetFrameRate();
        _sampleByteWidth = pcm->GetSampleByteWidth();
        _numBytes        = pcm->GetNumberBytes();
    }

    /* void SetWaveFormat(WAVEFORMATEX *pcmwf) {
	memset(pcmwf, 0, sizeof(WAVEFORMATEX));
	pcmwf->wFormatTag     = WAVE_FORMAT_PCM;
	pcmwf->nChannels      = GetNumberChannels();
	pcmwf->nSamplesPerSec = GetFrameRate(); //they realy mean frames!
	pcmwf->nBlockAlign    = FramesToBytes(1);
	pcmwf->nAvgBytesPerSec= SecondsToBytes(1.0);
	pcmwf->wBitsPerSample = GetSampleByteWidth() * 8;
    }*/



    // queries
    int    GetSampleByteWidth() { return(_sampleByteWidth); }
    int    GetNumberChannels()     { return(_numChannels); }
    int    GetFrameRate()       { return(_frameRate); }
    int    GetNumberBytes()     { return(_numBytes); }
    int    GetNumberFrames()    { return(BytesToFrames(_numBytes)); }
    double GetNumberSeconds()   { return(BytesToSeconds(_numBytes)); }

  private:
    int _sampleByteWidth;
    int _numChannels;
    int _frameRate;
    int _numBytes;
};


#endif /* _PCM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\path2i.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    2D paths

*******************************************************************************/


#ifndef _PATH2I_H
#define _PATH2I_H

#include "include/appelles/path2.h"
#include "privinc/storeobj.h"
#include "privinc/probe.h"

class Path2Ctx;
class LineStyle;
class BoundingPolygon;
class PathInfo;
class TransformedPath2;
class TextPath2;
class DAGDI;

class ATL_NO_VTABLE Path2 : public AxAValueObj {
  public:

    // Accumulate a path into the DC for either filling or drawing.  If this is
    // called to fill a path, the forRegion parameter should be set to true.

    void AccumPathIntoDC (HDC hdc, Transform2 *initXform, bool forRegion=false);

    void RenderToDaGdi (DAGDI *daGdi,
                        Transform2 *initXform,
                        DWORD w,
                        DWORD h,
                        Real res,
                        bool forRegion=false);

    // Return the first/last point of the path, in the local coordinate
    // system of the path.  Needed for path concatenation.
    virtual Point2Value *FirstPoint() = 0;
    virtual Point2Value *LastPoint() = 0;

    // Gathers the lengths of the component subpaths and stores accumulated
    // information in a context list.  NOTE:  HDC of Path2Ctx will be nil.

    virtual void GatherLengths (Path2Ctx&) = 0;

    // Returns the point along the path at the normalized [0,1] parameter.

    virtual Point2Value *Sample (PathInfo& pathinfo, Real num0to1) = 0;

    // Accumulate the path into the specified ctx.  Note that this
    // also has the responsibility of setting ctx._lastPoint to the
    // world coordinates of the last point.
    virtual void Accumulate(Path2Ctx& ctx) = 0;

    // Return TRUE (and fill in parameters) if we can pull out points
    // for a single polygon or polybezier.  By default, assume we
    // cannot, and return false.
    virtual Bool ExtractAsSingleContour(
        Transform2 *initXform,
        int *numPts,            // out
        POINT **gdiPts,         // out
        Bool *isPolyline        // out (true = polyline, false = polybezier)
        ) {

        return FALSE;
    }

    virtual const Bbox2 BoundingBox (void) = 0;
#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx) = 0;
#endif  // BOUNDINGBOX_TIGHTER
    virtual Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style) = 0;

    virtual DXMTypeInfo GetTypeInfo() { return Path2Type; }

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val);

    virtual Bool IsClosed() { return false; }

    // Return NULL if the path is something other than a transformed
    // path, otherwise return the TransformedPath
    virtual TransformedPath2 *IsTransformedPath() {
        return NULL;
    }

    virtual TextPath2 *IsTextPath() {
        return NULL;
    }

    virtual int Savings(CacheParam& p) { return 0; }

    virtual bool CanRenderNatively() {
        return false;  // subclass must implement if it can be
                       // rendered natively
    }
};

class TextPath2 : public Path2
{
  public:
    TextPath2(Text *text, bool restartClip);
    Point2Value *FirstPoint();
    Point2Value *LastPoint();
    void GatherLengths (Path2Ctx &context);

    Point2Value *Sample (PathInfo &pathinfo, Real distance);

    void Accumulate(Path2Ctx& ctx);

    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style);

    virtual void DoKids(GCFuncObj proc);

    virtual TextPath2 *IsTextPath() { return this; }

    Text *GetText() { return _text; }
    bool  GetRestartClip() { return _restartClip; }

    virtual int Savings(CacheParam& p) { return 3; }

  protected:
    Text *_text;
    bool  _restartClip;
};

class TransformedPath2 : public Path2
{
  public:
    TransformedPath2(Transform2 *xf, Path2 *p);

    Point2Value *FirstPoint();
    Point2Value *LastPoint();

    void GatherLengths (Path2Ctx &context);

    Point2Value *Sample (PathInfo &pathinfo, Real distance);

    // Standard push, accumulate, process, and pop...
    void Accumulate(Path2Ctx& ctx);

    // Just apply the transform...
    Bool ExtractAsSingleContour(Transform2 *initXform,
                                int *numPts,            
                                POINT **gdiPts,          
                                Bool *isPolyline);

    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style);

    virtual void DoKids(GCFuncObj proc);

    virtual Bool IsClosed();

    virtual TransformedPath2 *IsTransformedPath() {
        return this;
    }

    virtual bool CanRenderNatively() {
        return _p->CanRenderNatively();
    }

    Transform2 *GetXf() { return _xf; }
    Path2      *GetPath() { return _p; }

    virtual int Savings(CacheParam& p) { return _p->Savings(p); }

  protected:
    Transform2 *_xf;
    Path2      *_p;
};


// exposed so that we don't have to expose all
// the path2xxxx classes in a header
Path2 *InternalPolyLine2(int numPts, Point2 *pts);

Path2 *Line2(const Point2 &, const Point2 &);

#endif /* _PATH2I_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\pervasiv.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _PERVASIV_H
#define _PERVASIV_H

extern BOOL InInit ;

#endif /* _PERVASIV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\qdev.h ===
#ifndef _QDEV_H
#define _QDEV_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    DirectSound device interface.

*******************************************************************************/

//#include <windows.h>
#include "privinc/path.h"
#include "privinc/snddev.h"
#include "privinc/helpq.h"
#include "privinc/bufferl.h"
#include "privinc/gendev.h"    // DeviceType

class QuartzMIDIdev : public GenericDevice{
  public:
    friend SoundDisplayEffect;

    QuartzMIDIdev();
    ~QuartzMIDIdev();

    DeviceType GetDeviceType()   { return(SOUND_DEVICE); }

    // TODO: Remove it 
    AVPathList GetDonePathList() { return(donePathList); }

    // render methods
    void RenderSound(Sound *snd);
    void RenderSound(Sound *lsnd, Sound *rsnd);
    void BeginRendering();
    void EndRendering();

    // XXX for now; eventually we will have a structure relating many sounds...
    QuartzRenderer *_filterGraph;
    AVPath _path;                // bufferElement path which owns device 

    void StealDevice(QuartzRenderer *filterGraph, AVPath bufferPath);
    void Stop(MIDIbufferElement *);

  protected:
    // path stuff
    AVPathList          donePathList;


    // values to set, get, unset...
};

#endif /* _QDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\qmidi.h ===
#ifndef _QMIDI_H
#define _QMIDI_H

/*******************************************************************************
Copyright (c) 1997 Microsoft Corporation

    Private include file for defining quartz MIDI sounds.
*******************************************************************************/

#include "appelles/sound.h"

#include "privinc/storeobj.h"
#include "privinc/helpq.h"

class qMIDIsound : public LeafSound {
  public:
    qMIDIsound();
    ~qMIDIsound();
    virtual void Open(char *fileName);

#if _USE_PRINT
    ostream& Print(ostream& s) { return s << "MIDI"; }
#endif

    virtual bool   RenderAvailable(MetaSoundDevice *);
    double GetLength();

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

    QuartzRenderer *GetMIDI() { return _filterGraph; }
    
    static double       _RATE_EPSILON; // change needed to bother quartz

  protected:
    QuartzRenderer     *_filterGraph;
};

#endif /* _QMIDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\privpref.h ===
#pragma once
#ifndef _PRIVPREFS_H
#define _PRIVPREFS_H

/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Internal preferences class

*******************************************************************************/

#include <d3d.h>
#include <d3drm.h>

class PrivatePreferences
{
  public:
    PrivatePreferences();

    void Propagate();

    HRESULT PutPreference(char *prefName, VARIANT v);
    HRESULT GetPreference(char *prefName, VARIANT *pV);

    BOOL                _overrideMode;     // true == override app prefs

    BOOL                _rgbMode;          // true == RGB
    int                 _fillMode;         // Solid / Wireframe / Points
    int                 _shadeMode;        // Flat / Gouraud / Phong
    BOOL                _dithering;        // Disabled / Enabled
    BOOL                _texmapPerspect;   // [Perspective Texmapping] Off / On
    BOOL                _texmapping;       // [Texmapping] Off / On
    int                 _texturingQuality; // D3D RM texture quality
    BOOL                _useHW;            // Use 3D Hardware
    unsigned int        _useMMX;           // Use MMX 3D Software Rendering
    BOOL                _worldLighting;    // Light in World Coordinates

    int                 _clrKeyR;          // color key for transparency
    int                 _clrKeyG;
    int                 _clrKeyB;

    int                 _gcStat;
    BOOL                _jitterStat;
    BOOL                _heapSizeStat;
    BOOL                _dxStat;
    int                 _engineOptimization;
    double              _minFrameDuration;
    BOOL                _spritify;         // temp controls retained mode sound

    BOOL                _volatileRenderingSurface;
    
    // Optimizations
    BOOL                _dirtyRectsOn;
    BOOL                _dynamicConstancyAnalysisOn;
    BOOL                _BitmapCachingOn;

  protected:
    HRESULT DoPreference(char *prefName,
                         BOOL toPut,
                         VARIANT *pV);
};

#endif /* _PRIVPREFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\probe.h ===
#pragma once
#ifndef _PROBE_H
#define _PROBE_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Data types necessary for implementation of 2D and 3D probe.

*******************************************************************************/

#include "appelles/xform.h"
#include "appelles/xform2.h"
#include "appelles/vec2.h"
#include "appelles/image.h"
#include "privinc/imagei.h"
#include "appelles/geom.h"
#include "privinc/geomi.h"
#include "privinc/except.h"
#include "privinc/vec2i.h"

class RMVisualGeo;
struct IDirect3DRMVisual;
struct IDirect3DRMMesh;
struct IDirect3DRMFrame3;



/*****************************************************************************
The HitImageData class stores picking information for images and geometries.
*****************************************************************************/

class HitImageData : public AxAThrowingAllocatorClass {
  public:

    HitImageData() : _hasUserId(false), _userId(NULL) {}

    HitImageData(bool flag, GCIUnknown *id)
    : _hasUserId(flag), _userId(id) { }

    bool HasUserData() { return _hasUserId; }
    GCIUnknown *GetUserData() { return _userId; }

    BOOL operator<(const HitImageData &hi) const {
        return this < &hi ;
    }

    BOOL operator==(const HitImageData &hi) const {
        return this == &hi ;
    }

    typedef enum PickedType {
        Image,
        Geometry
    };

    int          _eventId;
    PickedType   _type;         // geo or image.
    Point2Value *_lcPoint2;     // only fill in one point
    Point3Value *_lcPoint3;

    // Note: the two below are inconsistent because in the 3D case, we happen
    // to have the wcToLc available, which is what we'll ultimately need, so we
    // just stash that.  In the 2D case, we don't, and we don't know if this
    // will be the winner, so we don't calculate it.

    Transform2  *_lcToWc2;      // only fill in one transform

    Vector3Value *_lcOffsetI;    // Pick Local Coord Offset Basis X Vector
    Vector3Value *_lcOffsetJ;    // Pick Local Coord Offset Basis Y Vector
    Point2Value  *_uvPoint2;     // UV point for geom hit

  private:
    bool  _hasUserId;
    GCIUnknown *_userId;
};



/*****************************************************************************
The PointIntersectCtx manages the 2D context for picking.  It maintains the
local-to-world and worl-to-local transforms of the images, and the hit
information as it traverses up the hierarchy.
*****************************************************************************/

class PointIntersectCtx : public AxAThrowingAllocatorClass
{
  public:
    PointIntersectCtx (Point2Value *wcPoint,
                       bool stuffResultsIntoQueue,
                       Real time,
                       Real lastPollTime,
                       LONG  userIDSize,
                       DWORD_PTR *outputUserIDs,
                       double *outputHitPointsArray,
                       LONG *pActualHitsPointer);

    ~PointIntersectCtx();

    void        SetTransform(Transform2 *xf);
    Transform2 *GetTransform();

    // These calls are for accumulating transforms from images only.
    // These are transforms that affect the rendered result.  The
    // other transform (above) is the totall accumulated transform
    // that affects the result, but may not include transforms that
    // affect components of the image like pen width.
    // For example, let's say you have a scaled image, then a scaled
    // path, then a bezier path.  To pick that path you need to know
    // the pen width.  However, the pen width is NOT affected by the
    // scaled path, see ?  it's only affected by image level
    // trnasforms.
    inline void        SetImageOnlyTransform( Transform2 *xf ) {
        _imgOnlyXf = xf;
    }
    inline Transform2 *GetImageOnlyTransform( ) { return _imgOnlyXf; }

    Point2Value *GetLcPoint();
    void         SetLcPoint(Point2Value *pt);
    Point2Value *GetWcPoint() { return _wcPoint; }

    // For recursive invocation.  Caller is responsible for collecting
    // and keeping state data (wc point and transform).  (This is a
    // reasonable request as long as there is only one caller -- else
    // we should move this functionality into this class so that it
    // can just be in one place.)
    void        PushNewLevel(Point2Value *newWcPoint);
    void        RestoreOldLevel(Point2Value *oldWcPoint,
                                Transform2 *oldTransform,
                                Transform2 *oldImageOnlyTransform);

    Real Time (void)         { return _time; }
    Real LastPollTime (void) { return _lastPollTime; }
    bool ResultsBeingStuffedIntoQueue (void) { return _resultsStuffed; }

    LONG    UserIDSize() { return _userIDSize; }
    DWORD_PTR  *OutputUserIDs() { return _outputUserIDs; }
    double *OutputHitPointsArray() { return _outputHitPointsArray; }
    LONG   *ActualHitsPointer() { return _pActualHitsPointer; }

    bool HaveWeGottenAHitYet(void) { return _gotHitYet; }
    void GotAHit(void) { _gotHitYet = true; }

    bool GetInsideOcclusionIgnorer() { return _insideOcclusionIgnorer; }
    void SetInsideOcclusionIgnorer(bool b) {
        _insideOcclusionIgnorer = b;
    }

    // Call when we hit an image with an event id.
    void AddEventId(int id, bool hasData, GCIUnknown *data);

    // Call when we hit an geometry.
    void AddHitGeometry
        (int id, bool hasData, GCIUnknown *udata, Point3Value *lcHitPt,
         Vector3Value *lcOffsetI, Vector3Value *lcOffsetJ, Point2Value *uvPt);

    //  get the hit image data
    vector<HitImageData>& GetResultData();

  protected:

    Point2Value	*_wcPoint;        // Image World Coordinates
    Real		 _time;           // Current Pick Time
    Real		 _lastPollTime;   // Last Pick Time
    bool		 _resultsStuffed;    // established when constructed.

    LONG		 _userIDSize;
    DWORD_PTR	*_outputUserIDs;
    double		*_outputHitPointsArray;
    LONG		*_pActualHitsPointer;

    bool		 _gotHitYet;
    bool		 _insideOcclusionIgnorer;

    Transform2	*_xf;
    Transform2	*_imgOnlyXf;

    Point2Value *_lcPoint;              // Image Local Coordinates
    Bool		 _lcPointValid;

    vector<HitImageData> _hitImages;
};



/*****************************************************************************
The data maintained for a geometry that is hit are all the "pickable geometry"
containers that led up to it, along with the transform under which they were
encountered.
*****************************************************************************/

class HitGeomData : public AxAThrowingAllocatorClass
{
  public:
    HitGeomData() : _hasUserId(false), _userId(NULL) { }

    HitGeomData(bool flag, GCIUnknown *id)
    : _hasUserId(flag), _userId(id) { }

    bool HasUserData() { return _hasUserId; }
    GCIUnknown *GetUserData() { return _userId; }

    int           _eventId;
    Transform3   *_lcToWcTransform;

    BOOL operator<(const HitGeomData &hg) const {
        return this < &hg ;
    }

    BOOL operator==(const HitGeomData &hg) const {
        return this == &hg ;
    }

  private:
    bool _hasUserId;
    GCIUnknown  *_userId;
};



/*****************************************************************************
This class manages the hit information for a particular D3D mesh.  Besides the
'wcHit' member, these fields are used to get the surface coordinates of the
object for texmap picking.
*****************************************************************************/

class HitInfo : public AxAThrowingAllocatorClass
{
  public:

    HitInfo (void)
        : lcToWc(0), texmap(0), hitVisual(0), dxxfInputs(0), mesh(0)
    {
    }

    // Fields Common to Both Picking Methods

    Transform3 *lcToWc;      // Geometry Modeling Coords to World Coords
    Image      *texmap;      // Winner's Texture Mapped Image
    Real        wcDistSqrd;  // Squared World Distance to Hit Point
    Point3Value wcoord;      // World Coordinates of Hit

    // Fields for RM6+ Picking

    Point2Value surfCoord;   // Surface Coordinate of Pick Point

    // For picking into dxtransforms
    IDirect3DRMVisual *hitVisual;
    int                hitFace;
    AxAValue          *dxxfInputs;
    int                dxxfNumInputs;
    Geometry          *dxxfGeometry;

    // Fields for old-style (pre RM6) Picking

    Point3Value      scoord;      // Screen Coords of Hit
    IDirect3DRMMesh *mesh;        // Hit D3D Mesh
    LONG             group;       // Group Index of Hit D3D RM Mesh
    ULONG            face;        // Face Index Of Hit D3D RM Mesh
};



/*****************************************************************************
For 3D picking via a pick ray; this maintains the coordinate transforms and
the hit information.
*****************************************************************************/

class GeomRenderer;

class RayIntersectCtx : public AxAThrowingAllocatorClass
{
  public:

    RayIntersectCtx (void)
        :
        _gRenderer (NULL),
        _winner (NULL),
        _texmap (0),
        _texmapLevel (0),
        _gotAWinner (false),
        _lcToWc (identityTransform3),
        _pickFrame (NULL),
        _dxxfNumInputs(0),
        _dxxfInputs(NULL),
        _dxxfGeometry(NULL),
        _subgeo(NULL),
        _upsideDown(false)
    { }

    ~RayIntersectCtx (void);

    // The Init() method returns false if initialization failed.

    bool Init (PointIntersectCtx&, Camera*, Geometry*);

    // These methods set/query the local-to-world transform for geometries.

    void         SetLcToWc (Transform3 *xf);
    Transform3  *GetLcToWc (void);

    // These two functions control the attribution of geometries for texture-
    // mapping.  The probe traverser calls SetTexture with each new texmap
    // attribution, descends into the geometry, and then calls EndTexmap() to
    // end the scope of the current texture.  These two functions
    // automatically manage the semantics of overriding attribution.

    void SetTexmap (Image *texture, bool upsideDown);
    void EndTexmap (void);

    // Control whether or not we're interested in texture and submesh
    // information.
    void SetDXTransformInputs(int numInputs,
                              AxAValue *inputs,
                              Geometry *dxxfGeo) {
        _dxxfNumInputs = numInputs;
        _dxxfInputs = inputs;
        _dxxfGeometry = dxxfGeo;
    }

    // Return the world-coordinate pick ray.

    Ray3 *WCPickRay (void) const;

    // These methods manage the candidate stack.

    void PushPickableAsCandidate (int eventId, bool hasData, GCIUnknown *data);
    void PopPickableAsCandidate (void);

    // Submit hit information to the ray-intersection context.  This also
    // copies the candidate data into the winner data if the hit is closer
    // than any prior hit.

    void SubmitHit (HitInfo *hit);

    // Return true if the given world-coordinate point is closer than the
    // current pick winner.

    bool CloserThanCurrentHit (Point3Value &wcPoint);

    // Process the events, and return whether or not any geometry was hit.

    bool ProcessEvents (void);

    // Submit a hit test on a Direct3D RM visual.

    void Pick (IDirect3DRMVisual *vis);

    void SubmitWinner(Real hitDist,
                      Point3Value &pickPoint,
                      float   tu,
                      float   tv,
                      int     faceIndex,
                      IDirect3DRMVisual *hitVisual);

    void SetPickedSubGeo(Geometry *subGeo, float tu, float tv);

    Geometry *GetPickedSubGeo(float *ptu, float *ptv);

    bool LookingForSubmesh();
    bool GotTheSubmesh();

    Camera *GetCamera (void) const;    // Query the Current Camera

  protected:

    // Flags
    bool _gotAWinner;   // True if We Currently Have a Valid Hit
    bool _rmraypick;    // True if Using RM Ray Picking (RM6+)
    bool _upsideDown;

    Camera     *_camera;       // Camera Used for Projected Geometry
    Ray3       *_wcRay;        // World-Coordinate Pick Ray
    Transform3 *_lcToWc;       // Local-To-World Transform
    Image      *_texmap;       // Current Geometry Texture Map
    int         _texmapLevel;  // Current Levels of Texture Mapping
    HitInfo    *_winner;       // Winner Hit Information

    int        _dxxfNumInputs;
    AxAValue  *_dxxfInputs;
    Geometry  *_dxxfGeometry;
    float      _subgeoTu, _subgeoTv;
    Geometry  *_subgeo;

    // NOTE: One we can always count on RM6, we can change _winner to be an
    //       instance of HitInfo, rather than a pointer to one.

    PointIntersectCtx   *_context2D;         // 2D Picking Context

    vector<HitGeomData> _candidateData;      // Hit Data: Candiate Hit Point
    vector<HitGeomData> _currentWinnerData;

    // Variables for Old-Style Picking

    GeomRenderer *_gRenderer;   // Renderer Object Hijacked for Picking

    // Variables for RM Ray-Picking

    IDirect3DRMFrame3* _pickFrame;  // Frame for RM Ray Picking
};


inline Camera* RayIntersectCtx::GetCamera (void) const
{
    return _camera;
}


inline Ray3* RayIntersectCtx::WCPickRay (void) const
{
    return _wcRay;
}


bool PerformPicking (Image *img,
                     Point2Value *wcPos,
                     bool stuffResults,
                     Real time,
                     Real lastPollTime,
                     LONG size = 0,
                     DWORD_PTR *userIds = NULL,
                     double *points = NULL,
                     LONG *actualHits = NULL);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\quati.h ===
#ifndef _QUATI_H
#define _QUATI_H

/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:



Revision:



--*/

#ifdef QUATERNIONS_REMOVED_FOR_NOW

#include "appelles/common.h"
#include "appelles/valued.h"
#include <appelles/vec3.h>

class Quaternion : public AxAValueObj
{
 public:
    // Note: in order for transformations based on quaternions to work, u must
    // be a unit vector.
    Quaternion(Real cc, Vector3Value *uu) : 
       heapCreatedOn(GetHeapOnTopOfStack()), angleCalc(FALSE), c(cc) 
       { u = uu; }

    // This takes the quaternion components c and u as well as what they mean graphically: angle + axis.
    Quaternion(Real cc, Vector3Value *uu, Real angl, Vector3Value *axi) : 
       heapCreatedOn(GetHeapOnTopOfStack()), c(cc), angle(angl), angleCalc(TRUE) 
       { u = uu; axis = axi; }

    Real C() { return c; }
    Vector3Value *U() { return u; }

    Real Angle() { 
        if(!angleCalc)        {
            angle = 2*acos(c);
            angleCalc = TRUE;
        }
        return angle;
    }
    
    Vector3Value *Axis() {
        if (!angleCalc) {
            PushDynamicHeap(heapCreatedOn);
            axis = u/sin(Angle()/2.0);
            PopDynamicHeap();
            angleCalc = TRUE;
        }
        return axis;
    }

 private:
    Real c;                        // Real component
    Vector3Value *u;               // Imaginary (actualy a 3D vector) component

    Real angle;                        // Cache theta. Useful for extraction of composed Quaternions
    Vector3Value *axis;                // Cache axis of rotation.  Same as theta. NOT NORMALIZED!

    DynamicHeap& heapCreatedOn;
    Bool angleCalc;                // For lazy eval of angle and axis.
};

#endif QUATERNIONS_REMOVED_FOR_NOW

#endif                          // _QUATI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\registry.h ===
/*******************************************************************************
Copyright (c) 1995_96 Microsoft Corporation

    Support for server preferences stored in the registry.
*******************************************************************************/

#ifndef _REGISTRY_H
#define _REGISTRY_H

#include "privinc/privpref.h"

class RegistryEntry {
  public:
    RegistryEntry();
    RegistryEntry(char *subdirectory, char *item);

  protected:
    void SetEntry(char *subdirectory, char *item);
    bool Open(HKEY *phk);       // return TRUE if this is newly created
    void Close(HKEY hk);

    char *_subdirectory;
    char *_item;
};

class IntRegistryEntry : public RegistryEntry {
  public:
    IntRegistryEntry();
    IntRegistryEntry(char *subdir,
                     char *item,
                     int initialValue   // set to this if key doesn't exist
                     );

    void SetEntry(char *subdir, char *item);

    int  GetValue();

  protected:
    int _defaultVal;
};


typedef void (*UpdaterFuncType)(PrivatePreferences *, Bool);

// Extend the global list of preference updater functions.
extern void ExtendPreferenceUpdaterList(UpdaterFuncType updaterFunc);

// Update all the user preferences.
extern void UpdateAllUserPreferences(PrivatePreferences *prefs,
                                     Bool isInitializationTime);

// Startup a thread in which the property sheet is displayed.  When
// the sheet is exited, the property sheet is destroyed, and the
// thread terminated.
extern void DisplayPropertySheet(HINSTANCE inst, HWND hwnd);

///////////////// Preference strings for registry items

// Engine preference strings
#define PREF_ENGINE_MAX_FPS             "Max FPS"
#define PREF_ENGINE_OVERRIDE_APP_PREFS  "Override Application Preferences"
#define PREF_ENGINE_OPTIMIZATIONS_ON    "Optimizations On"
#define PREF_ENGINE_RETAINEDMODE        "Enable Retained-Mode Extensions"

// 3D preference strings
#define PREF_3D_DITHER_ENABLE    "Dither Enable"
#define PREF_3D_FILL_MODE        "Fill Mode"
#define PREF_3D_LIGHT_ENABLE     "Light Enable"
#define PREF_3D_PERSP_CORRECT    "Perspective Correct Texturing"
#define PREF_3D_RGB_LIGHTING     "RGB Lighting"
#define PREF_3D_SHADE_MODE       "Shade Mode"
#define PREF_3D_TEXTURE_ENABLE   "Texture Enable"
#define PREF_3D_TEXTURE_QUALITY  "Texture Quality"
#define PREF_3D_USEHW            "Enable 3D Hardware Acceleration"
#define PREF_3D_USEMMX           "Use MMX"
#define PREF_3D_VIEWDEPSPEC      "View Dependent Specular"
#define PREF_3D_SORTEDALPHA      "Sorted Transparency"
#define PREF_3D_WORLDLIGHTING    "World-Coordinate Lighting"

// 2D preference strings
#define PREF_2D_COLOR_KEY_RED    "ColorKey Red (0-255)"
#define PREF_2D_COLOR_KEY_GREEN  "ColorKey Green (0-255)"
#define PREF_2D_COLOR_KEY_BLUE   "ColorKey Blue (0-255)"

// Audio preference strings
#define PREF_AUDIO_SW_SYNTH      "Use software synth"
#define PREF_AUDIO_SYNCHRONIZE   "Synchronize via rate and phase"
#define PREF_AUDIO_QMIDI         "Use Quartz MIDI"
#define PREF_AUDIO_FRAMERATE     "Frame Rate"
#define PREF_AUDIO_SAMPLE_BYTES  "Bytes per sample"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\snddev.h ===
#ifndef _SNDDEV_H
#define _SNDDEV_H


/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    General sound device interface.

*******************************************************************************/

#include "privinc/util.h"
#include "gendev.h"

class DirectSoundDev;

class MetaSoundDevice : public GenericDevice {
  public:
    MetaSoundDevice(HWND hwnd, Real latentsy); // primary constuctor
    MetaSoundDevice(MetaSoundDevice *);        // used to clone existing object
    ~MetaSoundDevice();
    void ResetContext();

    DeviceType GetDeviceType() { return SOUND_DEVICE; }

    Bool GetLooping() { return _currentLooping; }
    void SetLooping() {
        _currentLooping    = TRUE;
        _loopingHasBeenSet = TRUE;
    }
    void UnsetLooping() {
        _currentLooping    = FALSE;
        _loopingHasBeenSet = FALSE;
    }
    Bool IsLoopingSet() { return _loopingHasBeenSet; } // XXX Not needed anymore

    void SetGain(Real r) { _currentGain = r; }
    Real GetGain() { return _currentGain; }

    void SetPan(Real p) { _currentPan = p; }
    Real GetPan() { return _currentPan; }

    void SetRate(Real r) { _currentRate = r; }
    Real GetRate() { return _currentRate; }

    // XXX eventualy might want to move these to protected/use mthd to access
    DirectSoundDev *dsDevice;

    bool AudioDead()    { return(_fatalAudioState); }
    void SetAudioDead() { _fatalAudioState = true;  }

    //_seekMutex
    double     _seek;              // the seek position

  protected:

    // values to set, get, unset...
    double     _currentGain;
    double     _currentPan;
    double     _currentRate;
    bool       _currentLooping;
    bool       _loopingHasBeenSet;
    bool       _fatalAudioState;
};


class SoundDisplayEffect;

MetaSoundDevice *CreateSoundDevice(HWND hwnd, Real latentsy);
void DestroySoundDirectDev(MetaSoundDevice * impl);

void DisplaySound (Sound *snd, MetaSoundDevice *dev);

#endif /* _SNDDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\polygon.h ===
#ifndef _POLYGON_H
#define _POLYGON_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    bounding Polygon header

-------------------------------------*/

#include "appelles/xform2.h"

//
// Helper function to create and initialize a BoundingPolygon
//
class BoundingPolygon;
BoundingPolygon *NewBoundingPolygon(const Bbox2 &box=NullBbox2);

class BoundingPolygon : public AxAValueObj {

    friend BoundingPolygon *NewBoundingPolygon(const Bbox2 &box);
    
  private:
    // can only be constructed through helper function
    BoundingPolygon();
    void PostConstructorInitialize(void);

  public:
    ~BoundingPolygon();
    void SetBox(const Bbox2 &box);

    void Crop(const Bbox2 &box);
    void Transform(Transform2 *xform);

    // returns number of verts in polygon.
    // copied to vert array iff number >= 3
    int  GetPointArray(Point2Value **vertArray,
                       Bool clockwise=FALSE,
                       bool * pbReversed=NULL);
    
    int GetPointCount() { return _vertexCount; }

    const Bbox2 BoundingBox();

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    void AddToPolygon(BoundingPolygon &pgon);
    void AddToPolygon(int numPts, Point2Value **pts);

    Bool PtInPolygon(Point2Value *pt);

    virtual void DoKids(GCFuncObj proc);
    
    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }

    #if _DEBUG
    void BoundingPolygon::_debugOnly_Print();
    #endif

  private:
    void TestAndAdd(Real axis,
                    Real ax, Real ay,
                    Real bx, Real by,
                    Bool aOut,
                    Bool bOut,
                    Bool XY,
                    Point2Value *b,
                    list<Point2Value *> *vertList);

    void ForceTransform();

    int _vertexCount;
    Transform2 *_accumXform;
    Bool _xfDirty;

    list<Point2Value *> *_vertList;
};


#endif /* _POLYGON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\resource.h ===
/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Direct Animation Resources.  To add new messages, define the constant ID
    here, and add the English description to src/appel/rsrc/danim.rc.

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define IDR_PERVASIVES             10

/* .X File Resources For VRML reading */
#define IDR_XFILE_SPHERE           13
#define IDR_XFILE_CONE_BODY        14
#define IDR_XFILE_CONE_BOTTOM      15
#define IDR_XFILE_CYLINDER_TOP     16
#define IDR_XFILE_CYLINDER_BOTTOM  17
#define IDR_XFILE_CYLINDER_BODY    18
#define IDR_XFILE_CUBE_TOP         20
#define IDR_XFILE_CUBE_BOTTOM      21
#define IDR_XFILE_CUBE_FRONT       22
#define IDR_XFILE_CUBE_BACK        23
#define IDR_XFILE_CUBE_LEFT        24
#define IDR_XFILE_CUBE_RIGHT       25

#define IDR_DXACTRL                101
#define IDR_DXACTRL_WINDOWED       102

#define IDB_DXACTRL                111
#define IDB_DXACTRL_WINDOWED       112

#define ERROR_BASE                200
#define STATUS_BASE              1200

#define IDS_OPENING_FILE      (STATUS_BASE + 0)
#define IDS_DOWNLOAD_FILE     (STATUS_BASE + 1)
#define IDS_DOWNLOAD_PCT_FILE (STATUS_BASE + 2)

// Define the error messages - separate by module
// Save the first section for general errors

#define SRV_ERROR_BASE        (ERROR_BASE + 100) // Server
#define BE_ERROR_BASE         (ERROR_BASE + 200) // Back End
#define GEO_ERROR_BASE        (ERROR_BASE + 300) // Geometry values & operations
#define IMG_ERROR_BASE        (ERROR_BASE + 400) // Image values & operations
#define SND_ERROR_BASE        (ERROR_BASE + 500) // Sound values & operations
#define SPLINE_ERROR_BASE     (ERROR_BASE + 600) // Spline values & operations
#define MISCVAL_ERROR_BASE    (ERROR_BASE + 700) // Misc values & operations
#define EXTEND_ERROR_BASE     (ERROR_BASE + 800) // Extensibility operations


////////////  General errors


#define IDS_ERR_FILE_NOT_FOUND         (ERROR_BASE + 0)   /* %1 - URL */
#define IDS_ERR_INVERT_SINGULAR_MATRIX (ERROR_BASE + 1)   /* No params */
#define IDS_ERR_STACK_FAULT            (ERROR_BASE + 2)   /* No params */
#define IDS_ERR_DIVIDE_BY_ZERO         (ERROR_BASE + 3)   /* No params */
#define IDS_ERR_OUT_OF_MEMORY          (ERROR_BASE + 4)   /* No params */

#ifdef _DEBUG
#define IDS_ERR_OUT_OF_MEMORY_DBG      (ERROR_BASE + 5)   /* %1 - Amount of memory, %2 - msg */
#endif

#define IDS_ERR_ABORT                  (ERROR_BASE + 6)   /* No params */
#define IDS_ERR_INVALIDARG             (ERROR_BASE + 7)   /* No params */
#define IDS_ERR_CORRUPT_FILE           (ERROR_BASE + 8)   /* %1 - URL */
#define IDS_ERR_OPEN_FILE_FAILED       (ERROR_BASE + 9)   /* %1 - Filename */
#define IDS_ERR_INTERNAL_ERROR         (ERROR_BASE + 10)  /* No params */
#define IDS_ERR_MATRIX_NUM_ELEMENTS    (ERROR_BASE + 11)  /* No params */
#define IDS_ERR_ZERO_ELEMENTS_IN_ARRAY (ERROR_BASE + 12)  /* No params */
#define IDS_ERR_TYPE_MISMATCH          (ERROR_BASE + 13)  /* No params */
#define IDS_ERR_NO_DECODER             (ERROR_BASE + 14)  /* %1 - filename*/
#define IDS_ERR_DECODER_FAILED         (ERROR_BASE + 15)  /* %1 - filename*/
#define IDS_ERR_UNKNOWN_MIME_TYPE      (ERROR_BASE + 16)  /* %1 - filename*/
#define IDS_ERR_ACCESS_DENIED          (ERROR_BASE + 17)  /* %1 - URL */
#define IDS_ERR_SHARING_VIOLATION      (ERROR_BASE + 18)  /* %1 - URL */
#define IDS_ERR_NOT_READY              (ERROR_BASE + 19)  /* No params */
#define IDS_ERR_REGISTRY_ERROR         (ERROR_BASE + 20)  /* No params */
#define IDS_ERR_NOT_IMPLEMENTED        (ERROR_BASE + 21)
#define IDS_ERR_PRE_DX3                (ERROR_BASE + 22)

#define IDS_RENDER_ERROR               (ERROR_BASE + 23) /*Unexpected render error*/
#define IDS_TICK_ERROR                 (ERROR_BASE + 24) /*Unexpected tick error*/
#define IDS_UNEXPECTED_ERROR           (ERROR_BASE + 25) /*Unexpected error*/
#define IDS_DISPLAYCHANGE_ERROR        (ERROR_BASE + 26) /*Unexpected error*/
////////////  Geometry section errors


#define IDS_ERR_GEO_UNABLE_TO_UNZIP        (GEO_ERROR_BASE + 0) /* %1 - filename */

#if INCLUDE_VRML
    #define IDS_ERR_GEO_VRML_READ_ERR        (GEO_ERROR_BASE +1)/*%1=filename*/
    #define IDS_ERR_GEO_VRML_NO_VERTICES     (GEO_ERROR_BASE +2)/*No params*/
    #define IDS_ERR_GEO_VRML_INSUFF_NRM_INDS (GEO_ERROR_BASE +3)/*No params*/
    #define IDS_ERR_GEO_VRML_TXT_CRD_MISMTCH (GEO_ERROR_BASE +4)/*No params*/
    #define IDS_ERR_GEO_VRML_TC_OUT_OF_RANGE (GEO_ERROR_BASE +5)/*No params*/
    #define IDS_ERR_GEO_VRML_INSUFF_MAT_INDS (GEO_ERROR_BASE +6)/*No params*/
#else
    #define IDS_ERR_GEO_VRML_NOT_SUPPORTED   (GEO_ERROR_BASE +1)/*No params*/
#endif

#define IDS_ERR_GEO_CREATE_D3DRM       (GEO_ERROR_BASE + 7) /* No params */
#define IDS_ERR_GEO_AT_FROM_COINCIDENT (GEO_ERROR_BASE + 8) /* No params */
#define IDS_ERR_GEO_PARALLEL_UP        (GEO_ERROR_BASE + 9) /* No params */
#define IDS_ERR_GEO_SINGULAR_CAMERA    (GEO_ERROR_BASE +10) /* No params */
#define IDS_ERR_GEO_CAMERA_FOCAL_DIST  (GEO_ERROR_BASE +11) /* No params */
#define IDS_ERR_GEO_BAD_RMTEXTURE      (GEO_ERROR_BASE +12) /* No params */

#define IDS_ERR_GEO_TMESH_MIN_INDICES  (GEO_ERROR_BASE +13)
#define IDS_ERR_GEO_TMESH_MIN_POS      (GEO_ERROR_BASE +14) /* %1=nPos,  %2=nTris, %3=nPos expected */
#define IDS_ERR_GEO_TMESH_MIN_NORM     (GEO_ERROR_BASE +15) /* %1=nNorm, %2=nTris, %3=nNorm expected */
#define IDS_ERR_GEO_TMESH_MIN_UV       (GEO_ERROR_BASE +16) /* %1=nUV,   %2=nTris, %3=nUV expected */
#define IDS_ERR_GEO_TMESH_OOB_PINDEX   (GEO_ERROR_BASE +17) /* index */
#define IDS_ERR_GEO_TMESH_OOB_NINDEX   (GEO_ERROR_BASE +18) /* index */
#define IDS_ERR_GEO_TMESH_OOB_UINDEX   (GEO_ERROR_BASE +19) /* index */
#define IDS_ERR_GEO_TMESH_BAD_PINDEX   (GEO_ERROR_BASE +20) /* index */
#define IDS_ERR_GEO_TMESH_BAD_NINDEX   (GEO_ERROR_BASE +21) /* index */
#define IDS_ERR_GEO_TMESH_BAD_UINDEX   (GEO_ERROR_BASE +22) /* index */
#define IDS_ERR_GEO_TMESH_BAD_INDICES  (GEO_ERROR_BASE +23)

////////////  Image section errors

#define IDS_ERR_IMG_BAD_BITDEPTH        (IMG_ERROR_BASE + 0) /* %1 - bit depth */
#define IDS_ERR_IMG_OPACITY_DEPTH       (IMG_ERROR_BASE + 1)  /* no params */
#define IDS_ERR_IMG_BMAPEFF_GET_FMT_CNT (IMG_ERROR_BASE + 2)  /* no params */
#define IDS_ERR_IMG_BMAPEFF_GET_FMTS    (IMG_ERROR_BASE + 3)  /* no params */
#define IDS_ERR_IMG_NOT_ENOUGH_PTS_2    (IMG_ERROR_BASE + 4)  /* no params */
#define IDS_ERR_IMG_NOT_ENOUGH_PTS_3    (IMG_ERROR_BASE + 5)  /* no params */
#define IDS_ERR_IMG_NOT_ENOUGH_PTS_4    (IMG_ERROR_BASE + 6)  /* no params */
#define IDS_ERR_IMG_ARRAY_MISMATCH      (IMG_ERROR_BASE + 7)  /* no params */
#define IDS_ERR_IMG_MULTI_MOVIE         (IMG_ERROR_BASE + 8)  /* no params */
#define IDS_ERR_IMG_INVALID_LINESTYLE   (IMG_ERROR_BASE + 9)  /* no params */
#define IDS_ERR_IMG_SURFACE_BUSY        (IMG_ERROR_BASE + 10) /* no params */
#define IDS_ERR_IMG_BAD_DXTRANSF_USE    (IMG_ERROR_BASE + 11) /* no params */

////////////  Sound section errors

#define IDS_ERR_SND_LOADSECTION_FAIL       (SND_ERROR_BASE + 0) /* %1 - filename */

////////////  Server section errors

#define IDS_ERR_SRV_INVALID_ASSOC          (SRV_ERROR_BASE + 0)  /* %1 - extension */
#define IDS_ERR_SRV_INVALID_RUNBVRID       (SRV_ERROR_BASE + 1)  /* %1 - id */
#define IDS_ERR_SRV_BAD_SCRIPTING_LANG     (SRV_ERROR_BASE + 2) /*no param*/
#define IDS_ERR_SRV_SCRIPT_STRING_TOO_LONG (SRV_ERROR_BASE + 3) /*%1-len*/
#define IDS_ERR_SRV_RENDER_NOT_REENTRANT   (SRV_ERROR_BASE + 4) /*no param*/
#define IDS_ERR_SRV_CONST_REQUIRED         (SRV_ERROR_BASE + 5) /*no param*/
#define IDS_ERR_SRV_INVALID_DEVICE         (SRV_ERROR_BASE + 6) /*no param*/
#define IDS_ERR_SRV_VIEW_TARGET_NOT_SET    (SRV_ERROR_BASE + 7) /*no param*/

////////////  Backend section errors

#define IDS_ERR_BE_TYPE_MISMATCH   (BE_ERROR_BASE + 0) /* %1 - str, %2 - type1 , %3 - type2 */
#define IDS_ERR_BE_BAD_INDEX       (BE_ERROR_BASE + 1) /* %1 - prefix, %2 - maxsize, %3 - index */
#define IDS_ERR_BE_TUPLE_LENGTH    (BE_ERROR_BASE + 2) /* no param */
#define IDS_ERR_BE_ALREADY_INIT    (BE_ERROR_BASE + 3) /* no param */
#define IDS_ERR_BE_WRONG_TRIGGER   (BE_ERROR_BASE + 4) /* no param */
#define IDS_ERR_BE_PERF_USERDATA   (BE_ERROR_BASE + 5) /* no param */
#define IDS_ERR_BE_TRANS_CONST_BVR (BE_ERROR_BASE + 6) /* no param */
#define IDS_ERR_BE_TRANS_GONE      (BE_ERROR_BASE + 7) /* no param */
#define IDS_ERR_BE_FINALIZED_SW    (BE_ERROR_BASE + 8) /* no param */
#define IDS_ERR_BE_BAD_SWITCH      (BE_ERROR_BASE + 9) /* no param */
#define IDS_ERR_BE_UNINITIALIZED_BVR    (BE_ERROR_BASE +  10) /* no param */
#define IDS_ERR_BE_NUM_EXTRACT     (BE_ERROR_BASE + 11) /* no param */
#define IDS_ERR_BE_STR_EXTRACT     (BE_ERROR_BASE + 12) /* no param */
#define IDS_ERR_BE_BOOL_EXTRACT    (BE_ERROR_BASE + 13) /* no param */
#define IDS_ERR_BE_UNTILNOTIFY     (BE_ERROR_BASE + 14) /* no param */
#define IDS_ERR_BE_BADHOOKRETURN   (BE_ERROR_BASE + 15) /* no param */
#define IDS_ERR_BE_IMPORTFAILURE   (BE_ERROR_BASE + 16) /* %1 - string descrip*/
#define IDS_ERR_BE_CYCLIC_BVR      (BE_ERROR_BASE + 17) /* no param */
#define IDS_ERR_BE_NON_CONST_DURATION      (BE_ERROR_BASE + 18) /* no param */

#define IDS_ERR_BE_ARRAY_ADD      (BE_ERROR_BASE + 19) /* no param */
#define IDS_ERR_BE_ARRAY_REM      (BE_ERROR_BASE + 20) /* no param */
#define IDS_ERR_BE_ARRAY_FLAG     (BE_ERROR_BASE + 21) /* no param */
#define IDS_ERR_BE_ARRAY_ADD_TYPE (BE_ERROR_BASE + 22) /* no param */

// %1 degree, %2 knots, %3 points
#define IDS_ERR_SPLINE_KNOT_COUNT          (SPLINE_ERROR_BASE + 0) /* no param */
#define IDS_ERR_SPLINE_KNOT_MONOTONICITY   (SPLINE_ERROR_BASE + 1) /* no param */
#define IDS_ERR_SPLINE_BAD_DEGREE          (SPLINE_ERROR_BASE + 2) /* no param */
#define IDS_ERR_SPLINE_MISMATCHED_WEIGHTS  (SPLINE_ERROR_BASE + 3) /* no param */

#define IDS_ERR_MISCVAL_BAD_EXTRUDE     (MISCVAL_ERROR_BASE + 0) /* no params */

#define IDS_ERR_EXTEND_DXTRANSFORM_FAILED      (EXTEND_ERROR_BASE + 0) /* no param */
#define IDS_ERR_EXTEND_DXTRANSFORM_NEED_DX6    (EXTEND_ERROR_BASE + 1) /* no param */
#define IDS_ERR_EXTEND_DXTRANSFORM_FAILED_LOAD (EXTEND_ERROR_BASE + 2) /* %1 - clsid */
#define IDS_ERR_EXTEND_DXTRANSFORM_CLSID_FAIL  (EXTEND_ERROR_BASE + 3) /* no param */

#define RESID_TYPELIB           1

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\scores.h ===
#ifndef _SCORES_H
#define _SCORES_H

/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Header file for score.  Score is an object that has a Start method
    which takes global time, alpha data and produces a behavior that
    returns beta type.

--*/

#include "appelles/envelope.h"

typedef struct _Unit {
    void* dummy;
}* Unit;

RB_CONST(Unit unit);

typedef TimeType TimeG;

// Unfortunately C++ doesn't support template-based typedef.
// Handler is the generalized case for Scores

// Define the handler implementation first.

template<class A, class B>
class ATL_NO_VTABLE HandlerImpl : public HasRefCount
{
  public:
    virtual B Handle(TimeG, A) = 0;

    virtual void Init(HandlerImpl<A, B>*)
    { RaiseException_InternalError("Handler can only be initialized once."); }
};

// This is used to promote constant to constant handler.
// A constant handler ignores the input data and always
// returns the constant.

template<class A, class B>
class ConstHandlerImpl : public HandlerImpl<A, B>
{
  public:
    ConstHandlerImpl(const B i) : data(i) {}
        
    virtual B Handle(TimeG, A) { return data; }

  private:
    B data;
};

template<class A, class B>
class InitHandlerImpl : public HandlerImpl<A, B>
{
  public:
    InitHandlerImpl() : impl(NULL) {}
    
    virtual B Handle(TimeG t, A data)
    {
        if (!impl)
            RaiseException_InternalError("Handler not initialized.");

        return impl->Handle(t, data);
    }
        
    virtual void Init(HandlerImpl<A, B>* i)
    {
        if (impl)
            RaiseException_InternalError("Handler can only be initialized once.");
        else
        {
            // no need to RefSubDel, since impl == NULL
            impl = i;

            impl->Add(1);
        }
    }

  private:
    HandlerImpl<A, B>* impl;
};

// Handler is an envelope.

template<class A, class B>
class Handler : public Envelope< HandlerImpl<A, B> >
{
  public:
    Handler() {}

    Handler(HandlerImpl<A, B>* i) : Envelope< HandlerImpl<A, B> >(i) {}

    Handler(const B i)
        : Envelope< HandlerImpl<A, B> >(new ConstHandlerImpl<A, B>(i)) {}

    B Handle(TimeG t, A data) { return GetImpl()->Handle(t, data); }

    void Init(Handler<A, B> h) { GetImpl()->Init(h.GetImpl()); }
};

// What really needs is template typedef.
//#define Score(A, B) Handler<A, Bvr<B> >

template<class A, class B>
class Score : public Handler< A, Bvr<B> >
{
  public:
    Score(char* n = NULL)
        : name(n), Handler< A, Bvr<B> >
            (new InitHandlerImpl<A, Bvr<B> >()) {}
    
    Score(HandlerImpl< A, Bvr<B> > *i) : Handler< A, Bvr<B> >(i) {}

    Score(Bvr<B> b)
        : Handler< A, Bvr<B> >(new ConstHandlerImpl<A, Bvr<B> >(b)) {}
    
    Score(const B i) : Handler< A, Bvr<B> >(i) {}

    char* GetName() { return name; }
    
  private:
    char* name;
};

template<class A>
class EventTimeHandlerImpl : public HandlerImpl< A, Bvr<TimeG> >
{
  public:
    virtual Bvr<TimeG> Handle(TimeG t, A) { return t; }
};

template<class A, class B>
class CondScoreImpl : public HandlerImpl< A, Bvr<B> >
{
  public:
    CondScoreImpl(Score<A, Bool> b, Score<A, B> i, Score<A, B> e)
        : bScore(b), iScore(i), eScore(e) {}
    
    virtual Bvr<B> Handle(TimeG t, A data)
    {
        return new CondBvrImpl<B>(bScore.Handle(t, data),
                                  iScore.Handle(t, data),
                                  eScore.Handle(t, data));
    }

  private:
    Score<A, Bool> bScore;
    Score<A, B> iScore;
    Score<A, B> eScore;
};

template<class A, class B>
inline
Score<A, B> Cond(Score<A, Bool> b, Score<A, B> iScore, Score<A, B> eScore)
{ return new CondScoreImpl<A, B>(b, iScore, eScore); }

// Don't know why this is not working...
template<class A>
class EventTime : public Score<A, TimeG>
{
  public:
    EventTime() : Score<A, TimeG>(new EventTimeHandlerImpl<A>()) {}
};

template<class A, class B>
class SnapshotHandlerImpl : public HandlerImpl<A, Bvr<B> >
{
  public:
    SnapshotHandlerImpl(Score<A, B> s) : score(s) {}
    
    virtual Bvr<B> Handle(TimeG t, A data)
    {
        EvalParam tparam(t);
        
        return score.Handle(t, data).Eval(tparam);
    }

  private:
    Score<A, B> score;
};

template<class A, class B>
Handler<A, B>
Snapshot(Score<A, B> s)
{ return new SnapshotHandlerImpl<A, B>(s); }

#endif /* _SCORES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\rmvisgeo.h ===
#pragma once
#ifndef _RMVISGEO_H
#define _RMVISGEO_H

/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Building a geometry out of a D3D retained mode visual.
*******************************************************************************/

#include <dxtrans.h>
#include <d3drmvis.h>
#include "privinc/bbox3i.h"
#include "privinc/probe.h"
#include "privinc/colori.h"
#include "privinc/matutil.h"
#include "privinc/d3dutil.h"
#include "privinc/ddrender.h"
#include "privinc/importgeo.h"


    // Class Declarations

class GeomRenderer;
class Transform2;


class AttrState
{ public:
    Color emissive;
    Color diffuse;
    Color specular;
    Real  specularExp;
    Real  opacity;

    IDirect3DRMTexture *texture;

    bool shadowMode;
};



/*****************************************************************************
The MeshInfo class contains information about a given mesh, including the
group and vertex information.  Note that this class does not AddRef() the
given mesh -- it is the responsibility of the caller to handle that.
*****************************************************************************/

class MeshInfo : public AxAValueObj
{
  public:
    MeshInfo();
    ~MeshInfo (void) {
        CleanUp();
    }

    void CleanUp (void);

    void SetMesh (IDirect3DRMMesh* mesh);

    bool IsEmpty (void) const;

    void SetMaterialProperties (
        Color *emissive, Color *diffuse, Color *specular,
        Real specularExp, Real opacity, IDirect3DRMTexture *texture,
        bool shadowmode, int renderDevID);

    IDirect3DRMMesh* GetMesh (void) const;

    Bbox3 GetBox (void);

    void SetD3DQuality (D3DRMRENDERQUALITY);
    void SetD3DMapping (D3DRMMAPPING);

    // Create a meshbuilder from the mesh and cache for subsequent calls.

    IDirect3DRMMeshBuilder* GetMeshBuilder (void);

    // TODO: Not a type in avrtypes.h??

    virtual DXMTypeInfo GetTypeInfo() {
        return AxATrivialType;
    }

  protected:
    IDirect3DRMMesh* _mesh;
    int              _numGroups;

    // Flags

    int  _opacityBugWorkaroundID;

    AttrState  _overrideAttrs;  // Override Attribute Values
    AttrState *_defaultAttrs;   // Default Attr Values For All Mesh Groups

    IDirect3DRMMeshBuilder* _optionalBuilder;
};


    // This method returns true if the mesh has not yet been initialized, or
    // if the meshInfo object has been cleaned up.

inline bool MeshInfo::IsEmpty (void) const
{
    return (_mesh == NULL);
}

    // This method returns the contained RM mesh object.

inline IDirect3DRMMesh* MeshInfo::GetMesh (void) const
{
    return _mesh;
}



/*****************************************************************************
This is the superclass for all D3DRM primitives.  In encompasses both DX3 and
DX6 type objects.
*****************************************************************************/

class ATL_NO_VTABLE RMVisualGeo : public Geometry
{
  public:

    RMVisualGeo (void);

    // The following methods are no-ops for RMVisualGeo's

    void CollectSounds   (SoundTraversalContext &context) {};
    void CollectLights   (LightContext &context) {};
    void CollectTextures (GeomRenderer &device)  {};

    // The GenericDevice render method calls the real Render method.

    void Render (GenericDevice& dev);

    virtual void Render (GeomRenderer &geomRenderer) = 0;


    void RayIntersect (RayIntersectCtx &context);

    virtual void CleanUp (void) = 0;

    virtual IDirect3DRMVisual *Visual (void) = 0;

    virtual Bbox3 *BoundingVol (void) = 0;

    VALTYPEID GetValTypeId() { return RMVISUALGEOM_VTYPEID; }

    class RMVisGeoDeleter : public DynamicHeap::DynamicDeleter
    {
      public:
        RMVisGeoDeleter (RMVisualGeo *obj) : _obj(obj) {}

        void DoTheDeletion (void) {
            _obj->CleanUp();
        }

        RMVisualGeo *_obj;
    };
};



/*****************************************************************************
This class is a superclass for the frame and mesh object classes.
*****************************************************************************/

class ATL_NO_VTABLE RM1VisualGeo : public RMVisualGeo
{
  public:

    // By default, the Render method passes this object to the device's Render
    // method.

    void Render (GeomRenderer &geomRenderer) {
        geomRenderer.Render (this);
    }

    // New virtual function to apply material properties

    virtual void SetMaterialProperties (
        Color *emissive, Color *diffuse, Color *specular,
        Real specularExp, Real opacity, IDirect3DRMTexture *texture,
        bool shadowmode, int renderDevID) = 0;

    virtual void SetD3DMapping (D3DRMMAPPING mapping) = 0;
    virtual void SetD3DQuality (D3DRMRENDERQUALITY quality) = 0;

    Bbox3 *BoundingVol (void) {
        return NEW Bbox3 (_bbox);
    }

  protected:

    Bbox3 _bbox;
};




/*****************************************************************************
The RM1MeshGeo class contains information about a single D3DRM mesh
object.  Note that there's an implicit mesh AddRef for the lifetime of this
class.  Users of this class should Release() the given mesh if they are done
using it after construction of this object.
*****************************************************************************/

class RM1MeshGeo : public RM1VisualGeo
{
  public:

    RM1MeshGeo (IDirect3DRMMesh *mesh, bool trackGenIDs = false);

    ~RM1MeshGeo() {
        CleanUp();
    }

    void CleanUp (void);

    void Render (GeomRenderer &geomRenderer);

    void SetMaterialProperties (
        Color *emissive, Color *diffuse, Color *specular,
        Real specularExp, Real opacity, IDirect3DRMTexture *texture,
        bool shadowmode, int renderDevID);

    void SetD3DQuality (D3DRMRENDERQUALITY quality);
    void SetD3DMapping (D3DRMMAPPING mapping);

    IDirect3DRMVisual *Visual (void) {
        return _meshInfo.GetMesh();
    }

    void MeshGeometryChanged (void);

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM1MeshGeo[" << (void*)(this) << "]";
        }
    #endif

  protected:
    MeshInfo       _meshInfo;
    IDXBaseObject *_baseObj;     // don't keep a reference
};



/*****************************************************************************
The RM1FrameGeo class contains information about a D3DRM frame hierarchy.  It
takes the root frame pointer, and a list of meshes contained in the frame
hierarchy.  NOTE:  The meshes in the list are not AddRef'ed; it is assumed
that they each have a reference from withing the given frame hierarchy.  Users
of this class should Release() the frame (and meshes, if AddRef'ed
individually) if they are done using it after constructing this class.
*****************************************************************************/

class RM1FrameGeo : public RM1VisualGeo
{
  public:

    RM1FrameGeo (
        IDirect3DRMFrame* frame,
        vector<IDirect3DRMMesh*> *internalMeshes,
        Bbox3 *bbox);

    ~RM1FrameGeo() {
        CleanUp();
    }

    void CleanUp (void);

    void SetMaterialProperties (
        Color *emissive, Color *diffuse, Color *specular,
        Real specularExp, Real opacity, IDirect3DRMTexture *texture,
        bool shadowmode, int renderDevID);

    void SetD3DQuality (D3DRMRENDERQUALITY quality);
    void SetD3DMapping (D3DRMMAPPING mapping);

    IDirect3DRMVisual *Visual (void) {
        return _frame;
    }

    virtual void DoKids(GCFuncObj proc);

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM1FrameGeo[" << (void*)(this) << "]";
        }
    #endif

  protected:
    IDirect3DRMFrame *_frame;
    int               _numMeshes;
    MeshInfo        **_meshes;
};



/*****************************************************************************
This class is a superclass for all RM3 interface (RM6) geometries.
*****************************************************************************/

class ATL_NO_VTABLE RM3VisualGeo : public RMVisualGeo
{
  public:

    // By default, the Render method passes this object to the device's Render
    // method.

    void Render (GeomRenderer &geomRenderer) {
        geomRenderer.Render (this);
    }
};



/*****************************************************************************
This class wraps a D3DRMMeshBuilder3 object.
*****************************************************************************/

class RM3MBuilderGeo : public RM3VisualGeo
{
  public:

    RM3MBuilderGeo (IDirect3DRMMeshBuilder3*, bool trackGenIDs);
    RM3MBuilderGeo (IDirect3DRMMesh *);

    // Reset meshbuilder to the contents of the given mesh.

    void Reset (IDirect3DRMMesh*);

    ~RM3MBuilderGeo() {
        CleanUp();
    }

    void CleanUp (void);

    void Render (GeomRenderer &geomRenderer);

    inline IDirect3DRMVisual *Visual (void) {
        return _mbuilder;
    }

    inline Bbox3* BoundingVol (void) {
        return NEW Bbox3 (_bbox);
    }

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM3MBuilderGeo[" << (void*)(this) << "]";
        }
    #endif

    void TextureWrap(TextureWrapInfo *wrapInfo);

    void Optimize (void);

  protected:

    void SetBbox (void);    // Auto-set Meshbuilder Bounding Box

    IDirect3DRMMeshBuilder3 *_mbuilder;  // Wrapped MeshBuilder Object
    IDXBaseObject           *_baseObj;   // For Tracking Generation ID's
    Bbox3                    _bbox;
};



/*****************************************************************************
This class wraps a static (non-animate) D3DRMFrame3 object.
*****************************************************************************/

class RM3FrameGeo : public RM3VisualGeo
{
  public:

    RM3FrameGeo (IDirect3DRMFrame3 *frame);

    ~RM3FrameGeo() {
        CleanUp();
    }

    void CleanUp (void);

    IDirect3DRMVisual *Visual (void) {
        return _frame;
    }

    Bbox3* BoundingVol (void) {
        return NEW Bbox3 (_bbox);
    }

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM3FrameGeo[" << (void*)(this) << "]";
        }
    #endif

    void TextureWrap (TextureWrapInfo *info);

  protected:

    IDirect3DRMFrame3 *_frame;    // Frame Hierarcy
    Bbox3              _bbox;     // Static Cached Bounding Box
};



/*****************************************************************************
This class manages a progressive mesh object.
*****************************************************************************/

class RM3PMeshGeo : public RM3VisualGeo
{
  public:

    RM3PMeshGeo (IDirect3DRMProgressiveMesh *pmesh);

    ~RM3PMeshGeo() {
        CleanUp();
    }

    void CleanUp (void);

    IDirect3DRMVisual *Visual (void) {
        return _pmesh;
    }

    Bbox3* BoundingVol (void) {
        return NEW Bbox3 (_bbox);
    }

    #if _USE_PRINT
        ostream& Print (ostream& os) {
            return os << "RM3PMeshGeo[" << (void*)(this) << "]";
        }
    #endif

  protected:

    IDirect3DRMProgressiveMesh *_pmesh;    // Progressive Mesh

    Bbox3 _bbox;   // The bounding box will always be the largest bounding box
                   // of all possible refinements of the pmesh.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\server.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SERVER_H
#define _SERVER_H

#include "storeobj.h"
#include "privinc/backend.h"
#include "privinc/probe.h"
#include "privinc/mutex.h"
#include "privinc/util.h"
#include "backend/preference.h"
#include <dxtrans.h>

class EventQ ;
class PickQ ;
class DirectDrawImageDevice ;
class DirectSoundDev ;
class MetaSoundDevice ;
class ViewPreferences ;

// ====================================
// These are all thread specific calls
// ====================================

HWND GetCurrentSampleWindow() ;

DynamicHeap & GetCurrentSampleHeap() ;
DynamicHeap & GetGCHeap() ;
DynamicHeap & GetTmpHeap();
DynamicHeap & GetViewRBHeap();

DirectDrawImageDevice * GetImageRendererFromViewport(DirectDrawViewport *);
DirectDrawViewport    * GetCurrentViewport( bool dontCreateOne = false );
MetaSoundDevice       * GetCurrentSoundDevice();
DirectSoundDev        * GetCurrentDSoundDevice();

#if PERFORMANCE_REPORTING
GlobalTimers & GetCurrentTimers();
#endif  // PERFORMANCE_REPORTING

// This is used by the pick queue to approximate the pick function.
Time GetLastSampleTime();

void ReportErrorHelper(HRESULT hr, LPCWSTR szErrorText);
void SetStatusTextHelper(char * szStatus);
void ReportGCHelper(bool bStarting);

bool GetCurrentServiceProvider (IServiceProvider **);

void FreeSoundBufferCache();

// ====================================
// GC Related APIs
// ====================================

GCList GetCurrentGCList() ;
GCRoots GetCurrentGCRoots() ;

// ====================================
// Global functions
// ====================================

void ViewNotifyImportComplete(Bvr bvr, bool bDying);

// ====================================
// EventQ APIs
// ====================================

enum AXAEventId {
    AXAE_MOUSE_MOVE,
    AXAE_MOUSE_BUTTON,
    AXAE_KEY,
    AXAE_FOCUS,
    AXAE_APP_TRIGGER,
} ;

class AXAWindEvent {
  public:
    AXAWindEvent(AXAEventId id,
                 Time when,
                 DWORD x, DWORD y,
                 BYTE modifiers,
                 DWORD data,
                 BOOL bState)
    : id(id),
      when(when),
      x(x), y(y),
      modifiers(modifiers),
      data(data),
      bState(bState) {}

    AXAEventId id;
    Time when;
    DWORD x;
    DWORD y;
    BYTE modifiers;
    DWORD data;
    BOOL bState;

    bool operator<(const AXAWindEvent &t) const {
        return this < &t ;
    }

    bool operator>(const AXAWindEvent &t) const {
        return this > &t ;
    }

    bool operator!=(const AXAWindEvent &t) const {
        return !(*this == t) ;
    }

    bool operator==(const AXAWindEvent &t) const {
        return (memcmp (this, &t, sizeof(*this)) != 0) ;
    }

    // For STL
    AXAWindEvent () {}
};

AXAWindEvent* AXAEventOccurredAfter(Time when,
                                    AXAEventId id,
                                    DWORD data,
                                    BOOL bState,
                                    BYTE modReq,
                                    BYTE modOpt);

BOOL AXAEventGetState(Time when,
                      AXAEventId id,
                      DWORD data,
                      BYTE mod);

void AXAGetMousePos(Time when, DWORD & x, DWORD & y);

BOOL AXAWindowSizeChanged() ;

// ====================================
// PickQ APIs
// ====================================

// We want to answer the question: at time t, is the cursor over the
// object with a specific id?  Currently we only do polling and record
// the time points where pick is true.  What we want is a continuous
// function.  TODO: Until we have a better approach, like if we can
// tell the cursor just leave the object, I'm using a _lastPollTime
// field to determine if the cursor is still on the pick object. 

struct PickQData {
    Time                      _eventTime;
    Time                      _lastPollTime;
    HitImageData::PickedType  _type;
    Point2Value               _wcImagePt;     // World Coord Image Pick Point
    Real                      _xCoord;
    Real                      _yCoord;
    Real                      _zCoord;
    Transform2               *_wcToLc2;
    Vector3Value              _offset3i;      // Local Coord 3D Pick Offset I
    Vector3Value              _offset3j;      // Local Coord 3D Pick Offset J

    bool operator==(const PickQData & pd) const {
        return (memcmp (this, &pd, sizeof(*this)) != 0) ;
    }

    bool operator!=(const PickQData &pd) const {
        return !(*this == pd) ;
    }

    bool operator<(const PickQData &pd) const {
        return this < &pd ;
    }

    bool operator>(const PickQData &pd) const {
        return this > &pd ;
    }

};

// Converts pixel point to image world coordinate
Point2Value* PixelPos2wcPos (short x, short y);
BOOL CheckForPickEvent(int id, Time time, PickQData & result) ;
// This will copy the pick data
void AddToPickQ (int id, PickQData & data) ;

// ====================================
// Globals
// ====================================

extern HINSTANCE hInst ;

// =============================
// For Backend, these operate on current view
// =============================

class CRView;

void ViewEventHappened();

void TriggerEvent(DWORD eventId, Bvr data, bool bAllViews);
void RunViewBvrs(Time startGlobalTime, TimeXform tt);

CRView *ViewAddPickEvent();
void ViewDecPickEvent(CRView*);

class DiscreteImage;
class DirectDrawImageDevice;

void DiscreteImageGoingAway(DiscreteImage *img,
                            DirectDrawViewport *vprt = NULL);
void SoundGoingAway(Sound *sound);

// Get last sample time (in terms of view global) of the current
// view.   Plus the system times of last sample and current sample
bool ViewLastSampledTime(DWORD& lastSystemTime,
                         DWORD& currentSystemTime,
                         Time & t0);

double ViewGetFrameRate();
double ViewGetTimeDelta();

unsigned int ViewGetSampleID();

#endif /* _SERVER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\sndfile.h ===
#ifndef _SNDFILE_H
#define _SNDFILE_H


class ATL_NO_VTABLE SndFile {
  public:
    //SndFile(): 
        //_fileNumChannels(0),
        //_fileSampleRate(0),
        //_fileBytesPerSample(0),
        //_fileNumSampleBytes(0),
        //_fileLengthSeconds(0),
        //_fileNumFrames(0)
    //{}

    virtual ~SndFile() {}
    virtual int  Read(void *buffer, int numBytes)         = 0;
    virtual int  ReadFrames(void *buffer, int numFrames)  = 0;
    virtual void SeekFrames(long frameOffset, int whence) = 0;

    // temporary methods (these will be replaced by a parameter list)
    virtual int GetByteCount()      {return(_fileNumSampleBytes);}
    virtual int GetFrameCount()     {return(_fileNumFrames);}
    virtual int GetBytesPerSample() {return(_fileBytesPerSample);}
    virtual int GetNumChannels()    {return(_fileNumChannels);}
    virtual int GetSampleRate()     {return((int)_fileSampleRate);}
    virtual double GetLength() {
        return((double)_fileNumSampleBytes / 
               (double)(_fileSampleRate*_fileNumChannels)); }

    // Hacks
    //FileType(char *string);

  protected:
    char  *_fileName;

    // the 'file' parameters (how samples are stored in the file)
    int    _fileNumChannels;
    double _fileSampleRate;
    int    _fileBytesPerSample;
    int    _fileNumSampleBytes;  // number of bytes of audio data in file
    double _fileLengthSeconds;
    int    _fileNumFrames;       // number of frames in the file

    // the 'com' parameters (used to determine the api sample format)
};


class WaveSoundFile : public SndFile {
  public:
    WaveSoundFile(char *fileName);
    ~WaveSoundFile();
    int Read(void *buffer, int numBytes) 
        { return(mmioRead(_fileHandle, (char*)buffer, numBytes)); }

    int ReadFrames(void *buffer, int numFrames) 
        {
        int actualBytes = mmioRead(_fileHandle, (char*)buffer, 
            numFrames * _fileBytesPerSample * _fileNumChannels);

        return(actualBytes / _fileBytesPerSample / _fileNumChannels);
        }

    void SeekFrames(long frameOffset, int whence);


  private:
    HMMIO _fileHandle;
    long  _dataBlockLocation;    // byte count in .wav file where datablock is
    long  _eoDataBlockLocation;  // byte count in file where datablock ends
};

extern SndFile *CreateSoundFile(char *fileName);

#endif /* _SNDFILE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\stquartz.h ===
#ifndef _STQUARTZ_H_
#define _STQUARTZ_H_

#include "privinc/helpds.h"
#include "privinc/helpq.h"
#include "privinc/pcm.h"

class StreamQuartzPCM : public LeafDirectSound {
  public:
    StreamQuartzPCM(char *fileName);
    ~StreamQuartzPCM();

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "StreamQuartzPCM";
    }
#endif

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

    const double GetLatency() { return _latency; }
    char *GetFileName() { return _fileName; }
    unsigned char *GetBuffer() { return _buffer; }
    void SetBuffer(unsigned char *b) { _buffer = b; }

  private:
    const double   _latency;
    char          *_fileName;
    unsigned char *_buffer;    // shuttle buffer
};

#endif /* _STQUARTZ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\spritethread.h ===
#ifndef _SPRITETHREAD_H
#define _SPRITETHREAD_H

/*******************************************************************************

Copyright (c) 1997 Microsoft Corporation

Abstract:

    Class which manages sprite thread

*******************************************************************************/

#include "privinc/mutex.h"
#include "privinc/snddev.h"
#include "backend/sprite.h"


class SpriteThread {
  public:
    SpriteThread(MetaSoundDevice *metaDev, RMImpl *updateTree);
    ~SpriteThread();

    // XXX these should probably be private one day...
    bool             _done;
    RMImpl          *_updateTree;
    MetaSoundDevice *_metaDev;

  private:
    DWORD            _threadID;
    HANDLE           _threadHandle;
    //CritSect *_cs;
};

#endif /* _SPRITETHREAD_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\storeobj.h ===
#ifndef _STOREOBJ_H
#define _STOREOBJ_H

/*++

Copyright (c) 1995-96  Microsoft Corporation

Abstract:

    Memory management for static value implementation classes.  Such
    classes derive from StoreObj, which redefine new and delete to
    allocate from dynamic heaps.

--*/

#include "appelles/common.h"
#include "gendev.h"
#include "backend.h"
#include "backend/gc.h"
#include <memory.h>


// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 ) 

class DynamicHeap;
class DirectDrawImageDevice;

class ATL_NO_VTABLE StoreObj : public GCBase {
  public:
    StoreObj();
    
  #if _DEBUGMEM
    void *operator new(size_t s, int blockType, char * szFileName, int nLine);
  #else
    void *operator new(size_t s);
  #endif // _DEBUGMEM
    void  operator delete(void *ptr);
};

// Allocate memory from the current store.  This will throw an
// exception if memory can't be allocated, so don't worry about
// checking the return value.
#if _DEBUGMEM
#define AllocateFromStore(size) AllocateFromStoreFn(size, __FILE__, __LINE__, NULL)
extern void *AllocateFromStoreFn(size_t size,
                                 char * szFileName,
                                 int nLine,
                                 DynamicHeap **ppHeap); // output
#else
#define AllocateFromStore(size) AllocateFromStoreFn(size, NULL)

extern void *AllocateFromStoreFn(size_t size,
                                 DynamicHeap **ppHeap); // output

#endif  // _DEBUGMEM

// Deallocate memory that was allocated on the current store.  Results
// are undefined if the memory was allocated on a different store.
extern void DeallocateFromStore(void *ptr);

//////////// Dynamic Heaps /////////////

//   "Dynamic Heaps" allow the allocation of memory out of a pool that's
// dynamically scoped.  When the heap is "reset", memory starts
// allocating from the beginning.  Performing a "new" on a class
// that derives from StoreObj above allocates off of the "current"
// dynamic heap on the top of the per-thread stack of heaps.  This
// dynamically scoped heap makes senses for situations in which the
// client knows that an objects useful lifetime is over by the time
// the "reset" is done.

//   Subclasses of the abstract dynamic heap object implement
// different allocation policies.  For instance, one will be a "System
// Heap", where everything is allocated off of the true system heap
// store, and "reset" has no effect.  Another will be the
// "TransientHeap", useful for objects with well-understood lifetimes,
// where "reset" actually does cause the memory for these objects to
// be re-used.

class ATL_NO_VTABLE DynamicHeap {
  public:

    // For defining deleters that will be invoked when the store is
    // deleted, provided they are registered via
    // RegisterDynamicDeleter below.
    class ATL_NO_VTABLE DynamicDeleter {
      public:
        virtual void DoTheDeletion() = 0;
    };

    virtual ~DynamicHeap();

    // Allocate memory off of this dynamic heap
#if _DEBUGMEM
    virtual void *Allocate(size_t size, char * szFileName, int nLine) = 0;
#else
    virtual void *Allocate(size_t size) = 0;
#endif

    // Return memory back to this dynamic heap
    virtual void  Deallocate(void *ptr) = 0;

    // Reset the store, and, if debugging AND clear == TRUE,
    // clear it out to a unique value.
    virtual void  Reset(Bool clear = TRUE) = 0;

    // Register a deleter.  When the store is reset, all the
    // registered deleter's will have their method invoked.  The
    // deleter itself will be deleted when reset is called as well.
    virtual void  RegisterDynamicDeleter(DynamicDeleter *deleter) = 0;

    virtual void  UnregisterDynamicDeleter(DynamicDeleter *deleter) = 0;

    virtual size_t PtrSize(void *ptr) = 0;

    virtual bool  IsTransientHeap() = 0;

#if DEVELOPER_DEBUG
    virtual bool  ValidateMemory(void *ptr) = 0;
    // For debugging
    virtual void  Dump() const = 0;
    virtual char *Name() const = 0;
       
    virtual size_t  BytesUsed() = 0;
#endif

};

template <class T>
class DynamicPtrDeleter : public DynamicHeap::DynamicDeleter
{
  public:
    DynamicPtrDeleter(T* p) : ptr(p) {}
    virtual void DoTheDeletion() { delete ptr; }
  private:
    T* ptr;
};


// For creating a transient heap.
extern DynamicHeap&   TransientHeap(char *name,
                                    size_t initial_size,
                                    Real  growth_rate = 1.5);
extern void           DestroyTransientHeap(DynamicHeap& heap);

extern DynamicHeap&   CreateWin32Heap(char *name,
                                      DWORD fOptions,
                                      DWORD dwInitialSize,
                                      DWORD dwMaxSize);
extern void           DestroyWin32Heap(DynamicHeap& heap);

// Push (pop) a dynamic heap onto (off of) the per-thread heap stack.
// new and delete from the StoreObj() class allocate from the
// dynamic heap on the top of the stack.
extern void           PushDynamicHeap(DynamicHeap& heap);
extern void           PopDynamicHeap();
extern void           ResetDynamicHeap(DynamicHeap& heap);

extern DynamicHeap&   GetSystemHeap();
extern DynamicHeap&   GetInitHeap();
extern DynamicHeap&   GetHeapOnTopOfStack();

#if DEVELOPER_DEBUG
extern size_t DynamicHeapBytesUsed();
#endif

class ImageDisplayDev;

// Not all classes need to be added here.  Only the classes which will
// need to be queried.  All others should return UNKNOWN_VTYPEID to
// indicate that they are not part of the enumeration

enum VALTYPEID {
    UNKNOWN_VTYPEID = 0,

    // Basic types
    PRIMOP_VTYPEID,
    PAIR_VTYPEID,
    SOUND_VTYPEID,
    ARRAY_VTYPEID,
    IMAGE_VTYPEID,
    GEOMETRY_VTYPEID,

    // Image subtypes
    SOLIDCOLORIMAGE_VTYPEID,
    CROPPEDIMAGE_VTYPEID,
    TRANSFORM2IMAGE_VTYPEID,
    DISCRETEIMAGE_VTYPEID,
    MOVIEIMAGE_VTYPEID,
    OVERLAYEDIMAGE_VTYPEID,
    OVERLAYEDARRAYIMAGE_VTYPEID,
    PROJECTEDGEOMIMAGE_VTYPEID,
    DIBIMAGE_VTYPEID,
    OPAQUEIMAGE_VTYPEID,
    PLUGINDECODERIMAGE_VTYPEID,
    HTMLIMAGE_VTYPEID,
    MOVIEIMAGEFRAME_VTYPEID,
    CACHEDIMAGE_VTYPEID,
    DIRECTDRAWSURFACEIMAGE_VTYPEID,

    // Geometry subtypes
    AGGREGATEGEOM_VTYPEID,
    MULTIAGGREGATEGEOM_VTYPEID,
    FULLATTRGEOM_VTYPEID,
    SOUNDGEOM_VTYPEID,
    RMVISUALGEOM_VTYPEID,
    LIGHTGEOM_VTYPEID,
    EMPTYGEOM_VTYPEID,
    SHADOWGEOM_VTYPEID,
    DXXFGEOM_VTYPEID
};

class RewriteOptimizationParam;
class CacheParam;

class ATL_NO_VTABLE AxAValueObj : public StoreObj
{
  public:
    AxAValueObj() : StoreObj() {}

    // TODO: Can we guarantee the same heap?
    virtual ~AxAValueObj() {}
    
    virtual void Render(GenericDevice& dev) {}

    // Compute and return cache for a value using the specified
    // device.  The 'cacheKey' parameter is a pointer to an AxAValue.
    // On input, it points to a value that can be used as the 'cache
    // key' for the value that can be reused.  On exit, it gets filled
    // in with a new cache key for use in subsequent calls.
    virtual AxAValue _Cache(CacheParam &param);

    // Client's entry point
    static AxAValue Cache(AxAValue obj, CacheParam &param);
    
    virtual void DestroyCache() { }

    virtual BOOL IsLazy() { return FALSE; }

    virtual void DoKids(GCFuncObj) {}

    // sound would return a special snapshot sound that won't render  
    virtual AxAValueObj *Snapshot() { return this; }

    virtual DXMTypeInfo GetTypeInfo() = 0;

    virtual VALTYPEID GetValTypeId() { return UNKNOWN_VTYPEID; }

    virtual AxAValue RewriteOptimization(RewriteOptimizationParam &param);

    virtual AxAValue ExtendedAttrib(char *attrib, VARIANT& val) {
        return this;
    }
};

class DynamicHeapPusher
{
  public:
    DynamicHeapPusher (DynamicHeap & heap)
    { PushDynamicHeap (heap) ; }
    ~DynamicHeapPusher ()
    { PopDynamicHeap () ; }
} ;

// This takes a heap and when deleted ensures it is freed.
// Putting this on the stack will handle exceptions well.
class DynamicHeapAllocator
{
  public:
    DynamicHeapAllocator (DynamicHeap & heap)
    : _heap(heap) {}
    ~DynamicHeapAllocator ()
    { DestroyTransientHeap (_heap) ; }

    DynamicHeap & GetHeap () { return _heap ; }
  protected:
    DynamicHeap & _heap ;
} ;

// Utility functions
#if _DEBUGMEM
#define StoreAllocate(heap,size) StoreAllocateFn(heap,size, __FILE__, __LINE__)
extern void *StoreAllocateFn(DynamicHeap& heap, size_t size, char * szFileName, int nLine);
#else
#define StoreAllocate(heap,size) StoreAllocateFn(heap,size)
extern void *StoreAllocateFn(DynamicHeap& heap, size_t size);
#endif  // _DEBUGMEM

extern void StoreDeallocate(DynamicHeap& heap, void *ptr);

#endif /* _STOREOBJ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\stlsubst.h ===
#ifndef _STLSUBST_H
#define _STLSUBST_H

/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

  Substitute for certain STL functions on void* containers.  This
  allows us to avoid code bloat introduced by frequent STL template
  expansion.  Rule is that individual functions that are large in size
  should have helper functions here.  Additionally, there are macros
  that ensure the typed-value is the same size as the untyped value.

*******************************************************************************/

// Push a void* element onto the back of a void* vector.
extern void VectorPushBackPtr(vector<void*>& vec,
                              void *newElt);

// Push a void* element onto a void* stack.
extern void StackVectorPushPtr(stack<void* >& vec,
                               void *newElt);

#if _DEBUG

// Just use typesafe operations.  Will cause code-bloat, but that's OK
// for debug.
#define VECTOR_PUSH_BACK_PTR(vec, newElt) \
  Assert(sizeof(newElt) == sizeof(void*)); \
  BEGIN_LEAK               \
  (vec).push_back(newElt); \
  END_LEAK

#define STACK_VECTOR_PUSH_PTR(stk, newElt) \
  Assert(sizeof(newElt) == sizeof(void*)); \
  BEGIN_LEAK              \
  (stk).push(newElt);   \
  END_LEAK

#else  /* !_DEBUG */

#define VECTOR_PUSH_BACK_PTR(vec, newElt) \
  (vec).push_back(newElt)

#define STACK_VECTOR_PUSH_PTR(stk, newElt) \
  (stk).push(newElt)

#endif /* DEBUG */

#endif /* _STLSUBST_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\soundi.h ===
#ifndef _SOUNDI_H
#define _SOUNDI_H

/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Private include file for defining sounds.
*******************************************************************************/

#include <dsound.h>

#include "appelles/sound.h"

#include "privinc/storeobj.h"
#include "privinc/helpds.h"
#include "privinc/dsdev.h"
#include "privinc/snddev.h"
#include "privinc/pcm.h"

// Setup the statics
#define CANONICALFRAMERATE   22050 // reasonably hifi (would preffer 44.1K|48K)
#define CANONICALSAMPLEBYTES     2 // 16bit sound is critical to dynamic range!

class BufferElement;
class SoundDisplayDev;             // forward declaration

class Sound : public AxAValueObj {
  public:
    Sound() {}
    virtual ~Sound() {} // allow objects derived from Sound to have destructors
    virtual DXMTypeInfo  GetTypeInfo()             { return SoundType;     }
    virtual VALTYPEID    GetValTypeId()            { return SOUND_VTYPEID; }

    virtual AxAValueObj *Snapshot() { return silence; }
    
    static double _minAttenuation;
    static double _maxAttenuation;
};


// all the info we need to construct or reconstruct a sound
class SoundContext : public AxAThrowingAllocatorClass {
  public:
    SoundContext() : _looping(false) {}
    ~SoundContext() {}
    bool GetLooping() { return(_looping); }
    void SetLooping(bool looping) { _looping = looping; }
    char *GetFileName() { return(_fileName); }

  protected:

  private:
    bool  _looping;
    char *_fileName;
    // double _time;  // do we need to keep track of the time
};

class SoundInstance;
class ATL_NO_VTABLE LeafSound : public Sound {
  public:
    ~LeafSound();

    // pure virtual? methods the generic render may call
    virtual bool   RenderAvailable(MetaSoundDevice *) = 0;

    virtual SoundInstance *CreateSoundInstance(TimeXform tt) = 0;
};


class LeafDirectSound : public LeafSound {
  public:
    virtual bool RenderAvailable(MetaSoundDevice *metaDev);
    PCM _pcm;          // dsound sounds are PCM sounds!
};


// The sound data is used to hold the relevant attributes of a sound
// after it's been pulled out of a geometry hierarchy.
class SoundData
{
  public:
    Transform3 *_transform;  // Accumulated Modeling Transform
    Sound *_sound;      // sound

    BOOL operator<(const SoundData &sd) const {
        return (this < &sd) ;
    }

    BOOL operator==(const SoundData &sd) const {
        return (this == &sd) ;
    }
};


// The sound context class maintains traversal context while gathering
// sounds from the geometry tree.
class SoundTraversalContext
{
  public:
    SoundTraversalContext();

    void  setTransform (Transform3 *transform) { _currxform = transform; }
    Transform3 *getTransform (void) { return _currxform; }

    void addSound (Transform3 *transform, Sound *sound);
    vector<SoundData> _soundlist; // List of Collected Sounds

  private:
    Transform3 *_currxform;       // Current Accumulated Transform

};


class StaticWaveSound : public LeafDirectSound {
  public:
    StaticWaveSound(unsigned char *origSamples, PCM *pcm);
    ~StaticWaveSound();

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "(static wave sound)";
    }
#endif

  protected:
    unsigned char      *_samples;
};

#endif /* _SOUNDI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\solidimg.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements SolidImage, inifinte single color image.

*******************************************************************************/

#ifndef _SOLIDIMG_H
#define _SOLIDIMG_H

#include <privinc/imagei.h>
#include <privinc/colori.h>
#include <privinc/imgdev.h>

class ImageDisplayDev;

class SolidColorImageClass : public Image {
  public:

    SolidColorImageClass(Color *color) : 
         _color(color), Image() {}

    void Render(GenericDevice& _dev)    { 
        ImageDisplayDev &dev = (ImageDisplayDev &)_dev;
        dev.RenderSolidColorImage(*this); 
    }

    const Bbox2 BoundingBox(void) {
        return UniverseBbox2; 
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return UniverseBbox2; 
    }
#endif  // BOUNDINGBOX_TIGHTER

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "SolidColorImageClass" << "<bounding box>" << *_color;
    }
#endif

    const Bbox2 OperateOn(const Bbox2 &box) {
        return box;
    }

    Bool DetectHit(PointIntersectCtx& ctx) {
        // A solid color image, being infinite, is always detected. 
        return TRUE;
    }

    Color *GetColor() {
        return _color;
    }

    Bool GetColor(Color **color) {
        *color = _color;
        return TRUE;
    }

    virtual VALTYPEID GetValTypeId() { return SOLIDCOLORIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == SolidColorImageClass::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc);

  protected:  
    Color *_color;
};


#endif /* _SOLIDIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\stream.h ===
#ifndef _STREAM_H_
#define _STREAM_H_

// TODO: remove the whole file

#ifdef DELETEME
#include "privinc/soundi.h"

class DSstreamingBufferElement;

class SinSynth : public LeafDirectSound {
  public:
    SinSynth(double newFreq=1.0);

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "SinSynth";
    }
#endif

  protected:
    double _sinFrequency;
};
#endif /* DELETEME */

#ifdef DONTDELETEMEI_HAVE_SYNC_CODE_EMBEDDED_IN_ME
class StreamPCMfile : public LeafDirectSound {
  public:
    StreamPCMfile(char *fileName);
    ~StreamPCMfile();

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "StreamPCMfile(";
    }
#endif /* _USE_PRINT */
    virtual void RenderNewBuffer(BufferElement *bufferElement,
                    MetaSoundDevice *metaDev);
    virtual void RenderAttributes(
                    MetaSoundDevice *metaDev, BufferElement *bufferElement);
    virtual void RenderStartAtLocation(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement, double phase, Bool looping);
    virtual void RenderStop(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement);
    virtual void RenderSamples(MetaSoundDevice *, BufferElement *);
    virtual void RenderSetMute(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement);
    virtual Bool RenderCheckComplete(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement);
    virtual void RenderCleanupBuffer(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement);
    virtual bool StreamPCMfile::RenderPosition(MetaSoundDevice *metaDev,
                    BufferElement *bufferElement, double *mediaTime);
    virtual double GetLength() { 
        if(_soundFile)
            return(_soundFile->GetLength()); // pass the buck
        else
            return(-1.0); } // err

  protected:
    char    *_fileName;
    SndFile *_soundFile;
    int      _sampleRate;
    int      _numChannels;
    int      _bytesPerSample;

};
#endif

#ifdef DELETEME
class QuartzStreamPCM : public LeafDirectSound {
  public:
    QuartzStreamPCM(char *fileName);
    ~QuartzStreamPCM();

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "QuartzStreamPCM(";
    }
#endif

    virtual void RenderNewBuffer();
    virtual void RenderAttributes(BufferElement *bufferElement);
    virtual void RenderStartAtLocation(BufferElement *bufferElement, 
        double phase, Bool looping);
    virtual double GetLength();
    virtual void RenderStop(BufferElement *bufferElement);
    virtual void RenderSamples(MetaSoundDevice *, BufferElement *);
    virtual void RenderSetMute(BufferElement *bufferElement);
    virtual Bool RenderCheckComplete(BufferElement *bufferElement);
    virtual void RenderCleanupBuffer(BufferElement *bufferElement);

  protected:
    char    *_fileName;
    int      _sampleRate;
    int      _numChannels;
    int      _bytesPerSample;

};
#endif /* DELETEME */

#endif /* _STREAM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\texti.h ===
#ifndef _TEXTI_H
#define _TEXTI_H


/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    texti.h

Abstract:

     Implements the Text class

--*/

#include "appelles/common.h"

enum textRenderStyle {
    textRenderStyle_invalid,
    textRenderStyle_filled,
    textRenderStyle_outline,
    textRenderStyle_filledOutline
};
    

#define DEFAULT_TEXT_POINT_SIZE 12.0

////////////
class TextCtx;

class ATL_NO_VTABLE Text : public AxAValueObj {
  public:
    virtual void RenderToTextCtx(TextCtx& ctx) = 0;
    virtual int GetCharacterCount() = 0;
    virtual WideString GetStringPtr() = 0;

    virtual DXMTypeInfo GetTypeInfo() { return TextType; }
};

////////////

// Need this in multiple places...

class FontFamily : public AxAValueObj {
  public:
    FontFamily(FontFamilyEnum f) : _ff(f), _familyName(NULL) {}

    FontFamily(AxAString * familyName)
    : _ff(ff_serifProportional), _familyName(familyName) {}
    
    FontFamilyEnum GetFontFamily() { return _ff; }

    AxAString * GetFontFamilyName() { return _familyName; }
    
    virtual DXMTypeInfo GetTypeInfo() { return FontFamilyType; }

    virtual void DoKids(GCFuncObj proc)
    { if (_familyName) (*proc)(_familyName); }
  private:
    FontFamilyEnum _ff;
    AxAString * _familyName;
};

#endif /* _TEXTI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\transimg.h ===
#ifndef _TRANSIMG_H
#define _TRANSIMG_H


/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Transformed Image class header

-------------------------------------*/

#include "privinc/imagei.h"
#include "privinc/xform2i.h"
#include "privinc/bbox2i.h"

class Transform2Image : public AttributedImage {
  public:

    Transform2Image(Transform2 *xf, Image *img);

    void Render(GenericDevice& dev);

    const Bbox2 BoundingBox(void);

    Real DisjointBBoxAreas(DisjointCalcParam &param);

    void _CollectDirtyRects(DirtyRectCtx &ctx);
    
#if BOUNDINGBOX_TIGHTER
    Bbox2 *BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Bbox2Ctx bbctxAccum(bbctx, _xform);
        return _image->BoundingBoxTighter(bbctxAccum);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "TransformImage("
                  << _xform << "," << _image << ")";
    }
#endif

    const Bbox2 OperateOn(const Bbox2 &box);

    Bool  DetectHit(PointIntersectCtx& ctx);

    DiscreteImage *IsPurelyTransformedDiscrete(Transform2 **theXform);

    Transform2 *GetTransform() { return _xform; }

    virtual VALTYPEID GetValTypeId() { return TRANSFORM2IMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == Transform2Image::GetValTypeId() ||
                AttributedImage::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc) { 
        AttributedImage::DoKids(proc);
        (*proc)(_xform); 
    }

  protected:
    Transform2 *_xform;
};


#endif /* _TRANSIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\surfacemanager.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SURFACEMANAGER_H
#define _SURFACEMANAGER_H

#include <privinc/ddsurf.h>

class DirectDrawViewport;
class DirectDrawImageDevice;
struct DDSurface;
class SurfaceCollection;
class SurfacePool;
class SurfaceMap;
class SurfaceManager;



// TODO: should either rename these guys to something more obvious (to
// easily demonstrate that they're global enums, OR put them in the
// DDSurface class.
    enum clear_enum { dontClear=0, doClear=1 };
    enum scratch_enum { notScratch=0, scratch=1 } ;
    enum vidmem_enum { notVidmem=0, vidmem=1 } ;
    enum except_enum { noExcept=0, except=1 } ;
    enum texture_enum { notTexture=0, isTexture=1 } ;

class SurfaceManager {

  public:
    
    SurfaceManager(DirectDrawViewport &ownerVp);
    
    ~SurfaceManager();

    SurfacePool *GetSurfacePool(DDPIXELFORMAT *pf);
    void AddSurfacePool(SurfacePool *sp);
    void RemoveSurfacePool(SurfacePool *sp);
    SurfaceMap *GetSurfaceMap(DDPIXELFORMAT *pf);
    void AddSurfaceMap(SurfaceMap *sm);
    void RemoveSurfaceMap(SurfaceMap *sm);

  private:

    typedef list<SurfaceCollection *> collection_t;
    
    void *Find(collection_t &sc, DDPIXELFORMAT *pf);
    bool Find(collection_t &sc, void *ptr, collection_t::iterator &i);
    void DeleteAll(collection_t &sc);

    collection_t  _pools;
    collection_t  _maps;

    bool          _doingDestruction;
    DirectDrawViewport &_owningViewport;
};


class SurfaceCollection {

  public:

    // need a copy of the pixel format... can you think
    // of a better way to pass it without using a ref or pointer ?
    // (neeed to make sure it's not NULL!)
    SurfaceCollection(SurfaceManager &mgr, DDPIXELFORMAT pf);

    virtual ~SurfaceCollection();

    bool IsSamePixelFormat(DDPIXELFORMAT *pf);

    inline DWORD GetDepth()     { return _pixelFormat.dwRGBBitCount; }
    inline DWORD GetRedMask()   { return _pixelFormat.dwRBitMask; }
    inline DWORD GetGreenMask() { return _pixelFormat.dwGBitMask; }
    inline DWORD GetBlueMask()  { return _pixelFormat.dwBBitMask; }

    inline SurfaceManager &GetSurfaceManager() { return _manager; }
    inline DDPIXELFORMAT &GetPixelFormat() { return _pixelFormat; }

  protected:
    virtual bool IsEmpty() = 0;

    #if _DEBUG
    void _debugonly_doAsserts( DDSurface *s ) {
        return;
        // this is good code, but too conservative.  catches good
        // stuff though, so keep around for later.. 
        //if( !(s->_debugonly_GetPixelFormat().dwFlags & DDPF_ZBUFFER) ) {
        //Assert(IsSamePixelFormat( &(s->_debugonly_GetPixelFormat() ) ));
        //}
    }
    #endif

  private:
    SurfaceManager &_manager;
    DDPIXELFORMAT _pixelFormat;

};

class SurfacePool : public SurfaceCollection {

    friend class CompositingStack;  // wish we could get per class scoping!

    #if _DEBUG
    friend class SurfaceTracker;
    #endif
    
  public:

    class ATL_NO_VTABLE DeletionNotifier {
      public:
        virtual void Advise(SurfacePool *pool) = 0;
    };

    SurfacePool(SurfaceManager &mgr, DDPIXELFORMAT &pf);

    virtual ~SurfacePool();

    // lends a copy of my reference. client needs to
    // make her own copy if she wants to keep a reference
    DDSurface *GetSizeCompatibleDDSurf(
        DDSurface *preferredSurf,       // Look for this surf first
        LONG width, LONG height,        // Surface Dimensions
        vidmem_enum vid,                // System or Video Memory
        LPDIRECTDRAWSURFACE surface);    // Specific Surface, or NULL for any

    // creates a reference for the client to keep
   void FindAndReleaseSizeCompatibleDDSurf(
        DDSurface *preferredSurf,       // Look for this surf first.
        LONG width, LONG height,        // Surface Dimensions
        vidmem_enum vid,                // System or Video Memory
        LPDIRECTDRAWSURFACE surface,    // Specific Surface, or NULL for any
        DDSurface **outSurf);
    
    void PopSurface(DDSurface **outSurf);
    void ReleaseAndEmpty();
    void ReleaseAndEmpty(int numSurfaces);
    void CopyAndEmpty(SurfacePool *srcPool);
    
    inline void AddSurface(DDSurface *ddsurf) {

        DebugCode( _debugonly_doAsserts( ddsurf ) );
        
        ADDREF_DDSURF(ddsurf, "SurfacePool::AddSurface", this);
        _pool.push_back(ddsurf);
    }

    void Erase(DDSurface *ddsurf);

    void RegisterDeletionNotifier(DeletionNotifier *delNotifier);
    void UnregisterDeletionNotifier(DeletionNotifier *delNotifier);

    //
    // iterator style methods
    //
    inline void Begin() { _i = _pool.begin(); }
    inline void Next() { _i++; }
    inline bool IsEnd() { return (_i == _pool.end()) ; }
    inline DDSurface *GetCurrentSurf() { return (*_i); }

    inline int  Size() { return _pool.size(); }

    #if _DEBUG
    void Report() {
      TraceTag((tagError, "SurfacePool(%x)  size: %d\n", this, Size()));
    }
    #endif
    
  protected:

    inline bool IsEmpty() { return _pool.empty(); }
    inline DDSurface  *Back() {
        Assert( (Size() > 0) && "SurfacePool::Back() size<=0!!");
        return _pool.back();
    }
    inline void PushBack(DDSurface *s) {
        DebugCode( _debugonly_doAsserts(s) );
        _pool.push_back(s);
    }
    inline void PopBack() {
        Assert( (Size() > 0) && "SurfacePool::PopBack() size<=0!!");
        _pool.pop_back();
    }

    bool Find(DDSurface *ddsurf);

    typedef list<DDSurface *> surfDeque_t;

    surfDeque_t::iterator _i;
    surfDeque_t     _pool;

    typedef set<DeletionNotifier *> deletionNotifiers_t;
    deletionNotifiers_t _deletionNotifiers;
    CritSect            _critSect;
};


class SurfaceMap : public SurfaceCollection {
    
  public:

    SurfaceMap(SurfaceManager &mgr,
               DDPIXELFORMAT &pf,
               texture_enum isTx=notTexture);
    virtual ~SurfaceMap();
    
    void DeleteImagesFromMap(bool skipmovies = true);

    DDSurface *LookupSurfaceFromImage(Image *image);

    void StashSurfaceUsingImage(Image *image, DDSurface *surf);

    void DeleteMapEntry(Image *image);

    #if _DEBUG
    void Report() {
      TraceTag((tagError, "map size: %d\n", _map.size()));
      //TraceTag((tagError, "surface collection size: %d\n", Size()));
    }
    #endif

  protected:

    bool IsEmpty() { return _map.empty(); }

  private:

    void ReleaseCurrentEntry();

    texture_enum    _isTexture;
    
    typedef map<Image *,
                DDSurface *,
                less<Image *> > imageMap_t;

    imageMap_t::iterator _i;
    imageMap_t  _map;
};


class CompositingStack : public SurfacePool {

  public:

    CompositingStack(DirectDrawViewport &vp, SurfacePool &sp);
    ~CompositingStack();

    void GetSurfaceFromFreePool(
        DDSurface **outSurf,
        clear_enum   clr,
        INT32 minW=-1, INT32 minH=-1,
        scratch_enum scr = notScratch,
        vidmem_enum  vid = notVidmem, 
        except_enum  exc = except);

    void PushCompositingSurface(
        clear_enum   clr,
        scratch_enum scr = notScratch,
        vidmem_enum  vid = notVidmem, 
        except_enum  exc = except);
        
    inline DDSurface *TargetDDSurface() {
        Assert( (Size() > 0) && "TargetDDSurface(): No surface available on CompositingStack!");
        return Back();  // won't get inlined, no code bloat
    }

    inline void PushTargetSurface(DDSurface *surface) {
        DebugCode( _debugonly_doAsserts( surface ) );
        ADDREF_DDSURF( surface, "CompositingStack::PushTargetSurface", this );
        PushBack(surface);
    }
    
    void PopTargetSurface();

    inline int TargetSurfaceCount() {
        return Size();
    }

    inline void ReturnSurfaceToFreePool(DDSurface *ddsurf) {
        _freeSurfacePool.AddSurface(ddsurf);
    }
    DDSurface *ScratchDDSurface(
        clear_enum cl = dontClear,
        INT32 minW=-1, INT32 minH=-1);  
    
    inline void ScratchDDSurface(
        DDSurface **outSurf,
        clear_enum cl = dontClear,
        INT32 minW=-1, INT32 minH=-1)
    {
        *outSurf = ScratchDDSurface(cl, minW, minH);
        ADDREF_DDSURF(*outSurf, "ScratchDDSurface (get ref version)", this);
    }
    inline DDSurface *GetScratchDDSurfacePtr() {
        return _scratchDDSurface;
    }
    inline void SetScratchDDSurface(DDSurface *surface) {
        _scratchDDSurface = surface;
    }

    void ReplaceAndReturnScratchSurface(DDSurface *surface);

    inline void ReleaseScratch() {
        _scratchDDSurface.Release();
    }
        
    #if _DEBUG
    void Report() {
      TraceTag((tagError, "Stack(%x)  size: %d\n", this, Size()));
      TraceTag((tagError, "Stack(%x)  pool: "));
      _freeSurfacePool.Report();
    }
    #endif

  private:

    DirectDrawViewport &_viewport;
    SurfacePool &_freeSurfacePool;
    DDSurfPtr<DDSurface> _scratchDDSurface;
};




//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Surface Tracker:  keeps track of all allocated surfaces on a per viewport
//  basis for debugging.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#if _DEBUG
class SurfaceTracker {
  public:
    SurfaceTracker() {}

    ~SurfaceTracker() {
        Report();
    }
    
    void NewSurface(DDSurface *s)
    {
        Assert( !Find(s));
        _pool.push_back(s);
    }
    
    void DeleteSurface(DDSurface *s)
    {
        if(Find(s)) {
            _pool.erase(_i);
        } else {
            TraceTag((tagError, "SurfaceTracker: possible multiple delete.  <false alarm if dxtransforms in sample>"));
        }
    }

    void Report() {
        TraceTag((tagDDSurfaceLeak, "-------- begin: Leaked Surfaces R E P O R T --------"));

        for(_i = _pool.begin(); _i != _pool.end(); _i++) {
            (*_i)->Report();
        }

        TraceTag((tagDDSurfaceLeak, "-------- end: SurfaceTracker R E P O R T --------"));
    }

    bool Find(DDSurface *ddsurf)
    {
        for(_i = _pool.begin(); _i != _pool.end(); _i++) {
            if( (*_i) == ddsurf ) {
                return true;
            }
        }
        return false;
    }

    // Use a list, deque has a bug!
    typedef list<DDSurface *> surfDeque_t;

    surfDeque_t::iterator _i;
    surfDeque_t     _pool;
};
#endif

#endif /* _SURFACEMANAGER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\urlbuf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _URLBUF_H
#define _URLBUF_H

#include <urlmon.h>
#include <wininet.h>
#include "dastream.h"

extern HINSTANCE hInst;

class CDXMBindStatusCallback : public IBindStatusCallback,
                               public IAuthenticate
{
  public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid,void ** ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IBindStatusCallback methods
    STDMETHOD(OnStartBinding)(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHOD(GetPriority)(LONG* pnPriority);
    STDMETHOD(OnLowResource)(DWORD dwReserved);
    STDMETHOD(OnProgress)(
                ULONG ulProgress,
                ULONG ulProgressMax,
                ULONG ulStatusCode,
                LPCWSTR pwzStatusText);
    STDMETHOD(OnStopBinding)(HRESULT hrResult, LPCWSTR szError);
    STDMETHOD(GetBindInfo)(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHOD(OnDataAvailable)(
                DWORD grfBSCF,
                DWORD dwSize,
                FORMATETC *pfmtetc,
                STGMEDIUM* pstgmed);
    STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown* punk);

    // IAuthenticate methods
    STDMETHOD(Authenticate)(
                HWND * phwnd,
                LPWSTR * pwszUser,
                LPWSTR * pwszPassword);

    // Constructors/destructors
    CDXMBindStatusCallback(void);
    virtual ~CDXMBindStatusCallback(void);

  private:
    IBinding*       m_pbinding;
    DWORD           m_cRef;
};

class CBSCWrapper
{
  public:
    CBSCWrapper(void);
    ~CBSCWrapper(void);

    CDXMBindStatusCallback *   _pbsc;
};

class daurlstream : public daolestream
{
  public:
    daurlstream(const char * name);
  protected:
    CBSCWrapper bsc;
};

class INetTempFile
{
  public:
    // This raises an exception on failure
    INetTempFile (LPCSTR szURL) ;
    INetTempFile () ;
    ~INetTempFile () ;

    // These do not raise exceptions

    BOOL Open (LPCSTR szURL) ;
    void Close () ;

    LPSTR GetTempFileName () { return _tmpfilename ; }
    LPSTR GetURL () { return _url ; }

    BOOL IsOpen() { return _url != NULL ; }
  protected:
    LPSTR _url ;
    LPSTR _tmpfilename ;
} ;


class URLRelToAbsConverter
{
  public:
    URLRelToAbsConverter(LPSTR baseURL, LPSTR relURL);

    LPSTR GetAbsoluteURL () { return _url ; }
  protected:
    char _url[INTERNET_MAX_URL_LENGTH + 1] ;
} ;

class URLCanonicalize
{
  public:
    URLCanonicalize(LPSTR path);

    LPSTR GetURL () { return _url ; }
  protected:
    char _url[INTERNET_MAX_URL_LENGTH + 1] ;
} ;

#endif /* _URLBUF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\textctx.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Context for gather text state during rendering

*******************************************************************************/


#ifndef _TEXTCTX_H
#define _TEXTCTX_H

#include "headers.h"
#include "appelles/common.h"
#include "appelles/color.h"
#include "appelles/text.h"
#include "privinc/imgdev.h"
#include "privinc/server.h"
#include "appelles/bbox2.h"
#include "texti.h"

class DirectDrawImageDevice;

class TextCtx {
  public:

    enum ForWhat {
        renderForReal,
        renderForColor,
        renderForBox,
        renderForPath
    };

    TextCtx(DirectDrawImageDevice *dev=NULL,
            Image *textImg=NULL) :
      _dev(dev),
      _textImg(textImg)
    {
        // Just set up the defaults...
        _col = white;
        _font = ff_serifProportional;

        _bold = FALSE;
        _italic = FALSE;
        _strikethrough = FALSE;
        _underline = FALSE;
        
        _fixedText = false;
        
        _weight = (double)(FW_NORMAL) / 1000.0;
        _antiAlias = 0.0;
        _fontSize = DEFAULT_TEXT_POINT_SIZE;
        _defaultColor = _col;
        _defaultFont = _font;

        _fontSet = false;
        _colorSet = false;

        _stashedBbox = NullBbox2;
        _stashedColor = NULL;

        _forWhat = renderForReal;

        _dc = NULL;
        _xform = NULL;
        _familyName = NULL;

        _characterTransform = NULL;
    }

    ~TextCtx() {}
    
    void  BeginRendering(ForWhat forWhat = renderForReal,
                         HDC dc=NULL,
                         Transform2 *xform=NULL) 
    { 
        _forWhat = forWhat; 
        _dc = dc;
        _xform = xform;
        Assert(_characterTransform == NULL);
    }
    void RenderString(WideString str);
    void  EndRendering() { }

    inline const Bbox2& GetStashedBbox() { 
        return _stashedBbox;
    }

    Color *GetStashedColor() {
        Assert(_stashedColor && "stashedBbox not derived in textctx!"); 
        return _stashedColor;
    }

    Color *GetColor() { return _col; }
    void    SetColor(Color *col) {
        if (!_colorSet) {
            _col = col;
            _colorSet = TRUE;
        }
    }
    void    ResetColor() { _col = _defaultColor; }


    FontFamilyEnum  GetFont() { return _font; }
    void    SetFont(FontFamilyEnum font) {
        if (!_fontSet) {
            _font = font;
            _fontSet = TRUE;
        }
    }

    WideString GetFontFamily() { return _familyName; }
    void SetFontFamily(WideString familyName) { _familyName = familyName; }
    
    void    ResetFont() {
        _font = _defaultFont;
        _familyName = NULL;
    }

    Bool    GetBold() { return _bold; }
    void    SetBold(Bool b) { _bold = b; }

    Bool    GetItalic() { return _italic; }
    void    SetItalic(Bool i) { _italic = i; }

    Bool    GetUnderline() { return _underline; }
    void    SetUnderline(Bool b) { _underline = b; }

    Bool    GetStrikethrough() { return _strikethrough; }
    void    SetStrikethrough(Bool b) { _strikethrough = b; }

    double  GetWeight() { return _weight; }
    void    SetWeight(double weight) { _weight = weight; }

    Real    GetAntiAlias() { return _antiAlias; }
    void    SetAntiAlias(Real aa) { _antiAlias = aa; }
    
    int     GetFontSize() { return _fontSize; }
    void    SetFontSize(int size) { _fontSize = size; }
    
    bool    GetFixedText() { return _fixedText; }
    void    SetFixedText(bool b) { _fixedText = b; }

    void    SetTextImageTopRight(Point2Value *topRight) { _topRight = topRight; }
    Point2Value *GetTextImageTopRight() { return _topRight;  }

    void    SetCharacterTransform(Transform2 *xf) { _characterTransform = xf;}
    Transform2 *GetCharacterTransform() { return _characterTransform; }
    
  protected:

    // purpose of ctx accumulation
    ForWhat _forWhat;

    // Traversal attributes.
    Color      *_col;
    Color      *_defaultColor;
    FontFamilyEnum  _font, _defaultFont;
    Bool        _bold;
    Bool        _underline;
    Bool        _strikethrough;
    Bool        _italic;
    bool        _fixedText;
    Real        _weight;
    Real        _antiAlias;
    int         _fontSize;

    WideString _familyName;

    // Top right corner of the un-transformed text
    Point2Value     *_topRight;

    // Per character transform.
    Transform2 *_characterTransform;
    
    // owning text
    //Text       *_text;
    Image    *_textImg;

    // Simple on/off bits to specify whether these attributes have
    // been set.
    bool        _fontSet;
    bool        _colorSet;

    // What rendering mode
    Bool        _deriveBbox;

    // Stashed info for non real rendering
    Bbox2      _stashedBbox;
    Color      *_stashedColor;

    // info for path accumulation
    HDC          _dc;
    Transform2  *_xform;

    // Image device we're created with
    DirectDrawImageDevice *_dev;
};

#endif /* _TEXTCTX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\urlimage.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _URLIMAGE_H
#define _URLIMAGE_H

#include <ddraw.h>
#include <dxhtml.h>

#include <privinc/comutil.h>
#include <privinc/discimg.h>

#include "privinc/probe.h"

class UrlImage : public DiscreteImage {

  public:

    UrlImage(IDirectXHTML *pDxhtml, AxAString *url);
    virtual ~UrlImage(){ CleanUp(); }

    void CleanUp() {
        _pDXHTML.Release();
        _pDXHTMLCallback.Release();
    }
    
    bool SetupDxHtml();
    IDirectXHTML  *GetDXHTML() { return _pDXHTML; }

    void OnWindowMessage(UINT msg,
                         WPARAM wParam,
                         LPARAM lParam);    
    void SetSampleTime(double t) {
        _lastTime = _curTime;
        _curTime = t;
        _isHit = false;
    }
        
    void OnCompletedDownload(SIZEL *docSize)
    {
        _downdLoadComplete = true;
        #if 0
        _width = docSize->cx;
        _height = docSize->cy;
        ::SetRect(&_rect, 0,0, _width, _height);

        _membersReady = TRUE;
        #endif
    }

    void Render(GenericDevice& dev);
    
    const Bbox2 BoundingBox() {

        /*
        if( _downdLoadComplete && !_bboxReady) {
            SetBbox( GetPixelWidth(),
                     GetPixelHeight(),
                     GetResolution() );
            _bboxReady = TRUE;
        }*/
        
        return _bbox;
    }

    void  SetBbox(int w, int h, Real res)
    {
        _bbox.min.Set(Real( - w ) * 0.5 / res,
                      Real( - h ) * 0.5 / res);
        _bbox.max.Set(Real( w ) * 0.5 / res,
                      Real( h ) * 0.5 / res);
        _bboxReady = TRUE;
    }

    void SetMembers( int w, int h )
    {
        _width = w;  _height = h;
        ::SetRect(&_rect, 0,0, _width, _height);
        _membersReady = TRUE;
    }
    
    Bool DetectHit(PointIntersectCtx& ctx);

    void InitializeWithDevice(ImageDisplayDev *dev, Real res);
    
    void InitIntoDDSurface(DDSurface *ddSurf, ImageDisplayDev *dev);

    VALTYPEID GetValTypeId() { return URLIMAGE_VTYPEID; }
    bool CheckImageTypeId(VALTYPEID type) {
        return (type == UrlImage::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }

    // Ricky:  is this correct ??
    void DoKids(GCFuncObj proc) { 
        DiscreteImage::DoKids(proc);
        (*proc)(_url); 
    }

           
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(UrlImage @ " << (void *)this << ")";
    }   
#endif

    
  private:

    DebugCode( DDSurface *_initialDDSurf );

    AxAString *_url;
    DAAptComPtr<IDirectXHTML, &IID_IDirectXHTML> _pDXHTML;
    DAComPtr<IDirectXHTMLCallback>               _pDXHTMLCallback;

    ULONG         _lastHitX;
    ULONG         _lastHitY;
    
    double        _lastTime;
    double        _curTime;

    bool          _isHit;
    bool          _downdLoadComplete;
};
    
//**********************************************************************
// File name: DXHTMLCB.h
//
// Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//**********************************************************************

//
// Interface
//
class CDirectXHTMLCallback : public IDirectXHTMLCallback
{
private:
    UrlImage        *_urlImage;
    ULONG           m_cRef;

public:
    //
    // Constructor and Destructor
    //
    CDirectXHTMLCallback(UrlImage *);
    ~CDirectXHTMLCallback();

    //
    // IUnknown Interfaces
    //
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    //
    // Initialization methods
    //
    STDMETHODIMP OnSetTitleText( LPCWSTR lpszText );
    STDMETHODIMP OnSetProgressText( LPCWSTR lpszText );
    STDMETHODIMP OnSetStatusText( LPCWSTR lpszText );
    STDMETHODIMP OnSetProgressMax( const DWORD dwMax );
    STDMETHODIMP OnSetProgressPos( const DWORD dwPos );
    STDMETHODIMP OnCompletedDownload( void );
    STDMETHODIMP OnInvalidate( const RECT *lprc, DWORD dwhRgn, VARIANT_BOOL fErase );
};


#endif /* _URLIMAGE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\textimg.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _TEXTIMG_H
#define _TEXTIMG_H

#include "privinc/storeobj.h"
#include "appelles/text.h"
#include "appelles/image.h"
#include "privinc/probe.h"
#include "privinc/texti.h"
#include "privinc/textctx.h"
#include "privinc/bbox2i.h"

class TextImage : public Image {
  public:
    TextImage(Text *t) : _text(t), _bbox(NullBbox2) {}

    void Render(GenericDevice& dev);

    const Bbox2 BoundingBox() {
        return DeriveBbox();
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, DeriveBbox());
    }
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) { return box; }

    Bool  DetectHit(PointIntersectCtx& ctx) {
        Point2Value *lcPt = ctx.GetLcPoint();

        if (!lcPt) return FALSE; // singular transform
        
        return BoundingBox().Contains(Demote(*lcPt));
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "RenderTextToImage(...)";
    }
#endif

    Bool GetColor(Color **color) {
        TextCtx ctx;
        
        ctx.BeginRendering(TextCtx::renderForColor);
        _text->RenderToTextCtx(ctx);
        ctx.EndRendering();

        *color = ctx.GetStashedColor();
        return TRUE;
    }

    Text *GetText() { return _text; }
    
    // Turn off text caching because of clear quality issues by making
    // Savings return 0.  Re-enable by making it return 2.
    int Savings(CacheParam& p) { return 0; }

    virtual void DoKids(GCFuncObj proc);

  protected:
    const Bbox2 DeriveBbox();
    Text *_text;
    Bbox2 _bbox;
};


#endif /* _TEXTIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\tls.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Structures on thread-local storage

*******************************************************************************/


#ifndef _TLS_H
#define _TLS_H

#include "except.h"

class DynamicHeap;


class ThreadLocalStructure : public AxAThrowingAllocatorClass {
  public:

    ThreadLocalStructure() {
        _bitmapCaching = NoPreference;
        _geometryBitmapCaching = NoPreference;
    }
    
    stack<DynamicHeap*> _stackOfHeaps;

    BoolPref _bitmapCaching;
    BoolPref _geometryBitmapCaching;
};

LPVOID CreateNewStructureForThread(DWORD tlsIndex);
extern DWORD localStructureTlsIndex;

// Make this function inlined, since it is called quite frequently.
// The elements of it that are called on process or thread creation
// only are not inlined.
inline ThreadLocalStructure *
GetThreadLocalStructure()
{
    // Grab what is stored in TLS at this index.
    LPVOID result = TlsGetValue(localStructureTlsIndex);

    // If null, then we haven't created the stack for this thread yet.
    // Do so.
    if (result == NULL) {
        Assert((GetLastError() == NO_ERROR) && "Error in TlsGetValue()");
        result = CreateNewStructureForThread(localStructureTlsIndex);
    }

    return (ThreadLocalStructure *)result;
}

#endif /* _TLS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\viewport.h ===
#ifndef _VIEWPORT_H
#define _VIEWPORT_H

/*-------------------------------------
Copyright (c) 1996 Microsoft Corporation
-------------------------------------*/

#include "headers.h"

#include <math.h>
#include <ddraw.h>
#include <ddrawex.h>
#include <privinc/error.h>
#include <privinc/ddSurf.h>
#include <privinc/SurfaceManager.h>
#include <privinc/bbox2i.h>
#include <privinc/drect.h>
#include <privinc/discimg.h>
#include <privinc/gendev.h>    // DeviceType


void RectToBbox(LONG pw, LONG ph, Bbox2 &box, Real res);

typedef struct {
    // even though these are mutuall exlusive..
    // they should NOT be a union.
    DDSurfPtr<DDSurface>  _targetDDSurf;
    DDSurfPtr<GDISurface> _targetGDISurf;
    HWND           _targetHWND;
    bool           _alreadyOffset;

    targetEnum     _targetType;

    RECT          *_prcViewport;
    RECT          *_prcClip;
    RECT          *_prcInvalid;
    POINT          _offsetPt;

    bool           _composeToTarget;

    // accessor fcns
    bool IsHWND() { return _targetType == target_hwnd; }
    bool IsDdsurf() { return _targetType == target_ddsurf; }
    bool IsHdc() { return _targetType == target_hdc; }
    bool IsValid() { return _targetType != target_invalid; }

    #if LATER
    // if this is implemented, make sure to add reset code in Reset()
    HRGN           _oldClipRgn;
    HRGN           _clipRgn;
    HDC            _dcFromSurf;
    #endif

    void Reset(bool doDelete)
    {
        _targetType = target_invalid;
        _targetHWND = NULL;
        if(doDelete) {
            delete _prcViewport;
            delete _prcClip;
            delete _prcInvalid;
        }
        _prcViewport = _prcClip = _prcInvalid = NULL;
        _offsetPt.x = _offsetPt.y = 0;
        _composeToTarget = false;
        _alreadyOffset = false;
    }
        
} viewportTargetPackage_t;

// when we want to use ddraw3 exclusively
#define DDRAW3 0
#define DIRECTDRAW DirectDraw3()

#if _DEBUG
#define CREATESURF(desc, surfpp, punk, str) MyCreateSurface(desc, surfpp, punk, str);
#else
#define CREATESURF(desc, surfpp, punk, str) MyCreateSurface(desc, surfpp, punk);
#endif

// viewport functions.
HRESULT GetDirectDraw(IDirectDraw **ddraw1, IDirectDraw2 **ddraw2, IDirectDraw3 **ddraw3);
HRESULT GetPrimarySurface(IDirectDraw2 *ddraw2, IDirectDraw3 *ddraw3, IDDrawSurface **primary);

int BitsPerDisplayPixel (void);

HRESULT SetClipperOnPrimary(LPDIRECTDRAWCLIPPER clipper);

// debug helper functions
#if _DEBUG
extern void DrawRect(HDC dc, RECT *rect,
                     int r, int g, int b,
                     int a1=0, int a2=0, int a3=0);
extern void DrawRect(DDSurface *surf, RECT *rect,
                     int r, int g, int b,
                     int a1=0, int a2=0, int a3=0);
extern void DrawRect(DDSurface *surf, const Bbox2 &bbox,
                     int height, int width, Real res,
                     int r, int g, int b);
#else
#define DrawRect(a,b, d,e,f, g,h,i)
#endif

// Structures used in this class
class TargetDescriptor
{
  public:
    TargetDescriptor() { Reset(); }
    void Reset() {
        isReady = false;
        ZeroMemory(&_pixelFormat, sizeof(DDPIXELFORMAT));
        _redShift = _greenShift = _blueShift = 0;
        _redWidth = _greenWidth = _blueWidth = 0;
        _redTrunc = _greenTrunc = _blueTrunc = 0;
        _red = _green = _blue = 0;
    }

    inline DDPIXELFORMAT &GetPixelFormat() { return _pixelFormat; }
    
    bool isReady;
    DDPIXELFORMAT _pixelFormat;
    char _redShift,  _greenShift, _blueShift;
    char _redWidth, _greenWidth, _blueWidth;
    char _redTrunc, _greenTrunc, _blueTrunc;
    Real _red, _green, _blue;
};


// forward decls
class GeomRenderer;
class DirectDrawImageDevice;
class DibImageClass;
class TextCtx;
class CompositingSurfaceReturner;
struct ClipperReturner;
class SurfacePool;
class SurfaceMap;
class DAGDI;
class targetPackage_t;

class DirectDrawViewport : public GenericDevice {

    // TODO: These guys *should not* all have to be friends.  This is
    // really bogus.  The methods should be made public. 
    friend class  DirectDrawImageDevice;
    friend class  GeomRenderer;
    friend class  CompositingSurfaceReturner;
    friend class  OverlayedImage;
    friend class  CImageDecodeEventSink;
    friend struct ClipperReturner;
    friend class  TargetSurfacePusher;
    friend class  SurfaceArrayReturner;
    friend class  ApplyDXTransformImage;
    
  public:
    DirectDrawViewport();
   ~DirectDrawViewport();

    //
    // Must be called right after construction, ok ?
    //
    void PostConstructorInitialize();

    DeviceType GetDeviceType() { return(IMAGE_DEVICE); }
    
    void RenderImage(Image *image, DirtyRectState &d);
    void BeginRendering(Real topLevelOpac);
    void EndRendering(DirtyRectState &d);
    void Clear();

    bool SetTargetPackage(targetPackage_t *targetPackage);

    int Width() const { return _width; }
    int Height() const { return _height; }

    void SetWidth(int w)  { _width = w; }
    void SetHeight(int h) { _height = h; }

    // Return resolution, in pixels per meter.
    Real GetResolution() { return _resolution; }

    DWORD GetTargetBitDepth() { return _targetDepth; }
    DDPIXELFORMAT &GetTargetPixelFormat() {
        Assert( _targetPixelFormatIsSet );
        Assert( _compositingStack );
        Assert( _compositingStack->IsSamePixelFormat( &_targetDescriptor.GetPixelFormat()));
        return _compositingStack->GetPixelFormat();
    }
    TargetDescriptor &GetTargetDescriptor() { return _targetDescriptor; }
    
    IDirectDraw*  DirectDraw1 (void);
    IDirectDraw2* DirectDraw2 (void);

    #if DDRAW3
        IDirectDraw3* DirectDraw3 (void);
    #else
        inline IDirectDraw2* DirectDraw3 (void) { return DirectDraw2(); }
    #endif

    void DiscreteImageGoingAway(DiscreteImage *image);

    HRESULT MyCreateSurface(LPDDSURFACEDESC lpDesc,
                            LPDIRECTDRAWSURFACE FAR * lplpSurf,
                            IUnknown FAR *pUnk
    #if _DEBUG
                            ,char *whyWhy
    #endif
                            );
#if _DEBUGSURFACE // XXX Note: this code is incorrect due to the perf scoping
                  //           used for movies!
SurfaceTracker *_debugonly_surfaceTracker;
SurfaceTracker *Tracker() {return _debugonly_surfaceTracker;}
#endif


    // -- Win32 Event handling methods --

    void WindowResizeEvent(int width, int height) {  _windowResize = TRUE; }

    // Can this frame be displayed ?
    Bool CanDisplay() {
        return
            _canDisplay &&
            _deviceInitialized &&
            !OnDeathRow();
    }

    bool IsInitialized() { return _deviceInitialized; }
    bool IsWindowless() { return ! _targetPackage._targetHWND; }
    bool IsCompositeDirectly() {  return _targetPackage._composeToTarget;  }
    bool IsSurfMgrSet() { return _surfMgrSet; }
    
    void Stop() {
        _canDisplay = false;
        _canFinalBlit = false;
    }
    void MarkForDestruction() { _onDeathRow = true; }
    bool ICantGoOn() { return _onDeathRow; }
    bool OnDeathRow() { return _onDeathRow; }
    bool IsTargetViable();
    
    DirectDrawImageDevice *GetImageRenderer() {
        return _currentImageDev;
    }

    bool TargetsDiffer( targetPackage_t &a,
                        targetPackage_t &b );
    
    GeomRenderer* MainGeomRenderer (void);
    GeomRenderer* GetAnyGeomRenderer(void);
    void AddGeomDev(GeomRenderer *gdev) { _geomDevs.push_back(gdev);}
    void RemoveGeomDev(GeomRenderer *gdev) { _geomDevs.remove(gdev); }

    IDX2D *GetDX2d() { return _dx2d; }
    IDXTransformFactory *GetDXTransformFactory() { return _IDXTransformFactory; }
    IDXSurfaceFactory *GetDXSurfaceFactory() { return _IDXSurfaceFactory; }

    void CreateSizedDDSurface(DDSurface **ppSurf,
                              DDPIXELFORMAT &pf,
                              LONG width,
                              LONG height,
                              RECT *clipRect,
                              vidmem_enum vid=notVidmem);
    
  private:

    bool ReallySetTargetPackage(targetPackage_t *targetPackage);
    bool GetPixelFormatFromTargetPackage(targetPackage_t *targetStruct,DDPIXELFORMAT &targPf);
   
    void SetUpSurfaceManagement( DDPIXELFORMAT &ddpf );
    void ConstructDdrawMembers();
    void InitializeDevice();    // inits device, ddraw,
                                // deviceDescriptor, etc..
    void SetUpDx2D();
    DAComPtr<IDX2D> _dx2d;
    DAComPtr<IDXTransformFactory> _IDXTransformFactory;
    DAComPtr<IDXSurfaceFactory>   _IDXSurfaceFactory;
    
    // -- Device cache functions & members --
    list<DirectDrawImageDevice *> _deviceStack;
    DirectDrawImageDevice *_tmpDev;
    DirectDrawImageDevice *PopImageDevice();
    void PushImageDevice(DirectDrawImageDevice *dev);

    // -- Private helper functions --

    void UpdateWindowMembers();

    // Destroys surface if exists.  Creates surface
    // with width/height size and clipRect for clipping.
    void ReInitializeSurface(
        LPDDRAWSURFACE *surfPtrPtr,
        DDPIXELFORMAT &pf,
        LPDIRECTDRAWCLIPPER *clipperPtr,
        LONG width,
        LONG height,
        RECT *clipRect,
        vidmem_enum vid=notVidmem,
        except_enum exc=except);

    // Creates a clipper object if one doesn't exist already
    void CreateClipper(LPDIRECTDRAWCLIPPER *clipperPtr);

    // helper function for EndRendering

    void BlitToPrimary(POINT *p,RECT *destRect,RECT *srcRect);

    // Creates a vanilla offscreen surface of width/height
    void CreateOffscreenSurface(
        LPDDRAWSURFACE *surfPtrPtr,
        DDPIXELFORMAT &pf,      
        LONG width,
        LONG height,
        vidmem_enum vid=notVidmem,
        except_enum exc=except);

    // Creates a surface using the give specifications
    void CreateSpecialSurface(
        LPDDRAWSURFACE *surfPtrPtr,
        LPDDSURFACEDESC desc,
        char *errStr);

    // Attaches a ZBUFFER surface to the target, creates if nonexistent.
    // If a Zbuffer can't be created, then an exception is thrown if except
    // is true, otherwise it returns the error code.

    HRESULT AttachZBuffer (DDSurface *zbuff, except_enum exc=except);

    // Sets cliplist on surface of size 'rect'.
    void SetCliplistOnSurface(
        LPDDRAWSURFACE surface,
        LPDIRECTDRAWCLIPPER *clipper,
        RECT *rect);

    HPALETTE GethalftoneHPal();
    LPDIRECTDRAWPALETTE GethalftoneDDpalette();
    HPALETTE CreateHalftonePalettes();
    bool AttachFinalPalette(LPDDRAWSURFACE surface);
    void GetPaletteEntries(HPALETTE hPal, LPPALETTEENTRY palEntries);
    void CreateDDPaletteWithEntries(LPDIRECTDRAWPALETTE *palPtr, LPPALETTEENTRY palEntries);
    //void SelectDDPaleteIntoDC(HDC dc, LPDDRAWSURFACE surface, char *str, int times);
    void SetPaletteOnSurface(LPDDRAWSURFACE surface,
                             LPDIRECTDRAWPALETTE pal);

    void OneTimeDDrawMemberInitialization();
    void CreateSizeDependentTargDDMembers() {
        Assert(!_targetSurfaceClipper);
        //_targetSurfaceClipper = NULL;
        //
        // Create the surface and implicitly (also clipper)
        // Push on _targetSurfaceStack
        //
        PushFirstTargetSurface();
    }

    void RePrepareTargetSurfaces (void);
    //
    // Returns the geom device associated with the DDSurface
    // creates one if none exists.
    //
    GeomRenderer *GetGeomDevice(DDSurface *ddSurf);
    
    DWORD MapColorToDWORD(Color *color);
    DWORD MapColorToDWORD(COLORREF colorRef);

    void UpdateTargetBbox() {
        Real temp;
        temp = GetResolution();
        if (temp != 0)
        {
            Real w = Real(Width()) / temp;
            Real h = Real(Height()) / temp;
            _targetBbox.min.Set(-(w*0.5), -(h*0.5));
            _targetBbox.max.Set( (w*0.5),  (h*0.5));
        }
    }

  public:

    CompositingStack *GetCompositingStack() { return _compositingStack; }
    void AttachCurrentPalette (LPDDRAWSURFACE surface, bool bUsingXforms=false);
    bool IsNT5Windowed() { return (sysInfo.IsNT() && (sysInfo.OSVersionMajor() == 5) && _targetPackage.IsHWND()); }

    // Don't even think of holding on to this bbox!
    inline const Bbox2& GetTargetBbox(void) const 
    { 
        return _targetBbox; 
    }
    
  private:
    // Creates a logical font struct from description in textCtx
    void MakeLogicalFont(TextCtx &textCtx, LPLOGFONTW,
                         LONG width=0, LONG height=0);

    // Enumerates all systems fonts and chooses
    // reasonable fits for font needs
    //void SetUpFonts();

  public:
    void ClearSurface(DDSurface *dds, DWORD color, RECT *rect);
    void ClearDDSurfaceDefaultAndSetColorKey(DDSurface *dds)
    {
        ClearDDSurfaceDefaultAndSetColorKey(dds, _defaultColorKey);
    }
    
    void ClearDDSurfaceDefaultAndSetColorKey(DDSurface *dds, DWORD clrKey)
    {
        Assert( ( dds != _externalTargetDDSurface ) &&
                "trying to clear external target surface" );

        // Set the color key on the surface which stripps off any
        // offending alpha bits.  then get it back out to clear the
        // surace with...
        dds->SetColorKey( clrKey );
        // NOTE: DO NOT MOVE THE SETCOLORKEY AFTER THE CLEARSURFACE
        // CALL!
        // NOTE: DO NOT PASS IN A COLOR KEY TO THE CALL WITHOUT
        // GETTING THE KEY FROM THE SURFACE!!!
        ClearSurface(dds, dds->ColorKey(), dds->GetSurfRect());
        //dds->ClearInterestingRect();
    }

    // --------------------------------------------------
    //
    // Compositing & target surface management
    //
    // --------------------------------------------------

    void GetDDSurfaceForCompositing
        (SurfacePool &pool,
         DDSurface  **outSurf,
         INT32 w, INT32 h,
         clear_enum   clr,
         scratch_enum scr = notScratch,
         vidmem_enum  vid = notVidmem, 
         except_enum  exc = except);

    DWORD GetColorKey() { return _defaultColorKey; }
    void  SetColorKey(DWORD key) { _defaultColorKey = key; }
        
    targetPackage_t     _oldtargetPackage;

    bool GetAlreadyOffset(DDSurface * ddsurf);
    POINT GetOffset() { return _targetPackage._offsetPt; };
  
  private:

    void DestroyCompositingSurfaces() {
        if (_freeCompositingSurfaces) {
            _freeCompositingSurfaces->ReleaseAndEmpty();
        }
    }
    void CreateNewCompositingSurface
         (DDPIXELFORMAT &pf,
          DDSurface **outSurf,
          INT32 width = -1, INT32 height = -1,
          vidmem_enum vid=notVidmem,
          except_enum exc=except);
    
    void ColorKeyedCompose
         (DDSurface *destDDSurf,
          RECT *srcRect,
          DDSurface *srcDDSurf,
          RECT *destRect,
          DWORD clrKey);

    // @@@ ???  this doesn't count any more.
    // we need to decide who the rendering device is, prepare it's
    // compositing stack and surface pool, hand them to it and the let
    // it go.
    void PushFirstTargetSurface();

    void DestroyTargetSurfaces();
    void DestroySizeDependentDDMembers();

    viewportTargetPackage_t   _targetPackage;
    
    LPDIRECTDRAWCLIPPER _targetSurfaceClipper;
    DDSurfPtr<DDSurface> _externalTargetDDSurface;
    LPDIRECTDRAWCLIPPER _externalTargetDDSurfaceClipper;
    LPDIRECTDRAWCLIPPER _oldExternalTargetDDSurfaceClipper;
    bool                _opacityCompositionException;

    bool                _usingExternalDdraw;

    IUnknown     *_directDraw;
    IDirectDraw  *_directDraw1;
    IDirectDraw2 *_directDraw2;
    IDirectDraw3 *_directDraw3;
    IDDrawSurface      *_primSurface;

    IDDrawSurface      * GetMyPrimarySurface();

    void  ReleaseIDirectDrawObjects();
    
    LPDIRECTDRAWCLIPPER _primaryClipper;

    bool                _retreivedPrimaryPixelFormat;
    DDPIXELFORMAT       _primaryPixelFormat;
    bool                _targetPixelFormatIsSet;

    // -- Image/Surface Map members and functions --
    // Associates Images (that stick around across frames)
    // with surfaces dedicated to them.
    SurfaceManager *_surfaceManager;
    SurfaceMap  *_imageSurfaceMap;
    SurfaceMap  *_imageTextureSurfaceMap;
    SurfaceMap  *_imageUpsideDownTextureSurfaceMap;

    SurfacePool      *_freeCompositingSurfaces;
    SurfacePool      *_zbufferSurfaces;
    
    CompositingStack *_compositingStack;

    void AddZBufferDDSurface(DDSurface *surf) {
        _zbufferSurfaces->AddSurface(surf);
    }

    void DestroyZBufferSurfaces() {
        if (_zbufferSurfaces) {
            _zbufferSurfaces->ReleaseAndEmpty();
        }
    }

    //
    // List of Geometry devices: for picking
    //
    list<GeomRenderer *> _geomDevs;

    void NotifyGeomDevsOfSurfaceDeath(
        LPDDRAWSURFACE surface)
    {
        DDSurfPtr<DDSurface> dds;

        // XXX: factor out. see below!
        _freeCompositingSurfaces->Begin();
        while( !_freeCompositingSurfaces->IsEnd() ) {
            dds = _freeCompositingSurfaces->GetCurrentSurf();
            if(dds->GeomDevice()) {
                dds->GeomDevice()->SurfaceGoingAway(surface);
            }
            _freeCompositingSurfaces->Next();
        }

        dds = _compositingStack->GetScratchDDSurfacePtr();
        if(dds && dds->GeomDevice()) {
            dds->GeomDevice()->SurfaceGoingAway(surface);
        }


        // XXX: factor out. see above!
        // Do target surfaces
        _compositingStack->Begin();
        while( !_compositingStack->IsEnd() ) {
            dds = _compositingStack->GetCurrentSurf();
            if(dds->GeomDevice()) {
                dds->GeomDevice()->SurfaceGoingAway(surface);
            }
            _compositingStack->Next();
        }
    }

    // -- Viewport/window data members --
    Real          _resolution; // of dev, in pixels per meter
    int           _width;
    int           _height;
    DWORD         _targetDepth;      // Bits Per Pixel

    RECT         _clientRect;
    Bbox2        _targetBbox;

    LPDIRECTDRAWPALETTE _finalDDpalette;
    LPDIRECTDRAWPALETTE _halftoneDDpalette;
    HPALETTE            _halftoneHPal;

    bool         _canDisplay;
    bool         _windowResize;
    bool         _deviceInitialized;
    bool         _canFinalBlit;
    bool         _surfMgrSet;
    //
    // true if the device needs to be destroyed
    // next chance possible.  Used when the mode
    // changes
    //
    bool          _onDeathRow;

    DWORD        _defaultColorKey;

    TargetDescriptor    _targetDescriptor;

    DirectDrawImageDevice *_currentImageDev;
    DynamicHeap &_heapIWasCreatedOn;

    // -- commonly used vars that used to be globals --
    HRESULT _ddrval;
    DDBLTFX _bltFx;
};


//
// Helper classes
//
struct  ClipperReturner {
    ClipperReturner(DDSurface *surf,
                    LPDIRECTDRAWCLIPPER clip,
                    DirectDrawViewport &vp) :
    _surf(surf),
    _clip(clip),
    _vp(vp)
    {}

    ~ClipperReturner() {
        if (_clip && _surf) {
            if( _vp._targetPackage._composeToTarget ) {
                _vp.SetCliplistOnSurface(_surf->IDDSurface(), &_clip, NULL);
            }
        }
    }

    DDSurface *_surf;
    LPDIRECTDRAWCLIPPER _clip;
    DirectDrawViewport &_vp;
};



#endif /* _VIEWPORT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\xform2i.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation class for 2D transforms

*******************************************************************************/


#ifndef _XFORM2I_H
#define _XFORM2I_H

#include "appelles/xform2.h"
#include "appelles/common.h"
#include "privinc/storeobj.h"
#include "privinc/vec2i.h"
#include <dxtrans.h>

// Currently, this is just a dummy version of what will eventuall go
// here. 
class ATL_NO_VTABLE Transform2 : public AxAValueObj {
  public:
    enum Xform2Type {
        Identity,
        Translation,
        Scale,
        Shear,
        Rotation,
        TwoByTwo,
        Full
        };

#if _USE_PRINT
    virtual ostream& Print(ostream& os) = 0;
#endif
    virtual Xform2Type Type() = 0;
    
    // Fill m with all the matrix entries
    virtual void GetMatrix(Real m[6]) = 0;

    // Return a copy that's been allocated on the heap that's current
    // when this is called.
    virtual Transform2 *Copy() = 0;

    virtual DXMTypeInfo GetTypeInfo() { return Transform2Type; }

    virtual bool SwitchToNumbers(Xform2Type typeOfNewNumbers,
                                 Real      *numbers);
};

Point2 TransformPoint2(Transform2 *a, const Point2& pt);
Point2Value *TransformPoint2Value(Transform2 *a, Point2Value *pt);
Vector2 TransformVector2(Transform2 *xf, const Vector2& v);
Vector2Value *TransformVector2Value(Transform2 *a, Vector2Value *v);

Transform2 *ScaleRR(Real x, Real y);
Transform2 *Rotate2Radians(Real angle);
Transform2 *TranslateRR(Real tx, Real ty);
Transform2 *TranslateRRWithMode(Real tx, Real ty, bool pixelMode);
Transform2 *RotateRealR(Real angle);
Transform2 *XShear2R (Real xAmt);
Transform2 *YShear2R (Real yAmt);

Transform2 *FullXform(Real a00, Real a01, Real a02,
                      Real a10, Real a11, Real a12);


void 
TransformDXPoint2ArrayToGDISpace(Transform2 *a,
                               DXFPOINT *srcPts, 
                               POINT *gdiPts,
                               int numPts,
                               int width,
                               int height,
                               Real resolution);

void 
TransformPoint2ArrayToGDISpace(Transform2 *a,
                               Point2 *srcPts, 
                               POINT *gdiPts,
                               int numPts,
                               int width,
                               int height,
                               Real resolution);


#endif /* _XFORM2I_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\util.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Miscellaneous utility functions header
*******************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "privinc/mutex.h"

// 
#ifndef _IA64_
BOOL IsWow64();
#endif

// Conversion
RawString CopyWideString(WideString bstr);
WideString CopyRawString(RawString bstr);

// ANSI Copy functions

inline char * CopyString(const char *str) {
    char *newstr = NEW char [str?(lstrlen(str) + 1):1] ;
    if (newstr) lstrcpyA (newstr,str?str:"") ;
    return newstr ;
}

inline char * CopyStringFromStore(char *str, DynamicHeap & heap) {
#if _DEBUGMEM
    int size = (str?(lstrlen(str)+1):1) * sizeof(char);
    char *newstr = (char *)heap.Allocate(size, __FILE__, __LINE__);
#else
    char *newstr =
        (char *) heap.Allocate ((str?(lstrlen(str)+1):1)*sizeof(char))  ;
#endif // _DEBUGMEM
    lstrcpyA (newstr,str?str:"") ;
    return newstr ;
}

inline char * CopyStringFromStore(char *str) {
    return CopyStringFromStore(str,GetHeapOnTopOfStack()) ;
}

inline void FreeStringFromStore(char *str, DynamicHeap & heap) {
    if (str) heap.Deallocate (str) ;
}

inline void FreeStringFromStore(char *str) {
    FreeStringFromStore(str,GetHeapOnTopOfStack()) ;
}


// Unicode copy functions

inline WCHAR * CopyString(const WCHAR *str) {
    WCHAR *newstr = NEW WCHAR [str?(lstrlenW(str) + 1):1] ;
    if (newstr) StrCpyW (newstr,str?str:L"") ;
    return newstr ;
}

inline WCHAR * CopyStringFromStore(WCHAR *str, DynamicHeap & heap) {
#if _DEBUGMEM
    int size = (str?(lstrlenW(str)+1):1) * sizeof(WCHAR);
    WCHAR *newstr = (WCHAR *)heap.Allocate(size, __FILE__, __LINE__);
#else
    WCHAR *newstr =
        (WCHAR *) heap.Allocate ((str?(lstrlenW(str)+1):1)*sizeof(WCHAR))  ;
#endif // _DEBUGMEM
    StrCpyW (newstr,str?str:L"") ;
    return newstr ;
}

inline WCHAR * CopyStringFromStore(WCHAR *str) {
    return CopyStringFromStore(str,GetHeapOnTopOfStack()) ;
}

inline void FreeStringFromStore(WCHAR *str, DynamicHeap & heap) {
    if (str) heap.Deallocate (str) ;
}

inline void FreeStringFromStore(WCHAR *str) {
    FreeStringFromStore(str,GetHeapOnTopOfStack()) ;
}


    /***  Assorted Utility Functions  ***/

inline bool IsOdd (LONG n)
{
    return (n & 1);
}

bool MMX_Able (void);     // Report support for MMX instructions.

    // Return the smallest power of two that is >= number.

int CeilingPowerOf2 (int number);

#define fsaturate(min,max,n) clamp(double(n),double(min),double(max))
#define  saturate(min,max,n) clamp(long(n),long(min),long(max))

bool isNear(double value, double test, double epsilon);

bool IntersectHorzRightRay(Point2Value *rayToRight, Point2Value *a, Point2Value *b);

double GetCurrTime (void);
int operator== (RECT&, RECT&);

    // These functions decrement or increment the mantissa of the floating
    // point number.  Note that this works only for IEEE floats.  Underflow
    // and overflow are properly handled by adjusting the exponent accordingly.

float MantissaDecrement (float n, int decrement);
float MantissaIncrement (float n, int increment);

    // Generic Linear Interpolator

template <class element>
    inline element Lerp (element A, element B, double t)
    {
        return A + (B-A)*t;
    }

    // Cyclic-Redundancy Code (CRC32) generator.  This function calculates a
    // new or running CRC on the given code block.  If called on a new block,
    // use the default CRC parameter value.  If iterating toward a final CRC,
    // supply the intermediate value on subsequent calls.

unsigned int crc32 (void *buffer, size_t length, unsigned int curr_crc = 0);


DWORD GetPerfTickCount();
extern DWORD perfFrequency;

#if PERFORMANCE_REPORTING

    class PerformanceTimer {
      public:
        PerformanceTimer();
        void Start();
        HRESULT Stop (HRESULT result=0);
        void Reset();
        double GetTime();
        DWORD Ticks();

      protected:
        DWORD     _totalTicks;
        DWORD     _localStart;
        DWORD     _threadStartedOn;
        CritSect  _criticalSection;

        bool _isStarted;
    };

    // Start timer on entrance to scope, stop upon leaving scope.
    class PerformanceTimerScope {
      public:
        PerformanceTimerScope(PerformanceTimer &timer) : _timer(timer) {
            _timer.Start();
        }

        ~PerformanceTimerScope() {
            _timer.Stop();
        }

      protected:
        PerformanceTimer &_timer;
    };

    class GlobalTimers
    {
      public:
        // Global timers

        // Load time timers
        PerformanceTimer audioLoadTimer;
        PerformanceTimer imageLoadTimer;
        PerformanceTimer geometryLoadTimer;
        PerformanceTimer downloadTimer;
        PerformanceTimer importblockingTimer;

        // DirectX Rendering timers
        PerformanceTimer ddrawTimer;
        PerformanceTimer d3dTimer;
        PerformanceTimer dsoundTimer;
        PerformanceTimer gdiTimer;
        PerformanceTimer alphaTimer;
        PerformanceTimer dxxformTimer;
        PerformanceTimer dx2dTimer;
        PerformanceTimer customTimer;
    };
 
    extern void PerfPrintLine(char *format=NULL, ...);

    #define PERFPRINTF(x) PerfPrintf x
    #define PERFPRINTLINE(x) PerfPrintLine x

    #define TIME_SUBSYS(timer,statement) \
    (   GetCurrentTimers().timer.Start(),\
        GetCurrentTimers().timer.Stop(statement)\
    )

    #define TIME_DDRAW(statement)  TIME_SUBSYS(ddrawTimer, statement)
    #define TIME_D3D(statement)    TIME_SUBSYS(d3dTimer,   statement)
    #define TIME_DSOUND(statement) TIME_SUBSYS(dsoundTimer,statement)
    #define TIME_DXXFORM(statement) TIME_SUBSYS(dxxformTimer,statement)
    #define TIME_DX2D(statement) TIME_SUBSYS(dx2dTimer,statement)
    #define TIME_CUSTOM(statement) TIME_SUBSYS(customTimer,statement)

    #define  TIME_GDI(statement) \
    do { \
        PerformanceTimerScope __ptc(GetCurrentTimers().gdiTimer); \
        statement;                     \
    } while(0)

    #define  TIME_ALPHA(statement) \
    do { \
        PerformanceTimerScope __ptc(GetCurrentTimers().alphaTimer); \
        statement;                     \
    } while(0)
    
#else

    #define PERFPRINTF(x)
    #define PERFPRINTLINE(x)

    #define  TIME_DDRAW(statement)  statement
    #define  TIME_D3D(statement)    statement
    #define  TIME_DSOUND(statement) statement
    #define  TIME_GDI(statement)    statement
    #define  TIME_ALPHA(statement)  statement
    #define  TIME_DXXFORM(statement) statement
    #define  TIME_DX2D(statement) statement
    #define  TIME_CUSTOM(statement) statement

#endif  // PERFORMANCE_REPORTING

inline double Tick2Sec(DWORD tick)
{ return ((double) tick) / (double) perfFrequency; }

extern void PerfPrintf(char *format, ...);

void CatchWin32Faults (BOOL b) ;

class CatchWin32FaultCleanup
{
  public:
    CatchWin32FaultCleanup () {
        CatchWin32Faults (TRUE) ;
    }
    ~CatchWin32FaultCleanup () {
        CatchWin32Faults (FALSE) ;
    }
} ;

// Pixel stuff
extern double pixelConst;
extern double meterConst;

inline double PixelToNum(double d) {
    Assert (pixelConst != 0.0);
    return d * pixelConst;
}

inline double PixelYToNum(double d) {
    Assert (pixelConst != 0.0);
    return -d * pixelConst;
}

inline double NumToPixel(double d) {
    Assert (meterConst != 0.0);
    return d * meterConst;
}

inline double NumToPixelY(double d) {
    Assert (meterConst != 0.0);
    return -d * meterConst;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\vec3i.h ===
#ifndef _VEC3I_H
#define _VEC3I_H

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 ) 

/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    This header file contains the implementation of 3D geometric elements
    (points, vectors, rays, and planes), plus the operations on and between
    these elements.

*******************************************************************************/

#include "d3dtypes.h"
#include "appelles/vec2.h"
#include "privinc/storeobj.h"
#include "privinc/vecutil.h"


typedef enum _ClipCode {
    CLIPCODE_OUT = -1,
    CLIPCODE_STRADDLE = 0,
    CLIPCODE_IN = 1
} ClipCode;


#if 0
--------
    After reading Meyer's "More Effective C++", there are several things we
    should do with our math object classes when appopropriate.

    First of all, we should implement operator+=, operator-=, operator*= and so
    forth where appropriate (they should take const objects).

    We should implement operator+ (for example) like this:

        inline const Vector3 operator+ (const Vector3 A, const Vector3 B)
        {   return Vector3(A) += B;
        }

    This will enable the compiler to do the return value optimization (for
    unnamed temporary objects).

    This should also apply to mixed operations (e.g. Point3 + Vector3).
--------
#endif

class Vector3Value : public AxAValueObj
{
  public:

    Real x, y, z;

#if _USE_PRINT
    ostream& Print(ostream& os) {
      return os << "Vector3Value(" << x << "," << y << "," << z << ")";
    }
#endif

    Vector3Value (void) {}
    Vector3Value (Real r0, Real r1, Real r2) : x(r0), y(r1), z(r2) {}
    Vector3Value (ApuVector3 &V) : x(V.xyz[0]), y(V.xyz[1]), z(V.xyz[2]) {}
    Vector3Value (D3DVECTOR &V) : x(V.x), y(V.y), z(V.z) {}

    void Set (Real Vx, Real Vy, Real Vz) { x=Vx; y=Vy; z=Vz; }

    bool operator== (Vector3Value &other);

    inline bool operator!= (Vector3Value &other)  { return !(*this==other); }

    Vector3Value& operator*= (Real);

    inline Vector3Value& operator/= (Real s)  { return *this *= (1/s); }

    Real LengthSquared();

    inline Real Length()  { return sqrt (LengthSquared()); }

    Vector3Value& Normalize();

    void Transform (Transform3 *xf);

    inline Vector3Value& operator*= (Transform3 &xf)
    {   Transform(&xf);
        return *this;
    }

    virtual DXMTypeInfo GetTypeInfo() { return Vector3ValueType; }
};


class Vector3WithCreationSource : public Vector3Value
{
  public:
    bool _createdInPixelMode;
};


    // Vector Operations

void    Cross        (Vector3Value &result, Vector3Value &A, Vector3Value &B);
Vector3Value Cross        (Vector3Value&, Vector3Value&);
Real    Dot          (Vector3Value&, Vector3Value&);
Real    AngleBetween (Vector3Value&, Vector3Value&);

Vector3Value operator+ (Vector3Value&, Vector3Value&);
Vector3Value operator- (Vector3Value&, Vector3Value&);
Vector3Value operator- (Vector3Value&);
Vector3Value operator* (Real, Vector3Value&);
Vector3Value operator* (Transform3&, Vector3Value&);

Vector3Value *XyzVector3RRR (Real x, Real y, Real z);
Vector3Value *SphericalVector3RRR (Real azimuth,Real elevation,Real radius);
Vector3Value *ScaleRealVector3R (Real scalar, Vector3Value *V);
Vector3Value *DivideVector3RealR (Vector3Value *V, Real scalar);

inline Vector3Value operator* (Vector3Value &V, Real s)  { return s * V; }
inline Vector3Value operator/ (Vector3Value &V, Real d)  { return (1/d) * V; }

class Plane3;

class Point3Value : public AxAValueObj
{
  public:

    Real x, y, z;

#if _USE_PRINT
    ostream& Print(ostream& os) {
      return os << "Point3Value(" << x << "," << y << "," << z << ")";
    }
#endif
    
    Point3Value (void) {}
    Point3Value (Real r0, Real r1, Real r2) : x(r0), y(r1), z(r2) {}
    Point3Value (D3DVECTOR &V) : x(V.x), y(V.y), z(V.z) {}

    void Set (Real Px, Real Py, Real Pz) { x=Px; y=Py; z=Pz; }

    bool operator== (Point3Value &other);     // Compare This Point With Another
    inline bool operator!= (Point3Value &other) { return !(*this==other); }

    Point3Value& operator+= (Vector3Value&);
    Point3Value& operator-= (Vector3Value&);

    void Transform (Transform3 *xf);    // Transforms This Point

    inline Point3Value& operator*= (Transform3 &xf)
    {   Transform(&xf);
        return *this;
    }

    ClipCode Clip(Plane3 &plane);

    virtual DXMTypeInfo GetTypeInfo() { return Point3ValueType; }
};

class Point3WithCreationSource : public Point3Value
{
  public:
    bool _createdInPixelMode;
};


    // Point Operators

Point3Value *XyzPoint3RRR (Real x, Real y, Real z);
Point3Value *SphericalPoint3RRR (Real azimuth,Real elevation,Real radius);
Real DistanceSquared (Point3Value&, Point3Value&);
Real RDistancePoint3Point3 (Point3Value *P, Point3Value *Q);

inline Real Distance (Point3Value &P, Point3Value &Q)
    { return sqrt (DistanceSquared (P,Q)); }


    // Point-Vector Operators

Vector3Value operator- (Point3Value&, Point3Value&);
Point3Value  operator+ (Point3Value&, Vector3Value&);
Point3Value  operator- (Point3Value&, Vector3Value&);
Point3Value  operator* (Transform3&, Point3Value&);

inline Point3Value operator+ (Vector3Value &V, Point3Value &P)  { return P + V; }

inline Vector3Value* AsVector (Point3Value  &P) { return NEW Vector3Value (P.x, P.y, P.z); }
inline Point3Value*  AsPoint  (Vector3Value &V) { return NEW Point3Value (V.x, V.y, V.z); }



class Ray3 : public AxAValueObj
{
  public:

#if _USE_PRINT
    ostream& Print(ostream& os) {
      return os << "Ray3(" << orig << "," << dir << ")";
    }
#endif
    
    Ray3 (Point3Value &origin, Vector3Value &direction)
        : orig(origin), dir(direction) {}

    // Query Functions

    Point3Value  &Origin (void)     { return orig; }
    Vector3Value &Direction (void)  { return dir; }

    void Transform (Transform3*);

    // Evaluate the ray given a real-valued parameter.

    Point3Value Evaluate (Real t);

    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }

  private:

    Point3Value  orig;    // Ray Origin
    Vector3Value dir;     // Ray Direction
};



// The Plane3 class describes a plane of normal N, plane constant d.
// The implicit equation for the plane is Ax + By + Cz + d = 0.

class Plane3 : public AxAValueObj
{
  public:

#if _USE_PRINT
    ostream& Print(ostream& os) {
      return os << "Plane3(" << N << "," << d << ")";
    }
#endif
    
    Vector3Value N;   // Plane Normal
    Real    d;   // Plane Constant

    Plane3 (void) : N(0,0,1), d(0) {}
    Plane3 (Real A, Real B, Real C, Real D) : N(A,B,C), d(D) {}
    Plane3 (Real P[4]) : N(P[0],P[1],P[2]), d(P[3]) {}
    Plane3 (Vector3Value &V, Real D) : N(V), d(D) {}

    Plane3 (Vector3Value &V, Point3Value &P) : N(V), d(-Dot(V,*AsVector(P))) {}

    Plane3& operator*= (Transform3*);

    Plane3& Normalize (void);

    Vector3Value Normal (void);    // Return Plane Normal Vector
    Point3Value  Point (void);     // Return Point on Plane
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }
};

    // Plane Functions

        // This function returns the signed distance from the plane to the
        // given point.  If the sign is positive, then the point lies on the
        // same side of the plane as the plane normal.  If the distance is
        // zero, the point lies on the plane.

Real Distance (Plane3&, Point3Value&);

inline Plane3 operator* (Transform3 *T, Plane3 &plane)
{   return Plane3(plane) *= T;
}

        // Returns the ray parameter for the intersection between the ray and
        // the plane (infinity if the ray is parallel to the plane).

Real Intersect (Ray3 &ray, Plane3 &plane);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\vec2i.h ===
#ifndef _VEC2I_H
#define _VEC2I_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Private implementation of 2D vectors and points

*******************************************************************************/


#include "appelles/common.h"
#include "privinc/storeobj.h"
#include "appelles/vec2.h"

// Vector2
//
// Class that implements a simple 2-element geometric vector
//

class Vector2
{

public:

    Real x, y;

    Vector2(void) {}
    Vector2(const Real _x, const Real _y) : x(_x), y(_y) {}
    
    inline void Set(const Real _x, const Real _y) 
    {
        x = _x;
        y = _y;
    }

    inline const bool operator==(const Vector2 &other) const 
    {
        return ((x == other.x) && (y == other.y));
    }

    inline Vector2& operator+=(const Vector2 &addend) 
    {
        x += addend.x;
        y += addend.y;

        return *this;
    }

    inline Vector2& operator-=(const Vector2 &subtrahend) 
    {
        x -= subtrahend.x;
        y -= subtrahend.y;

        return *this;
    }

    inline Vector2& operator*=(const Real scale) 
    {
        x *= scale;
        y *= scale;

        return *this;
    }

    inline Vector2& operator/=(const Real divisor) 
    {
        Real reciprocal = 1.0 / divisor;
        x *= reciprocal;
        y *= reciprocal;

        return *this;
    }

    inline const Real LengthSquared(void) const 
    {
        return (x * x + y * y);
    }

    inline const Real Length(void) const 
    {
        return sqrt(LengthSquared());
    }

    inline Vector2& Normalize(void) 
    {
        *this /= Length();

        return *this;
    }

#if _USE_PRINT
    inline ostream& Print(ostream& os) const {
        return os << "Vector2(" << x << "," << y << ")";
    }
#endif
};

inline const Vector2 operator-(const Vector2 &v)
{
    return Vector2(-v.x, -v.y);
}

inline const Vector2 operator+(const Vector2 &augend, const Vector2 &addend)
{
    return Vector2(augend.x + addend.x, augend.y + addend.y);
}

inline const Vector2 operator-(const Vector2 &minuend, const Vector2 &subtrahend)
{
    return Vector2(minuend.x - subtrahend.x, minuend.y - subtrahend.y);
}

inline const Vector2 operator*(const Vector2 &multiplicand, const Real multiplier)
{
    return Vector2(multiplicand.x * multiplier, multiplicand.y * multiplier);
}

inline const Vector2 operator*(const Real multiplier, const Vector2 &multiplicand)
{
    return Vector2(multiplicand.x * multiplier, multiplicand.y * multiplier);
}

inline const Vector2 operator/(const Vector2 &dividend, const Real divisor)
{
    return Vector2(dividend.x / divisor, dividend.y / divisor);
}

#if _USE_PRINT
inline ostream& operator<< (ostream& os, const Vector2& V)
{   return os << "<" << V.x << ", " << V.y << ">";
}
#endif

inline const Real Dot(const Vector2 &v1, const Vector2 &v2)
{   
    return (v1.x * v2.x) + (v1.y * v2.y);
}

inline const Real Cross(const Vector2 &v1, const Vector2 &v2)
{   
    return (v1.x * v2.y) - (v1.y * v2.x);
}

inline const Real AngleBetween(const Vector2 &v1, const Vector2 &v2)
{   
    return acos(Dot(v1,v2) / (v1.Length() * v2.Length()));
}


// Point2
//
// Class that implements a simple 2-element geometric point
//

class Point2
{

public:

    Real x, y;

    Point2(void) {}
    Point2(const Real _x, const Real _y) : x(_x), y(_y) {}
    
    inline void Set(const Real _x, const Real _y) 
    {
        x = _x;
        y = _y;
    }

    inline const bool operator==(const Point2 &other) const 
    {
        return ((x == other.x) && (y == other.y));
    }

    inline Point2& operator+=(const Vector2 &addend) 
    {
        x += addend.x;
        y += addend.y;

        return *this;
    }

    inline Point2& operator-=(const Vector2 &subtrahend) 
    {
        x -= subtrahend.x;
        y -= subtrahend.y;

        return *this;
    }

#if _USE_PRINT
    inline ostream& Print(ostream& os) const {
        return os << "Point2(" << x << "," << y << ")";
    }
#endif
};

inline const Point2 operator+(const Point2& augend, const Point2& addend)
{
    return Point2(augend.x + addend.x, augend.y + addend.y);
}

inline const Point2 operator+(const Point2& p, const Vector2& v)
{
    return Point2(p.x + v.x, p.y + v.y);
}

inline const Vector2 operator-(const Point2 &p1, const Point2 &p2)
{
    return Vector2(p1.x - p2.x, p1.y - p2.y);
}

inline const Point2 operator*(const Real multiplier, const Point2& multiplicand)
{
    return Point2(multiplicand.x * multiplier, multiplicand.y * multiplier);
}

inline const Point2 operator*(const Point2& multiplicand, const Real multiplier)
{
    return Point2(multiplicand.x * multiplier, multiplicand.y * multiplier);
}

#if _USE_PRINT
inline ostream& operator<< (ostream& os, const Point2& P)
{   return os << "<" << P.x << ", " << P.y << ">";
}
#endif

inline const Real DistanceSquared(const Point2 &p1, const Point2 &p2)
{
    Real dx = p2.x - p1.x,
         dy = p2.y - p1.y;

    return (dx * dx + dy * dy);
}

inline const Real Distance(const Point2 &p1, const Point2 &p2)
{
    return sqrt(DistanceSquared(p1,p2));
}



// Vector2Value
//
// Class that implements a 2-element geometric vector, as an AxAValue.
//

class Vector2Value : public AxAValueObj
{
  public:

    Real x, y;

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "Vector2Value(" << x << "," << y << ")";
    }
#endif
    
    Vector2Value (void) {}
    Vector2Value (Real _x, Real _y) : x(_x), y(_y) {}

    inline void Set (const Real Vx, const Real Vy) 
    {   x=Vx; y=Vy; 
    }

    inline const Real LengthSquared (void) const
    {   return x*x + y*y;
    }

    inline const Real Length (void) const
    {   return sqrt(LengthSquared()); 
    }

    inline Vector2Value& Normalize (void)
    {   return *this *= 1 / Length();
    }

    inline const bool operator== (const Vector2Value &other) const  // Test for Equality
    {   return (x == other.x) && (y == other.y);
    }

    inline Vector2Value& operator*= (const Real scalar)
    {   x *= scalar;
        y *= scalar;
        return *this;
    }

    inline Vector2Value& operator/= (const Real d)
    {   return *this *= (1/d); 
    }

    virtual DXMTypeInfo GetTypeInfo(void)
    {   return Vector2ValueType; 
    }
};

class Vector2WithCreationSource : public Vector2Value
{
  public:
    bool _createdInPixelMode;
};

class Point2Value : public AxAValueObj
{
  public:

    Real x, y;

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "Point2Value(" << x << "," << y << ")";
    }
#endif
    
    Point2Value (void) {}
    Point2Value (const Real _x, const Real _y) : x(_x), y(_y) {}

    void Set (const Real Px, const Real Py) 
    {   x=Px; y=Py; 
    }

    inline const bool operator== (const Point2Value &other) const      // Test for Equality
    {   return (x == other.x) && (y == other.y);
    }

    inline Point2Value& operator-= (const Vector2Value& V)
    {   x -= V.x;
        y -= V.y;
        return *this;
    }

    inline Point2Value& operator+= (const Vector2Value& V)
    {   x += V.x;
        y += V.y;
        return *this;
    }

    virtual DXMTypeInfo GetTypeInfo(void) 
    {   return Point2ValueType; 
    }
};

class Point2WithCreationSource : public Point2Value
{
  public:
    bool _createdInPixelMode;
};


    // Vector Operators

inline const Vector2Value operator- (const Vector2Value &A, const Vector2Value &B)
{   return Vector2Value (A.x - B.x, A.y - B.y);
}

inline const Vector2Value operator+ (const Vector2Value &A, const Vector2Value &B)
{   return Vector2Value (A.x + B.x, A.y + B.y);
}

inline const Vector2Value operator- (const Vector2Value &V)
{   return Vector2Value (-V.x, -V.y);
}

inline const Vector2Value operator* (const Real s, const Vector2Value &V)
{   return Vector2Value (s * V.x, s * V.y);
}

inline const Vector2Value operator* (const Vector2Value &V, const Real s)  
{   return s * V; 
}

inline const Vector2Value operator/ (const Vector2Value &V, const Real d)  
{   return V * (1/d); 
}

inline const Real Dot (const Vector2Value &A, const Vector2Value &B)
{   return (A.x * B.x) + (A.y * B.y);
}

inline const Real AngleBetween (const Vector2Value &A, const Vector2Value &B)
{   return acos(Dot(A,B) / (A.Length() * B.Length()));
}

inline const Real Cross (const Vector2Value &A, const Vector2Value &B)
{   return (A.x * B.y) - (A.y * B.x);
}



    // Vector External Interfaces

Vector2Value *XyVector2RR(Real x, Real y);
Vector2Value *PolarVector2RR(Real angle, Real radius);
Real RDotVector2Vector2 (Vector2Value *A, Vector2Value *B);
Vector2Value *ScaleRealVector2R (Real scalar, Vector2Value *v);
Vector2Value *DivideVector2RealR(Vector2Value *v, Real scalar);


    // Point Operators

inline const Real DistanceSquared (const Point2Value& P, const Point2Value&Q)
{
    Real dx = P.x - Q.x,
         dy = P.y - Q.y;

    return (dx*dx) + (dy*dy);
}

inline const Real Distance (const Point2Value &A, const Point2Value &B)
{ 
    return sqrt (DistanceSquared (A,B)); 
}


    // Point External Interfaces

Point2Value *XyPoint2RR (Real x, Real y);
Point2Value *PolarPoint2RR (Real angle, Real radius);


    // Point-Vector Operators

inline const Vector2Value operator- (const Point2Value &P, const Point2Value &Q)
{   return Vector2Value (P.x - Q.x, P.y - Q.y);
}

inline const Point2Value operator+ (const Point2Value &P, const Vector2Value &V)
{   return Point2Value (P.x + V.x, P.y + V.y);
}

inline const Point2Value operator- (const Point2Value &P, const Vector2Value &V)
{   return Point2Value (P.x - V.x, P.y - V.y);
}

inline const Point2Value operator+ (const Vector2Value &V, const Point2Value &P)  
{   return P + V; 
}



    // Promotion and demotion

inline const Vector2 Demote(const Vector2Value& v)
{
    return Vector2(v.x, v.y);
}

inline Vector2Value* Promote(const Vector2& v)
{
    return NEW Vector2Value(v.x, v.y);
}

inline const Point2 Demote(const Point2Value& v)
{
    return Point2(v.x, v.y);
}

inline Point2Value* Promote(const Point2& v)
{
    return NEW Point2Value(v.x, v.y);
}


    // Constants

const Vector2 XVector2(1,0);
const Vector2 YVector2(0,1);
const Vector2 ZeroVector2(0,0);
const Point2 Origin2(0,0);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\xformi.h ===
#ifndef _AV_XFORMI_H
#define _AV_XFORMI_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Implementation of abstract perspective transformation class

*******************************************************************************/

#include "appelles/common.h"
#include "appelles/valued.h"
#include "privinc/matutil.h"
#include "privinc/xform2i.h"
#include "privinc/storeobj.h"


// Forward Declarations

class Point3;
class Vector3;



class ATL_NO_VTABLE Transform3 : public AxAValueObj
{
  public:

    // Returns a reference to a 4x4 matrix.  Note that this breaks the
    // abstraction of general spatial transformations - if it COULD be
    // expressed as a 4x4 matrix, then it WOULD be.  We need to rip this
    // method out in the future and implement a cleaner abstraction.

    virtual const Apu4x4Matrix& Matrix() = 0;

    virtual Transform3 *Inverse ();
    virtual Bool        IsSingular();

    // Make a copy on the heap that is current when this is called.
    Transform3         *Copy();

    virtual DXMTypeInfo GetTypeInfo() { return Transform3Type; }

    virtual bool SwitchToNumbers(Transform2::Xform2Type typeOfNewNumbers,
                                 Real                  *numbers);
#if _USE_PRINT
    ostream& Print (ostream &os);
#endif

};


    // Instantiate a Transform3 from a utility matrix

Transform3 *Apu4x4XformImpl (const Apu4x4Matrix &matrix);

Transform3 *Transform3Matrix16 (Real m00, Real m01, Real m02, Real m03,
                                Real m10, Real m11, Real m12, Real m13,
                                Real m20, Real m21, Real m22, Real m23,
                                Real m30, Real m31, Real m32, Real m33);

Transform3 *TranslatePoint3 (Point3Value *new_origin);
Transform3 *Translate (Real Tx, Real Ty, Real Tz);
Transform3 *TranslateWithMode (Real Tx, Real Ty, Real Tz, bool pixelMode);

Transform3 *Scale (Real, Real, Real);

Transform3 *RotateXyz (Real angle, Real x, Real y, Real z);

Transform3 *RotateX (Real angle);
Transform3 *RotateY (Real angle);
Transform3 *RotateZ (Real angle);

    // Construct a 3D transform from the desired origin and 3 basis vectors.

Transform3 *TransformBasis
                (Point3Value *origin, Vector3Value *Bx, Vector3Value *By, Vector3Value *Bz);

extern Transform3 *CopyTransform3(Transform3 *xf);

    // Rotation using a Quaternion

#ifdef QUATERNIONS_REMOVED_FOR_NOW
Transform3 *RotateQuaternion (Quaternion *q);
#endif QUATERNIONS_REMOVED_FOR_NOW

    // Displaced Transform3 *does (xform(center + x) - center)

Transform3 *DisplacedXform (Point3Value *center, Transform3 *xform);

    // RollPitchHeading() places the object at 'position', rotated 'heading'
    // radians in the XZ plane, pitched up by 'pitch' radians, and rolled
    // about the viewing axis by 'roll' radians.

Transform3 *RollPitchHeading
                (Real *roll, Real *pitch, Real *heading, Point3Value *position);

    // PolarOrient() assumes that the target is located at the origin (in
    // modeling coordinates).  The object is moved 'radius' units along +Z,
    // rotated about +Z by 'twist' radians, rotated about -X by 'elevation'
    // radians, and finally rotated about +Y by 'azimuth' radians.
    // Normally, radius is in (0,infinity), elevation is in [-pi/2,+pi/2],
    // azimuth is in [0,2pi], and twist is in [-pi,+pi].

Transform3 *PolarOrient
                (Real *radius, Real *elevation, Real *azimuth, Real *twist);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\axasrv.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _AXASRV_H
#define _AXASRV_H


#endif /* _AXASRV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\privinc\vecutil.h ===
#ifndef _VECUTIL_H
#define _VECUTIL_H


/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Points

--*/

#include <math.h>

#ifndef AP_RAD_TO_DEG
#define AP_RAD_TO_DEG(x) (x * 57.2957795130823)
#endif /* AP_RAD_TO_DEG */

#ifndef AP_DEG_TO_RAD
#define AP_DEG_TO_RAD(x) (x / 57.2957795130823)
#endif /* AP_DEG_TO_RAD */

struct ApuVector3
{
  Real xyz[3];

  Real X() const { return xyz[0]; }
  Real Y() const { return xyz[1]; }
  Real Z() const { return xyz[2]; }
  Real operator[] (int i) const { return xyz[i]; }
  Real& operator[] (int i) { return xyz[i]; }
  void SetX(Real newx) { xyz[0] = newx; }
  void SetY(Real newy) { xyz[1] = newy; }
  void SetZ(Real newz) { xyz[2] = newz; }
  void Set(Real newx, Real newy, Real newz)
    { xyz[0] = newx; xyz[1] = newy; xyz[2] = newz; }

  Real Length() const;
  Real LengthSquared() const;

  void Normalize();

  operator Real *() { return &xyz[0]; }
  operator const Real *() const { return &xyz[0]; }
  void operator+=(const ApuVector3& rhs);
  void operator-=(const ApuVector3& rhs);
  void operator*=(Real rhs);
  void operator/=(Real rhs);

  void Negate();
  void Zero();

};

extern ApuVector3 apuXAxis3;         // (1, 0, 0)
extern ApuVector3 apuYAxis3;         // (0, 1, 0)
extern ApuVector3 apuZAxis3;         // (0, 0, 1)
extern ApuVector3 apuZero3;          // (0, 0, 0)

struct ApuBbox3
{
  ApuVector3 min;
  ApuVector3 max;
  void augment(Real x, Real y, Real z);
  void center(ApuVector3& result) const;
};

/*
 * Negative volume bbox used for initialization
 */
extern ApuBbox3 apuNegativeBbox3;

/*
 * The volume [0,1] x [0,1] x [0,1]
 */
extern ApuBbox3 apuUnitCubeBbox3;

/*
 * The volume [-1,1] x [-1,1] x [-1,1]
 */
extern ApuBbox3 apuTwoUnitCubeBbox3;

/*
 * Test for equality, within tolerance of epsilon.  Uses per
 * coordinate test, not true distance.
 */
Bool ApuEpsEq(Real value1, Real value2, Real epsilon);

/*
 * Test for equality, within tolerance of epsilon.  Uses per
 * coordinate test, not true distance.
 */
Bool ApuEpsEq(const ApuVector3& v1, const ApuVector3& v2,
                Real epsilon);

Real ApuDot(const ApuVector3& v1, const ApuVector3& v2);
Real ApuDistance(const ApuVector3& v1, const ApuVector3& v2);
Real ApuDistanceSquared(const ApuVector3& v1, const ApuVector3& v2);
void ApuCross(const ApuVector3& v1, const ApuVector3& v2, ApuVector3& result);

#endif /* _VECUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\retained\rmsound\sndbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation for retained mode sound

*******************************************************************************/

#include <headers.h>
#include "appelles/sound.h"
#include "appelles/axaprims.h"
#include "privinc/soundi.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "backend/values.h"
#include "backend/sprite.h"
#include "privinc/bufferl.h"  // bufferList stuff
#include "privinc/helps.h"    // class Pan
#include "privinc/util.h"     // TimeTransform

extern Sound *ApplyGain(AxANumber *g, Sound *s);
extern Sound *ApplyPan(AxANumber *g, Sound *s);
extern Sound *ApplyLooping(Sound *s);


SoundSprite::SoundSprite(Sound* snd, MetaSoundDevice *metaDev, 
    Time t0, bool loop) : _snd(snd), _t0(t0), _gain(1.0),
                          _rate(1.0), _loop(loop) 
{
     // Create the sound buffer etc

    _pan = 0.0;

// #define REIMPLEMENT
#ifdef REIMPLEMENT
        // Initialy we are only implementing and assuming static sounds
        // soon we will subclass...
    // Hmm.  Wonder how much could be accomplished by calling the 
    //       LeafSound::Render* methods?

    // does the master buffer exist yet?
    StaticBufferList *staticBufferList = SAFE_CAST(StaticBufferList *,
        metaDev->_bufferListList->GetBufferList(_snd));
//#else // maybe we can call existing code????


    // well, I think we will only get leafSounds...  maybe we should take this
    // as a param instead??
    LeafSound *leafSound = SAFE_CAST(LeafSound *, _snd);
    leafSound->RenderNewBuffer(metaDev);
#endif


}


void 
SoundSprite::UpdateAttributes(double time, double gain, double pan,
    double rate) 
{
        // TODO: lock?
        _gain = gain;
        _pan  = pan;
        _rate = rate;
}


// XXX only wrote this because:
//     std::copy(source.begin(), source.end(), destination->begin());
// results in a bogus destination!
void CopyList(list<Perf>&source, list<Perf>&destination)
{
    list<Perf>::iterator index;
    for(index = source.begin(); index!=source.end(); index++)
        destination.push_back(*index);

}

#ifdef NEW_RRR
double calculateRate(TimeXform timeTransform, double time1, double time2)
{
    double localTime1 = TimeTransform(timeTransform, time1);
    double localTime2 = TimeTransform(timeTransform, time2);
    double rate = (localTime2 - localTime1) / (time2 - time1);
    return rate;
}
#endif


class SndSpriteCtx : public SpriteCtx {
  public:
    SndSpriteCtx(MetaSoundDevice *metaDev) : _metaDev(metaDev), _loop(false) {}

    virtual void Reset() {
        _loop = false;

        // Should be empty, guard against exception.
        _pan.erase(_pan.begin(), _pan.end());
        _gain.erase(_gain.begin(), _gain.end());
    }

    // TODO: share
    virtual Bvr GetEmptyBvr() { return ConstBvr(silence); }
    
    void PushGain(Perf gain) { _gain.push_back(gain); }
    void PopGain() { _gain.pop_back(); }

    void PushPan(Perf pan) { _pan.push_back(pan); }
    void PopPan() { _pan.pop_back(); }

    list<Perf>* CopyPanList() {
        list<Perf>* c = NEW list<Perf>;
        CopyList(_pan, *c);
        Assert(_pan.size() == c->size());
        return c;
    }

    list<Perf>* CopyGainList() {
        list<Perf>* c = NEW list<Perf>;
        CopyList(_gain, *c);
        Assert(_gain.size() == c->size());
        return c;
    }

    bool IsLooping() { return _loop; }
    void SetLooping(bool b) { _loop = b; }
    MetaSoundDevice *_metaDev;  // XXX make an accessor?

  private:
    list<Perf>       _pan;
    list<Perf>       _gain;
    bool             _loop;
};


// Need to set up buffer at some point
class RMSoundImpl : public RMImpl {
  public:
    RMSoundImpl(list<Perf>* pan, list<Perf>* gain,
                SoundSprite* s, TimeXform tt)
    : RMImpl(s), _pan(pan), _gain(gain), _sprite(s), _tt(tt) {}

    virtual ~RMSoundImpl() {
        delete _pan;
        delete _gain;
        //delete _sprite;
    }
    

    // XXX all of the accumulation code has to be re-addressed to handle dB...
    virtual void _Sample(Param& param) {
        list<Perf>::iterator i;
        
        double gain = 1.0; // nominal gain
        double  pan = 0.0; // center pan?
        double rate = 1.0; // nominal rate

        for (i=_gain->begin(); i!=_gain->end(); i++)
            gain += ValNumber((*i)->Sample(param));
        
        for (i=_pan->begin(); i!=_pan->end(); i++)
            pan += ValNumber((*i)->Sample(param));

        // XXX calculate the rate and phase!
        // TODO: Enable when we get back to Spritify
#if 0   
        if (_tt != NULL) {
            //localTime1 = (*_tt)(param);
            double time1 = param._time;
            double localTime1 = EvalLocalTime(_tt, time1);
            double epsilon = 0.01; // XXX for now...
            double time2 = time1 + epsilon;
            double localTime2 = EvalLocalTime(_tt, time2);

            _lastLocalTime = localTime1;
            rate = (localTime2 - localTime1) / (time2 - time1);
        }
#endif  

        _lastSampleTime = param._time;
        _sprite->UpdateAttributes(param._time, gain, pan, rate);

    } 

    virtual void DoKids(GCFuncObj proc) {
        list<Perf>::iterator i;

        for (i=_pan->begin(); i!=_pan->end(); i++)
            (*proc)(*i);
        
        for (i=_gain->begin(); i!=_gain->end(); i++)
            (*proc)(*i);
        
        (*proc)(_tt);

        RMImpl::DoKids(proc);
    }

  private:
    list<Perf>  *_pan;
    list<Perf>  *_gain;
    SoundSprite *_sprite;
    TimeXform    _tt;
};


#ifdef NEW_rrr
void
RMSoundImpl::_Sample(Param& param) 
{
    // XXX all of the accumulation code has to be re-addressed to handle dB...
    list<Perf>::iterator i;
    
    double gain = 1.0; // nominal gain
    double  pan = 0.0; // center pan?
    double rateRate = 0.0; // nominal rate change

    for (i=_gain->begin(); i!=_gain->end(); i++)
        gain += ValNumber((*i)->Sample(param));
    
    for (i=_pan->begin(); i!=_pan->end(); i++)
        pan += ValNumber((*i)->Sample(param));

    // XXX calculate the rate and phase!
    if (!_tt->IsShiftXform()) {
        double epsilon = 0.01; // XXX for now...
                       // but it should eventualy be similar to frame rate
        double time1 = param._time;
        double time2 = time1 + epsilon;
        double time3 = param._time + 0.1;
        double time4 = time3 + epsilon;


        //_lastLocalTime = localTime1;


        double rate1 = calculateRate(_tt, time1, time2);
        double rate2 = calculateRate(_tt, time3, time4);

        // XXX this should really be calculated based on current rate!
        //     maybe I should send the spriteEngine 2 known rates and
        //     let it decide how to get there?
        rateRate = (rate2-rate1)/(time3-time1);
    }

    _lastSampleTime = param._time;
    _sprite->UpdateAttributes(param._time, gain, pan, rateRate);
}
#endif

// TODO: Code factoring
class GainBvrImpl : public BvrImpl {
  public:
    GainBvrImpl(Bvr gain, Bvr snd) : _gain(gain), _snd(snd) {
        // For backward compatibility, TODO: share
        Sound *(*fp)(AxANumber *, Sound *) = ApplyGain;
        _gainBvr = PrimApplyBvr(ValPrimOp(fp, 2, "Gain", SoundType),
                                2, _gain, _snd);
    }
    
    virtual Perf _Perform(PerfParam& p)
    { return ::Perform(_gainBvr, p); }

    virtual RMImpl *Spritify(PerfParam& pp,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        SndSpriteCtx* sCtx = SAFE_CAST(SndSpriteCtx *, ctx);

        sCtx->PushGain(::Perform(_gain, pp));
        RMImpl *p = _snd->Spritify(pp, ctx, sNodeOut);
        sCtx->PopGain();
        return p;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_gain);
        (*proc)(_snd);
        (*proc)(_gainBvr);
    }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType; }
    
    virtual Bvr EndEvent(Bvr b) {
        return _snd->EndEvent(b);
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _gainBvr; }
#endif
    
  private:
    Bvr _gain, _snd, _gainBvr;
};


Bvr ApplyGain(Bvr pan, Bvr snd)
{ return NEW GainBvrImpl(pan, snd); }


class PanBvrImpl : public BvrImpl {
  public:
    PanBvrImpl(Bvr pan, Bvr snd) : _pan(pan), _snd(snd) {
        // For backward compatibility
        Sound *(*fp)(AxANumber *, Sound *) = ApplyPan;
        _panBvr = PrimApplyBvr(ValPrimOp(fp, 2, "Pan",
                                         SoundType)
                               , 2, _pan, _snd);
    }
    
    virtual Perf _Perform(PerfParam& p) 
    { return ::Perform(_panBvr, p); }

    virtual RMImpl *Spritify(PerfParam& pp,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        SndSpriteCtx* sCtx = SAFE_CAST(SndSpriteCtx *, ctx);

        sCtx->PushPan(::Perform(_pan, pp));
        RMImpl *p = _snd->Spritify(pp, ctx, sNodeOut);
        sCtx->PopPan();
        return p;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_pan);
        (*proc)(_snd);
        (*proc)(_panBvr);
    }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType; }
    
    virtual Bvr EndEvent(Bvr b) {
        return _snd->EndEvent(b);
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _panBvr; }
#endif
    
  private:
    Bvr _pan, _snd, _panBvr;
};


Bvr ApplyPan(Bvr pan, Bvr snd)
{ return NEW PanBvrImpl(pan, snd); }

class MixBvrImpl : public BvrImpl {
  public:
    MixBvrImpl(Bvr left, Bvr right) : _left(left), _right(right) {
        // For backward compatibility
        Sound *(*fp)(Sound *, Sound *) = Mix;
        _mix = PrimApplyBvr(ValPrimOp(fp, 2, "Mix", SoundType),
                                      2,
                                      _left, _right);
    }
    
    virtual Perf _Perform(PerfParam& p)
    { return ::Perform(_mix, p); }

    virtual RMImpl *Spritify(PerfParam& p,
                             SpriteCtx* ctx,
                             SpriteNode** s) {
        SndSpriteCtx* sCtx = SAFE_CAST(SndSpriteCtx *, ctx);

        SpriteNode *right;
        
        RMImpl *lsnd = _left->Spritify(p, ctx, s);

        lsnd->Splice(_right->Spritify(p, ctx, &right));

        (*s)->Splice(right);

        return lsnd;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_left);
        (*proc)(_right);
        (*proc)(_mix);
    }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType; }
    
    virtual Bvr EndEvent(Bvr b) {
        return _mix->EndEvent(b);
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _mix; }
#endif
    
  private:
    Bvr _left, _right, _mix;
};


Bvr SoundMix(Bvr sndLeft, Bvr sndRight)
{ return NEW MixBvrImpl(sndLeft, sndRight); }


class SoundLoopBvrImpl : public BvrImpl {
  public:
    SoundLoopBvrImpl(Bvr snd) : _snd(snd) {
        Sound *(*fp)(Sound*) = ApplyLooping;
        // For backward compatibility
        _loopBvr = PrimApplyBvr(ValPrimOp(fp, 1, "ApplyLooping",
                                          SoundType),
                                1, _snd);
    }

    virtual Perf _Perform(PerfParam& pp)
    { return ::Perform(_loopBvr, pp); }

    virtual RMImpl *Spritify(PerfParam& pp,
                             SpriteCtx* ctx,
                             SpriteNode** sNodeOut) {
        SndSpriteCtx* sCtx = SAFE_CAST(SndSpriteCtx *, ctx);

        bool oloop = sCtx->IsLooping();
        sCtx->SetLooping(true);
        RMImpl *p = _snd->Spritify(pp, ctx, sNodeOut);
        sCtx->SetLooping(oloop);
        return p;
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_snd);
        (*proc)(_loopBvr);
    }

    virtual DXMTypeInfo GetTypeInfo () { return SoundType; }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << _loopBvr; }
#endif
    
  private:
    Bvr _loopBvr, _snd;
};


Bvr ApplyLooping(Bvr snd)
{ return NEW SoundLoopBvrImpl(snd); }


SpriteCtx *NewSoundCtx(MetaSoundDevice *metaDev)
{ return NEW SndSpriteCtx(metaDev); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\rsrc\makefile.inc ===
danim.rc : $(SDKDIR)\danim.tlb \
              dxactrl.rgs \
              dxactrl.bmp \
              dxactrlw.rgs \
              dxactrlw.bmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\retained\rmsound\spritethread.cpp ===
/*******************************************************************************

Copyright (c) 1997 Microsoft Corporation

Abstract:

    Class which manages the sprite thread.

*******************************************************************************/

#include "headers.h"
#include "privinc/mutex.h"
#include "privinc/debug.h"          // tracetags
#include "privinc/bufferl.h"        // BufferElement, et. al.
#include "privinc/spriteThread.h"
#include "backend/sprite.h"         // RMImpl (lets put it somewhere better!)
#include "privinc/helps.h"          // linearTodB
#include "privinc/htimer.h"         // HiresTimer

// this is the fn() which is the embodiment of the sprite thread
LPTHREAD_START_ROUTINE renderSprites(void *ptr)
{
    SpriteThread *spriteThread = (SpriteThread *)ptr;
    MetaSoundDevice *metaDev = spriteThread->_metaDev;

    CoInitialize(NULL); // needed on each thread to be able to
                        // cocreate...

#ifdef LATER

    HiresTimer&  timer = CreateHiresTimer();

    // make this a hi-priority thread
    BOOL status =
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    // XXX should be able to block on a semiphore if there is nothing todo
    double currentTime = timer.GetTime();
    double lastTime = currentTime;
    double epsilon = 0.0000001;

    while(!spriteThread->_done) {
        currentTime = timer.GetTime();// get the current hires time
        double deltaTime = currentTime - lastTime; // time since last iteration
        if (deltaTime < epsilon)
            deltaTime = epsilon;
        lastTime = currentTime;

        SoundSprite *sprite = // first sprite
            SAFE_CAST(SoundSprite *, spriteThread->_updateTree->_sprite);
        while(sprite) { // traverse spritelist
            AVPath path = metaDev->GetPath();
            LeafSound *sound = SAFE_CAST(LeafSound *, sprite->_snd);

            // get the BufferElement off the BufferListList
            BufferElement *bufferElement = 
                metaDev->_bufferListList->GetBuffer(sound, path);

            // have my way with the sprite!

            if(!bufferElement->_playing) {
                sound->RenderStartAtLocation(metaDev, bufferElement,
                        0.0, sprite->_loop);
                bufferElement->_playing = TRUE;
            }

            // calculate predictive trends
            double deltaRate = sprite->_rate * deltaTime;
            double rate = metaDev->GetRate() + deltaRate;

            metaDev->SetGain(LinearTodB(sprite->_gain));
            metaDev->GetPan()->SetLinear(sprite->_pan);
            metaDev->SetRate(rate);
            sound->RenderAttributes(metaDev, bufferElement, 1.0, 0, 0.0);

            // this may be called rapidly (use ptr?)
            sprite = SAFE_CAST(SoundSprite *, sprite->Next());
        }

        Sleep(10);  // sleep in milliSeconds...
    }
#endif

    // cleanup and exit
    CoUninitialize();
    TraceTag((tagSoundDebug, "SpriteThread exiting"));
    return(0);
}


SpriteThread::SpriteThread(MetaSoundDevice *metaDev, RMImpl *updateTree) :
 _metaDev(metaDev), _updateTree(updateTree)
{
    _done          = 0;  // enable the thread

    _threadHandle = CreateThread(NULL, 0,
                                 (LPTHREAD_START_ROUTINE)renderSprites,
                                 this,
                                 0,
                                 &_threadID);

    TraceTag((tagSoundDebug, "SpriteThread instantiated"));
}


SpriteThread::~SpriteThread()
{
    TraceTag((tagSoundDebug, "SpriteThread destroyed"));

    // XXX well the correct thing to do is set done=1, wait for the thread
    // to die, if this times out, then kill the thread!


    if(_threadHandle) {
        _done = TRUE;    // tell the thread to kill itself

        // TODO: May need to address whether to kill the thread or not
        if(WaitForSingleObject(_threadHandle, 5000) == WAIT_TIMEOUT) {
            Assert(FALSE && "Sprite thread termination timed out");
            TerminateThread(_threadHandle, 0);
        }

        CloseHandle(_threadHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\cbvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CBVR_H
#define _CBVR_H

#include "engine.h"
#include "privinc/util.h"
#include "comconv.h"

#pragma warning(disable:4355)  // using 'this' in constructor

//+-------------------------------------------------------------------------
//
//  Class:      CBvr
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class
ATL_NO_VTABLE
__declspec(uuid("2C19B7AE-C8BE-11d0-8794-00C04FC29D46"))
CBvr :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IObjectSafetyImpl<CBvr>,
    public ISupportErrorInfo,
    public IDAImport,
    public IDAModifiableBehavior,
    public IDA2Behavior
{
  public:
    CBvr() ;
    virtual ~CBvr() ;

    CRBvrPtr            GetBvr () { return _bvr ; }
    void                SetBvr (CRBvrPtr b);
    
    BEGIN_COM_MAP(CBvr)
        COM_INTERFACE_ENTRY2(IDispatch,IDA2Behavior)
        COM_INTERFACE_ENTRY(IDA2Behavior)
        COM_INTERFACE_ENTRY(IDAImport)
        COM_INTERFACE_ENTRY(IDAModifiableBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    static HRESULT WINAPI
        InternalQueryInterface(CBvr* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);
        
    HRESULT BvrGetClassName(BSTR * str);
    HRESULT BvrInit(IDABehavior *toBvr);
    HRESULT BvrImportance(double relativeImportance,
                          IDABehavior **ppBvr);
    HRESULT BvrRunOnce(IDABehavior **bvr);
    HRESULT BvrSubstituteTime(IDANumber *xform, IDABehavior **bvr);
    HRESULT BvrHook(IDABvrHook *notifier, IDABehavior **bvr);

    HRESULT BvrDuration(double duration, IDABehavior **bvr);
    HRESULT BvrDuration(IDANumber *duration, IDABehavior **bvr);
    HRESULT BvrRepeat(LONG count, IDABehavior **bvr);
    HRESULT BvrRepeatForever(IDABehavior **bvr);
    HRESULT BvrIsReady(VARIANT_BOOL bBlock, VARIANT_BOOL * b);
    HRESULT BvrSwitchTo(IDABehavior *switchTo, bool bOverrideFlags = false, DWORD dwFlags = 0);
    HRESULT BvrSwitchToNumber(double numToSwitchTo);
    HRESULT BvrSwitchToString(BSTR strToSwitchTo);
        
    HRESULT BvrImportStatus(LONG * status);
    HRESULT BvrImportCancel();
    HRESULT BvrGetImportPrio(float * prio);
    HRESULT BvrSetImportPrio(float prio);

    HRESULT BvrGetCurrentBvr(IDABehavior ** bvr);
    HRESULT BvrSetCurrentBvr(VARIANT bvr);

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    HRESULT BvrApplyPreference(BSTR pref, VARIANT val, IDABehavior **bvr);

    HRESULT BvrExtendedAttrib(BSTR attrib, VARIANT val, IDABehavior **bvr);

    virtual CR_BVR_TYPEID GetTypeInfo () = 0 ;
    virtual const char * GetName () = 0 ;
    virtual REFIID GetIID() = 0 ;
  protected:
    CRPtr<CRBvr> _bvr;
    
    HRESULT Error();
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr) = 0;

    bool GetPixelMode() { return false; }
};

bool CreateCBvr(REFIID riid,
                CRBvrPtr bvr,
                void ** ppv) ;
IDABehavior * CreateCBvr(CRBvrPtr bvr) ;

CRBvrPtr GetBvr(IUnknown * pbvr);

inline CRBvrPtr GetBvr(IDABehavior * pbvr)
{ return GetBvr((IUnknown *) pbvr); }

CR_BVR_TYPEID GetTypeInfoFromName(const char * lpszClassName) ;

typedef CBvr * (* CBVR_CREATEFUN) (IDABehavior **) ;

struct TypeInfoEntry
{
    TypeInfoEntry ()
    : typeInfo(CRUNKNOWN_TYPEID),
      cbvrCreateFun(NULL)
    {}

    TypeInfoEntry (CR_BVR_TYPEID ti,
                   CBVR_CREATEFUN c)
    : typeInfo(ti),
      cbvrCreateFun(c)
    {}

    TypeInfoEntry & operator= (const TypeInfoEntry & tie) {
        memcpy(this,&tie,sizeof(*this)) ;
        return *this ;
    }
    
    bool operator<(const TypeInfoEntry &t) const {
        return this < &t ;
    }

    bool operator>(const TypeInfoEntry &t) const {
        return this > &t ;
    }

    bool operator!=(const TypeInfoEntry &t) const {
        return !(*this == t) ;
    }

    bool operator==(const TypeInfoEntry &t) const {
        return (memcmp (this, &t, sizeof(*this)) != 0) ;
    }

    CR_BVR_TYPEID typeInfo ;
    CBVR_CREATEFUN cbvrCreateFun ;
} ;

void AddEntry (TypeInfoEntry & ce);

#define MAKE_BVR_TYPE_NAME(type,name,bvr) \
    type name; name = (type) ::GetBvr(bvr); \
    if (!name) goto done
    
#define MAKE_BVR_NAME(name,bvr) MAKE_BVR_TYPE_NAME(CRBvrPtr,name,bvr)

#define MAKE_BVR_TYPE(type,bvr) MAKE_BVR_TYPE_NAME(type, bvr##CRBvr, bvr)
#define MAKE_BVR(bvr) MAKE_BVR_TYPE(CRBvrPtr,bvr)

#define MAKE_COM_TYPE_NAME(type,name,bvr) \
    DAComPtr<type> name(bvr,false); \
    if (!name) goto done
    
#define MAKE_COM_TYPE(type,bvr) MAKE_COM_TYPE_NAME(type,bvr##COM,bvr)

#endif /* _CBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\bvrclas1.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "privinc/resource.h"
#include "bvrtypes.h"
#include "comconv.h"
#include "propanim.h"

#include "primmth1.h"

bool CreatePrim0(REFIID iid, void *fp  , void **ret);

bool CreatePrim1(REFIID iid, void *fp , IDABehavior * arg1 , void **ret);

bool CreatePrim2(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2 , void **ret);

bool CreatePrim3(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3 , void **ret);

bool CreatePrim4(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3, IDABehavior * arg4 , void **ret);

bool CreateVar(REFIID iid, CRBvrPtr var, void **ret);

STDMETHODIMP
CDACamera::Transform(IDATransform3 *  arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::Transform(%lx)", this));
    return CreatePrim2(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRCamera *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDACamera::Depth(double arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::Depth(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDACamera, (CRBvrPtr) (::CRDepth((CRCamera *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDACamera::DepthAnim(IDANumber *  arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::DepthAnim(%lx)", this));
    return CreatePrim2(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRCamera *, CRNumber *)) CRDepth , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDACamera::DepthResolution(double arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::DepthResolution(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDACamera, (CRBvrPtr) (::CRDepthResolution((CRCamera *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDACamera::DepthResolutionAnim(IDANumber *  arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDACamera::DepthResolutionAnim(%lx)", this));
    return CreatePrim2(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRCamera *, CRNumber *)) CRDepthResolution , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDACameraCreate(IDABehavior ** bvr)
{
    DAComObject<CDACamera> * pNew ;
    
    DAComObject<CDACamera>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDACamera *) pNew;

    return pNew ;
}

STDMETHODIMP
CDACameraFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRCAMERA_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAImage::AddPickData(IUnknown * arg1, VARIANT_BOOL arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::AddPickData(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRAddPickData((CRImage *) _bvr.p, /* NOELARG */ arg1, /* NOELARG */ BOOLTobool(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::get_BoundingBox(IDABbox2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::get_BoundingBox(%lx)", this));
    return CreatePrim1(IID_IDABbox2, (CRBbox2 * (STDAPICALLTYPE *)(CRImage *)) CRBoundingBox , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Crop(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Crop(%lx)", this));
    return CreatePrim3(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRPoint2 *, CRPoint2 *)) CRCrop , (IDA2Behavior *) (CBvr *)this, arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Transform(IDATransform2 *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Transform(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::OpacityAnim(IDANumber *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::OpacityAnim(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRNumber *)) CROpacity , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Opacity(double arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Opacity(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CROpacity((CRImage *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::Undetectable(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Undetectable(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *)) CRUndetectable , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Tile(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Tile(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *)) CRTile , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::Clip(IDAMatte *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::Clip(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRMatte *)) CRClip , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::MapToUnitSquare(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::MapToUnitSquare(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *)) CRMapToUnitSquare , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::ClipPolygonImageEx(long sizearg0, IDAPoint2 *  arg0[], IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::ClipPolygonImageEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRClipPolygonImage((CRImage *) _bvr.p, arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::ClipPolygonImage(VARIANT arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::ClipPolygonImage(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRClipPolygonImage((CRImage *) _bvr.p, arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::RenderResolution(long arg1, long arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::RenderResolution(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRenderResolution((CRImage *) _bvr.p, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::ImageQuality(DWORD arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::ImageQuality(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRImageQuality((CRImage *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAImage::ColorKey(IDAColor *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::ColorKey(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRColor *)) CRColorKey , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAImage::TransformColorRGB(IDATransform3 * arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAImage::TransformColorRGB(%lx)", this));
    return CreatePrim2(IID_IDAImage,
                       (CRImage * (STDAPICALLTYPE *)(CRImage *, CRTransform3 *)) CRTransformColorRGB,
                       (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)
        ?S_OK:Error();     
}

STDMETHODIMP
CDAImage::Pickable(IDAPickableResult **ppResult)
{
    PRIMPRECODE1(ppResult);
    PickableHelper(_bvr, PT_IMAGE, ppResult);
    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAImage::PickableOccluded(IDAPickableResult **ppResult)
{
    PRIMPRECODE1(ppResult);
    PickableHelper(_bvr, PT_IMAGE_OCCLUDED, ppResult);
    PRIMPOSTCODE1(ppResult);
}


// OBSOLETE

STDMETHODIMP
CDAImage::ApplyBitmapEffect(IUnknown  *unkOfEffectToApply,
                            IDAEvent *firesWhenChanged,
                            IDAImage **bvr)
{
    if (!bvr) return E_POINTER;
    *bvr = NULL;
    return E_NOTIMPL;
}

CBvr * CDAImageCreate(IDABehavior ** bvr)
{
    DAComObject<CDAImage> * pNew ;
    
    DAComObject<CDAImage>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAImage *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAImageFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRIMAGE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAMontage::Render(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAMontage::Render(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRMontage *)) CRRender , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAMontageCreate(IDABehavior ** bvr)
{
    DAComObject<CDAMontage> * pNew ;
    
    DAComObject<CDAMontage>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAMontage *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAMontageFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRMONTAGE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAPoint2::get_X(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::get_X(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *)) CRGetX , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint2::get_Y(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::get_Y(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *)) CRGetY , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint2::get_PolarCoordAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::get_PolarCoordAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *)) CRPolarCoordAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint2::get_PolarCoordLength(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::get_PolarCoordLength(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *)) CRPolarCoordLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint2::Transform(IDATransform2 *  arg0, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint2::Transform(%lx)", this));
    return CreatePrim2(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRPoint2 *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}


STDMETHODIMP
CDAPoint2::AnimateControlPosition(BSTR propertyPath,
                                  BSTR scriptingLanguage,
                                  VARIANT_BOOL invokeAsMethod,
                                  double minUpdateInterval,
                                  IDAPoint2 **newPt)
{
    // These ensure the return pointer is dealt with correctly
    return Point2AnimateControlPosition(this, propertyPath,
                                        scriptingLanguage,
                                        invokeAsMethod ? true : false,
                                        minUpdateInterval,
                                        newPt,
                                        false);
}

STDMETHODIMP
CDAPoint2::AnimateControlPositionPixel(BSTR propertyPath,
                                       BSTR scriptingLanguage,
                                       VARIANT_BOOL invokeAsMethod,
                                       double minUpdateInterval,
                                       IDAPoint2 **newPt)
{
    // These ensure the return pointer is dealt with correctly
    return Point2AnimateControlPosition(this, propertyPath,
                                        scriptingLanguage,
                                        invokeAsMethod ? true : false,
                                        minUpdateInterval,
                                        newPt,
                                        true);
}



CBvr * CDAPoint2Create(IDABehavior ** bvr)
{
    DAComObject<CDAPoint2> * pNew ;
    
    DAComObject<CDAPoint2>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAPoint2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAPoint2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRPOINT2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAString::Extract(BSTR * ret)
{
    TraceTag((tagCOMEntry, "CDAString::Extract(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = WideStringToBSTR(::CRExtract((CRString *) _bvr.p));
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAString::AnimateProperty(BSTR propertyPath,
                           BSTR scriptingLanguage,
                           VARIANT_BOOL invokeAsMethod,
                           double minUpdateInterval,
                           IDAString **newStr)
{ 
    // These ensure the return pointer is dealt with correctly
    return StringAnimateProperty(this, propertyPath,
                                 scriptingLanguage, 
                                 invokeAsMethod ? true : false,
                                 minUpdateInterval, newStr);
}



CBvr * CDAStringCreate(IDABehavior ** bvr)
{
    DAComObject<CDAString> * pNew ;
    
    DAComObject<CDAString>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAString *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAStringFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRSTRING_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAVector2::get_Length(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_Length(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::get_LengthSquared(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_LengthSquared(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRLengthSquared , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::Normalize(IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::Normalize(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *)) CRNormalize , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::MulAnim(IDANumber *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::MulAnim(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRNumber *)) CRMul , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::Mul(double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::Mul(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRMul((CRVector2 *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAVector2::DivAnim(IDANumber *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::DivAnim(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRNumber *)) CRDiv , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::Div(double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::Div(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRDiv((CRVector2 *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAVector2::get_X(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_X(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRGetX , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::get_Y(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_Y(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRGetY , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::get_PolarCoordAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_PolarCoordAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRPolarCoordAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::get_PolarCoordLength(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_PolarCoordLength(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRPolarCoordLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::Transform(IDATransform2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::Transform(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAVector2Create(IDABehavior ** bvr)
{
    DAComObject<CDAVector2> * pNew ;
    
    DAComObject<CDAVector2>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAVector2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAVector2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRVECTOR2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDALineStyle::End(IDAEndStyle *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::End(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CREndStyle *)) CREnd , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::Join(IDAJoinStyle *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::Join(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CRJoinStyle *)) CRJoin , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::Dash(IDADashStyle *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::Dash(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CRDashStyle *)) CRDash , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::WidthAnim(IDANumber *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::WidthAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PointToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRWidth((CRLineStyle *) _bvr.p, arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::width(double arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::width(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRWidth((CRLineStyle *) _bvr.p, /* NOELARG */ PointToNum(arg0))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::AntiAliasing(double arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::AntiAliasing(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRAntiAliasing((CRLineStyle *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::Detail(IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::Detail(%lx)", this));
    return CreatePrim1(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *)) CRDetail , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::Color(IDAColor *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::Color(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CRColor *)) CRLineColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::DashStyle(DWORD arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::DashStyle(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRDashEx((CRLineStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::MiterLimit(double arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::MiterLimit(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRMiterLimit((CRLineStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::MiterLimitAnim(IDANumber *  arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::MiterLimitAnim(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CRNumber *)) CRMiterLimit , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::JoinStyle(DWORD arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::JoinStyle(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRJoinEx((CRLineStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::EndStyle(DWORD arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::EndStyle(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CREndEx((CRLineStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}



CBvr * CDALineStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDALineStyle> * pNew ;
    
    DAComObject<CDALineStyle>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDALineStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDALineStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRLINESTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}



CBvr * CDADashStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDADashStyle> * pNew ;
    
    DAComObject<CDADashStyle>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDADashStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDADashStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRDASHSTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAPair::get_First(IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPair::get_First(%lx)", this));
    return CreatePrim1(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRPair *)) CRFirst , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPair::get_Second(IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPair::get_Second(%lx)", this));
    return CreatePrim1(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRPair *)) CRSecond , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAPairCreate(IDABehavior ** bvr)
{
    DAComObject<CDAPair> * pNew ;
    
    DAComObject<CDAPair>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAPair *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAPairFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRPAIR_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDATuple::Nth(long arg1, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDATuple::Nth(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDABehavior, (CRBvrPtr) (::CRNth((CRTuple *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDATuple::get_Length(long * ret)
{
    TraceTag((tagCOMEntry, "CDATuple::get_Length(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = (::CRLength((CRTuple *) _bvr.p));
    PRIMPOSTCODE1(ret) ;
}



CBvr * CDATupleCreate(IDABehavior ** bvr)
{
    DAComObject<CDATuple> * pNew ;
    
    DAComObject<CDATuple>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDATuple *) pNew;

    return pNew ;
}

STDMETHODIMP
CDATupleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRTUPLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\bvrti.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "bvrtypes.h"
#include "srvprims.h"

#define ENCODER     10000  // used to encode DISPID
                  
ITypeInfo* BvrComTypeInfoHolder::s_pImportInfo = NULL;
ITypeInfo* BvrComTypeInfoHolder::s_pModBvrInfo = NULL;
ITypeInfo* BvrComTypeInfoHolder::s_pBvr2Info = NULL;
long BvrComTypeInfoHolder::s_dwRef = 0;

HRESULT
BvrComTypeInfoHolder::LoadTypeInfo(LCID lcid, REFIID iid, ITypeInfo** ppInfo)
{
    HRESULT hRes = S_OK;
    
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);

    DAComPtr<ITypeLib> pTypeLib;
    hRes = LoadRegTypeLib(LIBID_DirectAnimation, DA_MAJOR_VERSION, DA_MINOR_VERSION, lcid, &pTypeLib);

    if (SUCCEEDED(hRes)) {
        hRes = pTypeLib->GetTypeInfoOfGuid(iid, ppInfo);

        if (SUCCEEDED(hRes) && s_dwRef == 0) {
            Assert(s_pImportInfo == NULL);
            Assert(s_pModBvrInfo == NULL);
            Assert(s_pBvr2Info == NULL);
            
            hRes = pTypeLib->GetTypeInfoOfGuid(IID_IDAImport,
                                               &s_pImportInfo);
            if (SUCCEEDED(hRes)) {
                hRes = pTypeLib->GetTypeInfoOfGuid(IID_IDAModifiableBehavior,
                                                   &s_pModBvrInfo);
                if (SUCCEEDED(hRes)) {
                    hRes = pTypeLib->GetTypeInfoOfGuid(IID_IDA2Behavior,
                                                       &s_pBvr2Info);
                }
            }
        }
    }

    if (SUCCEEDED(hRes)) {
        Assert(s_pImportInfo);
        Assert(s_pModBvrInfo);
        Assert(s_pBvr2Info);
        Assert(*ppInfo);
        s_dwRef++;
    } else {
        if (s_dwRef == 0) {
            RELEASE(s_pImportInfo);
            RELEASE(s_pModBvrInfo);
            RELEASE(s_pBvr2Info);
        }
        
        RELEASE(*ppInfo);
    }

    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    
    return hRes;
}

void
BvrComTypeInfoHolder::FreeTypeInfo()
{
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (--s_dwRef == 0) {
        RELEASE(s_pImportInfo);
        RELEASE(s_pModBvrInfo);
        RELEASE(s_pBvr2Info);
    }
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void
BvrComTypeInfoHolder::AddRef()
{
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    m_dwRef++;
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void
BvrComTypeInfoHolder::Release()
{
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (--m_dwRef == 0) {
        if (m_pInfo != NULL) {
            RELEASE(m_pInfo);
            // Only free type info if we had loaded the class specific
            // type info 
            FreeTypeInfo();
        }
    }
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT
BvrComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
    //If this assert occurs then most likely didn't initialize properly
    Assert(m_pguid != NULL);
    SET_NULL(ppInfo);
    
    HRESULT hRes = S_OK;
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);

    if (m_pInfo == NULL) {
        hRes = LoadTypeInfo(lcid, *m_pguid, &m_pInfo);
    }

    if (SUCCEEDED(hRes)) {
        Assert(m_pInfo);
        Assert(s_pImportInfo);
        Assert(s_pModBvrInfo);
        Assert(s_pBvr2Info);
        Assert(s_dwRef);
        
        if (ppInfo) {
            *ppInfo = m_pInfo;
            m_pInfo->AddRef();
        }
    }
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    return hRes;
}

HRESULT
BvrComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/,
                                  LCID lcid,
                                  ITypeInfo** pptinfo)
{
    HRESULT hRes = E_POINTER;
    if (pptinfo != NULL)
        hRes = GetTI(lcid, pptinfo);
    return hRes;
}

HRESULT
BvrComTypeInfoHolder::GetIDsOfNames(CRBvrPtr bvr,
                                    REFIID /*riid*/,
                                    LPOLESTR* rgszNames,
                                    UINT cNames,
                                    LCID lcid,
                                    DISPID* rgdispid)
{
    HRESULT hRes = GetTI(lcid, NULL);

    if (SUCCEEDED(hRes)) {
        // Everything should be valid since we succeeded with the
        // GetTI and our current object should have a reference count
        
        Assert(m_pInfo);
        Assert(s_pImportInfo);
        Assert(s_pModBvrInfo);
        Assert(s_pBvr2Info);
        Assert(s_dwRef);
        Assert(m_dwRef);

        ITypeInfo * TIList[] = { m_pInfo,
                                 CRIsImport(bvr)?s_pImportInfo:NULL,
                                 CRIsModifiableBvr(bvr)?s_pModBvrInfo:NULL,
                                 s_pBvr2Info };

        for (int i = 0; i < ARRAY_SIZE(TIList); i++) {
            if (TIList[i]) {
                hRes = TIList[i]->GetIDsOfNames(rgszNames,
                                                cNames,
                                                rgdispid);
            } else {
                hRes = DISP_E_UNKNOWNNAME;
            }

            // TODO: Should probably detect failures which indicate it
            // was the correct interface but just something else was
            // wrong
            
            if (SUCCEEDED(hRes)) {
                if (cNames >= 1) {
                    *rgdispid += (ENCODER*i);
                }
                break;
            }
        }
    }

    return hRes;
}

HRESULT
BvrComTypeInfoHolder::Invoke(CRBvrPtr bvr,
                             IDispatch* pbvr,
                             IDAImport* pimp,
                             IDAModifiableBehavior* pmod,
                             IDA2Behavior* pbvr2,
                             DISPID dispidMember,
                             REFIID riid,
                             LCID lcid,
                             WORD wFlags,
                             DISPPARAMS* pdispparams,
                             VARIANT* pvarResult,
                             EXCEPINFO* pexcepinfo,
                             UINT* puArgErr)
{
    SetErrorInfo(0, NULL);

    HRESULT hRes = GetTI(lcid, NULL);

    if (SUCCEEDED(hRes)) {
        // Everything should be valid since we succeeded with the
        // GetTI and our current object should have a reference count
        
        Assert(m_pInfo);
        Assert(s_pImportInfo);
        Assert(s_pModBvrInfo);
        Assert(s_pBvr2Info);
        Assert(s_dwRef);
        Assert(m_dwRef);

        // These lists must be in the same order and in the same order
        // as getidsofnames
        
        ITypeInfo * TIList[] = { m_pInfo,
                                 CRIsImport(bvr)?s_pImportInfo:NULL,
                                 CRIsModifiableBvr(bvr)?s_pModBvrInfo:NULL,
                                 s_pBvr2Info };

        IDispatch * DispList[] = { pbvr,
                                   pimp,
                                   pmod,
                                   pbvr2 };
        
        // convert the incomming dispid to the correct on and call invoke on the 
        // correct interface.....
        int nOffset;

        // Anything 0 or less (or too high) should just get passed to
        // the default interfaces (0 offset) to handle
        
        if (dispidMember > 0) {
            // Only the low word is relevant - the high word has some
            // misc information in it and is not relevant
            
            nOffset = LOWORD(dispidMember) / ENCODER;
            
            if(nOffset >= ARRAY_SIZE(TIList)) {
                // On an error just call the default interface with
                // the dispId which should be too high
                nOffset = 0;
            } else {
                // Adjust the dispid as appropriate
                dispidMember -= ENCODER * nOffset;
            }
        } else {
            nOffset = 0;
        }

        if (TIList[nOffset]) {
            hRes = TIList[nOffset]->Invoke(DispList[nOffset],
                                           dispidMember,
                                           wFlags,
                                           pdispparams,
                                           pvarResult,
                                           pexcepinfo,
                                           puArgErr);
        } else {
            hRes = DISP_E_UNKNOWNNAME;
        }
    }

    return hRes;
}

void
DeinitializeModule_BvrTI(bool bShutdown)
{
    Assert(!BvrComTypeInfoHolder::s_pImportInfo &&
           !BvrComTypeInfoHolder::s_pModBvrInfo &&
           !BvrComTypeInfoHolder::s_pBvr2Info &&
           BvrComTypeInfoHolder::s_dwRef == 0);

    RELEASE(BvrComTypeInfoHolder::s_pImportInfo);
    RELEASE(BvrComTypeInfoHolder::s_pModBvrInfo);
    RELEASE(BvrComTypeInfoHolder::s_pBvr2Info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\bvrclas0.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "privinc/resource.h"
#include "bvrtypes.h"
#include "comconv.h"
#include "results.h"

#include "primmth0.h"

bool CreatePrim0(REFIID iid, void *fp  , void **ret);

bool CreatePrim1(REFIID iid, void *fp , IDABehavior * arg1 , void **ret);

bool CreatePrim2(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2 , void **ret);

bool CreatePrim3(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3 , void **ret);

bool CreatePrim4(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3, IDABehavior * arg4 , void **ret);

bool CreateVar(REFIID iid, CRBvrPtr var, void **ret);

STDMETHODIMP
CDABoolean::Extract(VARIANT_BOOL * ret)
{
    TraceTag((tagCOMEntry, "CDABoolean::Extract(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = boolToBOOL(::CRExtract((CRBoolean *) _bvr.p));
    PRIMPOSTCODE(S_OK) ;
}



CBvr * CDABooleanCreate(IDABehavior ** bvr)
{
    DAComObject<CDABoolean> * pNew ;

    DAComObject<CDABoolean>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDABoolean *) pNew;

    return pNew ;
}

STDMETHODIMP
CDABooleanFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRBOOLEAN_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAGeometry::RenderSound(IDAMicrophone *  arg1, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::RenderSound(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRGeometry *, CRMicrophone *)) CRRenderSound , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::AddPickData(IUnknown * arg1, VARIANT_BOOL arg2, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::AddPickData(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRAddPickData((CRGeometry *) _bvr.p, /* NOELARG */ arg1, /* NOELARG */ BOOLTobool(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::Undetectable(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Undetectable(%lx)", this));
    return CreatePrim1(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *)) CRUndetectable , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::EmissiveColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::EmissiveColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CREmissiveColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::DiffuseColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::DiffuseColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CRDiffuseColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::SpecularColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::SpecularColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CRSpecularColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::SpecularExponent(double arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::SpecularExponent(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRSpecularExponent((CRGeometry *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::SpecularExponentAnim(IDANumber *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::SpecularExponentAnim(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRNumber *)) CRSpecularExponentAnim , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Texture(IDAImage *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Texture(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRImage *)) CRTexture , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Opacity(double arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Opacity(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CROpacity((CRGeometry *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::OpacityAnim(IDANumber *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::OpacityAnim(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRNumber *)) CROpacity , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Transform(IDATransform3 *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Transform(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Shadow(IDAGeometry *  arg1, IDAPoint3 *  arg2, IDAVector3 *  arg3, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Shadow(%lx)", this));
    return CreatePrim4(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRGeometry *, CRPoint3 *, CRVector3 *)) CRShadow , (IDA2Behavior *) (CBvr *)this, arg1, arg2, arg3, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::get_BoundingBox(IDABbox3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::get_BoundingBox(%lx)", this));
    return CreatePrim1(IID_IDABbox3, (CRBbox3 * (STDAPICALLTYPE *)(CRGeometry *)) CRBoundingBox , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Render(IDACamera *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Render(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRGeometry *, CRCamera *)) CRRender , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::LightColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CRLightColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::LightRangeAnim(IDANumber *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightRangeAnim(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRNumber *)) CRLightRange , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::LightRange(double arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightRange(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRLightRange((CRGeometry *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::LightAttenuationAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightAttenuationAnim(%lx)", this));
    return CreatePrim4(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRNumber *, CRNumber *, CRNumber *)) CRLightAttenuation , (IDA2Behavior *) (CBvr *)this, arg0, arg1, arg2, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::LightAttenuation(double arg0, double arg1, double arg2, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::LightAttenuation(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRLightAttenuation((CRGeometry *) _bvr.p, /* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::BlendTextureDiffuse(IDABoolean *  arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::BlendTextureDiffuse(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRBoolean *)) CRBlendTextureDiffuse , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::AmbientColor(IDAColor *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::AmbientColor(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRColor *)) CRAmbientColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::D3DRMTexture(IUnknown * arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::D3DRMTexture(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRD3DRMTexture((CRGeometry *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAGeometry::ModelClip(IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::ModelClip(%lx)", this));
    return CreatePrim3(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRPoint3 *, CRVector3 *)) CRModelClip , (IDA2Behavior *) (CBvr *)this, arg0, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::Lighting(IDABoolean *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::Lighting(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRBoolean *)) CRLighting , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAGeometry::TextureImage(IDAImage *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAGeometry::TextureImage(%lx)", this));
    return CreatePrim2 (IID_IDAGeometry, (CRGeometry* (STDAPICALLTYPE*)(CRGeometry*, CRImage*)) CRTextureImage, (IDA2Behavior*) (CBvr*)this, arg0, (void**) ret) ? S_OK : Error();
}

bool
PickableHelper(CRBvrPtr bvr,
               PickableType type,
               IDAPickableResult **ppResult)
{
    bool ok = false;
    
    CRPickableResultPtr res;

    switch (type) {
      case PT_IMAGE:
        res = CRPickable((CRImage *) bvr);
        break;
      case PT_IMAGE_OCCLUDED:
        res = CRPickableOccluded((CRImage *) bvr);
        break;
      case PT_GEOM:
        res = CRPickable((CRGeometry *) bvr);
        break;
      case PT_GEOM_OCCLUDED:
        res = CRPickableOccluded((CRGeometry *) bvr);
        break;
      default:
        Assert (!"Invalid type passed to PickableHelper");
        res = NULL;
        break;
    }

    if (res) {
        ok = CDAPickableResult::Create(res,
                                       ppResult);
    }

  done:
    return ok;
}

STDMETHODIMP
CDAGeometry::Pickable(IDAPickableResult **ppResult)
{
    PRIMPRECODE1(ppResult);
    PickableHelper(_bvr, PT_GEOM, ppResult);
    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAGeometry::PickableOccluded(IDAPickableResult **ppResult)
{
    PRIMPRECODE1(ppResult);
    PickableHelper(_bvr, PT_GEOM_OCCLUDED, ppResult);
    PRIMPOSTCODE1(ppResult);
}


STDMETHODIMP CDAGeometry::Billboard (IDAVector3 *axis, IDAGeometry **result)
{
    TraceTag ((tagCOMEntry, "CDAGeometry::Billboard(%lx)", this));
    return
      CreatePrim2 (
        IID_IDAGeometry,
        (CRGeometry* (STDAPICALLTYPE*)(CRGeometry*, CRVector3*)) CRBillboard,
        (IDA2Behavior*) (CBvr*)this, axis, (void**) result
      )
      ? S_OK : Error();
}


CBvr * CDAGeometryCreate(IDABehavior ** bvr)
{
    DAComObject<CDAGeometry> * pNew ;

    DAComObject<CDAGeometry>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAGeometry *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAGeometryFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRGEOMETRY_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAMicrophone::Transform(IDATransform3 *  arg0, IDAMicrophone *  * ret)
{
    TraceTag((tagCOMEntry, "CDAMicrophone::Transform(%lx)", this));
    return CreatePrim2(IID_IDAMicrophone, (CRMicrophone * (STDAPICALLTYPE *)(CRMicrophone *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}



CBvr * CDAMicrophoneCreate(IDABehavior ** bvr)
{
    DAComObject<CDAMicrophone> * pNew ;

    DAComObject<CDAMicrophone>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAMicrophone *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAMicrophoneFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRMICROPHONE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAPath2::Transform(IDATransform2 *  arg0, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::Transform(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPath2 *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAPath2::BoundingBox(IDALineStyle *  arg0, IDABbox2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::BoundingBox(%lx)", this));
    return CreatePrim2(IID_IDABbox2, (CRBbox2 * (STDAPICALLTYPE *)(CRPath2 *, CRLineStyle *)) CRBoundingBox , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAPath2::Fill(IDALineStyle *  arg0, IDAImage *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::Fill(%lx)", this));
    return CreatePrim3(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRPath2 *, CRLineStyle *, CRImage *)) CRFill , (IDA2Behavior *) (CBvr *)this, arg0, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAPath2::Draw(IDALineStyle *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::Draw(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRPath2 *, CRLineStyle *)) CRDraw , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAPath2::Close(IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPath2::Close(%lx)", this));
    return CreatePrim1(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPath2 *)) CRClose , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}



CBvr * CDAPath2Create(IDABehavior ** bvr)
{
    DAComObject<CDAPath2> * pNew ;

    DAComObject<CDAPath2>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAPath2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAPath2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRPATH2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDASound::PhaseAnim(IDANumber *  arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::PhaseAnim(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRNumber *)) CRPhase , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDASound::Phase(double arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Phase(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRPhase((CRSound *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDASound::RateAnim(IDANumber *  arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::RateAnim(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRNumber *)) CRRate , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDASound::Rate(double arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRRate((CRSound *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDASound::PanAnim(IDANumber *  arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::PanAnim(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRNumber *)) CRPan , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDASound::Pan(double arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Pan(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRPan((CRSound *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDASound::GainAnim(IDANumber *  arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::GainAnim(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRNumber *)) CRGain , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDASound::Gain(double arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Gain(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRGain((CRSound *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDASound::Loop(IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDASound::Loop(%lx)", this));
    return CreatePrim1(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *)) CRLoop , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}



CBvr * CDASoundCreate(IDABehavior ** bvr)
{
    DAComObject<CDASound> * pNew ;

    DAComObject<CDASound>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDASound *) pNew;

    return pNew ;
}

STDMETHODIMP
CDASoundFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRSOUND_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDATransform3::Inverse(IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform3::Inverse(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRTransform3 *)) CRInverse , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDATransform3::get_IsSingular(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform3::get_IsSingular(%lx)", this));
    return CreatePrim1(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRTransform3 *)) CRIsSingular , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDATransform3::ParallelTransform2(IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform3::ParallelTransform2(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRTransform3 *)) CRParallelTransform2 , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}



CBvr * CDATransform3Create(IDABehavior ** bvr)
{
    DAComObject<CDATransform3> * pNew ;

    DAComObject<CDATransform3>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDATransform3 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDATransform3Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRTRANSFORM3_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAFontStyle::Bold(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Bold(%lx)", this));
    return CreatePrim1(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *)) CRBold , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Italic(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Italic(%lx)", this));
    return CreatePrim1(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *)) CRItalic , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Underline(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Underline(%lx)", this));
    return CreatePrim1(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *)) CRUnderline , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Strikethrough(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Strikethrough(%lx)", this));
    return CreatePrim1(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *)) CRStrikethrough , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::AntiAliasing(double arg0, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::AntiAliasing(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRAntiAliasing((CRFontStyle *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAFontStyle::Color(IDAColor *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Color(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRColor *)) CRTextColor , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::FamilyAnim(IDAString *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::FamilyAnim(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRString *)) CRFamily , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Family(BSTR arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Family(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRFamily((CRFontStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAFontStyle::SizeAnim(IDANumber *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::SizeAnim(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRNumber *)) CRSize , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::Size(double arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Size(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRSize((CRFontStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAFontStyle::Weight(double arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::Weight(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRWeight((CRFontStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAFontStyle::WeightAnim(IDANumber *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::WeightAnim(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRNumber *)) CRWeight , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAFontStyle::TransformCharacters(IDATransform2 *  arg1, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAFontStyle::TransformCharacters(%lx)", this));
    return CreatePrim2(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRFontStyle *, CRTransform2 *)) CRTransformCharacters , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}



CBvr * CDAFontStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDAFontStyle> * pNew ;

    DAComObject<CDAFontStyle>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAFontStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAFontStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRFONTSTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}



CBvr * CDAJoinStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDAJoinStyle> * pNew ;

    DAComObject<CDAJoinStyle>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAJoinStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAJoinStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRJOINSTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDABbox3::get_Min(IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDABbox3::get_Min(%lx)", this));
    return CreatePrim1(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRBbox3 *)) CRMin , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDABbox3::get_Max(IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDABbox3::get_Max(%lx)", this));
    return CreatePrim1(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRBbox3 *)) CRMax , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}



CBvr * CDABbox3Create(IDABehavior ** bvr)
{
    DAComObject<CDABbox3> * pNew ;

    DAComObject<CDABbox3>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDABbox3 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDABbox3Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRBBOX3_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAArray::NthAnim(IDANumber *  arg1, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAArray::NthAnim(%lx)", this));
    return CreatePrim2(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRArray *, CRNumber *)) CRNth , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAArray::Length(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAArray::Length(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRArray *)) CRLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error();

}

STDMETHODIMP
CDAArray::AddElement(IDABehavior *  arg1, DWORD arg2, long * ret)
{
    TraceTag((tagCOMEntry, "CDAArray::AddElement(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRBvr * arg1VAL;
    arg1VAL = (CRBvr *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    /* NOELRET */ *ret = (::CRAddElement((CRArray *) _bvr.p, arg1VAL, /* NOELARG */ arg2));
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAArray::RemoveElement(long arg1)
{
    TraceTag((tagCOMEntry, "CDAArray::RemoveElement(%lx)", this));

    PRIMPRECODE0(ret) ;
    /* NOELRET */ ret = (::CRRemoveElement((CRArray *) _bvr.p, /* NOELARG */ arg1));
    PRIMPOSTCODE0(ret) ;
}

STDMETHODIMP
CDAArray::SetElement(long index, IDABehavior *  arg1, long flag)
{
    TraceTag((tagCOMEntry, "CDAArray::SetElement(%lx)", this));

    PRIMPRECODE0(ret) ;

    CRBvr * arg1VAL;
    arg1VAL = (CRBvr *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    /* NOELRET */ ret = (::CRSetElement((CRArray *) _bvr.p, index, arg1VAL, /* NOELARG */ flag));
    PRIMPOSTCODE0(ret) ;
}

STDMETHODIMP
CDAArray::GetElement(long index, IDABehavior **ret)
{
    TraceTag((tagCOMEntry, "CDAArray::GetElement(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDABehavior,
               (CRBvrPtr) ::CRGetElement((CRArray *) _bvr.p, index),
               (void **) ret);
    PRIMPOSTCODE1(ret) ;
}


CBvr * CDAArrayCreate(IDABehavior ** bvr)
{
    DAComObject<CDAArray> * pNew ;

    DAComObject<CDAArray>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAArray *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAArrayFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRARRAY_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}



CBvr * CDABehaviorCreate(IDABehavior ** bvr)
{
    DAComObject<CDABehavior> * pNew ;

    DAComObject<CDABehavior>::CreateInstance(&pNew) ;

    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDA2Behavior *) pNew;

    return pNew ;
}

STDMETHODIMP
CDABehaviorFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRUNKNOWN_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\bvrtypes.h ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#ifndef _BVRTYPES_H
#define _BVRTYPES_H

#include "cbvr.h"

//+-------------------------------------------------------------------------
//
//  Class:      BvrComTypeInfoHolder
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class BvrComTypeInfoHolder
{
    // Should be 'protected' but can cause compiler to generate fat code.
  public:
    const GUID* m_pguid;

    ITypeInfo* m_pInfo;
    long m_dwRef;

    static ITypeInfo* s_pImportInfo;
    static ITypeInfo* s_pModBvrInfo;
    static ITypeInfo* s_pBvr2Info;
    static long s_dwRef;

    static HRESULT LoadTypeInfo(LCID lcid, REFIID iid, ITypeInfo** ppInfo);
    static void FreeTypeInfo();
  public:
    HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

    void AddRef();
    void Release();
    HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    HRESULT GetIDsOfNames(CRBvrPtr bvr,
                          REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                          LCID lcid, DISPID* rgdispid);
    HRESULT Invoke(CRBvrPtr bvr,
                   IDispatch* pbvr,
                   IDAImport* pimp,
                   IDAModifiableBehavior* pmod,
                   IDA2Behavior* pbvr2,
                   DISPID dispidMember, REFIID riid,
                   LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                   EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

//+-------------------------------------------------------------------------
//
//  Class:      CBvrBase
//
//  Synopsis:
//
//--------------------------------------------------------------------------

template <class TInterface,
          const IID * iid>
class ATL_NO_VTABLE CBvrBase :
    public CBvr,
    public TInterface
{
  public:
    CBvrBase() { _tih.AddRef(); }
    ~CBvrBase() { _tih.Release(); }

    STDMETHOD(GetClassName)(BSTR * str)
    { return BvrGetClassName(str); }

    STDMETHOD(Init)(IDABehavior *toBvr)
    { return BvrInit(toBvr); }

    STDMETHOD(Importance)(double relativeImportance,
                          IDABehavior **ppBvr)
    { return BvrImportance(relativeImportance,ppBvr); }

    STDMETHOD(RunOnce)(IDABehavior **bvr)
    { return BvrRunOnce(bvr); }
        
    STDMETHOD(SubstituteTime)(IDANumber *xform, IDABehavior **bvr)
    { return BvrSubstituteTime(xform, bvr); }
        
    STDMETHOD(Hook)(IDABvrHook *notifier, IDABehavior **bvr)
    { return BvrHook(notifier, bvr); }

    STDMETHOD(Duration)(double duration, IDABehavior **bvr)
    { return BvrDuration(duration, bvr); }
    
    STDMETHOD(DurationAnim)(IDANumber *duration, IDABehavior **bvr)
    { return BvrDuration(duration, bvr); }
    
    STDMETHOD(Repeat)(LONG count, IDABehavior **bvr)
    { return BvrRepeat(count, bvr); }

    STDMETHOD(RepeatForever)(IDABehavior **bvr)
    { return BvrRepeatForever(bvr); }


    STDMETHOD(IsReady)(VARIANT_BOOL bBlock, VARIANT_BOOL *b)
    { return BvrIsReady(bBlock,b); }

    STDMETHOD(SwitchTo)(IDABehavior *switchTo)
    { return BvrSwitchTo(switchTo); }

    STDMETHOD(SwitchToNumber)(double numToSwitchTo)
    { return BvrSwitchToNumber(numToSwitchTo); }
    
    STDMETHOD(SwitchToString)(BSTR strToSwitchTo)
    { return BvrSwitchToString(strToSwitchTo); }


    STDMETHOD(put_CurrentBehavior)(VARIANT bvr)
    { return BvrSetCurrentBvr(bvr); }

    STDMETHOD(get_CurrentBehavior)(IDABehavior **bvr)
    { return BvrGetCurrentBvr(bvr); }


    STDMETHOD(ImportStatus)(LONG * status)
    { return BvrImportStatus(status); }

    STDMETHOD(ImportCancel)()
    { return BvrImportCancel(); }
    
    STDMETHOD(get_ImportPriority)(float * prio)
    { return BvrGetImportPrio(prio); }
    
    STDMETHOD(put_ImportPriority)(float prio)
    { return BvrSetImportPrio(prio); }

    STDMETHOD(SwitchToEx)(IDABehavior *switchTo, DWORD dwFlags)
    { return BvrSwitchTo(switchTo, true, dwFlags); }
    
    STDMETHOD(ApplyPreference)(BSTR pref, VARIANT val, IDABehavior **bvr)
    { return BvrApplyPreference(pref, val, bvr); }

    STDMETHOD(ExtendedAttrib)(BSTR attrib, VARIANT val, IDABehavior **bvr)
    { return BvrExtendedAttrib(attrib, val, bvr); }
    
    // Need to copy this here since multiple interface need this
    // implemented
    
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {*pctinfo = 1; return S_OK;}

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return _tih.GetTypeInfo(itinfo, lcid, pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return _tih.GetIDsOfNames(_bvr, riid, rgszNames, cNames, lcid, rgdispid);}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return _tih.Invoke(_bvr,
                         (TInterface *)this,this,this,this,
                         dispidMember, riid, lcid,
                         wFlags, pdispparams, pvarResult,
                         pexcepinfo, puArgErr); }
    
    virtual REFIID GetIID() { return *iid; }
  protected:
    static BvrComTypeInfoHolder _tih;
    static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
    { return _tih.GetTI(lcid, ppInfo); }
};

template <class T, const IID* piid>
BvrComTypeInfoHolder
CBvrBase<T, piid>::_tih =
{piid, NULL, 0};


enum PickableType {
    PT_IMAGE,
    PT_IMAGE_OCCLUDED,
    PT_GEOM,
    PT_GEOM_OCCLUDED,
};

bool PickableHelper (CRBvr*, PickableType, IDAPickableResult**);


#endif /* _BVRTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\bvrclas2.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "privinc/resource.h"
#include "bvrtypes.h"
#include "comconv.h"
#include "propanim.h"

#include "primmth2.h"

bool CreatePrim0(REFIID iid, void *fp  , void **ret);

bool CreatePrim1(REFIID iid, void *fp , IDABehavior * arg1 , void **ret);

bool CreatePrim2(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2 , void **ret);

bool CreatePrim3(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3 , void **ret);

bool CreatePrim4(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3, IDABehavior * arg4 , void **ret);

bool CreateVar(REFIID iid, CRBvrPtr var, void **ret);

STDMETHODIMP
CDAColor::get_Red(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Red(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetRed , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Green(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Green(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetGreen , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Blue(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Blue(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetBlue , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Hue(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Hue(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetHue , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Saturation(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Saturation(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetSaturation , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Lightness(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Lightness(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetLightness , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::AnimateProperty(BSTR propertyPath,
                          BSTR scriptingLanguage,
                          VARIANT_BOOL invokeAsMethod,
                          double minUpdateInterval,
                          IDA2Color **newCol)
{
    // These ensure the return pointer is dealt with correctly
    return ColorAnimateProperty(this, propertyPath,
                                 scriptingLanguage, 
                                 invokeAsMethod ? true : false,
                                 minUpdateInterval, newCol);
}


CBvr * CDAColorCreate(IDABehavior ** bvr)
{
    DAComObject<CDAColor> * pNew ;
    
    DAComObject<CDAColor>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAColor *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAColorFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRCOLOR_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAMatte::Transform(IDATransform2 *  arg0, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAMatte::Transform(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRMatte *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAMatteCreate(IDABehavior ** bvr)
{
    DAComObject<CDAMatte> * pNew ;
    
    DAComObject<CDAMatte>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAMatte *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAMatteFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRMATTE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDANumber::Extract(double * ret)
{
    TraceTag((tagCOMEntry, "CDANumber::Extract(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = (::CRExtract((CRNumber *) _bvr.p));
    PRIMPOSTCODE(S_OK) ;
}

STDMETHODIMP
CDANumber::ToStringAnim(IDANumber *  arg1, IDAString *  * ret)
{
    TraceTag((tagCOMEntry, "CDANumber::ToStringAnim(%lx)", this));
    return CreatePrim2(IID_IDAString, (CRString * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRToString , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDANumber::ToString(double arg1, IDAString *  * ret)
{
    TraceTag((tagCOMEntry, "CDANumber::ToString(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAString, (CRBvrPtr) (::CRToString((CRNumber *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}


STDMETHODIMP
CDANumber::AnimateProperty(BSTR propertyPath,
                           BSTR scriptingLanguage,
                           VARIANT_BOOL invokeAsMethod,
                           double minUpdateInterval,
                           IDANumber **newNum)
{
    // These ensure the return pointer is dealt with correctly
    return NumberAnimateProperty(this, propertyPath,
                                 scriptingLanguage,
                                 invokeAsMethod ? true : false,
                                 minUpdateInterval, newNum);
}



CBvr * CDANumberCreate(IDABehavior ** bvr)
{
    DAComObject<CDANumber> * pNew ;
    
    DAComObject<CDANumber>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDANumber *) pNew;

    return pNew ;
}

STDMETHODIMP
CDANumberFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRNUMBER_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAPoint3::Project(IDACamera *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::Project(%lx)", this));
    return CreatePrim2(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRPoint3 *, CRCamera *)) CRProject , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_X(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_X(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRGetX , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_Y(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_Y(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRGetY , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_Z(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_Z(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRGetZ , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_SphericalCoordXYAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_SphericalCoordXYAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRSphericalCoordXYAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_SphericalCoordYZAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_SphericalCoordYZAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRSphericalCoordYZAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_SphericalCoordLength(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_SphericalCoordLength(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRSphericalCoordLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::Transform(IDATransform3 *  arg0, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::Transform(%lx)", this));
    return CreatePrim2(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRPoint3 *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAPoint3Create(IDABehavior ** bvr)
{
    DAComObject<CDAPoint3> * pNew ;
    
    DAComObject<CDAPoint3>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAPoint3 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAPoint3Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRPOINT3_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDATransform2::Inverse(IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform2::Inverse(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRTransform2 *)) CRInverse , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDATransform2::get_IsSingular(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform2::get_IsSingular(%lx)", this));
    return CreatePrim1(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRTransform2 *)) CRIsSingular , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}



CBvr * CDATransform2Create(IDABehavior ** bvr)
{
    DAComObject<CDATransform2> * pNew ;
    
    DAComObject<CDATransform2>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDATransform2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDATransform2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRTRANSFORM2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAVector3::get_Length(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_Length(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_LengthSquared(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_LengthSquared(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRLengthSquared , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::Normalize(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::Normalize(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *)) CRNormalize , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::MulAnim(IDANumber *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::MulAnim(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRNumber *)) CRMul , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::Mul(double arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::Mul(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRMul((CRVector3 *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAVector3::DivAnim(IDANumber *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::DivAnim(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRNumber *)) CRDiv , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::Div(double arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::Div(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRDiv((CRVector3 *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAVector3::get_X(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_X(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRGetX , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_Y(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_Y(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRGetY , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_Z(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_Z(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRGetZ , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_SphericalCoordXYAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_SphericalCoordXYAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRSphericalCoordXYAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_SphericalCoordYZAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_SphericalCoordYZAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRSphericalCoordYZAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_SphericalCoordLength(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_SphericalCoordLength(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRSphericalCoordLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::Transform(IDATransform3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::Transform(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAVector3Create(IDABehavior ** bvr)
{
    DAComObject<CDAVector3> * pNew ;
    
    DAComObject<CDAVector3>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAVector3 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAVector3Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRVECTOR3_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}



CBvr * CDAEndStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDAEndStyle> * pNew ;
    
    DAComObject<CDAEndStyle>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAEndStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAEndStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRENDSTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDABbox2::get_Min(IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDABbox2::get_Min(%lx)", this));
    return CreatePrim1(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRBbox2 *)) CRMin , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDABbox2::get_Max(IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDABbox2::get_Max(%lx)", this));
    return CreatePrim1(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRBbox2 *)) CRMax , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}



CBvr * CDABbox2Create(IDABehavior ** bvr)
{
    DAComObject<CDABbox2> * pNew ;
    
    DAComObject<CDABbox2>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDABbox2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDABbox2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRBBOX2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAEvent::Notify(IDAUntilNotifier * arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::Notify(%lx)", this));

    PRIMPRECODE1(ret) ;
    DAComPtr<CRUntilNotifier > arg1VAL((CRUntilNotifier *) WrapCRUntilNotifier(arg1),false);
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::CRNotify((CREvent *) _bvr.p, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAEvent::Snapshot(IDABehavior *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::Snapshot(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CRBvr *)) CRSnapshot , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAEvent::AttachData(IDABehavior *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::AttachData(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CRBvr *)) CRAttachData , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAEvent::ScriptCallback(BSTR arg0, BSTR arg2, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::ScriptCallback(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::ScriptCallback((CREvent *) _bvr.p, /* NOELARG */ arg0, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAEvent::NotifyScript(BSTR arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::NotifyScript(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::NotifyScriptEvent((CREvent *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}



CBvr * CDAEventCreate(IDABehavior ** bvr)
{
    DAComObject<CDAEvent> * pNew ;
    
    DAComObject<CDAEvent>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAEvent *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAEventFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CREVENT_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAUserData::get_Data(IUnknown * * ret)
{
    TraceTag((tagCOMEntry, "CDAUserData::get_Data(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = (::CRGetData((CRUserData *) _bvr.p));
    PRIMPOSTCODE1(ret) ;
}



CBvr * CDAUserDataCreate(IDABehavior ** bvr)
{
    DAComObject<CDAUserData> * pNew ;
    
    DAComObject<CDAUserData>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAUserData *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAUserDataFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRUSERDATA_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\bvrtypes.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    IDABehavior implementation

*******************************************************************************/

#include "headers.h"
#include "cbvr.h"
#include "cview.h"
#include "drawsurf.h"
#include "srvprims.h"
#include "comcb.h"
#include "statics.h"
#include "control/dxactrl.h"
#include "bvrtypes.h"
#include "propanim.h"
#include "results.h"

DeclareTag(tagBvrTypes, "CBvr", "Bvr Types");

//+-------------------------------------------------------------------------
//
//  Initialization
//
//--------------------------------------------------------------------------

DACComModule _Module;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_DAStatics, CDAStatics)
    OBJECT_ENTRY(CLSID_DAView, CView)
    OBJECT_ENTRY(CLSID_DAViewerControl, CDAViewerControlWindowless)
    OBJECT_ENTRY(CLSID_DAViewerControlWindowed, CDAViewerControlWindowed)
END_OBJECT_MAP();

extern _ATL_OBJMAP_ENTRY PrimObjectMap0[];
extern _ATL_OBJMAP_ENTRY PrimObjectMap1[];
extern _ATL_OBJMAP_ENTRY PrimObjectMap2[];

#if DEVELOPER_DEBUG
LONG g_locksSinceLastTick = 0;
LONG g_unlocksSinceLastTick = 0;

LONG
GetLocksSinceLastTick()
{
    return g_locksSinceLastTick;
}

LONG
GetUnlocksSinceLastTick()
{
    return g_unlocksSinceLastTick;
}

void
ResetLockCounts()
{
    g_locksSinceLastTick = 0;
    g_unlocksSinceLastTick = 0;
}

#endif

LONG
DACComModule::Lock()
{
#if DEVELOPER_DEBUG
    InterlockedIncrement(&g_locksSinceLastTick);
#endif

    // Can't depend on value return from Lock to be accurate.  Since
    // the CRConnect can be called multiple times w/o a problem simply
    // check the internal variable to see if it is 0.  This should
    // never cause anything except multiple calls to CRConnect
    
    bool bNeedConnect = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    if (bNeedConnect) {
        CRConnect(hInst);
    }

    return l;
}

LONG
DACComModule::Unlock()
{
#if DEVELOPER_DEBUG
    InterlockedIncrement(&g_unlocksSinceLastTick);
#endif

    LONG l = CComModule::Unlock();
    if (l) return l;
    CRDisconnect(hInst);
    return 0;
}

#if DEVELOPER_DEBUG
typedef map<void *, const char *> ObjectMap;
ObjectMap *objMap = NULL;

void
DACComModule::AddComPtr(void *ptr, const char * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DACComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DACComModule::DumpObjectList()
{
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString ("DANIM.DLL: Detected unfreed COM pointers\n");
            OutputDebugString ("Listing pointers and types:\n");
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                char buf[1024];

                wsprintf(buf, "%#x:", (*i).first);
                OutputDebugString(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString("\n");
            }
        }
             
        LeaveCriticalSection(&m_csObjMap) ;
    }
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}


#endif

#define MAX_OBJECT_MAP_SIZE 50

// Set the max size to something big so we do not have a problem
_ATL_OBJMAP_ENTRY FullObjectMap[MAX_OBJECT_MAP_SIZE + 1];

// =========================================
// Initialization
// =========================================

int
CountObjectMapEntries(_ATL_OBJMAP_ENTRY *objmap)
{
    for (int i = 0;objmap[i].pclsid != NULL;i++) ;

    return i;
}

int
CopyOneMap(int curnum, _ATL_OBJMAP_ENTRY *objmap)
{
    if (objmap) {
        int num = CountObjectMapEntries(objmap);
        int size = num * sizeof (_ATL_OBJMAP_ENTRY);

        Assert ((curnum + num) < MAX_OBJECT_MAP_SIZE);
        
        memcpy(&FullObjectMap[curnum], objmap, size);

        return curnum + num;
    } else {
        Assert (curnum < MAX_OBJECT_MAP_SIZE);
        memset (&FullObjectMap[curnum], 0, sizeof(_ATL_OBJMAP_ENTRY));

        return curnum;
    }
}

void
CreateFullObjectMap()
{
    // Copy base object map
    int curnum = 0;

    curnum = CopyOneMap(curnum, COMObjectMap);
    curnum = CopyOneMap(curnum, PrimObjectMap0);
    curnum = CopyOneMap(curnum, PrimObjectMap1);
    curnum = CopyOneMap(curnum, PrimObjectMap2);
    curnum = CopyOneMap(curnum, NULL); // This will terminate it

    Assert (curnum < MAX_OBJECT_MAP_SIZE);
}

void
InitializeModule_ATL()
{
    // Combine the object entry lists
    CreateFullObjectMap();
    
    _Module.Init(FullObjectMap, hInst);

#if DEVELOPER_DEBUG
    objMap = new ObjectMap;
#endif
}

void
DeinitializeModule_ATL(bool bShutdown)
{
#if DEVELOPER_DEBUG
    DumpCOMObjectList();
    
    delete objMap;
    objMap = NULL;
#endif
    _Module.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\cbvr.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    IDABehavior implementation

Revision:

--*/

#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "comconv.h"

DeclareTag(tagBvr, "CBvr", "CBvr methods");

#pragma warning(disable:4355)  // using 'this' in constructor

//+-------------------------------------------------------------------------
//
//  Method:     CBvr::CBvr
//
//  Synopsis:   Constructor
//
//  Arguments:  Bvr bvr - bvr to wrap
//
//--------------------------------------------------------------------------

CBvr::CBvr()
: _bvr(NULL)
{
    TraceTag((tagBvr, "CBvr(%lx)::CBvr", this));
}


//+-------------------------------------------------------------------------
//
//  Method:     CBvr::~CBvr
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CBvr::~CBvr()
{
    TraceTag((tagBvr, "CBvr(%lx)::~CBvr", this));
}

void
CBvr::SetBvr(CRBvrPtr bvr)
{
    _bvr = bvr;
}

HRESULT
CBvr::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return BvrError(str,hr);
    else
        return hr;
}

HRESULT
CBvr::BvrGetClassName(BSTR * str)
{
    TraceTag((tagBvr,
              "CBvr(%lx)::GetClassName()",
              this));
    
    CHECK_RETURN_SET_NULL(str);
    
    if ((*str = A2BSTR(GetName())) == NULL)
        return E_OUTOFMEMORY;
    
    return S_OK;
}
    
HRESULT
CBvr::BvrInit(IDABehavior *toBvr)
{
    PRIMPRECODE0(ok);

    MAKE_BVR_NAME(crbvr, toBvr);

    ok = CRInit(_bvr, crbvr);

    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrImportance(double relativeImportance,
                    IDABehavior **bvr)
{
    PRIMPRECODE1(bvr);
    
    *bvr = CreateCBvr(CRImportance(_bvr, relativeImportance)) ;
    
    PRIMPOSTCODE1(bvr);
}

HRESULT
CBvr::BvrRunOnce(IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    *bvr = CreateCBvr(CRRunOnce(_bvr));
    PRIMPOSTCODE1(bvr) ;
}
    
HRESULT
CBvr::BvrSubstituteTime(IDANumber *xform,
                        IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;

    MAKE_BVR_TYPE_NAME(CRNumberPtr, xfbvr, xform);

    *bvr = CreateCBvr(CRSubstituteTime(_bvr, xfbvr));
    
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrSwitchTo(IDABehavior *switchTo, bool bOverrideFlags, DWORD dwFlags)
{
    PRIMPRECODE0(ok);

    MAKE_BVR_NAME(crbvr, switchTo);

    ok = CRSwitchTo(_bvr, crbvr, bOverrideFlags, dwFlags, 0);
    
    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrHook(IDABvrHook *notifier, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;

    MAKE_COM_TYPE_NAME(CRBvrHook, crnotifier, WrapCRBvrHook(notifier));

    *bvr = CreateCBvr(CRHook(_bvr, crnotifier));
    
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrDuration(double duration, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    *bvr = CreateCBvr(CRDuration(_bvr, duration));
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrDuration(IDANumber *duration, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    MAKE_BVR_TYPE_NAME(CRNumberPtr, crbvr, duration);
    *bvr = CreateCBvr(CRDuration(_bvr, crbvr));
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrRepeat(long count, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    *bvr = CreateCBvr(::CRRepeat(_bvr, count));
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrRepeatForever(IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    *bvr = CreateCBvr(::CRRepeatForever(_bvr));
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrSwitchToNumber(double numToSwitchTo)
{
    PRIMPRECODE0(ok);
    ok = CRSwitchToNumber((CRNumberPtr) _bvr.p, numToSwitchTo);
    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrSwitchToString(BSTR strToSwitchTo)
{
    PRIMPRECODE0(ok);
    ok = CRSwitchToString((CRStringPtr) _bvr.p, strToSwitchTo);
    PRIMPOSTCODE0(ok);
}

STDMETHODIMP
CBvr::InterfaceSupportsErrorInfo(REFIID riid)
{
    if (InlineIsEqualGUID(riid,IID_IDABehavior) ||
        InlineIsEqualGUID(riid,GetIID()) ||
        InlineIsEqualGUID(riid,IID_IDAImport) ||
        InlineIsEqualGUID(riid,IID_IDAModifiableBehavior) ||
        InlineIsEqualGUID(riid,IID_IDA2Behavior))
        return S_OK;

    return S_FALSE;
}

HRESULT
CBvr::BvrIsReady(VARIANT_BOOL bBlock, VARIANT_BOOL *b)
{
    PRIMPRECODE1(b);
    *b = true;
    PRIMPOSTCODE1(b);
}

HRESULT
CBvr::BvrGetCurrentBvr(IDABehavior ** bvr)
{
    PRIMPRECODE1(bvr);
    Assert (CRIsModifiableBvr(_bvr));
    *bvr = CreateCBvr(CRGetModifiableBvr(_bvr));
    PRIMPOSTCODE1(bvr);
}

HRESULT
CBvr::BvrSetCurrentBvr(VARIANT value)
{
    PRIMPRECODE0(ok);

    Assert (CRIsModifiableBvr(_bvr));

    CRBvrPtr crbvr = VariantToBvr(value,CRGetTypeId(_bvr));
    if (!crbvr) return Error();

    ok = CRSwitchTo(_bvr, crbvr, false, 0, 0);

    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrImportStatus(LONG * status)
{
    PRIMPRECODE(CHECK_RETURN_NULL(status));

    Assert (CRIsImport(_bvr));

    *status = CRImportStatus(_bvr);

    PRIMPOSTCODE(S_OK);
}

HRESULT
CBvr::BvrImportCancel()
{
    PRIMPRECODE0(ok);

    Assert (CRIsImport(_bvr));

    ok = CRImportCancel(_bvr);

    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrGetImportPrio(float * prio)
{
    PRIMPRECODE(CHECK_RETURN_NULL(prio));

    Assert (CRIsImport(_bvr));
    
    *prio = CRGetImportPriority(_bvr);

    PRIMPOSTCODE(S_OK);
}

HRESULT
CBvr::BvrSetImportPrio(float prio)
{
    PRIMPRECODE0(ok);

    Assert (CRIsImport(_bvr));
    
    ok = CRSetImportPriority(_bvr,prio);

    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrApplyPreference(BSTR pref, VARIANT val, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr);
    CRBvrPtr b = CRBvrApplyPreference(_bvr, pref, val);
    *bvr = CreateCBvr(b);
    PRIMPOSTCODE1(bvr);
}


HRESULT
CBvr::BvrExtendedAttrib(BSTR arg1,
                        VARIANT arg2,
                        IDABehavior **ret)
{
    TraceTag((tagCOMEntry, "CBvr::ExtendedAttrib(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRBvr * arg0VAL;
    arg0VAL = (CRBvr *) (_bvr);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDABehavior,
               (CRBvrPtr) (::CRExtendedAttrib(arg0VAL, arg1, arg2)),
               (void **) ret);
    
    PRIMPOSTCODE1(ret) ;
}


HRESULT WINAPI
CBvr::InternalQueryInterface(CBvr* pThis,
                             const _ATL_INTMAP_ENTRY* pEntries,
                             REFIID iid,
                             void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(CBvr))) {
        *ppvObject = pThis->_bvr;
        return S_OK;
    } else if (InlineIsEqualGUID(iid, IID_IDAImport)) {
        if (!CRIsImport(pThis->_bvr))
            return E_NOINTERFACE;
    } else if (InlineIsEqualGUID(iid, IID_IDAModifiableBehavior)) {
        if (!CRIsModifiableBvr(pThis->_bvr))
            return E_NOINTERFACE;
    }
    
    return CComObjectRootEx<CComMultiThreadModelNoCS>::InternalQueryInterface((void *)pThis,
                                                                              pEntries,
                                                                              iid,
                                                                              ppvObject);
}
        
//+-------------------------------------------------------------------------
//
//  Creation function table
//
//--------------------------------------------------------------------------

static list <TypeInfoEntry> * createList = NULL ;

void
AddEntry (TypeInfoEntry & ce)
{
    createList->push_back (ce) ;
}

TypeInfoEntry *
GetTypeInfoEntry (CR_BVR_TYPEID ti)
{
    for (list <TypeInfoEntry>::iterator i = createList->begin() ;
         i != createList->end();
         i++) {

        if (ti == (*i).typeInfo)
            return &(*i) ;
    }

    Assert (!"Tried to use unsupported type.");
    CRSetLastError(E_UNEXPECTED,NULL);
    
    return NULL ;
}

//+-------------------------------------------------------------------------
//
//  Function:     CreateCBvr
//
//--------------------------------------------------------------------------

bool
CreateCBvr(REFIID riid,
           CRBvrPtr bvr,
           void ** ppv)
{
    bool ret = false;
    
    if (bvr) {
        TypeInfoEntry * entry = GetTypeInfoEntry(CRGetTypeId(bvr)) ;

        if (entry) {
            CBvr * c = entry->cbvrCreateFun(NULL);

            if (c) {
                c->SetBvr(bvr);
                
                HRESULT hr = ((IDA2Behavior *) c)->QueryInterface(riid, ppv);
                
                if (FAILED(hr)) {
                    delete c;
                    CRSetLastError(hr, NULL);
                } else {
                    ret = true;
                }
            } else {
                CRSetLastError(E_OUTOFMEMORY, NULL);
            }
        }
    }

    return ret;
}

IDABehavior *
CreateCBvr(CRBvrPtr bvr)
{
    IDABehavior * ret = NULL;
    
    if (bvr) {
        TypeInfoEntry * entry = GetTypeInfoEntry(CRGetTypeId(bvr)) ;

        if (entry) {
            // This is a hack for LM since they expect the full class
            // pointer to be returned when IDABehavior is returned
            CBvr * c = entry->cbvrCreateFun(&ret);

            if (c) {
                c->SetBvr(bvr);

                Assert (ret);
                ret->AddRef();
            } else {
                CRSetLastError(E_OUTOFMEMORY, NULL);
            }
        }
    } else {
        CRSetLastError(E_INVALIDARG, NULL);
    }

    return ret;
}

CRBvrPtr GetBvr(IUnknown * pbvr)
{
    CRBvrPtr bvr = NULL;

    if (pbvr) {
        pbvr->QueryInterface(__uuidof(CBvr),(void **)&bvr);
    }
    
    if (bvr == NULL) {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}

CRSTDAPI_(bool)
CRBvrToCOM(CRBvrPtr bvr,
           REFIID riid,
           void ** ppv)
{
    if (!ppv) {
        CRSetLastError(E_POINTER, NULL);
        return false;
    }

    *ppv = NULL;
    
    if (bvr == NULL) {
        CRSetLastError(E_INVALIDARG, NULL);
        return false;
    }

    return CreateCBvr(riid, bvr, ppv);
}

CRSTDAPI_(CRBvrPtr)
COMToCRBvr(IUnknown * pbvr)
{
    return GetBvr(pbvr);
}

extern void InitClasses0();
extern void InitClasses1();
extern void InitClasses2();

void
InitializeModule_CBvr()
{
    createList = NEW list <TypeInfoEntry> ;
    InitClasses0 () ;
    InitClasses1 () ;
    InitClasses2 () ;
}

void
DeinitializeModule_CBvr(bool bShutdown)
{
    delete createList ;
    createList = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\comcb.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMCB_H
#define _COMCB_H

CRUntilNotifierPtr WrapCRUntilNotifier(IDAUntilNotifier * notifier);
CRUntilNotifierPtr WrapScriptCallback(BSTR function, BSTR language);

CRBvrHookPtr WrapCRBvrHook(IDABvrHook *hook);

// Call arbitrary script on the current HTML page.
HRESULT CallScriptOnPage(BSTR scriptSourceToInvoke,
                         BSTR scriptLanguage,
                         VARIANT *retVal);

CRBvrPtr UntilNotifyScript(CRBvrPtr b0,
                           CREventPtr event,
                           BSTR scriptlet);

CREventPtr NotifyScriptEvent(CREventPtr event,
                             BSTR scriptlet);

CREventPtr ScriptCallback(BSTR function,
                          CREventPtr event,
                          BSTR language);

// This is because we expect the this pointer to be first
inline CREventPtr ScriptCallback(CREventPtr event,
                                 BSTR function,
                                 BSTR language)
{ return ScriptCallback(function, event, language); }

#endif /* _COMCB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\comconv.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMCONV_H
#define _COMCONV_H

inline bool BOOLTobool(VARIANT_BOOL b) { return b?TRUE:FALSE ; }
inline VARIANT_BOOL boolToBOOL(bool b) { return (VARIANT_BOOL) b ; }

inline BSTR StringToBSTR(RawString str) { return A2BSTR(str) ; }

inline BSTR WideStringToBSTR(WideString str) { return W2BSTR(str) ; }

enum ARRAYFILL {
    ARRAYFILL_NONE,
    ARRAYFILL_DOUBLE,
    ARRAYFILL_FLOAT,
};

CRBvrPtr RateToNumBvr(CRBvrPtr b,CRBvrPtr bStart = NULL);
CRBvrPtr RateToNumBvr(double d);

CRBvrPtr ScaleRateToNumBvr(double d);
inline double DegreesToNum(double d) {
    return ((d * pi) / 180.0);
}

CRBvrPtr RateDegreesToNumBvr(double d);

extern double pixelConst;
extern CRNumberPtr pointCnv;
extern CRNumberPtr negPixel;

CRBvrPtr PixelToNumBvr(CRBvrPtr b);
CRBvrPtr PixelToNumBvr(double d);

CRBvrPtr PixelYToNumBvr(CRBvrPtr b);
CRBvrPtr PixelYToNumBvr(double d);

CRBvrPtr PointToNumBvr(double d);
inline double PointToNum(double d) {
    return d * METERS_PER_POINT;
}
CRBvrPtr PointToNumBvr(CRBvrPtr b);

#define CBvrsToBvrs(size, cbvrs) \
    _CBvrsToBvrs(size, (IDABehavior **)cbvrs, (CRBvrPtr *) _alloca(size * sizeof(CRBvrPtr)))

CRBvrPtr * _CBvrsToBvrs(long size, IDABehavior *pCBvrs[], CRBvrPtr * bvrs);

CRArrayPtr ToArrayBvr(long size,
                      IDABehavior *pCBvrs[],
                      DWORD dwFlags = 0);

class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool bPixelMode = false,
                      CR_BVR_TYPEID ti = CRUNKNOWN_TYPEID,
                      bool allowNullArray = false,
                      bool allowNullEntries = false);
    ~SafeArrayAccessor();

    void * GetArray() { return _v;}
    unsigned int GetArraySize() { return _ubound - _lbound + 1; }
    unsigned int GetNumObjects() { return _numObjects; }

    CRArrayPtr ToArrayBvr(DWORD dwFlags, 
                          ARRAYFILL toFill = ARRAYFILL_NONE,
                          void **fill = NULL, 
                          unsigned int *count = NULL);
    CRBvrPtr * ToBvrArray(CRBvrPtr *bvrArray);

    int *ToIntArray();

    bool IsNullArray() {
        return (_s == NULL || _numObjects == 0);
    }
    
    bool IsOK() { return _inited; }
  protected:
    enum SATYPE {
        SAT_OBJECT = 0,
        SAT_NUMBER = 1,
        SAT_POINT2 = 2,
        SAT_POINT3 = 3,
        SAT_VECTOR2= 4,
        SAT_VECTOR3= 5,
    };
    
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        double * _pDbl;
        IUnknown ** _ppUnk;
        void *_v;
    };
    
    SATYPE _type;
    VARTYPE _vt;
    CR_BVR_TYPEID _ti;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    unsigned int _numObjects;
    CComVariant _retVar;
    bool _bPixelMode;
    bool _entriesCanBeNull;
};

CRArrayPtr SrvArrayBvr(VARIANT & v,
                       bool bPixelMode = false,
                       CR_BVR_TYPEID ti = CRUNKNOWN_TYPEID,
                       DWORD dwFlags = 0,
                       ARRAYFILL toFill = ARRAYFILL_NONE,
                       void **fill = NULL, 
                       unsigned int *count = NULL);

CRBvrPtr VariantToBvr(VARIANT & v, CR_BVR_TYPEID ti = CRUNKNOWN_TYPEID);

template <class T>
class CRPtr
{
  public:
    typedef T _PtrClass;
    CRPtr() { p = NULL; }
    CRPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    CRPtr(const CRPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    ~CRPtr() {
        CRReleaseGC(p);
    }
    void Release() {
        CRReleaseGC(p);
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const CRPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            CRAddRefGC(lp);

        CRReleaseGC(p);

        p = lp;

        return lp;
    }
};

#endif /* _COMCONV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\comconv.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#include "headers.h"
#include "comconv.h"
#include "cbvr.h"

CRBvrPtr
RateToNumBvr(CRBvrPtr d, CRBvrPtr bStart)
{
    CRNumberPtr b = NULL;

    if (d) {
        b = CRMul((CRNumberPtr) d, CRLocalTime());

        if (b && bStart) {
            b = CRAdd(b,(CRNumberPtr)bStart);
        }
    }

    return (CRBvrPtr) b;
}

CRBvrPtr
PixelToNumBvr(double d)
{
    if (pixelConst != 0.0) {
        return (CRBvrPtr) CRCreateNumber(PixelToNum(d));
    } else {
        return PixelToNumBvr((CRBvrPtr) CRCreateNumber(d));
    }
}

CRBvrPtr
PixelYToNumBvr(double d)
{
    if (pixelConst != 0.0) {
        return (CRBvrPtr) CRCreateNumber(PixelYToNum(d));
    } else {
        return PixelYToNumBvr((CRBvrPtr) CRCreateNumber(d));
    }
}

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool bPixelMode,
                                     CR_BVR_TYPEID ti,
                                     bool canBeNull,
                                     bool entriesCanBeNull)
: _inited(false),
  _ti(ti),
  _bPixelMode(bPixelMode),
  _isVar(false),
  _s(NULL),
  _entriesCanBeNull(entriesCanBeNull),
  _numObjects(0)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _numObjects = 0;
                _inited = true;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LOCALE_USER_DEFAULT,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // If it is an object then we know how to handle it
    if (IS_VARTYPE(pVar,VT_UNKNOWN) ||
        IS_VARTYPE(pVar,VT_DISPATCH)) {
        _type = SAT_OBJECT;
        _vt = VT_UNKNOWN;
    } else {
        switch (ti) {
          case CRNUMBER_TYPEID: 
            _type = SAT_NUMBER;
            _vt = VT_R8;
            break;
          case CRPOINT2_TYPEID:
          case CRVECTOR2_TYPEID:
            _type = SAT_POINT2;
            _vt = VT_R8;
            break;
          case CRPOINT3_TYPEID:
          case CRVECTOR3_TYPEID:
            _type = SAT_POINT3;
            _vt = VT_R8;
            break;
          default:
            _type = SAT_OBJECT;
            _vt = VT_UNKNOWN;
            break;
        }

        // If it is a variant then just delay the check
        if (IS_VARIANT(pVar))
            _isVar = true;
        // Check the type to see if it is one of the options
        else if (!IS_VARTYPE(pVar,_vt)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        if (GetArraySize() > 0) {
            // Check the first argument to see its type
            // If it is not an object then we assume we will need to
            // use the alternative type.

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (IS_VARTYPE(pVar,VT_UNKNOWN) ||
                IS_VARTYPE(pVar,VT_DISPATCH)) {
                _type = SAT_OBJECT;
                _vt = VT_UNKNOWN;
            }
        } else {
            // If we have no elements then just assume they were objects
            _type = SAT_OBJECT;
            _vt = VT_UNKNOWN;
        }
    }

    int ElmsPerObject;
    
    switch (_type) {
      default:
        ElmsPerObject = 1;
        break;
      case SAT_POINT2:
        ElmsPerObject = 2;
        break;
      case SAT_POINT3:
        ElmsPerObject = 3;
        break;
    }

    _numObjects = GetArraySize() / ElmsPerObject;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

CRBvrPtr *
SafeArrayAccessor::ToBvrArray(CRBvrPtr *bvrArray)
{
    HRESULT hr;
    int i;

    if (!_inited){
        CRSetLastError(DISP_E_TYPEMISMATCH, NULL);
        goto Error;
    }
    
    if (!bvrArray) {
        CRSetLastError(E_OUTOFMEMORY, NULL);
        goto Error;
    }
    
    for (i = 0; i < _numObjects; i++) {
        CRBvrPtr bvr;
        
        switch (_type) {
          case SAT_OBJECT:
            {
                IUnknown * punk;
                
                if (_isVar) {
                    CComVariant var;

                    if (IS_VARTYPE(&_pVar[i], VT_NULL) ||
                        IS_VARTYPE(&_pVar[i], VT_EMPTY)) {
                        
                        punk = NULL;
                        
                    } else {
                        
                        HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                    
                        if (FAILED(hr)) {
                            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                            goto Error;
                        }
                    
                        punk = var.punkVal;
                        
                    }
                    
                } else {
                    punk = _ppUnk[i];
                }

                if (punk == NULL && _entriesCanBeNull) {

                    bvr = NULL;
                    
                } else {
                    
                    bvr = GetBvr(punk);

                    if (bvr == NULL) {
                        // Error code is already set
                        goto Error;
                    }
                
                    if (_ti != CRUNKNOWN_TYPEID && CRGetTypeId(bvr) != _ti) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                }

                break;
            }
          case SAT_NUMBER:
            {
                double dbl;
                
                if (_isVar) {
                    CComVariant num;
                    
                    hr = num.ChangeType(VT_R8, &_pVar[i]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }

                    dbl = num.dblVal;
                } else {
                    dbl = _pDbl[i];
                }
                
                bvr = (CRBvrPtr) CRCreateNumber(dbl);

                if (bvr == NULL) {
                    // Error code is already set
                    goto Error;
                }
                
                break;
            }
          case SAT_POINT2:
            {
                double x,y;
                
                if (_isVar) {
                    CComVariant ptx,pty;
                    
                    hr = ptx.ChangeType(VT_R8, &_pVar[i * 2]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                    
                    hr = pty.ChangeType(VT_R8, &_pVar[i * 2 + 1]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                    
                    x = ptx.dblVal;
                    y = pty.dblVal;
                } else {
                    x = _pDbl[i * 2];
                    y = _pDbl[i * 2 + 1];
                }
                
                if (_bPixelMode) {
                    if (_ti==CRPOINT2_TYPEID) {
                        if (pixelConst != 0.0) {
                            bvr = (CRBvrPtr) CRCreatePoint2(PixelToNum(x),
                                                            PixelYToNum(y));
                        } else {
                            bvr = (CRBvrPtr) CRCreatePoint2((CRNumberPtr) PixelToNumBvr(x),
                                                            (CRNumberPtr) PixelYToNumBvr(y));
                        }
                    } else {
                        if (pixelConst != 0.0) {
                            bvr = (CRBvrPtr) CRCreateVector2(PixelToNum(x),
                                                             PixelYToNum(y));
                        } else {
                            bvr = (CRBvrPtr) CRCreateVector2((CRNumberPtr) PixelToNumBvr(x),
                                                             (CRNumberPtr) PixelYToNumBvr(y));
                        } 
                    }
                } else {
                    if (_ti==CRPOINT2_TYPEID) {
                        bvr = (CRBvrPtr) CRCreatePoint2(x,y);
                    } else {
                        bvr = (CRBvrPtr) CRCreateVector2(x,y);
                    }
                }

                if (bvr == NULL) {
                    goto Error;
                }
                
                break;
            }
          case SAT_POINT3:
            {
                double x,y,z;
                
                if (_isVar) {
                    CComVariant ptx,pty,ptz;
                    
                    hr = ptx.ChangeType(VT_R8, &_pVar[i * 3]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }

                    hr = pty.ChangeType(VT_R8, &_pVar[i * 3 + 1]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                    
                    hr = ptz.ChangeType(VT_R8, &_pVar[i * 3 + 2]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                    
                    x = ptx.dblVal;
                    y = pty.dblVal;
                    z = ptz.dblVal;
                } else {
                    x = _pDbl[i * 3];
                    y = _pDbl[i * 3 + 1];
                    z = _pDbl[i * 3 + 2];
                }

                if (_ti==CRPOINT3_TYPEID) {
                    bvr = (CRBvrPtr) CRCreatePoint3(x,y,z);
                } else {
                    bvr = (CRBvrPtr) CRCreateVector3(x,y,z);
                }
                
                if (bvr == NULL) {
                    // Error code is already set
                    goto Error;
                }
                
                break;
            }
          default:
            Assert (!"Invalid type in ToBvrArray");
            CRSetLastError(E_FAIL,NULL);
            goto Error;
        }

        bvrArray[i] = bvr;
    }

    return bvrArray;
    
  Error:
    return NULL;
}

CRArrayPtr
SafeArrayAccessor::ToArrayBvr(DWORD dwFlags,
                              ARRAYFILL toFill,
                              void **fill, 
                              unsigned int *count)
{
    // Clear the fill return values.

    if (fill)  *fill = NULL;
    if (count) *count = 0;

    if (!_inited){
        CRSetLastError(DISP_E_TYPEMISMATCH, NULL);
        return NULL;
    }
    
    unsigned int len = GetArraySize();
    
    if (count) *count = len;

    // See if we can optimize the construction of the array
    // If not then just use the ToBvrArray mechanism

    if ((dwFlags & CR_ARRAY_CHANGEABLE_FLAG) ||
        _ti == CRUNKNOWN_TYPEID ||
        _type == SAT_OBJECT ||
        ((_type == SAT_POINT2 || _type == SAT_VECTOR2)
         && pixelConst == 0.0)) {

        CRBvrPtr * arr = (CRBvrPtr *) _alloca(_numObjects * sizeof (CRBvrPtr));

        if (arr == NULL || !ToBvrArray(arr))
            return NULL;

        return CRCreateArray(_numObjects, arr, dwFlags);
    }


    HRESULT hr;
    
    double * dblArray = NULL;
    if (toFill == ARRAYFILL_NONE) {
        dblArray = NEW double[len];
        if (!dblArray) {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto Error;
        }
    } else {
        if (toFill == ARRAYFILL_DOUBLE) {
            dblArray = NEW double[len];
            *fill = (void *) dblArray;
        } else {
            *fill = (void *) NEW float[len]; 
        }
        if (!*fill) {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto Error;
        }
    }

    if (_type == SAT_POINT2 && _bPixelMode) {
        for (int i = 0; i < _numObjects; i++) {
            double x,y;
                
            if (_isVar) {
                CComVariant ptx,pty;
                
                hr = ptx.ChangeType(VT_R8, &_pVar[i * 2]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    goto Error;
                }
                    
                hr = pty.ChangeType(VT_R8, &_pVar[i * 2 + 1]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    goto Error;
                }
                    
                x = ptx.dblVal;
                y = pty.dblVal;
            } else {
                x = _pDbl[i * 2];
                y = _pDbl[i * 2 + 1];
            }
            
            if (toFill == ARRAYFILL_FLOAT) {
                float *d = (float *) (*fill);
                d[i * 2] = PixelToNum(x);
                d[i * 2 + 1] = PixelYToNum(y);
            } else {
                dblArray[i * 2] = PixelToNum(x);
                dblArray[i * 2 + 1] = PixelYToNum(y);
            }
        }
    } else {
        for (int i = 0; i < len; i++) {
            double dbl;
                
            if (_isVar) {
                CComVariant num;
                
                hr = num.ChangeType(VT_R8, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    goto Error;
                }
                    
                dbl = num.dblVal;
            } else {
                dbl = _pDbl[i];
            }

            if (toFill==ARRAYFILL_FLOAT) {
                float *d = (float *) (*fill);
                d[i] = dbl;
            } else {
                dblArray[i] = dbl;
            }          
        }
    }

    {
        if (toFill==ARRAYFILL_NONE) {
            CRArrayPtr arr = CRCreateArray(len, dblArray, _ti);
        
            delete [] dblArray;

            return arr;
        }
    }
    
  Error:
    return NULL;
}

int *
SafeArrayAccessor::ToIntArray()
{
    unsigned int len = GetArraySize();

    int *intArray = NEW int[len];
    if (!intArray) {
        CRSetLastError(E_OUTOFMEMORY, NULL);
        return NULL;
    }
        
    for (unsigned int i = 0; i < len; i++) {
        if (_isVar) {
            CComVariant num;
                
            HRESULT hr = num.ChangeType(VT_I4, &_pVar[i]);
                
            if (FAILED(hr)) {
                CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                return NULL;
            }
                    
            intArray[i] = num.intVal;
        } 
    }

    return intArray;
}

CRBvrPtr
VariantToBvr(VARIANT & v, CR_BVR_TYPEID ti)
{
    VARIANT *pVar;
    CRBvrPtr bvr = NULL;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // If it is an object then we know how to handle it
    if (V_VT(pVar) == VT_UNKNOWN ||
        V_VT(pVar) == VT_DISPATCH) {
        CComVariant var;
                    
        if (FAILED(var.ChangeType(VT_UNKNOWN, pVar))) {
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
            goto Error;
        }
                    
        bvr = GetBvr(V_UNKNOWN(&var));

        if (bvr == NULL) {
            // Error code is already set
            goto Error;
        }
                
        if (ti != CRUNKNOWN_TYPEID && CRGetTypeId(bvr) != ti) {
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
            goto Error;
        }

        // Fall through
    } else {
        VARTYPE vt;
        
        switch (ti) {
          case CRNUMBER_TYPEID: 
            vt = VT_R8;
            break;
          case CRSTRING_TYPEID:
            vt = VT_BSTR;
            break;
          case CRBOOLEAN_TYPEID:
            vt = VT_BOOL;
            break;
          case CRUNKNOWN_TYPEID:
            vt = GET_VT(pVar);

            // If it is not a bool or bstr and we do not know what
            // type we want - convert it to a number
            // This is kind of arbitrary but we should not really be
            // asked to do this

            if (vt != VT_BSTR && vt != VT_BOOL)
                vt = VT_R8;

            break;
          default:
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
            goto Error;
        }

        CComVariant var;

        if (FAILED(var.ChangeType(vt, pVar))) {
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
            goto Error;
        }
        
        switch (vt) {
          case VT_R8:
            bvr = (CRBvrPtr) CRCreateNumber(V_R8(&var));
            break;
          case VT_BOOL:
            bvr = (CRBvrPtr) CRCreateBoolean(V_BOOL(&var)?true:false);
            break;
          case VT_BSTR:
            bvr = (CRBvrPtr) CRCreateString(V_BSTR(&var));
            break;
          default:
            Assert (!"Invalid type in VariantToBvr");
        }
    }

    return bvr;

  Error:
    
    return NULL;
}

CRBvrPtr *
_CBvrsToBvrs(long size, IDABehavior *pCBvrs[], CRBvrPtr * bvrs)
{
    if (bvrs == NULL) {
        CRSetLastError(E_OUTOFMEMORY,NULL);
    } else {
        for (int i=0; i<size; i++) {
            bvrs[i] = GetBvr(pCBvrs[i]);
        }
    }

    return bvrs;
}

CRArrayPtr
ToArrayBvr(long size, IDABehavior *pCBvrs[], DWORD dwFlags)
{
    if (size == 0)
    {
        CRSetLastError(E_INVALIDARG,NULL);
        return NULL;
    }
    
    CRBvrPtr * bvrs = CBvrsToBvrs(size, pCBvrs);

    if (bvrs == NULL)
        return NULL;

    return CRCreateArray(size, bvrs, dwFlags);
}

CRArrayPtr SrvArrayBvr(VARIANT & v,
                       bool bPixelMode,
                       CR_BVR_TYPEID ti,
                       DWORD dwFlags,
                       ARRAYFILL toFill,
                       void **fill,
                       unsigned int *count)
{
    CRArrayPtr result = NULL;

    // See if an IDAArray is coming in, if so, just use it.
    // Otherwise, need to access the SafeArray.
    
    CComVariant var;
    
    if (SUCCEEDED(var.ChangeType(VT_UNKNOWN, &v))) {
        CRBvrPtr bvr = GetBvr(V_UNKNOWN(&var));
    
        if (bvr != NULL &&
            CRGetTypeId(bvr) == CRARRAY_TYPEID) {

            if (ti == CRUNKNOWN_TYPEID || CRGetArrayTypeId(bvr) == ti) {
                result = (CRArrayPtr) bvr;
            }
        }
    }

    if (!result) {
        SafeArrayAccessor acc(v,bPixelMode,ti);

        if (acc.IsOK()) {
            result = acc.ToArrayBvr(dwFlags,toFill,fill,count);
        }
    }
    
    return result;
}

CRBvrPtr RateToNumBvr(double d)
{ return RateToNumBvr((CRBvrPtr) CRCreateNumber(d)); }

CRBvrPtr ScaleRateToNumBvr(double d)
{ return RateToNumBvr((CRBvrPtr) CRCreateNumber(d),
                      (CRBvrPtr) CRCreateNumber(1)); }

CRBvrPtr RateDegreesToNumBvr(double d) {
    return RateToNumBvr(DegreesToNum(d));
}

CRBvrPtr PixelToNumBvr(CRBvrPtr b) {
    return (CRBvrPtr) CRMul((CRNumberPtr)b,CRPixel());
}

CRBvrPtr PixelYToNumBvr(CRBvrPtr b)
{ return (CRBvrPtr) CRMul((CRNumberPtr) b,negPixel); }

CRBvrPtr PointToNumBvr(double d) {
    return (CRBvrPtr) CRCreateNumber(d * METERS_PER_POINT);
}

CRBvrPtr PointToNumBvr(CRBvrPtr b) {
    return (CRBvrPtr) CRMul((CRNumberPtr) b, pointCnv);
}

CRNumberPtr pointCnv = NULL;
double pixelConst = 0.0;
double meterConst = 0.0;
CRNumberPtr negPixel = NULL;

void
InitializeModule_COMConv()
{
    pointCnv = CRCreateNumber(METERS_PER_POINT);
    if (CRIsConstantBvr((CRBvrPtr) CRPixel())) {
        pixelConst = CRExtract(CRPixel());
        if (pixelConst) {
            meterConst = 1 / pixelConst;
        }
    }
    negPixel = (pixelConst != 0)?CRCreateNumber(-1 * pixelConst):CRMul(CRCreateNumber(-1),CRPixel());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\cdrawsur.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of DrawingSurface.

*******************************************************************************/

#include "headers.h"
#include "engine.h"
#include "drawsurf.h"
#include "privinc/resource.h"
#include "privinc/util.h"

// -------------------------------------------------------
// CDADrawingSurface
// -------------------------------------------------------

CDADrawingSurface::CDADrawingSurface()
{
    _st = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDADrawingSurface::~CDADrawingSurface
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CDADrawingSurface::~CDADrawingSurface()
{
    // Pop the stack till it's empty.
    DrawingContext *dc;
    while (!_ctxStack.empty()) {
        dc = _ctxStack.top();
        _ctxStack.pop();
        delete dc;
    }
    CleanUpImgVec();
}

void CDADrawingSurface::CleanUpImgVec() {

    // Release the images in _imgVec.
    vector<IDAImage *>::iterator begin = _imgVec.begin();
    vector<IDAImage *>::iterator end = _imgVec.end();

    vector<IDAImage *>::iterator i;
    for (i = begin; i < end; i++) {
        (*i)->Release();
    }
    _imgVec.clear();
}

HRESULT CDADrawingSurface::Init(IDAStatics *st)
{
    if (_st && _ctxStack.empty() && _imgVec.empty()) {
        Assert(FALSE && "Init called twice");
        return E_ABORT;
    }

    DrawingContext *dc = new DrawingContext(st, this);
    if (dc == NULL) {
        return E_OUTOFMEMORY;
    }

    _ctxStack.push(dc);
    _st = st;
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::SaveGraphicsState()
{
    DrawingContext *dcNew = NULL, *dc = GetCurrentContext();
    dcNew = new DrawingContext(_st, this, dc);
    _ctxStack.push(dcNew);

    if (dcNew == NULL)
        return E_OUTOFMEMORY;
    else
        return S_OK;
}

STDMETHODIMP CDADrawingSurface::RestoreGraphicsState()
{
    // Never restore more GraphicsState than we have saved.
    // Always keep at least one DrawingContext on the stack.

    if (_ctxStack.size() > 1) {
        DrawingContext *dc = GetCurrentContext();
        _ctxStack.pop();
        delete dc;
    }

    return S_OK;
}

HRESULT CDADrawingSurface::OverlayImages(vector<IDAImage *> &imgVec,
                                         IDAImage **ppimg)
{
    CHECK_RETURN_SET_NULL(ppimg);

    HRESULT hr;

    int size = imgVec.size();
    if (size == 0) {
        hr = _st->get_EmptyImage(ppimg);
    } else if (size == 1) {
        *ppimg = imgVec.front();
        (*ppimg)->AddRef();
        hr = S_OK;
    } else {

        IDAImage** imgArr = new IDAImage*[size];

        if (imgArr != NULL) {
            vector<IDAImage *>::iterator begin = imgVec.begin();
            vector<IDAImage *>::iterator end = imgVec.end();

            vector<IDAImage *>::iterator i = begin;

            for (int j = size-1; i < end; i++, j--) {
                imgArr[j] = *i;
            }
            hr = _st->OverlayArrayEx(size, imgArr, ppimg);
            delete imgArr;
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

STDMETHODIMP CDADrawingSurface::get_Image(IDAImage ** ppImg)
{
    return OverlayImages(_imgVec, ppImg);
}

DrawingContext *CDADrawingSurface::GetCurrentContext()
{
    return _ctxStack.top();
}

STDMETHODIMP CDADrawingSurface::get_LocalContextImage(IDAImage ** ppImg)
{
    return OverlayImages(GetCurrentContext()->imgVec(), ppImg);
}

STDMETHODIMP CDADrawingSurface::put_LineStyle(IDALineStyle *ls)
{
    CHECK_RETURN_NULL(ls);
    
    GetCurrentContext()->SetLineStyle(ls);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_BorderStyle(IDALineStyle *bs)
{
    CHECK_RETURN_NULL(bs);
    GetCurrentContext()->SetBorderStyle(bs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_FontStyle(IDAFontStyle *fs)
{
    CHECK_RETURN_NULL(fs);
    GetCurrentContext()->SetFontStyle(fs);
    return S_OK;
}

// Fill Type selection methods 
STDMETHODIMP CDADrawingSurface::TextureFill(IDAImage *img, double startx, double starty)
{
    CHECK_RETURN_NULL(img);

    // Calculate lower left position
    CComPtr<IDAImage> temp;
    CComPtr<IDATransform2> xf;
    CComPtr<IDABbox2> bb;
    CComPtr<IDAPoint2> max,min;
    CComPtr<IDANumber> minX,minY, sX,sY, newX, newY;       
    
    RETURN_IF_ERROR(img->get_BoundingBox(&bb)) 
    RETURN_IF_ERROR(bb->get_Min(&min))
    RETURN_IF_ERROR(min->get_X(&minX))
    RETURN_IF_ERROR(min->get_Y(&minY))
    RETURN_IF_ERROR(_st->DANumber(startx,&sX))
    RETURN_IF_ERROR(_st->DANumber(starty,&sY))

    RETURN_IF_ERROR(_st->Sub(sX, minX, &newX))
    RETURN_IF_ERROR(_st->Sub(sY, minY, &newY))               

    RETURN_IF_ERROR(_st->Translate2Anim(newX, newY, &xf))
    img->Transform(xf, &temp);
    GetCurrentContext()->SetFillStyle(fill_texture);
    GetCurrentContext()->SetTexture(temp);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::FillTexture(IDAImage *img)
{
    CHECK_RETURN_NULL(img);
    GetCurrentContext()->SetFillStyle(fill_texture);
    GetCurrentContext()->SetTexture(img);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::ImageFill(IDAImage *img, double startx, double starty)
{
    CHECK_RETURN_NULL(img);

    TextureFill(img,startx,starty);
    // Override the texture style by setting it to image fill
    GetCurrentContext()->SetFillStyle(fill_image);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::FillImage(IDAImage *img)
{
    CHECK_RETURN_NULL(img);
    GetCurrentContext()->SetFillStyle(fill_image);
    GetCurrentContext()->SetTexture(img);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::FillStyle(int ID)
{
    if((ID<0) || (ID>15))
        ID=0;
    GetCurrentContext()->SetFillStyle(ID);
    return S_OK;
}



STDMETHODIMP CDADrawingSurface::FillColor(IDAColor *foreground)
{
    CHECK_RETURN_NULL(foreground);
    GetCurrentContext()->SetForeColor(foreground);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::SecondaryFillColor(IDAColor *val)
{
    CHECK_RETURN_NULL(val);
    GetCurrentContext()->SetBackColor(val);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::GradientShape(VARIANT pts)
{    
    return GetCurrentContext()->SetGradientShape(pts);
}

STDMETHODIMP CDADrawingSurface::GradientExtent(double startx, double starty, double finishx, double finishy)
{
    CComPtr<IDAPoint2> startPt, finishPt;
    RETURN_IF_ERROR(_st->Point2(startx, starty, &startPt))
    RETURN_IF_ERROR(_st->Point2(finishx, finishy, &finishPt))
    GetCurrentContext()->SetGradientExtent(startPt, finishPt);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::GradientExtentPoints(IDAPoint2 *start, IDAPoint2 *stop)
{
    CHECK_RETURN_NULL(start);
    CHECK_RETURN_NULL(stop);
    
    GetCurrentContext()->SetGradientExtent(start, stop);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::GradientRolloffPower(double power)
{
    CComPtr<IDANumber> pow;
    RETURN_IF_ERROR(_st->DANumber(power, &pow))
    GetCurrentContext()->SetGradientRolloffPower(pow);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::GradientRolloffPowerAnim(IDANumber *power)
{
    CHECK_RETURN_NULL(power);
    GetCurrentContext()->SetGradientRolloffPower(power);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::FixedFillScale()
{
    GetCurrentContext()->SetXScaling(false);
    GetCurrentContext()->SetYScaling(false);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::HorizontalFillScale()
{
    GetCurrentContext()->SetXScaling(true);
    GetCurrentContext()->SetYScaling(false);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::VerticalFillScale()
{
    GetCurrentContext()->SetXScaling(false);
    GetCurrentContext()->SetYScaling(true);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::AutoSizeFillScale()
{
    GetCurrentContext()->SetXScaling(true);
    GetCurrentContext()->SetYScaling(true);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::Opacity(double op)
{
    IDANumber *opAnim;
    RETURN_IF_ERROR(_st->DANumber(op, &opAnim))

    return OpacityAnim(opAnim);
}

STDMETHODIMP CDADrawingSurface::OpacityAnim(IDANumber *op)
{
    CHECK_RETURN_NULL(op);
    GetCurrentContext()->SetOpacity(op);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_ClipMatte(IDAMatte *matte)
{
    CHECK_RETURN_NULL(matte);
    GetCurrentContext()->SetClip(matte);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_MouseEventsEnabled(VARIANT_BOOL on)
{
    GetCurrentContext()->SetMouseEventsEnabled(on?true:false);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_HatchFillTransparent(VARIANT_BOOL on)
{
    GetCurrentContext()->SetHatchFill(on?true:false);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::CropPoints(IDAPoint2 *min, IDAPoint2 *max)
{
    CHECK_RETURN_NULL(min);
    CHECK_RETURN_NULL(max);
    GetCurrentContext()->SetCrop(min, max);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::Crop(double minX, double minY, double maxX, double maxY)
{
    CComPtr<IDAPoint2> minPt, maxPt;
    RETURN_IF_ERROR(_st->Point2(minX, minY, &minPt))
    RETURN_IF_ERROR(_st->Point2(maxX, maxY, &maxPt))
    return CropPoints(minPt, maxPt);
}

STDMETHODIMP CDADrawingSurface::Transform(IDATransform2 *xf)
{
    CHECK_RETURN_NULL(xf);
    return GetCurrentContext()->Transform(xf);
}

STDMETHODIMP CDADrawingSurface::Reset()
{
    return GetCurrentContext()->Reset();
}

STDMETHODIMP CDADrawingSurface::Clear()
{
    HRESULT hr = GetCurrentContext()->Reset();
    if (SUCCEEDED(hr)) {
        GetCurrentContext()->CleanUpImgVec();
        CleanUpImgVec();
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CDADrawingSurface::PolylineEx(LONG numPts, IDAPoint2 *pts[])
{
    CHECK_RETURN_NULL(pts);
    
    CComPtr<IDAPath2> pth;
    RETURN_IF_ERROR(_st->PolylineEx(numPts, pts, &pth))
    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::Polyline(VARIANT pts)
{
    CComPtr<IDAPath2> pth;
    RETURN_IF_ERROR(_st->Polyline(pts, &pth))
    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::PolygonEx(LONG numPts, IDAPoint2 *pts[])
{
    CHECK_RETURN_NULL(pts);

    CComPtr<IDAPath2> pth, closedPth;
    RETURN_IF_ERROR(_st->PolylineEx(numPts, pts, &pth))
    RETURN_IF_ERROR(pth->Close(&closedPth))
    return GetCurrentContext()->Draw(closedPth, true);
}

STDMETHODIMP CDADrawingSurface::Polygon(VARIANT pts)
{
    CComPtr<IDAPath2> pth, closedPth;
    RETURN_IF_ERROR(_st->Polyline(pts, &pth))
    RETURN_IF_ERROR(pth->Close(&closedPth))
    return GetCurrentContext()->Draw(closedPth, true);
}

STDMETHODIMP CDADrawingSurface::LinePoints(IDAPoint2 *p1, IDAPoint2 *p2)
{
    CHECK_RETURN_NULL(p1);
    CHECK_RETURN_NULL(p2);
    CComPtr<IDAPath2> pth;
    RETURN_IF_ERROR(_st->Line(p1, p2, &pth))
    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::Line(double startX, double startY,
                      double endX, double endY)
{
    CComPtr<IDAPoint2> startPt, endPt;
    RETURN_IF_ERROR(_st->Point2(startX, startY, &startPt))
    RETURN_IF_ERROR(_st->Point2(endX, endY, &endPt))
    return LinePoints(startPt, endPt);
}

// The passed in xRadius and yRadius is the half width and half height of
// the bounding ellipse.
STDMETHODIMP CDADrawingSurface::ArcRadians(double x, double y, double startAngle, double endAngle, double width, double height)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->ArcRadians(startAngle, endAngle, width, height, &pthTemp))

    // The passed in x, y is the lower left corner of the bounding ellipse.
    // We'll move it from (-width/2, -height/2) to (x, y)
    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))

    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::ArcDegrees(double x, double y, double startAngle, double endAngle, double width, double height)
{
    double startAngleRadian = startAngle * degToRad;
    double endAngleRadian = endAngle * degToRad;
    return ArcRadians(x, y, startAngleRadian, endAngleRadian, width, height);
}

STDMETHODIMP CDADrawingSurface::Oval(double x, double y, double width, double height)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->Oval(width, height, &pthTemp))

    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))
    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::Rect(double x, double y, double width, double height)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->Rect(width, height, &pthTemp))

    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))
    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::RoundRect(double x, double y,
                                          double width, double height,
                                          double arcWidth, double arcHeight)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->RoundRect(width, height, arcWidth, arcHeight, &pthTemp))

    // The passed in x, y is the lower left corner of the bounding box.
    // We'll move it from (-width/2, -height/2) to (x, y)
    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))
    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::PieRadians(double x, double y, double startAngle, double endAngle,
                                           double width, double height)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->PieRadians(startAngle, endAngle, width, height, &pthTemp))

    // The passed in x, y is the lower left corner of the bounding ellipse.
    // We'll move it from (-width/2, -height/2) to (x, y)
    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))

    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::PieDegrees(double x, double y, double startAngle, double endAngle,
                                           double width, double height)
{
    double startAngleRadian = startAngle * degToRad;
    double endAngleRadian = endAngle * degToRad;
    return PieRadians(x, y, startAngleRadian, endAngleRadian, width, height);
}

STDMETHODIMP CDADrawingSurface::Text(BSTR str, double x, double y)
{
    CComPtr<IDAPoint2> pt;
    RETURN_IF_ERROR(_st->Point2(x, y, &pt))
    return TextPoint(str, pt);
}

STDMETHODIMP CDADrawingSurface::TextPoint(BSTR str, IDAPoint2 *pt)
{
    CHECK_RETURN_NULL(pt);
    return GetCurrentContext()->TextPoint(str, pt);
}

STDMETHODIMP CDADrawingSurface::FillPath(IDAPath2 *pth)
{
    CHECK_RETURN_NULL(pth);
    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::DrawPath(IDAPath2 *pth)
{
    CHECK_RETURN_NULL(pth);
    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::OverlayImage(IDAImage *img)
{
    CHECK_RETURN_NULL(img);
    return GetCurrentContext()->Overlay(img);
}

STDMETHODIMP CDADrawingSurface::LineColor(IDAColor *clr)
{
    CHECK_RETURN_NULL(clr);
    CComPtr<IDALineStyle> newLs;
    RETURN_IF_ERROR(GetCurrentContext()->GetLineStyle()->Color(clr, &newLs))
    GetCurrentContext()->SetLineStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::LineWidth(double width)
{
    CComPtr<IDALineStyle> newLs;
    RETURN_IF_ERROR(GetCurrentContext()->GetLineStyle()->width(width, &newLs))
    GetCurrentContext()->SetLineStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::LineDashStyle(DA_DASH_STYLE id)
{
    return GetCurrentContext()->LineDashStyle(id);
}

STDMETHODIMP CDADrawingSurface::LineEndStyle(DA_END_STYLE id)
{
    CComPtr<IDALineStyle> newLs;
    CComPtr<IDAEndStyle> end;

    // Use the default end style - flat, if invalid index.
    if (id == DAEndSquare) {
        RETURN_IF_ERROR(_st->get_EndStyleSquare(&end))
    } else if (id == DAEndRound) {
        RETURN_IF_ERROR(_st->get_EndStyleRound(&end))
    } else {
        RETURN_IF_ERROR(_st->get_EndStyleFlat(&end))
    }

    RETURN_IF_ERROR(GetCurrentContext()->GetLineStyle()->End(end, &newLs))
    GetCurrentContext()->SetLineStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::LineJoinStyle(DA_JOIN_STYLE id)
{
    CComPtr<IDALineStyle> newLs;
    CComPtr<IDAJoinStyle> join;

    // Use the default join style - bevel, if invalid index.
    if (id == DAJoinMiter) {
        RETURN_IF_ERROR(_st->get_JoinStyleMiter(&join))
    } else if (id == DAJoinRound) {
        RETURN_IF_ERROR(_st->get_JoinStyleRound(&join))
    } else {
        RETURN_IF_ERROR(_st->get_JoinStyleBevel(&join))
    }

    RETURN_IF_ERROR(GetCurrentContext()->GetLineStyle()->Join(join, &newLs))
    GetCurrentContext()->SetLineStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::BorderColor(IDAColor *clr)
{
    CHECK_RETURN_NULL(clr);
    IDALineStyle * newLs;
    RETURN_IF_ERROR(GetCurrentContext()->GetBorderStyle()->Color(clr, &newLs))
    GetCurrentContext()->SetBorderStyle(newLs);
    newLs->Release();
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::BorderWidth(double width)
{
    IDALineStyle * newLs;
    RETURN_IF_ERROR(GetCurrentContext()->GetBorderStyle()->width(width, &newLs))
    GetCurrentContext()->SetBorderStyle(newLs);
    newLs->Release();
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::BorderDashStyle(DA_DASH_STYLE id)
{
    return GetCurrentContext()->BorderDashStyle(id);
}

STDMETHODIMP CDADrawingSurface::BorderEndStyle(DA_END_STYLE id)
{
    CComPtr<IDALineStyle> oldLs, newLs;
    CComPtr<IDAEndStyle> end;
    oldLs = GetCurrentContext()->GetBorderStyle();

    // Use the default end style - flat, if invalid index.
    if (id == DAEndSquare) {
        RETURN_IF_ERROR(_st->get_EndStyleSquare(&end))
    } else if (id == DAEndRound) {
        RETURN_IF_ERROR(_st->get_EndStyleRound(&end))
    } else {
        RETURN_IF_ERROR(_st->get_EndStyleFlat(&end))
    }

    RETURN_IF_ERROR(oldLs->End(end, &newLs))
    GetCurrentContext()->SetBorderStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::BorderJoinStyle(DA_JOIN_STYLE id)
{
    CComPtr<IDALineStyle> oldLs, newLs;
    CComPtr<IDAJoinStyle> join;
    oldLs = GetCurrentContext()->GetBorderStyle();

    // Use the default join style - bevel, if invalid index.
    if (id == DAJoinMiter) {
        RETURN_IF_ERROR(_st->get_JoinStyleMiter(&join))
    } else if (id == DAJoinRound) {
        RETURN_IF_ERROR(_st->get_JoinStyleRound(&join))
    } else {
        RETURN_IF_ERROR(_st->get_JoinStyleBevel(&join))
    }

    RETURN_IF_ERROR(oldLs->Join(join, &newLs))
    GetCurrentContext()->SetBorderStyle(newLs);
    return S_OK;
}

STDMETHODIMP  CDADrawingSurface::Font(BSTR FontFace, LONG sizeInPoints,
                                      VARIANT_BOOL Bold, VARIANT_BOOL italic,
                                      VARIANT_BOOL underline, VARIANT_BOOL strikethrough)
{
    // Note: underline and strikethrough not supported.

    CComPtr<IDAFontStyle> fs1,fs2,fs3,fs4,fs;
    CComPtr<IDAColor> clr;
    _st->get_Black(&clr);
    RETURN_IF_ERROR(_st->Font(FontFace, sizeInPoints, clr, &fs1))
    if(Bold)
        fs1->Bold(&fs2);
    else
        fs2 = fs1;

    if(italic)
        fs2->Italic(&fs3);
    else
        fs3 = fs2;

    if(underline)
        fs3->Underline(&fs4);
    else
        fs4 = fs3;

    if(strikethrough)
        fs4->Strikethrough(&fs);
    else
        fs = fs4;

    GetCurrentContext()->SetFontStyle(fs);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\comobj0.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "bvrtypes.h"

#include "primmth0.h"

void InitClasses0 ()
{
    AddEntry (TypeInfoEntry(CRBOOLEAN_TYPEID,CDABooleanCreate)) ;
    AddEntry (TypeInfoEntry(CRGEOMETRY_TYPEID,CDAGeometryCreate)) ;
    AddEntry (TypeInfoEntry(CRMICROPHONE_TYPEID,CDAMicrophoneCreate)) ;
    AddEntry (TypeInfoEntry(CRPATH2_TYPEID,CDAPath2Create)) ;
    AddEntry (TypeInfoEntry(CRSOUND_TYPEID,CDASoundCreate)) ;
    AddEntry (TypeInfoEntry(CRTRANSFORM3_TYPEID,CDATransform3Create)) ;
    AddEntry (TypeInfoEntry(CRFONTSTYLE_TYPEID,CDAFontStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRJOINSTYLE_TYPEID,CDAJoinStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRBBOX3_TYPEID,CDABbox3Create)) ;
    AddEntry (TypeInfoEntry(CRARRAY_TYPEID,CDAArrayCreate)) ;
    AddEntry (TypeInfoEntry(CRUNKNOWN_TYPEID,CDABehaviorCreate)) ;
}

_ATL_OBJMAP_ENTRY PrimObjectMap0[] = {
    OBJECT_ENTRY(CLSID_DABoolean,CDABoolean)
    OBJECT_ENTRY(CLSID_DAGeometry,CDAGeometry)
    OBJECT_ENTRY(CLSID_DAMicrophone,CDAMicrophone)
    OBJECT_ENTRY(CLSID_DAPath2,CDAPath2)
    OBJECT_ENTRY(CLSID_DASound,CDASound)
    OBJECT_ENTRY(CLSID_DATransform3,CDATransform3)
    OBJECT_ENTRY(CLSID_DAFontStyle,CDAFontStyle)
    OBJECT_ENTRY(CLSID_DAJoinStyle,CDAJoinStyle)
    OBJECT_ENTRY(CLSID_DABbox3,CDABbox3)
    OBJECT_ENTRY(CLSID_DAArray,CDAArray)
    OBJECT_ENTRY(CLSID_DABehavior,CDABehavior)
    {NULL, NULL, NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\comobj1.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "bvrtypes.h"

#include "primmth1.h"


void InitClasses1 ()
{
    AddEntry (TypeInfoEntry(CRCAMERA_TYPEID,CDACameraCreate)) ;
    AddEntry (TypeInfoEntry(CRIMAGE_TYPEID,CDAImageCreate)) ;
    AddEntry (TypeInfoEntry(CRMONTAGE_TYPEID,CDAMontageCreate)) ;
    AddEntry (TypeInfoEntry(CRPOINT2_TYPEID,CDAPoint2Create)) ;
    AddEntry (TypeInfoEntry(CRSTRING_TYPEID,CDAStringCreate)) ;
    AddEntry (TypeInfoEntry(CRVECTOR2_TYPEID,CDAVector2Create)) ;
    AddEntry (TypeInfoEntry(CRLINESTYLE_TYPEID,CDALineStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRDASHSTYLE_TYPEID,CDADashStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRPAIR_TYPEID,CDAPairCreate)) ;
    AddEntry (TypeInfoEntry(CRTUPLE_TYPEID,CDATupleCreate)) ;
}

_ATL_OBJMAP_ENTRY PrimObjectMap1[] = {
    OBJECT_ENTRY(CLSID_DACamera,CDACamera)
    OBJECT_ENTRY(CLSID_DAImage,CDAImage)
    OBJECT_ENTRY(CLSID_DAMontage,CDAMontage)
    OBJECT_ENTRY(CLSID_DAPoint2,CDAPoint2)
    OBJECT_ENTRY(CLSID_DAString,CDAString)
    OBJECT_ENTRY(CLSID_DAVector2,CDAVector2)
    OBJECT_ENTRY(CLSID_DALineStyle,CDALineStyle)
    OBJECT_ENTRY(CLSID_DADashStyle,CDADashStyle)
    OBJECT_ENTRY(CLSID_DAPair,CDAPair)
    OBJECT_ENTRY(CLSID_DATuple,CDATuple)
    {NULL, NULL, NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\comcb.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "comcb.h"
#include "srvprims.h"
#include "cview.h"
#include "privinc/resource.h"
#include <mshtml.h>
#include "privinc/comutil.h"

static bool InitEventData(IDABehavior **data,
                          IDABehavior **curBvr,
                          CRBvrPtr eventData,
                          CRBvrPtr curRunningBvr)
{
    if (eventData) {
        *data = CreateCBvr(eventData);
        if (*data == NULL)
            goto Error;
    }
    
    if (curRunningBvr) {
        *curBvr = CreateCBvr(curRunningBvr);
        if (*curBvr == NULL)
            goto Error;
    }

    return true;
  Error:
    RELEASE(*data);
    RELEASE(*curBvr);

    return false;
}

// ================================================
// COMUntilNotifier
//
// ================================================

class COMUntilNotifier : public CRUntilNotifier
{
  public:
    COMUntilNotifier(IDAUntilNotifier * notifier)
    : _notifier(notifier),_cRef(1)  { _notifier->AddRef(); }
    ~COMUntilNotifier() {
        SAFERELEASE(_notifier);
    }
    
    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                 CRBvrPtr curRunningBvr,
                                 CRViewPtr curView)
    {
        DAComPtr<IDABehavior> event ;
        DAComPtr<IDABehavior> curBvr ;
        DAComPtr<IDAView> v;
        DAComPtr<IDABehavior> pResult ;
        HRESULT hr ;
        CRBvrPtr bvr = NULL;
        
        if (!InitEventData(&event, &curBvr, eventData, curRunningBvr))
            goto done;
        
        // Need to assign the internal pointer directly so we do not
        // get the addref
        Assert (!v); // To ensure we do not leak by accident
        
        v.p = (CView *)CRGetSite(curView);

        Assert(v);

        if (!v) {
            CRSetLastError(E_UNEXPECTED, NULL);
            goto done;
        }
    
        Assert (_notifier) ;
        hr = THR(_notifier->Notify(event,
                                   curBvr,
                                   v,
                                   &pResult));
        
        event.Release();
        curBvr.Release();
        v.Release();

        if (FAILED(hr)) {
            CRSetLastError(IDS_ERR_BE_UNTILNOTIFY, NULL);
            goto done;
        }

        // If this call fails then it will just fall through and
        // return NULL.  The error is already set by GetBvr
        
        bvr = GetBvr(pResult) ;

      done:
        return bvr ;
    }

  protected:
    IDAUntilNotifier * _notifier ;
    long _cRef;
} ;

CRUntilNotifierPtr
WrapCRUntilNotifier(IDAUntilNotifier * notifier)
{
    if (notifier == NULL) {
        CRSetLastError(E_INVALIDARG,NULL);
        return NULL;
    } else {
        CRUntilNotifierPtr ret = NEW COMUntilNotifier(notifier) ;
        if (ret == NULL)
            CRSetLastError(E_OUTOFMEMORY, NULL);
        return ret;
    }
}

// ================================================
// COMBvrHook
// TODO: Merge the code with COMUntilNotifier
// ================================================

class COMBvrHook : public CRBvrHook
{
  public:
    COMBvrHook(IDABvrHook * notifier)
    : _notifier(notifier),_cRef(1)  { _notifier->AddRef(); }
    ~COMBvrHook() {
        SAFERELEASE(_notifier);
    }
    
    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    virtual CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                         bool start,
                                         double startTime,
                                         double gTime,
                                         double lTime,
                                         CRBvrPtr sampleVal,
                                         CRBvrPtr curRunningBvr)
    {
        DAComPtr<IDABehavior> valCBvr ;
        DAComPtr<IDABehavior> curCBvr ;
        DAComPtr<IDABehavior> pResult ;
        HRESULT hr ;
        CRBvrPtr bvr = NULL;

        if (!InitEventData(&valCBvr,
                           &curCBvr,
                           sampleVal,
                           curRunningBvr))
            goto done;
        
        Assert (_notifier) ;
        hr = THR(_notifier->Notify(id,
                                   start,
                                   startTime,
                                   gTime,
                                   lTime,
                                   valCBvr,
                                   curCBvr,
                                   &pResult));
        
        valCBvr.Release();
        curCBvr.Release();

        if (FAILED(hr)) {
            CRSetLastError(IDS_ERR_BE_UNTILNOTIFY, NULL);
            goto done;
        }

        // If this call fails then it will just fall through and
        // return NULL.  The error is already set by GetBvr
        
        bvr = GetBvr(pResult) ;

      done:
        return bvr ;
    }
  protected:
    IDABvrHook * _notifier;
    long _cRef;
} ;

CRBvrHookPtr
WrapCRBvrHook(IDABvrHook * notifier)
{
    if (notifier == NULL) {
        CRSetLastError(E_INVALIDARG,NULL);
        return NULL;
    } else {
        CRBvrHookPtr ret = NEW COMBvrHook(notifier) ;
        if (ret == NULL)
            CRSetLastError(E_OUTOFMEMORY, NULL);
        return ret;
    }
}
    
// ================================================
// COMScriptCallback
//
// ================================================

class COMScriptCallback : public CRUntilNotifier
{
  public:
    COMScriptCallback(BSTR fun, BSTR language)
    : _fun(NULL), _varLanguage(NULL),_cRef(1)  {
        _fun = CopyString(fun);
        _varLanguage = CopyString(language);
    }

    ~COMScriptCallback() {
        delete [] _fun;
        delete [] _varLanguage;
    }

    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    bool CallScript();

    virtual CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                         CRBvrPtr curRunningBvr,
                                         CRViewPtr curView) {
        CallScript();
        return curRunningBvr;
    }
  protected:
    long _cRef;
    WideString _fun;
    WideString _varLanguage;
};

bool
COMScriptCallback::CallScript()
{
    CComVariant retVal;
    CComBSTR fun(_fun);
    CComBSTR varLanguage(_varLanguage);
    
    return SUCCEEDED(CallScriptOnPage(fun,
                                      varLanguage,
                                      &retVal));
}

HRESULT
CallScriptOnPage(BSTR scriptSourceToInvoke,
                 BSTR scriptLanguage,
                 VARIANT *retVal)
{
    // TODO: At some point, may want to cache some of these elements,
    // since this will be repeatedly called.
    
    DAComPtr<IServiceProvider> pSp;
    DAComPtr<IHTMLWindow2> pHTMLWindow2;
    
    if (!GetCurrentServiceProvider(&pSp) ||
        FAILED(pSp->QueryService(SID_SHTMLWindow,
                                 IID_IHTMLWindow2,
                                 (void **)&pHTMLWindow2)))
        return FALSE;

    VariantInit(retVal);
    return pHTMLWindow2->execScript(scriptSourceToInvoke,
                                    scriptLanguage,
                                    retVal);
}

CRUntilNotifierPtr WrapScriptCallback(BSTR bstr, BSTR language)
{ return NEW COMScriptCallback(bstr,language) ; }

// ================================================
// COMScriptNotifier
// ================================================
class COMScriptNotifier : public CRUntilNotifier
{
  public:
    COMScriptNotifier(BSTR scriptlet) : _fun(NULL),_cRef(1)  {
        _fun = CopyString(scriptlet);
    }

    ~COMScriptNotifier()
    { delete [] _fun; }

    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    virtual CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                         CRBvrPtr curRunningBvr,
                                         CRViewPtr curView) {
        DISPID dispid;
        DAComPtr<IServiceProvider> pSp;
        DAComPtr<IDispatch> pDispatch;
        CRBvrPtr bvr = NULL;
        DAComPtr<IDABehavior> event;
        DAComPtr<IDABehavior> curBvr;
        CComVariant retVal;
        HRESULT hr;
        
        {
            CComBSTR fun(_fun);

            if (!GetCurrentServiceProvider(&pSp) ||
                FAILED(pSp->QueryService(SID_SHTMLWindow,
                                         IID_IDispatch,
                                         (void **) &pDispatch)) ||
                FAILED(pDispatch->GetIDsOfNames(IID_NULL, &fun, 1,
                                                LOCALE_USER_DEFAULT,
                                                &dispid))) {
                CRSetLastError(E_FAIL,NULL);
                goto done;
            }
        }

        
        if (!InitEventData(&event, &curBvr, eventData, curRunningBvr))
            goto done;

        // paramters needed to be pushed in reverse order
        VARIANT rgvarg[2];
        rgvarg[1].vt = VT_DISPATCH;
        rgvarg[1].pdispVal = event;
        rgvarg[0].vt = VT_DISPATCH;
        rgvarg[0].pdispVal = curBvr;

        DISPPARAMS dp;
        dp.cNamedArgs = 0;
        dp.rgdispidNamedArgs = 0;
        dp.cArgs = 2;
        dp.rgvarg = rgvarg;

        hr = pDispatch->Invoke(dispid, IID_NULL,
                               LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                               &dp, &retVal, NULL, NULL);

        event.Release();
        curBvr.Release();

        if (FAILED(hr)) {
            CRSetLastError(IDS_ERR_BE_UNTILNOTIFY, NULL);
            goto done;
        }

        if (FAILED(retVal.ChangeType(VT_UNKNOWN))) {
            CRSetLastError(IDS_ERR_BE_UNTILNOTIFY, NULL);
            goto done;
        }

        // If this call fails then it will just fall through and
        // return NULL.  The error is already set by GetBvr
        
        bvr = GetBvr(V_UNKNOWN(&retVal));
      done:
        return bvr ;
    }

  protected:
    long _cRef;
    WideString _fun;
};

CREventPtr
NotifyScriptEvent(CREventPtr event, BSTR scriptlet)
{
    CREventPtr ret = NULL;

    CRUntilNotifierPtr un = NEW COMScriptNotifier(scriptlet);

    if (un) {
        ret = CRNotify(event, un);
    } else {
        CRSetLastError(E_OUTOFMEMORY, NULL);
    }

    if (!ret)
        delete un;
    
    return ret;
}

CRBvrPtr
UntilNotifyScript(CRBvrPtr b0, CREventPtr event, BSTR scriptlet)
{
    CRBvrPtr ret = NULL;

    CREventPtr scriptEvent = NotifyScriptEvent(event, scriptlet);

    // No need to cleanup since everything will get GC'd

    if (scriptEvent) {
        ret = CRUntilEx(b0, scriptEvent);
    }

    return ret;
}

CREventPtr
ScriptCallback(BSTR function, CREventPtr event, BSTR language)
{
    return CRNotify(event, WrapScriptCallback(function, language));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\comobj2.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "bvrtypes.h"

#include "primmth2.h"

void InitClasses2 ()
{
    AddEntry (TypeInfoEntry(CRCOLOR_TYPEID,CDAColorCreate)) ;
    AddEntry (TypeInfoEntry(CRMATTE_TYPEID,CDAMatteCreate)) ;
    AddEntry (TypeInfoEntry(CRNUMBER_TYPEID,CDANumberCreate)) ;
    AddEntry (TypeInfoEntry(CRPOINT3_TYPEID,CDAPoint3Create)) ;
    AddEntry (TypeInfoEntry(CRTRANSFORM2_TYPEID,CDATransform2Create)) ;
    AddEntry (TypeInfoEntry(CRVECTOR3_TYPEID,CDAVector3Create)) ;
    AddEntry (TypeInfoEntry(CRENDSTYLE_TYPEID,CDAEndStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRBBOX2_TYPEID,CDABbox2Create)) ;
    AddEntry (TypeInfoEntry(CREVENT_TYPEID,CDAEventCreate)) ;
    AddEntry (TypeInfoEntry(CRUSERDATA_TYPEID,CDAUserDataCreate)) ;
}

_ATL_OBJMAP_ENTRY PrimObjectMap2[] = {
    OBJECT_ENTRY(CLSID_DAColor,CDAColor)
    OBJECT_ENTRY(CLSID_DAMatte,CDAMatte)
    OBJECT_ENTRY(CLSID_DANumber,CDANumber)
    OBJECT_ENTRY(CLSID_DAPoint3,CDAPoint3)
    OBJECT_ENTRY(CLSID_DATransform2,CDATransform2)
    OBJECT_ENTRY(CLSID_DAVector3,CDAVector3)
    OBJECT_ENTRY(CLSID_DAEndStyle,CDAEndStyle)
    OBJECT_ENTRY(CLSID_DABbox2,CDABbox2)
    OBJECT_ENTRY(CLSID_DAEvent,CDAEvent)
    OBJECT_ENTRY(CLSID_DAUserData,CDAUserData)
    {NULL, NULL, NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\cview.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of views.
    TODO: This file needs to be broken up and lots of code factoring.

*******************************************************************************/


#include "headers.h"
#include "cview.h"
#include "comconv.h"
#include "privinc/resource.h"
#include "privinc/util.h"
#include "srvprims.h"
#include "mshtml.h"

DeclareTag(tagCView, "CView", "CView methods");

// -------------------------------------------------------
// CView
// -------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CView::CView
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CView::CView()
: _view(NULL),
  _dwSafety(0),
  _startFlags(0)
{
    TraceTag((tagCView, "CView(%lx)::CView", this));
}


//+-------------------------------------------------------------------------
//
//  Method:     CView::~CView
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CView::~CView()
{
    TraceTag((tagCView, "CView(%lx)::~CView", this));
    TraceTag((tagGCMedia, "CView(%lx)::~CView", this));

    if (_view)
        CRDestroyView(_view);
}


bool
CView::Init()
{
    _view = CRCreateView();
    return _view != NULL;
}

HRESULT
CView::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    Fire_Error(hr, str);
    if (str)
        return CComCoClass<CView, &CLSID_DAView>::Error(str,
                                                        IID_IDAView,
                                                        hr);
    else
        return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::Tick
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::Render()
{
    TraceTag((tagCView,
              "CView(%lx)::Render()",
              this));

    if (CRRender(_view))
        return S_OK;
    else {

        HRESULT dahr = CRGetLastError();

        if (dahr == DAERR_VIEW_SURFACE_BUSY)
            return S_OK;
        else
            return Error();
    }
}


// SetSimulation time sets the time for subsequent rendering
STDMETHODIMP
CView::Tick(double simTime, VARIANT_BOOL *needToRender) 
{
    // Ensure output parameters are setup correctly
    if (needToRender)
        *needToRender = false;

    bool bRender = false;
    bool bOk;

    bOk = CRTick(_view, simTime, &bRender);
    if (needToRender)
        *needToRender = bRender;

    TraceTag((tagCView,
              "CView(%lx)::Tick(%g), needRender = %d",
              this, simTime, bRender));

    if (bOk)
        return S_OK;
    else {

        HRESULT dahr = CRGetLastError();

        if (dahr == DAERR_VIEW_SURFACE_BUSY)
            return S_OK;

        if (!(_startFlags & CRAsyncFlag) && dahr == E_PENDING)
            return S_OK;
        
        return Error();
    }
}

STDMETHODIMP
CView::get_SimulationTime(double * simTime) 
{
    CHECK_RETURN_NULL(simTime);

    *simTime = CRGetSimulationTime(_view);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::AddBvrToRun
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::AddBvrToRun(IDABehavior *bvr, long *pId)
{
    TraceTag((tagCView, "CView(%lx)::AddBvrToRun(%lx)", this, bvr));

    bool ok = false;
    
    CHECK_RETURN_NULL(pId);
    MAKE_BVR_NAME(crbvr,bvr);
    
    ok = CRAddBvrToRun(_view, crbvr, false, pId);

  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CView::RemoveRunningBvr(long id)
{
    TraceTag((tagCView, "CView(%lx)::RemoveRunningBvr(%d)", this, id));

    if (CRRemoveRunningBvr(_view, id))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::StartModelEx(IDAImage * pImage,
                    IDASound * pSound,
                    double startTime,
                    DWORD dwFlags)
{
    TraceTag((tagCView,
              "CView(%lx)::StartModel(%lx,%lx,%lg)",
              this, pImage, pSound, startTime));
    TraceTag((tagGCMedia,
              "CView(%lx)::StartModel(%lx,%lx,%lg)",
              this, pImage, pSound, startTime));

    bool ok = false;
    bool bPending = false;
    
    // First thing is to set ourselves as the service provider
    if (!CRSetServiceProvider(_view, (IServiceProvider *) this))
    {
        goto done;
    }

    // Store the flags so we know whether to return E_PENDING errors
    // from tick

    _startFlags = dwFlags;
    
    CRImagePtr img;

    if (pImage)
    {
        img = (CRImagePtr) ::GetBvr(pImage);
        if (!img)
        {
            goto done;
        }
    }
    else
    {
        img = NULL;
    }
                
    CRSoundPtr snd;

    if (pSound)
    {
        snd = (CRSoundPtr) ::GetBvr(pSound);
        if (!snd)
        {
            goto done;
        }
    }
    else
    {
        snd = NULL;
    }

    // Since the site creates a cycle make sure we do not leak unless
    // the client does not call stopmodel
    
    CRSetSite(_view, this);

    
    ok = CRStartModel(_view, img, snd, startTime, dwFlags, &bPending);

    if (!ok) {
        CRSetSite(_view, NULL);
    }
  done:

    if (ok) {
        Fire_Start();
        return bPending?E_PENDING:S_OK;

    } else {

        HRESULT dahr = CRGetLastError();

        if (dahr == DAERR_VIEW_SURFACE_BUSY)
            return S_OK;
        else
        {
            // Clear the service provider
            CRSetServiceProvider(_view, NULL);
            return Error();
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::StopModel
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::StopModel()
{
    TraceTag((tagCView, "CView(%lx)::StopModel()", this));
    TraceTag((tagGCMedia, "CView(%lx)::StopModel()", this));

    // Break the cycle
    CRSetSite(_view, NULL);

    Fire_Stop();

    _vs.Release();
    _pClientSite.Release();
    CRSetServiceProvider(_view, NULL);

    if (CRStopModel(_view))
    {
        return S_OK;
    }
    else
    {   
        return Error();
    }
}

STDMETHODIMP
CView::Pause()
{
    TraceTag((tagCView, "CView(%lx)::Pause()", this));

    if (CRPauseModel(_view)) 
    {
        Fire_Pause();
        return S_OK;
    }
    else
    {
        return Error();
    }
}

STDMETHODIMP
CView::Resume()
{
    TraceTag((tagCView, "CView(%lx)::Resume()", this));

    if (CRResumeModel(_view)) 
    {
        Fire_Resume();
        return S_OK;
    }
    else
    {
        return Error();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::get_Window
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::get_Window(long * phwnd)
{
    TraceTag((tagCView,
              "CView(%lx)::get_Window",
              this));

    CHECK_RETURN_NULL(phwnd);

    *phwnd = PtrToUlong(CRGetWindow(_view));

    return S_OK;
}

STDMETHODIMP
CView::get_Window2(HWND * phwnd)
{
    TraceTag((tagCView,
              "CView(%lx)::get_Window",
              this));

    CHECK_RETURN_NULL(phwnd);

    *phwnd = CRGetWindow(_view) ;

    return S_OK;
}
//+-------------------------------------------------------------------------
//
//  Method:     CView::put_Window
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::put_Window(long hwnd)
{
    TraceTag((tagCView,
              "CView(%lx)::put_Window(%lx)",
              this,hwnd));

    if (CRSetWindow(_view,(HWND)hwnd))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::put_Window2(HWND hwnd)
{
    TraceTag((tagCView,
              "CView(%lx)::put_Window2(%lx)",
              this,hwnd));

    if (CRSetWindow(_view,hwnd))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::put_IDirectDrawSurface(IUnknown *ddsurf)
{
    if (CRSetDirectDrawSurface(_view, ddsurf))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::get_IDirectDrawSurface(IUnknown **iunk)
{
    CHECK_RETURN_SET_NULL(iunk);
    *iunk = CRGetDirectDrawSurface(_view);
    return S_OK;
}

STDMETHODIMP
CView::put_DC(HDC dc)
{
    if (CRSetDC(_view, dc))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::get_DC(HDC *dc)
{
    CHECK_RETURN_NULL(dc);
    
    *dc = CRGetDC(_view);
    return S_OK;
}


STDMETHODIMP
CView::put_CompositeDirectlyToTarget(VARIANT_BOOL composeToTarget)
{
    if (CRSetCompositeDirectlyToTarget(_view, composeToTarget?true:false))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::get_CompositeDirectlyToTarget(VARIANT_BOOL *composeToTarget)
{
    CHECK_RETURN_NULL(composeToTarget);
    
    *composeToTarget = CRGetCompositeDirectlyToTarget(_view);
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::RePaint
//
//  Synopsis:   Called when a window needs to be repainted
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::RePaint(long x, long y, long width, long height)
{
    TraceTag((tagCView,
              "CView(%lx)::Paint(%ld,%ld,%ld,%ld)",
              this, x,y,width,height));

    if (CRRepaint(_view, x, y, width, height))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::SetViewport
//
//  Synopsis:   Called to set the window size relative
//              to the rendering target.  This rectangle
//              defines our coordinate space.
//
//--------------------------------------------------------------------------
STDMETHODIMP
CView::SetViewport(long x, long y, long width, long height)
{
    TraceTag((tagCView,
              "CView(%lx)::SetSize(%ld,%ld,%ld,%ld)",
              this, x,y,width,height));
    
    if (CRSetViewport(_view, x, y, width, height))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::SetClipRect
//
//  Synopsis:   Relative to the viewport, clip rendering
//              to this rectangle.
//
//--------------------------------------------------------------------------
STDMETHODIMP
CView::SetClipRect(long x, long y, long width, long height)
{
    if (CRSetClipRect(_view, x, y, width, height))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::PaletteChanged
//
//  Synopsis:   Indicates that the palette has changed
//
//  NOTE [Hollasch]:  This method is never called -- seems like a good
//                    candidate for deletion.
//
//--------------------------------------------------------------------------
STDMETHODIMP
CView::PaletteChanged(VARIANT_BOOL bNew)
{
    TraceTag((tagCView, "CView(%lx)::PaletteChanged (%d)",
              this,bNew));

    return S_OK;
}

CRSTDAPICB_(void)
CView::SetStatusText(LPCWSTR StatusText)
{
    if (_vs) {
        BSTR bstr = W2BSTR(StatusText);
        
        if (bstr) {
            _vs->SetStatusText(bstr);
            SysFreeString(bstr);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::put_Site
//
//  Synopsis:   Sets an view site.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::put_Site(IDAViewSite * pViewSite)
{
    TraceTag((tagCView,
              "CView(%lx)::put_ViewSite(%lx)",
              this, pViewSite));

    Lock();
    _vs = pViewSite;
    Unlock();
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::get_Site
//
//  Synopsis:   Sets an view site.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::get_Site(IDAViewSite ** pViewSite)
{
    TraceTag((tagCView,
              "CView(%lx)::get_ViewSite()",
              this));

    CHECK_RETURN_SET_NULL(pViewSite);

    Lock();
    
    if (_vs) _vs->AddRef();
    
    *pViewSite = _vs;

    Unlock();
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::put_ClientSite
//
//  Synopsis:   Sets a view's ClientSite.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::put_ClientSite(IOleClientSite * pClientSite)
{
    TraceTag((tagCView,
              "CView(%lx)::put_ClientSite(%lx)",
              this, pClientSite));

    _pClientSite = pClientSite;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::get_ClientSite
//
//  Synopsis:   Sets an view ClientSite.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::get_ClientSite(IOleClientSite ** pClientSite)
{
    TraceTag((tagCView,
              "CView(%lx)::get_ViewClientSite()",
              this));

    CHECK_RETURN_SET_NULL(pClientSite);

    if (_pClientSite)
    {
        _pClientSite->AddRef();
        *pClientSite = _pClientSite;
    }

    return S_OK;
}

class
__declspec(uuid("5DA88D2C-0DB0-11d1-87F4-00C04FC29D46")) 
ATL_NO_VTABLE CDAPreferences : public CComObjectRootEx<CComMultiThreadModel>,
                               public CComCoClass<CDAPreferences, &__uuidof(CDAPreferences)>,
                               public IDispatchImpl<IDAPreferences, &IID_IDAPreferences, &LIBID_DirectAnimation>,
                               public IObjectSafetyImpl<CDAPreferences>,
                               public ISupportErrorInfoImpl<&IID_IDAPreferences>
{
  public:
#if _DEBUG
    const char * GetName() { return "CDAPreferences"; }
#endif
    BEGIN_COM_MAP(CDAPreferences)
        COM_INTERFACE_ENTRY(IDAPreferences)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()

    // IDAPreferences methods
    STDMETHOD(PutPreference)(BSTR prefName, VARIANT v) {
        Assert(_cv);
        
        if (CRPutPreference(_cv->GetView(), prefName, v))
            return S_OK;
        else
            return _cv->Error();
    }
    
    STDMETHOD(GetPreference)(BSTR prefName, VARIANT *pV) {
        Assert(_cv);

        CHECK_RETURN_NULL(pV);
        
        if (CRGetPreference(_cv->GetView(), prefName, pV))
            return S_OK;
        else
            return _cv->Error();
    }
    
    STDMETHOD(Propagate)() {
        Assert (_cv);
        if (CRPropagate(_cv->GetView()))
            return S_OK;
        else
            return _cv->Error();
    }

    CDAPreferences(CView * cv = NULL) : _cv(cv) {
        if (_cv) ((IDAPreferences *)_cv)->AddRef();
    }

    ~CDAPreferences() {
        if (_cv) ((IDAPreferences *)_cv)->Release();
    }
    
    void SetView(CView * cv) {
        if (_cv) ((IDAPreferences *)_cv)->Release();
        _cv = cv;
        if (_cv) ((IDAPreferences *)_cv)->AddRef();
    }
    CView * GetView() { return _cv; }
    
  protected:
    CView * _cv;
};

STDMETHODIMP
CView::get_Preferences(IDAPreferences **ppPrefs)
{
    HRESULT hr = E_FAIL;
    CHECK_RETURN_SET_NULL(ppPrefs);

    // See if we have a preference object and create one if we do not
    
    DAComObject<CDAPreferences> *pNew;
    DAComObject<CDAPreferences>::CreateInstance(&pNew);

    if (!pNew) {
        hr = E_OUTOFMEMORY;
    }
    else {
        
        pNew->SetView(this);
        
        hr = pNew->QueryInterface(IID_IDAPreferences, (void **)ppPrefs);
    }
    if (FAILED(hr))
        delete pNew;
    return hr;
}

STDMETHODIMP
CView::QueryHitPoint(DWORD dwAspect,
                     LPCRECT prcBounds,
                     POINT ptLoc,
                     LONG lCloseHint,
                     DWORD *pHitResult)
{
    CHECK_RETURN_NULL(pHitResult);

    *pHitResult = CRQueryHitPoint(_view,
                                  dwAspect,
                                  prcBounds,
                                  ptLoc,
                                  lCloseHint);

    return S_OK;
}


STDMETHODIMP
CView::QueryHitPointEx(LONG s,
                       DWORD_PTR *cookies,
                       double *points,
                       LPCRECT prcBounds,
                       POINT   ptLoc,
                       LONG *hits)
{
    CHECK_RETURN_NULL (hits);
    CHECK_RETURN_NULL (cookies);
    CHECK_RETURN_NULL (points);

    if (s<1) return E_INVALIDARG;

    *hits = CRQueryHitPointEx(_view, s, cookies, points, prcBounds, ptLoc);

    return S_OK;
}


//----------------------------------------------------------------------------
// Returns the set of invalidated rectangles from the last Render.  If
// the list of rects is null, return total number of rects in
// pNumRects.  Otherwise, fill in pRects up to size elements, putting
// number filled in in pNumRects.
//----------------------------------------------------------------------------
STDMETHODIMP
CView::GetInvalidatedRects(DWORD flags,
                           LONG size,
                           RECT *pRects,
                           LONG *pNumRects)
{
    CHECK_RETURN_NULL (pNumRects);

    *pNumRects = CRGetInvalidatedRects(_view,
                                       flags,
                                       size,
                                       pRects);

    return S_OK;
}


//----------------------------------------------------------------------------
// This method fetches the DirectDraw and Direct3DRM interfaces that
// correspond to the view.
//----------------------------------------------------------------------------

STDMETHODIMP
CView::GetDDD3DRM (IUnknown **DirectDraw, IUnknown **D3DRM)
{
    if (CRGetDDD3DRM(_view, DirectDraw, D3DRM))
        return S_OK;
    else
        return Error();
}



//----------------------------------------------------------------------------
// This method fetches the D3D RM device associated with the view, and a
// sequence number.  This number is incremented
//----------------------------------------------------------------------------

STDMETHODIMP
CView::GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum)
{
    CHECK_RETURN_SET_NULL(D3DRMDevice);

    if (CRGetRMDevice(_view, D3DRMDevice, SeqNum))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CViewFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppv)
{
    if (ppv)
        *ppv = NULL;
    
    DAComObject<CView>* pNew;
    DAComObject<CView>::CreateInstance(&pNew);

    HRESULT hr = S_OK;

    if (pNew && pNew->Init()) {
        hr = pNew->QueryInterface(riid, ppv);
    } else {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
        delete pNew;
    
    return hr;
}

//
// IServiceProvider implementation
//

STDMETHODIMP
CView::QueryService(REFGUID guidService,
                       REFIID riid,
                       void** ppv)
{
    HRESULT hr = E_FAIL;

    DAComPtr<IServiceProvider> sp;

    CHECK_RETURN_SET_NULL(ppv);
    
    if (!_pClientSite)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(_pClientSite->QueryInterface(IID_IServiceProvider,
                                          (void **) &sp));

    if (SUCCEEDED(hr))
    {
        hr = THR(sp->QueryService(guidService,
                                  riid,
                                  ppv));

        if (SUCCEEDED(hr))
        {
            hr = S_OK;
            goto done;
        }
    }
    
    // This means that we could not get the service
    // Specifically catch the window service and see if we can get it
    // from the IOleClientSite
    
    if (!InlineIsEqualGUID(guidService, SID_SHTMLWindow))
    {
        hr = E_FAIL;
        goto done;
    }
    
    {
        CComPtr<IOleContainer> root;
        CComPtr<IHTMLDocument2> htmlDoc;
        DAComPtr<IHTMLWindow2> wnd;

        hr = THR(_pClientSite->GetContainer(&root));

        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(root->QueryInterface(IID_IHTMLDocument2, (void **)&htmlDoc));

        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(htmlDoc->get_parentWindow(&wnd));

        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(wnd->QueryInterface(riid, ppv));

        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\context.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef DA_CONTEXT_H
#define DA_CONTEXT_H

#include "backend/bvr.h"
#include "dartapi.h"
#include "dartapipriv.h"
#include "privinc/mutex.h"
#include "backend/gc.h"
#include <dxtrans.h>

class SoundBufferCache ;
class ImageDisplayDev;
class QuartzRenderer;

// =========================================
// Context Class
// =========================================

class ATL_NO_VTABLE ViewIterator {
  public:
    virtual void Process(CRViewPtr) = 0;
};

class ATL_NO_VTABLE SiteIterator {
  public:
    virtual void Process(CRSitePtr) = 0;
};

class Context : public AxAThrowingAllocatorClass {
  public:
    Context () ;
    ~Context () { Cleanup(false); }

    void Cleanup(bool bShutdown);

    DynamicHeap & GetGCHeap () { return _gcHeap ; }
    DynamicHeap & GetTmpHeap () { return _tmpHeap ; }

    // DEADLOCK - Be careful what you do in the view iterator and
    // from the thread calling these functions since it can cause
    // deadlock
    
    void AddView(CRViewPtr v);
    void RemoveView(CRViewPtr v);
    void IterateViews(ViewIterator& proc);
    void ViewDecPickEvent(CRViewPtr v);

    CritSect & GetCritSect () { return _critSect; }

    GCList GetGCList() { return _gcList ; }

    GCRoots GetGCRoots() { return _gcRoots ; }

    SoundBufferCache* GetSoundBufferCache() { return _soundBufferCache ; }

    typedef set< CRViewPtr, less<CRViewPtr> > ViewSet;

    void AddSite(CRSitePtr v);
    void RemoveSite(CRSitePtr v);
    void IterateSite(SiteIterator& proc);

    typedef set< CRSitePtr, less<CRSitePtr> > SiteSet;

    void AcquireMIDIHardware(Sound *snd, QuartzRenderer *filterGraph);
    bool IsUsingMIDIHardware(Sound *snd, QuartzRenderer *filterGraph);
    
  protected:

    DynamicHeap & _gcHeap ;
    DynamicHeap & _tmpHeap;
    
    // SEH
    void IterateSite_helper(SiteIterator& proc, SiteSet::iterator i);
    void IterateViews_helper(ViewIterator& proc, set< CRViewPtr, less<CRViewPtr> >::iterator i);
    

    GCList _gcList ;

    GCRoots _gcRoots ;

    CritSect _critSect;

    // caches buffers from import before view/device exists
    SoundBufferCache *_soundBufferCache; 

    // TODO: like not to use pointer, but compiler complains.
    ViewSet & _viewSet;
    SiteSet & _siteSet;

    bool _inited;

    QuartzRenderer *_filterGraph;
    Sound *_txSnd;
} ;

Context & GetCurrentContext() ;
SoundBufferCache* GetSoundBufferCache();

#endif /* DA_CONTEXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\context.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Context implementation

*******************************************************************************/


#include "headers.h"
#include "context.h"
#include "view.h"
#include "eventq.h"
#include "import.h"
#include "privinc/util.h"
#include "privinc/registry.h"
#include "privinc/discimg.h"
#include "privinc/dddevice.h"
#include "privinc/bufferl.h"
#include "privinc/snddev.h"
#include "privinc/helpq.h"
#include "backend/sndbvr.h"


#if PRODUCT_PROF
#include "../../../tools/x86/icecap/icapexp.h"
#endif

Context * globalCtx = NULL ;

//TODO this is here because of a bug in cl.exe v. 7071. It is not
//referenced and should be optimized out.
Context::ViewSet cvs;    
Context::SiteSet css;    

Context::Context ()
: _inited(false),
  _gcHeap(CreateWin32Heap("Context GC Win32 Heap", 0, 0, 0)),
  _gcList(CreateGCList()),
  _gcRoots(CreateGCRoots()),
  _viewSet(* new ViewSet),
  _siteSet(* new SiteSet),
  _filterGraph(NULL),
  _tmpHeap(TransientHeap("Tmp Value Heap", 2000))
{
    TraceTag((tagServerCtx, "Context(%lx)::Context", this));

    _soundBufferCache = new SoundBufferCache();

    _inited = true;
}

void 
Context::Cleanup (bool bShutdown)
{
    if (!_inited) return;

    _inited = false;

    // Cleans up data structures

    TraceTag((tagServerCtx, "Context(%lx)::~Context", this));

#if DEVELOPER_DEBUG
    DumpGCRoots(_gcRoots);
#endif

    // TODO: We should do a GCCleanup but this seems to cause problems
    
    if (!bShutdown) {
        CleanUpGCList(_gcList, _gcRoots);
        delete _soundBufferCache;
    }
    

    FreeGCList(_gcList);
    FreeGCRoots(_gcRoots);

    Assert(_viewSet.size() == 0);
    delete & _viewSet;          // DecPickEvent needs the viewSet

    Assert(_siteSet.size() == 0);
    delete & _siteSet;

    DestroyWin32Heap (_gcHeap) ;
    delete &_tmpHeap;

}

void Context::AddView(CRViewPtr v)
{
    CritSectGrabber csg(GetCritSect());
    
    v->AddRef();
    
    _viewSet.insert(v);

    TraceTag((tagServerCtx, "AddView: %lx", v));
}

void Context::RemoveView(CRViewPtr v)
{
    CritSectGrabber csg(GetCritSect());

    TraceTag((tagServerCtx, "RemoveView: %lx", v));
    
    if (_viewSet.find(v) != _viewSet.end()) {

        TraceTag((tagServerCtx, "RemoveView - Found %x", v));
    
        _viewSet.erase(v);

        v->Release();
    }
}

void Context::IterateViews(ViewIterator& proc)
{
    set< CRViewPtr, less<CRViewPtr> > viewSetCopy ;
    
    // Copy the list so that we do not have the critical section while
    // we are calling the user supplied function - otherwise we could
    // (and likely will) cause deadlock

    TraceTag((tagServerCtx, "IterateViews::_viewSet(%d)",
              _viewSet.size()));
    
    {
        CritSectGrabber csg(GetCritSect());

        for (set< CRViewPtr, less<CRViewPtr> >::iterator i = _viewSet.begin();
             i != _viewSet.end();
             i++) {

            viewSetCopy.insert(*i);

#ifdef _DEBUG
            int refCnt =
#endif          
            // Need to AddRef to ensure it is not deleted while we are
            // processing it
            (*i)->AddRef();

            TraceTag((tagServerCtx,
                      "IterateViews(%lx) - After AddRef %d, dwRef=%d",
                      (*i), refCnt, (*i)->GetRefCount()));
        }
    }
    
    for (set< CRViewPtr, less<CRViewPtr> >::iterator i = viewSetCopy.begin();
         i != viewSetCopy.end(); i++) {

        IterateViews_helper(proc, i);

#ifdef _DEBUG
        int refCnt =
#endif          
        // Release it now since we do not need it anymore
        (*i)->Release();

        TraceTag((tagServerCtx,
                  "IterateViews(%lx) - After Release %d",
                  (*i), refCnt));

        // DON'T USE (*i) AFTER THE RELEASE!!!! THE VIEW MIGHT BE GONE
    }
}

void Context::IterateViews_helper(
    ViewIterator& proc,
    set< CRViewPtr, less<CRViewPtr> >::iterator i)
{
    __try {
        proc.Process(*i);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ReportErrorHelper(DAGetLastError(), DAGetLastErrorString());
        // Do nothing for now but we need to make sure we release everything
    }
}

void Context::ViewDecPickEvent(CRViewPtr v)
{
    CritSectGrabber csg(GetCritSect());

    if (_viewSet.find(v) != _viewSet.end())
        v->DecPickEvent();
}

void
Context::AcquireMIDIHardware(Sound *snd, QuartzRenderer *filterGraph)
{
    CritSectGrabber csg(GetCritSect());

    if (_filterGraph)
        _filterGraph->Stop();

    _filterGraph = filterGraph;
    _txSnd = snd;
}
    
bool
Context::IsUsingMIDIHardware(Sound *snd, QuartzRenderer *filterGraph)
{
    CritSectGrabber csg(GetCritSect());

    return (_filterGraph == filterGraph) && (_txSnd == snd);
}


void ViewDecPickEvent(CRViewPtr v)
{ globalCtx->ViewDecPickEvent(v); }


class DiscreteImageDeleter : public ViewIterator {
 public:
    DiscreteImageDeleter(DiscreteImage *img, DirectDrawViewport *vprt)
    : _img(img), _viewport(vprt) {}

    virtual void Process(CRViewPtr v) {
        ViewPusher vp (v,TRUE);

        DirectDrawViewport *viewport = v->GetImageDev();

        // todo: minor redundancy:  !_viewport.
        if (viewport) {
            if (!_viewport || (_viewport == viewport))
                viewport->DiscreteImageGoingAway(_img);
        }
    }
  private:
    DiscreteImage *_img;
    DirectDrawViewport *_viewport;
};


void DiscreteImageGoingAway(DiscreteImage *img,
                            DirectDrawViewport *vprt)
{
    GetCurrentContext().IterateViews(DiscreteImageDeleter(img, vprt));
}

class SoundDeleter : public ViewIterator {
 public:
    SoundDeleter(Sound *sound) : _sound(sound) {}

    virtual void Process(CRViewPtr view) {
        ViewPusher vp (view, TRUE);

        // remove TxSound
        
        SoundInstanceList *s = view->GetSoundInstanceList();

        // the list may have been gone after StopModel, so s can be
        // NULL
        if (s) {
            s->Stop(_sound);
        }

        MetaSoundDevice *currentDev = view->GetSoundDev();

        if (currentDev) {
            DirectSoundDev *dsDev = currentDev->dsDevice;
            Assert(dsDev);
            dsDev->RemoveStreamFile(_sound);
            dsDev->RemoveDSMasterBuffer(_sound);
        }
    }
    
  private:
    Sound *_sound;
};

void SoundGoingAway(Sound *sound)
{
    GetCurrentContext().IterateViews(SoundDeleter(sound));
}

void Context::AddSite(CRSitePtr s)
{
    CritSectGrabber csg(GetCritSect());
    
    s->AddRef();
    
    _siteSet.insert(s);
}

void Context::RemoveSite(CRSitePtr s)
{
    CritSectGrabber csg(GetCritSect());

    if (_siteSet.find(s) != _siteSet.end()) {

        _siteSet.erase(s);
    
        s->Release();
    }
}

void Context::IterateSite(SiteIterator& proc)
{
    set< CRSitePtr, less<CRSitePtr> > siteSetCopy ;
    
    // Copy the list so that we do not have the critical section while
    // we are calling the user supplied function - otherwise we could
    // (and likely will) cause deadlock
    
    {
        CritSectGrabber csg(GetCritSect());

        for (SiteSet::iterator i = _siteSet.begin();
             i != _siteSet.end();
             i++) {

            siteSetCopy.insert(*i);

            // Need to AddRef to ensure it is not deleted while we are
            // processing it
            (*i)->AddRef();
        }
    }

    for (SiteSet::iterator i = siteSetCopy.begin();
         i != siteSetCopy.end(); i++) {

        IterateSite_helper(proc, i);

        // Release it now since we do not need it anymore
        (*i)->Release();
    }
}

void Context::
IterateSite_helper(SiteIterator& proc, SiteSet::iterator i)
{    
    __try {
        proc.Process(*i);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        // Do since reporting the error can be reentrant
    }
}


// =========================================
// C Calls
// =========================================

Context &
GetCurrentContext()
{
    return *globalCtx ;
}


SoundBufferCache *
GetSoundBufferCache()
{
    return(GetCurrentContext().GetSoundBufferCache());
}

DynamicHeap &
GetTmpHeap()
{
    if (!globalCtx)
        return GetGCHeap();
    
    return globalCtx->GetTmpHeap();
}

DynamicHeap &
GetGCHeap()
{
    if (!globalCtx)
        return (GetSystemHeap()) ;

    return globalCtx->GetGCHeap() ;
}

GCList
GetCurrentGCList()
{
    if (!globalCtx)
        return NULL ;

    return globalCtx->GetGCList () ;
}

GCRoots GetCurrentGCRoots()
{ return globalCtx->GetGCRoots() ; }

void
SetStatusTextHelper(char * szStatus)
{
    CRViewPtr view = IntGetCurrentView();

    if (view)
        view->SetStatusText(szStatus);
}

class ErrorIterator : public SiteIterator {
 public:
    ErrorIterator(HRESULT hr, LPCWSTR szErrorText)
    : _hr(hr), _str(szErrorText) {}

    virtual void Process(CRSitePtr s) {
        Assert(s);

        s->ReportError(_hr, _str);
    }
  private:
    HRESULT _hr;
    LPCWSTR _str;
};

void
ReportErrorHelper(HRESULT errcode, LPCWSTR szErrorText)
{
    GetCurrentContext().IterateSite(ErrorIterator(errcode, szErrorText));
}

class ReportGCIterator : public SiteIterator {
 public:
    ReportGCIterator(bool b)
    : _b(b) {}

    virtual void Process(CRSitePtr s) {
        Assert(s);

        s->ReportGC(_b);
    }
  private:
    bool _b;
};

void
ReportGCHelper(bool bStarting)
{
    GetCurrentContext().IterateSite(ReportGCIterator(bStarting));
}

void
AcquireMIDIHardware(Sound *snd, QuartzRenderer *filterGraph)
{
    GetCurrentContext().AcquireMIDIHardware(snd, filterGraph);
}

bool
IsUsingMIDIHardware(Sound *snd, QuartzRenderer *filterGraph)
{
    return GetCurrentContext().IsUsingMIDIHardware(snd, filterGraph);
}

void
FreeSoundBufferCache()
{
    GetCurrentContext().GetSoundBufferCache()->FlushCache();
}

// =========================================
// Initialization
// =========================================

void
InitializeModule_Context()
{
    globalCtx = NEW Context ;
}

void
DeinitializeModule_Context(bool bShutdown)
{
    if (globalCtx) globalCtx->Cleanup(bShutdown);

    delete globalCtx ;
    globalCtx = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\crview.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of views.
    TODO: This file needs to be broken up and lots of code factoring.

*******************************************************************************/


#include "headers.h"
#include "context.h"
#include "view.h"
#include "privinc/resource.h"
#include "privinc/util.h"
#include "privinc/htimer.h"
#include "privinc/viewport.h"
#include "import.h"
#include "privinc/dddevice.h"
#include "privinc/d3dutil.h"    // For GetD3DRM()

extern void ReapElderlyMasterBuffers();
DeclareTag(tagCRView2, "CRView", "CRView methods");

DirectDrawViewport * g_dummyImageDev = NULL;
DirectDrawViewport *CreateDummyImageDev();

#if PERFORMANCE_REPORTING
GlobalTimers *globalTimers = NULL;
#endif  // PERFORMANCE_REPORTING

#ifdef _DEBUG
void DumpWindowSize(HWND hwnd, char * str = "")
{
    RECT r;
    GetClientRect(hwnd,&r);
    char buf[2048];
    
    sprintf (buf,
             "%s: left - %d, top - %d, right - %d, bottom - %d\n",
             str,
             r.left,r.top,r.right,r.bottom);

    TraceTag((tagCRView2, buf));
}
#endif

// -------------------------------------------------------
// CRView
// -------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CRView::CRView
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CRView::CRView()
: _cRef(0),
  _localHiresTimer(NULL),
  _firstRender(true),
  _bRenderLock(false),
  _bPaused(false)
{
    TraceTag((tagCRView2, "CRView(%lx)::CRView", this));

    _localHiresTimer = &CreateHiresTimer();
    
    // This should make us AddRef to 1 since we started at 0
    
    GetCurrentContext().AddView(this);

    Assert(_cRef == 1);
}


//+-------------------------------------------------------------------------
//
//  Method:     CRView::~CRView
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CRView::~CRView()
{
    TraceTag((tagCRView2, "CRView(%lx)::~CRView", this));

    // TODO: We need to clean this up since the view destructor also
    // calls stop but does not setup the state correctly

    // Push ourselves to ensure we can make the correct calls
    ViewPusher vp (this,false) ;
    // Also push the same heap we were created on
    DynamicHeapPusher dhp(GetSystemHeap()) ;
    
    Stop();

    delete _localHiresTimer;
}


// We need to be careful with InterlockedDecrement.  It only returns
// <0, == 0, or >0 not the actually value

// >0 means it has an outstanding reference
// 0 means no outstanding references - remove from global list
// <0 means it needs to be deleted

ULONG
CRView::Release()
{
    LONG l = InterlockedDecrement(&_cRef) ;

    TraceTag((tagCRView2, "CRView(%lx)::Release _cRef=%d, l=%d",
              this, _cRef, l));
    
    // We need to be careful since the removeview should also call
    // release and go in this same code and delete the object before
    // it returns
    
    if (l == 0) {
        GetCurrentContext().RemoveView(this);
    } else if (l < 0) {
        delete this;
    }

    return (l <= 0) ? 0 : (ULONG)l;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRView::Tick
//
//  Synopsis:
//
//--------------------------------------------------------------------------

// SetSimulation time sets the time for subsequent rendering
bool
CRView::Tick(double simTime) 
{
    if (ImportsPending())
        RaiseException_UserError(E_PENDING, IDS_ERR_NOT_READY);

#if 0
#if _DEBUGMEM
    _CrtMemState diff, oldState, newState;
    _CrtMemCheckpoint(&oldState);
#endif
#endif

    // timestamp _currentTime based on our internal hires clock!
    _currentTime = simTime;
    
    if (_firstRender) { // reset the timer if this is the first time
        _localHiresTimer->Reset(); // Zero timer
        _firstRender = false;
    }
    
    if (!IsStarted ())
        RaiseException_UserError(E_FAIL, 0);
    
    bool bNeedRender = Sample(simTime, _bPaused);
    
    // See if we got imports pending during the tick and return
    // the error code
    
    if (ImportsPending()) {
        bNeedRender = false;
        RaiseException_UserError(E_PENDING, IDS_ERR_NOT_READY);
    }
    
    //RenderSound(); // render audio

    ReapElderlyMasterBuffers(); // free old static sound master buffers
    // ReapSoundInstanceResources();

#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif

    return bNeedRender;
}

void
CRView::StopModel()
{
    Stop();
    _bPaused = false;
    _pServiceProvider.Release();
}

void
CRView::PauseModel()
{
    if (IsStarted())
    {
        Pause();
        _bPaused = true;
    }
}

void
CRView::ResumeModel()
{
    if (IsStarted())
    {
        Resume();
        _bPaused = false;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CRView::StartModel
//
//  Synopsis:
//
//--------------------------------------------------------------------------

void
CRView::StartModel(Bvr img,
                   Bvr snd,
                   double startTime,
                   DWORD dwFlags,
                   bool & bPending)
{
    TraceTag((tagGCMedia,
              "CRView(%lx)::StartModel(%lx,%lx,%lg)",
              this, img, snd, startTime));

#ifdef _DEBUG
    DumpWindowSize(GetWindow(),"StartModel");
#endif

    if (IsStarted ())
        RaiseException_UserError(E_FAIL, 0);
    
    // Grab the Preferences iface, and propagate the preferences
    // to the view before we start the view going.
    Propagate();
        
    _ticksAtStart = GetPerfTickCount();

#ifndef _NO_CRT
#if PERFORMANCE_REPORTING
    {
        double audioLoadTime = GetTimers().audioLoadTimer.GetTime();
        double geometryLoadTime = GetTimers().geometryLoadTimer.GetTime();
        double imageLoadTime = GetTimers().imageLoadTimer.GetTime();
        double downloadTime = GetTimers().downloadTimer.GetTime();
        double importblockingTime = GetTimers().importblockingTimer.GetTime();
        
        double mediaLoadTime = (audioLoadTime +
                                geometryLoadTime +
                                imageLoadTime +
                                importblockingTime +
                                downloadTime);
      
        PerfPrintLine("CRView::StartModel - Media Load Time: %g s composed of:",
                      mediaLoadTime);

        PerfPrintLine ("\tGeometry:             %g", geometryLoadTime);
        PerfPrintLine ("\tImage:                %g", imageLoadTime);
        PerfPrintLine ("\tSound:                %g", audioLoadTime);
        PerfPrintLine ("\tLoad:                 %g", downloadTime);
        PerfPrintLine ("\tImport Blocking:      %g", importblockingTime);
    }
#endif
#endif

    __try {
        _bPaused = false;
        Start(img, snd, startTime) ;
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        TraceTag((tagError, "CRView::StartModel - exception caught: "));
        TraceTag((tagError, " --> (hr: %x) %ls: ", DAGetLastError(), DAGetLastErrorString()));
        Stop();
        RETHROW;
    }

    // See if imports are pending
    
    bPending = ImportsPending();
}

//+-------------------------------------------------------------------------
//
//  Method:     CRView::SetStatusText
//
//  Synopsis:   Helper to set the status bar text.
//
//--------------------------------------------------------------------------

void
CRView::SetStatusText(char * szStatus)
{
    TraceTag((tagCRView2,
              "CRView(%lx)::SetStatusText(%s)",
              this, szStatus));

    DAComPtr<CRViewSite> s;

    {
        CritSectGrabber csg(_crit);
        s = _pViewSite ;
    }

    if (s) {
        USES_CONVERSION;
        s->SetStatusText(A2W(szStatus));
    }
}

// -------------------------------------------------------
// C Functions
// -------------------------------------------------------

static CritSect *dummyDevCritSect = NULL;

DirectDrawViewport *GetCurrentViewport( bool dontCreateOne )
{
    CRView * v = IntGetCurrentView() ;

    if (v) 
        return v->GetImageDev() ;
    else {

        if( dontCreateOne ) return NULL;
        
        TraceTag((tagImageDeviceInformative,
                  "GetCurrentImageDisplayDevice - no view"));

        // TODO: should check for if there is a context (which happens
        // at init time) and do something, unfortunately
        // GetCurrentContext returns a reference
        {
            CritSectGrabber csg(*dummyDevCritSect);
            if(!g_dummyImageDev) {
                g_dummyImageDev = CreateDummyImageDev();
            }

            return g_dummyImageDev;
        }
    }
}

DirectDrawImageDevice *GetImageRendererFromViewport(DirectDrawViewport *vp)
{
    return vp->GetImageRenderer();
}

MetaSoundDevice * GetCurrentSoundDevice()
{
    CRView * v = IntGetCurrentView() ;

    if (v) 
        return v->GetSoundDev() ;
    else
        return NULL ;
}

DirectSoundDev * GetCurrentDSoundDevice()
{
    MetaSoundDevice *metaDev = GetCurrentSoundDevice();
    if (metaDev)
        return metaDev->dsDevice;
    else
        return NULL;
}

DynamicHeap &GetCurrentSampleHeap()
{ return GetCurrentView().GetSampleHeap() ; }

DynamicHeap &GetViewRBHeap()
{ return GetCurrentView().GetRBHeap() ; }

Time GetLastSampleTime()
{ return GetCurrentView().GetLastSampleTime(); }

HWND GetCurrentSampleWindow()
{ return GetCurrentView().GetWindow () ; }

void ViewEventHappened()
{
    CRViewPtr v = IntGetCurrentView();
    
    if (v)
        v->EventHappened();
}

SoundInstanceList *
ViewGetSoundInstanceList()
{
    return GetCurrentView().GetSoundInstanceList(); 
}

double
ViewGetFramePeriod()
{
    return GetCurrentView().GetFramePeriod();
}

EventQ & GetCurrentEventQ()
{ return GetCurrentView().GetEventQ(); }

PickQ & GetCurrentPickQ()
{ return GetCurrentView().GetPickQ(); }

double ViewGetFrameRate()
{ return GetCurrentView().GetFrameRate(); }

double ViewGetTimeDelta()
{ return GetCurrentView().GetTimeDelta(); }

#if PERFORMANCE_REPORTING
GlobalTimers &
GetCurrentTimers()
{
    CRView * v = IntGetCurrentView() ;

    if (v) 
        return v->GetTimers() ;
    else
        return *globalTimers ;
}
#endif  // PERFORMANCE_REPORTING

// TODO: Making the trigger event happen at the current time would be
// ok for async trigger case, but will cause problem if it's called
// inside a notifier.   In such case, the user really wants it to
// happen at the event time.  Even if we can do so, since trigger
// affects all performances, we need to map that view's event time to
// other views', which would not be possible.  Thus we're doing a hack
// to make the trigger happen slightly before current tick time, so
// that at current frame, it's AFTER the event.   This could break if
// the user is driving tick with very fine intervals.  Probably ok for
// most of the cases though.

static const double EPSILON = 1e-15;

class AppTriggerProc : public ViewIterator {
  public:
    AppTriggerProc(DWORD id, Bvr data) : _id(id), _data(data) {}
    
    virtual void Process(CRView* v) {
        Bvr bvr;
        
        GC_CREATE_BEGIN;                                                        

        bvr = _data ? _data : TrivialBvr();

        // When the entry is clear, is should remove it from the set
        GCAddToRoots(bvr, GetCurrentGCRoots());

        GC_CREATE_END;

        {
            ViewPusher vp (v,true) ;

            
            double time = v->GetCurrentSimulationTime() - EPSILON;

            // We want our current time clamped at something slightly 
            // greater than zero so that events at zero can be considered
            // to have occured already.
            if(time < EPSILON)
                time = EPSILON;            

            v->GetEventQ().Add(
                AXAWindEvent(AXAE_APP_TRIGGER, time, (DWORD_PTR) bvr, 0,
                             0, _id, 0));
        }
    }

  private:
    DWORD _id;
    Bvr _data;
};

void TriggerEvent(DWORD eventId, Bvr data, bool bAllViews)
{
    AppTriggerProc p(eventId, data);

    if (bAllViews)
        GetCurrentContext().IterateViews(p);
    else
        p.Process(&GetCurrentView());
}

void RunViewBvrs(Time startGlobalTime, TimeXform tt)
{
    GetCurrentView().RunBvrs(startGlobalTime, tt);
}

bool ViewLastSampledTime(DWORD& lastSystemTime,
                         DWORD& currentSystemTime,
                         Time & t)
{
    CRView * v = IntGetCurrentView() ;

    if (v)
    {
        lastSystemTime = v->GetLastSystemTime();
        currentSystemTime = v->GetCurrentSystemTime();
        t = v->GetLastSampleTime();
        return true;
    }

    return false;
}

CRView *ViewAddPickEvent()
{
    CRView& view = GetCurrentView();

    view.AddPickEvent();

    return &view;
}

unsigned int
ViewGetSampleID()
{
    CRView& view = GetCurrentView();

    return view.GetSampleID();
}

bool
GetCurrentServiceProvider(IServiceProvider ** sp)
{
    Assert (sp);
    
    CRView * v = IntGetCurrentView() ;

    if (v) {
        {
            CritSectGrabber csg(v->GetCritSect());
            *sp = v->GetServiceProvider();
        }
        
        if (*sp) {
            (*sp)->AddRef();
        }
        return true;
    } else {
        *sp = NULL ;
        return false ;
    }
}

class ImportProc : public ViewIterator {
  public:
    ImportProc(Bvr bvr) : _bvr(bvr) {}
    
    virtual void Process(CRView* v) {
        v->RemoveIncompleteImport(_bvr);
    }

  private:
    Bvr _bvr;
};

void ViewNotifyImportComplete(Bvr bvr, bool bDying)
{
    GetCurrentContext().IterateViews(ImportProc(bvr));
}

#define BOGUS_IMAGEDEV_CLASS "ImageWindowClass"

DirectDrawViewport *
CreateDummyImageDev()
{
    DirectDrawViewport * imageDev;

    WNDCLASS wndclass;
        
    memset(&wndclass, 0, sizeof(WNDCLASS));
    wndclass.style          = 0;
    wndclass.lpfnWndProc    = DefWindowProc;
    wndclass.hInstance      = hInst;
    wndclass.hCursor        = NULL;
    wndclass.hbrBackground  = NULL;
    wndclass.lpszClassName  = BOGUS_IMAGEDEV_CLASS;
        
    RegisterClass(&wndclass) ;
    
    HWND hwnd = ::CreateWindow (BOGUS_IMAGEDEV_CLASS,
                                "",
                                0,0,0,2,2,NULL,NULL,hInst,NULL);

    imageDev = CreateImageDisplayDevice();

    targetPackage_t targetPackage;  // rendering target info
    targetPackage.Reset();
        
    targetPackage.SetHWND(hwnd);

    imageDev->SetTargetPackage( &targetPackage );

    return imageDev;
}

// =========================================
// Initialization
// =========================================

void
InitializeModule_CRView()
{

    dummyDevCritSect = NEW CritSect;

#if PERFORMANCE_REPORTING
    globalTimers = NEW GlobalTimers;
#endif  // PERFORMANCE_REPORTING
}

void
DeinitializeModule_CRView(bool bShutdown)
{
#if 0
    if (g_dummyImageDev) {
        DestroyImageDisplayDevice(g_dummyImageDev);
        g_dummyImageDev = NULL ;
    }
#endif

#if PERFORMANCE_REPORTING
    delete globalTimers;
#endif  // PERFORMANCE_REPORTING

    delete dummyDevCritSect;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\cview.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CVIEW_H
#define _CVIEW_H

#include "engine.h"
#include "daviewevents.h"
class ATL_NO_VTABLE CViewFactory : public CComClassFactory {
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//-------------------------------------------------------------------------
//
//  Class:      CView
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class ATL_NO_VTABLE CView :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CView, &CLSID_DAView>,
    public IDispatchImpl<IDA3View, &IID_IDA3View, &LIBID_DirectAnimation>,
    public IObjectSafetyImpl<CView>,
    public ISupportErrorInfoImpl<&IID_IDA3View>,
    public CProxy_IDAViewEvents<CView>,
    public IProvideClassInfo2Impl<&CLSID_DAView, &DIID__IDAViewEvents, &LIBID_DirectAnimation>,
    public IConnectionPointContainerImpl<CView>,
    public CRViewSite,
    public IServiceProvider
{
  public:
    CView();
    virtual ~CView();

    bool Init();

#if _DEBUG
    const char * GetName() { return "CView"; }
#endif

    DECLARE_REGISTRY(CLSID_DAView,
                     LIBID ".DAView.1",
                     LIBID ".DAView",
                     0,
                     THREADFLAGS_BOTH);

    DA_DECLARE_NOT_AGGREGATABLE(CView);
    DECLARE_CLASSFACTORY_EX(CViewFactory);

    BEGIN_COM_MAP(CView)
        COM_INTERFACE_ENTRY(IDA3View)
        COM_INTERFACE_ENTRY(IDA2View)
        COM_INTERFACE_ENTRY(IDAView)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
    END_COM_MAP();

    BEGIN_CONNECTION_POINT_MAP(CView)
        CONNECTION_POINT_ENTRY(DIID__IDAViewEvents)
    END_CONNECTION_POINT_MAP();

    // IDAView methods

    // SetSimulation time sets the time for subsequent rendering
    STDMETHOD(Tick)(double simTime, VARIANT_BOOL *needToRender);
    STDMETHOD(get_SimulationTime)(double * simTime);

    // These methods Render to the given hwnd or surface
    STDMETHOD(Render)();
    STDMETHOD(put_IDirectDrawSurface)(IUnknown *ddsurf);
    STDMETHOD(get_IDirectDrawSurface)(IUnknown **ddsurf);
    STDMETHOD(put_DC)(HDC  dc);
    STDMETHOD(get_DC)(HDC *dc);
    STDMETHOD(put_CompositeDirectlyToTarget)(VARIANT_BOOL  composeToTarget);
    STDMETHOD(get_CompositeDirectlyToTarget)(VARIANT_BOOL *composeToTarget);

    STDMETHOD(AddBvrToRun)(IDABehavior *bvr, long *pId);
    STDMETHOD(RemoveRunningBvr)(long id);

    STDMETHOD(StartModel)(IDAImage * pImage,
                          IDASound * pSound,
                          double startTime)
    { return StartModelEx(pImage, pSound, startTime, 0); }

    STDMETHOD(StartModelEx)(IDAImage * pImage,
                            IDASound * pSound,
                            double startTime,
                            DWORD dwFlags);
    STDMETHOD(StopModel)();
    STDMETHOD(Pause)();
    STDMETHOD(Resume)();
    STDMETHOD(get_Window)(long * hwnd);
    STDMETHOD(get_Window2)(HWND * hwnd);
    STDMETHOD(put_Window)(long hwnd);
    STDMETHOD(put_Window2)(HWND hwnd);
    STDMETHOD(SetViewport)(long x, long y, long width, long height);
    STDMETHOD(SetClipRect)(long x, long y, long width, long height);
    STDMETHOD(RePaint)(long x, long y, long width, long height);
    STDMETHOD(PaletteChanged)(VARIANT_BOOL bNew);
    STDMETHOD(put_Site)(IDAViewSite * pViewSite);
    STDMETHOD(get_Site)(IDAViewSite ** pViewSite);
    STDMETHOD(put_ClientSite)(IOleClientSite * pClientSite);
    STDMETHOD(get_ClientSite)(IOleClientSite ** pClientSite);

    // IDAViewEvent methods

    STDMETHOD(OnMouseMove)(double when,
                           long x, long y,
                           BYTE modifiers);
    STDMETHOD(OnMouseLeave)(double when);
    STDMETHOD(OnMouseButton)(double when,
                             long x, long y,
                             BYTE button,
                             VARIANT_BOOL bPressed,
                             BYTE modifiers);
    STDMETHOD(OnKey)(double when,
                     long key,
                     VARIANT_BOOL bPressed,
                     BYTE modifiers);
    STDMETHOD(OnFocus)(VARIANT_BOOL bHasFocus);

    STDMETHOD(get_Preferences)(IDAPreferences **prefs);

    STDMETHOD(QueryHitPoint)(DWORD dwAspect,
                             LPCRECT prcBounds,
                             POINT ptLoc,
                             LONG lCloseHint,
                             DWORD *pHitResult);

    STDMETHOD(QueryHitPointEx)(LONG s,
                               DWORD_PTR *cookies,
                               double *points,
                               LPCRECT prcBounds,
                               POINT   ptLoc,
                               LONG *hits);

    STDMETHOD(GetDDD3DRM) (IUnknown **DirectDraw,
                           IUnknown **D3DRM);

    STDMETHOD(GetRMDevice) (IUnknown **D3DRMDevice,
                            DWORD     *SequenceNumber);


    STDMETHOD(GetInvalidatedRects)(DWORD flags,
                                   LONG size,
                                   RECT *pRects,
                                   LONG *pNumRects);
    
    //
    // IServiceProvider interfaces
    //

    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

    CRView * GetView () { return _view ; }

    HRESULT Error();

    CRSTDAPICB_(void) SetStatusText(LPCWSTR StatusText);
    
  private:
    CRView *              _view;
    DWORD                 _dwSafety;
    DAComPtr<IDAViewSite> _vs;
    DAComPtr<IOleClientSite> _pClientSite;
    DWORD                 _startFlags;
};

#endif /* _CVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\engine.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    IDAEngine interface implementation

Revision:

--*/

#ifndef _ENGINE_H_
#define _ENGINE_H_

class IImportSite;

typedef CComClassFactory CDXMClassFactory ;

#define LIBID "DirectAnimation"

#endif  // _ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\drawctx.cpp ===
#include "headers.h"
#include "drawsurf.h"
#include "privinc/stlsubst.h"

DrawingContext::DrawingContext(IDAStatics *st,
                               CDADrawingSurface *ds,
                               DrawingContext *dc) :
    _st(st),
    _ds(ds)
{
    if (dc == NULL) {
        Reset();
    } else {
        // copy all attrs.
        _xf         = dc->_xf;
        _matte      = dc->_matte;
        _op         = dc->_op;
        _ls         = dc->_ls;
        _bs         = dc->_bs;
        _savedLs    = dc->_savedLs;
        _savedBs    = dc->_savedBs;
        _fs         = dc->_fs;
        _cropMin    = dc->_cropMin;
        _cropMax    = dc->_cropMax;
        _fillTex    = dc->_fillTex;
        _fillGrad   = dc->_fillGrad;
        _fore       = dc->_fore;
        _back       = dc->_back;
        _start      = dc->_start;
        _back       = dc->_back;
        _start      = dc->_start;
        _finish     = dc->_finish;
        _power      = dc->_power;

        _fillType   = dc->_fillType;
        _hatchFillOff = dc->_hatchFillOff;
        _mouseEvents= dc->_mouseEvents;
        _scaleX     = dc->_scaleX;
        _scaleY     = dc->_scaleY;
        _extentChgd = dc->_extentChgd;
        _opChgd     = dc->_opChgd;
        _xfChgd     = dc->_xfChgd;
        _cropChgd   = dc->_cropChgd;
        _clipChgd   = dc->_clipChgd;
    }

    Assert(_imgVec.empty());
}

DrawingContext::~DrawingContext() {
    CleanUpImgVec();
}

void DrawingContext::CleanUpImgVec() {
    vector<IDAImage *>::iterator begin = _imgVec.begin();
    vector<IDAImage *>::iterator end = _imgVec.end();

    vector<IDAImage *>::iterator i;
    for (i = begin; i < end; i++) {
        (*i)->Release();
    }
    _imgVec.clear();
}


HRESULT DrawingContext::Reset() {

    _opChgd = false;
    _xfChgd = false;
    _cropChgd = false;
    _clipChgd = false;
    _extentChgd = false;
    _scaleX = true;
    _scaleY = true;
    _hatchFillOff = false;
    _fillType = fill_solid;

    _ls.Release();
    _bs.Release();
    _savedLs.Release();
    _savedBs.Release();
    _fs.Release();
    _xf.Release();
    _fore.Release();
    _back.Release();
    _power.Release();
    _fillTex.Release();
    _fillGrad.Release();

    RETURN_IF_ERROR(_st->get_White(&_fore))
    RETURN_IF_ERROR(_st->get_White(&_back))
    RETURN_IF_ERROR(_st->DANumber(1, &_power))
    RETURN_IF_ERROR(_st->get_DefaultLineStyle(&_ls))
    RETURN_IF_ERROR(_st->get_DefaultFont(&_fs))
    RETURN_IF_ERROR(_st->get_EmptyImage(&_fillTex))
    RETURN_IF_ERROR(_st->get_EmptyImage(&_fillGrad))

    _bs = _ls;
    return _st->get_IdentityTransform2(&_xf);
}

HRESULT DrawingContext::Overlay(IDAImage *img) {

    img->AddRef();
    VECTOR_PUSH_BACK_PTR(_imgVec, img);
    img->AddRef();
    VECTOR_PUSH_BACK_PTR(_ds->_imgVec, img);

    return S_OK;
}

HRESULT DrawingContext::Draw(IDAPath2 *pth, VARIANT_BOOL bFill) {   
    // we must switch to meter mode for the calculations to be valid.
    VARIANT_BOOL pixelMode;
    _st->get_PixelConstructionMode(&pixelMode);
    _st->put_PixelConstructionMode(VARIANT_FALSE);

    // Auto-resetter of pixel mode.
    class PixelModeGrabber {
    public:
        PixelModeGrabber(IDAStatics *st, VARIANT_BOOL mode) : _mode(mode), _st(st) {}
        ~PixelModeGrabber() {
            _st->put_PixelConstructionMode(_mode);
        }

    protected:
        IDAStatics *_st;
        VARIANT_BOOL _mode;
    };

    PixelModeGrabber myGrabber(_st, pixelMode);

    CComPtr<IDAImage> img;

    if (bFill) {
        CComPtr<IDAImage> interiorImg;
        CComPtr<IDAImage> edgeImg;
        CComPtr<IDAImage> fillImg;
        CComPtr<IDAImage> foreFillImg;
        CComPtr<IDAImage> backFillImg;
        CComPtr<IDAMatte> matte;
            
        // Now construct the inner fill image for the path        
        if(_fillType == fill_solid) {    
            RETURN_IF_ERROR(_st->SolidColorImage(_fore, &fillImg)) 
        }
        else if(_fillType == fill_detectableEmpty) {
            RETURN_IF_ERROR(_st->get_DetectableEmptyImage(&fillImg))
        }
        else if((_fillType >= fill_hatchHorizontal) && (_fillType <= fill_hatchDiagonalCross)) 
        {
            // Define a standard hatch size for the drawing surface
            // since the SG control has a fixed hatch size.  
            // This value is chosen to attempt to match it.
            CComPtr<IDANumber> hatchSize;
            RETURN_IF_ERROR(_st->DANumber(.003, &hatchSize))            

            // Fill the foreground image with the appropriate pattern
            if(_fillType == fill_hatchHorizontal) {
                RETURN_IF_ERROR(_st->HatchHorizontalAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchVertical) {
                RETURN_IF_ERROR(_st->HatchVerticalAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchForwardDiagonal) {
                RETURN_IF_ERROR(_st->HatchForwardDiagonalAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchBackwardDiagonal) {
                RETURN_IF_ERROR(_st->HatchBackwardDiagonalAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchCross) {
                RETURN_IF_ERROR(_st->HatchCrossAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchDiagonalCross) {
                RETURN_IF_ERROR(_st->HatchDiagonalCrossAnim(_fore, hatchSize, &foreFillImg))
            }

            // If the hatch background fill is on, overlay a solid color
            if(!_hatchFillOff) {
                RETURN_IF_ERROR(_st->SolidColorImage(_back, &backFillImg))
                RETURN_IF_ERROR(_st->Overlay(foreFillImg,backFillImg, &fillImg))
            }
            else {
                fillImg = foreFillImg;
             }

        }
        else if((_fillType >= fill_horizontalGradient) && (_fillType <= fill_image))
        {
            // The gradient and image fills abide by scaling parameters and hence are grouped
            // together. Fore control compatibility, the vertical and horizontal gradients
            // are the two cases that do not respond to rotation within the start and stop value.

            IDAImage*               tempImg;
            CComPtr<IDAImage>       solidImg;
            CComPtr<IDATransform2>  xf;
            CComPtr<IDABbox2>       bb;
            CComPtr<IDAPoint2>      max,min;
            CComPtr<IDANumber>      xScale,yScale,
                                    pathMinX, pathMinY,
                                    maxx,maxy,minx,miny, 
                                    pathWidth,pathHeight, 
                                    solidMinX, solidMinY,
                                    solidMaxX, solidMaxY,
                                    pathSnapX, pathSnapY,
                                    newGradMinX, newGradMinY, 
                                    newGradMaxX, newGradMaxY,
                                    gradientWidth, gradientHeight,
                                    gradTranslateX, gradTranslateY,
                                    newGradientWidth, newGradientHeight;
            CComPtr<IDAColor>       _newForeVal, _newBackVal;           
            CComPtr<IDABoolean>     yOrientation, xOrientation;

            // If the user specified extents, grab the specified Start and Finish 
            // points and dimensions 
            CComPtr<IDANumber> xStart, yStart, xFinish, yFinish,  newStartVal, newFinishVal,
                               extentWidth, extentHeight, extentDiagonal;                
            if(_extentChgd) {
                RETURN_IF_ERROR(_start->get_X(&xStart))
                RETURN_IF_ERROR(_start->get_Y(&yStart))
                RETURN_IF_ERROR(_finish->get_X(&xFinish))
                RETURN_IF_ERROR(_finish->get_Y(&yFinish))
                RETURN_IF_ERROR(_st->Sub(xFinish, xStart, &extentWidth))
                RETURN_IF_ERROR(_st->Sub(yFinish, yStart, &extentHeight))                
                RETURN_IF_ERROR(_st->DistancePoint2(_start, _finish, &extentDiagonal))
            }
            
            // It is important for us to include the orientation of the intended
            // gradient so the gradient start and stop position can be reversed 
            // and it will have the desired effect. We can get this real easily
            // by swapping the _fore and _back for the gradient types
            // that need it (rather than using complex transformation logic)
            if(_extentChgd && (_fillType == fill_horizontalGradient) ) 
            {
                RETURN_IF_ERROR(_st->LT(xStart, xFinish, &xOrientation))

                RETURN_IF_ERROR(_st->Cond(xOrientation, 
                                          (IDABehavior*)  _fore, 
                                          (IDABehavior*)  _back,
                                          (IDABehavior**) &_newForeVal))

                RETURN_IF_ERROR(_st->Cond(xOrientation, 
                                          (IDABehavior*)  _back, 
                                          (IDABehavior*)  _fore,
                                          (IDABehavior**) &_newBackVal))              

                                RETURN_IF_ERROR(_st->Cond(xOrientation, 
                                          (IDABehavior*)  xStart, 
                                          (IDABehavior*)  xFinish,
                                          (IDABehavior**) &newStartVal))

                                RETURN_IF_ERROR(_st->Cond(xOrientation, 
                                          (IDABehavior*)  xFinish, 
                                          (IDABehavior*)  xStart,
                                          (IDABehavior**) &newFinishVal))

                                xStart.Release();
                                xFinish.Release();
                                xStart = newStartVal;
                                xFinish = newFinishVal;

            } 
            else if(_extentChgd && (_fillType == fill_verticalGradient))
            {
                RETURN_IF_ERROR(_st->GT(yStart, yFinish, &yOrientation))

                RETURN_IF_ERROR(_st->Cond(yOrientation, 
                                          (IDABehavior*)  _fore, 
                                          (IDABehavior*)  _back,
                                          (IDABehavior**) &_newForeVal))

                RETURN_IF_ERROR(_st->Cond(yOrientation, 
                                          (IDABehavior*)  _back, 
                                          (IDABehavior*)  _fore,
                                          (IDABehavior**) &_newBackVal))

                                RETURN_IF_ERROR(_st->Cond(yOrientation, 
                                          (IDABehavior*)  yStart, 
                                          (IDABehavior*)  yFinish,
                                          (IDABehavior**) &newStartVal))

                                RETURN_IF_ERROR(_st->Cond(yOrientation, 
                                          (IDABehavior*)  yFinish, 
                                          (IDABehavior*)  yStart,
                                          (IDABehavior**) &newFinishVal))
                                yStart.Release();
                                yFinish.Release();
                                yStart = newStartVal;
                                yFinish = newFinishVal;                                  
                
            }
            else {
                _newForeVal = _fore;
                _newBackVal = _back;
            }                


            // Create the gradient image based on the gradient fillType:
            CComPtr<IDAImage> gradientImg;            
            if(_fillType == fill_horizontalGradient) {
                RETURN_IF_ERROR(_st->GradientHorizontalAnim(_fore, _back, _power, &gradientImg))
            }
            else if(_fillType == fill_verticalGradient) {                                   
                RETURN_IF_ERROR(_st->GradientHorizontalAnim(_fore, _back, _power, &tempImg))
                RETURN_IF_ERROR(_st->Rotate2(pi/2,&xf))
                RETURN_IF_ERROR(tempImg->Transform(xf, &gradientImg))
                tempImg->Release();
                xf.Release();                
            }
            else if(_fillType == fill_radialGradient) {
                CComPtr<IDANumber> sides;
                RETURN_IF_ERROR(_st->DANumber(40,&sides))                
                RETURN_IF_ERROR(_st->RadialGradientRegularPolyAnim( _fore, _back, 
                                                                    sides, _power, &gradientImg))
            }
            else if(_fillType == fill_lineGradient) {
                RETURN_IF_ERROR(_st->GradientHorizontalAnim(_fore, _back,
                                                            _power, &gradientImg))
            }
            else if(_fillType == fill_rectGradient) {    
                RETURN_IF_ERROR(_st->RadialGradientSquareAnim(_fore, _back,
                                                              _power, &gradientImg))
            }
            else if(_fillType == fill_shapeGradient) {
                gradientImg = _fillGrad;
            }
            else if(_fillType == fill_image) {    
                gradientImg = _fillTex;
            }                     
                                           
            // Now calculate the bounding box of the fill gradient and store 
            // it in gradientWidth and gradientHeight:
            RETURN_IF_ERROR(gradientImg->get_BoundingBox(&bb)) 
            RETURN_IF_ERROR(bb->get_Max(&max))
            RETURN_IF_ERROR(bb->get_Min(&min))
            RETURN_IF_ERROR(max->get_X(&maxx))
            RETURN_IF_ERROR(min->get_X(&minx))
            RETURN_IF_ERROR(max->get_Y(&maxy))
            RETURN_IF_ERROR(min->get_Y(&miny))
            RETURN_IF_ERROR(_st->Sub(maxx,minx, &gradientWidth))
            RETURN_IF_ERROR(_st->Sub(maxy,miny, &gradientHeight))  

            // Stash away max and min Y bounds for later
            solidMinX = minx;         
            solidMinY = miny;
            solidMaxX = maxx;
            solidMaxY = maxy;                        

            // Cleanup variables for reuse -- Release() sets pointer to NULL.
            bb.Release();   max.Release();  min.Release(); 
            maxx.Release(); maxy.Release(); minx.Release(); miny.Release();

            // Calculate the Path bounding box and store it in pathWidth, pathHeight                       
            // Note that the correct bounding box here is the drawn path's bounding box
            CComPtr<IDABbox2> bbBackup, bbTight;
            CComPtr<IDABoolean> nullBbox;
            CComPtr<IDABehavior> tempBB;
            RETURN_IF_ERROR(pth->Draw(_bs, &tempImg))
            RETURN_IF_ERROR(tempImg->get_BoundingBox(&bbTight))
            RETURN_IF_ERROR(bbTight->get_Max(&max))
            RETURN_IF_ERROR(bbTight->get_Min(&min))
            RETURN_IF_ERROR(max->get_X(&maxx))
            RETURN_IF_ERROR(min->get_X(&minx))
            RETURN_IF_ERROR(max->get_Y(&maxy))
            RETURN_IF_ERROR(min->get_Y(&miny))
            RETURN_IF_ERROR(_st->GT(minx, maxx, &nullBbox))
            RETURN_IF_ERROR(pth->BoundingBox(_bs, &bbBackup))
            RETURN_IF_ERROR(_st->Cond(nullBbox, bbBackup, bbTight, &tempBB))
            RETURN_IF_ERROR(tempBB->QueryInterface(IID_IDABbox2, 
                                                                                            (void**)&bb))
            max.Release(); min.Release(); 
            maxx.Release(); minx.Release(); maxy.Release(); miny.Release();
            RETURN_IF_ERROR(bb->get_Max(&max))
            RETURN_IF_ERROR(bb->get_Min(&min))
            RETURN_IF_ERROR(max->get_X(&maxx))
            RETURN_IF_ERROR(min->get_X(&minx))
            RETURN_IF_ERROR(max->get_Y(&maxy))
            RETURN_IF_ERROR(min->get_Y(&miny))
            RETURN_IF_ERROR(_st->Sub(maxx,minx, &pathWidth))
            RETURN_IF_ERROR(_st->Sub(maxy,miny, &pathHeight))            

            // Stash path min points for later
            pathMinX = minx;
            pathMinY = miny;
            tempImg->Release();

            // Cleanup for reuse -- Release() sets pointer to NULL
            bb.Release();   max.Release();  min.Release(); 
            maxx.Release(); maxy.Release(); minx.Release(); miny.Release();


            // If the user has set the gradient extents, set the scaling factors 
            // based on the type of gradient and the Start and Finish measurements.
            if(_extentChgd) {
                if(_fillType == fill_lineGradient) {
                    // Scale the X component of gradient to the extentDiagonal and
                    // Keep the Y component at its current size (1 meter)
                    newGradientWidth = extentDiagonal;                    
                    newGradientHeight = gradientHeight;
                }
                else if(_fillType == fill_verticalGradient) {
                    // Scale the X component of gradient to the path width and 
                    // Scale the Y component to extentHeight
                    newGradientWidth = pathWidth;
                    newGradientHeight = extentHeight;
                }
                else if(_fillType == fill_horizontalGradient) {
                    // Scale the Y component of gradient to the path height and 
                    // Scale the X component to extentWidth 
                    newGradientWidth = extentWidth;
                    newGradientHeight = pathHeight;
                }
                else {
                    // For radial gradients, the distance between points is a radius 
                    // and the image should be scaled by two times the diagonal in
                    // both the X and Y direction.
                    CComPtr<IDANumber> two;
                    RETURN_IF_ERROR(_st->DANumber(2, &two))
                    RETURN_IF_ERROR(_st->Mul(extentDiagonal, two, &newGradientWidth))
                    newGradientHeight = newGradientWidth;
                }
            }

            // Scale the gradient image to the user indicated dimensions.
            if(_scaleX || _scaleY || _extentChgd) {                
                if(_extentChgd)
                   RETURN_IF_ERROR(_st->Div(newGradientWidth,gradientWidth, &xScale))
                else if(_scaleX)                   
                   RETURN_IF_ERROR(_st->Div(pathWidth,gradientWidth, &xScale))
                else
                   RETURN_IF_ERROR(_st->DANumber(1, &xScale))

                if(_extentChgd)
                   RETURN_IF_ERROR(_st->Div(newGradientHeight,gradientHeight, &yScale))
                else if(_scaleY)
                   RETURN_IF_ERROR(_st->Div(pathHeight,gradientHeight, &yScale))
                else
                   RETURN_IF_ERROR(_st->DANumber(1, &yScale))

                RETURN_IF_ERROR(_st->Scale2Anim(xScale, yScale, &xf))
                RETURN_IF_ERROR(gradientImg->Transform(xf, &tempImg))
                gradientImg.p->Release();   
                gradientImg.p = tempImg;               
                xf.Release();
            }      
            
            // Get the new bounds of the gradient image (post scaling) and the 
            // translation vector for moving the image to the path minX and minY
            RETURN_IF_ERROR(gradientImg->get_BoundingBox(&bb))            
            RETURN_IF_ERROR(bb->get_Min(&min))
            RETURN_IF_ERROR(bb->get_Max(&max))
            RETURN_IF_ERROR(min->get_X(&newGradMinX))
            RETURN_IF_ERROR(min->get_Y(&newGradMinY))
            RETURN_IF_ERROR(max->get_X(&newGradMaxX))
            RETURN_IF_ERROR(max->get_Y(&newGradMaxY))
            RETURN_IF_ERROR(_st->Sub(pathMinX, newGradMinX, &pathSnapX))
            RETURN_IF_ERROR(_st->Sub(pathMinY, newGradMinY, &pathSnapY))

            // Cleanup for reuse -- Release() sets pointer to NULL
            bb.Release();   max.Release();  min.Release(); 

            // Here are the final gradient extent specific additions to the image
            if(_extentChgd) {

                // For line gradient types, we must overlay the gradient with the cropped
                // solid image from the foreground. It must be positioned to the left of 
                // the gradient for line and horizontal gradients, and over the gradient 
                // for vertical gradients.               
                if((_fillType == fill_lineGradient)       ||
                   (_fillType == fill_horizontalGradient) ||
                   (_fillType == fill_verticalGradient))
                {                
                    CComPtr<IDAImage> scaledSolidImg, croppedSolidImg;
                    CComPtr<IDANumber> zero, one, negOne, scaleFac;                                                   
                    CComPtr<IDAPoint2> solidMin, solidMax;
                    RETURN_IF_ERROR(_st->DANumber(0, &zero))
                    // BUG: A meter doesn't seem to be meter here. I was creating
                    // a solid that is cropped to 2 meters on a side yet it fits
                    // neatly on the screen without being scaled. The scale by ten 
                    // is a fudge factor to get the desired effect.
                    RETURN_IF_ERROR(_st->DANumber(10, &scaleFac))
                    RETURN_IF_ERROR(_st->DANumber(1, &one))
                    RETURN_IF_ERROR(_st->DANumber(-1, &negOne))
                    RETURN_IF_ERROR(_st->SolidColorImage(_newForeVal, &solidImg))
                    
                    if(_fillType == fill_verticalGradient) {
                        // For vertical gradients, the solid must be cropped at the
                        // bottom at newGradMaxY - solidMinY.
                        RETURN_IF_ERROR(_st->Point2Anim(one,one, &solidMax))
                        RETURN_IF_ERROR(_st->Point2Anim(negOne, zero, &solidMin))
                        RETURN_IF_ERROR(_st->Scale2UniformAnim(scaleFac, &xf))
                    }
                    else {
                        // For horizontal gradients, the solid must be cropped at
                        // the left by newGradMinX - solidMaxX.               
                        RETURN_IF_ERROR(_st->Point2Anim(negOne, negOne, &solidMin))
                        RETURN_IF_ERROR(_st->Point2Anim(zero, one, &solidMax))                                                           
                        RETURN_IF_ERROR(_st->Scale2UniformAnim(scaleFac, &xf))
                    }
                    RETURN_IF_ERROR(solidImg->Crop(solidMin, solidMax, &croppedSolidImg))                    
                    RETURN_IF_ERROR(croppedSolidImg->Transform(xf, &scaledSolidImg))                                                                               
                    RETURN_IF_ERROR(_st->Overlay(gradientImg, scaledSolidImg, &tempImg))                                                  
                    gradientImg.p->Release();
                    gradientImg.p = tempImg;                                        
                    xf.Release();
                }

                // Fold in the rotation component of the extent settings. Note: the rotation
                // does not affect vertical, horizontal, and radial fill styles.               
                if((_fillType != fill_horizontalGradient) &&
                   (_fillType != fill_verticalGradient) &&
                   (_fillType != fill_radialGradient)) 
                {                                                                                     
                    // Rotate to angle atan2(f.y - s.y, f.x - s.x)))                   
                    CComPtr<IDANumber> deltaX, deltaY, delta, angle;                                        
                    RETURN_IF_ERROR(_st->Sub(yFinish, yStart, &deltaY))
                    RETURN_IF_ERROR(_st->Sub(xFinish, xStart, &deltaX))
                    RETURN_IF_ERROR(_st->Atan2(deltaY, deltaX, &angle))                                                    
                    RETURN_IF_ERROR(_st->Rotate2Anim(angle, &xf))
                    RETURN_IF_ERROR(gradientImg->Transform(xf, &tempImg))
                    gradientImg.p->Release();
                    gradientImg.p = tempImg;
                    xf.Release();                                                                                
                }           

                // Finally, complete translation component for the gradient types that
                // support translation and the dimensions that are affected by it.
                if(_fillType == fill_lineGradient) {
                    // For line gradients, the image must be translated
                    // by (xStart - gradMinX, yStart - (gradMaxY + gradMinY)/2).                   
                    CComPtr<IDANumber> tempSum, midY, two;
                    RETURN_IF_ERROR(_st->DANumber(2, &two))
                    RETURN_IF_ERROR(_st->Sub(xStart, newGradMinX, &gradTranslateX))
                    RETURN_IF_ERROR(_st->Add(newGradMaxY, newGradMinY, &tempSum))
                    RETURN_IF_ERROR(_st->Div(tempSum, two, &midY))
                    RETURN_IF_ERROR(_st->Sub(yStart, midY, &gradTranslateY))                  
                }
                else if(_fillType == fill_verticalGradient) {
                    // Ignore the X value in the translation
                    gradTranslateX = pathSnapX;
                    RETURN_IF_ERROR(_st->Sub(yStart, newGradMaxY, &gradTranslateY))
                }
                else if(_fillType == fill_horizontalGradient) {
                    // Ignore the Y value in the translation
                    gradTranslateY = pathSnapY;  
                    RETURN_IF_ERROR(_st->Sub(xStart, newGradMinX, &gradTranslateX))                   
                }
                else {
                    // Translate to startX and startY
                    gradTranslateX = xStart;
                    gradTranslateY = yStart;
                }
                RETURN_IF_ERROR(_st->Translate2Anim(gradTranslateX, gradTranslateY, &xf))
                RETURN_IF_ERROR(gradientImg->Transform(xf, &tempImg))
                gradientImg.p->Release();
                gradientImg.p = tempImg;
            }
            else if((_fillType == fill_image) && (!_scaleX) && (!_scaleY));
                                // This is a fixed image, do nothing            
                        else {
                RETURN_IF_ERROR(_st->Translate2Anim(pathSnapX, pathSnapY, &xf))
                RETURN_IF_ERROR(gradientImg->Transform(xf, &tempImg))      
                gradientImg.p->Release();
                gradientImg.p = tempImg;
            }

            // To simulate a gradient of infinite extent, the backFill color is
            // used to create a solidColorImage and overlaid with the ForeFillImg.
            // This doesn't apply to image fills.
            if(_fillType != fill_image) {
               solidImg.Release();
               RETURN_IF_ERROR(_st->SolidColorImage(_newBackVal, &solidImg))
               RETURN_IF_ERROR(_st->Overlay(gradientImg,solidImg, &fillImg))
            }
            else            
               fillImg = gradientImg;          
        }
        else if(_fillType == fill_texture) {
            RETURN_IF_ERROR(_fillTex->Tile(&fillImg))
        }
        else
            RETURN_IF_ERROR(_st->get_EmptyImage(&fillImg))
       
        RETURN_IF_ERROR(pth->Fill(_bs, fillImg, &img))

    } else {
        RETURN_IF_ERROR(pth->Draw(_ls, &img))
    }

    //
    //  NOTE:  The following code is optimized for CComPtr to avoid unnecessary
    //         addref/release calls.  Since we know that img.p is always valid, we
    //         simply release the reference and reassign it to the new image.
    //
    if (_xfChgd) {
        IDAImage *imgTemp;
        RETURN_IF_ERROR(img->Transform(_xf, &imgTemp))
        img.p->Release();
        img.p = imgTemp;
    }

    if (_opChgd) {
        IDAImage *imgTemp;
        RETURN_IF_ERROR(img->OpacityAnim(_op, &imgTemp))
        img.p->Release();
        img.p = imgTemp;
    }

    if (_cropChgd) {
        IDAImage *imgTemp;
        RETURN_IF_ERROR(img->Crop(_cropMin, _cropMax, &imgTemp))
        img.p->Release();
        img.p = imgTemp;
    }

    if (_clipChgd) {
        IDAImage *imgTemp;
        RETURN_IF_ERROR(img->Clip(_matte, &imgTemp))
        img.p->Release();
        img.p = imgTemp;
    }   

    return Overlay(img);
}

HRESULT DrawingContext::Transform(IDATransform2 *xf) {

    _xfChgd = true;
    IDATransform2 *temp;
    HRESULT hr = _st->Compose2(_xf, xf, &temp);
    if (_xf.p) _xf.p->Release();
    _xf.p = temp;
    return hr;
}

void DrawingContext::SetOpacity(IDANumber *op) {

    _opChgd = true;
    _op = op;
}

void DrawingContext::SetClip(IDAMatte *matte) {

    _clipChgd = true;
    _matte = matte;
}

void DrawingContext::SetCrop(IDAPoint2 *min, IDAPoint2 *max) {

    _cropChgd = true;
    _cropMin = min;
    _cropMax = max;
}

HRESULT DrawingContext::TextPoint(BSTR str, IDAPoint2 *pt)
{
    // we must switch to meter mode for the calculations to be valid.
    VARIANT_BOOL pixelMode;
    _st->get_PixelConstructionMode(&pixelMode);
    _st->put_PixelConstructionMode(VARIANT_FALSE);

    // Auto-resetter of pixel mode.
    class PixelModeGrabber {
    public:
        PixelModeGrabber(IDAStatics *st, VARIANT_BOOL mode) : _mode(mode), _st(st) {}
        ~PixelModeGrabber() {
            _st->put_PixelConstructionMode(_mode);
        }

    protected:
        IDAStatics *_st;
        VARIANT_BOOL _mode;
    };

    PixelModeGrabber myGrabber(_st, pixelMode);

    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->StringPath(str, _fs, &pthTemp))

    CComPtr<IDABbox2> bbox;
    RETURN_IF_ERROR(pthTemp->BoundingBox(_bs, &bbox))

    // The passed in x, y is the lower left corner of the text.
    // We'll move it from (-box.min.x, -box.min.y) to (x, y)
    CComPtr<IDATransform2> xf;
    CComPtr<IDAPoint2> min;
    CComPtr<IDAVector2> xlate;
    CComPtr<IDAPoint2> newmin;
    CComPtr<IDANumber> xmin;
    CComPtr<IDANumber> ymin;

    RETURN_IF_ERROR(bbox->get_Min(&min))
    RETURN_IF_ERROR(min->get_X(&xmin))
    RETURN_IF_ERROR(_st->DANumber(0.0, &ymin))
    RETURN_IF_ERROR(_st->Point2Anim(xmin, ymin, &newmin))
    RETURN_IF_ERROR(_st->SubPoint2(pt, newmin, &xlate))
    RETURN_IF_ERROR(_st->Translate2Vector(xlate, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))

    return Draw(pth, true);
}



HRESULT DrawingContext::SetGradientShape(VARIANT pts) {
    CComPtr<IDAImage> gradient;
    RETURN_IF_ERROR(_st->RadialGradientPolygonAnim(_fore, _back, pts, _power, &gradient))
    _fillGrad = gradient;
    return S_OK;
}

void DrawingContext::SetGradientExtent(IDAPoint2 *start, IDAPoint2 *finish){
    _extentChgd = true;
    _start = start;
    _finish = finish;
}

HRESULT DrawingContext::LineDashStyle(DA_DASH_STYLE id)
{
    // If we're setting to the emtpy dash style, save the current line style
    // into _savedLs before overiding the current line style to empty.
    // If _savedLs is NULL when we enter this routine, it means that the last
    // LineDashStyle call didn't set it to empty style.  Otherwise, the last
    // call sets it to empty style.

    CComPtr<IDALineStyle> newLs;

    if (id == DAEmpty) {
        if (_savedLs != NULL) {
            // the last LineDashStyle also sets the dash style to empty.
            return S_OK;
        }

        RETURN_IF_ERROR(_st->get_EmptyLineStyle(&newLs))
        _savedLs = _ls;

    } else {

        CComPtr<IDADashStyle> dash;  
        CComPtr<IDALineStyle> oldLs;

        // Use the default dash style - solid, if invalid index.
        if (id == DADash) {
            RETURN_IF_ERROR(_st->get_DashStyleDashed(&dash))
        } else {
            RETURN_IF_ERROR(_st->get_DashStyleSolid(&dash))
        }

        if (_savedLs == NULL)
            oldLs = _ls;
        else
            oldLs = _savedLs;

        RETURN_IF_ERROR(oldLs->Dash(dash, &newLs))
        _savedLs.Release();
    }

    _ls = newLs;
    return S_OK;
}

HRESULT DrawingContext::BorderDashStyle(DA_DASH_STYLE id)
{
    // If we're setting to the emtpy dash style, save the current border style
    // into _savedBs before overiding the current line style to empty.
    // If _savedBs is NULL when we enter this routine, it means that the last
    // BorderDashStyle call didn't set it to empty style.  Otherwise, the last
    // call sets it to empty style.

    CComPtr<IDALineStyle> oldBs, newBs;

    if (id == DAEmpty) {
        if (_savedBs != NULL) {
            // the last LineDashStyle also sets the dash style to empty.
            return S_OK;
        }

        RETURN_IF_ERROR(_st->get_EmptyLineStyle(&newBs))
        _savedBs = _bs;

    } else {

        CComPtr<IDADashStyle> dash;
        // Use the default dash style - solid, if invalid index.
        if (id == DADash) {
            RETURN_IF_ERROR(_st->get_DashStyleDashed(&dash))
        } else {
            RETURN_IF_ERROR(_st->get_DashStyleSolid(&dash))
        }

        if (_savedBs == NULL)
            oldBs = _bs;
        else
            oldBs = _savedBs;

        RETURN_IF_ERROR(oldBs->Dash(dash, &newBs))
        _savedBs = NULL;
    }

    _bs = newBs;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\eventq.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Event Queue management

*******************************************************************************/

#include "headers.h"
#include "context.h"
#include "eventq.h"
#include "view.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/probe.h"
#include "privinc/xformi.h"
#include "privinc/xform2i.h"
#include "appelles/image.h"
#include "privinc/mutex.h"
#include "privinc/resource.h"
#include "privinc/registry.h"
#include "privinc/debug.h"

EventQ::EventQ ()
{
    ClearStates () ;
}

EventQ::~EventQ()
{
}

// Offset to distinguish win event of same time
static const Time DIFFERENTIAL_OFFSET = 0.0000001;      

// Ensures events are enqueued sorted by time and no times are the
// same

void
EventQ::Add (AXAWindEvent & ev)
{
    if (!_msgq.empty()) {
        AXAWindEvent & lastEvent = _msgq.back();

        if (ev.when <= lastEvent.when) {
            ev.when = lastEvent.when + DIFFERENTIAL_OFFSET;
        }

        if (ev.id == AXAE_MOUSE_MOVE) {
            _mouseLeft = false;
        }
    }
    
    _msgq.push_back(ev);
}

void
EventQ::ClearStates ()
{
    _mousex = _mousey = 1000000000 ;
    _keysDown.erase(_keysDown.begin(), _keysDown.end());
    _buttonsDown.erase(_buttonsDown.begin(), _buttonsDown.end());
    _resized = FALSE ;
    _mouseLeft = false;
    _mouseLeftTime = 0.0;
}

void
EventQ::Reset ()
{
    _msgq.erase(_msgq.begin(), _msgq.end());
    ClearStates () ;
}

// Keep events for DELTA time
static const Time DELTA = 0.5;

void
EventQ::Prune(Time curTime)
{
    Time cutOff = curTime - DELTA;
    
    while (!_msgq.empty()) {
        AXAWindEvent & ev = _msgq.front();

        if (ev.when > cutOff)
            break;

        switch (ev.id) {
          case AXAE_MOUSE_BUTTON:
            if (ev.bState)
                _buttonsDown.push_front((BYTE) ev.data) ;
            else
                _buttonsDown.remove((BYTE) ev.data) ;
            break;
          case AXAE_KEY:
            if (ev.bState)
                _keysDown.push_front(ev.data) ;
            else
                _keysDown.remove(ev.data) ;
            break;
          case AXAE_MOUSE_MOVE:
            _mousex = ev.x ;
            _mousey = ev.y ;
            break ;
          case AXAE_APP_TRIGGER:
            GCRemoveFromRoots((Bvr) ev.x, GetCurrentGCRoots());
            break;
          case AXAE_FOCUS:
            if (!ev.bState) {
                // When we lose focus clear all the key states
                _keysDown.erase(_keysDown.begin(), _keysDown.end());
            }
            break ;
          default:
            break;
        }

        _msgq.pop_front();
    }
}

// Search for event with event time > t0
AXAWindEvent *
EventQ::OccurredAfter(Time when,
                      AXAEventId id,
                      DWORD data,
                      BOOL bState,
                      BYTE modReq,
                      BYTE modOpt)
{
    for (list<AXAWindEvent>::iterator i = _msgq.begin();
         i != _msgq.end();
         i++) {
        
        if ((*i).id == id &&
            (*i).data == data &&
            (*i).bState == bState &&
            ((*i).modifiers & modReq) == modReq &&
            ((*i).modifiers & (~modOpt)) == 0 &&
            (*i).when > when) {

            return &(*i);
        }
    }

    return NULL;
}

BOOL
EventQ::GetState(Time when,
                 AXAEventId id,
                 DWORD data,
                 BYTE mod)
{
    // Look through the list to see if we have any messages
    // Start looking from the end and if we find one return it
    
    for (list<AXAWindEvent>::reverse_iterator i = _msgq.rbegin();
         i != _msgq.rend();
         i++) {
             
        AXAWindEvent & ev = *i;

        if (ev.when > when)
            continue;

        // If we are looking for a key press and we have a lost focus
        // event then the key cannot be pressed
        if (ev.id == AXAE_FOCUS &&
            id == AXAE_KEY &&
            !ev.bState) {
            return FALSE ;
        }

        // Found the latest state - return it
        if (ev.id == id && ev.data == data && ev.modifiers == mod)
            return ev.bState ;
    }
    
    // Lookup the last known state

    switch (id) {
      case AXAE_MOUSE_BUTTON:
        {
            for (list<BYTE>::iterator i = _buttonsDown.begin();
                 i != _buttonsDown.end();
                 i++) {

                if (*i == data) return TRUE ;
            }

            break ;
        }
      case AXAE_KEY:
        {
            for (list<DWORD>::iterator i = _keysDown.begin();
                 i != _keysDown.end();
                 i++) {
                if (*i == data) return TRUE ;
            }

            break ;
        }
      default:
        RaiseException_InternalError ("EventGetState: Invalid event type") ;
    }

    // The data was out of range - return FALSE
    
    return FALSE ;
}

void
EventQ::GetMousePos(Time when, DWORD & x, DWORD & y)
{
    // Look through the list to see if we have any messages
    // Start looking from the end and if we find one return it
    
    for (list<AXAWindEvent>::reverse_iterator i = _msgq.rbegin();
         i != _msgq.rend();
         i++) {

        AXAWindEvent & ev = *i;

        if (ev.when > when)
            continue;

        if (ev.id == AXAE_MOUSE_MOVE || ev.id == AXAE_MOUSE_BUTTON) {
            x = ev.x ;
            y = ev.y ;
            return;
        }
    }

    // No queued events - return last known position

    x = _mousex ;
    y = _mousey ;
}

void
EventQ::MouseLeave(Time when)
{
    _mouseLeft = true;
    _mouseLeftTime = when;
} 

bool
EventQ::IsMouseInWindow(Time when)
{
    if (_mouseLeft && (when > _mouseLeftTime)) {
        return false;
    }

    return true;
}

// ======================================================
// C Functions
// ======================================================

AXAWindEvent* AXAEventOccurredAfter(Time when,
                                    AXAEventId id,
                                    DWORD data,
                                    BOOL bState,
                                    BYTE modReq,
                                    BYTE modOpt)
{ return GetCurrentEventQ().OccurredAfter(when, id, data, bState,
                                          modReq, modOpt) ; }

BOOL AXAEventGetState(Time when,
                      AXAEventId id,
                      DWORD data,
                      BYTE mod)
{ return GetCurrentEventQ().GetState(when, id, data, mod) ; }

void AXAGetMousePos(Time when, DWORD & x, DWORD & y)
{ GetCurrentEventQ().GetMousePos (when, x, y) ; }

BOOL AXAWindowSizeChanged()
{ return GetCurrentEventQ().IsResized() ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\eventq.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

*******************************************************************************/


#ifndef _AXAEVENTQ_H
#define _AXAEVENTQ_H

class EventQ
{
  public:
    EventQ () ;
    ~EventQ () ;

    void Add (AXAWindEvent & evt) ;
    void Prune (Time curTime) ;

    AXAWindEvent * OccurredAfter(Time when,
                                 AXAEventId id,
                                 DWORD data,
                                 BOOL bState,
                                 BYTE modReq,
                                 BYTE modOpt) ;
    
    BOOL GetState(Time when,
                  AXAEventId id,
                  DWORD data,
                  BYTE mod) ;

    void GetMousePos(Time when, DWORD & x, DWORD & y) ;

    void MouseLeave(Time when);
    bool IsMouseInWindow(Time when);

    void Reset () ;

    // This is cleared when the event queue is cleared
    void SizeChanged(BOOL b) { _resized = b ; }
    BOOL IsResized() { return _resized ; }
  protected:
    list < DWORD > _keysDown;
    list < BYTE > _buttonsDown;
    DWORD _mousex;
    DWORD _mousey;
    list< AXAWindEvent > _msgq ;

    BOOL  _resized;

    bool  _mouseLeft;
    Time  _mouseLeftTime;

    // Needs to be callable from constructor
    void ClearStates () ;
} ;

#endif /* _AXAEVENTQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\events.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of views.

*******************************************************************************/


#include "headers.h"
#include "cview.h"
#include "axadefs.h"

DeclareTag(tagCViewEvent, "CView", "CView IDAViewEvent methods");

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnMouseMove
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnMouseMove(double when, 
                   long x, long y,
                   BYTE modifiers)
{
    TraceTag((tagCViewEvent,
              "CView(%lx)::OnMouseMove(%lg, %ld, %ld, %hd)",
              this, when, x, y, modifiers));

    
    if (CROnMouseMove(_view, when, x, y, modifiers))
    {
        Fire_OnMouseMove(when, x, y, modifiers);
        return S_OK;
    }
    else
    {
        return Error();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnMouseLeave
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnMouseLeave(double when)
{
    TraceTag((tagCViewEvent,
              "CView(%lx)::OnMouseLeave(%lg, %ld)",
              this, when));

    
    if (CROnMouseLeave(_view, when))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnMouseButton
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnMouseButton(double when, 
                     long x, long y,
                     BYTE button,
                     VARIANT_BOOL bPressed,
                     BYTE modifiers)
{
    TraceTag((tagCViewEvent,
              "CView(%lx)::OnMouseButton(%lg, %ld, %ld, %hd, %s, %hd)",
              this, when, x, y,
              button, (bPressed?"Down":"Up"),
              modifiers));

    if (CROnMouseButton(_view,
                        when,
                        x, y, button,
                        bPressed?true:false,
                        modifiers))
    {
        Fire_OnMouseButton(when, x, y, button, bPressed, modifiers);
        return S_OK;
    }
    else
    {
        return Error();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnKey
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnKey(double when, 
             long key,
             VARIANT_BOOL bPressed,
             BYTE modifiers)

{
    TraceTag((tagCViewEvent,
              "CView(%lx)::OnKey(%lg, %lx, %s, %hd)",
              this, when, key,
              (bPressed?"Down":"Up"), modifiers));

    if (CROnKey(_view,
                when,
                key,
                bPressed?true:false,
                modifiers))
    {
        Fire_OnKey(when, key, bPressed, modifiers);
        return S_OK;
    }
    else
    {
        return Error();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnFocus
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnFocus(VARIANT_BOOL bHasFocus)
{
    TraceTag((tagCViewEvent, "CView(%lx)::OnFocus(%s)",
              this,
              (bHasFocus?"TRUE":"FALSE")));
    
    if (CROnFocus(_view, bHasFocus?true:false))
    {
        Fire_OnFocus(bHasFocus);
        return S_OK;
    }
    else
    {
        return Error();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\drawsurf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    DrawingSurface interface

*******************************************************************************/


#ifndef _DADRARSURF_H
#define _DADRARSURF_H

#include "cbvr.h"
#include "engine.h"
#include "statics.h"
#include "srvprims.h"
#include "comconv.h"


#define RETURN_IF_ERROR(fn) {HRESULT hr = fn; if (FAILED(hr)) return hr; }

class DrawingContext;

//-------------------------------------------------------------------------
//
//  Class:      CDADrawingSurface
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class
__declspec(uuid("6230F9F9-D221-11d0-9385-00C04FB6BD36")) 
ATL_NO_VTABLE CDADrawingSurface : public CComObjectRootEx<CComMultiThreadModel>,
                            public CComCoClass<CDADrawingSurface, &__uuidof(CDADrawingSurface)>,
                            public IDispatchImpl<IDADrawingSurface, &IID_IDADrawingSurface, &LIBID_DirectAnimation>,
                            public IObjectSafetyImpl<CDADrawingSurface>,
                            public ISupportErrorInfoImpl<&IID_IDADrawingSurface>
{
  friend class DrawingContext;

  public:
#if _DEBUG
    const char * GetName() { return "CDADrawingSurface"; }
#endif
    BEGIN_COM_MAP(CDADrawingSurface)
        COM_INTERFACE_ENTRY(IDADrawingSurface)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()

    // IDADrawingSurface methods

    STDMETHOD(get_Image)(IDAImage ** img);
    STDMETHOD(put_LineStyle)(IDALineStyle *ls);
    STDMETHOD(put_BorderStyle)(IDALineStyle *bs);
    STDMETHOD(put_FontStyle)(IDAFontStyle *fs);
    STDMETHOD(put_ClipMatte)(IDAMatte *matte);
    STDMETHOD(put_MouseEventsEnabled)(VARIANT_BOOL on);
    STDMETHOD(put_HatchFillTransparent)(VARIANT_BOOL fillOff);
    STDMETHOD(get_LocalContextImage)(IDAImage ** img);

    STDMETHOD(Reset)();
    STDMETHOD(Clear)();
    STDMETHOD(SaveGraphicsState)();
    STDMETHOD(RestoreGraphicsState)();
    STDMETHOD(Opacity)(double opac);
    STDMETHOD(OpacityAnim)(IDANumber *opac);

    STDMETHOD(Crop)(double minX, double minY, double maxX, double maxY);
    STDMETHOD(CropPoints)(IDAPoint2 *min, IDAPoint2 *max);
    STDMETHOD(Transform)(IDATransform2 *xform);

    STDMETHOD(LineColor)(IDAColor *clr);
    STDMETHOD(LineWidth)(double width);
    STDMETHOD(LineDashStyle)(DA_DASH_STYLE id);
    STDMETHOD(LineEndStyle)(DA_END_STYLE id);
    STDMETHOD(LineJoinStyle)(DA_JOIN_STYLE id);

    STDMETHOD(BorderColor)(IDAColor *clr);
    STDMETHOD(BorderWidth)(double width);
    STDMETHOD(BorderDashStyle)(DA_DASH_STYLE id);
    STDMETHOD(BorderEndStyle)(DA_END_STYLE id);
    STDMETHOD(BorderJoinStyle)(DA_JOIN_STYLE id);

    STDMETHOD(Font)(BSTR FontFace, LONG sizeInPoints,
                    VARIANT_BOOL Bold, VARIANT_BOOL italic,
                    VARIANT_BOOL underline, VARIANT_BOOL strikethrough);

    // Fill Type selection methods 
    STDMETHOD(TextureFill)(IDAImage *obsolete1, double obsolete2, double obsolete3);
    STDMETHOD(ImageFill)(IDAImage *obsolete1, double obsolete2, double obsolete3);
    STDMETHOD(FillTexture)(IDAImage *img);
    STDMETHOD(FillImage)(IDAImage *img);
    STDMETHOD(FillStyle)(int ID);
    STDMETHOD(FillColor)(IDAColor *foreground);
    STDMETHOD(SecondaryFillColor)(IDAColor *val);

    STDMETHOD(GradientShape)(VARIANT pts);
    STDMETHOD(GradientExtent)(double startx, double starty, double finishx, double finishy);
    STDMETHOD(GradientExtentPoints)(IDAPoint2 *start, IDAPoint2 *stop);
    STDMETHOD(GradientRolloffPower)(double power);
    STDMETHOD(GradientRolloffPowerAnim)(IDANumber *power);

    STDMETHOD(FixedFillScale)();
    STDMETHOD(HorizontalFillScale)();
    STDMETHOD(VerticalFillScale)();
    STDMETHOD(AutoSizeFillScale)();    

    // IDADrawingSurface Draw methods
    STDMETHOD(PolylineEx)(LONG numPts, IDAPoint2 *pts[]);
    STDMETHOD(Polyline)(VARIANT pts);
    STDMETHOD(PolygonEx)(LONG numPts, IDAPoint2 *pts[]);
    STDMETHOD(Polygon)(VARIANT pts);
    STDMETHOD(LinePoints)(IDAPoint2 *point1, IDAPoint2 *point2);
    STDMETHOD(Line)(double startX, double startY,
                          double endX, double endY);
    STDMETHOD(ArcRadians)(double x, double y, double startAngle, double endAngle, double arcWidth, double arcHeight);
    STDMETHOD(ArcDegrees)(double x, double y, double startAngle, double endAngle, double arcWidth, double arcHeight);
    STDMETHOD(Oval)(double x, double y, double width, double height);
    STDMETHOD(Rect)(double x, double y, double width, double height);
    STDMETHOD(RoundRect)(double x, double y,
                         double width, double height,
                         double arcWidth, double arcHeight);
    STDMETHOD(PieRadians)(double x, double y, double startAngle, double endAngle, double arcWidth, double arcHeight);
    STDMETHOD(PieDegrees)(double x, double y, double startAngle, double endAngle, double arcWidth, double arcHeight);
    STDMETHOD(Text)(BSTR str, double x, double y);
    STDMETHOD(TextPoint)(BSTR str, IDAPoint2 *pt);
    STDMETHOD(FillPath)(IDAPath2 *path);
    STDMETHOD(DrawPath)(IDAPath2 *path);
    STDMETHOD(OverlayImage)(IDAImage *img);

    // BUGBUG -- What happens with this template parameter? vector<>??
    HRESULT OverlayImages(vector<IDAImage *> &imgVec, IDAImage **ppimg);

    CDADrawingSurface();
    virtual ~CDADrawingSurface();
    HRESULT Init(IDAStatics *st);

    DrawingContext *GetCurrentContext();
    void CleanUpImgVec();

    CComPtr<IDAStatics>    _st;
    stack<DrawingContext*> _ctxStack;
    vector<IDAImage *>     _imgVec;
};

class DrawingContext
{
public:
    DrawingContext(IDAStatics *st, CDADrawingSurface *ds,
                   DrawingContext *dc = NULL);
    ~DrawingContext();

    void SetLineStyle(IDALineStyle *ls) { _ls = ls; }
    void SetBorderStyle(IDALineStyle *bs) { _bs = bs; }
    void SetFontStyle(IDAFontStyle *fs) { _fs = fs; }
    void SetOpacity(IDANumber *op);
    void SetCrop(IDAPoint2 *min, IDAPoint2 *max);
    void SetClip(IDAMatte *matte);
    void SetXScaling(bool scaleX) { _scaleX = scaleX; }
    void SetYScaling(bool scaleY) { _scaleY = scaleY; }
    void SetForeColor(IDAColor *fore) { _fore = fore; }
    void SetBackColor(IDAColor *back) { _back = back; }
    void SetHatchFill(bool fillOff) { _hatchFillOff = fillOff; }
    void SetTexture(IDAImage *img) { _fillTex = img; }
    void SetGradientExtent(IDAPoint2 *start, IDAPoint2 *finish);
    void SetGradientRolloffPower(IDANumber *power) { _power = power; }
    void SetFillStyle(int type) { _fillType = type; }
    void SetMouseEventsEnabled(bool val) { _mouseEvents = val; }
    void CleanUpImgVec();
    vector<IDAImage *> imgVec()             {return _imgVec;}

    HRESULT LineDashStyle(DA_DASH_STYLE id);
    HRESULT BorderDashStyle(DA_DASH_STYLE id);
    HRESULT SetGradientShape(VARIANT pts);
    HRESULT Transform(IDATransform2 *xf);
    HRESULT TextPoint(BSTR str, IDAPoint2 *pt);
    HRESULT Draw(IDAPath2 *pth, VARIANT_BOOL bFill);
    HRESULT Overlay(IDAImage *img);
    HRESULT Reset();

    IDALineStyle * GetLineStyle()    { return _ls; }
    IDALineStyle * GetBorderStyle()  { return _bs; }

private:
    CComPtr<IDAStatics>     _st;
    CComPtr<IDATransform2>  _xf;
    CComPtr<IDAMatte>       _matte;
    CComPtr<IDANumber>      _op;
    CComPtr<IDALineStyle>   _ls;
    CComPtr<IDALineStyle>   _bs;
    CComPtr<IDALineStyle>   _savedLs;
    CComPtr<IDALineStyle>   _savedBs;
    CComPtr<IDAFontStyle>   _fs;
    CComPtr<IDAPoint2>      _cropMin;
    CComPtr<IDAPoint2>      _cropMax;
    CComPtr<IDAImage>       _fillTex;
    CComPtr<IDAImage>       _fillGrad;
    CComPtr<IDAColor>       _fore;
    CComPtr<IDAColor>       _back;
    CComPtr<IDAPoint2>      _start;
    CComPtr<IDAPoint2>      _finish;
    CComPtr<IDANumber>      _power;


    vector<IDAImage *>  _imgVec;
    CDADrawingSurface   *_ds;
    int                 _fillType;
    bool                _mouseEvents;
    bool                _scaleX, _scaleY;
    bool                _hatchFillOff;
    bool                _extentChgd;
    bool                _opChgd;
    bool                _xfChgd;
    bool                _cropChgd;
    bool                _clipChgd;
};

enum {  // Fill Styles
    fill_empty = 0,
    fill_solid = 1,
    fill_detectableEmpty = 2,
    fill_hatchHorizontal = 3,
    fill_hatchVertical = 4,
    fill_hatchForwardDiagonal = 5,
    fill_hatchBackwardDiagonal = 6,
    fill_hatchCross = 7,
    fill_hatchDiagonalCross = 8,
    fill_horizontalGradient = 9,
    fill_verticalGradient = 10,
    fill_radialGradient = 11,
    fill_lineGradient = 12,  
    fill_rectGradient = 13,
    fill_shapeGradient = 14,
    fill_image = 15,
    fill_texture = 16
};
#endif /* _DADRAWSURF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\daviewevents.h ===
#include "..\..\types\idl\danimid.h"

//////////////////////////////////////////////////////////////////////////////
// CProxy_IDAViewEvents
template <class T>
class CProxy_IDAViewEvents : public IConnectionPointImpl<T, &DIID__IDAViewEvents, CComDynamicUnkArray>
{
public:
    //methods:
    //_IDAViewEvents : IDispatch
public:

    void Fire_Start()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_START, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
 
    void Fire_Stop()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_STOP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_OnMouseMove(double when,
                          LONG xPos, 
                          LONG yPos,
                          short modifiers)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
		    if (*pp != NULL)
            {
                pvars[3].vt = VT_R8;
                pvars[3].dblVal = when;
                pvars[2].vt = VT_I4;
                pvars[2].lVal = xPos;
                pvars[1].vt = VT_I4;
                pvars[1].lVal = yPos;
                pvars[0].vt = VT_I2;
                pvars[0].bVal = modifiers;
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ONMOUSEMOVE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }
    
    
    void Fire_OnMouseButton(double when,
                           LONG xPos, 
                           LONG yPos,
                           short button,
                           VARIANT_BOOL bPressed,
                           short modifiers)
    {
        VARIANTARG* pvars = NEW VARIANTARG[6];
        for (int i = 0; i < 6; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[5].vt = VT_R8;
                pvars[5].dblVal = when;
                pvars[4].vt = VT_I4;
                pvars[4].lVal = xPos;
                pvars[3].vt = VT_I4;
                pvars[3].lVal= yPos;
                pvars[2].vt = VT_I2;
                pvars[2].bVal = button;
                pvars[1].vt = VT_BOOL;
                pvars[1].boolVal = bPressed;
                pvars[0].vt = VT_I2;
                pvars[0].bVal = modifiers;
                
                DISPPARAMS disp = { pvars, NULL, 6, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ONMOUSEBUTTON, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnKey(double when,
                    LONG key,
                    VARIANT_BOOL bPressed,
                    short modifiers)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[3].vt = VT_R8;
                pvars[3].dblVal = when;
                pvars[2].vt = VT_I4;
                pvars[2].lVal = key;
                pvars[1].vt = VT_BOOL;
                pvars[1].boolVal = bPressed;
                pvars[0].vt = VT_I2;
                pvars[0].bVal = modifiers;
                
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ONKEY, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnFocus(VARIANT_BOOL bHasFocus)
    {
        VARIANTARG* pvars = NEW VARIANTARG[1];

        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_BOOL;
                pvars[0].boolVal= bHasFocus;
                
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ONFOCUS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }
 
    void Fire_Pause()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_PAUSE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
 
    void Fire_Resume()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_RESUME, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_Error(HRESULT HResult, LPCWSTR ErrorString)
    {
        VARIANTARG* pvars = NEW VARIANTARG[2];
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= (long)HResult;
                pvars[1].vt = VT_BSTR;
                pvars[1].bstrVal= SysAllocString(ErrorString);
                
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ERROR, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                SysFreeString(pvars[1].bstrVal);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }
 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\impgeom.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/
   importing image media.

*******************************************************************************/

#include "headers.h"
#include "import.h"
#include "include/appelles/axaprims.h"
#include "include/appelles/readobj.h"

#if INCLUDE_VRML
//-------------------------------------------------------------------------
//  Wrl import site
//--------------------------------------------------------------------------
void ImportWrlSite::OnComplete()
{
    TraceTag((tagImport, "ImportWrlSite::OnComplete for %s", m_pszPath));

    __try {
        Geometry *geo = ReadVrmlForImport(m_pszPath);
        if (fBvrIsValid(m_bvr))
            SwitchOnce(m_bvr, ConstBvr(geo));
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        OnError();
    }

    ImportGeomSite::OnComplete();
}


void ImportWrlSite::ReportCancel(void)
{
    ImportGeomSite::ReportCancel();
}
#endif

//-------------------------------------------------------------------------
//  X import site
//--------------------------------------------------------------------------
void ImportXSite::OnComplete()
{
    TraceTag((tagImport, "ImportXSite::OnComplete for %s", m_pszPath));

    __try {
        Geometry *geo = ReadXFileForImport
                        (m_pszPath, _v1Compatible, _wrap ? &_wrapInfo : NULL);
        if (fBvrIsValid(m_bvr))
            SwitchOnce(m_bvr, ConstBvr(geo));
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        OnError();
    }

    ImportGeomSite::OnComplete();
}


void ImportXSite::ReportCancel(void)
{
    ImportGeomSite::ReportCancel();
}

//-------------------------------------------------------------------------
//  Geom import site
//--------------------------------------------------------------------------
void
ImportGeomSite::OnError(bool bMarkFailed)
{
    HRESULT hr = DAGetLastError();
    LPCWSTR sz = DAGetLastErrorString();

    if (bMarkFailed && fBvrIsValid(m_bvr))
        ImportSignal(m_bvr, hr, sz);

    IImportSite::OnError();
}

void ImportGeomSite::ReportCancel(void)
{
    if (fBvrIsValid(m_bvr)) {
        char szCanceled[MAX_PATH];
        LoadString(hInst,IDS_ERR_ABORT,szCanceled,sizeof(szCanceled));
        ImportSignal(m_bvr, E_ABORT, szCanceled);
    }
    IImportSite::ReportCancel();
}

void ImportGeomSite::OnComplete()
{
    if (fBvrIsValid(m_bvr))
        ImportSignal(m_bvr);

    IImportSite::OnComplete();
}

bool ImportGeomSite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = IImportSite::fBvrIsDying(deadBvr);
    if (deadBvr == m_bvr) {
        m_bvr = NULL;
    }
    if (m_bvr)
        return false;
    else
        return fBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\impimage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/ 
   importing image media. 

*******************************************************************************/
#include "headers.h"
#include "privinc/backend.h"
#include "import.h"
#include "include/appelles/axaprims.h"
#include "include/appelles/readobj.h"
#include "privinc/movieimg.h"
#include "impprim.h"
//-------------------------------------------------------------------------
//  Image import site
//--------------------------------------------------------------------------


void
ImportImageSite::OnError(bool bMarkFailed)
{
    HRESULT hr = DAGetLastError();
    LPCWSTR sz = DAGetLastErrorString();
    
    if (bMarkFailed && fBvrIsValid(m_bvr))
        ImportSignal(m_bvr, hr, sz);

    IImportSite::OnError();
}
    
void ImportImageSite::ReportCancel(void)
{
    if (fBvrIsValid(m_bvr)) {
        char szCanceled[MAX_PATH];
        LoadString(hInst,IDS_ERR_ABORT,szCanceled,sizeof(szCanceled));
        ImportSignal(m_bvr, E_ABORT, szCanceled);
    }
    IImportSite::ReportCancel();
}
    
void ImportImageSite::OnComplete()
{
    int count = 0;
    int *delays = (int*)ThrowIfFailed(malloc(sizeof(int)));
    int loop = 0;

    TraceTag((tagImport, "ImportImageSite::OnComplete for %s", m_pszPath));

    Image **p;

    // See if it's a type we handle natively.
    
    __try {
        // ReadDibForImport returns an array that's allocated on
        // GCHeap 
    
        p = ReadDibForImport(const_cast<char*>(GetPath()),
                             GetCachePath(),
                             GetStream(),
                             m_useColorKey,
                             m_ckRed,
                             m_ckGreen,
                             m_ckBlue,
                             &count, 
                             &delays,
                             &loop);

        Bvr importedImageBvr = NULL;
    
        if (p) {
            if (count == 1) {
        
                importedImageBvr = ConstBvr(*p);
    
                // Free the return array as we're only interested in the first
                // element. 
                StoreDeallocate(GetGCHeap(), p);
            } else {
                // animated images
                importedImageBvr = AnimImgBvr(p, count, delays, loop);
            }
        }

        if (importedImageBvr && fBvrIsValid(m_bvr)) {
            SwitchOnce(m_bvr, importedImageBvr);
        }
        
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        OnError();
    }

    if (fBvrIsValid(m_bvr))
        ImportSignal(m_bvr);

    IImportSite::OnComplete();    
}


bool ImportImageSite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = IImportSite::fBvrIsDying(deadBvr);
    if (deadBvr == m_bvr) {
        m_bvr = NULL;
    }
    if (m_bvr)
        return FALSE;
    else
        return fBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\impmovie.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/ 
   importing image media. 

*******************************************************************************/
#include "headers.h"
#include "import.h"
#include "include/appelles/axaprims.h"
#include "include/appelles/readobj.h"
#include "privinc/movieimg.h"
#include "privinc/soundi.h"
#include "privinc/miscpref.h"
#include "impprim.h"
#include "backend/sndbvr.h"

//-------------------------------------------------------------------------
//  Movie import site
//--------------------------------------------------------------------------
void
ImportMovieSite::OnError(bool bMarkFailed)
{
    HRESULT hr = S_OK; // all import errs are handled (was: DAGetLastError())
    LPCWSTR sz = DAGetLastErrorString();
    
    if(bMarkFailed) {
        if(fBvrIsValid(_soundBvr))
            ImportSignal(_soundBvr, hr, sz);
        if(fBvrIsValid(_imageBvr))
            ImportSignal(_imageBvr, hr, sz);
    }

    StreamableImportSite::OnError();
}
    

void ImportMovieSite::ReportCancel(void)
{
    // @@@ XXX shouldn't we change this to be natively wide strings ?
    char szCanceled[MAX_PATH];
    LoadString(hInst,IDS_ERR_ABORT,szCanceled,sizeof(szCanceled));
    if(fBvrIsValid(_soundBvr))
        ImportSignal(_soundBvr, E_ABORT, szCanceled);
    if(fBvrIsValid(_imageBvr))
        ImportSignal(_imageBvr, E_ABORT, szCanceled);
    StreamableImportSite::ReportCancel();
}
    

bool
EnableAVmode() // enable avmode based on the criteria of the day
{
    // registry(if present) overides tracetag (if debug) which overides default
    // we also check to ensure that all the post 4.0.1 amstream interfaces 
    //    needed for avmode are present

    // ----> CHANGE THE DEFAULT AVMODE HERE! <-----
    bool movieFix = true;  // default to on!

#ifdef REMOVEDFORNOW
#if _DEBUG
    // if debug set movieFix to tracetag value (subject to registry overide)
    movieFix = IsTagEnabled(tagMovieFix) ? true : false;
#endif
#endif

    { // open registry key, read value
    HKEY hKey;
    char *subKey = "Software\\Microsoft\\DirectAnimation\\Preferences\\AUDIO";
    char *valueName = "avmode";
    DWORD     type;
    DWORD     data;
    DWORD     dataSize = sizeof(data);

    // does reg entry exist?
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, subKey, 
                                      NULL, KEY_ALL_ACCESS, &hKey)) {

        // if we can read value...
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, valueName, NULL, &type,
                                      (LPBYTE) &data, &dataSize))
            movieFix = data ? true : false; // force mode if regentry exists
    }

    RegCloseKey(hKey);
    }

    if(!QuartzAVmodeSupport())
        movieFix = false;  // dissable if we have an old amstream

return(movieFix);
}

void ImportMovieSite::OnComplete()
{
    int delay = -1; // default to -1
    double videoLength = 0.0, soundLength = 0.0;

    TraceTag((tagImport, "ImportMovieSite::OnComplete for %s", m_pszPath));

    LeafSound      *sound  = NULL;
    Bvr      movieImageBvr = NULL;

    // pick pathname 'raw' url for streaming or urlmon download path
    char *pathname = GetStreaming() ? m_pszPath : GetCachePath();
    Assert(pathname);

    bool _enableAVmode = EnableAVmode(); 

    if(!_enableAVmode) {
        // conventional code path, attempt to create 1 sound and 1 movie object
        TraceTag((tagAVmodeDebug,
            "ImportMovieSite::OnComplete seperate A and V movie creation"));
        __try {
            sound = ReadQuartzAudioForImport(pathname, &soundLength);
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            sound   = NULL;  // FAILED! OK, we will try to continue w/o audio
        }
        
        __try {
            movieImageBvr = ReadQuartzVideoForImport(pathname, &videoLength);
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            // FAILED! OK, we will try to continue w/o video
            movieImageBvr = NULL; 
        }
    }
    else {
        // wild'n'crazy workaround mode.  Create one object both audio, video
        TraceTag((tagAVmodeDebug,
            "ImportMovieSite::OnComplete AV movie creation"));

        __try {
            ReadAVmovieForImport(pathname, &sound, &movieImageBvr, &videoLength);
            soundLength = videoLength;  // these are boundup together!
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            movieImageBvr = NULL; // FAILED!
            sound      = NULL; // FAILED!
        }
    }
    

    __try {
        // Switch only after importing everything.  Should probably lock
        // the switchers for to make these synchronized but that still
        // wouldn't guarantee that they would happen on the same frame.
        if(!sound && !movieImageBvr) {  // did we fail completely?
            // The errors have already been set
            RaiseException_UserError();
        }
        else {  // at least we have audio or video
            if(sound && fBvrIsValid(_soundBvr))
                SwitchOnce(_soundBvr, SoundBvr(sound));
            else if(fBvrIsValid(_soundBvr))
                SwitchOnce(_soundBvr, ConstBvr(silence));

            if (movieImageBvr && fBvrIsValid(_imageBvr))
                SwitchOnce(_imageBvr, movieImageBvr);
            else if(fBvrIsValid(_imageBvr))
                SwitchOnce(_imageBvr, ConstBvr(emptyImage));

            double length;
            if(sound && movieImageBvr)
                length = (soundLength > videoLength) ? soundLength : videoLength;
            else if(movieImageBvr)
                length = videoLength;
            else
                length = soundLength;
            if(fBvrIsValid(_lengthBvr)) {
                // XXX TODO DON'T CALCULATE LENGTH if _lengthBvr isn't valid!
                SwitchOnce(_lengthBvr, NumToBvr(length)); 
            }
        }
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        // ImportSignal only needed to be explicitly called if for some reason
        // there exists a failure.  Switch once calls Signal and is side 
        // effecting nulling the bvr member on the import object
        if(fBvrIsValid(_imageBvr))
           ImportSignal(_imageBvr);
        if(fBvrIsValid(_soundBvr))
           ImportSignal(_soundBvr);
    }

    // SwitchOnce, or failing that, ImportSignal should have nulled these
    Assert(!_imageBvr); 
    Assert(!_soundBvr);

    StreamableImportSite::OnComplete();
}


bool ImportMovieSite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = StreamableImportSite::fBvrIsDying(deadBvr);
    if(deadBvr == _imageBvr) {
        _imageBvr = NULL;
    }
    else if(deadBvr == _soundBvr) {
        _soundBvr = NULL;
    }
    else if(deadBvr == _lengthBvr) {
        _lengthBvr = NULL;
    }
    if(_imageBvr || _soundBvr || _lengthBvr)
        return false;
    else
        return fBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\oleobj.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

DeclareTag(tagATL, "ATL", "Trace Messages");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\import.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    async moniker import header

Revision:

--*/
#ifndef _IMPORT_H_
#define _IMPORT_H_

#include "privinc/comutil.h"
#include "privinc/ipc.h"
#include "backend/bvr.h"
#include "privinc/importgeo.h"

//-------------------------------------------
//forward declarations
//-------------------------------------------
class IImportSite;

void SetImportOnBvr(IImportSite * import,Bvr b);
void SetImportOnEvent(IImportSite * import,Bvr b);

class ImportThread : public DAThread
{
  public:
    // This is callable from any thread to add an import to the import
    // queue
    void AddImport(IImportSite* pICB);
    bool FinishImport(IImportSite* pICB);

    void StartThread();
    void StopThread();

  protected:
    virtual void ProcessMsg(DWORD dwMsg,
                            DWORD dwNumParams,
                            DWORD dwParams[]);

    CritSect _cs;

#if DEVELOPER_DEBUG
    virtual char * GetName() { return "ImportThread"; }
#endif
};

void StartImportThread();
void StopImportThread();

//use this structure to override default behavior of IBSC
struct BSCInfo {
    DWORD grfBINDF;  //bindinfo flags
};

//-------------------------------------------
// asynchronouse URL callback interface
//-------------------------------------------
class CImportBindStatusCallback : public IBindStatusCallback,
                                  public IAuthenticate,
                                  public AxAThrowingAllocatorClass
{
  public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid,void ** ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IBindStatusCallback methods
    STDMETHOD(OnStartBinding)(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHOD(GetPriority)(LONG* pnPriority);
    STDMETHOD(OnLowResource)(DWORD dwReserved);
    STDMETHOD(OnProgress)(
        ULONG ulProgress,
        ULONG ulProgressMax,
        ULONG ulStatusCode,
        LPCWSTR pwzStatusText);
    STDMETHOD(OnStopBinding)(HRESULT hrResult, LPCWSTR szError);
    STDMETHOD(GetBindInfo)(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHOD(OnDataAvailable)(
        DWORD grfBSCF,
        DWORD dwSize,
        FORMATETC *pfmtetc,
        STGMEDIUM* pstgmed);
    STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown* punk);

    // IAuthenticate methods
    STDMETHOD(Authenticate)(HWND * phwnd,LPWSTR * pwszUser,LPWSTR * pwszPassword);

    // Constructors/destructors
    CImportBindStatusCallback(IImportSite* pIIS);
    virtual ~CImportBindStatusCallback();

  private:
    char m_szCacheFileName[INTERNET_MAX_URL_LENGTH];
    IImportSite* m_pIIS;
    CComPtr<IBinding> m_pbinding;
    DWORD     m_cRef;
    UINT m_ulProgressMax;
    friend class ASyncImport;
    friend class IImportSite;
};


//------------------------------------------------------------
// Import Site
// Site specific outgoing interface used by
// the asynchronous URL moniker.  All media
// import sites should inherit from this interface
// NOTE: all bvrs used in import sites MUST be ImportSwitcherBvr
// or ImportEvent
//------------------------------------------------------------
//REVIEW--garbage collection

class ATL_NO_VTABLE IImportSite : public AxAThrowingAllocatorClass
{
#define _SimImports 2
  public:
    IImportSite(LPSTR pszPath,
                CRImportSitePtr site,
                IBindHost * bh,
                bool bAsync,
                Bvr ev = NULL,
                Bvr progress = NULL,
                Bvr size = NULL);
    virtual ~IImportSite();

    ULONG AddRef() { return InterlockedIncrement(&m_cRef); }
    ULONG Release() {
        ULONG ul = InterlockedDecrement(&m_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }

    Bvr  GetEvent() { return m_ev ; }
    void SetEvent(Bvr event) ;

    Bvr  GetProgress() { return m_progress; }
    void SetProgress(Bvr progress) ;

    Bvr  GetSize() { return m_size; }
    void SetSize(Bvr size) ;

    // This is callable from any thread and is the main call to add
    // the import site to the queue of imports to begin downloading
    void StartDownloading();

    //OnProgress--called during download, if file size is available.
    //%complete = ulProgress/ulProgressMax * 100
    virtual void OnProgress(ULONG ulProgress,
                            ULONG ulProgressMax) ;

    //OnStartLoading-called by async moniker on OnStartBinding
    virtual void OnStartLoading();

    //OnStartLoading-called by async moniker for any type of error.
    //Returns hresult and error string of error.
    virtual void OnError(bool bMarkFailed = true);

    // This must be provided by any derived classes
    // This is called from OnSerializeFinish with the critical section
    // already obtained and the heaps set
    virtual void OnComplete();

    IStream *GetStream() {
        return m_IStream;
    }

    LPCSTR  GetPath()      { return m_pszPath;   }
    char   *GetCachePath() { return  _cachePath; }
    void    SetCachePath(char *path);

    void vBvrIsDying(Bvr deadBvr);
    virtual bool fBvrIsDying(Bvr deadBvr);
    bool fBvrIsValid(Bvr myBvr){return ((myBvr != NULL) && (myBvr->Valid()));}
    bool AllBvrsDead(){return m_fAllBvrsDead;}
    void SetAllBvrsDead(){m_fAllBvrsDead = true;}
    bool IsCanceled(){return m_bCanceled;}
    CritSect m_CS;

    DWORD GetImportId() { return m_id; }
  protected:
    DWORD m_id;
    LPSTR m_pszPath;
    double m_lastProgress;
    bool m_bSetSize;
    bool m_fReportedError;
    bool m_bAsync;
    DAComPtr<IStream> m_IStream;
    DAComPtr<CRImportSite> m_site;
    DAAPTCOMPTR(IBindHost) m_bindhost;

    //OnSerializeFinish-called via a thread message in OnStopLoading.
    //Used to serialize calls to import primitives.
    void OnSerializeFinish();
    // SEH
    void OnSerializeFinish_helper();
    void OnSerializeFinish_helper2();
    void Import_helper(LPWSTR &pwszUrl);

    // If bDone is false then num cannot be >= 1
    void UpdateProgress(double num, bool bDone = false);

    friend class ASyncImport;
    friend class CImportBindStatusCallback;

    long m_cRef;

    char *_cachePath; // CImportBindStatusCallback::OnProgress sets this

    // This is called to complete the processing of the data after the
    // IStream is valid
    void CompleteDownloading();

    virtual HRESULT Import();

    static const int LOAD_OK;
    static const int LOAD_FAILED;

  private:
    bool m_fAllBvrsDead;
    Bvr m_ev;
    Bvr m_progress;
    Bvr m_size;
    bool m_bCanceled;

    // TODO: Don you may want to change this back to how it was but I
    // wanted to separate them from the StartDownloading call I added
    friend ImportThread;

    // Protect these from being called from the wrong thread
    HRESULT QueueImport();
    HRESULT CompleteImport();
    bool DeQueueImport();
    static HRESULT StartAnImport();

    // some stuff to sync sim import limits
    float m_ImportPrio;
    bool  m_bQueued;
    bool  m_bImporting;
    bool  IsQueued(){return m_bQueued;}
    void  StartingImport();
    void  EndingImport();
    bool  IsImporting(){return m_bImporting;}

    static int SimImports();
#ifdef _DEBUG
    DWORD dwconsttime;
    DWORD dwqueuetime;
    DWORD dwstarttime;
    DWORD dwfirstProgtime;
    DWORD dwCompletetime;
#endif
    // protect the stack;
  public:
    // cancel needs to do more later...
    void CancelImport();
    virtual void ReportCancel(void){return;}
    void   SetImportPrio(float ip) { m_ImportPrio = ip; }
    float  GetImportPrio() { return m_ImportPrio; }
    static CritSect * s_pCS;
    static char s_Fmt[100];
    static list<IImportSite *> * s_pSitelist;
    static ImportThread * s_thread;
};


#define STREAM_THREASHOLD 200000  // size in bytes where we automaticaly stream

class StreamableImportSite : public IImportSite
{
  public:
    StreamableImportSite(LPSTR      pszPath,
                         CRImportSitePtr site,
                         IBindHost * bh,
                         bool       bAsync,
                         Bvr        ev        = NULL,
                         Bvr        progress  = NULL,
                         Bvr size = NULL)
    : IImportSite(pszPath, site, bh, bAsync, ev, progress, size), _stream(false)
    {}

    HRESULT Import();
    virtual void ReportCancel(void){IImportSite::ReportCancel();}
    void    SetStreaming(bool mode) { _stream = mode;  }
    bool    GetStreaming()          { return(_stream); }

  protected:
    bool    _stream;
};


struct ImportSiteGrabber
{
    ImportSiteGrabber(IImportSite & p, bool bAddRef = true)
    : _pSite(p)
    {
        if (bAddRef) _pSite.AddRef();
    }
    ~ImportSiteGrabber(){
        _pSite.Release();
    }

  protected:
    IImportSite & _pSite;
};


//-------------------------------------------
// Image Import Site
//-------------------------------------------
class ImportImageSite : public IImportSite
{
  public:
    ImportImageSite(LPSTR pszPath,
                    CRImportSitePtr site,
                    IBindHost * bh,
                    bool bAsync,
                    Bvr bvr,
                    bool useColorKey,
                    BYTE ckRed,
                    BYTE ckGreen,
                    BYTE ckBlue,
                    Bvr ev = NULL,
                    Bvr progress = NULL)
    : IImportSite(pszPath,site,bh,bAsync,ev,progress),
      m_bvr(bvr),
      m_useColorKey(useColorKey),
      m_ckRed(ckRed),
      m_ckGreen(ckGreen),
      m_ckBlue(ckBlue)
    {
        // register the import site with the bvrs.  all derived classes must do
        // this for their contained bvrs so the callbacks will work...
        SetImportOnBvr(this,m_bvr);
    }

    ~ImportImageSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual void OnError(bool bMarkFailed = true);
    virtual bool fBvrIsDying(Bvr deadBvr);

  protected:
    Bvr  m_bvr;
    bool m_useColorKey;
    BYTE m_ckRed;
    BYTE m_ckGreen;
    BYTE m_ckBlue;
};


//-------------------------------------------
// Movie Import Site
//-------------------------------------------
class ImportMovieSite : public StreamableImportSite
{
  public:
    ImportMovieSite(LPSTR pszPath,
                    CRImportSitePtr site,
                    IBindHost * bh,
                    bool bAsync,
                    Bvr imageBvr,
                    Bvr sndBvr,
                    Bvr lengthBvr,
                    Bvr ev = NULL,
                    Bvr progress = NULL)
    : StreamableImportSite(pszPath,site,bh,bAsync,ev,progress),
      _imageBvr(imageBvr),
      _soundBvr(sndBvr),
      _lengthBvr(lengthBvr)
    {
        // register the import site with the bvrs.  all derived classes must do
        // this for their contained bvrs so the callbacks will work...
        SetImportOnBvr(this,_imageBvr);
        SetImportOnBvr(this,_soundBvr);
        SetImportOnBvr(this,_lengthBvr);
    }

    ~ImportMovieSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual void OnError(bool bMarkFailed = true);
    virtual bool fBvrIsDying(Bvr deadBvr);

  protected:
    Bvr       _imageBvr;
    Bvr       _soundBvr;
    Bvr       _lengthBvr;
};


//-------------------------------------------
// AMstream Import Site
//-------------------------------------------
class ATL_NO_VTABLE ImportSndsite : public StreamableImportSite
{
  public:
    ImportSndsite(LPSTR pszPath,
                  CRImportSitePtr site,
                  IBindHost * bh,
                  bool  bAsync,
                  Bvr   bvr,
                  Bvr   lengthBvr,
                  Bvr   ev         = NULL,
                  Bvr   progress   = NULL)
    : StreamableImportSite(pszPath, site, bh, bAsync, ev, progress),
      m_bvr(bvr), m_lengthBvr(lengthBvr)
    {
        SetImportOnBvr(this,m_bvr);
        SetImportOnBvr(this,m_lengthBvr);
    }

    virtual void OnProgress(ULONG ulProgress, ULONG ulProgressMax)
        { IImportSite::OnProgress(ulProgress,ulProgressMax); }

    ~ImportSndsite() { }
    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual void OnError(bool bMarkFailed = true);
    virtual bool fBvrIsDying(Bvr deadBvr);

  protected:
    Bvr   m_bvr;
    Bvr   m_lengthBvr;
};


class ImportPCMsite : public ImportSndsite
{
  public:
    ImportPCMsite(LPSTR pszPath,
                  CRImportSitePtr site,
                  IBindHost * bh,
                  bool  bAsync,
                  Bvr   bvr,
                  Bvr   bvrNum,
                  Bvr   lengthBvr,
                  Bvr   ev         = NULL,
                  Bvr   progress   = NULL)
    : ImportSndsite(pszPath,site,bh,bAsync,bvr,lengthBvr,ev,progress),
      m_bvrNum(bvrNum)
    { SetImportOnBvr(this,m_bvrNum); }

    ~ImportPCMsite() { }

    virtual void OnProgress(ULONG ulProgress, ULONG ulProgressMax)
    {
        _soundBytes = ulProgressMax;

        // compute average bandwidth (need to know current time!)

        // if time remaining to download < (the time it takes to play what we
        // already have downloaded) AND the file is over a certain length
        // then early play it (stream type2)...
    }


    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual bool fBvrIsDying(Bvr deadBvr);

  protected:

    // SEH
    void OnComplete_helper(Sound * &sound,
                           Bvr &soundBvr,
                           double &length,
                           bool &nonFatal);

    Bvr   m_bvrNum;
    ULONG  _soundBytes;
};


//-------------------------------------------
// Mid Import Site
//-------------------------------------------
class ImportMIDIsite : public ImportSndsite
{
  public:
    ImportMIDIsite(LPSTR pszPath,
                   CRImportSitePtr site,
                   IBindHost * bh,
                   bool bAsync,
                   Bvr  bvr,
                   Bvr  lengthBvr,
                   Bvr  ev       = NULL,
                   Bvr  progress = NULL)
    : ImportSndsite(pszPath,site,bh,bAsync,bvr,lengthBvr,ev,progress) { }

    ~ImportMIDIsite(){ }
    virtual void ReportCancel(void);
    virtual void OnComplete();

};


//-------------------------------------------
// geom Import Site
//-------------------------------------------
class ATL_NO_VTABLE ImportGeomSite : public IImportSite
{
  public:
    ImportGeomSite(LPSTR pszPath,
                   CRImportSitePtr site,
                   IBindHost * bh,
                   bool bAsync,
                   Bvr bvr,
                   Bvr ev = NULL,
                   Bvr progress = NULL)
    : IImportSite(pszPath,site,bh,bAsync,ev,progress),
      m_bvr(bvr)
    {
        SetImportOnBvr(this,m_bvr);
    }

    ~ImportGeomSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual void OnError(bool bMarkFailed = true);
    virtual bool fBvrIsDying(Bvr deadBvr);
  protected:
    Bvr m_bvr;
};


#if INCLUDE_VRML
//-------------------------------------------
// wrl Import Site
//-------------------------------------------
class ImportWrlSite : public ImportGeomSite
{
  public:
    ImportWrlSite(LPSTR pszPath,
                  CRImportSitePtr site,
                  IBindHost * bh,
                  bool bAsync,
                  Bvr bvr,
                  Bvr ev = NULL,
                  Bvr progress = NULL)
    : ImportGeomSite(pszPath,site,bh,bAsync,bvr,ev,progress)
    {
    }

    ~ImportWrlSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();
};
#endif

//-------------------------------------------
// x Import Site
//-------------------------------------------
class ImportXSite : public ImportGeomSite
{
  public:
    ImportXSite(LPSTR pszPath,
                CRImportSitePtr site,
                IBindHost * bh,
                bool bAsync,
                Bvr bvr,
                Bvr ev = NULL,
                Bvr progress = NULL,
                bool wrap = false,
                TextureWrapInfo *pWrapInfo = NULL,
                bool v1Compatible = true)
    : ImportGeomSite(pszPath,site,bh,bAsync,bvr,ev,progress),
      _v1Compatible (v1Compatible)
    {
        if (pWrapInfo) {

            // If we have wrap information, then we look at the wrap flag to
            // determine if it's valid to apply, and if so we copy the data.
            // All wrapped (valid or not) geometry is imported properly (this
            // is incompatible with version 1 of DA).

            _wrap = wrap;

            if (wrap) {
                _wrapInfo = *pWrapInfo;
            }

        } else {

            // If we have no wrap information, then this is the legacy
            // unwrapped geometry import code, and we need to maintain
            // backwards compatible with a bug in version 1 of DA.

            _wrap = false;
        }
    }

    ~ImportXSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();

  private:
      bool _wrap;
      bool _v1Compatible;
      TextureWrapInfo _wrapInfo;
};


#endif  // _IMPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\impsound.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/ 
   importing image media. 

*******************************************************************************/
#include "headers.h"
#include "import.h"
#include "context.h"
#include "include/appelles/axaprims.h"
#include "include/appelles/readobj.h"
#include "privinc/stquartz.h"
#include "privinc/soundi.h"
#include "privinc/bufferl.h"
#include "privinc/movieimg.h"
#include "impprim.h"
#include "backend/bvr.h"  // EndBvr()
#include "backend/sndbvr.h"

//-------------------------------------------------------------------------
//  PCM import site
//--------------------------------------------------------------------------
void ImportPCMsite::OnComplete_helper(
    Sound * &sound, // ref to ptr
    Bvr &soundBvr,
    double &length,
    bool &nonFatal)
{
    // pick pathname 'raw' url for streaming or urlmon download path
    char *pathname = GetStreaming() ? m_pszPath : GetCachePath();
    Assert(pathname);

    QuartzAudioStream *quartzStream = NEW QuartzAudioStream(pathname);

    // XXX RobinSp says we can't count on GetDuration being accurate!
    double  seconds = quartzStream->GetDuration();  // get the duration
    long soundBytes = quartzStream->pcm.SecondsToBytes(seconds); // determine size
    if(!soundBytes) {
        nonFatal = true;
        RaiseException_InternalError("empty audio file"); // this is silence...
    }

    quartzStream->pcm.SetNumberBytes(soundBytes);

    bool useStaticWaveOnly = false;

    LeafSound *snd;
    StreamQuartzPCM *pcmSnd = NULL;

    if (soundBytes > STREAM_THREASHOLD) {
        // stream the sound
        
        TraceTag((tagSoundLoads, "Streaming %s (%d)", pathname, soundBytes));
        sound = snd = pcmSnd = NEW StreamQuartzPCM(pathname);
        pcmSnd->_pcm.SetNumberBytes(soundBytes);
        length = seconds;
    }
    else {  // its small.  Statically load it into a dsound buffer!
        // add a fudge factor to combat inaccuracy in GetDuration!
        double fudgedSeconds = seconds * 1.5;
        long bytesToRequest  = 
            quartzStream->pcm.SecondsToBytes(fudgedSeconds);
        long framesToRequest = quartzStream->pcm.SecondsToFrames(fudgedSeconds);

        unsigned char *buffer = (unsigned char *)
            StoreAllocate(GetSystemHeap(), bytesToRequest);
        
        if(!buffer) {
#if _MEMORY_TRACKING
            OutputDebugString("\nDirectAnimation: Out Of Memory\n");
            F3DebugBreak();
#endif
            TraceTag((tagSoundErrors, "WavSoundClass buffer malloc failed"));
            RaiseException_OutOfMemory("WavSoundClass buffer malloc failed", 
                                       bytesToRequest);
        }

        // do a blocking read
        long actualFrames = 
            quartzStream->ReadFrames(framesToRequest, buffer, true);
        Assert(actualFrames);

        // XXX we should somehow cancel the import if we fail to read!

        quartzStream->pcm.SetNumberFrames(actualFrames); // set our pcm info
        length = quartzStream->pcm.FramesToSeconds(actualFrames);

        Assert(actualFrames < framesToRequest); // fudge factor large enough?
        TraceTag((tagSoundLoads, "Static ld %s quartz:%d, actual:%d (err:%d)",
                  pathname, soundBytes, quartzStream->pcm.FramesToBytes(actualFrames), 
                  quartzStream->pcm.FramesToBytes(actualFrames)-soundBytes));

        // NOTE: StaticWaveSound is responsible for deleting buffer
        sound = snd = NEW StaticWaveSound(buffer, &(quartzStream->pcm));

        delete quartzStream;
        quartzStream = NULL; // no need to cache the quartzStream for staticSnd
    }

    if(quartzStream) {
        // add qstream to context sound cache list to be recycled later!
        QuartzBufferElement *bufferElement = 
            NEW QuartzBufferElement(pcmSnd, quartzStream, NULL); // NULL path

        // hold IStream handle to keep file from being purged by ie
        bufferElement->SetFile(GetStream()); 

        SoundBufferCache *soundCache = 
            GetCurrentContext().GetSoundBufferCache();
        // allow aging: bufferElement->SetNonAging();  // dissable aging for imports
        soundCache->AddBuffer(sound, bufferElement);
    }

    soundBvr = SoundBvr(snd);
}


void ImportPCMsite::OnComplete()
{
    TraceTag((tagImport, "ImportPCMsite::OnComplete for %s", m_pszPath));
    Bvr soundBvr;
    double length = 0.0;
    bool nonFatal = false;

    __try {

        Sound *sound;
        OnComplete_helper( sound, soundBvr, length, nonFatal );
        
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        if(!nonFatal) {
            RETHROW;
        }
        soundBvr = ConstBvr(silence);
    }

    if(fBvrIsValid(m_bvr))
        SwitchOnce(m_bvr, soundBvr);

    if(fBvrIsValid(m_lengthBvr))
        SwitchOnce(m_lengthBvr, NumToBvr(length));

    ImportSndsite::OnComplete();
}


bool ImportPCMsite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = ImportSndsite::fBvrIsDying(deadBvr);
    if (deadBvr == m_bvrNum) {
        m_bvrNum = NULL;
    }
    if (m_bvrNum)
        return false;
    else
        return fBase;
}

void ImportPCMsite::ReportCancel(void)
{
    ImportSndsite::ReportCancel();
}
    
//-------------------------------------------------------------------------
//  Mid import site
//--------------------------------------------------------------------------
void ImportMIDIsite::OnComplete()
{
    TraceTag((tagImport, "ImportMIDIsite::OnComplete for %s", m_pszPath));

    double length;
    
    // pick pathname 'raw' url for streaming or urlmon download path
    char *pathname = GetStreaming() ? m_pszPath : GetCachePath();
    Assert(pathname);
    LeafSound *sound = ReadMIDIfileForImport(pathname, &length);
    
    if(fBvrIsValid(m_bvr))
        SwitchOnce(m_bvr, SoundBvr(sound));
    if(fBvrIsValid(m_lengthBvr))
        SwitchOnce(m_lengthBvr, NumToBvr(length));

    ImportSndsite::OnComplete();
}


void ImportMIDIsite::ReportCancel(void)
{
    ImportSndsite::ReportCancel();
}
    
//-------------------------------------------------------------------------
//  Common Snd import site
//--------------------------------------------------------------------------
void ImportSndsite::OnError(bool bMarkFailed)
{
    HRESULT hr = S_OK; // all snd import errs are handled (was: DAGetLastError)
    LPCWSTR sz = DAGetLastErrorString();
    
    if (bMarkFailed && fBvrIsValid(m_bvr))
        ImportSignal(m_bvr, hr, sz);

    StreamableImportSite::OnError(bMarkFailed);
}
    
void ImportSndsite::ReportCancel(void)
{
    if (fBvrIsValid(m_bvr)) {
        char szCanceled[MAX_PATH];
        LoadString(hInst,IDS_ERR_ABORT,szCanceled,sizeof(szCanceled));
        ImportSignal(m_bvr, E_ABORT, szCanceled);
    }
    StreamableImportSite::ReportCancel();
}
    
bool ImportSndsite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = IImportSite::fBvrIsDying(deadBvr);
    if (deadBvr == m_bvr) {
        m_bvr = NULL;
    }
    else if (deadBvr == m_lengthBvr) {
        m_lengthBvr = NULL;
    }
    if (m_bvr || m_lengthBvr)
        return false;
    else
        return fBase;
}

void ImportSndsite::OnComplete()
{
    if(fBvrIsValid(m_bvr))
        ImportSignal(m_bvr);
    StreamableImportSite::OnComplete();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\pickq.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the PickQ class

*******************************************************************************/


#include "headers.h"
#include "view.h"
#include "pickq.h"
#include "privinc/probe.h"
#include "appelles/hacks.h"
#include "privinc/vec2i.h"

// ==============================
// PickQ implementation
// ==============================

PickQ::PickQ ()
: _heap1(NULL),
  _heap2(NULL),
  _heapSwitchTime(0.0)
{
    _heap1 = &TransientHeap("pick heap1", 10000);
    _heap2 = &TransientHeap("pick heap2", 10000);
    _heap = _heap1 ;
}

PickQ::~PickQ()
{
    Reset(0.0, TRUE);

    if (_heap1)
        DestroyTransientHeap(*_heap1);    

    if (_heap2)
        DestroyTransientHeap(*_heap2);    
}

// Keep events for DELTA time
static const Time DELTA = 0.5;

void
PickQ::Reset(Time curTime, BOOL noLeftover)
{
    Time cutOff = curTime - DELTA;

    if (noLeftover) {
        for (PickMap::iterator i = _pm.begin(); i != _pm.end(); i++) {
            delete (*i).second; // delete pick event queue
        }
        _pm.erase(_pm.begin(), _pm.end());
        
    } else {

        BEGIN_LEAK
        list<int> eIds;         // Gather empty pick id queues.
        END_LEAK

        Time maxHeapTime = 0.0;
        
        for (PickMap::iterator i = _pm.begin(); i != _pm.end(); i++) {
            PickEventQ* q = (*i).second;
            
            while (!q->empty()) {
                if (q->front()._eventTime > cutOff) {
                    maxHeapTime = MAX(maxHeapTime, q->back()._eventTime);
                    break;
                }

                q->pop_front();
            }

            // If empty, delete and save it for removal from pickmap.
            if (q->empty()) {
                delete q;
                eIds.push_front((*i).first);
            }
        }

        // Erase empty queues from pickmap
        for (list<int>::iterator j = eIds.begin(); j != eIds.end(); j++) {
            _pm.erase(*j);
        }

        if (cutOff > _heapSwitchTime) {
            _heap = (_heap == _heap1) ? _heap2 : _heap1;
            
#if _DEBUG
            /*
            if (_heapSwitchTime && maxHeapTime) {
                printf("cutoff = %15.5f, switch = %15.5f, new = %15.5f\n",
                       cutOff, _heapSwitchTime, maxHeapTime);
            }
            GetCurrentHeap().Dump();
            */
#endif      
            ResetDynamicHeap(GetCurrentHeap());
            _heapSwitchTime = maxHeapTime;
        }
    }
}

void
PickQ::Add (int eventId, PickQData & data)
{
    PickMap::iterator i = _pm.find(eventId);
    PickEventQ *q;

    if (i == _pm.end()) {
        BEGIN_LEAK
        q = new PickEventQ;
        END_LEAK
        
        _pm[eventId] = q;
    } else {
        q = (*i).second;

        // Duplicated entries, ignore.
        if (q->back()._eventTime == data._eventTime)
            return;

        // They should be sorted.
        Assert(q->back()._eventTime < data._eventTime);
    }

    q->insert(q->end(), data);
}

void
PickQ::GatherPicks(Image* image, Time time, Time lastPollTime)
{
    Reset(time, FALSE);

    DWORD x,y ;

    EventQ& eq = GetCurrentEventQ();
    
    if (eq.IsMouseInWindow(time)) {
        eq.GetMousePos(time, x, y); 
        // Turn rawMousePos into wcMousePos
        Point2Value *wcMousePos = PixelPos2wcPos((short)x,(short)y) ;

        // Don't reset
        DynamicHeapPusher dhp(GetCurrentHeap());

        PerformPicking(image, wcMousePos, true, time, lastPollTime);
    }
}

// TODO: This is temporary, we need a better approach for interpolated
// polling events like pick.
static const double EPSILON = 0.001;  // 10ms

inline BOOL FEQ(double f1, double f2)
{ return fabs(f1 - f2) <= EPSILON; }

// Check to see if the specified ID is on the pick queue.
BOOL
PickQ::CheckForPickEvent(int id, Real time, PickQData & result)
{
    PickMap::iterator i = _pm.find(id);

    if (i == _pm.end()) {
        return FALSE;
    } else {
        PickEventQ* q = (*i).second;

        if (q->empty())
            return FALSE;

        // See if time outside queue range, if so, see if it's close
        // enough to the end points to decide hit.
        
        result = q->front();
        
        if (time <= result._eventTime)
            return FEQ(time, result._eventTime);

        result = q->back();

        // See if it's the last time we poll.  If not, that means it's
        // not picked in the current frame.

        if (time >= result._eventTime) {
            if (result._eventTime == GetLastSampleTime()) {
                result._eventTime = time;
                return TRUE;
            }
            return FALSE;
        }

        Assert((time > q->front()._eventTime) &&
               (time < q->back()._eventTime));

        // Find out the range time falls on.
        
        PickEventQ::iterator last = q->begin();
        PickEventQ::iterator j = q->begin();
        
        while ((++j) != q->end()) {
            
            if (time < (*j)._eventTime) {
                Time t1 = (*last)._eventTime;
                Time t2 = (*j)._eventTime;
                
                Assert((t1 <= time) && (time <= t2));

                // The probe is true within that range if the last
                // poll time of the end == event time of the beginning. 
                
                if (t1 == (*j)._lastPollTime) {

                    // See if time point closer to end or begin
                    
                    if ((time - t1) > (t2 - time))
                        result = *last;
                    else
                        result = *j;

                    /*
                    printf("pickq entry: %20.15f, time: %20.15f\n",
                           result._eventTime, time);
                    fflush(stdout);
                    */
                    
                    result._eventTime = time;

                    return TRUE;
                }

                // Time falls into a range that probe is not true.
                // See if it's close enough to either range end.
                
                if (FEQ(time, t1)) {
                    result = (*last);
                    return TRUE;
                }

                if (FEQ(time, t2)) {
                    result = (*j);
                    return TRUE;
                }

                return FALSE;
            }

            ++last;
        }

        // Shouldn't get here...
        Assert(FALSE);

        return FALSE;
    }
}

// C Functions

BOOL CheckForPickEvent(int id, Real time, PickQData & result)
{ return GetCurrentPickQ().CheckForPickEvent(id, time, result); }

Point2Value*
PixelPos2wcPos(short x, short y)
{
    /* TODO: We need to clean up this hacky stuff. */
    Real res = ViewerResolution();
    Point2Value *topRight = PRIV_ViewerUpperRight(NULL);

    Real w = topRight->x;
    Real h = topRight->y;

    Real nx = ( Real(x) / res) - w;

    Real ny = h - ( Real(y) / res);

// XyPoint2 copies the real values...hopefully
    return XyPoint2RR(nx, ny);
}

void AddToPickQ (int id, PickQData & data)
{ GetCurrentPickQ().Add (id, data) ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\impprim.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    import primitive header

Revision:

--*/

#ifndef _IMPPRIM_H_
#define _IMPPRIM_H_

Bvr AnimImgBvr(Image **i, int count, int *delays, int loop);
Sound      *ReadMidiFileWithLength(char *pathname,Real *length); // out argument
LeafSound  *ReadMIDIfileForImport(char *pathname, double *length);
LeafSound  *ReadQuartzAudioForImport(char *pathname, double *length);
Bvr         ReadQuartzVideoForImport(char *pathname, double *length);
LeafSound  *ReadQuartzStreamForImport(char *pathname); // XXX old remove
void        ReadAVmovieForImport(char *simplePathname,
                                 LeafSound **sound,
                                 Bvr *imageBvr,
                                 double *length);

#endif  // _IMPPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\impprim.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all import primitives (level below COM)

*******************************************************************************/

#include "headers.h"
#include "context.h"
#include "guids.h"
#include "dispids.h"
#include "include/appelles/readobj.h"
#include "include/appelles/axaprims.h"
#include "backend/events.h"
#include "backend/jaxaimpl.h"
#include "privinc/urlbuf.h"
#include "privinc/resource.h"
#include "privinc/movieimg.h"
#include "privinc/soundi.h"
#include "privinc/midi.h"
#include "privinc/qmidi.h"
#include "privinc/server.h"
#include "privinc/opt.h"
#include "privinc/debug.h"
#include "privinc/stream.h"
#include "privinc/stquartz.h"
#include "privinc/util.h"
#include "privinc/soundi.h"
#include "appelles/sound.h"
#include "appelles/readobj.h"
#include "axadefs.h"
#include "include/appelles/hacks.h"
#include "privinc/miscpref.h"
#include "privinc/bufferl.h"
#include "impprim.h"
#include "privinc/viewport.h" // GetDirectDraw
#include "backend/moviebvr.h"

class AnimatedImageBvrImpl : public BvrImpl {
  public:
    AnimatedImageBvrImpl(Image **i, int count, int *delays, int loop) :
    _images(i), _count(count), _delays(delays), _loop(loop) {
        Assert( (count > 1) && "Bad image count (<=1)");
            
        _delaySum = 0.0;
        Assert(_delays);
        for(int x=0; x<_count; x++)
            _delaySum += double(_delays[x]) / 1000.0;
    }

    ~AnimatedImageBvrImpl() {
        StoreDeallocate(GetGCHeap(), _images);
        StoreDeallocate(GetGCHeap(), _delays);
    }
        
    virtual DWORD GetInfo(bool) { return BVR_TIMEVARYING_ONLY; }

    virtual Perf _Perform(PerfParam& p);

    virtual void _DoKids(GCFuncObj proc) { 
                for (int i=0; i<_count; i++)
                        (*proc)(_images[i]);
        }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "AnimatedGif"; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return ImageType ; }

    Image **_images;
    int _count;
    int _loop;
    int *_delays;
    double      _delaySum;
};

class AnimatedImagePerfImpl : public PerfImpl {
  public:
    AnimatedImagePerfImpl(AnimatedImageBvrImpl *base, TimeXform tt)
    : _base(base), _tt(tt) {}

    AxAValue _Sample(Param& p) {
        double localTime = EvalLocalTime(p, _tt);           // Get local time
        unsigned long curLoop =
            (unsigned long) floor( localTime / double(_base->_delaySum) );
        double curDelay = localTime - double(curLoop) * _base->_delaySum;
        double accumDelay = 0.0;
        long index = 0;

        // Detect a boundary condition and return the max index.
        Assert(_base->_loop >= -1);
        Assert(_base->_count > 0);
        if( (_base->_count == 1) ||
            (_base->_loop == -1) ||
            ((_base->_loop != 0) && (curLoop > _base->_loop)) ) {
            return _base->_images[_base->_count-1];
        }        

        // walk through delays to determine our index value
        double delay = double(_base->_delays[index]) / 1000.0; // delay value in milliSeconds  
        while ((curDelay > accumDelay+delay) && (index < _base->_count)) {            
            accumDelay += delay;
            delay = double(_base->_delays[++index]) / 1000.0;  
        }
                              
        return _base->_images[index];  
    }

    virtual void _DoKids(GCFuncObj proc) { 
        (*proc)(_tt); 
        (*proc)(_base);
        }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "AnimatedGif perf"; }
#endif

  private:
    TimeXform     _tt;
    AnimatedImageBvrImpl *_base;
};

Perf
AnimatedImageBvrImpl::_Perform(PerfParam& p)
{
    return NEW AnimatedImagePerfImpl(this, p._tt);
}

Bvr AnimImgBvr(Image **i, int count, int *delays, int loop)
{return NEW AnimatedImageBvrImpl(i,count,delays,loop);}


Sound *
ReadMidiFileWithLength(char *pathname, double *length) // returns length
{
    Assert(pathname);
    if(!pathname)
        RaiseException_InternalError("cache path name not set");
    return(ReadMIDIfileForImport(pathname, length));
}


extern miscPrefType miscPrefs; // registry prefs struct setup in miscpref.cpp
LeafSound *ReadMIDIfileForImport(char *pathname, double *length)
{
    TraceTag((tagImport, "Read MIDI file %s", pathname));

    Assert(pathname);
    if(!pathname)
        RaiseException_InternalError("cache path name not set");

#ifdef REGISTRY_MIDI
    // select aaMIDI/qMIDI based on a registry entry...
    MIDIsound *snd;
    if(miscPrefs._qMIDI) 
        snd = NEW  qMIDIsound;
    else
        snd = NEW aaMIDIsound;
#else
    qMIDIsound *snd = NEW qMIDIsound;
#endif
    snd->Open(pathname);

    *length = snd->GetLength();

    return snd;
}

static StreamQuartzPCM *_NewStreamQuartzPCM(char *pathname)
{
    return NEW StreamQuartzPCM(pathname);
}

static StreamQuartzPCM *_Nonthrowing_NewSteamQuartzPCM(char *pathname)
{
    StreamQuartzPCM *sound = NULL;
    __try {  // need to test this to allow only audio or video to
             // succeed
        sound = _NewStreamQuartzPCM(pathname);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {}

    return sound;
}


static MovieImage *_NewMovieImage(QuartzAVstream *quartzAVstream)
{
    return NEW MovieImage(quartzAVstream, ViewerResolution());
}

static MovieImage *_Nonthrowing_NewMovieImage(QuartzAVstream *quartzAVstream)
{
    MovieImage *image = NULL;
    
    __try { // need to test this to allow only audio or video to succeed

        image = _NewMovieImage(quartzAVstream);

    } __except ( HANDLE_ANY_DA_EXCEPTION ) {}

    return image;
}

// returns null sound, or image if failure...
// added complexity to allow audio or video to fail
void ReadAVmovieForImport(char *simplePathname, 
                          LeafSound **sound,
                          Bvr *pImageBvr,
                          double *length)
{
    MovieImage *image = NULL;  // make sure these default to null if we throw
    *pImageBvr = NULL;
    *sound = NULL;
    StreamQuartzPCM *snd;
    
    Assert(simplePathname);
    if(!simplePathname)
        RaiseException_InternalError("cache path name not set");

    char *pathname = simplePathname;

    *length = HUGE_VAL; // default to something big!

    // for the purposes of speeding up first use, instantiate and cache a fg
    
    // try to create an AVstream (we might find it fails audio or video)
    QuartzAVstream *quartzAVstream = NEW QuartzAVstream(pathname);
    if(quartzAVstream) {
        // if we don't have audio and video destroy and get us what we wanted!
        if(!quartzAVstream->GetAudioValid() && !quartzAVstream->GetVideoValid()) {
            // XXX bad scene, no audio or video!
            delete quartzAVstream;  // forget the stream, leave sound + image null
        }
        else if(!quartzAVstream->GetAudioValid()) { // no audio, do ReadVideo()
            delete quartzAVstream;  // forget the stream
            *pImageBvr = ReadQuartzVideoForImport(simplePathname, length);
        }
        else if(!quartzAVstream->GetVideoValid()) { // no video, do ReadAudio()
            delete quartzAVstream;  // forget the stream
            *sound = ReadQuartzAudioForImport(simplePathname, length);
        } 
        else {  // avstream with audio and video! (lets actually do the work)
            *sound = snd = _Nonthrowing_NewSteamQuartzPCM(pathname);

            // RobinSp says we can't count on GetDuration being accurate!
            *length = 
                quartzAVstream->QuartzVideoReader::GetDuration();  // get the duration

            image = _Nonthrowing_NewMovieImage(quartzAVstream);

            // add qstream to context sound cache list to be recycled later!
            SoundBufferCache *sndCache = GetCurrentContext().GetSoundBufferCache();
            if(sound) {
                QuartzBufferElement *bufferElement =
                    NEW QuartzBufferElement(snd, quartzAVstream, NULL); // NULL path
                bufferElement->SetNonAging();  // dissable aging for imports
                sndCache->AddBuffer(*sound, bufferElement);
            }

            if(image) {
                QuartzVideoBufferElement *bufferElement =
                    NEW QuartzVideoBufferElement(quartzAVstream);
                *pImageBvr = MovieImageBvr(image, bufferElement);
            }
        }
    }
}


LeafSound *
ReadQuartzAudioForImport(char *simplePathname, double *length)
{
    Assert(simplePathname);
    if(!simplePathname)
        RaiseException_InternalError("cache path name not set");

    char *pathname = simplePathname;

    StreamQuartzPCM *snd = NEW StreamQuartzPCM(pathname);
    *length = HUGE_VAL; // default to something big!

    // GetHeapOnTopOfStack().RegisterDynamicDeleter(NEW
        // DynamicPtrDeleter<Sound>(snd));

    // for the purposes of speeding up first use, instantiate and cache a fg
    QuartzAudioStream *quartzStream = NEW QuartzAudioStream(pathname);
    if(quartzStream) {
        // XXX RobinSp says we can't count on GetDuration being accurate!
        *length = quartzStream->GetDuration();  // get the duration

        // add qstream to context sound cache list to be recycled later!
        QuartzBufferElement *bufferElement =
            NEW QuartzBufferElement(snd, quartzStream, NULL);

        SoundBufferCache *sndCache = GetCurrentContext().GetSoundBufferCache();
        // allow aging: bufferElement->SetNonAging();  // dissable aging for imports
        sndCache->AddBuffer(snd, bufferElement);
    }

    return snd;
}


Bvr
ReadQuartzVideoForImport(char *simplePathname, double *length)
{
    Assert(simplePathname);
    if(!simplePathname)
        RaiseException_InternalError("cache path name not set");

    char *pathname = simplePathname;
    MovieImage *movieImage = NULL;

    *length = HUGE_VAL; // default to something big!
    QuartzVideoStream *quartzStream = NEW QuartzVideoStream(pathname);
    if(quartzStream) {
        movieImage = NEW MovieImage(quartzStream, ViewerResolution());

        // XXX RobinSp says we can't count on GetDuration being accurate!
        *length = quartzStream->GetDuration();  // get the duration

        // add qstream to context sound cache list to be recycled later!
        QuartzVideoBufferElement *bufferElement =
            NEW QuartzVideoBufferElement(quartzStream);

        return MovieImageBvr(movieImage, bufferElement);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\import.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/ 
   importing media. 

*******************************************************************************/

#include "headers.h"
#include "import.h"
#include "backend/jaxaimpl.h"

#define MSG_DOWNLOAD 0x01
#define MSG_FINISHLOADING 0x02

// Cannot assume static initialization from C runtime - use module
// initialization mechanism

list<IImportSite *> * IImportSite::s_pSitelist = NULL;
CritSect * IImportSite::s_pCS = NULL;
char IImportSite::s_Fmt[100];
ImportThread * IImportSite::s_thread = NULL;
long dwImportId = 0;

const int IImportSite::LOAD_OK = 0;
const int IImportSite::LOAD_FAILED = -1;

//-------------------------------------------------------------------------
//  Base import site
//--------------------------------------------------------------------------
IImportSite::IImportSite(char * pszPath,
                         CRImportSitePtr site,
                         IBindHost * bh,
                         bool bAsync,
                         Bvr ev,
                         Bvr progress,
                         Bvr size)
: m_ev(ev),
  m_progress(progress),
  m_size(size),
  m_lastProgress(0),
  m_fReportedError(false),
  m_bSetSize(false),
  m_cRef(1), // always start refcount at 1
  m_bindhost(bh),
  m_site(site),
  m_pszPath(NULL),
  m_bAsync(bAsync),
  m_bQueued(false),
  m_bImporting(false),
  m_ImportPrio(0),
  m_fAllBvrsDead(false),
  m_bCanceled(false),
#if _DEBUG
  dwconsttime(timeGetTime()),
  dwqueuetime(0),
  dwstarttime(0),
  dwfirstProgtime(0),
  dwCompletetime(0),
#endif
   _cachePath(NULL)
{
    m_pszPath = CopyString(pszPath);

    // register the import site with the bvrs.  all derived classes must do
    // this for their contained bvrs so the callbacks will work...
    SetImportOnEvent(this,m_ev);
    SetImportOnBvr(this,m_progress);
    SetImportOnBvr(this,m_size);

    // put this pointer on the list so we can track it
    // if we don't have a crit section pointer, we are in shutdown...
    if (s_pCS) {
        CritSectGrabber csg(*s_pCS);
        m_id = ++dwImportId;
        AddRef();
        s_pSitelist->push_back(this);
    } else {
        m_id = ++dwImportId;
    }

    if (m_site)
    {
        m_site->OnImportCreate(m_id, m_bAsync);
    }
}


IImportSite::~IImportSite()
{
    if (m_site)
    {
        m_site->OnImportStop(m_id);
    }
    
    delete m_pszPath;
    delete  _cachePath;

    TraceTag((tagImport, "~IImportSite --- Done,"));
}


void
IImportSite::SetCachePath(char *path)
{
    if(!_cachePath) { // only bother setting path once
        int length = lstrlen(path) + 1; // length including terminator
        _cachePath = NEW char[length];
        memmove(_cachePath, path, length); // no crt
    }
}


void
IImportSite::SetEvent(Bvr event)
{
    Assert(m_ev == NULL);
    m_ev = event;
    SetImportOnEvent(this,m_ev);
}


void
IImportSite::SetProgress(Bvr progress)
{
    Assert(m_progress == NULL);
    m_progress = progress;
    SetImportOnBvr(this,m_progress);
    
}


void
IImportSite::SetSize(Bvr size)
{
    Assert(m_size == NULL);
    m_size = size;
    SetImportOnBvr(this,m_size);
}


void
IImportSite::OnStartLoading()
{
}


void
IImportSite::OnProgress(ULONG ulProgress,
                        ULONG ulProgressMax)
{
    CritSectGrabber csg(m_CS);
    {
#ifdef _DEBUG
        if (dwfirstProgtime == 0)
            dwfirstProgtime = timeGetTime();
#endif
        DynamicHeapPusher dhp(GetGCHeap()) ;
        
        if (ulProgressMax != 0) {
            GC_CREATE_BEGIN;                                                        
            // Set the size if it has not been set yet
            if (!m_bSetSize && fBvrIsValid(m_size)) {
                SwitchTo(m_size,
                         NumToBvr((double) ulProgressMax),
                         true,
                         SW_FINAL);
                m_bSetSize = true ;
            }

            UpdateProgress(((double) ulProgress) /
                           ((double) ulProgressMax)) ;

            GC_CREATE_END;
        }
    }
#if _DEBUG
    if (ulProgressMax==0)
       TraceTag((tagImport, "percent complete = unknown"));
    else
       TraceTag((tagImport, "percent complete = %i",(ulProgress/ulProgressMax)*100));
#endif
}


void
IImportSite::OnSerializeFinish_helper2()
{
    // IMPORTANT!
    // This should look almost identical to srvprim.h:PRECODE
        
    CritSectGrabber csg(m_CS);
    GC_CREATE_BEGIN;                                                        
    OnComplete() ;
    if (fBvrIsValid(m_ev))
        SetImportEvent(m_ev, LOAD_OK) ;
    UpdateProgress(1,true) ;
    GC_CREATE_END;
}

void
IImportSite::OnSerializeFinish_helper()
{
    __try {
        OnSerializeFinish_helper2();
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        OnError();
    }    
}

void
IImportSite::OnSerializeFinish()
{
    TraceTag((tagImport, "ImportSite::OnSerializeFinish for %s", m_pszPath));

    // Only do this if there were no errors
    if (!m_fReportedError) {
        {
            // just for debug, we should always get one allocated.
            if (m_site) {
                char szStatus[INTERNET_MAX_URL_LENGTH + sizeof(s_Fmt)];
                wsprintf(szStatus, s_Fmt, m_pszPath);
        
                USES_CONVERSION;
                m_site->SetStatusText(m_id,A2W(szStatus));
            }
        }

        DynamicHeapPusher dhp(GetGCHeap()) ;

        OnSerializeFinish_helper();

        // Indicate the import is done ASAP
        if (m_site) {
            m_site->OnImportStop(m_id);
            m_site.Release();
        }
    }
}


// just a place holder so all the code looks the same
// every site that knows about a bvr that must be signaled should do it here
// and then call its base class OnComplete
void IImportSite::OnComplete()
{
}

void
IImportSite::OnError(bool bMarkFailed)
{
    HRESULT hr = DAGetLastError();
    LPCWSTR sz = DAGetLastErrorString();
    
    //external user message from szPath; only report once.
    if (!m_fReportedError && m_site) {
        m_site->ReportError(m_id,hr,sz);
        m_fReportedError=true;
    }

    // Set this to true even if there isn't a site, since
    // OnSerializeFinish will look at it.
    m_fReportedError = true;

    GC_CREATE_BEGIN;                                                        
    if (fBvrIsValid(m_ev))
        SetImportEvent(m_ev, LOAD_FAILED) ;
    GC_CREATE_END;
    
    // Indicate the import is done ASAP
    if (m_site) {
        m_site->OnImportStop(m_id);
        m_site.Release();
    }
}

#define PROGRESS_INC 0.0001
#define MAX_PROGRESS 0.999999

// !! Assumes the create lock and heap are already pushed

void
IImportSite::UpdateProgress(double num, bool bDone)
{
    CritSectGrabber csg(m_CS);
    if (fBvrIsValid(m_progress)) {
#if 0
        if (num < 0) {
            num = 0 ;
        } else if (bDone) {
            num = 1 ;
        } else {
            if (num > MAX_PROGRESS) num = MAX_PROGRESS ;
            if (num < (m_lastProgress + PROGRESS_INC))
                return ;
        }
#endif

        m_lastProgress = num ;

        SwitchTo(m_progress,NumToBvr(num),true,bDone?SW_FINAL:SW_DEFAULT);
    }
}

void IImportSite::Import_helper(LPWSTR &pwszUrl)
{
    HRESULT hr;
    int i;
    
    DAComPtr<IBindStatusCallback> pbsc(NEW CImportBindStatusCallback(this),false);
    if (!pbsc)
        RaiseException_UserError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    
    i =  MultiByteToWideChar(CP_ACP, 0, GetPath(), -1, NULL, 0);
    Assert(i > 0);
    pwszUrl = THROWING_ARRAY_ALLOCATOR(WCHAR, i * sizeof(WCHAR));
    MultiByteToWideChar(CP_ACP, 0, GetPath(), -1, pwszUrl, i);
    pwszUrl[i - 1] = 0;
    
    CComPtr<IMoniker> _pmk;
    CComPtr<IStream> _pStream;
    if ( m_bindhost ) {  //coordinate moniker create & bind through container's IBindHost

        hr=THR(m_bindhost->CreateMoniker(pwszUrl,NULL,&_pmk,0));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }

        hr=THR(m_bindhost->MonikerBindToStorage(_pmk,NULL,pbsc,IID_IStream,(void**)&_pStream));    
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }
    }
    else {  //no bind host
        CComPtr<IBindCtx> _pbc;

        hr=THR(CreateAsyncBindCtx(0,pbsc,NULL,&_pbc));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }

        hr=THR(CreateURLMoniker(NULL,pwszUrl, &_pmk));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }

        hr=THR(_pbc->RegisterObjectParam(SZ_ASYNC_CALLEE,_pmk));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }

        hr=THR(_pmk->BindToStorage(_pbc,NULL,IID_IStream,(void**)&_pStream));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }
    }
}

HRESULT
IImportSite::Import()
{
    LPWSTR pwszUrl=NULL;
    HRESULT ret = S_OK;
    
#ifdef _DEBUG
    dwstarttime = timeGetTime();
#endif
    
    __try {
        
        Import_helper( pwszUrl );
        
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {

        ret = DAGetLastError();
        OnError();
        CompleteImport();
        
    }

    delete pwszUrl;
    return ret;
}

// set the state of the import site because it is starting an import
void
IImportSite::StartingImport()
{
    Assert(!m_bImporting);
    m_bImporting = true;

    // Indicate the import is starting
    if (m_site) {
        m_site->OnImportStart(m_id);
    }
}

// set the state of the import site because it is done importing
void
IImportSite::EndingImport()
{
    Assert(m_bImporting);
    // set not queued so we won't try to restart the import
    m_bQueued = false;
    // reset the imporing flag so we can start another import or
    // remove this one from the queue
    m_bImporting = false;
}
// set the state so the import site is able to be imported
HRESULT
IImportSite::QueueImport()
{
    Assert(!m_bQueued);
    // mark this site as ready to import
    m_bQueued = true;
#ifdef _DEBUG
    dwqueuetime = timeGetTime();
#endif
    // try and start an import
    StartAnImport();
    // tell the world we are happy
    return S_OK;
}

// do all the housekeeping for when and import is complete
HRESULT
IImportSite::CompleteImport()
{
    // ture off the importing flag so we can remove it from the queue
    EndingImport();
    // remove this entry from the queue
    if (!DeQueueImport()) {
        Assert(false);
    }

    // We no longer need the IStream so to avoid file locks we release it
    m_IStream.Release();

    // try and start a NEW import
    StartAnImport();
    // tell the world we are happy
#ifdef _DEBUG
    dwCompletetime = timeGetTime();
    TraceTag((tagImport, "IImportSite::CompleteImport, %s",m_pszPath));
    TraceTag((tagImport, "Const time      = %lx  delta from const",dwconsttime));
    TraceTag((tagImport, "Queue time      = %lx   %lu ms",dwqueuetime, dwqueuetime-dwconsttime));
    TraceTag((tagImport, "Start time      = %lx   %lu ms",dwstarttime, dwstarttime-dwconsttime));
    TraceTag((tagImport, "First Prog time = %lx   %lu ms",dwfirstProgtime, dwfirstProgtime-dwconsttime));
    TraceTag((tagImport, "Complete time   = %lx   %lu ms",dwCompletetime, dwCompletetime-dwconsttime));
#endif
    return S_OK;
}

// remove an import site from the import queue
bool
IImportSite::DeQueueImport()
{
    bool bret = false;
    TraceTag((tagImport, "DequeueImport -- site=%lx",this));
    // remove the site from our import list if it's import
    // is not in progress
    if (!IsImporting()) {
        CritSectGrabber csg(*s_pCS);
        TraceTag((tagImport, "DequeueImport -- removing site from list=%lx",this));
        
        // Make sure it is in the list before we Release it
        list<IImportSite *>::iterator i = s_pSitelist->begin() ;
        while (i != s_pSitelist->end()) {
            // we add refed it when we added it to the list, so release it now
            if ((*i) == this) 
                Release();
            i++;
        }
        
        s_pSitelist->remove(this);
        
        bret = true;
    }
    return bret;
}

// find an import on the list to start its import
// if we are not doing too many imports already
HRESULT
IImportSite::StartAnImport()
{
    IImportSite * pStartMe = NULL;
    float currentprio = -1;
    // if we are not busy yet, start another one.
    if(SimImports() < _SimImports) {
        {
            CritSectGrabber csg(*s_pCS);
            list<IImportSite *>::iterator i = s_pSitelist->begin() ;

            // go through the list and start the highest prio import we find
            // if they all are the same, we start the first
            while (i != s_pSitelist->end()) {
                if(!(*i)->IsImporting() &&
                    (*i)->IsQueued() &&
                    (*i)->GetImportPrio() > currentprio) {
                        pStartMe = *i;
                        currentprio = pStartMe->GetImportPrio();
                }
                i++;
            }
        }
        // if we found one, start it
        if (pStartMe) {
            pStartMe->StartingImport();
            pStartMe->Import();
        }
    }
    return S_OK;
}

// return the number of sites importing at this time
int
IImportSite::SimImports()
{
    // count the number of imports in progress
    CritSectGrabber csg(*s_pCS);
    int count = 0;
    list<IImportSite *>::iterator i = s_pSitelist->begin() ;
    
    while (i != s_pSitelist->end()) {
        if((*i)->IsImporting())
            count++;
        i++;
    }
    return count;
}

void
IImportSite::CancelImport()
{
    if (!m_bCanceled) {
        m_bCanceled = true;
        DeQueueImport();
        if (!m_bAsync)
            ReportCancel();
    }
}

void IImportSite::vBvrIsDying(Bvr deadBvr)

{
    if (!AllBvrsDead()) {
        CritSectGrabber csg(m_CS);
        if (fBvrIsDying(deadBvr))
        {
            SetAllBvrsDead();
            // cancel the import if nobody cares anymore
            CancelImport();
        }
    }
}

// is is up to the derived classes to call this
bool IImportSite::fBvrIsDying(Bvr deadBvr)
{
    if (deadBvr == m_ev)
    {
        m_ev = NULL;
    }
    else if (deadBvr == m_progress)
    {
        m_progress = NULL;
    }
    else if (deadBvr == m_size)
    {
        m_size = NULL;
    }
    if (m_ev || m_progress || m_size)
        return FALSE;
    else
        return TRUE;
}

void
IImportSite::StartDownloading()
{
    s_thread->AddImport(this);
}

void
IImportSite::CompleteDownloading()
{
    if (!s_thread->FinishImport(this)) {
        TraceTag((tagImport,
                  "CompleteDownload failed for import - %s", m_pszPath));

        DASetLastError(E_FAIL, IDS_ERR_FILE_NOT_FOUND, m_pszPath);
        OnError();
    }
}

HRESULT
StreamableImportSite::Import()
{
    if(GetStreaming()) { // do spacey magic to spoof import for streaming
        OnProgress((ULONG)100, (ULONG)100); // spoof an OnProgress complete

        // spoof completion the most std way (causes an OnComplete())
        CompleteDownloading();

    }
    else {
        IImportSite::Import();              // do the std urlmon based import
    }

    return S_OK;
}


//-------------------------------------------------------
//  Import thread
//-------------------------------------------------------

void
ImportThread::AddImport(IImportSite* pIIS)
{
    StartThread();
    
    pIIS->AddRef();
    if (!SendAsyncMsg(MSG_DOWNLOAD, 1, (DWORD_PTR) pIIS)) {
        pIIS->Release();
        RaiseException_InternalError("Unable to schedule import");
    }
}

bool
ImportThread::FinishImport(IImportSite* pIIS)
{
    Assert (IsStarted());
    
    pIIS->AddRef();
    if (!SendAsyncMsg(MSG_FINISHLOADING, 1, (DWORD_PTR) pIIS)) {
        pIIS->Release();
        return false;
    }

    return true;
}

void
ImportThread::StartThread()
{
    CritSectGrabber csg(_cs);
    if (!Start())
        RaiseException_InternalError("Unable to start import thread");
}

void
ImportThread::StopThread()
{
    CritSectGrabber csg(_cs);
    if (!Stop())
        RaiseException_InternalError("Unable to stop import thread");
}

void
ImportThread::ProcessMsg(DWORD dwMsg,
                         DWORD dwNumParams,
                         DWORD dwParams[])
{
    switch (dwMsg) {
      case MSG_DOWNLOAD:
        Assert (dwNumParams == 1);
        // queue the import, will also start the next one
        // if we are not maxed already
        ((IImportSite*)dwParams[0])->QueueImport();
        ((IImportSite*)dwParams[0])->Release();
        break;
      case MSG_FINISHLOADING:
        Assert (dwNumParams == 1);
        ((IImportSite*)dwParams[0])->OnSerializeFinish();
        // this is so the import queue can start another import
        ((IImportSite*)dwParams[0])->CompleteImport();
        ((IImportSite*)dwParams[0])->Release();
        break;
      default:
        Assert (false && "Invalid message sent to import thread");
    }
}

void
StartImportThread()
{
    IImportSite::s_thread->StartThread();
}

void
StopImportThread()
{
    IImportSite::s_thread->StopThread();

    CritSectGrabber csg(*IImportSite::s_pCS);
    
    // Make sure it is in the list before we Release it
    list<IImportSite *>::iterator i = IImportSite::s_pSitelist->begin() ;
    while (i != IImportSite::s_pSitelist->end()) {
        // we add refed it when we added it to the list, so release it now
        (*i)->CancelImport();
        (*i)->Release();
        i++;
    }
    
    IImportSite::s_pSitelist->clear();
}

//+-------------------------------------------------------------------------
//
//  CImportBindStatusCallback implementation
//
//  Generic implementation of IBindStatusCallback.  This is the root
//  class.
//
//--------------------------------------------------------------------------
CImportBindStatusCallback::CImportBindStatusCallback(IImportSite* pIIS) :
m_pIIS(pIIS)
{
    m_cRef = 1;
    m_szCacheFileName[0] = NULL;

    if (m_pIIS) m_pIIS->AddRef();
}


CImportBindStatusCallback::~CImportBindStatusCallback(void)
{
    RELEASE(m_pIIS);
}


STDMETHODIMP
CImportBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown)) {
        *ppv = (IUnknown *) (IBindStatusCallback *) this;
    }
    else if (IsEqualIID(riid, IID_IBindStatusCallback)) {
        *ppv = (IBindStatusCallback *) this;
    }
    else if (IsEqualIID(riid, IID_IAuthenticate)) {
        TraceTag((tagImport, "CImportBindStatusCallback::QI for IAuthenticate"));
        *ppv = (IAuthenticate *) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
    CImportBindStatusCallback::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}


STDMETHODIMP_(ULONG)
    CImportBindStatusCallback::Release(void)
{
    ULONG ul = InterlockedDecrement((long *)&m_cRef) ;

    if (ul == 0) delete this;

    return ul;
}


STDMETHODIMP
CImportBindStatusCallback::GetPriority(LONG* pnPriority)
{
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnProgress(ULONG ulProgress,  ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    if (m_pIIS->IsCanceled()) {
        if (m_pbinding != NULL) {
            m_pbinding->Abort();
        }
        else {
            // if no binding, cant cancel...
            Assert(0);
        }
    }
    else {
        if (ulStatusCode==BINDSTATUS_CACHEFILENAMEAVAILABLE) {
            if (WideCharToMultiByte(CP_ACP, 0, szStatusText, 
                lstrlenW(szStatusText)+1, m_szCacheFileName, MAX_PATH, 
                NULL, NULL)==0) {
                m_szCacheFileName[0] = NULL;
            }
            m_pIIS->SetCachePath(m_szCacheFileName); // stash the filename
            TraceTag((tagImport, "OnProcess:  cache file name obtained(%s)",m_szCacheFileName));
        }

        else if (ulStatusCode==BINDSTATUS_BEGINDOWNLOADDATA ||
                 ulStatusCode==BINDSTATUS_DOWNLOADINGDATA ||
                 ulStatusCode==BINDSTATUS_ENDDOWNLOADDATA) {

            m_pIIS->OnProgress(ulProgress,ulProgressMax);
        }
    }

    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    m_pbinding = pbinding;

    if (m_pIIS)
        m_pIIS->OnStartLoading();

    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR szError)
{
    Assert(m_pIIS);

    // Release the binding so that synchronous operations on the url
    // will work
    m_pbinding.Release();

    if (hrStatus) {
        DASetLastError(hrStatus, IDS_ERR_FILE_NOT_FOUND, m_pIIS->GetPath());
        m_pIIS->OnError();
    }
    
    if (m_pIIS) 
        m_pIIS->CompleteDownloading();

    // We no longer need it - free it now
    RELEASE(m_pIIS);
    
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::GetBindInfo(DWORD * pgrfBINDF, BINDINFO * pbindInfo)
{
    *pgrfBINDF=BINDF_ASYNCHRONOUS;
    
    if (StrCmpNIA("res://", m_pIIS->GetPath(), 6) == 0)
        *pgrfBINDF |= BINDF_PULLDATA;

    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnDataAvailable(DWORD grfBSCF,DWORD dwSize, FORMATETC * pfmtetc,
                                           STGMEDIUM * pstgmed)
{
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF) {
        if (!m_pIIS->m_IStream && pstgmed->tymed == TYMED_ISTREAM) {
            m_pIIS->m_IStream=pstgmed->pstm;
            TraceTag((tagImport, "IBSC::OnDataAvailable: addref on pstgmed %s",m_szCacheFileName));
        }
    }

    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    TraceTag((tagImport, "IBSC::OnObjectAvailable."));
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::Authenticate(HWND * phwnd,
                                        LPWSTR * pwszUser,
                                        LPWSTR * pwszPassword)
{
    if ((phwnd == NULL) || (pwszUser == NULL) || (pwszPassword == NULL)) {
        return E_INVALIDARG;
    }

    *phwnd = GetDesktopWindow();
    *pwszUser = NULL;
    *pwszPassword = NULL;

    TraceTag((tagImport, "-- hwnd=%lx, user=%ls, password=%ls", *phwnd,*pwszUser,  *pwszPassword));

    return S_OK;
}

// =========================================
// Initialization
// =========================================
void
InitializeModule_Import()
{
    IImportSite::s_pSitelist = NEW list<IImportSite *>;
    IImportSite::s_pCS = NEW CritSect;
    LoadString(hInst, IDS_DOWNLOAD_FILE, IImportSite::s_Fmt, sizeof(IImportSite::s_Fmt));
    IImportSite::s_thread = NEW ImportThread;
}

void
DeinitializeModule_Import(bool bShutdown)
{
    // Do not grab critsect since the thread may have been terminated
    // and never released the critsect.  Also there is no need - we
    // are terminating and all other threads are dead by now.
    
    delete IImportSite::s_thread;
    IImportSite::s_thread = NULL;

    delete IImportSite::s_pSitelist;
    IImportSite::s_pSitelist = NULL;

    delete IImportSite::s_pCS;
    IImportSite::s_pCS = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\pickq.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    // TODO: Should rename this file or merge into privinc/evenq.h

*******************************************************************************/


#ifndef _PICKQ_H
#define _PICKQ_H

#include "privinc/server.h"
#include "privinc/probe.h"

// Need comparison for constructing a map.  We don't really care what
// the results are, though...
typedef list<PickQData> PickEventQ;

typedef map< int, PickEventQ*, less<int> > PickMap;

class PickQ
{
  public:
    PickQ () ;
    ~PickQ () ;
    
    // This copies the data
    
    void Add (int eventId, PickQData & data) ;
    
    PickMap & GetCurrentPickMap() { return _pm ; }
    DynamicHeap & GetCurrentHeap () { return *_heap ; }

    void GatherPicks(Image* image, Time time, Time lastPollTime);
    
    BOOL CheckForPickEvent(int id, Time time, PickQData & result) ;

    void Reset(Time curTime, BOOL noLeftover);
    
  protected:
    PickMap _pm ;

    DynamicHeap * _heap;
    DynamicHeap * _heap1;
    DynamicHeap * _heap2;

    Time _heapSwitchTime;
} ;

#endif /* _PICKQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\primmth0.h ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

//
// DABoolean
//

class CDABooleanFactory;

class ATL_NO_VTABLE CDABoolean:
    public CBvrBase < IDABoolean,
                      &IID_IDABoolean>,
    public CComCoClass<CDABoolean, &CLSID_DABoolean>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDABoolean);

    DECLARE_CLASSFACTORY_EX(CDABooleanFactory);

    DECLARE_REGISTRY(CLSID_DABoolean,
                     LIBID ".DABoolean.1",
                     LIBID ".DABoolean",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDABoolean)
        COM_INTERFACE_ENTRY(IDABoolean)

        COM_INTERFACE_ENTRY2(IDABehavior,IDABoolean)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRBOOLEAN_TYPEID ; }
    const char * GetName () { return "DABoolean" ; }
    STDMETHOD(Extract) (VARIANT_BOOL * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDABoolean, &CLSID_DABoolean>::Error(str, IID_IDABoolean,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDABooleanCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDABooleanFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAGeometry
//

class CDAGeometryFactory;

class ATL_NO_VTABLE CDAGeometry:
    public CBvrBase < IDA3Geometry,
                      &IID_IDA3Geometry>,
    public CComCoClass<CDAGeometry, &CLSID_DAGeometry>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAGeometry);

    DECLARE_CLASSFACTORY_EX(CDAGeometryFactory);

    DECLARE_REGISTRY(CLSID_DAGeometry,
                     LIBID ".DAGeometry.1",
                     LIBID ".DAGeometry",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAGeometry)
        COM_INTERFACE_ENTRY(IDAGeometry)
        COM_INTERFACE_ENTRY(IDA2Geometry)
        COM_INTERFACE_ENTRY(IDA3Geometry)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA3Geometry)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRGEOMETRY_TYPEID ; }
    const char * GetName () { return "DAGeometry" ; }
    STDMETHOD(RenderSound) (IDAMicrophone *  arg1, IDASound *  * ret);
    STDMETHOD(Pickable) (IDAPickableResult * * ret);
    STDMETHOD(PickableOccluded) (IDAPickableResult * * ret);
    STDMETHOD(AddPickData) (IUnknown * arg1, VARIANT_BOOL arg2, IDAGeometry *  * ret);
    STDMETHOD(Undetectable) (IDAGeometry *  * ret);
    STDMETHOD(EmissiveColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(DiffuseColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(SpecularColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(SpecularExponent) (double arg0, IDAGeometry *  * ret);
    STDMETHOD(SpecularExponentAnim) (IDANumber *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Texture) (IDAImage *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Opacity) (double arg0, IDAGeometry *  * ret);
    STDMETHOD(OpacityAnim) (IDANumber *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Shadow) (IDAGeometry *  arg1, IDAPoint3 *  arg2, IDAVector3 *  arg3, IDAGeometry *  * ret);
    STDMETHOD(get_BoundingBox) (IDABbox3 *  * ret);
    STDMETHOD(Render) (IDACamera *  arg1, IDAImage *  * ret);
    STDMETHOD(LightColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(LightRangeAnim) (IDANumber *  arg0, IDAGeometry *  * ret);
    STDMETHOD(LightRange) (double arg0, IDAGeometry *  * ret);
    STDMETHOD(LightAttenuationAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAGeometry *  * ret);
    STDMETHOD(LightAttenuation) (double arg0, double arg1, double arg2, IDAGeometry *  * ret);
    STDMETHOD(BlendTextureDiffuse) (IDABoolean *  arg1, IDAGeometry *  * ret);
    STDMETHOD(AmbientColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(D3DRMTexture) (IUnknown * arg1, IDAGeometry *  * ret);
    STDMETHOD(ModelClip) (IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAGeometry *  * ret);
    STDMETHOD(Lighting) (IDABoolean *  arg0, IDAGeometry *  * ret);
    STDMETHOD(TextureImage) (IDAImage *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Billboard) (IDAVector3*, IDAGeometry**);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAGeometry, &CLSID_DAGeometry>::Error(str, IID_IDA3Geometry,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAGeometryCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAGeometryFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAMicrophone
//

class CDAMicrophoneFactory;

class ATL_NO_VTABLE CDAMicrophone:
    public CBvrBase < IDAMicrophone,
                      &IID_IDAMicrophone>,
    public CComCoClass<CDAMicrophone, &CLSID_DAMicrophone>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAMicrophone);

    DECLARE_CLASSFACTORY_EX(CDAMicrophoneFactory);

    DECLARE_REGISTRY(CLSID_DAMicrophone,
                     LIBID ".DAMicrophone.1",
                     LIBID ".DAMicrophone",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAMicrophone)
        COM_INTERFACE_ENTRY(IDAMicrophone)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAMicrophone)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRMICROPHONE_TYPEID ; }
    const char * GetName () { return "DAMicrophone" ; }
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDAMicrophone *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAMicrophone, &CLSID_DAMicrophone>::Error(str, IID_IDAMicrophone,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAMicrophoneCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAMicrophoneFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAPath2
//

class CDAPath2Factory;

class ATL_NO_VTABLE CDAPath2:
    public CBvrBase < IDAPath2,
                      &IID_IDAPath2>,
    public CComCoClass<CDAPath2, &CLSID_DAPath2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAPath2);

    DECLARE_CLASSFACTORY_EX(CDAPath2Factory);

    DECLARE_REGISTRY(CLSID_DAPath2,
                     LIBID ".DAPath2.1",
                     LIBID ".DAPath2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAPath2)
        COM_INTERFACE_ENTRY(IDAPath2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAPath2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRPATH2_TYPEID ; }
    const char * GetName () { return "DAPath2" ; }
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAPath2 *  * ret);
    STDMETHOD(BoundingBox) (IDALineStyle *  arg0, IDABbox2 *  * ret);
    STDMETHOD(Fill) (IDALineStyle *  arg0, IDAImage *  arg1, IDAImage *  * ret);
    STDMETHOD(Draw) (IDALineStyle *  arg0, IDAImage *  * ret);
    STDMETHOD(Close) (IDAPath2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAPath2, &CLSID_DAPath2>::Error(str, IID_IDAPath2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAPath2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAPath2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DASound
//

class CDASoundFactory;

class ATL_NO_VTABLE CDASound:
    public CBvrBase < IDASound,
                      &IID_IDASound>,
    public CComCoClass<CDASound, &CLSID_DASound>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDASound);

    DECLARE_CLASSFACTORY_EX(CDASoundFactory);

    DECLARE_REGISTRY(CLSID_DASound,
                     LIBID ".DASound.1",
                     LIBID ".DASound",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDASound)
        COM_INTERFACE_ENTRY(IDASound)

        COM_INTERFACE_ENTRY2(IDABehavior,IDASound)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRSOUND_TYPEID ; }
    const char * GetName () { return "DASound" ; }
    STDMETHOD(PhaseAnim) (IDANumber *  arg0, IDASound *  * ret);
    STDMETHOD(Phase) (double arg0, IDASound *  * ret);
    STDMETHOD(RateAnim) (IDANumber *  arg0, IDASound *  * ret);
    STDMETHOD(Rate) (double arg0, IDASound *  * ret);
    STDMETHOD(PanAnim) (IDANumber *  arg0, IDASound *  * ret);
    STDMETHOD(Pan) (double arg0, IDASound *  * ret);
    STDMETHOD(GainAnim) (IDANumber *  arg0, IDASound *  * ret);
    STDMETHOD(Gain) (double arg0, IDASound *  * ret);
    STDMETHOD(Loop) (IDASound *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDASound, &CLSID_DASound>::Error(str, IID_IDASound,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDASoundCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDASoundFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DATransform3
//

class CDATransform3Factory;

class ATL_NO_VTABLE CDATransform3:
    public CBvrBase < IDATransform3,
                      &IID_IDATransform3>,
    public CComCoClass<CDATransform3, &CLSID_DATransform3>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDATransform3);

    DECLARE_CLASSFACTORY_EX(CDATransform3Factory);

    DECLARE_REGISTRY(CLSID_DATransform3,
                     LIBID ".DATransform3.1",
                     LIBID ".DATransform3",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDATransform3)
        COM_INTERFACE_ENTRY(IDATransform3)

        COM_INTERFACE_ENTRY2(IDABehavior,IDATransform3)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRTRANSFORM3_TYPEID ; }
    const char * GetName () { return "DATransform3" ; }
    STDMETHOD(Inverse) (IDATransform3 *  * ret);
    STDMETHOD(get_IsSingular) (IDABoolean *  * ret);
    STDMETHOD(ParallelTransform2) (IDATransform2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDATransform3, &CLSID_DATransform3>::Error(str, IID_IDATransform3,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDATransform3Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDATransform3Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAFontStyle
//

class CDAFontStyleFactory;

class ATL_NO_VTABLE CDAFontStyle:
    public CBvrBase < IDA2FontStyle,
                      &IID_IDA2FontStyle>,
    public CComCoClass<CDAFontStyle, &CLSID_DAFontStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAFontStyle);

    DECLARE_CLASSFACTORY_EX(CDAFontStyleFactory);

    DECLARE_REGISTRY(CLSID_DAFontStyle,
                     LIBID ".DAFontStyle.1",
                     LIBID ".DAFontStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAFontStyle)
        COM_INTERFACE_ENTRY(IDAFontStyle)
        COM_INTERFACE_ENTRY(IDA2FontStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA2FontStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRFONTSTYLE_TYPEID ; }
    const char * GetName () { return "DAFontStyle" ; }
    STDMETHOD(Bold) (IDAFontStyle *  * ret);
    STDMETHOD(Italic) (IDAFontStyle *  * ret);
    STDMETHOD(Underline) (IDAFontStyle *  * ret);
    STDMETHOD(Strikethrough) (IDAFontStyle *  * ret);
    STDMETHOD(AntiAliasing) (double arg0, IDAFontStyle *  * ret);
    STDMETHOD(Color) (IDAColor *  arg1, IDAFontStyle *  * ret);
    STDMETHOD(FamilyAnim) (IDAString *  arg1, IDAFontStyle *  * ret);
    STDMETHOD(Family) (BSTR arg1, IDAFontStyle *  * ret);
    STDMETHOD(SizeAnim) (IDANumber *  arg1, IDAFontStyle *  * ret);
    STDMETHOD(Size) (double arg1, IDAFontStyle *  * ret);
    STDMETHOD(Weight) (double arg1, IDAFontStyle *  * ret);
    STDMETHOD(WeightAnim) (IDANumber *  arg1, IDAFontStyle *  * ret);
    STDMETHOD(TransformCharacters) (IDATransform2 *  arg1, IDAFontStyle *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAFontStyle, &CLSID_DAFontStyle>::Error(str, IID_IDA2FontStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAFontStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAFontStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAJoinStyle
//

class CDAJoinStyleFactory;

class ATL_NO_VTABLE CDAJoinStyle:
    public CBvrBase < IDAJoinStyle,
                      &IID_IDAJoinStyle>,
    public CComCoClass<CDAJoinStyle, &CLSID_DAJoinStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAJoinStyle);

    DECLARE_CLASSFACTORY_EX(CDAJoinStyleFactory);

    DECLARE_REGISTRY(CLSID_DAJoinStyle,
                     LIBID ".DAJoinStyle.1",
                     LIBID ".DAJoinStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAJoinStyle)
        COM_INTERFACE_ENTRY(IDAJoinStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAJoinStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRJOINSTYLE_TYPEID ; }
    const char * GetName () { return "DAJoinStyle" ; }


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAJoinStyle, &CLSID_DAJoinStyle>::Error(str, IID_IDAJoinStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAJoinStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAJoinStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DABbox3
//

class CDABbox3Factory;

class ATL_NO_VTABLE CDABbox3:
    public CBvrBase < IDABbox3,
                      &IID_IDABbox3>,
    public CComCoClass<CDABbox3, &CLSID_DABbox3>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDABbox3);

    DECLARE_CLASSFACTORY_EX(CDABbox3Factory);

    DECLARE_REGISTRY(CLSID_DABbox3,
                     LIBID ".DABbox3.1",
                     LIBID ".DABbox3",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDABbox3)
        COM_INTERFACE_ENTRY(IDABbox3)

        COM_INTERFACE_ENTRY2(IDABehavior,IDABbox3)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRBBOX3_TYPEID ; }
    const char * GetName () { return "DABbox3" ; }
    STDMETHOD(get_Min) (IDAPoint3 *  * ret);
    STDMETHOD(get_Max) (IDAPoint3 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDABbox3, &CLSID_DABbox3>::Error(str, IID_IDABbox3,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDABbox3Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDABbox3Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAArray
//

class CDAArrayFactory;

class ATL_NO_VTABLE CDAArray:
    public CBvrBase < IDA3Array,
                      &IID_IDA3Array>,
    public CComCoClass<CDAArray, &CLSID_DAArray>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAArray);

    DECLARE_CLASSFACTORY_EX(CDAArrayFactory);

    DECLARE_REGISTRY(CLSID_DAArray,
                     LIBID ".DAArray.1",
                     LIBID ".DAArray",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAArray)
        COM_INTERFACE_ENTRY(IDAArray)
        COM_INTERFACE_ENTRY(IDA2Array)
        COM_INTERFACE_ENTRY(IDA3Array)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA3Array)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRARRAY_TYPEID ; }
    const char * GetName () { return "DAArray" ; }
    STDMETHOD(NthAnim) (IDANumber *  arg1, IDABehavior *  * ret);
    STDMETHOD(Length) (IDANumber *  * ret);
    STDMETHOD(AddElement) (IDABehavior *  arg1, DWORD arg2, long * ret);
    STDMETHOD(RemoveElement) (long arg1);
    STDMETHOD(SetElement)(long index, IDABehavior *  arg, long flag);
    STDMETHOD(GetElement)(long index, IDABehavior **ret);

  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAArray, &CLSID_DAArray>::Error(str, IID_IDA3Array,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAArrayCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAArrayFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

class IDAHackBvr : public IDABehavior{};

//
// DABehavior
//

class CDABehaviorFactory;

class ATL_NO_VTABLE CDABehavior:
    public CBvrBase < IDAHackBvr,
                      &IID_IDABehavior>,
    public CComCoClass<CDABehavior, &CLSID_DABehavior>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDABehavior);

    DECLARE_CLASSFACTORY_EX(CDABehaviorFactory);

    DECLARE_REGISTRY(CLSID_DABehavior,
                     LIBID ".DABehavior.1",
                     LIBID ".DABehavior",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDABehavior)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAHackBvr)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRUNKNOWN_TYPEID ; }
    const char * GetName () { return "DABehavior" ; }


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDABehavior, &CLSID_DABehavior>::Error(str, IID_IDABehavior,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDABehaviorCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDABehaviorFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\primmth2.h ===
//
// DAColor
//

class CDAColorFactory;

class ATL_NO_VTABLE CDAColor:
    public CBvrBase < IDA2Color,
                      &IID_IDA2Color>,
    public CComCoClass<CDAColor, &CLSID_DAColor>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAColor);

    DECLARE_CLASSFACTORY_EX(CDAColorFactory);
    
    DECLARE_REGISTRY(CLSID_DAColor,
                     LIBID ".DAColor.1",
                     LIBID ".DAColor",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAColor)
        COM_INTERFACE_ENTRY(IDAColor)
        COM_INTERFACE_ENTRY(IDA2Color)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA2Color)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRCOLOR_TYPEID ; }
    const char * GetName () { return "DAColor" ; }
    STDMETHOD(get_Red) (IDANumber *  * ret);
    STDMETHOD(get_Green) (IDANumber *  * ret);
    STDMETHOD(get_Blue) (IDANumber *  * ret);
    STDMETHOD(get_Hue) (IDANumber *  * ret);
    STDMETHOD(get_Saturation) (IDANumber *  * ret);
    STDMETHOD(get_Lightness) (IDANumber *  * ret);
    STDMETHOD(AnimateProperty) (BSTR propertyPath_0, 
                                BSTR scriptingLanguage_1, 
                                VARIANT_BOOL invokeAsMethod_2, 
                                double minUpdateInterval_3, 
                                IDA2Color * * ret_4) ;


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAColor, &CLSID_DAColor>::Error(str, IID_IDAColor,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAColorCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAColorFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAMatte
//

class CDAMatteFactory;

class ATL_NO_VTABLE CDAMatte:
    public CBvrBase < IDAMatte,
                      &IID_IDAMatte>,
    public CComCoClass<CDAMatte, &CLSID_DAMatte>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAMatte);

    DECLARE_CLASSFACTORY_EX(CDAMatteFactory);
    
    DECLARE_REGISTRY(CLSID_DAMatte,
                     LIBID ".DAMatte.1",
                     LIBID ".DAMatte",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAMatte)
        COM_INTERFACE_ENTRY(IDAMatte)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAMatte)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRMATTE_TYPEID ; }
    const char * GetName () { return "DAMatte" ; }
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAMatte *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAMatte, &CLSID_DAMatte>::Error(str, IID_IDAMatte,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAMatteCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAMatteFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DANumber
//

class CDANumberFactory;

class ATL_NO_VTABLE CDANumber:
    public CBvrBase < IDANumber,
                      &IID_IDANumber>,
    public CComCoClass<CDANumber, &CLSID_DANumber>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDANumber);

    DECLARE_CLASSFACTORY_EX(CDANumberFactory);
    
    DECLARE_REGISTRY(CLSID_DANumber,
                     LIBID ".DANumber.1",
                     LIBID ".DANumber",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDANumber)
        COM_INTERFACE_ENTRY(IDANumber)

        COM_INTERFACE_ENTRY2(IDABehavior,IDANumber)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRNUMBER_TYPEID ; }
    const char * GetName () { return "DANumber" ; }
    STDMETHOD(Extract) (double * ret);
    STDMETHOD(AnimateProperty) (BSTR arg1, BSTR arg2, VARIANT_BOOL arg3, double arg4, IDANumber *  * ret);
    STDMETHOD(ToStringAnim) (IDANumber *  arg1, IDAString *  * ret);
    STDMETHOD(ToString) (double arg1, IDAString *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDANumber, &CLSID_DANumber>::Error(str, IID_IDANumber,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDANumberCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDANumberFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAPoint3
//

class CDAPoint3Factory;

class ATL_NO_VTABLE CDAPoint3:
    public CBvrBase < IDAPoint3,
                      &IID_IDAPoint3>,
    public CComCoClass<CDAPoint3, &CLSID_DAPoint3>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAPoint3);

    DECLARE_CLASSFACTORY_EX(CDAPoint3Factory);
    
    DECLARE_REGISTRY(CLSID_DAPoint3,
                     LIBID ".DAPoint3.1",
                     LIBID ".DAPoint3",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAPoint3)
        COM_INTERFACE_ENTRY(IDAPoint3)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAPoint3)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRPOINT3_TYPEID ; }
    const char * GetName () { return "DAPoint3" ; }
    STDMETHOD(Project) (IDACamera *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(get_X) (IDANumber *  * ret);
    STDMETHOD(get_Y) (IDANumber *  * ret);
    STDMETHOD(get_Z) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordXYAngle) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordYZAngle) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordLength) (IDANumber *  * ret);
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDAPoint3 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAPoint3, &CLSID_DAPoint3>::Error(str, IID_IDAPoint3,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAPoint3Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAPoint3Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DATransform2
//

class CDATransform2Factory;

class ATL_NO_VTABLE CDATransform2:
    public CBvrBase < IDATransform2,
                      &IID_IDATransform2>,
    public CComCoClass<CDATransform2, &CLSID_DATransform2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDATransform2);

    DECLARE_CLASSFACTORY_EX(CDATransform2Factory);
    
    DECLARE_REGISTRY(CLSID_DATransform2,
                     LIBID ".DATransform2.1",
                     LIBID ".DATransform2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDATransform2)
        COM_INTERFACE_ENTRY(IDATransform2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDATransform2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRTRANSFORM2_TYPEID ; }
    const char * GetName () { return "DATransform2" ; }
    STDMETHOD(Inverse) (IDATransform2 *  * ret);
    STDMETHOD(get_IsSingular) (IDABoolean *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDATransform2, &CLSID_DATransform2>::Error(str, IID_IDATransform2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDATransform2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDATransform2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAVector3
//

class CDAVector3Factory;

class ATL_NO_VTABLE CDAVector3:
    public CBvrBase < IDAVector3,
                      &IID_IDAVector3>,
    public CComCoClass<CDAVector3, &CLSID_DAVector3>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAVector3);

    DECLARE_CLASSFACTORY_EX(CDAVector3Factory);
    
    DECLARE_REGISTRY(CLSID_DAVector3,
                     LIBID ".DAVector3.1",
                     LIBID ".DAVector3",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAVector3)
        COM_INTERFACE_ENTRY(IDAVector3)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAVector3)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRVECTOR3_TYPEID ; }
    const char * GetName () { return "DAVector3" ; }
    STDMETHOD(get_Length) (IDANumber *  * ret);
    STDMETHOD(get_LengthSquared) (IDANumber *  * ret);
    STDMETHOD(Normalize) (IDAVector3 *  * ret);
    STDMETHOD(MulAnim) (IDANumber *  arg0, IDAVector3 *  * ret);
    STDMETHOD(Mul) (double arg0, IDAVector3 *  * ret);
    STDMETHOD(DivAnim) (IDANumber *  arg1, IDAVector3 *  * ret);
    STDMETHOD(Div) (double arg1, IDAVector3 *  * ret);
    STDMETHOD(get_X) (IDANumber *  * ret);
    STDMETHOD(get_Y) (IDANumber *  * ret);
    STDMETHOD(get_Z) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordXYAngle) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordYZAngle) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordLength) (IDANumber *  * ret);
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDAVector3 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAVector3, &CLSID_DAVector3>::Error(str, IID_IDAVector3,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAVector3Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAVector3Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAEndStyle
//

class CDAEndStyleFactory;

class ATL_NO_VTABLE CDAEndStyle:
    public CBvrBase < IDAEndStyle,
                      &IID_IDAEndStyle>,
    public CComCoClass<CDAEndStyle, &CLSID_DAEndStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAEndStyle);

    DECLARE_CLASSFACTORY_EX(CDAEndStyleFactory);
    
    DECLARE_REGISTRY(CLSID_DAEndStyle,
                     LIBID ".DAEndStyle.1",
                     LIBID ".DAEndStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAEndStyle)
        COM_INTERFACE_ENTRY(IDAEndStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAEndStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRENDSTYLE_TYPEID ; }
    const char * GetName () { return "DAEndStyle" ; }


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAEndStyle, &CLSID_DAEndStyle>::Error(str, IID_IDAEndStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAEndStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAEndStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DABbox2
//

class CDABbox2Factory;

class ATL_NO_VTABLE CDABbox2:
    public CBvrBase < IDABbox2,
                      &IID_IDABbox2>,
    public CComCoClass<CDABbox2, &CLSID_DABbox2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDABbox2);

    DECLARE_CLASSFACTORY_EX(CDABbox2Factory);
    
    DECLARE_REGISTRY(CLSID_DABbox2,
                     LIBID ".DABbox2.1",
                     LIBID ".DABbox2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDABbox2)
        COM_INTERFACE_ENTRY(IDABbox2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDABbox2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRBBOX2_TYPEID ; }
    const char * GetName () { return "DABbox2" ; }
    STDMETHOD(get_Min) (IDAPoint2 *  * ret);
    STDMETHOD(get_Max) (IDAPoint2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDABbox2, &CLSID_DABbox2>::Error(str, IID_IDABbox2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDABbox2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDABbox2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAEvent
//

class CDAEventFactory;

class ATL_NO_VTABLE CDAEvent:
    public CBvrBase < IDA2Event,
                      &IID_IDA2Event>,
    public CComCoClass<CDAEvent, &CLSID_DAEvent>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAEvent);

    DECLARE_CLASSFACTORY_EX(CDAEventFactory);
    
    DECLARE_REGISTRY(CLSID_DAEvent,
                     LIBID ".DAEvent.1",
                     LIBID ".DAEvent",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAEvent)
        COM_INTERFACE_ENTRY(IDAEvent)
        COM_INTERFACE_ENTRY(IDA2Event)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA2Event)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CREVENT_TYPEID ; }
    const char * GetName () { return "DAEvent" ; }
    STDMETHOD(Notify) (IDAUntilNotifier * arg1, IDAEvent *  * ret);
    STDMETHOD(Snapshot) (IDABehavior *  arg1, IDAEvent *  * ret);
    STDMETHOD(AttachData) (IDABehavior *  arg1, IDAEvent *  * ret);
    STDMETHOD(ScriptCallback) (BSTR arg0, BSTR arg2, IDAEvent *  * ret);
    STDMETHOD(NotifyScript) (BSTR arg1, IDAEvent *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAEvent, &CLSID_DAEvent>::Error(str, IID_IDA2Event,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAEventCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAEventFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAUserData
//

class CDAUserDataFactory;

class ATL_NO_VTABLE CDAUserData:
    public CBvrBase < IDAUserData,
                      &IID_IDAUserData>,
    public CComCoClass<CDAUserData, &CLSID_DAUserData>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAUserData);

    DECLARE_CLASSFACTORY_EX(CDAUserDataFactory);
    
    DECLARE_REGISTRY(CLSID_DAUserData,
                     LIBID ".DAUserData.1",
                     LIBID ".DAUserData",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAUserData)
        COM_INTERFACE_ENTRY(IDAUserData)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAUserData)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRUSERDATA_TYPEID ; }
    const char * GetName () { return "DAUserData" ; }
    STDMETHOD(get_Data) (IUnknown * * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAUserData, &CLSID_DAUserData>::Error(str, IID_IDAUserData,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAUserDataCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAUserDataFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\results.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

*******************************************************************************/


#include "headers.h"
#include "results.h"
#include "privinc/dxxf.h"
#include "cbvr.h"
#include "srvprims.h"

#define PROP_RETURNER(classAndMethod, propType, memberName) \
  STDMETHODIMP                                      \
  classAndMethod(propType **ppResult) {             \
      CHECK_RETURN_SET_NULL(ppResult);              \
      if ((memberName).p) {                         \
          *ppResult = (memberName);                 \
          (memberName)->AddRef();                   \
      }                                             \
      return S_OK;                                  \
  }

#define BVR_RETURNER(classAndMethod, propType, exp)             \
  STDMETHODIMP                                                  \
  classAndMethod(propType **ppResult) {                         \
      CHECK_RETURN_SET_NULL(ppResult);                          \
      CRLockGrabber __gclg;                                     \
      CRBvrPtr b = (CRBvrPtr) exp;                              \
      if (b) {                                                  \
          if (!CreateCBvr(IID_##propType,                       \
                          b,                                    \
                          (void **) ppResult))                  \
              return CRGetLastError();                          \
      }                                                         \
      return S_OK;                                              \
  }

//////////////////////////  CDAPickableResult   ////////////////

BVR_RETURNER(CDAPickableResult::get_Image, IDAImage, CRGetImage(_result));
BVR_RETURNER(CDAPickableResult::get_Geometry, IDAGeometry, CRGetGeometry(_result));
BVR_RETURNER(CDAPickableResult::get_PickEvent, IDAEvent, CRGetEvent(_result));


// Static method
bool
CDAPickableResult::Create(CRPickableResult *res,
                          IDAPickableResult **ppResult)
{
    *ppResult = NULL;
    DAComObject<CDAPickableResult> *pNew;
    DAComObject<CDAPickableResult>::CreateInstance(&pNew);

    HRESULT hr = E_OUTOFMEMORY;
    if (pNew) {
        pNew->_result = res;
        hr = pNew->QueryInterface(IID_IDAPickableResult,
                                  (void **)ppResult);
        if (FAILED(hr)) {
            delete pNew;
        }
    }

    if (FAILED(hr)) {
        CRSetLastError(hr, NULL);
        return false;
    } else {
        return true;
    } 
}

//////////////////////////  CDAImportationResult   ////////////////

BVR_RETURNER(CDAImportationResult::get_Image, IDAImage, _image)
BVR_RETURNER(CDAImportationResult::get_Sound, IDASound, _sound)
BVR_RETURNER(CDAImportationResult::get_Geometry, IDAGeometry, _geom)

BVR_RETURNER(CDAImportationResult::get_Duration, IDANumber, _duration)
BVR_RETURNER(CDAImportationResult::get_Progress, IDANumber, _progress)
BVR_RETURNER(CDAImportationResult::get_Size, IDANumber, _size)
    
BVR_RETURNER(CDAImportationResult::get_CompletionEvent,
             IDAEvent, _completionEvent)


// Static method
HRESULT
CDAImportationResult::Create(CRImage *img,
                             CRSound *snd,
                             CRGeometry *geom,
                             CRNumber *duration,
                             CREvent *event,
                             CRNumber *progress,
                             CRNumber *size,
                             IDAImportationResult **ppResult)
{
    DAComObject<CDAImportationResult> *pNew;
    DAComObject<CDAImportationResult>::CreateInstance(&pNew);

    *ppResult = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    if (pNew) {
        pNew->_image = (CRBvrPtr)img;
        pNew->_sound = (CRBvrPtr)snd;
        pNew->_geom = (CRBvrPtr)geom;
        pNew->_duration = (CRBvrPtr)duration;
        pNew->_progress = (CRBvrPtr)progress;
        pNew->_size = (CRBvrPtr)size;
        pNew->_completionEvent = (CRBvrPtr)event;
        hr = pNew->QueryInterface(IID_IDAImportationResult,
                                  (void **)ppResult);
        if (FAILED(hr)) {
            delete pNew;
        }
    }

    return hr;
}

//////////////////////  CDADXTransformResult   ////////////////

PROP_RETURNER(CDADXTransformResult::get_TheTransform, IDispatch, _theTransform)

// Static method
HRESULT
CDADXTransformResult::Create(IDispatch *theXf,
                             CRDXTransformResultPtr  bvr,
                             IDADXTransformResult **ppResult)
{
    DAComObject<CDADXTransformResult> *pNew;
    DAComObject<CDADXTransformResult>::CreateInstance(&pNew);

    *ppResult = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    if (pNew) {
        pNew->_theTransform = theXf;
        pNew->_xfResult = bvr;

        hr = pNew->QueryInterface(IID_IDADXTransformResult,
                                  (void **)ppResult);
    }

    if (FAILED(hr)) {
        delete pNew;
        CRSetLastError(hr, NULL);
    }

    return hr;
}

STDMETHODIMP
CDADXTransformResult::PutBvrAsProperty(BSTR property,
                                       IDABehavior *comBvr)
{
    PRIMPRECODE0(ok);

    MAKE_BVR_NAME(crbvr, comBvr);

    ok = CRSetBvrAsProperty(_xfResult,
                            property,
                            crbvr);

    PRIMPOSTCODE0(ok);
}

BVR_RETURNER(CDADXTransformResult::get_OutputBvr,
             IDABehavior,
             CRGetOutputBvr(_xfResult))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\propanim.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Headers for property animation functions

*******************************************************************************/


#ifndef _PROPANIM_H
#define _PROPANIM_H

HRESULT
Point2AnimateControlPosition(IDAPoint2 *pt,
                             BSTR propertyPath,
                             BSTR scriptingLanguage,
                             bool invokeAsMethod,
                             double minUpdateInterval,
                             IDAPoint2 **newPt,
                             bool convertToPixel);

HRESULT
NumberAnimateProperty(IDANumber *num,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDANumber **newNum);

HRESULT
StringAnimateProperty(IDAString *str,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDAString **newStr);

HRESULT
ColorAnimateProperty(IDA2Color *col,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDA2Color **newCol);



#endif /* _PROPANIM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\primmth1.h ===
//
// DACamera
//

class CDACameraFactory;

class ATL_NO_VTABLE CDACamera:
    public CBvrBase < IDACamera,
                      &IID_IDACamera>,
    public CComCoClass<CDACamera, &CLSID_DACamera>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDACamera);

    DECLARE_CLASSFACTORY_EX(CDACameraFactory);
    
    DECLARE_REGISTRY(CLSID_DACamera,
                     LIBID ".DACamera.1",
                     LIBID ".DACamera",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDACamera)
        COM_INTERFACE_ENTRY(IDACamera)

        COM_INTERFACE_ENTRY2(IDABehavior,IDACamera)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRCAMERA_TYPEID ; }
    const char * GetName () { return "DACamera" ; }
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDACamera *  * ret);
    STDMETHOD(Depth) (double arg0, IDACamera *  * ret);
    STDMETHOD(DepthAnim) (IDANumber *  arg0, IDACamera *  * ret);
    STDMETHOD(DepthResolution) (double arg0, IDACamera *  * ret);
    STDMETHOD(DepthResolutionAnim) (IDANumber *  arg0, IDACamera *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDACamera, &CLSID_DACamera>::Error(str, IID_IDACamera,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDACameraCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDACameraFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAImage
//

class CDAImageFactory;

class ATL_NO_VTABLE CDAImage:
    public CBvrBase < IDA3Image,
                      &IID_IDA3Image>,
    public CComCoClass<CDAImage, &CLSID_DAImage>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAImage);

    DECLARE_CLASSFACTORY_EX(CDAImageFactory);
    
    DECLARE_REGISTRY(CLSID_DAImage,
                     LIBID ".DAImage.1",
                     LIBID ".DAImage",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAImage)
        COM_INTERFACE_ENTRY(IDAImage)
        COM_INTERFACE_ENTRY(IDA2Image)
        COM_INTERFACE_ENTRY(IDA3Image)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA3Image)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRIMAGE_TYPEID ; }
    const char * GetName () { return "DAImage" ; }
    STDMETHOD(Pickable) (IDAPickableResult * * ret);
    STDMETHOD(PickableOccluded) (IDAPickableResult * * ret);
    STDMETHOD(ApplyBitmapEffect) (IUnknown * arg1, IDAEvent *  arg2, IDAImage *  * ret);
    STDMETHOD(AddPickData) (IUnknown * arg1, VARIANT_BOOL arg2, IDAImage *  * ret);
    STDMETHOD(get_BoundingBox) (IDABbox2 *  * ret);
    STDMETHOD(Crop) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAImage *  * ret);
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAImage *  * ret);
    STDMETHOD(OpacityAnim) (IDANumber *  arg0, IDAImage *  * ret);
    STDMETHOD(Opacity) (double arg0, IDAImage *  * ret);
    STDMETHOD(Undetectable) (IDAImage *  * ret);
    STDMETHOD(Tile) (IDAImage *  * ret);
    STDMETHOD(Clip) (IDAMatte *  arg0, IDAImage *  * ret);
    STDMETHOD(MapToUnitSquare) (IDAImage *  * ret);
    STDMETHOD(ClipPolygonImageEx) (long sizearg0, IDAPoint2 *  arg0[], IDAImage *  * ret);
    STDMETHOD(ClipPolygonImage) (VARIANT arg0, IDAImage *  * ret);
    STDMETHOD(RenderResolution) (long arg1, long arg2, IDAImage *  * ret);
    STDMETHOD(ImageQuality) (DWORD arg1, IDAImage *  * ret);
    STDMETHOD(ColorKey) (IDAColor *  arg1, IDAImage *  * ret);
    STDMETHOD(TransformColorRGB) (IDATransform3 * arg1, IDAImage *  * ret);

  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAImage, &CLSID_DAImage>::Error(str, IID_IDA3Image,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAImageCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAImageFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAMontage
//

class CDAMontageFactory;

class ATL_NO_VTABLE CDAMontage:
    public CBvrBase < IDAMontage,
                      &IID_IDAMontage>,
    public CComCoClass<CDAMontage, &CLSID_DAMontage>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAMontage);

    DECLARE_CLASSFACTORY_EX(CDAMontageFactory);
    
    DECLARE_REGISTRY(CLSID_DAMontage,
                     LIBID ".DAMontage.1",
                     LIBID ".DAMontage",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAMontage)
        COM_INTERFACE_ENTRY(IDAMontage)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAMontage)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRMONTAGE_TYPEID ; }
    const char * GetName () { return "DAMontage" ; }
    STDMETHOD(Render) (IDAImage *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAMontage, &CLSID_DAMontage>::Error(str, IID_IDAMontage,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAMontageCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAMontageFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAPoint2
//

class CDAPoint2Factory;

class ATL_NO_VTABLE CDAPoint2:
    public CBvrBase < IDAPoint2,
                      &IID_IDAPoint2>,
    public CComCoClass<CDAPoint2, &CLSID_DAPoint2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAPoint2);

    DECLARE_CLASSFACTORY_EX(CDAPoint2Factory);
    
    DECLARE_REGISTRY(CLSID_DAPoint2,
                     LIBID ".DAPoint2.1",
                     LIBID ".DAPoint2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAPoint2)
        COM_INTERFACE_ENTRY(IDAPoint2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAPoint2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRPOINT2_TYPEID ; }
    const char * GetName () { return "DAPoint2" ; }
    STDMETHOD(AnimateControlPosition) (BSTR arg1, BSTR arg2, VARIANT_BOOL arg3, double arg4, IDAPoint2 *  * ret);
    STDMETHOD(AnimateControlPositionPixel) (BSTR arg1, BSTR arg2, VARIANT_BOOL arg3, double arg4, IDAPoint2 *  * ret);
    STDMETHOD(get_X) (IDANumber *  * ret);
    STDMETHOD(get_Y) (IDANumber *  * ret);
    STDMETHOD(get_PolarCoordAngle) (IDANumber *  * ret);
    STDMETHOD(get_PolarCoordLength) (IDANumber *  * ret);
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAPoint2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAPoint2, &CLSID_DAPoint2>::Error(str, IID_IDAPoint2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAPoint2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAPoint2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAString
//

class CDAStringFactory;

class ATL_NO_VTABLE CDAString:
    public CBvrBase < IDAString,
                      &IID_IDAString>,
    public CComCoClass<CDAString, &CLSID_DAString>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAString);

    DECLARE_CLASSFACTORY_EX(CDAStringFactory);
    
    DECLARE_REGISTRY(CLSID_DAString,
                     LIBID ".DAString.1",
                     LIBID ".DAString",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAString)
        COM_INTERFACE_ENTRY(IDAString)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAString)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRSTRING_TYPEID ; }
    const char * GetName () { return "DAString" ; }
    STDMETHOD(Extract) (BSTR * ret);
    STDMETHOD(AnimateProperty) (BSTR arg1, BSTR arg2, VARIANT_BOOL arg3, double arg4, IDAString *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAString, &CLSID_DAString>::Error(str, IID_IDAString,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAStringCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAStringFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAVector2
//

class CDAVector2Factory;

class ATL_NO_VTABLE CDAVector2:
    public CBvrBase < IDAVector2,
                      &IID_IDAVector2>,
    public CComCoClass<CDAVector2, &CLSID_DAVector2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAVector2);

    DECLARE_CLASSFACTORY_EX(CDAVector2Factory);
    
    DECLARE_REGISTRY(CLSID_DAVector2,
                     LIBID ".DAVector2.1",
                     LIBID ".DAVector2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAVector2)
        COM_INTERFACE_ENTRY(IDAVector2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAVector2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRVECTOR2_TYPEID ; }
    const char * GetName () { return "DAVector2" ; }
    STDMETHOD(get_Length) (IDANumber *  * ret);
    STDMETHOD(get_LengthSquared) (IDANumber *  * ret);
    STDMETHOD(Normalize) (IDAVector2 *  * ret);
    STDMETHOD(MulAnim) (IDANumber *  arg1, IDAVector2 *  * ret);
    STDMETHOD(Mul) (double arg1, IDAVector2 *  * ret);
    STDMETHOD(DivAnim) (IDANumber *  arg1, IDAVector2 *  * ret);
    STDMETHOD(Div) (double arg1, IDAVector2 *  * ret);
    STDMETHOD(get_X) (IDANumber *  * ret);
    STDMETHOD(get_Y) (IDANumber *  * ret);
    STDMETHOD(get_PolarCoordAngle) (IDANumber *  * ret);
    STDMETHOD(get_PolarCoordLength) (IDANumber *  * ret);
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAVector2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAVector2, &CLSID_DAVector2>::Error(str, IID_IDAVector2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAVector2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAVector2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DALineStyle
//

class CDALineStyleFactory;

class ATL_NO_VTABLE CDALineStyle:
    public CBvrBase < IDA2LineStyle,
                      &IID_IDA2LineStyle>,
    public CComCoClass<CDALineStyle, &CLSID_DALineStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDALineStyle);

    DECLARE_CLASSFACTORY_EX(CDALineStyleFactory);
    
    DECLARE_REGISTRY(CLSID_DALineStyle,
                     LIBID ".DALineStyle.1",
                     LIBID ".DALineStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDALineStyle)
        COM_INTERFACE_ENTRY(IDALineStyle)
        COM_INTERFACE_ENTRY(IDA2LineStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA2LineStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRLINESTYLE_TYPEID ; }
    const char * GetName () { return "DALineStyle" ; }
    STDMETHOD(End) (IDAEndStyle *  arg0, IDALineStyle *  * ret);
    STDMETHOD(Join) (IDAJoinStyle *  arg0, IDALineStyle *  * ret);
    STDMETHOD(Dash) (IDADashStyle *  arg0, IDALineStyle *  * ret);
    STDMETHOD(WidthAnim) (IDANumber *  arg0, IDALineStyle *  * ret);
    STDMETHOD(width) (double arg0, IDALineStyle *  * ret);
    STDMETHOD(AntiAliasing) (double arg0, IDALineStyle *  * ret);
    STDMETHOD(Detail) (IDALineStyle *  * ret);
    STDMETHOD(Color) (IDAColor *  arg0, IDALineStyle *  * ret);
    STDMETHOD(DashStyle) (DWORD arg1, IDALineStyle *  * ret);
    STDMETHOD(MiterLimit) (double arg1, IDALineStyle *  * ret);
    STDMETHOD(MiterLimitAnim) (IDANumber *  arg1, IDALineStyle *  * ret);
    STDMETHOD(JoinStyle) (DWORD arg1, IDALineStyle *  * ret);
    STDMETHOD(EndStyle) (DWORD arg1, IDALineStyle *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDALineStyle, &CLSID_DALineStyle>::Error(str, IID_IDA2LineStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDALineStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDALineStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DADashStyle
//

class CDADashStyleFactory;

class ATL_NO_VTABLE CDADashStyle:
    public CBvrBase < IDADashStyle,
                      &IID_IDADashStyle>,
    public CComCoClass<CDADashStyle, &CLSID_DADashStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDADashStyle);

    DECLARE_CLASSFACTORY_EX(CDADashStyleFactory);
    
    DECLARE_REGISTRY(CLSID_DADashStyle,
                     LIBID ".DADashStyle.1",
                     LIBID ".DADashStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDADashStyle)
        COM_INTERFACE_ENTRY(IDADashStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDADashStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRDASHSTYLE_TYPEID ; }
    const char * GetName () { return "DADashStyle" ; }


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDADashStyle, &CLSID_DADashStyle>::Error(str, IID_IDADashStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDADashStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDADashStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAPair
//

class CDAPairFactory;

class ATL_NO_VTABLE CDAPair:
    public CBvrBase < IDAPair,
                      &IID_IDAPair>,
    public CComCoClass<CDAPair, &CLSID_DAPair>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAPair);

    DECLARE_CLASSFACTORY_EX(CDAPairFactory);
    
    DECLARE_REGISTRY(CLSID_DAPair,
                     LIBID ".DAPair.1",
                     LIBID ".DAPair",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAPair)
        COM_INTERFACE_ENTRY(IDAPair)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAPair)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRPAIR_TYPEID ; }
    const char * GetName () { return "DAPair" ; }
    STDMETHOD(get_First) (IDABehavior *  * ret);
    STDMETHOD(get_Second) (IDABehavior *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAPair, &CLSID_DAPair>::Error(str, IID_IDAPair,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAPairCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAPairFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DATuple
//

class CDATupleFactory;

class ATL_NO_VTABLE CDATuple:
    public CBvrBase < IDATuple,
                      &IID_IDATuple>,
    public CComCoClass<CDATuple, &CLSID_DATuple>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDATuple);

    DECLARE_CLASSFACTORY_EX(CDATupleFactory);
    
    DECLARE_REGISTRY(CLSID_DATuple,
                     LIBID ".DATuple.1",
                     LIBID ".DATuple",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDATuple)
        COM_INTERFACE_ENTRY(IDATuple)

        COM_INTERFACE_ENTRY2(IDABehavior,IDATuple)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRTUPLE_TYPEID ; }
    const char * GetName () { return "DATuple" ; }
    STDMETHOD(Nth) (long arg1, IDABehavior *  * ret);
    STDMETHOD(get_Length) (long * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDATuple, &CLSID_DATuple>::Error(str, IID_IDATuple,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDATupleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDATupleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\propanim.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Animation of ActiveX control properties.

*******************************************************************************/


#include "headers.h"

#include <mshtml.h>
#include "statics.h"
#include "propanim.h"
#include "cview.h"
#include "comcb.h"

// Caller responsible for deallocating.
static char *
ConvertWideToAnsi(LPCWSTR wideStr)
{
    int len = lstrlenW(wideStr) + 1;
    char *ansiStr = new char[len * 2];
    
    if (ansiStr) {
        WideCharToMultiByte(CP_ACP, 0,
                            wideStr, -1,
                            ansiStr, len * 2,
                            NULL, NULL);
    }

    return ansiStr;
}

// TODO: Pull up into a utility library
static BSTR
makeBSTR(LPSTR ansiStr)
{

#ifdef _UNICODE
    return SysAllocString(ansiStr);
#else
    USES_CONVERSION;
    return SysAllocString(A2W(ansiStr));
#endif    
}

static void
StringFromDouble(double d, char *str, bool showFraction)
{
    if (showFraction) {
        // wsprintf doesn't support printing floating point numbers,
        // so we construct a floating point representation explicitly
        // here.
        char *sign = (d < 0) ? "-" : "";
        if (d < 0) d = -d;
    
        int integerPortion = (int)d;

        // up to 4 decimal places
        int fractionalPortion = (int)((d - integerPortion) * 10000); 

        wsprintf(str, "%s%d.%.4d", sign, integerPortion,
                 fractionalPortion);
    } else {
        wsprintf(str, "%d", (int)d);
    }
    
}

// TODO: This should really use the raw layer and not do all this
// extra COM junk

#define NULL_IF_FAILED(exp) if (FAILED(hr = exp)) return NULL;
#define HR_IF_FAILED(exp) if (FAILED(hr = exp)) return hr;
    
#define MAX_SCRIPT_LEN 512
    
class CPropAnimHook : public IDABvrHook
{
  public:

    typedef enum { POINT, STRING, NUMBER, COLOR } BehaviorType;
    typedef enum { VBSCRIPT, JSCRIPT, OTHER } ScriptingLanguageType;
    
    CPropAnimHook(LPWSTR propertyPath,
                  LPWSTR scriptingLanguage,
                  VARIANT_BOOL invokeAsMethod,
                  double minUpdateInterval,
                  BehaviorType bvrType,
                  bool convertToPixel) 
        {

        _propertyPath              = ConvertWideToAnsi(propertyPath);
        _scriptingLanguageStr      = ConvertWideToAnsi(scriptingLanguage);
        _convertToPixel            = convertToPixel;
        
        if (lstrcmp(_scriptingLanguageStr, "VBScript") == 0) {
            _scriptingLanguage = VBSCRIPT;
        } else if (lstrcmp(_scriptingLanguageStr, "JScript") == 0) {
            _scriptingLanguage = JSCRIPT;
        } else {
            _scriptingLanguage = OTHER;
        }


        _cRef              = 1;
        _invokeAsMethod    = invokeAsMethod;
        _minUpdateInterval = minUpdateInterval;
        _bvrType           = bvrType;
        _lastInvocation    = 0.0;
        _firstTimeVtblSetting = true;

        _scriptStrings[0] = _firstScriptString;
        _scriptStrings[1] = _secondScriptString;
    }

    ~CPropAnimHook() {
        delete [] _propertyPath;
        delete [] _scriptingLanguageStr;
    }

    // IUnknown methods
    STDMETHODIMP_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    STDMETHODIMP_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    STDMETHODIMP QueryInterface (REFIID riid, void **ppv) {
        if ( !ppv )
            return E_POINTER;

        *ppv = NULL;
        if (InlineIsEqualGUID(riid,IID_IUnknown)) {
            *ppv = (void *)(IUnknown *)this;
        } else if (InlineIsEqualGUID(riid,IID_IDABvrHook)) {
            *ppv = (void *)(IDABvrHook *)this;
        } else {
            return E_NOINTERFACE;
        }

        AddRef();
        return S_OK;
    }


    // IDABvrHook methods
    STDMETHODIMP Notify(LONG id,
                        VARIANT_BOOL start,
                        double startTime,
                        double gTime,
                        double lTime,
                        IDABehavior * sampleVal,
                        IDABehavior * curRunningBvr,
                        IDABehavior ** ppBvr) {

        // Just continue on with the currently sample.
        *ppBvr = NULL;

        // Not interested in bvr starting notifies
        if (!start) {

            HRESULT hr = S_OK;

            // TODO: Build up a map to allow disambiguation of
            // multiple performances of this behavior.  Otherwise,
            // we'll get the separate performances firing off each
            // others events and not interpreting the updateInterval
            // value correctly.
            
            // First determine whether we should cause an invocation
            // this time.  Second part of this will handle wraparound
            // of the timer appropriately.  That is, if the global
            // time is ever less then the time of the last invocation,
            // then we've wrapped around.
            if (gTime > _lastInvocation + _minUpdateInterval ||
                gTime < _lastInvocation) {

                _lastInvocation = gTime;

                // Check for fast path to vtbl bind to the style of an
                // element.  TODO: We should be able to do this on
                // number and string properties too.
                if (!_invokeAsMethod && _bvrType == POINT) {
                    hr = VtblBindPointProperty(sampleVal);
                } else {
                    hr = E_FAIL; // just for the logic below
                }

                // If we made it through the above successfully,
                // we're all set.  Otherwise, go through
                // script.
                if (FAILED(hr)) {

                    // Will never be more than 2 script strings (point
                    // requires two).
                    int numScriptStrings;
                    switch (_bvrType) {
                      case POINT:
                        numScriptStrings = BuildUpPointScript(sampleVal);
                        break;

                      case STRING:
                        numScriptStrings = BuildUpStringScript(sampleVal);
                        break;

                      case NUMBER:
                        numScriptStrings = BuildUpNumberScript(sampleVal);
                        break;

                      case COLOR:
                        numScriptStrings = BuildUpColorScript(sampleVal);
                        break;
                    }

                    if (numScriptStrings == 0) {
                        Assert(FALSE && "Couldn't construct script string");
                        return E_FAIL;
                    }

                    for (int i = 0; i < numScriptStrings; i++) {
                    
                        TraceTag((tagCOMCallback,
                                  "About to invoke scripting string: %s",
                                  _scriptStrings[i]));

                        BSTR bstrScriptString = makeBSTR(_scriptStrings[i]);
                        BSTR scriptingLanguageBSTR = makeBSTR(_scriptingLanguageStr);
                                              
                        CComVariant retval;
                        hr = CallScriptOnPage(bstrScriptString,
                                              scriptingLanguageBSTR,
                                              &retval);

                        SysFreeString(bstrScriptString);
                        SysFreeString(scriptingLanguageBSTR);

                    }

                }
                
            }

            return hr;
        }

        return S_OK;
    }


  protected:

    HRESULT yankCoords(IDABehavior *sampleVal,
                       double *xVal,
                       double *yVal) {

        HRESULT hr;
        
        CComPtr<IDAPoint2> ptBvr;
        CComPtr<IDANumber> ptXBvr;
        CComPtr<IDANumber> ptYBvr;
        
        HR_IF_FAILED(sampleVal->QueryInterface(IID_IDAPoint2,
                                               (void **)&ptBvr));

        HR_IF_FAILED(ptBvr->get_X(&ptXBvr));
        HR_IF_FAILED(ptBvr->get_Y(&ptYBvr));

        HR_IF_FAILED(ptXBvr->Extract(xVal));
        HR_IF_FAILED(ptYBvr->Extract(yVal));

        return hr;
    }

    HRESULT VtblBindPointProperty(IDABehavior *sampleVal) {
        
        HRESULT hr;

        // TODO: We used to cache all through the grabbing of the
        // style, and do this only once.  However, there is a bug
        // (reflected in bug 9084 in our raid db) that was caused by
        // this IDABvrHook being GC'd after the client site was set to
        // NULL.  This was causing our cached style to be released
        // after it was invalid, causing a fault.  Thus, for now, we
        // don't cache.  Should reintroduce caching with a check to
        // avoid this after the client site is set back to null.
        
        // First time through, build up and cache the
        // IHTMLStyle for the specified property.

        DAComPtr<IServiceProvider> sp;
        CComPtr<IHTMLWindow2> htmlWindow;
        CComPtr<IHTMLDocument2> htmlDoc;
        CComPtr<IHTMLElementCollection> allElements;
        CComPtr<IHTMLStyle> style;

        // Grab the collection of all elements on the page
        if (!GetCurrentServiceProvider(&sp) || !sp)
            return E_FAIL;

        HR_IF_FAILED(sp->QueryService(SID_SHTMLWindow,
                                      IID_IHTMLWindow2,
                                      (void **) &htmlWindow));
        HR_IF_FAILED(htmlWindow->get_document(&htmlDoc));
        HR_IF_FAILED(htmlDoc->get_all(&allElements));
                        
        VARIANT varName;
        varName.vt = VT_BSTR;
        varName.bstrVal = makeBSTR(_propertyPath);
        VARIANT varIndex;
        VariantInit( &varIndex );
        CComPtr<IDispatch>    disp;
        CComPtr<IHTMLElement> element;

        // Find the named item we're looking for,
        // and grab its' style.
        if (FAILED(hr = allElements->item(varName, varIndex,
                                          &disp)) ||
                
            // There's a Trident bug (43078) that has the item()
            // method called above returning S_OK even if it
            // doesn't find the item.  Therefore, check for this
            // case explicitly. 
            (disp.p == NULL)) {
                
            ::SysFreeString(varName.bstrVal);
            return hr;
                
        }

        ::SysFreeString(varName.bstrVal);
                
        HR_IF_FAILED(disp->QueryInterface(IID_IHTMLElement,
                                          (void **)&element));
                
        HR_IF_FAILED(element->get_style(&style));

        // This is where the stuff separate from the
        // cache comes in.
        double xVal, yVal;
        HR_IF_FAILED(yankCoords(sampleVal, &xVal, &yVal));

        if (_convertToPixel) {
            // Convert the x and y values, which are coming in
            // interpreted as meters, into pixel values.  Also invert
            // y, since pixel mode y is positive down.
            // Could cache this value, but it's so cheap, there's no
            // need to.
            xVal = NumToPixel(xVal);
            yVal = NumToPixelY(yVal);
        }

        // Do the x coordinate
        long newVal = (long)xVal;
        long oldVal;
        HR_IF_FAILED(style->get_pixelLeft(&oldVal));

        // Note that Trident has this weird behavior of reporting a
        // position of 0 for the initial position even when that's not
        // where it is.  Work around this by forcing the setting on
        // the first time through.
        if (newVal != oldVal || _firstTimeVtblSetting) {
            HR_IF_FAILED(style->put_pixelLeft(newVal));
        }


        // Do the y coordinate
        newVal = (long)yVal;
        HR_IF_FAILED(style->get_pixelTop(&oldVal));

        if (newVal != oldVal || _firstTimeVtblSetting) {
            HR_IF_FAILED(style->put_pixelTop(newVal));
        }

        _firstTimeVtblSetting = false;

        return hr;
                    
    }
        
    
    int BuildUpPointScript(IDABehavior *sampleVal) {
        HRESULT hr;
        double             xValue;
        double             yValue;
        char               xString[25];
        char               yString[25];

        hr = yankCoords(sampleVal, &xValue, &yValue);
        if (FAILED(hr)) {
            return 0;
        }

        // Don't want fractions on this, since it is always position. 
        StringFromDouble(xValue, xString, false);
        StringFromDouble(yValue, yString, false);

        if (_invokeAsMethod) {

            // Include fudge factor for additional characters.
            int scriptLen = lstrlen(_propertyPath) +
                            lstrlen(xString) + lstrlen(yString) + 25;

            if (scriptLen > MAX_SCRIPT_LEN) {
                RaiseException_UserError(E_INVALIDARG,
                                   IDS_ERR_SRV_SCRIPT_STRING_TOO_LONG,
                                   scriptLen);
            }
                
            // If invoking as a method, we'll just form the string
            // according to the proper language.
            switch (_scriptingLanguage) {
              case VBSCRIPT:
                wsprintf(_scriptStrings[0], "%s %s, %s",
                         _propertyPath, xString, yString);
                break;

              case JSCRIPT:
                wsprintf(_scriptStrings[0], "%s(%s, %s);",
                         _propertyPath, xString, yString);
                break;

              case OTHER:
                RaiseException_UserError(E_FAIL, IDS_ERR_SRV_BAD_SCRIPTING_LANG);
                break;
            }

            return 1;
            
        } else {

            // include fudge factor for additional characters
            int scriptLen =
                lstrlen(_propertyPath) + lstrlen(xString) + 25;
            
            if (scriptLen > MAX_SCRIPT_LEN) {
                RaiseException_UserError(E_INVALIDARG,
                                   IDS_ERR_SRV_SCRIPT_STRING_TOO_LONG,
                                   scriptLen);
            }
                
            wsprintf(_scriptStrings[0], "%s.style.left = %s%s",
                     _propertyPath, xString,
                     (_scriptingLanguage == JSCRIPT) ? ";" : "");

            wsprintf(_scriptStrings[1], "%s.style.top = %s%s",
                     _propertyPath, yString,
                     (_scriptingLanguage == JSCRIPT) ? ";" : "");

            return 2;
        }
                
    }
    
    int BuildUpStringScript(IDABehavior *sampleVal) {
        HRESULT hr;
        CComPtr<IDAString> strBvr;

        NULL_IF_FAILED(sampleVal->QueryInterface(IID_IDAString,
                                                 (void **)&strBvr));
        
        BSTR extractedStringBSTR;
        NULL_IF_FAILED(strBvr->Extract(&extractedStringBSTR));

        // Don't worry about deleting the result of extract, only
        // valid for this call.

        USES_CONVERSION;
        ConstructSinglePropertyString(W2A(extractedStringBSTR), true, false);

        ::SysFreeString(extractedStringBSTR);

        return 1;
    }

    int BuildUpNumberScript(IDABehavior *sampleVal) {
        HRESULT hr;
        CComPtr<IDANumber> numBvr;

        NULL_IF_FAILED(sampleVal->QueryInterface(IID_IDANumber,
                                                 (void **)&numBvr));
        
        double extractedNumber;
        NULL_IF_FAILED(numBvr->Extract(&extractedNumber));

        char numberString[25];
        StringFromDouble(extractedNumber, numberString, true);

        ConstructSinglePropertyString(numberString, false, false);

        return 1;
    }

    
    int BuildUpColorScript(IDABehavior *sampleVal) {
        HRESULT hr;
        CComPtr<IDAColor> colBvr;

        NULL_IF_FAILED(sampleVal->QueryInterface(IID_IDAColor,
                                                 (void **)&colBvr));
        
        CComPtr<IDANumber> rBvr;
        CComPtr<IDANumber> gBvr;
        CComPtr<IDANumber> bBvr;
        colBvr->get_Red(&rBvr);
        colBvr->get_Green(&gBvr);
        colBvr->get_Blue(&bBvr);
        
        double redNumber;
        double greenNumber;
        double blueNumber;

        NULL_IF_FAILED(rBvr->Extract(&redNumber));
        NULL_IF_FAILED(gBvr->Extract(&greenNumber));
        NULL_IF_FAILED(bBvr->Extract(&blueNumber));
        
        char buf[256];
        ZeroMemory(buf,sizeof(buf));
        wsprintf(buf,"\"#%02x%02x%02x\"",(int)(redNumber*255), (int)(greenNumber*255),(int)(blueNumber*255));

        // Don't worry about deleting the result of extract, only
        // valid for this call.

        ConstructSinglePropertyString(buf, false, true);

        return 1;
    }
    
    void
    ConstructSinglePropertyString(char *propertyValueString, bool insertQuotes, bool setColor) {

        // include fudge factor for additional characters
        int scriptLen =
            lstrlen(_propertyPath) + lstrlen(propertyValueString) + 25;
            
        if (scriptLen > MAX_SCRIPT_LEN) {
            RaiseException_UserError(E_INVALIDARG,
                               IDS_ERR_SRV_SCRIPT_STRING_TOO_LONG,
                               scriptLen);
        }

        char *qval;
        if(insertQuotes) 
            qval = "'";
        else
            qval = "";

        if (_invokeAsMethod) {

            // If invoking as a method, we'll just do
            switch (_scriptingLanguage) {
              case VBSCRIPT:
                if(setColor)
                    wsprintf(_scriptStrings[0], "%s = \"%s%s%s\"", _propertyPath, qval, propertyValueString, qval);
                else
                    wsprintf(_scriptStrings[0], "%s %s%s%s", _propertyPath, qval, propertyValueString, qval);
                break;

              case JSCRIPT:
                if(setColor)
                    wsprintf(_scriptStrings[0], "%s = \'%s%s%s\';", _propertyPath, qval, propertyValueString, qval);
                else
                    wsprintf(_scriptStrings[0], "%s(%s%s%s);", _propertyPath, qval, propertyValueString, qval);
              
                break;

              case OTHER:
                RaiseException_UserError(E_FAIL, IDS_ERR_SRV_BAD_SCRIPTING_LANG);
                break;
            }
                
        } else {

            // Setting as a property.  All scripting languages (that
            // we know of) support this syntax.
            wsprintf(_scriptStrings[0], "%s = %s%s%s%s",
                     _propertyPath, qval, propertyValueString, qval,
                     (_scriptingLanguage == JSCRIPT) ? ";" : "");

        }

    }
    
    long                   _cRef;
    char *                 _propertyPath;
    LPSTR                 _scriptingLanguageStr;
    ScriptingLanguageType  _scriptingLanguage;
    VARIANT_BOOL           _invokeAsMethod;
    double                 _minUpdateInterval;
    double                 _lastInvocation;
    BehaviorType           _bvrType;
    bool                   _firstTimeVtblSetting;
    bool                   _convertToPixel;

    char                   _firstScriptString[MAX_SCRIPT_LEN];
    char                   _secondScriptString[MAX_SCRIPT_LEN];
    char                  *_scriptStrings[2];

    // TODO: Reintroduce caching of this ONLY if we yank it after
    // SetClientSite(NULL) occurs.  That is, we can't effectively do a
    // Release on it after that happens.
//    CComPtr<IHTMLStyle>    _style;
};


HRESULT
AnimatePropertyCommonCase(CPropAnimHook::BehaviorType type,
                          IDABehavior *origBvr,
                          BSTR propertyPath,
                          BSTR scriptingLanguage,
                          bool invokeAsMethod,
                          double minUpdateInterval,
                          void **resultTypedBvr,
                          bool convertToPixel)
{
    if (!resultTypedBvr) {
        return E_POINTER;
    }

    *resultTypedBvr = NULL;
    
    // First, build up a behavior hook that will be invoked on every
    // sampling.
    DAComPtr<IDABvrHook> hook(NEW CPropAnimHook(propertyPath,
                                                scriptingLanguage,
                                                invokeAsMethod,
                                                minUpdateInterval,
                                                type,
                                                convertToPixel),
                              false);

    if (!hook) return E_OUTOFMEMORY;
    
    DAComPtr<IDABehavior> newBvr;
    
    // Then let the new behavior be the original bvr hooked.
    HRESULT hr = origBvr->Hook(hook, &newBvr);

    if (SUCCEEDED(hr)) {
        GUID iid;
        switch (type) {
          case CPropAnimHook::NUMBER:
            iid = IID_IDANumber;
            break;

          case CPropAnimHook::STRING:
            iid = IID_IDAString;
            break;
            
          case CPropAnimHook::POINT:
            iid = IID_IDAPoint2;
            break;

          case CPropAnimHook::COLOR:
            iid = IID_IDA2Color;
            break;

          default:
            Assert (!"Invalid type past to AnimatePropertyCommonCase");
        }
        
        hr = newBvr->QueryInterface(iid, resultTypedBvr);
    }

    return hr;
}

HRESULT
Point2AnimateControlPosition(IDAPoint2 *pt,
                             BSTR propertyPath,
                             BSTR scriptingLanguage,
                             bool invokeAsMethod,
                             double minUpdateInterval,
                             IDAPoint2 **newPt,
                             bool convertToPixel)
{
    return AnimatePropertyCommonCase(CPropAnimHook::POINT,
                                     pt,
                                     propertyPath,
                                     scriptingLanguage,
                                     invokeAsMethod,
                                     minUpdateInterval,
                                     (void **) newPt,
                                     convertToPixel);
}


HRESULT
NumberAnimateProperty(IDANumber *num,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDANumber **newNum)
{
    return AnimatePropertyCommonCase(CPropAnimHook::NUMBER,
                                     num,
                                     propertyPath,
                                     scriptingLanguage,
                                     invokeAsMethod,
                                     minUpdateInterval,
                                     (void **) newNum,
                                     false);
}

HRESULT
StringAnimateProperty(IDAString *str,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDAString **newStr)
{
    return AnimatePropertyCommonCase(CPropAnimHook::STRING,
                                     str,
                                     propertyPath,
                                     scriptingLanguage,
                                     invokeAsMethod,
                                     minUpdateInterval,
                                     (void **) newStr,
                                     false);
}

HRESULT
ColorAnimateProperty(IDA2Color *col,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDA2Color **newCol)
{
    return AnimatePropertyCommonCase(CPropAnimHook::COLOR,
                                     col,
                                     propertyPath,
                                     scriptingLanguage,
                                     invokeAsMethod,
                                     minUpdateInterval,
                                     (void **) newCol,
                                     false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\results.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Declaration of Importation and Pickable result interfaces.

*******************************************************************************/


#ifndef _RESULTS_H
#define _RESULTS_H

#include <dxtrans.h>
#include <comconv.h>

class
__declspec(uuid("BCBB1F74-E384-11d0-9B99-00C04FC2F51D")) 
ATL_NO_VTABLE CDAPickableResult
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CDAPickableResult, &__uuidof(CDAPickableResult)>,
      public IDispatchImpl<IDAPickableResult, &IID_IDAPickableResult, &LIBID_DirectAnimation>,
      public IObjectSafetyImpl<CDAPickableResult>,
      public ISupportErrorInfoImpl<&IID_IDAPickableResult>
{
  public:
#if _DEBUG
    const char * GetName() { return "CDAPickableResult"; }
#endif
    BEGIN_COM_MAP(CDAPickableResult)
        COM_INTERFACE_ENTRY(IDAPickableResult)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()
        
    STDMETHOD(get_Image)(IDAImage **ppImg);
    STDMETHOD(get_Geometry)(IDAGeometry **ppGeo);
    STDMETHOD(get_PickEvent)(IDAEvent **ppPickEvent);

    static bool Create(CRPickableResult *res,
                       IDAPickableResult **result);
  protected:
    CRPtr<CRPickableResult> _result;
};



class
__declspec(uuid("BCBB1F75-E384-11d0-9B99-00C04FC2F51D")) 
ATL_NO_VTABLE CDAImportationResult
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CDAImportationResult, &__uuidof(CDAImportationResult)>,
      public IDispatchImpl<IDAImportationResult, &IID_IDAImportationResult, &LIBID_DirectAnimation>,
      public IObjectSafetyImpl<CDAImportationResult>,
      public ISupportErrorInfoImpl<&IID_IDAImportationResult>
{
  public:
#if _DEBUG
    const char * GetName() { return "CDAImportationResult"; }
#endif
    BEGIN_COM_MAP(CDAImportationResult)
        COM_INTERFACE_ENTRY(IDAImportationResult)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()
        
    STDMETHOD(get_Image)(IDAImage **ppImg);
    STDMETHOD(get_Sound)(IDASound **ppSnd);
    STDMETHOD(get_Geometry)(IDAGeometry **ppGeo);
    STDMETHOD(get_Duration)(IDANumber **ppDuration);
    STDMETHOD(get_Progress)(IDANumber **ppProgress);
    STDMETHOD(get_Size)(IDANumber **ppSize);
    STDMETHOD(get_CompletionEvent)(IDAEvent **ppCompletionEvent);

    static HRESULT Create(CRImage             *img,
                          CRSound             *snd,
                          CRGeometry          *geom,
                          CRNumber            *duration,
                          CREvent             *event,
                          CRNumber            *progress,
                          CRNumber            *size,
                          IDAImportationResult **result);

  protected:
    CRPtr<CRBvr>    _image;
    CRPtr<CRBvr>    _sound;
    CRPtr<CRBvr>    _geom;
    CRPtr<CRBvr>    _duration;
    CRPtr<CRBvr>    _progress;
    CRPtr<CRBvr>    _size;
    CRPtr<CRBvr>    _completionEvent;
};



class
__declspec(uuid("5E3BF06E-4B11-11d1-9BC8-00C04FC2F51D"))
ATL_NO_VTABLE CDADXTransformResult
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CDADXTransformResult, &__uuidof(CDADXTransformResult)>,
      public IDispatchImpl<IDADXTransformResult, &IID_IDADXTransformResult, &LIBID_DirectAnimation>,
      public IObjectSafetyImpl<CDADXTransformResult>,
      public ISupportErrorInfoImpl<&IID_IDADXTransformResult>
{
  public:
#if _DEBUG
    const char * GetName() { return "CDADXTransformResult"; }
#endif
    BEGIN_COM_MAP(CDADXTransformResult)
        COM_INTERFACE_ENTRY(IDADXTransformResult)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()
        
    STDMETHOD(get_OutputBvr)(IDABehavior **ppOutputBvr);
    STDMETHOD(get_TheTransform)(IDispatch **ppTransform);

    STDMETHOD(PutBvrAsProperty)(BSTR property,
                                IDABehavior *bvr);

    static HRESULT Create(IDispatch             *theXf,
                          CRDXTransformResultPtr bvr,
                          IDADXTransformResult **ppResult);

    HRESULT Error()
    { return CRGetLastError(); }
  protected:
    CRPtr<CRDXTransformResult>    _xfResult;
    CComPtr<IDispatch>            _theTransform;
};


#endif /* _RESULTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\srvprims.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SRVPRIMS_H
#define _SRVPRIMS_H

#include "engine.h"
#include "cbvr.h"

#pragma warning(disable:4102)  // unreferenced label

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

class CRLockGrabber
{
  public:
    CRLockGrabber() { CRAcquireGCLock(); }
    ~CRLockGrabber() { CRReleaseGCLock(); }
};

#define PRECODE(x) \
    {\
        CRLockGrabber __gclg; \
        x
                                         
#define POSTCODE(b) \
      done: \
        return (b);\
    }

#define PRIMPRECODE(x) PRECODE(x)
#define PRIMPOSTCODE(x) POSTCODE(x)

#define PRIMPRECODE0(b) PRECODE(bool b = false)
#define PRIMPOSTCODE0(b) POSTCODE((b)?S_OK:Error())

#define PRIMPRECODE1(ret) \
    CHECK_RETURN_SET_NULL(ret);\
    PRECODE(0)
              
#define PRIMPOSTCODE1(ret) PRIMPOSTCODE0(*ret)

#define PRIMPRECODE2(ret1,ret2) \
    CHECK_RETURN_SET_NULL(ret1); \
    CHECK_RETURN_SET_NULL(ret2); \
    PRECODE(0)
                                                                
#define PRIMPOSTCODE2(ret1,ret2) PRIMPOSTCODE0(*ret1 && *ret2)

#endif /* _SRVPRIMS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\server.cpp ===
/*******************************************************************************

Copyright (c) 1995 Microsoft Corporation

Abstract:

    Server Implementation

*******************************************************************************/

#include "headers.h"
#include "privinc/registry.h"

// =========================================
// Initialization
// =========================================

extern int gcStat = 1;
extern BOOL jitterStat = TRUE;
extern BOOL heapSizeStat = TRUE;
extern BOOL dxStat = TRUE;
extern int engineOptimization = 0;

double minFrameDuration = 1 / 30.0;  // prefs globals
bool   spritify         = false;     

static void UpdateUserPreferences(PrivatePreferences *prefs,
                                  Bool isInitializationTime)
{
    gcStat             = prefs->_gcStat;
    jitterStat         = prefs->_jitterStat;
    heapSizeStat       = prefs->_heapSizeStat;
    dxStat             = prefs->_dxStat;
    engineOptimization = prefs->_engineOptimization;
    minFrameDuration   = prefs->_minFrameDuration;
    spritify           = (prefs->_spritify==TRUE);

    PERFPRINTF(("Max. FPS = %g", 1.0 / minFrameDuration));
    PERFPRINTF((", GC Stat %s", (gcStat ? "On" : "Off")));
    PERFPRINTF((", Jitter Stat %s", (jitterStat ? "On" : "Off")));
    PERFPRINTF((", DirectX Stat %s", (dxStat ? "On" : "Off")));
    PERFPRINTF((", Optimizations "));
    if (engineOptimization < 2) {
        PERFPRINTF((engineOptimization ? "On" : "Off"));
    } else {
        PERFPRINTF(("%d", engineOptimization));
    }

    PERFPRINTLINE(());
}

void
InitializeModule_Server()
{
    ExtendPreferenceUpdaterList (UpdateUserPreferences);

    // Preferences won't be updated until a view is constructed, so
    // explicitly grab the key preferences that we need to have before
    // the view is in place.
    IntRegistryEntry engineOptimizationEntry("Engine",
                                             PREF_ENGINE_OPTIMIZATIONS_ON,
                                             1); 
    engineOptimization = engineOptimizationEntry.GetValue();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\statics2.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Second file with methods on statics

*******************************************************************************/


#include "headers.h"
#include "srvprims.h"
#include "results.h"
#include "comcb.h"
#include "statics.h"
#include "context.h"
#include <DXTrans.h>
#include "privinc/util.h"
#include "privinc/geomi.h"

STDMETHODIMP
CDAStatics::ImportGeometryWrapped(
    LPOLESTR url,
    LONG wrapType,
    double originX,
    double originY,
    double originZ,
    double zAxisX,
    double zAxisY,
    double zAxisZ,
    double yAxisX,
    double yAxisY,
    double yAxisZ,
    double texOriginX,
    double texOriginY,
    double texScaleX,
    double texScaleY,
    DWORD flags,
    IDAGeometry **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportGeometryWrapped(%lx)", this));

    PRIMPRECODE1(bvr);

    CRGeometryPtr geo;
    DAComPtr<IBindHost> bh(GetBindHost(), false);

    DWORD id;
    id = CRImportGeometryWrapped(GetURLOfClientSite(),
                                 url,
                                 this,
                                 bh,
                                 NULL,
                                 &geo,
                                 NULL,
                                 NULL,
                                 NULL,
                                 wrapType,
                                 originX,
                                 originY,
                                 originZ,
                                 zAxisX,
                                 zAxisY,
                                 zAxisZ,
                                 yAxisX,
                                 yAxisY,
                                 yAxisZ,
                                 texOriginX,
                                 texOriginY,
                                 texScaleX,
                                 texScaleY,
                                 flags);

    if (id)
    {
        CreateCBvr(IID_IDAGeometry, (CRBvrPtr) geo, (void **) bvr);
    }

    PRIMPOSTCODE1(bvr);
}


STDMETHODIMP
CDAStatics::ImportGeometryWrappedAsync(
    LPOLESTR url,
    LONG wrapType,
    double originX,
    double originY,
    double originZ,
    double zAxisX,
    double zAxisY,
    double zAxisZ,
    double yAxisX,
    double yAxisY,
    double yAxisZ,
    double texOriginX,
    double texOriginY,
    double texScaleX,
    double texScaleY,
    DWORD flags,
    IDAGeometry *pGeoStandIn,
    IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportGeometryWrappedAsync(%lx)", this));

    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRGeometryPtr, geostandin, pGeoStandIn);
    CRGeometryPtr pGeometry;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;

    DWORD id;
    id = CRImportGeometryWrapped(GetURLOfClientSite(),
                                 url,
                                 this,
                                 bh,
                                 geostandin,
                                 &pGeometry,
                                 &pEvent,
                                 &pProgress,
                                 &pSize,
                                 wrapType,
                                 originX,
                                 originY,
                                 originZ,
                                 zAxisX,
                                 zAxisY,
                                 zAxisZ,
                                 yAxisX,
                                 yAxisY,
                                 yAxisZ,
                                 texOriginX,
                                 texOriginY,
                                 texScaleX,
                                 texScaleY,
                                 flags);

    if (id)
    {
        CDAImportationResult::Create(NULL,
                                     NULL,
                                     pGeometry,
                                     NULL,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ImportDirect3DRMVisual (
    IUnknown     *visual,
    IDAGeometry **bvr)
{

    TraceTag((tagCOMEntry, "CDAStatics::ImportDirect3DRMVisual(%lx)", this));

    PRIMPRECODE1(bvr) ;

    CHECK_RETURN_NULL(visual);

    CRGeometryPtr geo;

    geo = CRImportDirect3DRMVisual (visual);

    if (geo) {
        CreateCBvr(IID_IDAGeometry,
                   (CRBvrPtr) geo,
                   (void **) bvr) ;
    }

    PRIMPOSTCODE1(bvr) ;
}


STDMETHODIMP
CDAStatics::ImportDirect3DRMVisualWrapped (
    IUnknown *visual,
    LONG wrapType,
    double originX,
    double originY,
    double originZ,
    double zAxisX,
    double zAxisY,
    double zAxisZ,
    double yAxisX,
    double yAxisY,
    double yAxisZ,
    double texOriginX,
    double texOriginY,
    double texScaleX,
    double texScaleY,
    DWORD flags,
    IDAGeometry **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportDirect3DRMVisualWrapped(%lx)", this));

    PRIMPRECODE1(bvr) ;

    CHECK_RETURN_NULL(visual);

    CRGeometryPtr geo;

    geo = CRImportDirect3DRMVisualWrapped (
        visual,
        wrapType,
        originX,
        originY,
        originZ,
        zAxisX,
        zAxisY,
        zAxisZ,
        yAxisX,
        yAxisY,
        yAxisZ,
        texOriginX,
        texOriginY,
        texScaleX,
        texScaleY,
        flags );

    if (geo) {
        CreateCBvr(IID_IDAGeometry,
                   (CRBvrPtr) geo,
                   (void **) bvr) ;
    }

    PRIMPOSTCODE1(bvr) ;
}


void
CreateTransformHelper(IUnknown *theXfAsUnknown,
                      LONG                   numInputs,
                      CRBvrPtr              *inputs,
                      CRBvrPtr               evaluator,
                      IOleClientSite        *clientSite,
                      IDADXTransformResult **ppResult)
{
    HRESULT hr;

    CRDXTransformResultPtr xfResult = CRApplyDXTransform(theXfAsUnknown,
                                                         numInputs,
                                                         inputs,
                                                         evaluator);

    if (xfResult) {

        // Set the bindhost on the transform if it'll accept it.
        DAComPtr<IDXTBindHost> bindHostObj;
        hr = theXfAsUnknown->QueryInterface(IID_IDXTBindHost,
                                            (void **)&bindHostObj);

        if (SUCCEEDED(hr) && clientSite) {

            DAComPtr<IServiceProvider> servProv;
            DAComPtr<IBindHost> bh;
            hr = clientSite->QueryInterface(IID_IServiceProvider,
                                            (void **)&servProv);
            if (SUCCEEDED(hr)) {
                hr = servProv->QueryService(SID_IBindHost,
                                            IID_IBindHost,
                                            (void**)&bh);

                if (SUCCEEDED(hr)) {
                    hr = bindHostObj->SetBindHost(bh);
                    // Harmless if this fails, just carry on.
                }
            }
        }

        DAComPtr<IDispatch> xf;
        hr = theXfAsUnknown->QueryInterface(IID_IDispatch,
                                            (void **)&xf);

        // This NULL-ing should happen automatically, but it doesn't
        // always work this way, so we do it here.
        if (FAILED(hr)) {
            xf.p = NULL;
            hr = S_OK;
        }

        hr = CDADXTransformResult::Create(xf,
                                          xfResult,
                                          ppResult);
    }
}

STDMETHODIMP
CDAStatics::ApplyDXTransformEx(IUnknown *theXfAsUnknown,
                               LONG numInputs,
                               IDABehavior **inputs,
                               IDANumber *evaluator,
                               IDADXTransformResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ApplyDXTransformEx(%lx)", this));

    PRIMPRECODE1(ppResult);

    // Grab client site, but don't do an add'l addref, as
    // GetClientSite() already does one.
    DAComPtr<IOleClientSite> cs(GetClientSite(), false);

    CRBvrPtr *bvrArray = CBvrsToBvrs(numInputs, inputs);
    if (bvrArray == NULL) goto done;

    CRBvrPtr evalBvr;
    if (evaluator) {
        evalBvr = ::GetBvr(evaluator);
        if (evalBvr == NULL) goto done;
    } else {
        evalBvr = NULL;
    }

    CreateTransformHelper(theXfAsUnknown,
                          numInputs,
                          bvrArray,
                          evalBvr,
                          cs,
                          ppResult);

    PRIMPOSTCODE1(ppResult);
}

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

// Grabbed mostly from cbvr.cpp:SafeArrayAccessor::SafeArrayAccessor().
bool
GrabBvrFromVariant(VARIANT v, CRBvrPtr *res)
{
    CRBvrPtr evalBvr = NULL;

    HRESULT hr = S_OK;

    VARIANT *pVar;
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    if (IS_VARTYPE(pVar, VT_EMPTY) ||
        IS_VARTYPE(pVar, VT_NULL)) {

        evalBvr = NULL;

    } else if (IS_VARTYPE(pVar, VT_DISPATCH)) {

        IDispatch *pdisp;

        if (V_ISBYREF(pVar)) {
            pdisp = *V_DISPATCHREF(pVar);
        } else {
            pdisp = V_DISPATCH(pVar);
        }

        DAComPtr<IDANumber> evalNum;
        hr = pdisp->QueryInterface(IID_IDANumber, (void **)&evalNum);

        if (FAILED(hr)) {
            CRSetLastError(E_INVALIDARG, NULL);
        } else {
            evalBvr = ::GetBvr(evalNum);
        }

    } else {

        CRSetLastError(E_INVALIDARG, NULL);
        evalBvr = NULL;
        hr = E_INVALIDARG;

    }

    *res = evalBvr;

    return SUCCEEDED(hr);
}

STDMETHODIMP
CDAStatics::ApplyDXTransform(VARIANT varXf,
                             VARIANT inputs,
                             VARIANT evalVariant,
                             IDADXTransformResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ApplyDXTransform(%lx)", this));
    DAComPtr<IUnknown> punk;

    PRIMPRECODE1(ppResult);
    CComVariant var;
    
    HRESULT hr = var.ChangeType(VT_BSTR, &varXf);
    if (SUCCEEDED(hr))
    {
        CLSID   clsid;

        Assert(var.vt == VT_BSTR);

        // Extract out clsid from string and try to cocreate on it.
        hr  = CLSIDFromString(V_BSTR(&var), &clsid);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CDAStatics::ApplyDXTransform(%lx) - CLSIDFromString() failed", this));
            RaiseException_UserError(hr, IDS_ERR_EXTEND_DXTRANSFORM_CLSID_FAIL);
        }

        // cocreate on clsid
        hr = CoCreateInstance(clsid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IUnknown,
                              (void **)&punk);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CDAStatics::ApplyDXTransform(%lx) - CoCreateInstance() failed", this));
            RaiseException_UserError(hr, IDS_ERR_EXTEND_DXTRANSFORM_FAILED_LOAD, V_BSTR(&var));
        }
    }
    else
    {
        hr = var.ChangeType(VT_UNKNOWN, &varXf);
        if (SUCCEEDED(hr))
        {
            punk = var.punkVal;
        }
        else
        {
            TraceTag((tagError, "CDAStatics::ApplyDXTransform(%lx) - invalidarg", this));
            RaiseException_UserError(E_INVALIDARG, IDS_ERR_INVALIDARG);
        }
    }
    // Use NULL for type info, since this may be a heterogenous list
    SafeArrayAccessor inputSA(inputs, false, CRUNKNOWN_TYPEID, true, true);
    if (!inputSA.IsOK()) return Error();

    CRBvrPtr *inputBvrs = inputSA.ToBvrArray((CRBvrPtr *)_alloca(inputSA.GetNumObjects() * sizeof(CRBvrPtr)));

    if (inputBvrs==NULL)
        return Error();
 
    CRBvrPtr evalBvr;

    if (GrabBvrFromVariant(evalVariant, &evalBvr)) {
        CreateTransformHelper(punk,
                              inputSA.GetNumObjects(),
                              inputBvrs,
                              evalBvr,
                              GetClientSite(),
                              ppResult);
    } else {
        return Error();
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ModifiableNumber(double initVal,
                             IDANumber **ppResult)
{
    PRIMPRECODE1(ppResult);

    CreateCBvr(IID_IDANumber, (CRBvrPtr) CRModifiableNumber(initVal), (void **)ppResult);

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ModifiableString(BSTR initVal,
                             IDAString **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ModifiableString(%lx)", this));

    PRIMPRECODE1(ppResult);

    CreateCBvr(IID_IDAString, (CRBvrPtr) CRModifiableString(initVal), (void **)ppResult);

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::get_ModifiableBehaviorFlags(DWORD * pdwFlags)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ModifiableBehaviorFlags(%lx)", this));

    CHECK_RETURN_NULL(pdwFlags);

    CritSectGrabber csg(_cs);

    *pdwFlags = _dwModBvrFlags;

    return S_OK;
}

STDMETHODIMP
CDAStatics::put_ModifiableBehaviorFlags(DWORD dwFlags)
{
    TraceTag((tagCOMEntry, "CDAStatics::put_ModifiableBehaviorFlags(%lx)", this));

    CritSectGrabber csg(_cs);

    _dwModBvrFlags = dwFlags;

    return S_OK;
}



/*****************************************************************************
The TriMesh parameters are variant arrays, and should be able to accomodate
several types of elements.  'positions' should handle arrays of Point3 or
floating-point triples (either 4-byte or 8-byte floats).  Similarly, 'normals'
should handle arrays of Vector3 or float triples, and UVs should handle arrays
of Point2 or float tuples.
*****************************************************************************/

STDMETHODIMP
CDAStatics::TriMesh (
    int           nTriangles,   // Number of Triangles in Mesh
    VARIANT       positions,    // Array of Vertex Positions
    VARIANT       normals,      // Array of Vertex Normals
    VARIANT       UVs,          // Array of Vertex Surface Coordiantes
    VARIANT       indices,      // Array of Triangle Vertex Indices
    IDAGeometry **result)       // Resultant TriMesh Geometry
{
    TraceTag((tagCOMEntry, "CDAStatics::TriMesh(%lx)", this));

    PRIMPRECODE1 (result);

    bool errorflag = true;
    CRBvr *trimesh = NULL;

    // The TriMeshData object is used to hold all of the information necessary
    // to create the trimesh.

    TriMeshData tm;

    tm.numTris = nTriangles;

    // Extract the trimesh indices array.  This can either be null or an array
    // of 32-bit integers.

    SafeArrayAccessor sa_indices (indices, false, CRNUMBER_TYPEID, true);
    if (!sa_indices.IsOK()) goto cleanup;

    tm.numIndices = static_cast<int> (sa_indices.GetNumObjects());
    tm.indices    = sa_indices.ToIntArray();

    if ((tm.numIndices > 0) && !tm.indices)
    {
        DASetLastError (DISP_E_TYPEMISMATCH, IDS_ERR_GEO_TMESH_BAD_INDICES);
        goto cleanup;
    }

    // Extract the trimesh vertex positions.  These can be a variant array of
    // either floats, doubles, or Point3's.  The SrvArrayBvr() call below will
    // map doubles and floats to an array of floats, or it will return a
    // pointer to an array behavior (of Point3's).

    unsigned int count;   // Number of non-behavior elements returned.
    CRArrayPtr   bvrs;    // Array of Behaviors
    void        *floats;  // Array of Floats

    bvrs = SrvArrayBvr (positions, false, CRPOINT3_TYPEID, 0,
                        ARRAYFILL_FLOAT, &floats, &count);

    tm.vPosFloat = static_cast<float*> (floats);

    Assert (!(bvrs && tm.vPosFloat));   // Expect only one to be non-null.

    if (bvrs)
        tm.numPos = (int) ArrayExtractElements (bvrs, tm.vPosPoint3);
    else if (tm.vPosFloat)
        tm.numPos = (int) count;
    else
        goto cleanup;

    // Extract the vertex normals.  As for positions, this can be a variant
    // array of floats, doubles, or Vector3's.

    bvrs = SrvArrayBvr (normals, false, CRVECTOR3_TYPEID, 0,
                        ARRAYFILL_FLOAT, &floats, &count);

    tm.vNormFloat = static_cast<float*> (floats);

    Assert (! (bvrs && tm.vNormFloat));   // Expect only one to be non-null.

    if (bvrs)
        tm.numNorm = (int) ArrayExtractElements (bvrs, tm.vNormVector3);
    else if (tm.vPosFloat)
        tm.numNorm = (int) count;
    else
        goto cleanup;

    // Extract the vertex surface coordinates.  This variant array can be
    // floats, doubles, or Point2's.

    bvrs = SrvArrayBvr (UVs, false, CRPOINT2_TYPEID, 0,
                        ARRAYFILL_FLOAT, &floats, &count);

    tm.vUVFloat = static_cast<float*> (floats);

    Assert (! (bvrs && tm.vUVFloat));   // Expect only one to be non-null.

    if (bvrs)
        tm.numUV = (int) ArrayExtractElements (bvrs, tm.vUVPoint2);
    else if (tm.vUVFloat)
        tm.numUV = (int) count;
    else
        goto cleanup;

    // Create the resulting trimesh.

    trimesh = CRTriMesh (tm);

    if (trimesh && CreateCBvr(IID_IDAGeometry, trimesh, (void **)result))
        errorflag = false;

  cleanup:

    // All of the scalar arrays passed in were allocated with system memory
    // in the extractions above.  Now that we've created the trimesh we can
    // release the memory here.

    if (tm.vPosFloat)  delete tm.vPosFloat;
    if (tm.vNormFloat) delete tm.vNormFloat;
    if (tm.vUVFloat)   delete tm.vUVFloat;
    if (tm.indices)    delete tm.indices;

    if (errorflag) return Error();

    PRIMPOSTCODE1 (result);
}



STDMETHODIMP
CDAStatics::TriMeshEx (
    int           nTriangles,   // Number of Triangles in Mesh
    int           nPositions,   // Number of Vertex Positions
    float         positions[],  // Array  of Vertex Positions
    int           nNormals,     // Number of Vertex Normals
    float         normals[],    // Array  of Vertex Normals
    int           nUVs,         // Number of Vertex Surface Coordinates
    float         UVs[],        // Array  of Vertex Surface Coordinates
    int           nIndices,     // Number of Triangle Vertex Indices
    int           indices[],    // Array  of Triangle Vertex Indices
    IDAGeometry **result)       // Resultant TriMesh Geometry
{
    TraceTag((tagCOMEntry, "CDAStatics::TriMesh(%lx)", this));

    PRIMPRECODE1 (result);

    TriMeshData tm;

    tm.numTris    = nTriangles;
    tm.numIndices = nIndices;
    tm.indices    = indices;
    tm.numPos     = nPositions;
    tm.vPosFloat  = positions;
    tm.numNorm    = nNormals;
    tm.vNormFloat = normals;
    tm.numUV      = nUVs;
    tm.vUVFloat   = UVs;

    CreateCBvr (IID_IDAGeometry, ::CRTriMesh(tm), (void**)result);

    PRIMPOSTCODE1 (result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\statics.h ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#ifndef _STATICS_H
#define _STATICS_H

#include "engine.h"
#include "cbvr.h"
#include "privinc/comutil.h"
#include "comconv.h"
#include <DXTrans.h>

//+-------------------------------------------------------------------------
//
//  Class:      CDAStatics
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class ATL_NO_VTABLE CDAStaticsFactory : public CComClassFactory {
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

class ATL_NO_VTABLE CDAStatics
    : public CComObjectRootEx<CComMultiThreadModel>,
      public IObjectSafetyImpl<CDAStatics>,
      public CComCoClass<CDAStatics, &CLSID_DAStatics>,
      public IDispatchImpl<IDA3Statics,
                           &IID_IDA3Statics,
                           &LIBID_DirectAnimation>,
      public ISupportErrorInfoImpl<&IID_IDA3Statics>,
      public CRImportSite,
      public CRSite
{
  public:
#if _DEBUG
    const char * GetName() { return "CDAStatics"; }
#endif

    DA_DECLARE_NOT_AGGREGATABLE(CDAStatics);

    ULONG InternalRelease();

    DECLARE_REGISTRY(CLSID_DAStatics,
                     LIBID ".DAStatics.1",
                     LIBID ".DAStatics",
                     0,
                     THREADFLAGS_BOTH);

    DECLARE_CLASSFACTORY_EX(CDAStaticsFactory);

    BEGIN_COM_MAP(CDAStatics)
        COM_INTERFACE_ENTRY(IDA3Statics)
        COM_INTERFACE_ENTRY(IDA2Statics)
        COM_INTERFACE_ENTRY(IDAStatics)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()

    // IDAStatics methods
    STDMETHOD(get_VersionString)(BSTR * stringOut);
    STDMETHOD(put_Site)(IDASite * pSite);
    STDMETHOD(get_Site)(IDASite ** pSite);
    STDMETHOD(put_ClientSite)(IOleClientSite * pClientSite);
    STDMETHOD(get_ClientSite)(IOleClientSite ** pClientSite);
    STDMETHOD(put_PixelConstructionMode)(VARIANT_BOOL bMode);
    STDMETHOD(get_PixelConstructionMode)(VARIANT_BOOL * bMode);

    // IDAStatics methods not automatically generated

    STDMETHOD(TriggerEvent)(IDAEvent *event,
                            IDABehavior *data);

    STDMETHOD(NewDrawingSurface)(IDADrawingSurface **pds);

    // Importation
    STDMETHOD(ImportMovie)(LPOLESTR url,
                           IDAImportationResult **ppResult)
        { return(DoImportMovie(url, ppResult, false)); }

    STDMETHOD(ImportMovieStream)(LPOLESTR url,
                           IDAImportationResult **ppResult)
        { return(DoImportMovie(url, ppResult, true)); }

    STDMETHOD(ImportMovieAsync)(LPOLESTR url,
                                IDAImage   *pImageStandIn,
                                IDASound   *pSoundStandIn,
                                IDAImportationResult **ppResult);

    STDMETHOD(ImportImage)(LPOLESTR url,
                           IDAImage **ppImage);

    STDMETHOD(ImportImageAsync)(LPOLESTR url,
                                IDAImage *pImageStandIn,
                                IDAImportationResult **ppResult);

    STDMETHOD(ImportImageColorKey)(LPOLESTR url,
                                   BYTE ckRed,
                                   BYTE ckGreen,
                                   BYTE ckBlue,
                                   IDAImage **ppImage);

    STDMETHOD(ImportImageAsyncColorKey)(LPOLESTR url,
                                        IDAImage *pImageStandIn,
                                        BYTE ckRed,
                                        BYTE ckGreen,
                                        BYTE ckBlue,
                                        IDAImportationResult **ppResult);

    STDMETHOD(ImportSoundStream)(LPOLESTR url,
                           IDAImportationResult **ppResult)
        { return(DoImportMovie(url, ppResult, true)); }

    STDMETHOD(ImportSound)(LPOLESTR url,
                           IDAImportationResult **ppResult)
        { return(DoImportSound(url, ppResult, false)); }

    STDMETHOD(ImportSoundAsync)(LPOLESTR url,
                                IDASound   *pSoundStandIn,
                                IDAImportationResult **ppResult);

    STDMETHOD(ImportGeometry)(LPOLESTR url,
                              IDAGeometry **ppGeometry);

    STDMETHOD(ImportGeometryWrapped)(LPOLESTR url,
                                     LONG wrapType,
                                     double originX,
                                     double originY,
                                     double originZ,
                                     double zAxisX,
                                     double zAxisY,
                                     double zAxisZ,
                                     double yAxisX,
                                     double yAxisY,
                                     double yAxisZ,
                                     double texOriginX,
                                     double texOriginY,
                                     double texScaleX,
                                     double texScaleY,
                                     DWORD flags,
                                     IDAGeometry **ppGeometry);

    STDMETHOD(ImportGeometryAsync)(LPOLESTR url,
                                   IDAGeometry *pGeoStandIn,
                                   IDAImportationResult **ppResult);

    STDMETHOD(ImportGeometryWrappedAsync)(LPOLESTR url,
                                          LONG wrapType,
                                          double originX,
                                          double originY,
                                          double originZ,
                                          double zAxisX,
                                          double zAxisY,
                                          double zAxisZ,
                                          double yAxisX,
                                          double yAxisY,
                                          double yAxisZ,
                                          double texOriginX,
                                          double texOriginY,
                                          double texScaleX,
                                          double texScaleY,
                                          DWORD flags,
                                          IDAGeometry *pGeoStandIn,
                                          IDAImportationResult **ppResult);

    STDMETHOD(ImportDirectDrawSurface)(IUnknown *dds,
                                       IDAEvent *updateEvent,
                                       IDAImage **bvr);

    STDMETHOD(get_AreBlockingImportsComplete)(VARIANT_BOOL *bComplete);

    STDMETHOD(Cond)(IDABoolean *c,
                    IDABehavior *i,
                    IDABehavior *e,
                    IDABehavior **pCondBvr);

    STDMETHOD(DAArrayEx)(long s, IDABehavior *pBvrs[], IDAArray **bvr)
    { return DAArrayEx2(s, pBvrs, 0, bvr); }
    STDMETHOD(DAArray)(VARIANT pBvrs, IDAArray **bvr)
    { return DAArray2(pBvrs, 0, bvr); }
    STDMETHOD(DAArrayEx2)(long s,
                          IDABehavior *pBvrs[],
                          DWORD dwFlags,
                          IDAArray **bvr);
    STDMETHOD(DAArray2)(VARIANT pBvrs,
                        DWORD dwFlags,
                        IDAArray **bvr);
    STDMETHOD(DATupleEx)(long size, IDABehavior *pBvrs[], IDATuple **bvr);
    STDMETHOD(DATuple)(VARIANT pBvrs, IDATuple **bvr);

    STDMETHOD(ModifiableBehavior)(IDABehavior *orig, IDABehavior **bvr);

    STDMETHOD(UninitializedArray)(IDAArray *typeTmp, IDAArray **bvr);

    STDMETHOD(UninitializedTuple)(IDATuple *typeTmp, IDATuple **bvr);

    STDMETHOD(NumberBSplineEx)(int degree,
                               long numKnots,
                               IDANumber *knots[],
                               long numPts,
                               IDANumber *ctrlPts[],
                               long numWts,
                               IDANumber *weights[],
                               IDANumber *evaluator,
                               IDANumber **bvr);
    STDMETHOD(NumberBSpline)(int degree,
                             VARIANT knots,
                             VARIANT ctrlPts,
                             VARIANT weights,
                             IDANumber *evaluator,
                             IDANumber **bvr);

    STDMETHOD(Point2BSplineEx)(int degree,
                               long numKnots,
                               IDANumber *knots[],
                               long numPts,
                               IDAPoint2 *ctrlPts[],
                               long numWts,
                               IDANumber *weights[],
                               IDANumber *evaluator,
                               IDAPoint2 **bvr);
    STDMETHOD(Point2BSpline)(int degree,
                             VARIANT knots,
                             VARIANT ctrlPts,
                             VARIANT weights,
                             IDANumber *evaluator,
                             IDAPoint2 **bvr);

    STDMETHOD(Point3BSplineEx)(int degree,
                               long numKnots,
                               IDANumber *knots[],
                               long numPts,
                               IDAPoint3 *ctrlPts[],
                               long numWts,
                               IDANumber *weights[],
                               IDANumber *evaluator,
                               IDAPoint3 **bvr);
    STDMETHOD(Point3BSpline)(int degree,
                             VARIANT knots,
                             VARIANT ctrlPts,
                             VARIANT weights,
                             IDANumber *evaluator,
                             IDAPoint3 **bvr);

    STDMETHOD(Vector2BSplineEx)(int degree,
                                long numKnots,
                                IDANumber *knots[],
                                long numPts,
                                IDAVector2 *ctrlPts[],
                                long numWts,
                                IDANumber *weights[],
                                IDANumber *evaluator,
                                IDAVector2 **bvr);
    STDMETHOD(Vector2BSpline)(int degree,
                              VARIANT knots,
                              VARIANT ctrlPts,
                              VARIANT weights,
                              IDANumber *evaluator,
                              IDAVector2 **bvr);

    STDMETHOD(Vector3BSplineEx)(int degree,
                                long numKnots,
                                IDANumber *knots[],
                                long numPts,
                                IDAVector3 *ctrlPts[],
                                long numWts,
                                IDANumber *weights[],
                                IDANumber *evaluator,
                                IDAVector3 **bvr);
    STDMETHOD(Vector3BSpline)(int degree,
                              VARIANT knots,
                              VARIANT ctrlPts,
                              VARIANT weights,
                              IDANumber *evaluator,
                              IDAVector3 **bvr);

    STDMETHOD(ImportDirect3DRMVisual)(IUnknown *visual,
                                      IDAGeometry **bvr);

    STDMETHOD(ImportDirect3DRMVisualWrapped)(IUnknown *visual,
                                             LONG wrapType,
                                             double originX,
                                             double originY,
                                             double originZ,
                                             double zAxisX,
                                             double zAxisY,
                                             double zAxisZ,
                                             double yAxisX,
                                             double yAxisY,
                                             double yAxisZ,
                                             double texOriginX,
                                             double texOriginY,
                                             double texScaleX,
                                             double texScaleY,
                                             DWORD flags,
                                             IDAGeometry **bvr);

    STDMETHOD(ApplyDXTransformEx)(IUnknown *theXf,
                                  LONG numInputs,
                                  IDABehavior **inputs,
                                  IDANumber *evaluator,
                                  IDADXTransformResult **ppResult);

    STDMETHOD(ApplyDXTransform)(VARIANT varXf,
                                VARIANT inputs,
                                VARIANT evaluator,
                                IDADXTransformResult **ppResult);

    STDMETHOD(ModifiableNumber)(double initVal,
                                IDANumber **ppResult);
    STDMETHOD(ModifiableString)(BSTR initVal,
                                IDAString **ppResult);

    STDMETHOD(get_ModifiableBehaviorFlags)(DWORD * pdwFlags);
    STDMETHOD(put_ModifiableBehaviorFlags)(DWORD dwFlags);

    STDMETHOD(Pow) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Abs) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Sqrt) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Floor) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Round) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Ceiling) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Asin) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Acos) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Atan) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Sin) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Cos) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Tan) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Exp) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Ln) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Log10) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(ToDegrees) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(ToRadians) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Mod) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Atan2) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Add) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Sub) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Mul) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Div) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(LT) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(LTE) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(GT) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(GTE) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(EQ) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(NE) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(Neg) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(InterpolateAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  * ret);
    STDMETHOD(Interpolate) (double arg0, double arg1, double arg2, IDANumber *  * ret);
    STDMETHOD(SlowInSlowOutAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDANumber *  * ret);
    STDMETHOD(SlowInSlowOut) (double arg0, double arg1, double arg2, double arg3, IDANumber *  * ret);
    STDMETHOD(SoundSource) (IDASound *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Mix) (IDASound *  arg0, IDASound *  arg1, IDASound *  * ret);
    STDMETHOD(And) (IDABoolean *  arg0, IDABoolean *  arg1, IDABoolean *  * ret);
    STDMETHOD(Or) (IDABoolean *  arg0, IDABoolean *  arg1, IDABoolean *  * ret);
    STDMETHOD(Not) (IDABoolean *  arg0, IDABoolean *  * ret);
    STDMETHOD(Integral) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Derivative) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(IntegralVector2) (IDAVector2 *  arg0, IDAVector2 *  * ret);
    STDMETHOD(IntegralVector3) (IDAVector3 *  arg0, IDAVector3 *  * ret);
    STDMETHOD(DerivativeVector2) (IDAVector2 *  arg0, IDAVector2 *  * ret);
    STDMETHOD(DerivativeVector3) (IDAVector3 *  arg0, IDAVector3 *  * ret);
    STDMETHOD(DerivativePoint2) (IDAPoint2 *  arg0, IDAVector2 *  * ret);
    STDMETHOD(DerivativePoint3) (IDAPoint3 *  arg0, IDAVector3 *  * ret);
    STDMETHOD(KeyState) (IDANumber *  arg0, IDABoolean *  * ret);
    STDMETHOD(KeyUp) (LONG arg0, IDAEvent *  * ret);
    STDMETHOD(KeyDown) (LONG arg0, IDAEvent *  * ret);
    STDMETHOD(DANumber) (double arg0, IDANumber *  * ret);
    STDMETHOD(DAString) (BSTR arg0, IDAString *  * ret);
    STDMETHOD(DABoolean) (VARIANT_BOOL arg0, IDABoolean *  * ret);
    STDMETHOD(SeededRandom) (double arg0, IDANumber *  * ret);
    STDMETHOD(get_MousePosition) (IDAPoint2 *  * ret);
    STDMETHOD(get_LeftButtonState) (IDABoolean *  * ret);
    STDMETHOD(get_RightButtonState) (IDABoolean *  * ret);
    STDMETHOD(get_DATrue) (IDABoolean *  * ret);
    STDMETHOD(get_DAFalse) (IDABoolean *  * ret);
    STDMETHOD(get_LocalTime) (IDANumber *  * ret);
    STDMETHOD(get_GlobalTime) (IDANumber *  * ret);
    STDMETHOD(get_Pixel) (IDANumber *  * ret);
    STDMETHOD(UserData) (IUnknown * arg0, IDAUserData *  * ret);
    STDMETHOD(UntilNotify) (IDABehavior *  arg0, IDAEvent *  arg1, IDAUntilNotifier * arg2, IDABehavior *  * ret);
    STDMETHOD(Until) (IDABehavior *  arg0, IDAEvent *  arg1, IDABehavior *  arg2, IDABehavior *  * ret);
    STDMETHOD(UntilEx) (IDABehavior *  arg0, IDAEvent *  arg1, IDABehavior *  * ret);
    STDMETHOD(Sequence) (IDABehavior *  arg0, IDABehavior *  arg1, IDABehavior *  * ret);
    STDMETHOD(SequenceArrayEx) (long sizearg0, IDABehavior *  arg0[], IDABehavior *  * ret);
    STDMETHOD(SequenceArray) (VARIANT arg0, IDABehavior *  * ret);
    STDMETHOD(FollowPath) (IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngle) (IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleUpright) (IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathEval) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleEval) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleUprightEval) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAnim) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleAnim) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleUprightAnim) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(UntilNotifyScript) (IDABehavior *  arg0, IDAEvent *  arg1, BSTR arg2, IDABehavior *  * ret);
    STDMETHOD(ConcatString) (IDAString *  arg0, IDAString *  arg1, IDAString *  * ret);
    STDMETHOD(PerspectiveCamera) (double arg0, double arg1, IDACamera *  * ret);
    STDMETHOD(PerspectiveCameraAnim) (IDANumber *  arg0, IDANumber *  arg1, IDACamera *  * ret);
    STDMETHOD(ParallelCamera) (double arg0, IDACamera *  * ret);
    STDMETHOD(ParallelCameraAnim) (IDANumber *  arg0, IDACamera *  * ret);
    STDMETHOD(ColorRgbAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAColor *  * ret);
    STDMETHOD(ColorRgb) (double arg0, double arg1, double arg2, IDAColor *  * ret);
    STDMETHOD(ColorRgb255) (short arg0, short arg1, short arg2, IDAColor *  * ret);
    STDMETHOD(ColorHsl) (double arg0, double arg1, double arg2, IDAColor *  * ret);
    STDMETHOD(ColorHslAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAColor *  * ret);
    STDMETHOD(get_Red) (IDAColor *  * ret);
    STDMETHOD(get_Green) (IDAColor *  * ret);
    STDMETHOD(get_Blue) (IDAColor *  * ret);
    STDMETHOD(get_Cyan) (IDAColor *  * ret);
    STDMETHOD(get_Magenta) (IDAColor *  * ret);
    STDMETHOD(get_Yellow) (IDAColor *  * ret);
    STDMETHOD(get_Black) (IDAColor *  * ret);
    STDMETHOD(get_White) (IDAColor *  * ret);
    STDMETHOD(get_Aqua) (IDAColor *  * ret);
    STDMETHOD(get_Fuchsia) (IDAColor *  * ret);
    STDMETHOD(get_Gray) (IDAColor *  * ret);
    STDMETHOD(get_Lime) (IDAColor *  * ret);
    STDMETHOD(get_Maroon) (IDAColor *  * ret);
    STDMETHOD(get_Navy) (IDAColor *  * ret);
    STDMETHOD(get_Olive) (IDAColor *  * ret);
    STDMETHOD(get_Purple) (IDAColor *  * ret);
    STDMETHOD(get_Silver) (IDAColor *  * ret);
    STDMETHOD(get_Teal) (IDAColor *  * ret);
    STDMETHOD(Predicate) (IDABoolean *  arg0, IDAEvent *  * ret);
    STDMETHOD(NotEvent) (IDAEvent *  arg0, IDAEvent *  * ret);
    STDMETHOD(AndEvent) (IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret);
    STDMETHOD(OrEvent) (IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret);
    STDMETHOD(ThenEvent) (IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret);
    STDMETHOD(get_LeftButtonDown) (IDAEvent *  * ret);
    STDMETHOD(get_LeftButtonUp) (IDAEvent *  * ret);
    STDMETHOD(get_RightButtonDown) (IDAEvent *  * ret);
    STDMETHOD(get_RightButtonUp) (IDAEvent *  * ret);
    STDMETHOD(get_Always) (IDAEvent *  * ret);
    STDMETHOD(get_Never) (IDAEvent *  * ret);
    STDMETHOD(TimerAnim) (IDANumber *  arg0, IDAEvent *  * ret);
    STDMETHOD(Timer) (double arg0, IDAEvent *  * ret);
    STDMETHOD(AppTriggeredEvent) (IDAEvent *  * ret);
    STDMETHOD(ScriptCallback) (BSTR arg0, IDAEvent *  arg1, BSTR arg2, IDAEvent *  * ret);
    STDMETHOD(get_EmptyGeometry) (IDAGeometry *  * ret);
    STDMETHOD(UnionGeometry) (IDAGeometry *  arg0, IDAGeometry *  arg1, IDAGeometry *  * ret);
    STDMETHOD(UnionGeometryArrayEx) (long sizearg0, IDAGeometry *  arg0[], IDAGeometry *  * ret);
    STDMETHOD(UnionGeometryArray) (VARIANT arg0, IDAGeometry *  * ret);
    STDMETHOD(get_EmptyImage) (IDAImage *  * ret);
    STDMETHOD(get_DetectableEmptyImage) (IDAImage *  * ret);
    STDMETHOD(SolidColorImage) (IDAColor *  arg0, IDAImage *  * ret);
    STDMETHOD(GradientPolygonEx) (long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDAColor *  arg1[], IDAImage *  * ret);
    STDMETHOD(GradientPolygon) (VARIANT arg0, VARIANT arg1, IDAImage *  * ret);
    STDMETHOD(RadialGradientPolygonEx) (IDAColor *  arg0, IDAColor *  arg1, long sizearg2, IDAPoint2 *  arg2[], double arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientPolygon) (IDAColor *  arg0, IDAColor *  arg1, VARIANT arg2, double arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientPolygonAnimEx) (IDAColor *  arg0, IDAColor *  arg1, long sizearg2, IDAPoint2 *  arg2[], IDANumber *  arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientPolygonAnim) (IDAColor *  arg0, IDAColor *  arg1, VARIANT arg2, IDANumber *  arg3, IDAImage *  * ret);
    STDMETHOD(GradientSquare) (IDAColor *  arg0, IDAColor *  arg1, IDAColor *  arg2, IDAColor *  arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientSquare) (IDAColor *  arg0, IDAColor *  arg1, double arg2, IDAImage *  * ret);
    STDMETHOD(RadialGradientSquareAnim) (IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDAImage *  * ret);
    STDMETHOD(RadialGradientRegularPoly) (IDAColor *  arg0, IDAColor *  arg1, double arg2, double arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientRegularPolyAnim) (IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAImage *  * ret);
    STDMETHOD(GradientHorizontal) (IDAColor *  arg0, IDAColor *  arg1, double arg2, IDAImage *  * ret);
    STDMETHOD(GradientHorizontalAnim) (IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDAImage *  * ret);
    STDMETHOD(HatchHorizontal) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchHorizontalAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchVertical) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchVerticalAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchForwardDiagonal) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchForwardDiagonalAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchBackwardDiagonal) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchBackwardDiagonalAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchCross) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchCrossAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchDiagonalCross) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchDiagonalCrossAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(Overlay) (IDAImage *  arg0, IDAImage *  arg1, IDAImage *  * ret);
    STDMETHOD(OverlayArrayEx) (long sizearg0, IDAImage *  arg0[], IDAImage *  * ret);
    STDMETHOD(OverlayArray) (VARIANT arg0, IDAImage *  * ret);
    STDMETHOD(get_AmbientLight) (IDAGeometry *  * ret);
    STDMETHOD(get_DirectionalLight) (IDAGeometry *  * ret);
    STDMETHOD(get_PointLight) (IDAGeometry *  * ret);
    STDMETHOD(SpotLightAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAGeometry *  * ret);
    STDMETHOD(SpotLight) (IDANumber *  arg0, double arg1, IDAGeometry *  * ret);
    STDMETHOD(get_DefaultLineStyle) (IDALineStyle *  * ret);
    STDMETHOD(get_EmptyLineStyle) (IDALineStyle *  * ret);
    STDMETHOD(get_JoinStyleBevel) (IDAJoinStyle *  * ret);
    STDMETHOD(get_JoinStyleRound) (IDAJoinStyle *  * ret);
    STDMETHOD(get_JoinStyleMiter) (IDAJoinStyle *  * ret);
    STDMETHOD(get_EndStyleFlat) (IDAEndStyle *  * ret);
    STDMETHOD(get_EndStyleSquare) (IDAEndStyle *  * ret);
    STDMETHOD(get_EndStyleRound) (IDAEndStyle *  * ret);
    STDMETHOD(get_DashStyleSolid) (IDADashStyle *  * ret);
    STDMETHOD(get_DashStyleDashed) (IDADashStyle *  * ret);
    STDMETHOD(get_DefaultMicrophone) (IDAMicrophone *  * ret);
    STDMETHOD(get_OpaqueMatte) (IDAMatte *  * ret);
    STDMETHOD(get_ClearMatte) (IDAMatte *  * ret);
    STDMETHOD(UnionMatte) (IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret);
    STDMETHOD(IntersectMatte) (IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret);
    STDMETHOD(DifferenceMatte) (IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret);
    STDMETHOD(FillMatte) (IDAPath2 *  arg0, IDAMatte *  * ret);
    STDMETHOD(TextMatte) (IDAString *  arg0, IDAFontStyle *  arg1, IDAMatte *  * ret);
    STDMETHOD(get_EmptyMontage) (IDAMontage *  * ret);
    STDMETHOD(ImageMontage) (IDAImage *  arg0, double arg1, IDAMontage *  * ret);
    STDMETHOD(ImageMontageAnim) (IDAImage *  arg0, IDANumber *  arg1, IDAMontage *  * ret);
    STDMETHOD(UnionMontage) (IDAMontage *  arg0, IDAMontage *  arg1, IDAMontage *  * ret);
    STDMETHOD(Concat) (IDAPath2 *  arg0, IDAPath2 *  arg1, IDAPath2 *  * ret);
    STDMETHOD(ConcatArrayEx) (long sizearg0, IDAPath2 *  arg0[], IDAPath2 *  * ret);
    STDMETHOD(ConcatArray) (VARIANT arg0, IDAPath2 *  * ret);
    STDMETHOD(Line) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAPath2 *  * ret);
    STDMETHOD(Ray) (IDAPoint2 *  arg0, IDAPath2 *  * ret);
    STDMETHOD(StringPathAnim) (IDAString *  arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret);
    STDMETHOD(StringPath) (BSTR arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret);
    STDMETHOD(PolylineEx) (long sizearg0, IDAPoint2 *  arg0[], IDAPath2 *  * ret);
    STDMETHOD(Polyline) (VARIANT arg0, IDAPath2 *  * ret);
    STDMETHOD(PolydrawPathEx) (long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDANumber *  arg1[], IDAPath2 *  * ret);
    STDMETHOD(PolydrawPath) (VARIANT arg0, VARIANT arg1, IDAPath2 *  * ret);
    STDMETHOD(ArcRadians) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(ArcRadiansAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret);
    STDMETHOD(ArcDegrees) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(PieRadians) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(PieRadiansAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret);
    STDMETHOD(PieDegrees) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(Oval) (double arg0, double arg1, IDAPath2 *  * ret);
    STDMETHOD(OvalAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAPath2 *  * ret);
    STDMETHOD(Rect) (double arg0, double arg1, IDAPath2 *  * ret);
    STDMETHOD(RectAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAPath2 *  * ret);
    STDMETHOD(RoundRect) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(RoundRectAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret);
    STDMETHOD(CubicBSplinePathEx) (long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDANumber *  arg1[], IDAPath2 *  * ret);
    STDMETHOD(CubicBSplinePath) (VARIANT arg0, VARIANT arg1, IDAPath2 *  * ret);
    STDMETHOD(TextPath) (IDAString *  arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret);
    STDMETHOD(get_Silence) (IDASound *  * ret);
    STDMETHOD(MixArrayEx) (long sizearg0, IDASound *  arg0[], IDASound *  * ret);
    STDMETHOD(MixArray) (VARIANT arg0, IDASound *  * ret);
    STDMETHOD(get_SinSynth) (IDASound *  * ret);
    STDMETHOD(get_DefaultFont) (IDAFontStyle *  * ret);
    STDMETHOD(FontAnim) (IDAString *  arg0, IDANumber *  arg1, IDAColor *  arg2, IDAFontStyle *  * ret);
    STDMETHOD(Font) (BSTR arg0, double arg1, IDAColor *  arg2, IDAFontStyle *  * ret);
    STDMETHOD(StringImageAnim) (IDAString *  arg0, IDAFontStyle *  arg1, IDAImage *  * ret);
    STDMETHOD(StringImage) (BSTR arg0, IDAFontStyle *  arg1, IDAImage *  * ret);
    STDMETHOD(TextImageAnim) (IDAString *  arg0, IDAFontStyle *  arg1, IDAImage *  * ret);
    STDMETHOD(TextImage) (BSTR arg0, IDAFontStyle *  arg1, IDAImage *  * ret);
    STDMETHOD(get_XVector2) (IDAVector2 *  * ret);
    STDMETHOD(get_YVector2) (IDAVector2 *  * ret);
    STDMETHOD(get_ZeroVector2) (IDAVector2 *  * ret);
    STDMETHOD(get_Origin2) (IDAPoint2 *  * ret);
    STDMETHOD(Vector2Anim) (IDANumber *  arg0, IDANumber *  arg1, IDAVector2 *  * ret);
    STDMETHOD(Vector2) (double arg0, double arg1, IDAVector2 *  * ret);
    STDMETHOD(Point2Anim) (IDANumber *  arg0, IDANumber *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(Point2) (double arg0, double arg1, IDAPoint2 *  * ret);
    STDMETHOD(Vector2PolarAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAVector2 *  * ret);
    STDMETHOD(Vector2Polar) (double arg0, double arg1, IDAVector2 *  * ret);
    STDMETHOD(Vector2PolarDegrees) (double arg0, double arg1, IDAVector2 *  * ret);
    STDMETHOD(Point2PolarAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(Point2Polar) (double arg0, double arg1, IDAPoint2 *  * ret);
    STDMETHOD(DotVector2) (IDAVector2 *  arg0, IDAVector2 *  arg1, IDANumber *  * ret);
    STDMETHOD(NegVector2) (IDAVector2 *  arg0, IDAVector2 *  * ret);
    STDMETHOD(SubVector2) (IDAVector2 *  arg0, IDAVector2 *  arg1, IDAVector2 *  * ret);
    STDMETHOD(AddVector2) (IDAVector2 *  arg0, IDAVector2 *  arg1, IDAVector2 *  * ret);
    STDMETHOD(AddPoint2Vector) (IDAPoint2 *  arg0, IDAVector2 *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(SubPoint2Vector) (IDAPoint2 *  arg0, IDAVector2 *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(SubPoint2) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAVector2 *  * ret);
    STDMETHOD(DistancePoint2) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDANumber *  * ret);
    STDMETHOD(DistanceSquaredPoint2) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDANumber *  * ret);
    STDMETHOD(get_XVector3) (IDAVector3 *  * ret);
    STDMETHOD(get_YVector3) (IDAVector3 *  * ret);
    STDMETHOD(get_ZVector3) (IDAVector3 *  * ret);
    STDMETHOD(get_ZeroVector3) (IDAVector3 *  * ret);
    STDMETHOD(get_Origin3) (IDAPoint3 *  * ret);
    STDMETHOD(Vector3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAVector3 *  * ret);
    STDMETHOD(Vector3) (double arg0, double arg1, double arg2, IDAVector3 *  * ret);
    STDMETHOD(Point3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAPoint3 *  * ret);
    STDMETHOD(Point3) (double arg0, double arg1, double arg2, IDAPoint3 *  * ret);
    STDMETHOD(Vector3SphericalAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAVector3 *  * ret);
    STDMETHOD(Vector3Spherical) (double arg0, double arg1, double arg2, IDAVector3 *  * ret);
    STDMETHOD(Point3SphericalAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAPoint3 *  * ret);
    STDMETHOD(Point3Spherical) (double arg0, double arg1, double arg2, IDAPoint3 *  * ret);
    STDMETHOD(DotVector3) (IDAVector3 *  arg0, IDAVector3 *  arg1, IDANumber *  * ret);
    STDMETHOD(CrossVector3) (IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret);
    STDMETHOD(NegVector3) (IDAVector3 *  arg0, IDAVector3 *  * ret);
    STDMETHOD(SubVector3) (IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret);
    STDMETHOD(AddVector3) (IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret);
    STDMETHOD(AddPoint3Vector) (IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAPoint3 *  * ret);
    STDMETHOD(SubPoint3Vector) (IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAPoint3 *  * ret);
    STDMETHOD(SubPoint3) (IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDAVector3 *  * ret);
    STDMETHOD(DistancePoint3) (IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDANumber *  * ret);
    STDMETHOD(DistanceSquaredPoint3) (IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDANumber *  * ret);
    STDMETHOD(get_IdentityTransform3) (IDATransform3 *  * ret);
    STDMETHOD(Translate3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDATransform3 *  * ret);
    STDMETHOD(Translate3) (double arg0, double arg1, double arg2, IDATransform3 *  * ret);
    STDMETHOD(Translate3Rate) (double arg0, double arg1, double arg2, IDATransform3 *  * ret);
    STDMETHOD(Translate3Vector) (IDAVector3 *  arg0, IDATransform3 *  * ret);
    STDMETHOD(Translate3Point) (IDAPoint3 *  arg0, IDATransform3 *  * ret);
    STDMETHOD(Scale3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDATransform3 *  * ret);
    STDMETHOD(Scale3) (double arg0, double arg1, double arg2, IDATransform3 *  * ret);
    STDMETHOD(Scale3Rate) (double arg0, double arg1, double arg2, IDATransform3 *  * ret);
    STDMETHOD(Scale3Vector) (IDAVector3 *  arg0, IDATransform3 *  * ret);
    STDMETHOD(Scale3UniformAnim) (IDANumber *  arg0, IDATransform3 *  * ret);
    STDMETHOD(Scale3Uniform) (double arg0, IDATransform3 *  * ret);
    STDMETHOD(Scale3UniformRate) (double arg0, IDATransform3 *  * ret);
    STDMETHOD(Rotate3Anim) (IDAVector3 *  arg0, IDANumber *  arg1, IDATransform3 *  * ret);
    STDMETHOD(Rotate3) (IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(Rotate3Rate) (IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(Rotate3Degrees) (IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(Rotate3RateDegrees) (IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(XShear3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret);
    STDMETHOD(XShear3) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(XShear3Rate) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(YShear3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret);
    STDMETHOD(YShear3) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(YShear3Rate) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(ZShear3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret);
    STDMETHOD(ZShear3) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(ZShear3Rate) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(Transform4x4AnimEx) (long sizearg0, IDANumber *  arg0[], IDATransform3 *  * ret);
    STDMETHOD(Transform4x4Anim) (VARIANT arg0, IDATransform3 *  * ret);
    STDMETHOD(Compose3) (IDATransform3 *  arg0, IDATransform3 *  arg1, IDATransform3 *  * ret);
    STDMETHOD(Compose3ArrayEx) (long sizearg0, IDATransform3 *  arg0[], IDATransform3 *  * ret);
    STDMETHOD(Compose3Array) (VARIANT arg0, IDATransform3 *  * ret);
    STDMETHOD(LookAtFrom) (IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDAVector3 *  arg2, IDATransform3 *  * ret);
    STDMETHOD(get_IdentityTransform2) (IDATransform2 *  * ret);
    STDMETHOD(Translate2Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(Translate2) (double arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(Translate2Rate) (double arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(Translate2Vector) (IDAVector2 *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Translate2Point) (IDAPoint2 *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(Scale2) (double arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(Scale2Rate) (double arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(Scale2Vector2) (IDAVector2 *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2Vector) (IDAVector2 *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2UniformAnim) (IDANumber *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2Uniform) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2UniformRate) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2Anim) (IDANumber *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2Rate) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2Degrees) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2RateDegrees) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(XShear2Anim) (IDANumber *  arg0, IDATransform2 *  * ret);
    STDMETHOD(XShear2) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(XShear2Rate) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(YShear2Anim) (IDANumber *  arg0, IDATransform2 *  * ret);
    STDMETHOD(YShear2) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(YShear2Rate) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Transform3x2AnimEx) (long sizearg0, IDANumber *  arg0[], IDATransform2 *  * ret);
    STDMETHOD(Transform3x2Anim) (VARIANT arg0, IDATransform2 *  * ret);
    STDMETHOD(Compose2) (IDATransform2 *  arg0, IDATransform2 *  arg1, IDATransform2 *  * ret);
    STDMETHOD(Compose2ArrayEx) (long sizearg0, IDATransform2 *  arg0[], IDATransform2 *  * ret);
    STDMETHOD(Compose2Array) (VARIANT arg0, IDATransform2 *  * ret);
    STDMETHOD(get_ViewFrameRate) (IDANumber *  * ret);
    STDMETHOD(get_ViewTimeDelta) (IDANumber *  * ret);
    STDMETHOD(UnionMontageArrayEx) (long sizearg0, IDAMontage *  arg0[], IDAMontage *  * ret);
    STDMETHOD(UnionMontageArray) (VARIANT arg0, IDAMontage *  * ret);
    STDMETHOD(get_EmptyColor) (IDAColor *  * ret);
    STDMETHOD(TriMesh) (int nTriangles, VARIANT positions, VARIANT normals, VARIANT UVs, VARIANT indices, IDAGeometry **ret);
    STDMETHOD(TriMeshEx) (int nTriangles,
                          int nPositions,
                          float positions[],
                          int nNormals,
                          float normals[],
                          int nUVs,
                          float UVs[],
                          int nIndices,
                          int indices[],
                          IDAGeometry **ret);
    STDMETHOD(RadialGradientMulticolor) (VARIANT  offsets,
                                         VARIANT  colors,
                                         IDAImage **result);

    STDMETHOD(RadialGradientMulticolorEx) (
                          int        nOffsets,
                          IDANumber *offsets[],
                          int        nColors,
                          IDAColor  *colors[],
                          IDAImage **result);

    STDMETHOD(LinearGradientMulticolor) (VARIANT  offsets,
                                         VARIANT  colors,
                                         IDAImage **result);

    STDMETHOD(LinearGradientMulticolorEx) (
                          int        nOffsets,
                          IDANumber *offsets[],
                          int        nColors,
                          IDAColor  *colors[],
                          IDAImage **result);

    // OBSOLETED METHODS

    STDMETHOD(Array)(VARIANT pBvrs, IDAArray **bvr)
    { return DAArray(pBvrs, bvr); }

    STDMETHOD(Tuple)(VARIANT pBvrs, IDATuple **bvr)
    { return DATuple(pBvrs, bvr); }

    // END OBSOLETED METHODS

    CDAStatics();
    ~CDAStatics();

    IDASite * GetSite ();
    IOleClientSite * GetClientSite ();
    LPWSTR GetURLOfClientSite();
    IBindHost* GetBindHost ();

    bool GetPixelMode()
    { bool b ; Lock(); b = _bPixelMode; Unlock(); return b; }
    void SetPixelMode(bool b)
    { Lock(); _bPixelMode = b; Unlock(); }

    CRBvrPtr PixelToNumBvr(double d);
//    CRBvrPtr PixelToNumBvr(IDANumber * num);
    CRBvrPtr RatePixelToNumBvr(double d);
    CRBvrPtr PixelToNumBvr(CRBvrPtr b);
    double PixelToNum(double d);

    CRBvrPtr PixelYToNumBvr(double d);
//    CRBvrPtr PixelYToNumBvr(IDANumber * num);
    CRBvrPtr RatePixelYToNumBvr(double d);
    CRBvrPtr PixelYToNumBvr(CRBvrPtr b);
    double PixelYToNum(double d);

    CRSTDAPICB_(void) SetStatusText(LPCWSTR StatusText);
    CRSTDAPICB_(void) ReportError(HRESULT hr, LPCWSTR ErrorText);
    CRSTDAPICB_(void) ReportGC(bool bStarting);

    CRSTDAPICB_(void) SetStatusText(DWORD importId,
                                    LPCWSTR StatusText){}
    CRSTDAPICB_(void) ReportError(DWORD importId,
                                  HRESULT hr,
                                  LPCWSTR ErrorText)
    { ReportError(hr, ErrorText); }

    CRSTDAPICB_(void) OnImportCreate(DWORD importId, bool async)
    { if(!async) AddSyncImportSite(importId); }
    CRSTDAPICB_(void) OnImportStart(DWORD importId) {}
    CRSTDAPICB_(void) OnImportStop(DWORD importId)
    { RemoveSyncImportSite(importId) ; }

    void AddSyncImportSite(DWORD dwId);
    void RemoveSyncImportSite(DWORD dwId);
  protected:
    HRESULT Error();

    // These all increment/decrement the reference counts
    void SetSite (IDASite * pSite);
    void SetClientSite (IOleClientSite * pSite);

    DAComPtr<IDASite>            _pSite;
    DAComPtr<IOleClientSite>     _pOleClientSite;
    DAComPtr<IBindHost>          _pBH;
    LPWSTR                       _clientSiteURL;
    bool                         _bPixelMode;
    CritSect                     _cs;
    list < DWORD >               _importList;
    DWORD                        _dwModBvrFlags;

    HRESULT MakeSplineEx(int degree,
                         long numKnots,
                         IDANumber *knots[],
                         long numPts,
                         IDABehavior *ctrlPoints[],
                         long numWts,
                         IDANumber *weights[],
                         IDANumber *evaluator,
                         CR_BVR_TYPEID tid,
                         REFIID iid,
                         void **bvr);

    HRESULT MakeSpline(int degree,
                       VARIANT knots,
                       VARIANT ctrlPoints,
                       VARIANT weights,
                       IDANumber *evaluator,
                       CR_BVR_TYPEID tid,
                       REFIID iid,
                       void **bvr);
  private:
    HRESULT DoImportSound(LPOLESTR url,
                          IDAImportationResult **ppResult, bool stream);

    HRESULT DoImportMovie(LPOLESTR url,
                          IDAImportationResult **ppResult, bool stream);

};

#endif /* _STATICS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\view.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Viewer interface

*******************************************************************************/


#ifndef _DAVIEW_H
#define _DAVIEW_H

#include "context.h"
#include "eventq.h"
#include "pickq.h"
#include "privinc/imgdev.h"
#include "privinc/soundi.h"
#include "backend/perf.h"
#include "backend/bvr.h"
#include "privinc/drect.h"
#include "privinc/htimer.h"
#include "privinc/privpref.h"
#include "privinc/comutil.h"
#include <dxtrans.h>

class SpriteThread;
class SoundInstanceList;
class PerfTimeXformImpl;

class View : public AxAThrowingAllocatorClass
{
  public:
    View();
    ~View () ;

    void CreateDevices (bool needSoundDevice, bool needImageDevice) ;
    void DestroyDevices () ;
    void SetTargetOnDevices () ;

    void RenderImage(AxAValue v);
    void RenderSound(AxAValue v);

    void DoPicking(AxAValue v, Time time) ;

    bool Sample(Time time, bool paused);
    void RenderImage();
    void RenderSound();

    void Start(Bvr img, Bvr snd, Time startTime);
    void Stop();
    void Pause();
    void Resume();

    DWORD AddBvrToRun(Bvr bvr, bool continueTimeline = false);
    void RemoveRunningBvr(DWORD id);

    void RunBvrs(Time startGlobalTime, TimeXform tt);

    Bvr Snapshot(Bvr bvr, Time t);

    HWND GetWindow ();
    bool SetWindow (HWND hwnd);
    IDirectDrawSurface * GetDDSurf();
    bool SetDDSurf(IDirectDrawSurface *ddsurf, HDC parentDC=NULL);
    HDC GetHDC();
    bool SetHDC(HDC hdc);

    void SetCompositeDirectlyToTarget(bool b) {
        _targetPackage.SetComposeToTarget( b );
        _doTargetUpdate = true;
    }
    
    bool GetCompositeDirectlyToTarget() {
        return _targetPackage.GetComposeToTarget();
    }

    void SetViewport (LONG left, LONG top, LONG right, LONG bottom) {
        RECT r = {left, top, right, bottom};
        _targetPackage.SetRawViewportRect( r );
        _doTargetUpdate = true;
    }

    void SetClipRect (LONG left, LONG top, LONG right, LONG bottom) {
        RECT r = {left, top, right, bottom};
        _targetPackage.SetRawClipRect( r );
        _doTargetUpdate = true;
    }

    void SetInvalid (LONG left, LONG top, LONG right, LONG bottom);
    bool IsStarted () { return _isStarted; }
    bool IsDevInited () { return _devInited ; }
    bool IsWindowless () {
//        Assert(_targetPackage._targetType != target_invalid);
        return _targetPackage.GetTargetType() != target_hwnd ;
    }
    
    bool IsTargetPackageValid() { return(_targetPackage.IsValid()); }

    // This adds an incomplete import to the list of imports needed
    // for the current model to be ready

    void AddIncompleteImport(Bvr b) {
        CritSectGrabber csg(_importCS);

        // If the event is currently set then we need to reset it
        if (_pendingImports.size() == 0)
            _importEvent.Reset();

        _pendingImports.insert(b);
    }

    void RemoveIncompleteImport(Bvr b) {
        CritSectGrabber csg(_importCS);

        _pendingImports.erase(b);

        // If there are no more imports set the event
        if (_pendingImports.size() == 0)
            _importEvent.Signal();
    }

    void ClearImportList() {
        CritSectGrabber csg(_importCS);
        _pendingImports.clear();

        // Set the event since there are no more imports

        _importEvent.Signal();
    }

    bool ImportsPending() {
        CritSectGrabber csg(_importCS);
        return (_pendingImports.size() > 0);
    }

    void WaitForImports() {
        _importEvent.Wait();
    }

    void DisableDirtyRects();

    DirectDrawViewport * GetImageDev () { return _imageDev ; }
    MetaSoundDevice * GetSoundDev () { return _soundDev ; }
    PickQ & GetPickQ () { return _pickq ; }
    EventQ & GetEventQ () { return _eventq ; }
    Time GetLastSampleTime() { return _lastSampleTime; }
    DWORD GetLastSystemTime() { return _lastSystemTime; }
    DWORD GetCurrentSystemTime() { return _currentSystemTime; }
    Time GetLocalTime();
    DynamicHeap & GetSampleHeap () { return *_sampleHeap ; }
    DynamicHeap & GetRBHeap () { return *_rbHeap ; }
    DynamicHeap & GetRenderHeap () { return *_renderHeap ; }
    DynamicHeap & GetQueryHitPointHeap () { return *_queryHitPointHeap ; }

    void Repaint();

    void EventHappened();

    void AddPickEvent() { InterlockedIncrement(&_pickEvents); }
    void DecPickEvent() { InterlockedDecrement(&_pickEvents); }

    double GetFramePeriod() { return _framePeriod; }

    double GetFrameRate();
    double GetTimeDelta();

#if PERFORMANCE_REPORTING
    GlobalTimers & GetTimers() { return _timers; }
#endif  // PERFORMANCE_REPORTING

    bool QueryHitPoint(DWORD dwAspect,
                       LPCRECT prcBounds,
                       POINT ptLoc,
                       LONG lCloseHint);

    LONG QueryHitPointEx(LONG s,
                         DWORD_PTR *userIds,
                         double *points,
                         LPCRECT prcBounds,
                         POINT ptLoc);

    LONG GetInvalidatedRects(DWORD flags,
                             LONG  size,
                             RECT *pRects);

    SoundInstanceList *GetSoundInstanceList() {
        return _sndList;
    }

    unsigned int GetSampleID() { return _sampleId; }
    
    PerfTimeXformImpl *GetPerfTimeXformFromCache(Perf);
    void SetPerfTimeXformCache(Perf, PerfTimeXformImpl *);
    void ClearPerfTimeXformCache();
    
  protected:
    targetPackage_t _targetPackage;  // rendering target info
    targetPackage_t _oldTargetPackage;  // last target package
    bool _doTargetUpdate;
    HWND _bogusSoundHwnd ;
    bool _devInited ;

    Image *QueryHitPointWcPt(LPCRECT prcBounds,
                             POINT ptLoc,
                             Point2Value& wcPt);

    DynamicHeap *_sampleHeap ;
    DynamicHeap *_renderHeap ;
    DynamicHeap *_queryHitPointHeap ;
    DynamicHeap *_rbHeap;

    Perf _sndPerf, _imgPerf;
    AxAValue _sndVal, _imgVal, _imgForQueryHitPt;

    typedef map< DWORD, std::pair<Bvr, bool>, less<DWORD> > RunList;
    typedef map< DWORD, Perf, less<DWORD> > RunningList;
    
    RunList _toRunBvrs;
    RunningList _runningBvrs;
    DWORD _runId;

    long _pickEvents;
    PickQ _pickq ;
    EventQ _eventq ;
    Time _lastSampleTime;
    Time _currentSampleTime;
    DWORD _lastSystemTime;
    DWORD _currentSystemTime;

    DirectDrawViewport * _imageDev;
    MetaSoundDevice * _soundDev;

    int   _toPaint;               // number of frames to render

    bool  _firstRendering;
    bool  _someEventHappened;
    bool  _isRBConst;
    bool  _repaintCalled;

    int            _lastSampleId;
    DirtyRectState _dirtyRectState;
    bool           _dirtyRectsDisabled;

    bool  _isStarted;

    // TODO: should decrement _toPaint in Sample, then we don't need this.
    bool  _emptyImageSoFar;
    bool  _firstSample;

#if PERFORMANCE_REPORTING
    void  ResetJitterMeasurements();
#endif  // PERFORMANCE_REPORTING

    void  SubmitNewRenderingTime();
    void StartPerf(Bvr img, Bvr snd, Time time);
    void PreRender();

#define MAX_RENDER_TIMES 1000

    void ReportPerformance();
    void  GetRenderingTimeStats(Real *avg,
                                Real *avgFrameLength,
                                Real *avgVariance,
                                Real *maxVariance,
                                Real *minVariance);
#if PERFORMANCE_REPORTING


    GlobalTimers _timers;
    DWORD _sampleTime;
    DWORD _pickTime;
    DWORD _gcTime;
    DWORD _numSamples;          // Count samples in reporting period
    DWORD _renderTime;
    DWORD _viewStartTime;

#endif  // PERFORMANCE_REPORTING

    DWORD _FPSNumSamples;       // for FrameRate Behavior
    DWORD _FPSLastReportTime;
    double _FPS;
    
    DWORD _numFrames;
    DWORD _lastRenderingTime;
    DWORD _totalTime;
    DWORD _renderTimes[MAX_RENDER_TIMES];
    int   _renderTimeIdx;
    DWORD _lastReportTime;
    double _framePeriod;     // length of time in seconds frame took to render
    HWND CreateViewWindow() ;

    // Retained mode sound
    SpriteNode   *_soundSprite;
    RMImpl       *_rmSound;
    SpriteThread *_spriteThread;

    SoundInstanceList *_sndList;

    CritSect  _importCS;
    set <Bvr> _pendingImports;
    Win32Event _importEvent;

    list<Perf> _events;
    list<Perf> _changeables;
    list<Perf> _conditionals;
    
    unsigned int _lastRBId;
    unsigned int _sampleId;

    typedef map<Perf, PerfTimeXformImpl *, less<Perf> > PerfTTMap;
    PerfTTMap _ttCache;

    double _lastCondsCheckTime;
    double _modelStartTime;
};


class CRView : public View
{
  public:
    CRView();
    ~CRView();

    ULONG AddRef() { return InterlockedIncrement(&_cRef); }
    ULONG Release();

    bool Tick(double simTime);

    void StartModel(Bvr pImage,
                    Bvr pSound,
                    double startTime,
                    DWORD dwFlags,
                    bool & bPending);
    void StopModel();
    void PauseModel();
    void ResumeModel();
    bool Paused() { return _bPaused; }

    void SetSite(CRViewSitePtr pViewSite) { _pViewSite = pViewSite; }
    CRViewSitePtr GetSite() { return _pViewSite; }
    void SetServiceProvider(IServiceProvider * pServiceProvider)
    { _pServiceProvider = pServiceProvider; }
    IServiceProvider * GetServiceProvider() { return _pServiceProvider; }

    bool PutPreference(LPCWSTR prefName, VARIANT v) {
        USES_CONVERSION;
        return SUCCEEDED(_privPrefs.PutPreference(W2A(prefName), v));
    }

    bool GetPreference(LPCWSTR prefName, VARIANT *pV) {
        USES_CONVERSION;
        return SUCCEEDED(_privPrefs.GetPreference(W2A(prefName), pV));
    }

    void Propagate() {
        _privPrefs.Propagate();
    }

    PrivatePreferences& GetPreferences() {
        return _privPrefs;
    }
    
    void                SetStatusText(char * szStatus);

    double              GetCurrentSimulationTime() { return _currentTime; }

    double              GetCurrentGlobalTime()
    { return _localHiresTimer->GetTime(); }

    CritSect &          GetCritSect() { return _crit; }

    bool                GetRenderLock() { return _bRenderLock; }
    void                SetRenderLock(bool b) { _bRenderLock = b; }

#if _DEBUG
    long                GetRefCount() { return _cRef; }
#endif
  protected:
    bool                  _firstRender;
    HiresTimer *          _localHiresTimer;
    DAComPtr<CRViewSite>  _pViewSite;
    DAComPtr<IServiceProvider> _pServiceProvider;
    PrivatePreferences    _privPrefs;
    CritSect              _crit;
    double                _currentTime;
    DWORD                 _ticksAtStart;
    bool                  _bRenderLock;
    bool                  _bPaused;
    long                  _cRef;
};

EventQ & GetCurrentEventQ() ;
PickQ & GetCurrentPickQ() ;
CRView * IntGetCurrentView();
CRView & GetCurrentView() ;
CRView * SetCurrentView(CRView * v) ;

#if _DEBUG
struct DisablePopups
{
    DisablePopups(bool bDisable = true) : _bDisable(bDisable)
    { if (_bDisable) _bPrev = DISABLE_ASSERT_POPUPS(true); }
    ~DisablePopups()
    { if (_bDisable) DISABLE_ASSERT_POPUPS(_bPrev); }

    BOOL _bDisable;
    BOOL _bPrev;
};
#endif

struct ViewPusher
{
    ViewPusher (CRView * cv,
                bool bNeedLock = false,
                bool bNeedRenderLock = false)
    : _cv(*cv),
      _bNeedRenderLock(bNeedRenderLock),
      _bNeedLock(bNeedLock),
      _bWasLocked(false)
    {
        Assert (cv);
        
        _prevView = SetCurrentView(cv);
        if (_bNeedLock) _cv.GetCritSect().Grab();

        if (_bNeedRenderLock) {
            _bWasLocked = _cv.GetRenderLock();
            // XXX tmp for workaround      Assert (!_bWasLocked);
            if (!_bWasLocked) _cv.SetRenderLock(true);
        }
    }
    ~ViewPusher()
    {
        if (_bNeedRenderLock) {
            if (!_bWasLocked) _cv.SetRenderLock(false);
        }
        if (_bNeedLock) _cv.GetCritSect().Release();
        SetCurrentView(_prevView);
    }

    bool WasLocked() { return _bWasLocked; }
    void CheckLock() {
        if (_bNeedRenderLock && _bWasLocked)
            RaiseException_UserError(DAERR_VIEW_LOCKED, IDS_ERR_SRV_RENDER_NOT_REENTRANT);
    }
  protected:
    CRView & _cv;
    CRView * _prevView;
    bool _bNeedLock;
    bool _bNeedRenderLock;
    bool _bWasLocked;
#ifdef _DEBUG
    DisablePopups _popup;
#endif
} ;


#endif /* _DAVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\statics.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Methods on the statics, always available, therefore called Statics.

*******************************************************************************/


#include "headers.h"
#include "srvprims.h"
#include "results.h"
#include "comcb.h"
#include "version.h"
#include "statics.h"
#include "drawsurf.h"
#include "privinc/util.h"
#include <mshtml.h>

DeclareTag(tagStatics, "CDAStatics", "IDAStatics methods");

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::CDAStatics
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//--------------------------------------------------------------------------

CDAStatics::CDAStatics()
: _bPixelMode(false),
  _clientSiteURL(NULL),
  _dwModBvrFlags(0)
{
    TraceTag((tagStatics, "CDAStatics::CDAStatics(%lx)", this));
}

ULONG
CDAStatics::InternalRelease()
{
    // InternalRelease doesn't return the ref count, use m_dwRef
    // probably returns the result of InterlockedDecrement
    ULONG i =
        CComObjectRootEx<CComMultiThreadModel>::InternalRelease(); 
    
    if (m_dwRef==1) {
        CRRemoveSite(this);
    }

    return i;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::~CDAStatics
//
//  Synopsis:   Destructor
//
//  Arguments:  
//
//--------------------------------------------------------------------------

CDAStatics::~CDAStatics()
{
    TraceTag((tagStatics, "CDAStatics::~CDAStatics(%lx)", this));
    delete _clientSiteURL;
    // NEVER PUT THE REMOVE SITE CALL HERE - not MT safe
}

HRESULT
CDAStatics::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CDAStatics, &CLSID_DAStatics>::Error(str,
                                                                IID_IDAStatics,
                                                                hr);
    else
        return hr;
}

STDMETHODIMP
CDAStatics::TriggerEvent(IDAEvent *event, IDABehavior *data)
{
    TraceTag((tagCOMEntry, "CDAStatics::(%lx)", this));
    
    PRIMPRECODE0(ok);
    MAKE_BVR_TYPE_NAME(CREventPtr, crevent, event);
    CRBvrPtr crdata;

    if (data) {
        crdata = GetBvr(data);
        if (crdata == NULL) goto done;
    } else {
        crdata = NULL;
    }

    ok = CRTriggerEvent(crevent, crdata);

    PRIMPOSTCODE0(ok);
}

STDMETHODIMP
CDAStatics::ImportImage(LPOLESTR url,
                        IDAImage **ppImage)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportImage(%lx)", this));
    
    PRIMPRECODE1(ppImage);

    CRImagePtr img;
    DAComPtr<IBindHost> bh(GetBindHost(), false);
    
    DWORD id = CRImportImage(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             false,
                             0,
                             0,
                             0,
                             NULL,
                             &img,
                             NULL,
                             NULL,
                             NULL);
    if (id)
    {
        CreateCBvr(IID_IDAImage, (CRBvrPtr) img, (void **) ppImage);
    }
        
    PRIMPOSTCODE1(ppImage);
}

STDMETHODIMP
CDAStatics::ImportImageAsync(LPOLESTR url,
                             IDAImage *pImageStandIn,
                             IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportImageAsync(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRImagePtr, standin, pImageStandIn);
    CRImagePtr pImage;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;

    DWORD id;

    id = CRImportImage(GetURLOfClientSite(),
                       url,
                       this,
                       bh,
                       false,
                       0,
                       0,
                       0,
                       standin,&pImage,
                       &pEvent,&pProgress, &pSize);

    if (id)
    {
        CDAImportationResult::Create(pImage,
                                     NULL,
                                     NULL,
                                     NULL,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ImportImageColorKey(LPOLESTR url,
                                BYTE ckRed,
                                BYTE ckGreen,
                                BYTE ckBlue,
                                IDAImage **ppImage)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportImageColorKey(%lx)", this));
    
    PRIMPRECODE1(ppImage);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    CRImagePtr img;
    
    DWORD id;
    id = CRImportImage(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             true,
                             ckRed,
                             ckGreen,
                             ckBlue,
                             NULL,
                             &img,
                             NULL,
                             NULL,
                             NULL);
    if(id)
    {
        CreateCBvr(IID_IDAImage, (CRBvrPtr) img, (void **) ppImage);
    }
        
    PRIMPOSTCODE1(ppImage);
}


STDMETHODIMP
CDAStatics::ImportImageAsyncColorKey(LPOLESTR url,
                                     IDAImage *pImageStandIn,
                                     BYTE ckRed,
                                     BYTE ckGreen,
                                     BYTE ckBlue,
                                     IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportImageAsyncColorKey(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRImagePtr, standin, pImageStandIn);
    CRImagePtr pImage;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;

    DWORD id;
    id = CRImportImage(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             true, ckRed, ckGreen, ckBlue,
                             standin,&pImage,
                             &pEvent,&pProgress, &pSize);
    
    if (id)
    {
        CDAImportationResult::Create(pImage,
                                     NULL,
                                     NULL,
                                     NULL,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

HRESULT
CDAStatics::DoImportMovie(LPOLESTR url,
                          IDAImportationResult **ppResult, 
                          bool stream)
{
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    CRImagePtr pImage;
    CRSoundPtr pSound;
    CRNumberPtr pDuration;

    DWORD id;
    id = CRImportMovie(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             stream,
                             NULL,
                             NULL,
                             &pImage,
                             &pSound,
                             &pDuration,
                             NULL,
                             NULL,
                             NULL);
    
    if (id)
    {
        CDAImportationResult::Create(pImage,
                                     pSound,
                                     NULL,
                                     pDuration,
                                     NULL,
                                     NULL,
                                     NULL,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}


STDMETHODIMP
CDAStatics::ImportMovieAsync(LPOLESTR url,
                             IDAImage   *pImageStandIn,
                             IDASound   *pSoundStandIn,
                             IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportMovieAsync(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRImagePtr, imgstandin, pImageStandIn);
    MAKE_BVR_TYPE_NAME(CRSoundPtr, sndstandin, pSoundStandIn);
    CRImagePtr pImage;
    CRSoundPtr pSnd;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;
    CRNumberPtr pDuration;

    DWORD id;
    id = CRImportMovie(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             false,
                             imgstandin,
                             sndstandin,
                             &pImage,&pSnd,
                             &pDuration,
                             &pEvent,&pProgress, &pSize);

    if (id)
    {
        CDAImportationResult::Create(pImage,
                                     pSnd,
                                     NULL,
                                     pDuration,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

HRESULT
CDAStatics::DoImportSound(LPOLESTR url,
                          IDAImportationResult **ppResult, 
                          bool stream)
{
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    CRSoundPtr pSound;
    CRNumberPtr pDuration;

    DWORD id;

    id = CRImportSound(GetURLOfClientSite(),
                       url,
                       this,
                       bh,
                       stream,
                       NULL,
                       &pSound,
                       &pDuration,
                       NULL,
                       NULL,
                       NULL);

    if (id)
    {
        CDAImportationResult::Create(NULL,
                                     pSound,
                                     NULL,
                                     pDuration,
                                     NULL,
                                     NULL,
                                     NULL,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}


STDMETHODIMP
CDAStatics::ImportSoundAsync(LPOLESTR url,
                             IDASound   *pSoundStandIn,
                             IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportSoundAsync(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRSoundPtr, sndstandin, pSoundStandIn);
    CRSoundPtr pSnd;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;
    CRNumberPtr pDuration;

    DWORD id;

    id = CRImportSound(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             false,
                             sndstandin,
                             &pSnd,
                             &pDuration,
                             &pEvent,
                             &pProgress,
                             &pSize);

    if (id)
    {
        CDAImportationResult::Create(NULL,
                                     pSnd,
                                     NULL,
                                     pDuration,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ImportGeometry(LPOLESTR url,
                           IDAGeometry **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportGeometry(%lx)", this));
    
    PRIMPRECODE1(bvr);

    CRGeometryPtr geo;
    DAComPtr<IBindHost> bh(GetBindHost(), false);
    
    DWORD id;
    id = CRImportGeometry(GetURLOfClientSite(),
                                url,
                                this,
                                bh,
                                NULL,
                                &geo,
                                NULL,
                                NULL,
                                NULL);
    if (id)
    {
        CreateCBvr(IID_IDAGeometry, (CRBvrPtr) geo, (void **) bvr);
    }
        
    PRIMPOSTCODE1(bvr);
}


STDMETHODIMP
CDAStatics::ImportGeometryAsync(LPOLESTR url,
                              IDAGeometry *pGeoStandIn,
                              IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportGeometryAsync(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRGeometryPtr, geostandin, pGeoStandIn);
    CRGeometryPtr pGeometry;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;

    DWORD id;
    id = CRImportGeometry(GetURLOfClientSite(),
                          url,
                          this,
                          bh,
                          geostandin,
                          &pGeometry,
                          &pEvent,
                          &pProgress,
                          &pSize);

    if (id)
    {
        CDAImportationResult::Create(NULL,
                                     NULL,
                                     pGeometry,
                                     NULL,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ImportDirectDrawSurface(IUnknown *dds,
                                    IDAEvent *updateEvent,
                                    IDAImage **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportDirectDrawSurface(%lx)", this));
    
    PRIMPRECODE1(bvr) ;

    CHECK_RETURN_NULL(dds);
    
    CREventPtr crevent;
    if(updateEvent) {
        crevent = (CREventPtr) ::GetBvr(updateEvent);
        if (!crevent) goto done;
    } else {
        crevent = NULL;
    }

    CRImagePtr img;

    img = CRImportDirectDrawSurface(dds, crevent);

    if (img) {
        CreateCBvr(IID_IDAImage,
                   (CRBvrPtr) img,
                   (void **) bvr) ;
    }

    PRIMPOSTCODE1(bvr) ;
}


STDMETHODIMP
CDAStatics::get_AreBlockingImportsComplete(VARIANT_BOOL *bComplete)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_AreBlockingImportsComplete(%lx)", this));
    
    CHECK_RETURN_NULL(bComplete);

    CritSectGrabber csg(_cs);

    *bComplete = _importList.size() == 0;

    return S_OK;
}

STDMETHODIMP
CDAStatics::Cond(IDABoolean *c,
                 IDABehavior *i,
                 IDABehavior *e,
                 IDABehavior **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::Cond(%lx)", this));
    
    PRIMPRECODE1(bvr) ;

    MAKE_BVR_TYPE_NAME(CRBooleanPtr, crcond, c);
    MAKE_BVR_NAME(cri, i);
    MAKE_BVR_NAME(cre, e);

    *bvr = CreateCBvr(CRCond(crcond, cri, cre));

    PRIMPOSTCODE1(bvr) ;
}

STDMETHODIMP
CDAStatics::DAArrayEx2(long size, IDABehavior *pCBvrs[], DWORD dwFlags, IDAArray **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::DAArrayEx2(%lx)", this));
    
    PRIMPRECODE1(bvr);

    CHECK_RETURN_NULL(pCBvrs);

    CreateCBvr(IID_IDAArray,
               (CRBvrPtr) ToArrayBvr(size, pCBvrs, dwFlags),
               (void **) bvr);
    
    PRIMPOSTCODE1(bvr) ;
}

STDMETHODIMP
CDAStatics::DAArray2(VARIANT pBvrs, DWORD dwFlags, IDAArray **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::DAArray2(%lx)", this));
    
    PRIMPRECODE1(bvr);
    CreateCBvr(IID_IDAArray,
               (CRBvrPtr) ::SrvArrayBvr(pBvrs,
                                        false,
                                        CRUNKNOWN_TYPEID,
                                        dwFlags),
               (void **) bvr);
    PRIMPOSTCODE1(bvr) ;
}

STDMETHODIMP
CDAStatics::DATupleEx(long size, IDABehavior *pCBvrs[], IDATuple **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::DATupleEx(%lx)", this));
    
    PRIMPRECODE1(bvr);

    CHECK_RETURN_NULL(pCBvrs);

    CRBvrPtr * arr = CBvrsToBvrs(size,pCBvrs);

    if (arr) {
        CreateCBvr(IID_IDATuple,
                   (CRBvrPtr) ::CRCreateTuple(size, arr),
                   (void **)bvr) ;
    }
    
    PRIMPOSTCODE1(bvr);
}

STDMETHODIMP
CDAStatics::DATuple(VARIANT pBvrs, IDATuple **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::DATuple(%lx)", this));
    
    PRIMPRECODE1(bvr);
    SafeArrayAccessor acc(pBvrs,GetPixelMode());

    CRBvrPtr * arr = 
        (acc.GetNumObjects()>0) ? 
        acc.ToBvrArray((CRBvrPtr *)_alloca(acc.GetNumObjects() * sizeof(CRBvrPtr)))
        : NULL;
    
    if (arr == NULL) goto done;

    if (acc.IsOK()) {
        CreateCBvr(IID_IDATuple,
                   (CRBvrPtr) CRCreateTuple(acc.GetNumObjects(), arr),
                   (void **)bvr) ;
    }
    
    PRIMPOSTCODE1(bvr);
}

STDMETHODIMP
CDAStatics::ModifiableBehavior(IDABehavior *orig, IDABehavior **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ModifiableBehavior(%lx)", this));
    
    PRIMPRECODE1(bvr) ;

    MAKE_BVR_NAME(crbvr, orig);

    *bvr = CreateCBvr(CRModifiableBvr(crbvr, _dwModBvrFlags));

    PRIMPOSTCODE1(bvr) ;
}

// TODO: Factor out the code
STDMETHODIMP
CDAStatics::UninitializedArray(IDAArray *typeTmp, IDAArray **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::UninitializedArray(%lx)", this));
    
    PRIMPRECODE1(bvr);

    MAKE_BVR_TYPE_NAME(CRArrayPtr, crarr, typeTmp);

    CreateCBvr(IID_IDAArray,
               (CRBvrPtr) CRUninitializedArray(crarr),
               (void **)bvr);

    PRIMPOSTCODE1(bvr);
}

STDMETHODIMP
CDAStatics::UninitializedTuple(IDATuple *typeTmp, IDATuple **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::UninitializedTuple(%lx)", this));
    
    PRIMPRECODE1(bvr);

    MAKE_BVR_TYPE_NAME(CRTuplePtr, crtuple, typeTmp);

    CreateCBvr(IID_IDATuple,
               (CRBvrPtr) CRUninitializedTuple(crtuple),
               (void **)bvr);

    PRIMPOSTCODE1(bvr);
}

HRESULT
CDAStatics::MakeSplineEx(int degree,        
                         long numKnots,        
                         IDANumber *knots[],   
                         long numPts,          
                         IDABehavior *ctrlPoints[],
                         long numWts,          
                         IDANumber *weights[], 
                         IDANumber *evaluator, 
                         CR_BVR_TYPEID tid,
                         REFIID iid,
                         void **bvr)    
{   
    PRIMPRECODE1(bvr) ;
    
    if (numKnots != numPts + degree - 1) {
        return E_INVALIDARG ;             
    }                                     
    
    CRNumberPtr * knotarr;
    knotarr = (CRNumberPtr *) CBvrsToBvrs(numKnots, knots);
    if (knotarr == NULL) goto done;
        
    CRBvrPtr * ptarr;
    ptarr = CBvrsToBvrs(numPts, ctrlPoints);
    if (ptarr == NULL) goto done;
    
    CRNumberPtr * wtsarr;
    if (numWts) {
        wtsarr = (CRNumberPtr *) CBvrsToBvrs(numWts, weights);
        if (wtsarr == NULL) goto done;
    } else {
        wtsarr = NULL;
    }

    MAKE_BVR_TYPE_NAME(CRNumberPtr,eval, evaluator);
    
    CreateCBvr(iid,
               CRBSpline(degree,
                         numKnots,
                         knotarr,
                         numPts,
                         ptarr,
                         numWts,
                         wtsarr,
                         eval,
                         tid),
               bvr) ;  

    PRIMPOSTCODE1(bvr) ;        
}

#define SPLINE_FUNC_EX(METHODNAME, BVRTYPE, TYPEID, BVRIID)     \
 STDMETHODIMP                                                   \
 CDAStatics::METHODNAME(int degree,                             \
                        long numKnots,                          \
                        IDANumber *knots[],                     \
                        long numPts,                            \
                        BVRTYPE *ctrlPoints[],                  \
                        long numWts,                            \
                        IDANumber *weights[],                   \
                        IDANumber *evaluator,                   \
                        BVRTYPE **bvr)                          \
 {                                                              \
    TraceTag((tagCOMEntry, "CDAStatics::SplineCreate(%lx)", this)); \
     return MakeSplineEx(degree,                                \
                       numKnots,                                \
                       knots,                                   \
                       numPts,                                  \
                       (IDABehavior **)ctrlPoints,              \
                       numWts,                                  \
                       weights,                                 \
                       evaluator,                               \
                       TYPEID,                                  \
                       BVRIID,                                  \
                       (void **)bvr);                           \
 }

SPLINE_FUNC_EX(NumberBSplineEx, IDANumber, CRNUMBER_TYPEID, IID_IDANumber);
SPLINE_FUNC_EX(Point2BSplineEx, IDAPoint2, CRPOINT2_TYPEID, IID_IDAPoint2);
SPLINE_FUNC_EX(Point3BSplineEx, IDAPoint3, CRPOINT3_TYPEID, IID_IDAPoint3);
SPLINE_FUNC_EX(Vector2BSplineEx, IDAVector2, CRVECTOR2_TYPEID, IID_IDAVector2);
SPLINE_FUNC_EX(Vector3BSplineEx, IDAVector3, CRVECTOR3_TYPEID, IID_IDAVector3);

HRESULT
CDAStatics::MakeSpline(int degree,        
                       VARIANT knots,
                       VARIANT ctrlPoints,
                       VARIANT weights,
                       IDANumber *evaluator, 
                       CR_BVR_TYPEID tid,
                       REFIID iid,
                       void **bvr)    
{   
    PRIMPRECODE1(bvr) ; 
                                                
    SafeArrayAccessor accKnots(knots,GetPixelMode(),CRNUMBER_TYPEID);
    if (!accKnots.IsOK()) return Error();
    
    SafeArrayAccessor accPoints(ctrlPoints,GetPixelMode(),tid);
    if (!accPoints.IsOK()) return Error();

    SafeArrayAccessor accWeights(weights,GetPixelMode(),CRNUMBER_TYPEID, true);
    if (!accWeights.IsOK()) return Error();

    long numPts = accPoints.GetNumObjects();                
    long numKnots = accKnots.GetNumObjects();               
    long numWts = accWeights.GetNumObjects();               
    
    if (numKnots != numPts + degree - 1) {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    CRNumberPtr * knotarr;
    knotarr = (CRNumberPtr *) accKnots.ToBvrArray((CRBvrPtr *)_alloca(numKnots * sizeof(CRBvrPtr)));
    if (knotarr == NULL) goto done;
    
    CRBvrPtr * ptarr;
    ptarr = accPoints.ToBvrArray((CRBvrPtr *)_alloca(numPts * sizeof(CRBvrPtr)));
    if (ptarr == NULL) goto done;
    
    CRNumberPtr * wtsarr;
    wtsarr = (CRNumberPtr *) accWeights.ToBvrArray((CRBvrPtr *)_alloca(numWts * sizeof(CRBvrPtr)));
    if (wtsarr == NULL) goto done;
    
    MAKE_BVR_TYPE_NAME(CRNumberPtr,eval, evaluator);
    
    CreateCBvr(iid,
               CRBSpline(degree,
                         numKnots,
                         knotarr,
                         numPts,
                         ptarr,
                         numWts,
                         numWts?wtsarr:NULL,
                         eval,
                         tid),
               bvr) ;  
    
    PRIMPOSTCODE1(bvr) ;        
}
        
#define SPLINE_FUNC(METHODNAME, BVRTYPE, TYPEID, BVRIID)        \
 STDMETHODIMP                                                   \
 CDAStatics::METHODNAME(int degree,                             \
                        VARIANT knots,                          \
                        VARIANT ctrlPoints,                     \
                        VARIANT weights,                        \
                        IDANumber *evaluator,                   \
                        BVRTYPE **bvr)                          \
 {                                                              \
     return MakeSpline(degree,                                  \
                       knots,                                   \
                       ctrlPoints,                              \
                       weights,                                 \
                       evaluator,                               \
                       TYPEID,                                  \
                       BVRIID,                                  \
                       (void **)bvr);                           \
 }

SPLINE_FUNC(NumberBSpline, IDANumber, CRNUMBER_TYPEID, IID_IDANumber);
SPLINE_FUNC(Point2BSpline, IDAPoint2, CRPOINT2_TYPEID, IID_IDAPoint2);
SPLINE_FUNC(Point3BSpline, IDAPoint3, CRPOINT3_TYPEID, IID_IDAPoint3);
SPLINE_FUNC(Vector2BSpline, IDAVector2, CRVECTOR2_TYPEID, IID_IDAVector2);
SPLINE_FUNC(Vector3BSpline, IDAVector3, CRVECTOR3_TYPEID, IID_IDAVector3);

bool CreatePrim0(REFIID iid, void *fp  , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)()) fp)(), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreatePrim1(REFIID iid, void *fp , IDABehavior * arg1 , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    MAKE_BVR_NAME(arg1VAL, arg1);

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)(CRBvrPtr)) fp)(arg1VAL), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreatePrim2(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2 , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    MAKE_BVR_NAME(arg1VAL, arg1);
    MAKE_BVR_NAME(arg2VAL, arg2);

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)(CRBvrPtr, CRBvrPtr)) fp)(arg1VAL, arg2VAL), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreatePrim3(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3 , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    MAKE_BVR_NAME(arg1VAL, arg1);
    MAKE_BVR_NAME(arg2VAL, arg2);
    MAKE_BVR_NAME(arg3VAL, arg3);

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)(CRBvrPtr, CRBvrPtr, CRBvrPtr)) fp)(arg1VAL, arg2VAL, arg3VAL), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreatePrim4(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3, IDABehavior * arg4 , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    MAKE_BVR_NAME(arg1VAL, arg1);
    MAKE_BVR_NAME(arg2VAL, arg2);
    MAKE_BVR_NAME(arg3VAL, arg3);
    MAKE_BVR_NAME(arg4VAL, arg4);

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)(CRBvrPtr, CRBvrPtr, CRBvrPtr, CRBvrPtr)) fp)(arg1VAL, arg2VAL, arg3VAL, arg4VAL), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreateVar(REFIID iid, CRBvrPtr var, void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    ok = CreateCBvr(iid, var, ret);
    PRIMPOSTCODE(ok) ;
}

STDMETHODIMP
CDAStatics::Pow(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Pow(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRPow , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Abs(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Abs(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRAbs , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Sqrt(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Sqrt(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRSqrt , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Floor(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Floor(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRFloor , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Round(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Round(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRRound , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Ceiling(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Ceiling(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRCeiling , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Asin(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Asin(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRAsin , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Acos(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Acos(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRAcos , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Atan(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Atan(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRAtan , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Sin(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Sin(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRSin , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Cos(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Cos(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRCos , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Tan(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Tan(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRTan , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Exp(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Exp(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRExp , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Ln(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Ln(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRLn , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Log10(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Log10(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRLog10 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ToDegrees(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ToDegrees(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRToDegrees , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ToRadians(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ToRadians(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRToRadians , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Mod(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Mod(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRMod , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Atan2(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Atan2(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRAtan2 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Add(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Add(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Sub(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Sub(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Mul(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Mul(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRMul , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Div(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Div(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRDiv , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::LT(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::LT(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRLT , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::LTE(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::LTE(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRLTE , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::GT(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GT(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRGT , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::GTE(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GTE(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRGTE , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::EQ(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::EQ(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CREQ , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::NE(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::NE(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRNE , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Neg(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Neg(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRNeg , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::InterpolateAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::InterpolateAnim(%lx)", this));
    return CreatePrim3(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *)) CRInterpolate , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Interpolate(double arg0, double arg1, double arg2, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Interpolate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDANumber, (CRBvrPtr) (::CRInterpolate(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::SlowInSlowOutAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SlowInSlowOutAnim(%lx)", this));
    return CreatePrim4(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *, CRNumber *)) CRSlowInSlowOut , arg0, arg1, arg2, arg3, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SlowInSlowOut(double arg0, double arg1, double arg2, double arg3, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SlowInSlowOut(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDANumber, (CRBvrPtr) (::CRSlowInSlowOut(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2, /* NOELARG */ arg3)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::SoundSource(IDASound *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SoundSource(%lx)", this));
    return CreatePrim1(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRSound *)) CRSoundSource , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Mix(IDASound *  arg0, IDASound *  arg1, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Mix(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRSound *)) CRMix , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::And(IDABoolean *  arg0, IDABoolean *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::And(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRBoolean *, CRBoolean *)) CRAnd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Or(IDABoolean *  arg0, IDABoolean *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Or(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRBoolean *, CRBoolean *)) CROr , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Not(IDABoolean *  arg0, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Not(%lx)", this));
    return CreatePrim1(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRBoolean *)) CRNot , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Integral(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Integral(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRIntegral , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Derivative(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Derivative(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::IntegralVector2(IDAVector2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::IntegralVector2(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *)) CRIntegral , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::IntegralVector3(IDAVector3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::IntegralVector3(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *)) CRIntegral , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DerivativeVector2(IDAVector2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DerivativeVector2(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DerivativeVector3(IDAVector3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DerivativeVector3(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DerivativePoint2(IDAPoint2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DerivativePoint2(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRPoint2 *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DerivativePoint3(IDAPoint3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DerivativePoint3(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRPoint3 *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::KeyState(IDANumber *  arg0, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::KeyState(%lx)", this));
    return CreatePrim1(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *)) CRKeyState , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::KeyUp(LONG arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::KeyUp(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::CRKeyUp(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::KeyDown(LONG arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::KeyDown(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::CRKeyDown(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DANumber(double arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DANumber(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDANumber, (CRBvrPtr) (::CRCreateNumber(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DAString(BSTR arg0, IDAString *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DAString(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAString, (CRBvrPtr) (::CRCreateString(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DABoolean(VARIANT_BOOL arg0, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DABoolean(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDABoolean, (CRBvrPtr) (::CRCreateBoolean(/* NOELARG */ BOOLTobool(arg0))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::SeededRandom(double arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SeededRandom(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDANumber, (CRBvrPtr) (::CRSeededRandom(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_MousePosition(IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_MousePosition(%lx)", this));
    return CreateVar(IID_IDAPoint2, (CRBvrPtr) CRMousePosition(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_LeftButtonState(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_LeftButtonState(%lx)", this));
    return CreateVar(IID_IDABoolean, (CRBvrPtr) CRLeftButtonState(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_RightButtonState(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_RightButtonState(%lx)", this));
    return CreateVar(IID_IDABoolean, (CRBvrPtr) CRRightButtonState(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DATrue(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DATrue(%lx)", this));
    return CreateVar(IID_IDABoolean, (CRBvrPtr) CRTrue(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DAFalse(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DAFalse(%lx)", this));
    return CreateVar(IID_IDABoolean, (CRBvrPtr) CRFalse(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_LocalTime(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_LocalTime(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRLocalTime(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_GlobalTime(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_GlobalTime(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRGlobalTime(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Pixel(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Pixel(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRPixel(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UserData(IUnknown * arg0, IDAUserData *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UserData(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAUserData, (CRBvrPtr) (::CRCreateUserData(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::UntilNotify(IDABehavior *  arg0, IDAEvent *  arg1, IDAUntilNotifier * arg2, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UntilNotify(%lx)", this));

    PRIMPRECODE1(ret) ;
    DAComPtr<CRUntilNotifier > arg2VAL((CRUntilNotifier *) WrapCRUntilNotifier(arg2),false);
    if (!arg2VAL) return Error();

    CREvent * arg1VAL;
    arg1VAL = (CREvent *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRBvr * arg0VAL;
    arg0VAL = (CRBvr *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDABehavior, (CRBvrPtr) (::CRUntilNotify(arg0VAL, arg1VAL, /* NOELARG */ arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Until(IDABehavior *  arg0, IDAEvent *  arg1, IDABehavior *  arg2, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Until(%lx)", this));
    return CreatePrim3(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRBvr *, CREvent *, CRBvr *)) CRUntil , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UntilEx(IDABehavior *  arg0, IDAEvent *  arg1, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UntilEx(%lx)", this));
    return CreatePrim2(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRBvr *, CREvent *)) CRUntilEx , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Sequence(IDABehavior *  arg0, IDABehavior *  arg1, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Sequence(%lx)", this));
    return CreatePrim2(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRBvr *, CRBvr *)) CRSequence , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SequenceArrayEx(long size, IDABehavior *  pCBvrs[], IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SequenceArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CHECK_RETURN_NULL(pCBvrs);

    CRBvrPtr * arr = CBvrsToBvrs(size,pCBvrs);

    if (arr) {
        CreateCBvr(IID_IDABehavior,
                   (CRBvrPtr) ::CRSequenceArray(size, arr),
                   (void **)ret) ;
    }
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::SequenceArray(VARIANT pBvrs, IDABehavior *  * bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::SequenceArray(%lx)", this));

    PRIMPRECODE1(bvr);
    SafeArrayAccessor acc(pBvrs,GetPixelMode());

    CRBvrPtr * arr = acc.ToBvrArray((CRBvrPtr *)_alloca(acc.GetNumObjects() * sizeof(CRBvrPtr)));
    if (arr == NULL) goto done;

    if (acc.IsOK()) {
        CreateCBvr(IID_IDABehavior,
                   (CRBvrPtr) CRSequenceArray(acc.GetNumObjects(), arr),
                   (void **)bvr) ;
    }
    
    PRIMPOSTCODE1(bvr);
}

STDMETHODIMP
CDAStatics::FollowPath(IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPath(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRPath2 * arg0VAL;
    arg0VAL = (CRPath2 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRFollowPath(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::FollowPathAngle(IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngle(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRPath2 * arg0VAL;
    arg0VAL = (CRPath2 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRFollowPathAngle(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::FollowPathAngleUpright(IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleUpright(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRPath2 * arg0VAL;
    arg0VAL = (CRPath2 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRFollowPathAngleUpright(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::FollowPathEval(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathEval(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathEval , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAngleEval(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleEval(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathAngleEval , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAngleUprightEval(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleUprightEval(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathAngleUprightEval , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAnim(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAnim(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPath , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAngleAnim(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleAnim(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathAngle , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAngleUprightAnim(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleUprightAnim(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathAngleUpright , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UntilNotifyScript(IDABehavior *  arg0, IDAEvent *  arg1, BSTR arg2, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UntilNotifyScript(%lx)", this));

    PRIMPRECODE1(ret) ;
    CREvent * arg1VAL;
    arg1VAL = (CREvent *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRBvr * arg0VAL;
    arg0VAL = (CRBvr *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDABehavior, (CRBvrPtr) (::UntilNotifyScript(arg0VAL, arg1VAL, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ConcatString(IDAString *  arg0, IDAString *  arg1, IDAString *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ConcatString(%lx)", this));
    return CreatePrim2(IID_IDAString, (CRString * (STDAPICALLTYPE *)(CRString *, CRString *)) CRConcatString , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::PerspectiveCamera(double arg0, double arg1, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PerspectiveCamera(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDACamera, (CRBvrPtr) (::CRPerspectiveCamera(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PerspectiveCameraAnim(IDANumber *  arg0, IDANumber *  arg1, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PerspectiveCameraAnim(%lx)", this));
    return CreatePrim2(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRPerspectiveCameraAnim , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ParallelCamera(double arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ParallelCamera(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDACamera, (CRBvrPtr) (::CRParallelCamera(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ParallelCameraAnim(IDANumber *  arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ParallelCameraAnim(%lx)", this));
    return CreatePrim1(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRNumber *)) CRParallelCameraAnim , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ColorRgbAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorRgbAnim(%lx)", this));
    return CreatePrim3(IID_IDAColor, (CRColor * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *)) CRColorRgb , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ColorRgb(double arg0, double arg1, double arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorRgb(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAColor, (CRBvrPtr) (::CRColorRgb(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ColorRgb255(short arg0, short arg1, short arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorRgb255(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAColor, (CRBvrPtr) (::CRColorRgb255(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ColorHsl(double arg0, double arg1, double arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorHsl(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAColor, (CRBvrPtr) (::CRColorHsl(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ColorHslAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorHslAnim(%lx)", this));
    return CreatePrim3(IID_IDAColor, (CRColor * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *)) CRColorHsl , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Red(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Red(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRRed(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Green(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Green(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRGreen(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Blue(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Blue(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRBlue(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Cyan(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Cyan(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRCyan(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Magenta(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Magenta(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRMagenta(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Yellow(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Yellow(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRYellow(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Black(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Black(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRBlack(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_White(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_White(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRWhite(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Aqua(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Aqua(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRAqua(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Fuchsia(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Fuchsia(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRFuchsia(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Gray(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Gray(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRGray(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Lime(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Lime(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRLime(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Maroon(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Maroon(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRMaroon(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Navy(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Navy(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRNavy(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Olive(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Olive(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CROlive(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Purple(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Purple(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRPurple(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Silver(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Silver(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRSilver(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Teal(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Teal(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRTeal(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Predicate(IDABoolean *  arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Predicate(%lx)", this));
    return CreatePrim1(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CRBoolean *)) CRPredicate , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::NotEvent(IDAEvent *  arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::NotEvent(%lx)", this));
    return CreatePrim1(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *)) CRNotEvent , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AndEvent(IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AndEvent(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CREvent *)) CRAndEvent , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::OrEvent(IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::OrEvent(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CREvent *)) CROrEvent , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ThenEvent(IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ThenEvent(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CREvent *)) CRThenEvent , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_LeftButtonDown(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_LeftButtonDown(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRLeftButtonDown(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_LeftButtonUp(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_LeftButtonUp(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRLeftButtonUp(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_RightButtonDown(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_RightButtonDown(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRRightButtonDown(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_RightButtonUp(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_RightButtonUp(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRRightButtonUp(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Always(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Always(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRAlways(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Never(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Never(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRNever(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::TimerAnim(IDANumber *  arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TimerAnim(%lx)", this));
    return CreatePrim1(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CRNumber *)) CRTimer , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Timer(double arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Timer(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::CRTimer(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::AppTriggeredEvent(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AppTriggeredEvent(%lx)", this));
    return CreatePrim0(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)()) CRAppTriggeredEvent , (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ScriptCallback(BSTR arg0, IDAEvent *  arg1, BSTR arg2, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ScriptCallback(%lx)", this));

    PRIMPRECODE1(ret) ;
    CREvent * arg1VAL;
    arg1VAL = (CREvent *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::ScriptCallback(/* NOELARG */ arg0, arg1VAL, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_EmptyGeometry(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyGeometry(%lx)", this));
    return CreateVar(IID_IDAGeometry, (CRBvrPtr) CREmptyGeometry(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionGeometry(IDAGeometry *  arg0, IDAGeometry *  arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionGeometry(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRGeometry *)) CRUnionGeometry , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionGeometryArrayEx(long sizearg0, IDAGeometry *  arg0[], IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionGeometryArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRUnionGeometry(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::UnionGeometryArray(VARIANT arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionGeometryArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRGEOMETRY_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRUnionGeometry(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_EmptyImage(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyImage(%lx)", this));
    return CreateVar(IID_IDAImage, (CRBvrPtr) CREmptyImage(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DetectableEmptyImage(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DetectableEmptyImage(%lx)", this));
    return CreateVar(IID_IDAImage, (CRBvrPtr) CRDetectableEmptyImage(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SolidColorImage(IDAColor *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SolidColorImage(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *)) CRSolidColorImage , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::GradientPolygonEx(long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDAColor *  arg1[], IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientPolygonEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = ToArrayBvr(sizearg1, (IDABehavior **) arg1);
    if (arg1VAL == NULL) return Error();
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRGradientPolygon(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::GradientPolygon(VARIANT arg0, VARIANT arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientPolygon(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = SrvArrayBvr(arg1,GetPixelMode(),CRCOLOR_TYPEID);
    if (!arg1VAL) return Error();

    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRGradientPolygon(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientPolygonEx(IDAColor *  arg0,
                                    IDAColor *  arg1,
                                    long sizearg2,
                                    IDAPoint2 *  arg2[],
                                    double arg3,
                                    IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientPolygonEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg2VAL;
    arg2VAL = ToArrayBvr(sizearg2, (IDABehavior **) arg2);
    if (arg2VAL == NULL) return Error();
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientPolygon(arg0VAL, arg1VAL, arg2VAL, /* NOELARG */ arg3)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientPolygon(IDAColor *  arg0,
                                  IDAColor *  arg1,
                                  VARIANT arg2,
                                  double arg3,
                                  IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientPolygon(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg2VAL;
    arg2VAL = SrvArrayBvr(arg2,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg2VAL) return Error();

    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientPolygon(arg0VAL, arg1VAL, arg2VAL, /* NOELARG */ arg3)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientPolygonAnimEx(IDAColor *  arg0, IDAColor *  arg1, long sizearg2, IDAPoint2 *  arg2[], IDANumber *  arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientPolygonAnimEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) (::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRArrayPtr arg2VAL;
    arg2VAL = ToArrayBvr(sizearg2, (IDABehavior **) arg2);
    if (arg2VAL == NULL) return Error();
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientPolygon(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientPolygonAnim(IDAColor *  arg0, IDAColor *  arg1, VARIANT arg2, IDANumber *  arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientPolygonAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) (::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRArrayPtr arg2VAL;
    arg2VAL = SrvArrayBvr(arg2,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg2VAL) return Error();

    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientPolygon(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::GradientSquare(IDAColor *  arg0, IDAColor *  arg1, IDAColor *  arg2, IDAColor *  arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientSquare(%lx)", this));
    return CreatePrim4(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *, CRColor *, CRColor *, CRColor *)) CRGradientSquare , arg0, arg1, arg2, arg3, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::RadialGradientSquare(IDAColor *  arg0, IDAColor *  arg1, double arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientSquare(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientSquare(arg0VAL, arg1VAL, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientSquareAnim(IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientSquareAnim(%lx)", this));
    return CreatePrim3(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *, CRColor *, CRNumber *)) CRRadialGradientSquare , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::RadialGradientRegularPoly(IDAColor *  arg0, IDAColor *  arg1, double arg2, double arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientRegularPoly(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientRegularPoly(arg0VAL, arg1VAL, /* NOELARG */ arg2, /* NOELARG */ arg3)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientRegularPolyAnim(IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientRegularPolyAnim(%lx)", this));
    return CreatePrim4(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *, CRColor *, CRNumber *, CRNumber *)) CRRadialGradientRegularPoly , arg0, arg1, arg2, arg3, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::GradientHorizontal(IDAColor *  arg0, IDAColor *  arg1, double arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientHorizontal(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRGradientHorizontal(arg0VAL, arg1VAL, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::GradientHorizontalAnim(IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientHorizontalAnim(%lx)", this));
    return CreatePrim3(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *, CRColor *, CRNumber *)) CRGradientHorizontal , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::HatchHorizontal(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchHorizontal(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchHorizontal(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchHorizontalAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchHorizontalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchHorizontal(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchVertical(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchVertical(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchVertical(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchVerticalAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchVerticalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchVertical(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchForwardDiagonal(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchForwardDiagonal(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchForwardDiagonal(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchForwardDiagonalAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchForwardDiagonalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchForwardDiagonal(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchBackwardDiagonal(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchBackwardDiagonal(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchBackwardDiagonal(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchBackwardDiagonalAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchBackwardDiagonalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchBackwardDiagonal(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchCross(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchCross(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchCross(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchCrossAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchCrossAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchCross(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchDiagonalCross(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchDiagonalCross(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchDiagonalCross(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchDiagonalCrossAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchDiagonalCrossAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchDiagonalCross(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Overlay(IDAImage *  arg0, IDAImage *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Overlay(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRImage *)) CROverlay , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::OverlayArrayEx(long sizearg0, IDAImage *  arg0[], IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::OverlayArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CROverlay(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::OverlayArray(VARIANT arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::OverlayArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRIMAGE_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CROverlay(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_AmbientLight(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_AmbientLight(%lx)", this));
    return CreateVar(IID_IDAGeometry, (CRBvrPtr) CRAmbientLight(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DirectionalLight(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DirectionalLight(%lx)", this));
    return CreateVar(IID_IDAGeometry, (CRBvrPtr) CRDirectionalLight(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_PointLight(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_PointLight(%lx)", this));
    return CreateVar(IID_IDAGeometry, (CRBvrPtr) CRPointLight(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SpotLightAnim(IDANumber *  arg0, IDANumber *  arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SpotLightAnim(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRSpotLight , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SpotLight(IDANumber *  arg0, double arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SpotLight(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRSpotLight(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_DefaultLineStyle(IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DefaultLineStyle(%lx)", this));
    return CreateVar(IID_IDALineStyle, (CRBvrPtr) CRDefaultLineStyle(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EmptyLineStyle(IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyLineStyle(%lx)", this));
    return CreateVar(IID_IDALineStyle, (CRBvrPtr) CREmptyLineStyle(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_JoinStyleBevel(IDAJoinStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_JoinStyleBevel(%lx)", this));
    return CreateVar(IID_IDAJoinStyle, (CRBvrPtr) CRJoinStyleBevel(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_JoinStyleRound(IDAJoinStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_JoinStyleRound(%lx)", this));
    return CreateVar(IID_IDAJoinStyle, (CRBvrPtr) CRJoinStyleRound(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_JoinStyleMiter(IDAJoinStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_JoinStyleMiter(%lx)", this));
    return CreateVar(IID_IDAJoinStyle, (CRBvrPtr) CRJoinStyleMiter(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EndStyleFlat(IDAEndStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EndStyleFlat(%lx)", this));
    return CreateVar(IID_IDAEndStyle, (CRBvrPtr) CREndStyleFlat(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EndStyleSquare(IDAEndStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EndStyleSquare(%lx)", this));
    return CreateVar(IID_IDAEndStyle, (CRBvrPtr) CREndStyleSquare(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EndStyleRound(IDAEndStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EndStyleRound(%lx)", this));
    return CreateVar(IID_IDAEndStyle, (CRBvrPtr) CREndStyleRound(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DashStyleSolid(IDADashStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DashStyleSolid(%lx)", this));
    return CreateVar(IID_IDADashStyle, (CRBvrPtr) CRDashStyleSolid(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DashStyleDashed(IDADashStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DashStyleDashed(%lx)", this));
    return CreateVar(IID_IDADashStyle, (CRBvrPtr) CRDashStyleDashed(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DefaultMicrophone(IDAMicrophone *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DefaultMicrophone(%lx)", this));
    return CreateVar(IID_IDAMicrophone, (CRBvrPtr) CRDefaultMicrophone(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_OpaqueMatte(IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_OpaqueMatte(%lx)", this));
    return CreateVar(IID_IDAMatte, (CRBvrPtr) CROpaqueMatte(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ClearMatte(IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ClearMatte(%lx)", this));
    return CreateVar(IID_IDAMatte, (CRBvrPtr) CRClearMatte(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionMatte(IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionMatte(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRMatte *, CRMatte *)) CRUnionMatte , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::IntersectMatte(IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::IntersectMatte(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRMatte *, CRMatte *)) CRIntersectMatte , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DifferenceMatte(IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DifferenceMatte(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRMatte *, CRMatte *)) CRDifferenceMatte , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FillMatte(IDAPath2 *  arg0, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FillMatte(%lx)", this));
    return CreatePrim1(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRPath2 *)) CRFillMatte , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::TextMatte(IDAString *  arg0, IDAFontStyle *  arg1, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TextMatte(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRTextMatte , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EmptyMontage(IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyMontage(%lx)", this));
    return CreateVar(IID_IDAMontage, (CRBvrPtr) CREmptyMontage(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ImageMontage(IDAImage *  arg0, double arg1, IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImageMontage(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRImage * arg0VAL;
    arg0VAL = (CRImage *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAMontage, (CRBvrPtr) (::CRImageMontage(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ImageMontageAnim(IDAImage *  arg0, IDANumber *  arg1, IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImageMontageAnim(%lx)", this));
    return CreatePrim2(IID_IDAMontage, (CRMontage * (STDAPICALLTYPE *)(CRImage *, CRNumber *)) CRImageMontageAnim , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionMontage(IDAMontage *  arg0, IDAMontage *  arg1, IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionMontage(%lx)", this));
    return CreatePrim2(IID_IDAMontage, (CRMontage * (STDAPICALLTYPE *)(CRMontage *, CRMontage *)) CRUnionMontage , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Concat(IDAPath2 *  arg0, IDAPath2 *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Concat(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPath2 *, CRPath2 *)) CRConcat , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ConcatArrayEx(long sizearg0, IDAPath2 *  arg0[], IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ConcatArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRConcat(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ConcatArray(VARIANT arg0, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ConcatArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPATH2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRConcat(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Line(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Line(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPoint2 *, CRPoint2 *)) CRLine , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Ray(IDAPoint2 *  arg0, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Ray(%lx)", this));
    return CreatePrim1(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPoint2 *)) CRRay , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::StringPathAnim(IDAString *  arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::StringPathAnim(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRStringPath , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::StringPath(BSTR arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::StringPath(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRFontStyle * arg1VAL;
    arg1VAL = (CRFontStyle *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRStringPath(/* NOELARG */ arg0, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PolylineEx(long sizearg0, IDAPoint2 *  arg0[], IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PolylineEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPolyline(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Polyline(VARIANT arg0, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Polyline(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPolyline(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PolydrawPathEx(long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDANumber *  arg1[], IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PolydrawPathEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = ToArrayBvr(sizearg1, (IDABehavior **) arg1);
    if (arg1VAL == NULL) return Error();
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPolydrawPath(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PolydrawPath(VARIANT arg0, VARIANT arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PolydrawPath(%lx)", this));

    PRIMPRECODE1(ret);

    CRArrayPtr arg1VAL;
    void *d1 = NULL;
    unsigned int n1 = 0;
    arg1VAL = SrvArrayBvr(arg1,GetPixelMode(),CRNUMBER_TYPEID,0,ARRAYFILL_DOUBLE,&d1,&n1);
    if (!arg1VAL && !d1) return Error();

    CRArrayPtr arg0VAL;
    void *d0 = NULL;
    unsigned int n0 = 0;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID,0,ARRAYFILL_DOUBLE,&d0,&n0);
    if (!arg0VAL && !d0) return Error();

    CRBvrPtr bvr = NULL;
    if (d0 && d1) {
        bvr = (CRBvrPtr) CRPolydrawPath((double*)d0,n0,(double*)d1,n1);
    } else {
        if (arg0VAL==NULL) {
            Assert(d0);
            arg0VAL = CRCreateArray(n0, (double*)d0, CRPOINT2_TYPEID);
        }

        if (arg1VAL==NULL) {
            Assert(d1);
            arg1VAL = CRCreateArray(n1, (double*)d1, CRNUMBER_TYPEID);
        }

        bvr = (CRBvrPtr) (::CRPolydrawPath(arg0VAL, arg1VAL));
    }

    if (d0) delete d0;
    if (d1) delete d1;

    if (bvr) {
        CreateCBvr(IID_IDAPath2, bvr, (void **) ret);
    } else {
        return Error();
    }

    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ArcRadians(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ArcRadians(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRArcRadians(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ArcRadiansAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ArcRadiansAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRArcRadians(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ArcDegrees(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ArcDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRArc(/* NOELARG */ DegreesToNum(arg0), /* NOELARG */ DegreesToNum(arg1), /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PieRadians(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PieRadians(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPieRadians(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PieRadiansAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PieRadiansAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPieRadians(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PieDegrees(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PieDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPie(/* NOELARG */ DegreesToNum(arg0), /* NOELARG */ DegreesToNum(arg1), /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Oval(double arg0, double arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Oval(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CROval(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::OvalAnim(IDANumber *  arg0, IDANumber *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::OvalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CROval(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rect(double arg0, double arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rect(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRRect(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RectAnim(IDANumber *  arg0, IDANumber *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RectAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRRect(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RoundRect(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RoundRect(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRRoundRect(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelToNum(arg1), /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RoundRectAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RoundRectAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRRoundRect(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::CubicBSplinePathEx(long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDANumber *  arg1[], IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::CubicBSplinePathEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = ToArrayBvr(sizearg1, (IDABehavior **) arg1);
    if (arg1VAL == NULL) return Error();
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRCubicBSplinePath(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::CubicBSplinePath(VARIANT arg0, VARIANT arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::CubicBSplinePath(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = SrvArrayBvr(arg1,GetPixelMode(),CRNUMBER_TYPEID);
    if (!arg1VAL) return Error();

    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRCubicBSplinePath(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::TextPath(IDAString *  arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TextPath(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRTextPath , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Silence(IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Silence(%lx)", this));
    return CreateVar(IID_IDASound, (CRBvrPtr) CRSilence(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::MixArrayEx(long sizearg0, IDASound *  arg0[], IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::MixArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRMix(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::MixArray(VARIANT arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::MixArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRSOUND_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRMix(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_SinSynth(IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_SinSynth(%lx)", this));
    return CreateVar(IID_IDASound, (CRBvrPtr) CRSinSynth(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DefaultFont(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DefaultFont(%lx)", this));
    return CreateVar(IID_IDAFontStyle, (CRBvrPtr) CRDefaultFont(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FontAnim(IDAString *  arg0, IDANumber *  arg1, IDAColor *  arg2, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FontAnim(%lx)", this));
    return CreatePrim3(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRString *, CRNumber *, CRColor *)) CRFont , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Font(BSTR arg0, double arg1, IDAColor *  arg2, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Font(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg2VAL;
    arg2VAL = (CRColor *) (::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRFont(/* NOELARG */ arg0, /* NOELARG */ arg1, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::StringImageAnim(IDAString *  arg0, IDAFontStyle *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::StringImageAnim(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRStringImage , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::StringImage(BSTR arg0, IDAFontStyle *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::StringImage(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRFontStyle * arg1VAL;
    arg1VAL = (CRFontStyle *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRStringImage(/* NOELARG */ arg0, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::TextImageAnim(IDAString *  arg0, IDAFontStyle *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TextImageAnim(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRTextImage , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::TextImage(BSTR arg0, IDAFontStyle *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TextImage(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRFontStyle * arg1VAL;
    arg1VAL = (CRFontStyle *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRTextImage(/* NOELARG */ arg0, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_XVector2(IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_XVector2(%lx)", this));
    return CreateVar(IID_IDAVector2, (CRBvrPtr) CRXVector2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_YVector2(IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_YVector2(%lx)", this));
    return CreateVar(IID_IDAVector2, (CRBvrPtr) CRYVector2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ZeroVector2(IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ZeroVector2(%lx)", this));
    return CreateVar(IID_IDAVector2, (CRBvrPtr) CRZeroVector2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Origin2(IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Origin2(%lx)", this));
    return CreateVar(IID_IDAPoint2, (CRBvrPtr) CROrigin2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Vector2Anim(IDANumber *  arg0, IDANumber *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRCreateVector2(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector2(double arg0, double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRCreateVector2(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point2Anim(IDANumber *  arg0, IDANumber *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point2Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPoint2, (CRBvrPtr) (::CRCreatePoint2(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point2(double arg0, double arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPoint2, (CRBvrPtr) (::CRCreatePoint2(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector2PolarAnim(IDANumber *  arg0, IDANumber *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2PolarAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRVector2Polar(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector2Polar(double arg0, double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2Polar(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRVector2Polar(/* NOELARG */ arg0, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector2PolarDegrees(double arg0, double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2PolarDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRVector2Polar(/* NOELARG */ DegreesToNum(arg0), /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point2PolarAnim(IDANumber *  arg0, IDANumber *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point2PolarAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPoint2, (CRBvrPtr) (::CRPoint2Polar(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point2Polar(double arg0, double arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point2Polar(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPoint2, (CRBvrPtr) (::CRPoint2Polar(/* NOELARG */ arg0, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DotVector2(IDAVector2 *  arg0, IDAVector2 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DotVector2(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *, CRVector2 *)) CRDot , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::NegVector2(IDAVector2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::NegVector2(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *)) CRNeg , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubVector2(IDAVector2 *  arg0, IDAVector2 *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubVector2(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRVector2 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AddVector2(IDAVector2 *  arg0, IDAVector2 *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AddVector2(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRVector2 *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AddPoint2Vector(IDAPoint2 *  arg0, IDAVector2 *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AddPoint2Vector(%lx)", this));
    return CreatePrim2(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRPoint2 *, CRVector2 *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubPoint2Vector(IDAPoint2 *  arg0, IDAVector2 *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubPoint2Vector(%lx)", this));
    return CreatePrim2(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRPoint2 *, CRVector2 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubPoint2(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubPoint2(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRPoint2 *, CRPoint2 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DistancePoint2(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DistancePoint2(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *, CRPoint2 *)) CRDistance , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DistanceSquaredPoint2(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DistanceSquaredPoint2(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *, CRPoint2 *)) CRDistanceSquared , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_XVector3(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_XVector3(%lx)", this));
    return CreateVar(IID_IDAVector3, (CRBvrPtr) CRXVector3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_YVector3(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_YVector3(%lx)", this));
    return CreateVar(IID_IDAVector3, (CRBvrPtr) CRYVector3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ZVector3(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ZVector3(%lx)", this));
    return CreateVar(IID_IDAVector3, (CRBvrPtr) CRZVector3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ZeroVector3(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ZeroVector3(%lx)", this));
    return CreateVar(IID_IDAVector3, (CRBvrPtr) CRZeroVector3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Origin3(IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Origin3(%lx)", this));
    return CreateVar(IID_IDAPoint3, (CRBvrPtr) CROrigin3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Vector3Anim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector3Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRCreateVector3(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector3(double arg0, double arg1, double arg2, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRCreateVector3(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1), /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point3Anim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point3Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPoint3, (CRBvrPtr) (::CRCreatePoint3(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point3(double arg0, double arg1, double arg2, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPoint3, (CRBvrPtr) (::CRCreatePoint3(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1), /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector3SphericalAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector3SphericalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRVector3Spherical(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector3Spherical(double arg0, double arg1, double arg2, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector3Spherical(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRVector3Spherical(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point3SphericalAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point3SphericalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPoint3, (CRBvrPtr) (::CRPoint3Spherical(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point3Spherical(double arg0, double arg1, double arg2, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point3Spherical(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPoint3, (CRBvrPtr) (::CRPoint3Spherical(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DotVector3(IDAVector3 *  arg0, IDAVector3 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DotVector3(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *, CRVector3 *)) CRDot , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::CrossVector3(IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::CrossVector3(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRVector3 *)) CRCross , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::NegVector3(IDAVector3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::NegVector3(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *)) CRNeg , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubVector3(IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubVector3(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRVector3 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AddVector3(IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AddVector3(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRVector3 *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AddPoint3Vector(IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AddPoint3Vector(%lx)", this));
    return CreatePrim2(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRPoint3 *, CRVector3 *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubPoint3Vector(IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubPoint3Vector(%lx)", this));
    return CreatePrim2(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRPoint3 *, CRVector3 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubPoint3(IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubPoint3(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRPoint3 *, CRPoint3 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DistancePoint3(IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DistancePoint3(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *, CRPoint3 *)) CRDistance , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DistanceSquaredPoint3(IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DistanceSquaredPoint3(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *, CRPoint3 *)) CRDistanceSquared , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_IdentityTransform3(IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_IdentityTransform3(%lx)", this));
    return CreateVar(IID_IDATransform3, (CRBvrPtr) CRIdentityTransform3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Translate3Anim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTranslate3(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate3(double arg0, double arg1, double arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTranslate3(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1), /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate3Rate(double arg0, double arg1, double arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) RatePixelToNumBvr(arg2);
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RatePixelYToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RatePixelToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTranslate3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL, /* NOELARG */ arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate3Vector(IDAVector3 *  arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3Vector(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRVector3 *)) CRTranslate3 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Translate3Point(IDAPoint3 *  arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3Point(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRPoint3 *)) CRTranslate3 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale3Anim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3Anim(%lx)", this));
    return CreatePrim3(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *)) CRScale3 , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale3(double arg0, double arg1, double arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRScale3(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale3Rate(double arg0, double arg1, double arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) ScaleRateToNumBvr(arg2);
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) ScaleRateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) ScaleRateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRScale3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL, /* NOELARG */ arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale3Vector(IDAVector3 *  arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3Vector(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRVector3 *)) CRScale3 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale3UniformAnim(IDANumber *  arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3UniformAnim(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *)) CRScale3Uniform , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale3Uniform(double arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3Uniform(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRScale3Uniform(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale3UniformRate(double arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3UniformRate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) ScaleRateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRScale3Uniform(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate3Anim(IDAVector3 *  arg0, IDANumber *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRVector3 *, CRNumber *)) CRRotate3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Rotate3(IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRVector3 * arg0VAL;
    arg0VAL = (CRVector3 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRRotate3(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate3Rate(IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRVector3 * arg0VAL;
    arg0VAL = (CRVector3 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRRotate3(arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate3Degrees(IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3Degrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRVector3 * arg0VAL;
    arg0VAL = (CRVector3 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRRotate3(arg0VAL, /* NOELARG */ DegreesToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate3RateDegrees(IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3RateDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateDegreesToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRVector3 * arg0VAL;
    arg0VAL = (CRVector3 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRRotate3(arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::XShear3Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear3Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRXShear3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::XShear3(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRXShear3(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::XShear3Rate(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRXShear3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::YShear3Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear3Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRYShear3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::YShear3(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRYShear3(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::YShear3Rate(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRYShear3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ZShear3Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ZShear3Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRZShear3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ZShear3(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ZShear3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRZShear3(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ZShear3Rate(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ZShear3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRZShear3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Transform4x4AnimEx(long sizearg0, IDANumber *  arg0[], IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Transform4x4AnimEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTransform4x4(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Transform4x4Anim(VARIANT arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Transform4x4Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRNUMBER_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTransform4x4(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Compose3(IDATransform3 *  arg0, IDATransform3 *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose3(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRTransform3 *, CRTransform3 *)) CRCompose3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Compose3ArrayEx(long sizearg0, IDATransform3 *  arg0[], IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose3ArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRCompose3(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Compose3Array(VARIANT arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose3Array(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRTRANSFORM3_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRCompose3(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::LookAtFrom(IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDAVector3 *  arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::LookAtFrom(%lx)", this));
    return CreatePrim3(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRPoint3 *, CRPoint3 *, CRVector3 *)) CRLookAtFrom , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_IdentityTransform2(IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_IdentityTransform2(%lx)", this));
    return CreateVar(IID_IDATransform2, (CRBvrPtr) CRIdentityTransform2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Translate2Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRTranslate2(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate2(double arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRTranslate2(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate2Rate(double arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RatePixelYToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RatePixelToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRTranslate2(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate2Vector(IDAVector2 *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2Vector(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRVector2 *)) CRTranslate2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Translate2Point(IDAPoint2 *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2Point(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPoint2 *)) CRTranslate2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRScale2 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2(double arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRScale2(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale2Rate(double arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) ScaleRateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) ScaleRateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRScale2(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale2Vector2(IDAVector2 *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Vector2(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRVector2 *)) CRScale2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2Vector(IDAVector2 *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Vector(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRVector2 *)) CRScale2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2UniformAnim(IDANumber *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2UniformAnim(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *)) CRScale2Uniform , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2Uniform(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Uniform(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRScale2Uniform(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale2UniformRate(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2UniformRate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRScale2Uniform(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate2Anim(IDANumber *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2Anim(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *)) CRRotate2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Rotate2(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRRotate2(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate2Rate(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRRotate2(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate2Degrees(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2Degrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRRotate2Degrees(/* NOELARG */ DegreesToNum(arg0))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate2RateDegrees(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2RateDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateDegreesToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRRotate2(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::XShear2Anim(IDANumber *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear2Anim(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *)) CRXShear2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::XShear2(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRXShear2(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::XShear2Rate(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRXShear2(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::YShear2Anim(IDANumber *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear2Anim(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *)) CRYShear2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::YShear2(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRYShear2(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::YShear2Rate(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRYShear2(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Transform3x2AnimEx(long sizearg0, IDANumber *  arg0[], IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Transform3x2AnimEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRTransform3x2(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Transform3x2Anim(VARIANT arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Transform3x2Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    CRBvrPtr b;
    void *d = NULL;
    unsigned int n = 0;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRNUMBER_TYPEID,0,ARRAYFILL_DOUBLE,&d,&n);
    if (!arg0VAL && !d) return Error();
    if (d) {
        b = (CRBvrPtr) CRTransform3x2((double*)d, n);
        delete d;
    } else {
        b = (CRBvrPtr) (::CRTransform3x2(arg0VAL));
    }
    CreateCBvr(IID_IDATransform2, b, (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Compose2(IDATransform2 *  arg0, IDATransform2 *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose2(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRTransform2 *, CRTransform2 *)) CRCompose2 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Compose2ArrayEx(long sizearg0, IDATransform2 *  arg0[], IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose2ArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRCompose2(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Compose2Array(VARIANT arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose2Array(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRTRANSFORM2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRCompose2(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_ViewFrameRate(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ViewFrameRate(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRViewFrameRate(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ViewTimeDelta(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ViewTimeDelta(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRViewTimeDelta(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionMontageArrayEx(long sizearg0, IDAMontage *  arg0[], IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionMontageArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAMontage, (CRBvrPtr) (::CRUnionMontageArray(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::UnionMontageArray(VARIANT arg0, IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionMontageArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRMONTAGE_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAMontage, (CRBvrPtr) (::CRUnionMontageArray(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_EmptyColor(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyColor(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CREmptyColor(), (void **) ret)?S_OK:Error(); 
}


STDMETHODIMP
CDAStatics::RadialGradientMulticolor (VARIANT  offsets,
                                      VARIANT  colors,
                                      IDAImage ** ret)
{
    PRIMPRECODE1(ret) ;

    CRArrayPtr offsetArray;
    offsetArray = SrvArrayBvr(offsets,GetPixelMode(),CRNUMBER_TYPEID);
    if (!offsetArray) return Error();
    
    CRArrayPtr clrArray;
    clrArray = SrvArrayBvr(colors,GetPixelMode(),CRCOLOR_TYPEID);
    if (!clrArray) return Error();

    CreateCBvr(IID_IDAImage,
               (CRBvrPtr) (::CRRadialGradientMulticolor( offsetArray, clrArray)),
               (void **) ret);

    PRIMPOSTCODE1(ret) ;
}


STDMETHODIMP
CDAStatics::RadialGradientMulticolorEx (
    int       nOffsets,
    IDANumber *offsets[],
    int       nColors,
    IDAColor *colors[],
    IDAImage **ret)
{
    PRIMPRECODE1(ret) ;

    if((nOffsets != nColors) || nOffsets<=0) {
        // TODO DEFINE OR RETURN CORRECT ERROR
        return E_INVALIDARG;
    }

    
    CRArrayPtr offsetsVal;
    offsetsVal = ToArrayBvr(nOffsets, (IDABehavior **) offsets);
    if (offsetsVal == NULL) return Error();

    CRArrayPtr colorsVal;
    colorsVal = ToArrayBvr(nColors, (IDABehavior **) colors);
    if (colorsVal == NULL) return Error();


    CreateCBvr(IID_IDAImage,
               (CRBvrPtr) (::CRRadialGradientMulticolor( offsetsVal, colorsVal)),
               (void **) ret);

    PRIMPOSTCODE1(ret) ;
}



STDMETHODIMP
CDAStatics::LinearGradientMulticolor (VARIANT  offsets,
                                      VARIANT  colors,
                                      IDAImage ** ret)
{
    PRIMPRECODE1(ret) ;

    CRArrayPtr offsetArray;
    offsetArray = SrvArrayBvr(offsets,GetPixelMode(),CRNUMBER_TYPEID);
    if (!offsetArray) return Error();
    
    CRArrayPtr clrArray;
    clrArray = SrvArrayBvr(colors,GetPixelMode(),CRCOLOR_TYPEID);
    if (!clrArray) return Error();

    CreateCBvr(IID_IDAImage,
               (CRBvrPtr) (::CRLinearGradientMulticolor( offsetArray, clrArray )),
               (void **) ret);

    PRIMPOSTCODE1(ret) ;
}


STDMETHODIMP
CDAStatics::LinearGradientMulticolorEx (
    int       nOffsets,
    IDANumber *offsets[],
    int       nColors,
    IDAColor *colors[],
    IDAImage **ret)
{
    PRIMPRECODE1(ret) ;

    if((nOffsets != nColors) || nOffsets<=0) {
        // TODO DEFINE OR RETURN CORRECT ERROR
        return E_INVALIDARG;
    }

    
    CRArrayPtr offsetsVal;
    offsetsVal = ToArrayBvr(nOffsets, (IDABehavior **) offsets);
    if (offsetsVal == NULL) return Error();

    CRArrayPtr colorsVal;
    colorsVal = ToArrayBvr(nColors, (IDABehavior **) colors);
    if (colorsVal == NULL) return Error();


    CreateCBvr(IID_IDAImage,
               (CRBvrPtr) (::CRLinearGradientMulticolor( offsetsVal, colorsVal )),
               (void **) ret);

    PRIMPOSTCODE1(ret) ;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::get_VersionString
//
//  Synopsis:   Gets the current version string from src/include/version.h
//
//--------------------------------------------------------------------------

STDMETHODIMP
CDAStatics::get_VersionString(BSTR *strOut)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_VersionString(%lx)", this));
    
    CHECK_RETURN_NULL(strOut);
    
    char *v = VERSION;          // from version.h
    *strOut = A2BSTR(v);

    return (*strOut) ? S_OK : E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::put_Site
//
//  Synopsis:   Sets the site.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CDAStatics::put_Site(IDASite * pSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::put_Site(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::put_Site(%lx)",
              this, pSite));

    SetSite(pSite) ;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::get_Site
//
//  Synopsis:   Gets a site.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CDAStatics::get_Site(IDASite ** pSite)
{
    TraceTag((tagStatics,
              "CDAStatics(%lx)::get_Site()",
              this));

    CHECK_RETURN_SET_NULL(pSite);

    *pSite = GetSite() ;

    return S_OK;
}

STDMETHODIMP
CDAStatics::put_ClientSite(IOleClientSite * pSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::put_ClientSite(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::put_ClientSite(%lx)",
              this, pSite));

    SetClientSite(pSite) ;

    return S_OK;
}

STDMETHODIMP
CDAStatics::get_ClientSite(IOleClientSite ** pSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ClientSite(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::get_ClientSite()",
              this));

    CHECK_RETURN_SET_NULL(pSite);

    *pSite = GetClientSite() ;

    return S_OK;
}

STDMETHODIMP
CDAStatics::put_PixelConstructionMode(VARIANT_BOOL bMode)
{
    TraceTag((tagCOMEntry, "CDAStatics::put_PixelConstructionMode(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::put_PixelConstructionMode(%d)",
              this, bMode));

    SetPixelMode(bMode?true:false);
    
    return S_OK;
}

STDMETHODIMP
CDAStatics::get_PixelConstructionMode(VARIANT_BOOL * pbMode)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_PixelConstructionMode(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::get_PixelConstructionMode()",
              this));

    CHECK_RETURN_NULL(pbMode);

    *pbMode = GetPixelMode();

    return S_OK;
}

STDMETHODIMP
CDAStatics::NewDrawingSurface(IDADrawingSurface **pds)
{
    TraceTag((tagCOMEntry, "CDAStatics::NewDrawingSurface(%lx)", this));
    
    CHECK_RETURN_SET_NULL(pds);

    DAComObject<CDADrawingSurface> *pNew;
    DAComObject<CDADrawingSurface>::CreateInstance(&pNew);

    HRESULT hr = E_OUTOFMEMORY;
    if (pNew) {
        hr = pNew->Init(this);
        if (SUCCEEDED(hr)) {
            hr = pNew->QueryInterface(IID_IDADrawingSurface, (void **)pds);
            if (SUCCEEDED(hr))
                return S_OK;
        }
        delete pNew;
    }

    return hr;
}

IDASite *
CDAStatics::GetSite ()
{
    TraceTag((tagCOMEntry, "CDAStatics::GetSite(%lx)", this));
    
    CritSectGrabber csg(_cs);
    
    IDASite * s = _pSite;
    if (s)
        s->AddRef();
    
    return s ;
}

void
CDAStatics::SetSite (IDASite * pSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::SetSite(%lx)", this));
    
    CritSectGrabber csg(_cs);
    
    _pSite = pSite;
}

IOleClientSite *
CDAStatics::GetClientSite ()
{
    TraceTag((tagCOMEntry, "CDAStatics::GetClientSite(%lx)", this));
    
    CritSectGrabber csg(_cs);
    
    IOleClientSite * p = _pOleClientSite;
    
    if (p)
        p->AddRef();
    
    return p ;
}

void
CDAStatics::SetClientSite (IOleClientSite * pClientSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::SetClientSite(%lx)", this));
    
    CritSectGrabber csg(_cs);
    
    _pOleClientSite = pClientSite;
    delete _clientSiteURL;
    _clientSiteURL = NULL;
    _pBH.Release();

    // For now never use the bindhost
    // The problem is that we need to marshal the pointer since we use
    // it from another thread but this causes deadlock since the main
    // thread currently blocks waiting on the imports
    
#if 0
    if (pClientSite) {
        CComPtr<IServiceProvider> servProv;
        CComPtr<IBindHost> bh;
        if (SUCCEEDED(pClientSite->QueryInterface(IID_IServiceProvider,
                                                  (void **)&servProv)) &&
            SUCCEEDED(servProv->QueryService(SID_IBindHost,
                                             IID_IBindHost,
                                             (void**)&bh))) {
            _pBH = bh;
        }
    }
#endif
}

LPWSTR
CDAStatics::GetURLOfClientSite()
{
    CritSectGrabber csg(_cs);

    if (!_clientSiteURL) {
        
        DAComPtr<IHTMLDocument2> pHTMLDoc;
        DAComPtr<IHTMLElementCollection> pElementCollection;
        DAComPtr<IOleContainer> pRoot;
        
        // Fail gracefully if we don't have a client site, since not
        // all uses will.
        if (!_pOleClientSite)
            goto done;
    
        // However, if we do have a client site, we should be able
        // to get these other elements.  If we don't, assert.
        // (TODO: what's going to happen in IE3?)
        if (SUCCEEDED(_pOleClientSite->GetContainer(&pRoot))) {
            if (FAILED(pRoot->QueryInterface(IID_IHTMLDocument2,
                                             (void **)&pHTMLDoc)))
                goto done;
        }
        else {
            
            DAComPtr<IHTMLWindow2> htmlWindow;
            DAComPtr<IServiceProvider> sp;

            if (FAILED(_pOleClientSite->QueryInterface(IID_IServiceProvider,                                     
                                      (void **) &sp)))
                goto done;
            
            if( FAILED(sp->QueryService(SID_SHTMLWindow,
                                      IID_IHTMLWindow2,
                                      (void **) &htmlWindow)))
                goto done;

            if( FAILED(htmlWindow->get_document(&pHTMLDoc)))
                goto done;
        }      
        
        if (FAILED(pHTMLDoc->get_all(&pElementCollection)))
            goto done;
        
        {
            CComVariant baseName;
            baseName.vt = VT_BSTR;
            baseName.bstrVal = SysAllocString(L"BASE");

            DAComPtr<IDispatch> pDispatch;
            if (FAILED(pElementCollection->tags(baseName, &pDispatch)))
                goto done;
            
            pElementCollection.Release();
            
            if (FAILED(pDispatch->QueryInterface(IID_IHTMLElementCollection,
                                                 (void **)&pElementCollection)))
                goto done;
        }

        {
            BSTR tempBstr = NULL;
            CComVariant index;
            index.vt = VT_I2;
            index.iVal = 0;
            DAComPtr<IDispatch> pDispatch;

            if (FAILED(pElementCollection->item(index,
                                                index,
                                                &pDispatch)) ||
                !pDispatch)
            {
                if (FAILED(pHTMLDoc->get_URL(&tempBstr)))
                    goto done;
            }
            else
            {
                DAComPtr<IHTMLBaseElement> pBaseElement;
                if (FAILED(pDispatch->QueryInterface(IID_IHTMLBaseElement, (void **)&pBaseElement)))
                    goto done;
                
                if (FAILED(pBaseElement->get_href(&tempBstr)))
                    goto done;
            }

            _clientSiteURL = CopyString(tempBstr);
            SysFreeString(tempBstr);
        }
    }

  done:
    if (_clientSiteURL == NULL)
        _clientSiteURL = CopyString(L"");
        
    return _clientSiteURL;
} // CDAStatics::GetURLOfClientSite()

IBindHost*
CDAStatics::GetBindHost ()
{
    CritSectGrabber csg(_cs);
    
    IBindHost * sp = _pBH;

    if (sp)
        sp->AddRef();

    return sp;
}

void
CDAStatics::AddSyncImportSite(DWORD id)
{
    CritSectGrabber csg(_cs);

    _importList.push_back(id);
}

void
CDAStatics::RemoveSyncImportSite(DWORD id)
{
    CritSectGrabber csg(_cs);

    _importList.remove(id);
}

CRSTDAPICB_(void)
CDAStatics::SetStatusText(LPCWSTR sz)
{
    DAComPtr<IDASite> site(GetSite(), false);

    if (site) {
        BSTR bstr = SysAllocString(sz);
        if (bstr) {
            THR(site->SetStatusText(bstr));
            SysFreeString(bstr);
        }
    }
}

CRSTDAPICB_(void)
CDAStatics::ReportError(HRESULT hr,
                        LPCWSTR sz)
{
    DAComPtr<IDASite> site(GetSite(), false);

    if (site) {
        BSTR bstr = SysAllocString(sz);
        if (bstr) {
            THR(site->ReportError(hr,bstr));
            SysFreeString(bstr);
        }
    }
}

CRSTDAPICB_(void)
CDAStatics::ReportGC(bool b)
{
    DAComPtr<IDASite> site(GetSite(), false);

    if (site) {
        THR(site->ReportGC(b));
    }
}

CRBvrPtr
CDAStatics::PixelToNumBvr(double d)
{
    return GetPixelMode()?::PixelToNumBvr(d):(CRBvrPtr)CRCreateNumber(d);
}

/*
CRBvrPtr
CDAStatics::PixelToNumBvr(IDANumber * num)
{
    CRBvrPtr b = ::GetBvr(num);

    if (b)
        b = PixelToNumBvr(b);

    return b;
}
*/

CRBvrPtr
CDAStatics::RatePixelToNumBvr(double d)
{
    return RateToNumBvr(PixelToNumBvr(d));
}

CRBvrPtr
CDAStatics::PixelToNumBvr(CRBvrPtr b)
{
    return GetPixelMode()?::PixelToNumBvr(b):b;
}

double
CDAStatics::PixelToNum(double d)
{
    return GetPixelMode()?::PixelToNum(d):d;
}

CRBvrPtr
CDAStatics::PixelYToNumBvr(double d)
{
    return GetPixelMode()?::PixelYToNumBvr(d):(CRBvrPtr)CRCreateNumber(d);
}

/*
CRBvrPtr
CDAStatics::PixelYToNumBvr(IDANumber * num)
{
    CRBvrPtr b = ::GetBvr(num);

    if (b)
        b = PixelYToNumBvr(b);

    return b;
}
*/

CRBvrPtr
CDAStatics::RatePixelYToNumBvr(double d)
{
    return RateToNumBvr(PixelYToNumBvr(d));
}

CRBvrPtr
CDAStatics::PixelYToNumBvr(CRBvrPtr b)
{
    return GetPixelMode()?::PixelYToNumBvr(b):b;
}

double
CDAStatics::PixelYToNum(double d)
{
    return GetPixelMode()?::PixelYToNum(d):d;
}

STDMETHODIMP
CDAStaticsFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                REFIID riid,
                                void ** ppv)
{
    if (ppv)
        *ppv = NULL;
    
    DAComObject<CDAStatics>* pNew;

    DAComObject<CDAStatics>::CreateInstance(&pNew);

    if (pNew) {
        HRESULT hr = pNew->QueryInterface(riid, ppv);
            
        if (hr) {
            delete pNew;
            return hr;
        } else {
            CRAddSite(pNew);

            Assert(pNew->m_dwRef == 2);
        
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\exc\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

// Disable warning for exception unwind
#pragma warning(disable:4530)

#include "include/headers.h"
#include <dartapi.h>
#include "privinc/mutex.h"
#include "privinc/comutil.h"
#include "privinc/server.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\noexc\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

// Disable warning for exception unwind
#pragma warning(disable:4530)

#include "include/headers.h"
#include <danim.h>
#include <dartapi.h>
#include "privinc/mutex.h"
#include "privinc/comutil.h"
#include "privinc/server.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\server\view.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of views.
    TODO: This file needs to be broken up and lots of code factoring.

*******************************************************************************/


#include "headers.h"
#include <ocmm.h>
#include "context.h"
#include "view.h"
#include "privinc/resource.h"
#include "backend/values.h"
#include "backend/timetran.h"
#include "backend/gc.h"
#include "privinc/probe.h"
#include "privinc/snddev.h"
#include "privinc/backend.h"
#include "privinc/util.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "backend/jaxaimpl.h"
#include "backend/sprite.h"
#include "privinc/debug.h"
#include "privinc/dddevice.h"
#include "privinc/opt.h"
#include "include/appelles/hacks.h"
#include "privinc/vec2i.h"
#include "privinc/spriteThread.h"
#include "backend/sndbvr.h"

#if DEVELOPER_DEBUG
extern "C" CRSTDAPI_(DWORD) GetTotalMemory();
#endif

extern bool spritify;
extern bool bShowFPS;           // flag for showing the frame rate.

#if PRODUCT_PROF
#include "../../../tools/x86/icecap/icapexp.h"
#endif /* PRODUCT_PROF */

#define BOGUS_SOUND_CLASS "DANIMHiddenSoundWindowClass"

#ifdef _DEBUG
extern "C" void PrintObj(GCBase* b);

DeclareTag(tagIndicateRBConst, "Optimizations", "ack if view is const");
DeclareTag(tagDisableRBConst, "Optimizations", "disable checking rbconst");
DeclareTag(tagDisableDirtyRects, "Optimizations", "disable dirty rects");
DeclareTag(tagDisableRendering, "Optimizations", "disable rendering");

void PrintRect(RECT & r,char * str = "")
{
    char buf[2048];
    sprintf (buf,
             "%s: left - %d, top - %d, right - %d, bottom - %d\n",
             str,
             r.left,r.top,r.right,r.bottom);

    printf (buf);
    OutputDebugString(buf);
}
#endif /* _DEBUG */

#if PERFORMANCE_REPORTING
static DWORD g_dllStartTime = 0;
static DWORD g_prevAvailMemory = 0;
#endif

// Couldn't use template because only differ in return type...
inline Image *ValImage(AxAValue v)
{
    Assert(dynamic_cast<Image *>(v) != NULL);

    return ((Image*) v);
}


inline Sound *ValSound(AxAValue v)
{
    Assert(dynamic_cast<Sound *>(v) != NULL);

    return ((Sound*) v);
}

const DWORD ReportThreshold = 10 ;

#if _DEBUGMEM
_CrtMemState diff, oldState, newState;
#endif


// =========================================================
// View Implementation
// =========================================================

View::View ()
:
#if PERFORMANCE_REPORTING
  _sampleTime(0),
  _pickTime(0),
  _gcTime(0),
  _numSamples(0),
  _renderTime(0),
  _viewStartTime(GetTickCount()),
#endif
  _FPSNumSamples(0),
  _FPSLastReportTime(0),
  _FPS(0),
  _numFrames(0),
  _lastRenderingTime(0),
  _lastReportTime(0),
  _renderTimeIdx(0),
  _totalTime(0),
  _sndPerf(NULL),
  _imgPerf(NULL),
  _sndVal(NULL),
  _imgVal(NULL),
  _imgForQueryHitPt(NULL),
  _firstRendering(true),
  _lastSampleTime(0.0),
  _lastSystemTime(0),
  _currentSystemTime(0),
  _currentSampleTime(0.0),
  _someEventHappened(false),
  _isRBConst(false),
  _toPaint(3),
  _repaintCalled(false),
  _bogusSoundHwnd(NULL),
  _imageDev(NULL),
  _soundDev(NULL),
  _devInited(FALSE),
  _runId(0),
  _pickEvents(0),
  _sampleHeap(NULL),
  _renderHeap(NULL),
  _queryHitPointHeap(NULL),
  _rbHeap(NULL),
  _isStarted(false),
  _soundSprite(NULL),
  _rmSound(NULL),
  _spriteThread(NULL),
  _importEvent(true, true),
  _lastRBId(0),
  _lastSampleId(PERF_CREATION_INITIAL_LAST_SAMPLE_ID),
  _sndList(NULL),
  _sampleId(-1),
  _dirtyRectsDisabled(false),
  _lastCondsCheckTime(0),
  _modelStartTime(0),
  _emptyImageSoFar(true),
  _firstSample(true)
{
    _targetPackage.Reset();
    _oldTargetPackage.Reset();

#ifdef _DEBUG
    bool trackit = false;

    if (trackit) {
#if _DEBUGMEM
        _CrtMemCheckpoint(&oldState);
#endif
    }
#endif

    // We're not in the view set yet, this can make _genList
    // inconsistent, that is, a GC can come in and remove DXBaseObject
    // w/o letting this view know as it's not in the set and will not
    // get iterated.

    //PopulateDXBaseObjects();
}


View::~View ()
{
    Stop();

#ifdef _DEBUG
    bool trackit = false;

    if (trackit) {
        //GarbageCollect(true, true);
        Sleep(1000);                // wait for GC to finish
#if _DEBUGMEM
        _CrtMemCheckpoint(&newState);
        _CrtMemDifference(&diff, &oldState, &newState);
        _CrtMemDumpStatistics(&diff);
        _CrtMemDumpAllObjectsSince(&oldState);
#endif
    }
#endif
}

HWND
View::CreateViewWindow()
{
    {
        WNDCLASS wndclass;

        memset(&wndclass, 0, sizeof(WNDCLASS));
        wndclass.style          = 0;
        wndclass.lpfnWndProc    = DefWindowProc;
        wndclass.hInstance      = hInst;
        wndclass.hCursor        = NULL;
        wndclass.hbrBackground  = NULL;
        wndclass.lpszClassName  = BOGUS_SOUND_CLASS;

        RegisterClass(&wndclass) ;
    }

    return ::CreateWindow (BOGUS_SOUND_CLASS,
                           "danim hidden sound window",
                           0,0,0,0,0,NULL,NULL,hInst,NULL);
}


void
View::CreateDevices(bool needSoundDevice, bool needImageDevice)
{
    if (!_devInited) {

        // If we don't need a sound, simply don't create the sound
        // device.

        if(needSoundDevice && IsWindowless()) {
            // for version 2 replace CreateViewWindow with GetDesktopWindow()

            _bogusSoundHwnd = CreateViewWindow();  // window to make dsound happy
            _soundDev = CreateSoundDevice(_bogusSoundHwnd, 0.0);
        }

        if (needImageDevice) {
            _imageDev = CreateImageDisplayDevice();
        }

        if(needSoundDevice && !IsWindowless()) {
            // make sure they are not lying to us w/a null hwnd!
            if(!_targetPackage.GetHWND())
                RaiseException_UserError(E_INVALIDARG, IDS_ERR_SRV_INVALID_DEVICE);

            _soundDev = CreateSoundDevice(_targetPackage.GetHWND(), 0.0);
        }

        _devInited = TRUE ;
    }
}


void
View::DestroyDevices()
{
    if (_imageDev) {
        DestroyImageDisplayDevice(_imageDev);
        _imageDev = NULL ;
    }

    if (_soundDev) {
        DestroySoundDirectDev(_soundDev);
        _soundDev = NULL ;
    }

    if (_bogusSoundHwnd) {
        DestroyWindow(_bogusSoundHwnd) ;
        _bogusSoundHwnd = NULL ;
    }

    _targetPackage.Reset();
    _oldTargetPackage.Reset();

    _devInited = FALSE ;
}

void
View::SetTargetOnDevices()
{
    if(!_doTargetUpdate) return;

    Assert( _imageDev );

    // Is the current target different from the old target ?
    if( _oldTargetPackage.IsValid() &&
        _imageDev->TargetsDiffer(_targetPackage, _oldTargetPackage) ) {

        TraceTag((tagWarning,
                  "View::SetTargetOnDevices() recreating "
                  "viewport due to target type change (type or surface depth changed)"));

        DestroyImageDisplayDevice(_imageDev);
        _imageDev = CreateImageDisplayDevice();
        _oldTargetPackage.Copy( _targetPackage );
    }


    HDC parentDC = _targetPackage.GetParentHDC();
    bool reinterpCoords = false;
    if( parentDC ) {
        Assert( _targetPackage.IsDdsurf() );
        reinterpCoords = true;
    }


    if( _targetPackage._IsValid_RawViewportRect() ) {

        RECT rcDeviceBounds = _targetPackage._GetRawViewportRect();
        if( reinterpCoords ) {
            _targetPackage.SetAlreadyOffset();
            ::LPtoDP(parentDC, (POINT *) &rcDeviceBounds, 2);
        }
        _targetPackage.SetViewportRect( rcDeviceBounds );
    }

    if( _targetPackage._IsValid_RawClipRect() ) {

        RECT rcDeviceClipBnds = _targetPackage._GetRawClipRect();
        if( reinterpCoords ) {
            ::LPtoDP(parentDC, (POINT *) &rcDeviceClipBnds, 2);
        }
        _targetPackage.SetClipRect( rcDeviceClipBnds );
    }


    bool success = false;
    {
        targetPackage_t _tPackageCopy;
        _tPackageCopy.Copy(_targetPackage);

        success = _imageDev->SetTargetPackage( &_tPackageCopy );
    }

    if (success) {
        _doTargetUpdate = false;
        _oldTargetPackage.Copy( _targetPackage );
    }
}

void
View::RenderSound(AxAValue snd)
{
#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&oldState);
#endif
#endif

#if PERFORMANCE_REPORTING
    DWORD startTime = GetPerfTickCount();
#endif

    if (_soundDev && _sndVal) {
        if(_soundDev->AudioDead())
            return;  // don't do anything, stub audio out

        __try {
            DisplaySound(ValSound(snd), _soundDev);
            _sndList->Update(_soundDev);
        }
        __except( HANDLE_ANY_DA_EXCEPTION )  {
            _soundDev->SetAudioDead();

            TraceTag((tagError, "RenderSound - continue without sound."));
        }
    }

#if PERFORMANCE_REPORTING
    DWORD renderTime = GetPerfTickCount() - startTime;
    Assert(GetPerfTickCount() >= startTime);

    _renderTime += renderTime;

    _totalTime += renderTime;
#endif

#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif
}

void
View::RenderImage(AxAValue img)
{

    HRESULT hr;

#if _DEBUG
    if (IsTagEnabled(tagDisableRendering))
        return;
#endif

    _imageDev->ResetContext();
    RenderImageOnDevice(_imageDev, ValImage(img), _dirtyRectState);

#if _DEBUG
    static bool showit = false;
    if (showit && _targetPackage.IsDdsurf()) {
        showme2(_targetPackage.GetIDDSurface());
    }
#endif

}

void
View::DisableDirtyRects()
{
    // Turn off dirty rects by clearing them and computing the merged
    // boxes of the cleared state (which will be accessed by
    // GetInvalidatedRects).
    _dirtyRectsDisabled = true;
    _dirtyRectState.Clear();
    _dirtyRectState.ComputeMergedBoxes();
}

void
View::DoPicking(AxAValue v, Time time)
{
#if PERFORMANCE_REPORTING
    DWORD pickTime = GetPerfTickCount();
#endif

#if _DEBUG
    if (IsTagEnabled(tagPickOptOff) || (_pickEvents > 0))
#else
    if (_pickEvents > 0)
#endif
        _pickq.GatherPicks(ValImage(v), time, _lastSampleTime);

#if PERFORMANCE_REPORTING
    _pickTime  += GetPerfTickCount() - pickTime;
#endif
}

#if PERFORMANCE_REPORTING
extern int gcStat;
extern BOOL jitterStat;
extern BOOL heapSizeStat;
extern BOOL dxStat;

static void
PrintMeasure(DWORD lastMeaTime, DWORD& startGCTime, double& gTime)
{
    double tmp = Tick2Sec(GetPerfTickCount() - lastMeaTime);
    gTime += tmp;

    PerfPrintLine ("%g s", tmp);

    startGCTime = GetPerfTickCount();
}


static void
AfterGCPrint(char* msg, DWORD& lastMeaTime, DWORD& gcTicks, DWORD startGCTime)
{
    gcTicks += GetPerfTickCount() - startGCTime;

    if (gcStat)
        GCPrintStat(GetCurrentGCList(), GetCurrentGCRoots());

    PerfPrintLine(msg);

    lastMeaTime = GetPerfTickCount();
}

#endif /* PERFORMANCE_REPORTING */

void
View::RunBvrs(Time startGlobalTime, TimeXform tt)
{
    // Need to protect the perform call

    GC_CREATE_BEGIN;

    GCRoots globalRoots = GetCurrentGCRoots();

    RunList::iterator i;

    TimeXform gtt = NULL;

    if ((tt==NULL) && !_toRunBvrs.empty()) {
        tt = ShiftTimeXform(startGlobalTime);
    }

    while (!_toRunBvrs.empty()) {
        i = _toRunBvrs.begin();
        DWORD id = (*i).first;
        Bvr b = (*i).second.first;
        bool continueTimeline = (*i).second.second;

        Assert(b);

        _toRunBvrs.erase(i);

        Perf perf;

        if (continueTimeline) {
            if (gtt==NULL) {
                gtt = ShiftTimeXform(_modelStartTime);
            }
            perf = ::Perform(b, PerfParam(_modelStartTime, gtt));
        } else {
            perf = ::Perform(b, PerfParam(startGlobalTime, tt));
        }
        GCAddToRoots(perf, globalRoots);
        GCRemoveFromRoots(b, globalRoots);
        _runningBvrs[id] = perf;
    }

    Assert(_toRunBvrs.size() == 0);

    GC_CREATE_END;
}

static void
GCAddPerfListToRoots(list<Perf>& lst, GCRoots roots)
{
    for (list<Perf>::iterator j = lst.begin();
         j != lst.end(); j++) {
        GCAddToRoots(*j, roots);
    }
}

void
View::Start(Bvr img, Bvr snd, Time startTime)
{
    _sndList = NEW SoundInstanceList();
    ClearPerfTimeXformCache();

    // Should never have imports pending

    Assert (!ImportsPending());

#if 0
#if _DEBUGMEM
        _CrtMemCheckpoint(&oldState);
#endif
#endif /* 0 */

    DynamicHeapPusher dhp(GetSystemHeap());

    _isStarted = true;
    _emptyImageSoFar = true;
    _firstSample = true;

    _modelStartTime = startTime;

    Assert ((_sampleHeap==NULL) && (_renderHeap==NULL));
    _sampleHeap = &TransientHeap("Sample Heap", 2000);
    _renderHeap = &TransientHeap("Render Heap", 2000);
    _queryHitPointHeap = &TransientHeap("QueryHitPoint Heap", 200);
    _rbHeap = &TransientHeap("RB Heap", 2000);

    // Only need to create a sound device
    bool needSoundDevice;
    if (!snd) {
        needSoundDevice = false;
    } else {
        ConstParam cp;
        Sound *constSound = SAFE_CAST(Sound *, snd->GetConst(cp));
        needSoundDevice = (!constSound || constSound != silence);
    }

    CreateDevices (needSoundDevice, img != NULL) ;

    if (img) {
        SetTargetOnDevices() ;
    }

    GCRoots globalRoots = GetCurrentGCRoots() ;

    // Need to protect everything including TimeXform

#if PERFORMANCE_REPORTING
    double evaluationTime = 0.0;
    DWORD gcTicks = 0;
    DWORD lastMeaTime = GetPerfTickCount();
    DWORD startGCTime = GetPerfTickCount();
#endif

#if PERFORMANCE_REPORTING
    AfterGCPrint("*** Performing...", lastMeaTime, gcTicks, startGCTime);

    _lastReportTime = GetPerfTickCount();
#endif

    GC_CREATE_BEGIN;

    TimeXform tt = ShiftTimeXform(startTime);

    RunBvrs(startTime, tt);

    if (img) {
        // Push the pre-rendering performances on the roots
        _imgPerf = ::Perform(img, PerfParam(startTime, tt));
        GCAddToRoots(_imgPerf, globalRoots);
    }

    if (snd) {

        if(spritify)  { // new retained mode code
            /*
              SpriteCtx *sCtx = NewSoundCtx(_soundDev);

              Assert(!_soundSprite); // verify _soundSprite, _rmSound not in use
              Assert(!_rmSound);
              _rmSound = snd->Spritify(PerfParam(startTime, tt), sCtx, &_soundSprite);
              Assert(_rmSound);

              sCtx->Release();


              // setup the spriteThread (XXX Need to find a good place for this)
              _spriteThread = NEW SpriteThread(_soundDev, _rmSound);
            */
            //GCAddToRoots(_rmSound, globalRoots);
        } else {
            _sndPerf = ::Perform(snd, PerfParam(startTime, tt));
            GCAddToRoots(_sndPerf, globalRoots);
        }
    }

    GC_CREATE_END;

#if PERFORMANCE_REPORTING
    PrintMeasure(lastMeaTime, startGCTime, evaluationTime);
#endif

#if PERFORMANCE_REPORTING
    AfterGCPrint("*** Total GC Time...", lastMeaTime, gcTicks, startGCTime);
    double tmp = Tick2Sec(gcTicks);

    PerfPrintLine ("%g s", tmp);
#endif

    {
        // force a dynamic constant calculation on first frame, can't
        // do it here as some of the imports may not be ready.
        _someEventHappened = true;

        /*
        DynamicHeapPusher h(GetGCHeap());

        _lastRBId = NewSampleId();
        Param p(startTime);
        RBConstParam pp(_lastRBId, p, &_events);

        if (_imgPerf->GetRBConst(pp))
            _isRBConst = TRUE;

        GCAddPerfListToRoots(_events, globalRoots);

        TraceTag((tagDCFoldTrace,
                  "View::Start %d events to watch", _events.size()));
                  */
    }

    ClearPerfTimeXformCache();

    GarbageCollect();

    _currentSampleTime = startTime;
    _lastSystemTime = _FPSLastReportTime = GetPerfTickCount();
}

void
ClearPerfList(list<Perf>& lst, GCRoots roots)
{
    for (list<Perf>::iterator j = lst.begin(); j != lst.end(); j++) {
        GCRemoveFromRoots(*j, roots);
    }

    lst.erase(lst.begin(), lst.end());
}

#define DELETENULL(p)      delete p; p = NULL;

template<class T>
inline void RemoveFromRootsNULL(T& x, GCRoots roots)
{
    if (x) {
        GCRemoveFromRoots(x, roots);
        x = NULL;
    }
}


void
View::Stop()
{
    DynamicHeapPusher dhp(GetSystemHeap());

    // Remove the list of imports pending

    ClearImportList();

    GCRoots roots = GetCurrentGCRoots();

    for (RunningList::iterator i = _runningBvrs.begin();
         i != _runningBvrs.end(); i++) {
        GCRemoveFromRoots((*i).second, roots);
    }

    _runningBvrs.erase(_runningBvrs.begin(), _runningBvrs.end());

    RemoveFromRootsNULL(_imgPerf, roots); // XXX are these order critical?

    if (spritify) {
        //RemoveFromRootsNULL(_rmSound, roots);
    } else
        RemoveFromRootsNULL(_sndPerf, roots);

    RemoveFromRootsNULL(_imgVal, roots);
    RemoveFromRootsNULL(_sndVal, roots);
    RemoveFromRootsNULL(_imgForQueryHitPt, roots);

    ClearPerfList(_events, roots);
    ClearPerfList(_changeables, roots);
    ClearPerfList(_conditionals, roots);

    delete _sndList;
    _sndList = NULL;

    // GarbageCollect(true);       // force GC

#if _DEBUG
    // Somehow suspend in the debugger doesn't work, this
    // instrumentation code is there for possible manual suspension..
    bool debug = false;

    while (debug) {
        Sleep(1000);
    }
#endif

    DestroyDevices();

    DELETENULL(_sampleHeap);
    DELETENULL(_renderHeap);
    DELETENULL(_queryHitPointHeap);
    DELETENULL(_rbHeap);

    GarbageCollect(true);       // force GC (try to do this AFTER dest dev)

    _isStarted = false;

#if 0
#if _DEBUGMEM
        _CrtMemCheckpoint(&newState);
        _CrtMemDifference(&diff, &oldState, &newState);
        _CrtMemDumpStatistics(&diff);
        _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif
}


void
View::Pause()
{
    if (IsStarted())
    {
        Assert(_sndList);
        //Assert(_soundDev);  // Assert seems unnecessary.

        _sndList->Pause();
        _sndList->Update(_soundDev); // force an update to propagate the pause
    }
}


void
View::Resume()
{
    if (IsStarted())
    {
        Assert(_sndList);
        _sndList->Resume();
    }
}


DWORD View::AddBvrToRun(Bvr bvrToRun, bool continueTimeline)
{
    DynamicHeapPusher dhp(GetSystemHeap());
// Remove since causes other problems
//    CatchWin32FaultCleanup cwfc;

    Assert(bvrToRun);

    GCRoots globalRoots = GetCurrentGCRoots() ;

    ++_runId;

    if (_toRunBvrs[_runId].first)
        GCRemoveFromRoots(_toRunBvrs[_runId].first, globalRoots);

    _toRunBvrs[_runId].first = bvrToRun;
    _toRunBvrs[_runId].second = continueTimeline;


    GC_CREATE_BEGIN;
    GCAddToRoots(bvrToRun, globalRoots);
    GC_CREATE_END;

    return _runId;
}

void View::RemoveRunningBvr(DWORD id)
{
    GCRoots globalRoots = GetCurrentGCRoots();

    RunList::iterator r = _toRunBvrs.find(id);

    if (r != _toRunBvrs.end()) {
        GC_CREATE_BEGIN;
        GCRemoveFromRoots((*r).second.first, globalRoots);
        GC_CREATE_END;
        _toRunBvrs.erase(r);
        return;
    }

    RunningList::iterator n = _runningBvrs.find(id);

    if (n != _runningBvrs.end()) {
        GC_CREATE_BEGIN;
        GCRemoveFromRoots((*n).second, globalRoots);
        GC_CREATE_END;
        _runningBvrs.erase(n);
        return;
    }

    RaiseException_UserError(E_INVALIDARG,
                       IDS_ERR_SRV_INVALID_RUNBVRID,
                       id);
}

void
View::SetInvalid (LONG left, LONG top, LONG right, LONG bottom)
{
    RECT r = {left, top, right, bottom};
    _targetPackage.SetRawInvalidRect( r );
    _doTargetUpdate = true;
}


void View::Repaint()
{
    _dirtyRectState.Clear();

    // Set this up so that the next Tick() will return that rendering
    // is required.
    _repaintCalled = true;
}


// Query against the current established sample by calling
// PerformPicking.
//
// TODO: Lots of optimizations possible here, since
// picking may be invoked twice, once during sampling, and once here
// during QueryHitPoint.  The thing to do is to stash off the results
// of one or the other, and cache the point for which those results
// were generated.  This, in conjunction with a serial number for each
// sampleval, will let us share the results between the two different
// pick traversals if the point is the same.
Image *View::QueryHitPointWcPt(LPCRECT prcBounds,
                               POINT ptLoc,
                               Point2Value& wcPt)
{
    if (_imgForQueryHitPt) {

        // Convert into coords relative to the bounds.  They come in
        // relative to the container.
        int localX = ptLoc.x - prcBounds->left;
        int localY = ptLoc.y - prcBounds->top;

        // Turn rawMousePos into wcMousePos.  Can't use
        // PixelPos2wcPos, because it looks for a "current" device, of
        // which there are none.  Use prcBounds instead to figure it
        // out.
        int centerXOffset =
            (prcBounds->right - prcBounds->left) / 2;

        int centerYOffset =
            (prcBounds->bottom - prcBounds->top) / 2;

        int centeredX = localX - centerXOffset;
        int centeredY = centerYOffset - localY; // flip orientation

        //  Convert to meters
        wcPt.x = (double) centeredX / ViewerResolution();
        wcPt.y = (double) centeredY / ViewerResolution();

        return ValImage(_imgForQueryHitPt);
    }

    return NULL;
}

#if DEVELOPER_DEBUG
extern bool GCIsInRoots(GCBase *ptr, GCRoots r);
#endif DEVELOPER_DEBUG

bool View::QueryHitPoint(DWORD dwAspect,
                         LPCRECT prcBounds,
                         POINT ptLoc,
                         LONG lCloseHint)
{
    Point2Value wcPt;
    Image *img = QueryHitPointWcPt(prcBounds, ptLoc, wcPt);

    if (img) {

        Assert(GCIsInRoots(img, GetCurrentGCRoots()));

        // Use special transient heap for stuff allocated during
        // QueryHitPoint.  Free data from call to call, since it's no
        // longer needed.  Note that if we ever optimize as described
        // above, this will need to be reevaluated.
        GetQueryHitPointHeap().Reset();
        DynamicHeapPusher dhp(GetQueryHitPointHeap());

        bool bRet;

        GC_CREATE_BEGIN;
        bRet = PerformPicking(img, &wcPt, false, 0, 0);
        GC_CREATE_END;

        return bRet;
    }

    return false;
}

LONG View::QueryHitPointEx(LONG s,
                           DWORD_PTR *userIds,
                           double *points,
                           LPCRECT prcBounds,
                           POINT ptLoc)
{
    Point2Value wcPt;
    Image *img = QueryHitPointWcPt(prcBounds, ptLoc, wcPt);

    if (img) {
        Assert(GCIsInRoots(img, GetCurrentGCRoots()));

        GetQueryHitPointHeap().Reset();
        DynamicHeapPusher dhp(GetQueryHitPointHeap());

        LONG actualHits = 0;

        GC_CREATE_BEGIN;
        PerformPicking(img,
                       &wcPt,
                       false,
                       _currentSampleTime,
                       _lastSystemTime,
                       s,
                       userIds,
                       points,
                       &actualHits);

        GC_CREATE_END;

        return actualHits;
    }

    return 0;
}

DeclareTag(tagGetInvalidatedRects, "Optimizations", "GetInvalidatedRects trace");

LONG View::GetInvalidatedRects(DWORD flags,
                               LONG  size,
                               RECT *pRects)
{
    vector<Bbox2> *pBoxes;
    int boxCount = _dirtyRectState.GetMergedBoxes(&pBoxes);

    if (pRects && boxCount>0 && (GetImageDev() != NULL)) {

        int toFill = size < boxCount ? size : boxCount;

        DirectDrawImageDevice *imgDev;

        imgDev = GetImageDev()->GetImageRenderer();

        int w = GetImageDev()->Width();
        int h = GetImageDev()->Height();

        // Note that these may extend outside of the target, but they
        // *do* represent the pixel values of the image itself.

        TraceTag((tagGetInvalidatedRects,
                  "Filling %d rects of %d",
                  toFill, boxCount));

        for (int i = 0; i < boxCount; i++) {

            Bbox2 box = (*pBoxes)[i];

            RECT r;
            // Compare contents...
            if (box == UniverseBbox2) {

                SetRect(&r, 0, 0, w, h);

            } else {

                imgDev->DoDestRectScale(&r,
                                        imgDev->GetResolution(),
                                        box,
                                        NULL);

                if (r.top < 0)
                    r.top = 0;
                if (r.left < 0)
                    r.left = 0;

                if (r.bottom > h)
                    r.bottom = h;
                if (r.right > w)
                    r.right = w;

            }

            if (i < toFill)
            {
                CopyRect(&pRects[i], &r);
            }
            else
            {
                // We ran out of boxes to fill - union the current box
                // into the previous one
                UnionRect(&pRects[toFill - 1], &pRects[toFill - 1], &r);
            }

            TraceTag((tagGetInvalidatedRects,
                      "Rect %d: (%d,%d) -> (%d,%d)",
                      i,
                      r.left, r.top,
                      r.right, r.bottom));

        }

    }

    return boxCount;
}

#ifdef _DEBUG
// For use with QuickWatch during debugging.
int PerfPrint(Perf p)
{
    cout << p;
    cout.flush();
    return 1;
}
#endif

#if DEVELOPER_DEBUG
#define GET_SIZE(var, heap)                  \
        size_t var = heap.BytesUsed();
#endif

DeclareTag(tagPerfStats, "Performance", "Disable Performance Stats");

// don't ifdef ReportPerformance() audio timetransform inferencing needs it!
void View::ReportPerformance()
{
    DWORD totalTicks = GetPerfTickCount() - _lastReportTime;

    Real avgFrameLength, avg, avgVar, minVar, maxVar;
    GetRenderingTimeStats(&avg, &avgFrameLength, &avgVar, &maxVar, &minVar);
    //_framePeriod = avgFrameLength;
    _framePeriod = avg; // used in LeafSound::Render()

#if _DEBUG
    if (IsTagEnabled(tagPerfStats)) return;
#endif

#if !_DEBUG && !PERFORMANCE_REPORTING
    if(bShowFPS && (totalTicks > ReportThreshold * perfFrequency)) {
        char buf[256];
        _snprintf(buf,
                  ARRAY_SIZE(buf),
                  "DA(%p,%d) %4.3g fps \n",
                  this,
                  _targetPackage.GetTargetType(),
                  ((double) _numFrames * perfFrequency) /
                  ((double) totalTicks));
        OutputDebugString(buf);

        _numFrames=0;
        _lastReportTime = GetPerfTickCount () ;
    }

#endif


#if PERFORMANCE_REPORTING
    if (totalTicks > ReportThreshold * perfFrequency) {

        PerfPrintLine();

        ULONG ddrawRender = _timers.ddrawTimer.Ticks();
        ULONG gdiRender = _timers.gdiTimer.Ticks();
        ULONG dx2dRender = _timers.dx2dTimer.Ticks();
        ULONG alphaRender = _timers.alphaTimer.Ticks();
        ULONG d3dRender = _timers.d3dTimer.Ticks();
        ULONG dsoundRender = _timers.dsoundTimer.Ticks();
        ULONG dxxfRender = _timers.dxxformTimer.Ticks();

        ULONG renderTime_NonDA =
            ddrawRender +
            gdiRender +
            dx2dRender +
            alphaRender +
            d3dRender +
            dsoundRender +
            dxxfRender;

        ULONG renderTime_DA = _renderTime - renderTime_NonDA;

        PerfPrintf("DA(%lx,%d) %4.3g fps %4.3g ticks/s %4.3gs ",
                   this,
                   _targetPackage.GetTargetType(),
                   ((double) _numFrames * perfFrequency) /
                   ((double) totalTicks),
                   ((double) _numSamples * perfFrequency) /
                   ((double) totalTicks),
                   (double) _totalTime / (double) perfFrequency);
        PerfPrintf("%4.3g%% sample  ",
                   100 * ((double) _sampleTime) / ((double) _totalTime));
        PerfPrintf("%5.3g%% DA render  ",
                   100 * ((double) renderTime_DA) / ((double) _totalTime));
        PerfPrintf("%5.3g%% non-DA render  ",
                   100 * ((double) renderTime_NonDA) / ((double) _totalTime));
        PerfPrintf("%5.3g%% pick  ",
                   100 * ((double)_pickTime) / ((double) _totalTime));
        PerfPrintf("%5.3g%% GC",
                   100 * ((double) _gcTime) / ((double) _totalTime));
        PerfPrintLine();

        if(dxStat) {
            PerfPrintf("-- nonDA Render: ");

            double dblTotal = (double)(renderTime_NonDA);

            if (dblTotal > 0)
            {
                PerfPrintf("%5.3g%% ddraw  ",
                           100 * ((double) ddrawRender) / dblTotal);

                PerfPrintf("%5.3g%% gdi  ",
                           100 * ((double) gdiRender) / dblTotal);

                PerfPrintf("%5.3g%% dx2d  ",
                           100 * ((double) dx2dRender) / dblTotal);

                PerfPrintf("%5.3g%% alpha  ",
                           100 * ((double) alphaRender) / dblTotal);

                PerfPrintf("%5.3g%% d3d  ",
                           100 * ((double) d3dRender) / dblTotal);

                PerfPrintf("%5.3g%% dxtrans ",
                           100 * ((double) dxxfRender) / dblTotal);

                PerfPrintf("%5.3g%% dSound  ",
                           100 * ((double) dsoundRender) / dblTotal);

                PerfPrintf("%5.3g%% custom  ",
                           100 * ((double) _timers.customTimer.Ticks()) / dblTotal);

                PerfPrintLine();
            }
        }

#if DEVELOPER_DEBUG

        if (heapSizeStat) {
            GET_SIZE(size1, (*_sampleHeap));
            GET_SIZE(size2, GetGCHeap());
            GET_SIZE(size3, GetSystemHeap());
            GET_SIZE(size4, (*_renderHeap));
            PerfPrintf("      Sample, Val GC, System, Render, Total sizes in KB:");
            PerfPrintLine("%d, %d, %d, %d = %d",
                          size1/1024,
                          size2/1024,
                          size3/1024,
                          size4/1024,
                          (size1+size2+size3+size4)/1024);

            PerfPrintLine("      Total Memory used by DA - %d Kb",
                          GetTotalMemory() / 1024);
        }

#endif /* _DEBUG */

        MEMORYSTATUS memstat;
        GlobalMemoryStatus(&memstat);
        DWORD availPhysK = memstat.dwAvailPhys / 1024;
        DWORD availPageK = memstat.dwAvailPageFile / 1024;
        DWORD sum = (memstat.dwAvailPhys + memstat.dwAvailPageFile) / 1024;
        PerfPrintf("      Mem Avail: %dK Phys + \t%dK Page =\t%dK\tDelta %dK",
                   availPhysK,
                   availPageK,
                   sum,
                   sum - g_prevAvailMemory);
        PerfPrintLine();

        // Note that this is a global, which is what we want.  If we
        // put it on the view, then we get a weird result each time we
        // switch views.  This needs to be consistent across views.
        // (I'm not worried about the possibility of multiple views
        // hitting this next instruction outside of a crit sect.  The
        // result will be harmless.)
        g_prevAvailMemory = sum;

        DWORD currTime = GetTickCount();
        DWORD dllTime = (currTime - g_dllStartTime) / 1000;
        DWORD viewTime = (currTime - _viewStartTime) / 1000;

        DWORD dllHours = dllTime / 3600;
        DWORD dllMins = dllTime / 60 - dllHours * 60;
        DWORD dllSecs = dllTime - dllHours * 3600 - dllMins * 60;

        DWORD viewHours = viewTime / 3600;
        DWORD viewMins = viewTime / 60 - viewHours * 60;
        DWORD viewSecs = viewTime - viewHours * 3600 - viewMins * 60;

        PerfPrintf("      DLL Running: %d:%02d:%02d, View Running: %d:%02d:%02d",
                   dllHours, dllMins, dllSecs,
                   viewHours, viewMins, viewSecs);
        PerfPrintLine();

        if (gcStat)
            GCPrintStat(GetCurrentGCList(), GetCurrentGCRoots());

        _lastReportTime = GetPerfTickCount () ;
        _gcTime = _totalTime = _sampleTime = _renderTime = _pickTime = 0 ;
        _numFrames = _numSamples = 0 ;

        ResetJitterMeasurements();

        //
        // Reset rendering timers
        //
        _timers.ddrawTimer.Reset();
        _timers.d3dTimer.Reset();
        _timers.dsoundTimer.Reset();
        _timers.dxxformTimer.Reset();
        _timers.customTimer.Reset();
        _timers.alphaTimer.Reset();
        _timers.gdiTimer.Reset();
        _timers.dx2dTimer.Reset();
    }
#endif /* PERFORMANCE_REPORTING */
}

void
View::EventHappened()
{
    _someEventHappened = true;
}


bool
View::Sample(Time time, bool paused)
{
#if DEVELOPER_DEBUG
    int listsize;
#endif

    if (_currentSampleTime > time && paused == false)
        {
        TraceTag((tagError, "tick backward! %5.3f %5.3f",
                  _currentSampleTime, time));

        // Workaround for IHammer controls

        if (time == 0)
        {
            time = _currentSampleTime;
        }
        else
        {
            // So the IHammer control would work
            if ((_currentSampleTime - time) > 1.0) {
                DASetLastError(E_INVALIDARG, 0);
                return false;
            }

            TraceTag((tagError, "close enough, continue"));
        }
    }

    ReportPerformance();

    _FPSNumSamples++;

#if PERFORMANCE_REPORTING
    _numSamples++;

    DWORD startSampleTime = GetPerfTickCount();
#endif

// Remove since causes other problems
//    CatchWin32FaultCleanup cwfc ;
    DynamicHeapPusher dph(*_sampleHeap);

    _currentSystemTime = GetPerfTickCount();

    if( GetImageDev() ) {
        DirectDrawViewport *vprt = GetImageDev();
        if( vprt->ICantGoOn() ) {
            Assert(_imageDev == GetImageDev());
            DestroyImageDisplayDevice(_imageDev);
            _imageDev = NULL;
            _imageDev = CreateImageDisplayDevice();
            _doTargetUpdate = true;
            _oldTargetPackage.Copy( _targetPackage );

            // do this before sample because sample sometimes
            // needs a device
            SetTargetOnDevices();

            // force repaint (clear dirty rects)
            Repaint();
        }
    }

    GCRoots roots = GetCurrentGCRoots();

    RemoveFromRootsNULL(_sndVal, roots);
    RemoveFromRootsNULL(_imgVal, roots);
    RemoveFromRootsNULL(_imgForQueryHitPt, roots);

    _lastSampleTime = _currentSampleTime;
    _currentSampleTime = time;

    ResetDynamicHeap(*_sampleHeap);
    _eventq.Prune (_lastSampleTime) ;
    _eventq.SizeChanged(FALSE) ;

    ClearPerfTimeXformCache();

#if PERFORMANCE_REPORTING
    DWORD startGCTime = GetPerfTickCount();
#endif

    GarbageCollect();

#if PERFORMANCE_REPORTING
    _gcTime += GetPerfTickCount() - startGCTime;

    DWORD sampleTime = GetPerfTickCount();
#endif

    Image *rewrittenImage = NULL;

    RunBvrs(time, NULL);

    GC_CREATE_BEGIN;

    // needs to be here, since the event check may sample the sound
    // through tuple/array.
    if(!paused)
        _sndList->Reset(time);

    Param p(time);

    _sampleId = p._id;

    // Sample events

    bool eventThatHappenedWasFromChangeable = false;

#if DEVELOPER_DEBUG
    listsize = _events.size();
#endif

    list<Perf>::iterator j;
    for (j = _events.begin(); j != _events.end(); j++) {

        (*j)->Sample(p);

        if (_someEventHappened) {
            TraceTag((tagIndicateRBConst,
                      "View::Sample[%g] event happened 0x%x",
                      time, *j));
            break;
        }
    }

    // Make sure the size is unaltered during the sampling of the
    // events otherwise the stl data structure could be changed during
    // the iterations

    Assert(listsize == _events.size());

    // Sample switchers for switches on this view.
    CheckChangeablesParam ccp(p);
    bool gotOne = false;

#if DEVELOPER_DEBUG
    listsize = _changeables.size();
#endif

    // Always go through all the changeables, since they have to
    // update their state.  Not a big perf loss, since most frames
    // nothing will change anyhow and we'll always have to go
    // through them all.
    for (j = _changeables.begin(); j != _changeables.end(); j++) {

        bool result = (*j)->CheckChangeables(ccp);

        if (result) {
            gotOne = true;

            TraceTag((tagIndicateRBConst,
                      "View::Sample[%g] switcher switched 0x%x",
                      time, *j));
        }
    }

    // Make sure the size is unaltered during the sampling of the
    // events otherwise the stl data structure could be changed during
    // the iterations

    Assert(listsize == _changeables.size());

    // Now, with the RBId set to hit the cache, go through all the
    // conditionals.  Note we only sample the conditions here,
    // which have already been cached, so we're ok setting the
    // RBId.
    if (!gotOne) {
        p._cid = _lastRBId;
    }

#if DEVELOPER_DEBUG
    listsize = _conditionals.size();
#endif

#if DO_CONDS_CHECK
        for (j = _conditionals.begin(); j != _conditionals.end(); j++) {

            bool result = (*j)->CheckChangeables(ccp);

            if (result) {
                gotOne = true;
                TraceTag((tagIndicateRBConst,
                          "View::Sample[%g] conditional transition 0x%x",
                          time, *j));
            }
        }
#endif

    // Make sure the size is unaltered during the sampling of the
    // events otherwise the stl data structure could be changed during
    // the iterations

    Assert(listsize == _conditionals.size());

    // Set back, we'll determine later if the main sampling should
    // have this turned on.
    p._cid = 0;

    if (gotOne) {
        if (!_someEventHappened) {
            EventHappened();
            eventThatHappenedWasFromChangeable = true;
        }
    }

    // Only allow the cache to be used when no events occurred.
    if (!_someEventHappened)
        p._cid = _lastRBId;

    if(spritify) {
        Assert(_rmSound);
        _rmSound->Sample(p);
    }
    else {
        if (_sndPerf && !paused) {
            _sndVal = _sndPerf->Sample(p);
            GCAddToRoots(_sndVal, roots);
            RenderSound(_sndVal);
        }
    }

    {
        // We need to make a copy since elements can be removed while
        // we sample
        // We also are in the GC lock so we do not need to worry about
        // the behaviors having been removed from the roots

        Assert(IsGCLockAcquired(GetCurrentThreadId()));

        RunningList runningBvrsCopy = _runningBvrs;

        // Sample "started" behaviors from the jaxa interface for
        // events.
        for (RunningList::iterator i = runningBvrsCopy.begin();
             i != runningBvrsCopy.end(); i++) {
            i->second->Sample(p);
        }
    }

    if (_imgPerf) {
        _imgForQueryHitPt = _imgVal = _imgPerf->Sample(p);
        GCAddToRoots(_imgVal, roots);
        GCAddToRoots(_imgForQueryHitPt, roots);
    }

    _lastSystemTime = _currentSystemTime;

#if PRODUCT_PROF
//        if (_firstRendering) {
//            cout << "Turning on IceCAP profiling." << endl;
//            cout.flush();
//            StartCAPAll();
//        }
#endif

    // Render several frames after event happens.  Can't just
    // render once coz value at event time is not the switched
    // value in general.
    if (_someEventHappened) {

        TraceTag((tagIndicateRBConst,
                  "View::(0x%x) change happened %g", this, time));

        //ResetDynamicHeap(*_rbHeap);
        //DynamicHeapPusher h(*_rbHeap);
        //REVERT-RB:
        DynamicHeap *heap = &GetGCHeap();

        DynamicHeapPusher h(*heap);

        ClearPerfList(_events, roots);
        ClearPerfList(_changeables, roots);
        ClearPerfList(_conditionals, roots);

        _lastRBId = NewSampleId();
        RBConstParam pp(_lastRBId, p, _events, _changeables, _conditionals);

        //bool doRB = false;

#if _DEBUG
        if (!IsTagEnabled(tagDisableRBConst)) {
#endif

            if (_imgPerf && //doRB &&
                GetCurrentView().GetPreferences()._dynamicConstancyAnalysisOn) {
                _isRBConst = _imgPerf->GetRBConst(pp) != NULL;
            }

#if _DEBUG
        }
#endif

        GCAddPerfListToRoots(_events, roots);
        GCAddPerfListToRoots(_changeables, roots);
        GCAddPerfListToRoots(_conditionals, roots);

        if (_isRBConst) {

            TraceTag((tagIndicateRBConst,
                      "View 0x%x is temporal constant at [%g]",
                      this, time));

            // Events from changeables only need to repaint once.  We
            // need to repaint more times for Until based events so
            // everything catches up.
            if (eventThatHappenedWasFromChangeable) {
                _toPaint = 1;
            } else {
                _toPaint = 3;
            }
        }

    }

#if _DEBUG
    if (IsTagEnabled(tagDisableDirtyRects)) {
        DisableDirtyRects();
    }
#endif

    // Don't bother doing dirty rectangles if we don't need to paint
    // anyhow.
    if (PERVIEW_DRECTS_ON && !_dirtyRectsDisabled && _imgVal &&
        (!_isRBConst || _toPaint > 0)) {

        // Only do dirty rects if we're a) windowed, or b) have a
        // non-volatile rendering surface (meaning that DA's the only
        // guy writing to that surface, other than through established
        // mechanisms like RePaint()).

        // TODO: Improve for the windowless case, where dirty rects
        // can make sense.

        if (!IsWindowless() ||
            !GetCurrentView().GetPreferences()._volatileRenderingSurface) {

            Assert(_imgVal->GetTypeInfo() == ImageType);
            Image *img = SAFE_CAST(Image *, _imgVal);

            rewrittenImage =
                _dirtyRectState.Process(img,
                                        _lastSampleId,
                                        GetImageDev()->GetTargetBbox());


            GCAddToRoots(rewrittenImage, roots);

            // Stash away the last sample
            _lastSampleId = p._id;

        }
    }

#if PERFORMANCE_REPORTING
    _sampleTime +=  GetPerfTickCount() - sampleTime;
#endif

    // Be sure to pick on the original image, not the "rewritten" one,
    // since that would ignore stuff that's not changing.
    if (_imgVal) {
        DoPicking(_imgVal, time);
    }

    GC_CREATE_END;

    if (_imgVal && rewrittenImage) {
        // Replace "actual" image with rewritten one.
        GCRemoveFromRoots(_imgVal, roots);
        _imgVal = rewrittenImage;
    }

    bool needToRender = false;

#if _DEBUG
    if (IsTagEnabled(tagEngNoSRender)) {
        needToRender = true;
    } else
#endif
        if (_repaintCalled || _isRBConst || rewrittenImage == emptyImage) {

            if (_repaintCalled) {

                // If repaint's been called, we need to paint twice.
                // Painting just once doesn't seem to clear everything
                // out.  We can afford the extra paint because it's
                // typically just on invalidations from window system
                // events.
                if (_toPaint < 2) {
                    _toPaint = 2;
                }
                _repaintCalled = false;

            }

            // TODO: should decrement _toPaint in Sample,
            // then we don't need this.
            _emptyImageSoFar &= (_imgVal == emptyImage);

            if (!_emptyImageSoFar && (_toPaint > 0)) {
                needToRender = true;
            }

            // We need to render at least once because of 38383
            if (_firstSample) {
                // but we don't want to mess with the original logic
                // so we only do it for emptyImage
                if (_emptyImageSoFar) {
                    needToRender = true;
                }
                // reset, don't do this again
                _firstSample = false;
            }
        } else {
            //Assert(_imgPerf->GetRBConst(NewSampleId()) == NULL);

            needToRender = true;
        }

    ClearPerfTimeXformCache();

#if PERFORMANCE_REPORTING
    _totalTime += GetPerfTickCount() - startSampleTime;
#endif

    // Reset for next time.
    _someEventHappened = false;

    return needToRender;
}

void View::RenderSound()
{
// Remove since causes other problems
//    CatchWin32FaultCleanup cwfc ;
    DynamicHeapPusher dph(*_sampleHeap);

    GC_CREATE_BEGIN;
    RenderSound(_sndVal);
    GC_CREATE_END;
}

void View::RenderImage()
{
    if (!_imgVal)
        return;

    #if 0
    {
        //
        // Checks for image device creation/destruction leaks
        //
        static int i = 0;
        i++;

        if(i > 3) {
            DynamicHeapPusher dph(*_sampleHeap);

            while(1) {

                _CrtMemCheckpoint(&oldState);

                if(! GetImageDev() ) {
                    _imageDev = CreateDdRlDisplayDevice();
                }

                SetTargetOnDevices();

                delete GetImageDev();
                _imageDev = NULL;

                _CrtMemCheckpoint(&newState);
                _CrtMemDifference(&diff, &oldState, &newState);
                _CrtMemDumpStatistics(&diff);
                _CrtMemDumpAllObjectsSince(&oldState);
            }
        }
    }
    #endif


#if 0
#if _DEBUGMEM
        _CrtMemCheckpoint(&oldState);
#endif
#endif

#if PERFORMANCE_REPORTING
    DWORD startTime = GetPerfTickCount();
#endif

// Remove since causes other problems
//    CatchWin32FaultCleanup cwfc ;
    DynamicHeapPusher dph(*_renderHeap);

    #if 0
    // Device creation/destruction leak detection
    if(! GetImageDev() ) {
        _imageDev = CreateDdRlDisplayDevice();
        _doTargetUpdate = true;
    }
    #endif

    SetTargetOnDevices();

    GC_CREATE_BEGIN;
    RenderImage(_imgVal);
    GC_CREATE_END;

    // If we think we needed to paint, then decrement this counter,
    // since we just did paint.
    if (_toPaint > 0) {
        _toPaint--;
    }

    _numFrames++;

    SubmitNewRenderingTime();

    // Only do this after the first frame.
    if (_firstRendering) {

#if PRODUCT_PROF
//            StopCAPAll();
//            cout << "Turning off IceCAP profiling." << endl;
#endif

        PERFPRINTLINE(("First Rendering(thread:%x): %g s",
                       GetCurrentThreadId(),
                       ((double) (GetPerfTickCount() - startTime)) /
                       (double) perfFrequency));

        _firstRendering = FALSE;

    }

#if PERFORMANCE_REPORTING
    DWORD renderTime = GetPerfTickCount() - startTime;

    Assert(GetPerfTickCount() >= startTime);

    _renderTime += renderTime;
    _totalTime += renderTime;
#endif

    #if 0
    // Device creation/destruction leak detection
    delete GetImageDev();
    _imageDev = NULL;
    #endif

    ResetDynamicHeap(*_renderHeap);

#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif

}

void
View::SubmitNewRenderingTime()
{
    DWORD timer = GetPerfTickCount();

    // 0 indicates first rendering, just skip
    if (_lastRenderingTime != 0) {
        _renderTimes[_renderTimeIdx++] = timer - _lastRenderingTime;
    }

    _lastRenderingTime = timer;

    if (_renderTimeIdx >= MAX_RENDER_TIMES) {
        DebugCode(cout << "Went beyond " << MAX_RENDER_TIMES << " renderings.\n");
        _renderTimeIdx = 0;
    }
}


void
View::GetRenderingTimeStats(Real *avg,
                            Real *avgFrameLength,
                            Real *avgVariance,
                            Real *maxVariance,
                            Real *minVariance)
{
    if (_renderTimeIdx == 0) {
        // If no renderings happened.
        *avg = 0;
        *avgFrameLength = 0;
        *avgVariance = 0;
        *maxVariance = 0;
        *minVariance = 0;
        return;
    }

    DWORD total = 0;
    for (int i = 0; i < _renderTimeIdx; i++) {
        DWORD v = _renderTimes[i];
        total += v;
    }

    DWORD avgTicks = total / _renderTimeIdx;

    *avg = (Real)avgTicks / perfFrequency;
    if(*avg)
        *avgFrameLength = 1.0 / *avg;

    DWORD dev = 0;
    long minTicksDiff = 1 << 16;
    long maxTicksDiff = 0;

    for (i = 0; i < _renderTimeIdx; i++) {
        DWORD v = _renderTimes[i];
        long diff = v - avgTicks;
        if (diff < 0) diff = -diff;
        dev += diff;

        if (diff < minTicksDiff) minTicksDiff = diff;
        if (diff > maxTicksDiff) maxTicksDiff = diff;

    }

    dev /= _renderTimeIdx;

    *avgVariance = (Real)dev / perfFrequency;
    *minVariance = (Real)minTicksDiff / perfFrequency;
    *maxVariance = (Real)maxTicksDiff / perfFrequency;
}


#if PERFORMANCE_REPORTING
void
View::ResetJitterMeasurements()
{
    _renderTimeIdx = 0;
}
#endif  // PERFORMANCE_REPORTING

HWND
View::GetWindow()
{
    return (_targetPackage.IsHWND())?
        _targetPackage.GetHWND() :
        NULL;
}

bool
View::SetWindow(HWND hwnd)
{
    if ( _targetPackage.IsHWND() &&
         _targetPackage.GetHWND() == hwnd ) return true;

    _targetPackage.SetHWND(hwnd);
    _doTargetUpdate = true;

    return true;
}

IDirectDrawSurface *
View::GetDDSurf()
{
    return (_targetPackage.IsDdsurf())?
        _targetPackage.GetIDDSurface() :
        NULL;
}

bool
View::SetDDSurf(
    IDirectDrawSurface *ddsurf,
    HDC parentDC)
{
    _targetPackage.SetIDDSurface(ddsurf, parentDC);
    _doTargetUpdate = true;

    return true;
}

HDC
View::GetHDC()
{
    return (_targetPackage.IsHDC())?
        _targetPackage.GetHDC() :
        NULL;
}

bool
View::SetHDC(HDC hdc)
{
    bool ret = false;

    DAComPtr<IServiceProvider> sp;
    DAComPtr<IDirectDraw3> ddraw3;
    DAComPtr<IDirectDrawSurface> dds;
    if(hdc && GetCurrentServiceProvider( &sp )
         && sp
         && SUCCEEDED(sp->QueryService(SID_SDirectDraw3,
                                       IID_IDirectDraw3,
                                       (void**)&ddraw3))
         && SUCCEEDED(ddraw3->GetSurfaceFromDC(hdc, &dds))
         && SetDDSurf(dds, hdc) ) {

        SetCompositeDirectlyToTarget(true);

        ret = true;

    }
    else
    {
        _targetPackage.SetHDC(hdc);
        _doTargetUpdate = true;
        ret = true;
    }

    return ret;
}

double
View::GetFrameRate()
{
    DWORD totalTicks = GetPerfTickCount() - _FPSLastReportTime;

    if (totalTicks > perfFrequency) {
        _FPS = ((double) _FPSNumSamples * perfFrequency) / (double) totalTicks;
        _FPSNumSamples = 0;
        _FPSLastReportTime = GetPerfTickCount();
    }

    return _FPS;
}

double
View::GetTimeDelta()
{
    return _currentSampleTime - _lastSampleTime;
}

PerfTimeXformImpl *
View::GetPerfTimeXformFromCache(Perf p)
{
    PerfTTMap::iterator i = _ttCache.find(p);

    return (i!=_ttCache.end()) ? (*i).second : NULL;
}

void
View::SetPerfTimeXformCache(Perf p, PerfTimeXformImpl *tt)
{
    Assert(_ttCache.find(p)==_ttCache.end());

    _ttCache[p] = tt;
}

void
View::ClearPerfTimeXformCache()
{
    _ttCache.erase(_ttCache.begin(), _ttCache.end());
}

// =========================================
// Thread specific calls
// =========================================

static DWORD viewTlsIndex = 0xFFFFFFFF;

CRViewPtr IntGetCurrentView()
{ return (CRViewPtr) TlsGetValue(viewTlsIndex); }

void IntSetCurrentView(CRViewPtr v)
{ TlsSetValue(viewTlsIndex, v); }

CRView &
GetCurrentView()
{
    CRViewPtr v = IntGetCurrentView();

    if (v == NULL)
        RaiseException_InternalError("Tried to get View with no view set") ;

    return *v ;
}

CRViewPtr
SetCurrentView(CRViewPtr v)
{
    CRViewPtr oldview = IntGetCurrentView() ;

    IntSetCurrentView(v);

    return oldview;
}

PerfTimeXformImpl *
ViewGetPerfTimeXformFromCache(Perf p)
{
    CRViewPtr v = IntGetCurrentView();

    if (v == NULL)
        return NULL;

    return v->GetPerfTimeXformFromCache(p);
}

void
ViewSetPerfTimeXformCache(Perf p, PerfTimeXformImpl *tt)
{
    CRViewPtr v = IntGetCurrentView();

    if (v != NULL) {
        v->SetPerfTimeXformCache(p, tt);
    }
}

void
ViewClearPerfTimeXformCache()
{ GetCurrentView().ClearPerfTimeXformCache(); }

// =========================================
// Initialization
// =========================================


void
InitializeModule_View()
{
    viewTlsIndex = TlsAlloc();
    Assert((viewTlsIndex != 0xFFFFFFFF) &&
           "TlsAlloc() failed");

#if PERFORMANCE_REPORTING
    g_dllStartTime = GetTickCount();
#endif

}

void
DeinitializeModule_View(bool bShutdown)
{
    if (viewTlsIndex != 0xFFFFFFFF)
        TlsFree(viewTlsIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\constant.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    This file contains constant values, which are useful for passing value
pointers to general API entry points.

    IMPORTANT:  These values must not be used for static initialization.  Since
static initialization order is undefined, the following values may not yet have
been set when referenced by other static initializers.  Hence, you can only
assume that these values are valid at run-time.  For static initialization,
use instead the real-valued internal constructors (e.g. new Bbox2(a,b,c,d)).

*******************************************************************************/

#include "headers.h"
#include "appelles/common.h"

    // Actual Value Storage

Real val_zero   = 0;
Real val_one    = 1;
Real val_negOne = -1;

    // Pointers to the Values

AxANumber *zero;
AxANumber *one;
AxANumber *negOne;

AxABoolean *truePtr;
AxABoolean *falsePtr;

void
InitializeModule_Constant()
{
    zero   = RealToNumber (val_zero);
    one    = RealToNumber (val_one);
    negOne = RealToNumber (val_negOne);

    truePtr  = BOOLToAxABoolean (true);
    falsePtr = BOOLToAxABoolean (false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\dastream.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <urlmon.h>
#include <wininet.h>
#include "privinc/debug.h"
#include "privinc/dastream.h"
#include "privinc/urlbuf.h"
#include "privinc/util.h"
#include "privinc/except.h"
#include "privinc/resource.h"
#include "privinc/server.h"
#include "privinc/mutex.h"

DeclareTag(tagDAStream, "DAStream", "Errors");

//
// OLE Stream
//

ULONG
daolestream::read (void *pv, ULONG cb)
{
    Assert (_stream.p);

    if (!_stream) {
        TraceTag((tagDAStream, "daolestream::read Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,"Tried to read from uninitialized stream");
    }

    ULONG cbRead = 0;

    // A failed error code could mean EOF
    _stream->Read(pv,cb,&cbRead);

    return cbRead;
}

ULONG
daolestream::write (void *pv, ULONG cb, bool bWriteAll)
{
    Assert (_stream.p);

    if (!_stream) {
        TraceTag((tagDAStream, "daolestream::write Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                            "Tried to write to uninitialized stream");
    }

    ULONG ret = 0;
    char * curpv = (char *)pv;

    do {
        ULONG cbWritten = 0;
        HRESULT hr;

        if ((hr = THR(_stream->Write(&curpv[ret],cb - ret,&cbWritten)) != S_OK))
            RaiseException_InternalErrorCode (hr,
                                    "Failed to write to stream");

        ret += cbWritten;
    } while (bWriteAll && ret < cb) ;

    return ret;
}

ULONG
daolestream::seek (LONG offset, DASEEK origin)
{
    Assert (_stream.p);

    if (!_stream) {
        TraceTag((tagDAStream, "daolestream::seek: Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to seek in uninitialized stream");
    }

    STREAM_SEEK fdir;
    ULARGE_INTEGER retpos;

    TraceTag((tagNetIO, "urlbuf::seekoff"));

    switch (origin) {
      case DASEEK_SET:
        fdir = STREAM_SEEK_SET;
        break;
      case DASEEK_CUR:
        fdir = STREAM_SEEK_CUR;
        break;
      case DASEEK_END:
        fdir = STREAM_SEEK_END;
        break;
      default:
        TraceTag((tagDAStream, "daolestream::seek: Invalid origin"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to seek with invalid origin");
    }

    HRESULT hr;
    LARGE_INTEGER lioffset;
    lioffset.QuadPart = offset;
    if ((hr = THR(_stream->Seek (lioffset,
                                 fdir,
                                 &retpos)) != S_OK))
        RaiseException_InternalErrorCode (hr,
                                "Failed to seek in stream");

    return(retpos.LowPart);
}

//
// Win32 Stream
//

ULONG
dawin32stream::read (void *pv, ULONG cb)
{
    Assert (_handle);

    if (!_handle) {
        TraceTag((tagDAStream, "dawin32stream::read Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to read from uninitialized stream");
    }

    DWORD cbRead;

    if (!ReadFile(_handle,pv,cb,&cbRead,NULL)) {
        TraceTag((tagDAStream, "dawin32stream::read: Read failed 0x%lX",GetLastError()));
        RaiseException_InternalErrorCode (GetLastError(),
                                "Failed to read from stream");
    }

    return cbRead;
}

ULONG
dawin32stream::write (void *pv, ULONG cb, bool bWriteAll)
{
    Assert (_handle);

    if (!_handle) {
        TraceTag((tagDAStream, "dawin32stream::write Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to write to uninitialized stream");
    }

    DWORD ret = 0;
    char * curpv = (char *)pv;

    do {
        DWORD cbWritten = 0;
        if (!WriteFile(_handle,&curpv[ret],cb - ret,&cbWritten,NULL)) {
            TraceTag((tagDAStream, "dawin32stream::write: Write failed 0x%lx",GetLastError()));
            RaiseException_InternalErrorCode (GetLastError(),
                                    "Failed to write to stream");
        }

        ret += cbWritten;
    } while (bWriteAll && ret < cb) ;

    return ret;
}

ULONG
dawin32stream::seek (LONG offset, DASEEK origin)
{
    Assert (_handle);

    if (!_handle) {
        TraceTag((tagDAStream, "dawin32stream::seek: Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to seek in uninitialized stream");
    }

    DWORD fdir;
    DWORD retpos;

    TraceTag((tagNetIO, "urlbuf::seekoff"));

    switch (origin) {
      case DASEEK_SET:
        fdir = FILE_BEGIN;
        break;
      case DASEEK_CUR:
        fdir = FILE_CURRENT;
        break;
      case DASEEK_END:
        fdir = FILE_END;
        break;
      default:
        TraceTag((tagDAStream, "dawin32stream::seek: Invalid origin"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to seek with invalid origin");
    }

    retpos = SetFilePointer(_handle,
                            offset,
                            NULL,
                            fdir);

    //if (retpos = 0xffffffff) {
    if (retpos == 0xffffffff) {
        TraceTag((tagDAStream, "dawin32stream::seek: Seek failed 0x%lx",GetLastError()));
        RaiseException_InternalErrorCode (GetLastError(),
                                "Failed to seek in stream");
    }

    return(retpos);
}

//
// dastrstream
//

ULONG
dastrstream::read (void *pv, ULONG cb)
{
    ULONG cbLeft = _size - _curpos;

    if (cb > cbLeft) cb = cbLeft;

    memcpy(pv,&_pdata[_curpos],cb);
    _curpos += cb;

    return cb;
}

ULONG
dastrstream::write (void *pv, ULONG cb, bool bWriteAll)
{
    ULONG cbLeft = _size - _curpos;

    if (cb > cbLeft) cb = cbLeft;

    memcpy(&_pdata[_curpos],pv,cb);
    _curpos += cb;

    return cb;
}

ULONG
dastrstream::seek (LONG offset, DASEEK origin)
{
    DWORD startpos;
    DWORD retpos;

    TraceTag((tagNetIO, "urlbuf::seekoff"));

    switch (origin) {
      case DASEEK_SET:
        startpos = 0;
        break;
      case DASEEK_CUR:
        startpos = _curpos;
        break;
      case DASEEK_END:
        startpos = _size;
        break;
      default:
        TraceTag((tagDAStream, "dastrstream::seek: Invalid origin"));
        RaiseException_InternalErrorCode (E_INVALIDARG,"Tried to seek with invalid origin");
    }

    retpos = startpos + offset;
    if (retpos > _size) {
        TraceTag((tagDAStream,
                  "dastrstream::seek: Seek failed - invalid position %ld",
                  retpos));
        RaiseException_InternalErrorCode (E_INVALIDARG,"Failed to seek in stream");
    }

    _curpos = retpos;

    return retpos;
}

void
dastrstream::init(void * pv, ULONG cb)
{
    _pdata = THROWING_ARRAY_ALLOCATOR(char,cb);

    if (pv) memcpy(_pdata,pv,cb);
    _curpos = 0;
    _size = cb;
}

//
// dafstream
//

void
dafstream::open(char *file, int mode)
{
    close();

    _mode = mode;

    DWORD dwAccess = 0;
    DWORD dwShare = 0;
    DWORD dwCreate = 0;

    if (mode & damode_read) dwAccess |= GENERIC_READ;
    if (mode & damode_write) dwAccess |= GENERIC_WRITE;

    if (mode & damode_nocreate)
        dwCreate = OPEN_EXISTING;
    else if (mode & damode_noreplace)
        dwCreate = CREATE_NEW;
    else if (mode & damode_trunc)
        dwCreate = CREATE_ALWAYS;
    else if (mode & damode_write)
        dwCreate = OPEN_ALWAYS;
    else
        dwCreate = OPEN_EXISTING;

    if (!(mode & damode_noshare)) dwShare |= (FILE_SHARE_READ | FILE_SHARE_WRITE);

    HANDLE h = CreateFile(file,dwAccess,dwShare,NULL,
                          dwCreate,FILE_ATTRIBUTE_NORMAL,NULL);

    if (h == INVALID_HANDLE_VALUE)
        RaiseException_UserError (GetLastError(),
                            IDS_ERR_OPEN_FILE_FAILED,
                            file);

    SetHandle(h);
}

void
dafstream::close()
{
    HANDLE h = GetHandle();

    if (h) {
        CloseHandle(h);
        SetHandle(NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\ddutil.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All Rights Reserved.

    Routines for loading bitmap and palettes from resources
*******************************************************************************/

#include "headers.h"

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <ddraw.h>
#include <privinc/ddutil.h>

#include "appelles/common.h"
#include "privinc/error.h"
#include "privinc/hresinfo.h"
#include "privinc/util.h"
#include "privinc/ddsurf.h"


/*****************************************************************************
Draw a bitmap into a DirectDrawSurface.
*****************************************************************************/

HRESULT DDCopyBitmap (
    IDDrawSurface *pdds,     // Destination DirectDraw Surface
    HBITMAP        hbm,      // Source Bitmap
    int            x,
    int            y,
    int            dx,       // Destination Width;  If Zero use Bitmap Width
    int            dy)       // Destination Height; If Zero use Bitmap Height
{
    HDC           hdcImage;
    HDC           hdc;
    BITMAP        bm;
    DDSURFACEDESC ddsd;
    HRESULT       hr;

    if (hbm == NULL || pdds == NULL)
        return E_FAIL;

    //
    // make sure this surface is restored.
    //
    pdds->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);
    SelectObject(hdcImage, hbm);

    //
    // get size of the bitmap
    //
    GetObject(hbm, sizeof(bm), &bm);    // get size of bitmap
    dx = dx == 0 ? bm.bmWidth  : dx;    // use the passed size, unless zero
    dy = dy == 0 ? bm.bmHeight : dy;

    //
    // get size of surface.
    //
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    pdds->GetSurfaceDesc(&ddsd);

    if ((hr = pdds->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt (hdc, 0, 0, ddsd.dwWidth, ddsd.dwHeight,
                    hdcImage, x, y, dx, dy, SRCCOPY);
        pdds->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

    return hr;
}



/*****************************************************************************
Convert a RGB color to a pysical color.

We do this by leting GDI SetPixel() do the color matching, then we lock the
memory and see what it got mapped to.
*****************************************************************************/

DWORD DDColorMatch (IDDrawSurface *pdds, COLORREF rgb)
{
    COLORREF rgbT;
    HDC hdc;
    DWORD dw = CLR_INVALID;
    DDSURFACEDESC ddsd;
    HRESULT hres;

    //
    //  use GDI SetPixel to color match for us
    //
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        rgbT = GetPixel(hdc, 0, 0);             // save current pixel value
        SetPixel(hdc, 0, 0, rgb);               // set our value
        pdds->ReleaseDC(hdc);
    }

    //
    // now lock the surface so we can read back the converted color
    //
    ddsd.dwSize = sizeof(ddsd);
    while ((hres = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;

    if (hres == DD_OK)
    {
        DWORD mask;
        dw = *(DWORD *)ddsd.lpSurface;                     // get DWORD

        if(ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) {
            mask = 0xff;
        } else {
            mask = ddsd.ddpfPixelFormat.dwRBitMask |
                   ddsd.ddpfPixelFormat.dwGBitMask |
                     ddsd.ddpfPixelFormat.dwBBitMask |
                     ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
        }

        pdds->Unlock(NULL);
        #if _DEBUG
        if( !((ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) ||
              (ddsd.ddpfPixelFormat.dwRGBBitCount == 16) ||
              (ddsd.ddpfPixelFormat.dwRGBBitCount == 24) ||
              (ddsd.ddpfPixelFormat.dwRGBBitCount == 32))
           )
        {
            Assert(FALSE && "unsupported bit depth in DDColorMatch");
        }
        #endif

        dw = dw & mask; // mask it to bpp
    }

    //
    //  now put the color that was there back.
    //
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        SetPixel(hdc, 0, 0, rgbT);
        pdds->ReleaseDC(hdc);
    }

    return dw;
}



/*****************************************************************************
Print out the information associated with a given HRESULT.
*****************************************************************************/

void reallyPrintDDError (HRESULT ddrval
    #if DEVELOPER_DEBUG
        , char const *filename,
        int lineNum
    #endif
    )
{
    #if DEVELOPER_DEBUG
        HresultInfo *info = GetHresultInfo (ddrval);

        if (info && info->hresult) {
            char str[1024];
            sprintf(str, "DirectAnimation DDRAW Err: %s (%x) in %s (line %d)\n",
                    info->hresult_str, ddrval, filename, lineNum);
            printf("%s",str);

            OutputDebugString(str);
        }
    #endif
}



/*****************************************************************************
Given the number of bits per pixel, return the DirectDraw DDBD_ value.
*****************************************************************************/

int BPPtoDDBD (int bitsPerPixel)
{
    switch (bitsPerPixel)
    {   case  1: return DDBD_1;
        case  2: return DDBD_2;
        case  4: return DDBD_4;
        case  8: return DDBD_8;
        case 16: return DDBD_16;
        case 24: return DDBD_24;
        case 32: return DDBD_32;
        default: return 0;
    }
}

void GetSurfaceSize(IDDrawSurface *surf,
                    LONG *width,
                    LONG *height)
{
    Assert(surf && "null surface in GetSurfaceSize");
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    if( surf->GetSurfaceDesc(&ddsd) != DD_OK ) {
        RaiseException_InternalError("GetSurfaceDesc failed in GetSurfaceSize");
    }
    *width = ddsd.dwWidth;
    *height = ddsd.dwHeight;
}



IDirectDrawSurface *DDSurf2to1(IDirectDrawSurface2 *dds2)
{
    IDirectDrawSurface *dds1 = NULL;
    HRESULT hr = dds2->QueryInterface(IID_IDirectDrawSurface, (void **) &dds1);
    IfDDErrorInternal(hr, "Can't QI for IDirectDrawSurface from IDirectDrawSurface2");

    return dds1;
}

IDirectDrawSurface2 *DDSurf1to2(IDirectDrawSurface *dds1)
{
    IDirectDrawSurface2 *dds2 = NULL;
    HRESULT hr = dds1->QueryInterface(IID_IDirectDrawSurface2, (void **) &dds2);
    IfDDErrorInternal(hr, "Can't QI for IDirectDrawSurface2 from IDirectDrawSurface");

    return dds2;
}

//////////////////////// Depth Converters ///////////////////////


DWORD GetDDUpperLeftPixel(LPDDRAWSURFACE surf)
{
    DWORD pixel;
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    HRESULT _ddrval = surf->Lock(NULL, &ddsd, 0, NULL);
    IfDDErrorInternal(_ddrval, "Couldn't lock surf in GetDDPixel");

    switch (ddsd.ddpfPixelFormat.dwRGBBitCount) {
      case 8:
        pixel = *((BYTE *)ddsd.lpSurface);
        break;
      case 16:
        pixel = *((WORD *)ddsd.lpSurface);
        break;
      case 24:
        {
            BYTE *surfPtr = ((BYTE *)ddsd.lpSurface);
            BYTE byte1 = *surfPtr++;
            BYTE byte2 = *surfPtr++;
            BYTE byte3 = *surfPtr;
            pixel = byte1 << 16 | byte2 << 8 | byte3;
        }
        break;
      case 32:
        pixel = *((DWORD *)ddsd.lpSurface);
        break;
    }
    surf->Unlock(ddsd.lpSurface);
    return pixel;
}


void
SetDDUpperLeftPixel(LPDDRAWSURFACE surf, DWORD pixel)
{
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    HRESULT _ddrval = surf->Lock(NULL, &ddsd, 0, NULL);
    IfDDErrorInternal(_ddrval, "Couldn't lock surf16 in conv16to32");

    switch (ddsd.ddpfPixelFormat.dwRGBBitCount) {
      case 8:
        *((BYTE *)ddsd.lpSurface) = (BYTE)(pixel);
        break;
      case 16:
        *((WORD *)ddsd.lpSurface) = (WORD)(pixel);
        break;
      case 24:
        {
            // Write 3 bytes in for the 24bit case
            BYTE *surfPtr = ((BYTE *)ddsd.lpSurface);
            *surfPtr++ = (BYTE)(pixel >> 16);
            *surfPtr++ = (BYTE)(pixel >> 8);
            *surfPtr = (BYTE)(pixel);
        }
        break;
      case 32:
        *((DWORD *)ddsd.lpSurface) = (DWORD)(pixel);
        break;
    }

    surf->Unlock(ddsd.lpSurface);
}


static void
SetAlphaBitsOn32BitSurface(IDirectDrawSurface *surf,
                           int width,
                           int height)
{
    // Treat RGBQUAD as a DWORD, since comparisons between DWORDS are
    // legal, but comparisons between RGBQUADS are not.  Only do it if
    // we know these are the same size.
    Assert(sizeof(RGBQUAD) == sizeof(DWORD));

    HRESULT hr;

    // Lock ddsurface
    DDSURFACEDESC desc;
    desc.dwSize = sizeof(DDSURFACEDESC);
    hr = surf->Lock(NULL,
                    &desc,
                    DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR,
                    NULL);

    IfDDErrorInternal(hr,
                      "Can't Get ddsurf lock for SetAlphaBitsOn32BitSurface");

    void *srcp = desc.lpSurface; // needed for unlock

    if (desc.ddpfPixelFormat.dwRGBBitCount == 32) {
        long pitch = desc.lPitch;

        // First pixel is the color key.  Stash it off.
        DWORD colorKeyVal = *(DWORD *)srcp;

        // Go through each pixel
        for(int i=0; i<height; i++) {
            DWORD *src =  (DWORD *) ((unsigned char *)srcp + (pitch * i));
            DWORD *last = src + width;
            while (src < last) {
                // Set the alpha byte to 0xff for the non-colorkey pixels.
                if (*src != colorKeyVal) {
                    ((RGBQUAD *)src)->rgbReserved  = 0xff;
                }
                src++;
            }
        }
    }

    hr = surf->Unlock(srcp);
    IfDDErrorInternal(hr,
                      "ddsurf unlock failed in SetAlphaBitsOn32BitSurface");
}

void
PixelFormatConvert(IDirectDrawSurface *srcSurf,
                   IDirectDrawSurface *dstSurf,
                   LONG width,
                   LONG height,
                   DWORD *sourceColorKey, // NULL if no color key
                   bool writeAlphaChannel)
{
    HDC srcDC = NULL;
    HDC dstDC = NULL;
    HRESULT hr;

    // Stash the color key off in the upper left hand pixel.  This
    // does alter the source image, but may be the only way to figure
    // out what the color key is in the converted image.  Other way
    // would be to search for the color key, but that would be quite
    // expensive.

    if (sourceColorKey) {
        SetDDUpperLeftPixel(srcSurf,
                            *sourceColorKey);
    }

    hr = srcSurf->GetDC(&srcDC);
    IfDDErrorInternal(hr, "Couldn't grab DC on srcSurf");

    hr = dstSurf->GetDC(&dstDC);
    IfDDErrorInternal(hr, "Couldn't grab DC on dstSurf");

    int ret;
    TIME_GDI(ret= BitBlt(dstDC, 0, 0, width, height,
                         srcDC,  0, 0,
                         SRCCOPY));

    Assert(ret && "BitBlt failed");

    if (dstDC) dstSurf->ReleaseDC(dstDC);
    if (srcDC) srcSurf->ReleaseDC(srcDC);

    if (writeAlphaChannel) {
        // This will be a no-op on non-32 bit surfaces.
        SetAlphaBitsOn32BitSurface(dstSurf, width, height);
    }

    if (sourceColorKey) {
        DWORD pix = GetDDUpperLeftPixel(dstSurf);
        DDCOLORKEY ck;
        ck.dwColorSpaceLowValue = pix;
        ck.dwColorSpaceHighValue = pix;
        hr = dstSurf->SetColorKey(DDCKEY_SRCBLT, &ck);
        if (FAILED(hr)) {
            Assert("Setting color key on dstSurf failed");
            return;
        }
    }

    // TODO: What about palettes on 8-bit surfaces???
}


/*****************************************************************************
Hacked workaround for Permedia cards, which have a primary pixel format
with alpha per pixel.  If we're in 16-bit, then we need to set the alpha
bits to opaque before using the surface as a texture.  For some reason,
an analogous hack for 32-bit surfaces has no effect on Permedia hardware
rendering, so we rely on hardware being disabled for such a scenario.
*****************************************************************************/

void SetSurfaceAlphaBitsToOpaque(IDirectDrawSurface *imsurf,
                                 DWORD colorKey,
                                 bool keyIsValid)
{
    DDSURFACEDESC surfdesc;
    surfdesc.dwSize = sizeof(surfdesc);

    DWORD descflags = DDSD_PIXELFORMAT | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH;
    surfdesc.dwFlags = descflags;

    if (  SUCCEEDED (imsurf->GetSurfaceDesc(&surfdesc))
       && ((surfdesc.dwFlags & descflags) == descflags)
       && (surfdesc.ddpfPixelFormat.dwRGBBitCount == 16)
       && !((surfdesc.ddpfPixelFormat.dwRBitMask |
             surfdesc.ddpfPixelFormat.dwGBitMask |
             surfdesc.ddpfPixelFormat.dwBBitMask) & 0x8000)
       && SUCCEEDED (imsurf->Lock (NULL,&surfdesc,
                                   DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR,
                                   NULL))
       )
    {
        char *line = (char*) surfdesc.lpSurface;
        unsigned int linesrem = surfdesc.dwHeight;

        WORD rgbMask = surfdesc.ddpfPixelFormat.dwRBitMask
                     | surfdesc.ddpfPixelFormat.dwGBitMask
                     | surfdesc.ddpfPixelFormat.dwBBitMask;

        WORD alphaMask = surfdesc.ddpfPixelFormat.dwRGBAlphaBitMask;

        if (keyIsValid)
        {
            // If we're color-keying the texture, then we need to set the alpha
            // to transparent for all pixels whose color matches the color key.
            // If the color does *not* match the key, then we just set the
            // alpha bits to opaque.

            while (linesrem--)
            {
                WORD *ptr = (WORD*) line;
                unsigned int linepixels = surfdesc.dwWidth;

                while (linepixels--)
                {
                    if ((*ptr & rgbMask) == colorKey)
                        *ptr &= rgbMask;
                    else
                        *ptr |= alphaMask;
                    ++ptr;
                }
                line += surfdesc.lPitch;
            }
        }
        else
        {
            // This surface has no color keyed transparency, so we just set the
            // alpha bits to fully opaque.

            while (linesrem--)
            {
                WORD *ptr = (WORD*) line;
                unsigned int linepixels = surfdesc.dwWidth;

                while (linepixels--)
                    *ptr++ |= alphaMask;

                line += surfdesc.lPitch;
            }
        }

        imsurf->Unlock (NULL);
    }
}




// this function is used for caching alpha.  the problem is some
// primitives are not alpha aware and leave the alpha byte untouched,
// while dx2d IS alpha aware and write the proper values into the
// alpha byte.  When we use dx2d to do an alpha aware compose of this
// surface to some other surface (A blend) we want the dx2d prims to
// show up properly (with aa and stuff) AND the non-alpha-aware prims
// to show up fully opaque also.
// So we need a way to make the non-alpha-aware prims visible while
// preserving the dx2d drawn pixels.  We decided to fill the surface
// with a color key that looks something like  0x01xxxxxxx.
// If the color key exists in that form on the surface, the alpha byte
// is set to 0.  If the pixel is NOT the color key AND has a 0x01 in
// the alpha byte we consider that pixel to be a non-alpha aware
// pixel.
// the only problem is we run the risk of making a legit dx2d partly
// transparent pixel (1 out of 256) fully opaque.  which looks weird.
void SetSurfaceAlphaBitsToOpaque(IDirectDrawSurface *imsurf,
                                 DWORD fullClrKey)
{
    DDSURFACEDESC surfdesc;
    surfdesc.dwSize = sizeof(surfdesc);

    DWORD descflags =
        DDSD_PIXELFORMAT |
        DDSD_WIDTH | DDSD_HEIGHT |
        DDSD_PITCH | DDSD_LPSURFACE;
    surfdesc.dwFlags = descflags;

    HRESULT hr = imsurf->Lock(NULL,&surfdesc,DDLOCK_SURFACEMEMORYPTR,NULL);
    if( SUCCEEDED ( hr ) ) 
    {
        char *line = (char*) surfdesc.lpSurface;
        unsigned int linesrem = surfdesc.dwHeight;

        DWORD rgbMask = surfdesc.ddpfPixelFormat.dwRBitMask
                     | surfdesc.ddpfPixelFormat.dwGBitMask
                     | surfdesc.ddpfPixelFormat.dwBBitMask;

        DWORD alphaMask = 0xff000000;

        // this is the key to differentiate between those pixels
        // written by dx2d and those written by non-alpha aware prims
        DWORD alphaKey = fullClrKey & alphaMask;

        {
            // If we're color-keying the texture, then we need to set the alpha
            // to transparent for all pixels whose color matches the color key.
            // If the color does *not* match the key, then we just set the
            // alpha bits to opaque.

            while (linesrem--)
            {
                DWORD *ptr = (DWORD*) line;
                unsigned int linepixels = surfdesc.dwWidth;

                while (linepixels--)
                {
                    if ((*ptr) == fullClrKey)
                        *ptr &= rgbMask;  // make fully transparent
                    else if( !((*ptr) & alphaMask) ) //|| ((*ptr) & alphaKey) )
                        *ptr |= alphaMask; // make fully opaque
                    ++ptr;
                }
                line += surfdesc.lPitch;
            }
        }
        imsurf->Unlock (NULL);
    }
}



// ===========================================================================
// ====================  D E B U G   F U N C T I O N S  ======================
// ===========================================================================

#if _DEBUG

/*****************************************************************************
This function computes the total and color-only CRC's for a given palette.
*****************************************************************************/

void PalCRCs (
    PALETTEENTRY  entries[],   // Palette Entries
    unsigned int &crc_total,   // CRC of all of Palette
    unsigned int &crc_color)   // CRC of Color Fields
{
    crc_color = 0;

    for (int i=0;  i < 256;  ++i)
        crc_color = crc32 (&entries[i], 3, crc_color);

    crc_total = crc32 (entries, 256 * sizeof(entries[0]));
}



/*****************************************************************************
Dump information about the given palette to the output debug stream.
*****************************************************************************/

void dumppalentries (PALETTEENTRY entries[])
{
    char buffer[128];

    strcpy (buffer, "    Palette Entries:");
    char *buffend = buffer + strlen(buffer);
    unsigned int entry = 0;
    unsigned int col = 99;

    while (entry < 256)
    {
        if (col >= 8)
        {   strcpy (buffend, "\n");
            OutputDebugString (buffer);
            sprintf (buffer, "    %02x:", entry);
            buffend = buffer + strlen(buffer);
            col = 0;
        }

        sprintf (buffend, " %02x%02x%02x%02x",
            entries[entry].peRed, entries[entry].peGreen,
            entries[entry].peBlue, entries[entry].peFlags);

        ++col;
        ++entry;
        buffend += strlen(buffend);
    }

    strcat (buffer, "\n");
    OutputDebugString (buffer);

    unsigned int crcTotal, crcColor;

    PalCRCs (entries, crcTotal, crcColor);

    sprintf (buffer, "    palette crc %08x (color %08x)\n", crcTotal, crcColor);
    OutputDebugString (buffer);
}



/*****************************************************************************
Dump information about the given palette to the output debug stream.
*****************************************************************************/

void dumpddpal (LPDIRECTDRAWPALETTE palette)
{
    char buffer[128];
    PALETTEENTRY entries[256];
    HRESULT hres = palette->GetEntries (0, 0, 256, entries);

    if (FAILED (hres))
    {   sprintf (buffer, "    GetEntries on palette failed %x\n", hres);
        OutputDebugString (buffer);
        return;
    }

    dumppalentries (entries);
}



/*****************************************************************************
This function is intended to be called directly from the debugger to print out
information about a given DDraw surface.
*****************************************************************************/

void surfinfo (IDDrawSurface *surf)
{
    char buffer[128];

    OutputDebugString ("\n");

    sprintf (buffer, "Info Dump of Surface %p\n", surf);
    OutputDebugString (buffer);

    DDSURFACEDESC desc;
    HRESULT hres;

    desc.dwSize = sizeof(desc);
    desc.dwFlags = 0;

    if (FAILED (surf->GetSurfaceDesc(&desc)))
        return;

    if (desc.dwFlags & DDSD_CAPS)
    {
        static struct { DWORD value; char *string; } capsTable[] =
        {
            { DDSCAPS_ALPHA,              " alpha"              },
            { DDSCAPS_BACKBUFFER,         " backbuffer"         },
            { DDSCAPS_COMPLEX,            " complex"            },
            { DDSCAPS_FLIP,               " flip"               },
            { DDSCAPS_FRONTBUFFER,        " frontbuffer"        },
            { DDSCAPS_OFFSCREENPLAIN,     " offscreenplain"     },
            { DDSCAPS_OVERLAY,            " overlay"            },
            { DDSCAPS_PALETTE,            " palette"            },
            { DDSCAPS_PRIMARYSURFACE,     " primarysurface"     },
            { DDSCAPS_SYSTEMMEMORY,       " systemmemory"       },
            { DDSCAPS_TEXTURE,            " texture"            },
            { DDSCAPS_3DDEVICE,           " 3ddevice"           },
            { DDSCAPS_VIDEOMEMORY,        " videomemory"        },
            { DDSCAPS_VISIBLE,            " visible"            },
            { DDSCAPS_WRITEONLY,          " writeonly"          },
            { DDSCAPS_ZBUFFER,            " zbuffer"            },
            { DDSCAPS_OWNDC,              " owndc"              },
            { DDSCAPS_LIVEVIDEO,          " livevideo"          },
            { DDSCAPS_HWCODEC,            " hwcodec"            },
            { DDSCAPS_MODEX,              " modex"              },
            { DDSCAPS_MIPMAP,             " mipmap"             },
            { DDSCAPS_ALLOCONLOAD,        " alloconload"        },
            { 0, 0 }
        };

        sprintf (buffer, "DDSCAPS[%08x]:", desc.ddsCaps.dwCaps);

        for (int i=0;  capsTable[i].value;  ++i)
        {   if (desc.ddsCaps.dwCaps & capsTable[i].value)
                strcat (buffer, capsTable[i].string);
        }

        strcat (buffer, "\n");

        OutputDebugString (buffer);
    }

    if ((desc.dwFlags & (DDSD_HEIGHT|DDSD_WIDTH)) == (DDSD_HEIGHT|DDSD_WIDTH))
    {   sprintf (buffer, "Size %d x %d\n", desc.dwWidth, desc.dwHeight);
        OutputDebugString (buffer);
    }

    if (desc.dwFlags & DDSD_ALPHABITDEPTH)
    {   sprintf (buffer, "AlphaBitDepth %d\n", desc.dwAlphaBitDepth);
        OutputDebugString (buffer);
    }

    bool palettized = false;

    if (desc.dwFlags & DDSD_PIXELFORMAT)
    {
        DDPIXELFORMAT pf = desc.ddpfPixelFormat;

        sprintf (buffer, "Pixel Format: flags %08x", pf.dwFlags);

        if (pf.dwFlags & DDPF_FOURCC)
        {   int cc = pf.dwFourCC;
            strcat (buffer, ", fourCC ");
            char *end = buffer + strlen(buffer);
            *end++ = (cc >> 24) & 0xFF;
            *end++ = (cc >> 16) & 0xFF;
            *end++ = (cc >>  8) & 0xFF;
            *end++ = cc & 0xFF;
            *end = 0;
        }

        if (pf.dwFlags & DDPF_RGB)
        {   sprintf (buffer+strlen(buffer), ", %d-bit RGB (%x %x %x)",
                pf.dwRGBBitCount, pf.dwRBitMask, pf.dwGBitMask, pf.dwBBitMask);
            pf.dwFlags &= ~DDPF_RGB;   // Clear This Bit

            sprintf (buffer+strlen(buffer), ", alpha %x", pf.dwRGBAlphaBitMask);
        }

        if (pf.dwFlags & DDPF_PALETTEINDEXED8)
        {   strcat (buffer, ", 8-bit palettized");
            pf.dwFlags &= ~DDPF_PALETTEINDEXED8;   // Clear This Bit
            palettized = true;
        }

        // If any flags left that we haven't reported on, print them.

        if (pf.dwFlags)
        {   sprintf (buffer+strlen(buffer),
                " (unknown flags: %08x)", pf.dwFlags);
        }

        strcat (buffer, "\n");
        OutputDebugString (buffer);
    }

    if (desc.dwFlags & DDSD_ZBUFFERBITDEPTH)
    {   sprintf (buffer, "ZBuffer Depth %d\n", desc.dwZBufferBitDepth);
        OutputDebugString (buffer);
    }

    // If the surface is palettized, dump the palette.

    if (palettized)
    {
        LPDIRECTDRAWPALETTE ddpal;
        hres = surf->GetPalette(&ddpal);

        if (SUCCEEDED (hres))
            dumpddpal (ddpal);
        else
        {
            OutputDebugString ("    GetPalette() returned error ");
            switch (hres)
            {
                case DDERR_NOEXCLUSIVEMODE:
                    OutputDebugString ("NOEXCLUSIVEMODE\n"); break;

                case DDERR_NOPALETTEATTACHED:
                    OutputDebugString ("NOPALETTEATTACHED\n"); break;

                case DDERR_SURFACELOST:
                    OutputDebugString ("SURFACELOST\n"); break;

                default:
                {   sprintf (buffer, "%x\n", hres);
                    OutputDebugString (buffer);
                    break;
                }
            }
        }
    }

    // Dump the description of an attached Z buffer surface if present.

    DDSCAPS zbuffcaps = { DDSCAPS_ZBUFFER };
    IDirectDrawSurface *zsurf = NULL;

    hres = surf->GetAttachedSurface (&zbuffcaps, &zsurf);

    if (SUCCEEDED(hres) && zsurf)
    {   sprintf (buffer, "Attached ZBuffer Surface %p\n", zsurf);
        OutputDebugString (buffer);
        surfinfo (zsurf);
    }

    // Dump some clipper info
    
    LPDIRECTDRAWCLIPPER lpClip = NULL;
    hres = surf->GetClipper( &lpClip );
    if( SUCCEEDED(hres) )
    {   sprintf (buffer, "Clipper: Has a clipper attached %p\n", lpClip);
        OutputDebugString (buffer);
        //
        // Now grab the rectangle...
        //
        DWORD sz=0;
        lpClip->GetClipList(NULL, NULL, &sz);
        Assert(sz != 0);
        
        char *foo = THROWING_ARRAY_ALLOCATOR(char, sizeof(RGNDATA) + sz);
        RGNDATA *lpClipList = (RGNDATA *) ( &foo[0] );
        hres = lpClip->GetClipList(NULL, lpClipList, &sz);
        if(hres == DD_OK) {
            HRGN rgn = ExtCreateRegion(NULL, sz, lpClipList);
            RECT rect;
            GetRgnBox(rgn,&rect);
            char buf[256];
            wsprintf(buf,"Clipper: (%d,%d,%d,%d) \n", rect.left, rect.top, rect.right, rect.bottom);
            OutputDebugString(buf);
        }
        delete foo;
    } else if( hres == DDERR_NOCLIPPERATTACHED )
    {   sprintf (buffer, "Clipper: No clipper attached\n");
        OutputDebugString (buffer);
    } else
    {   OutputDebugString("Clipper: hresult = ");
        hresult(hres);
    }
    RELEASE( lpClip );


    // Dump Owning direct draw object
    IUnknown *lpUnk;
    DDObjFromSurface( surf, &lpUnk, true );
    RELEASE(lpUnk);    
}

void DDObjFromSurface(
    IDirectDrawSurface *lpdds,
    IUnknown **lplpDD,
    bool doTrace,
    bool forceTrace)
{
    //
    // assert that the directdraw object on the surface is
    // the same as the ddraw object is the same
    //

    IDirectDrawSurface2 *dds2 = NULL;
    dds2 = DDSurf1to2(lpdds);

    IDirectDraw *lpDD = NULL;
    HRESULT hr = dds2->GetDDInterface((void **) &lpDD);
    Assert( SUCCEEDED( hr ) );

    Assert( lplpDD );
    lpDD->QueryInterface(IID_IUnknown, (void **)lplpDD);
    Assert( *lplpDD );

    if( doTrace ) {
        if( forceTrace ) {
            TraceTag((tagError,
                      "for ddraw surface %x the underlying ddraw obj is: %x",
                      lpdds, *lplpDD));
        } else {
            TraceTag((tagDirectDrawObject,
                      "for ddraw surface %x the underlying ddraw obj is: %x",
                      lpdds, *lplpDD));
        }
    }
    
    // release the GetDDInterface reference
    RELEASE( lpDD );
    
    // release extra surface
    RELEASE( dds2 );
}    

#define WIDTH(rect) ((rect)->right - (rect)->left)
#define HEIGHT(rect) ((rect)->bottom - (rect)->top)

void showme(DDSurface *surf)
{
    showme2( surf->IDDSurface() );
}

void showme2(IDirectDrawSurface *surf)
{
    HDC srcDC;
    HRESULT hr = surf->GetDC(&srcDC);
    HDC destDC = GetDC(NULL);

    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    hr = surf->GetSurfaceDesc(&ddsd);

    RECT dr, sr;
    SetRect( &sr, 0,0, ddsd.dwWidth, ddsd.dwHeight);
    SetRect( &dr, 0,0, ddsd.dwWidth, ddsd.dwHeight);
    
    StretchBlt(destDC,
               dr.left,
               dr.top,
               dr.right - dr.left,
               dr.bottom - dr.top,
               srcDC,
               sr.left,
               sr.top,
               sr.right - sr.left,
               sr.bottom - sr.top,
               SRCCOPY);

    hr = surf->ReleaseDC(srcDC);
    
    ReleaseDC( NULL, destDC );    
}



void showmerect(IDirectDrawSurface *surf,
                RECT *r,
                POINT offset)
{
    HDC srcDC;
    HRESULT hr = surf->GetDC(&srcDC);
    HDC destDC = GetDC(NULL);

    RECT dr, sr;
    dr = sr = *r;
    OffsetRect( &dr, offset.x, offset.y );
    
    StretchBlt(destDC,
               dr.left,
               dr.top,
               dr.right - dr.left,
               dr.bottom - dr.top,
               srcDC,
               sr.left,
               sr.top,
               sr.right - sr.left,
               sr.bottom - sr.top,
               SRCCOPY);

    hr = surf->ReleaseDC(srcDC);
    
    ReleaseDC( NULL, destDC );    
}


//--------------------------------------------------
// Given a surface and an x,y pair, finds the 
// corresponding pixel.
// Be careful, this is a debug function so it
// doesn't even pretend to make sure you're not
// asking for a pixel in Tacoma...
//--------------------------------------------------

DWORD GetPixelXY(LPDDRAWSURFACE surf, int x, int y)
{
    DWORD pixel;
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_PITCH | DDSD_LPSURFACE;

    HRESULT _ddrval = surf->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    IfDDErrorInternal(_ddrval, "Couldn't lock surf in GetDDPixel");

    // rows
    BYTE *p = (BYTE *)ddsd.lpSurface + ddsd.lPitch * y;

    // columns
    switch (ddsd.ddpfPixelFormat.dwRGBBitCount) {
      case 8:
        pixel = *(p + x);
        break;
      case 16:
        pixel = *((WORD *)p + x);
        break;
      case 24:
        {
            BYTE *surfPtr = ((BYTE *)p + (3*x));
            BYTE byte1 = *surfPtr++;
            BYTE byte2 = *surfPtr++;
            BYTE byte3 = *surfPtr;
            pixel = byte1 << 16 | byte2 << 8 | byte3;
        }
        break;
      case 32:
        pixel = *((DWORD *)p + x);
        break;
    }
    surf->Unlock(ddsd.lpSurface);
    return pixel;
}


#endif  // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\crc.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Routines for calculating Cyclic-Redundancy Codes (CRC).  These are useful for
quickly comparing blocks of data to see if they differ.  CRC's are guaranteed
to be identical for identical blocks, but may also yield identical values for
different blocks (though unlikely).
*******************************************************************************/

#include "headers.h"



#if _DEBUG

// Right now this stuff is only used for debugging purposes.

#include "privinc/util.h"



int CRC32Table [256] =
{
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,

    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,

    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,

    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};



/*****************************************************************************
This routine takes a buffer and calculates the new or running 32-bit CRC code.
*****************************************************************************/

unsigned int crc32 (void *buffer, size_t length, unsigned int curr_val)
{
    // The incoming CRC value is inverted to handle intermediate values that
    // have been inverted before return.  Ultimately, the final is inverted
    // as the final step, though I'm not sure why.  I do it here to be faithful
    // to other CRC implementations (in case it matters).

    unsigned int  crc = ~curr_val;
    char         *ptr = (char*) buffer;

    while (length--)
    {   crc = ((crc >> 8) & 0xffffff) ^ CRC32Table [(crc ^ *ptr) & 0xff];
        ++ptr;
    }

    return ~crc;
}


#endif    // Debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\helpdm.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\d3dutil.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

This file contains utility functions for Direct3D.
*******************************************************************************/

#include "headers.h"

#include "d3drmdef.h"

#ifdef BUILD_USING_CRRM
#include <crrm.h>
#endif

#include "privinc/registry.h"
#include "privinc/ddutil.h"
#include "privinc/d3dutil.h"
#include "privinc/debug.h"
#include "privinc/hresinfo.h"
#include "privinc/xformi.h"
#include "privinc/colori.h"
#include "privinc/vec3i.h"


DeclareTag (tag3DForceDX3, "3D", "Force use of DX3 RM");

static CritSect *D3DUtilCritSect = NULL; // D3D Critical Section
HINSTANCE  hInstD3D = NULL;              // D3D Instance

#ifdef BUILD_USING_CRRM
HINSTANCE  hInstCRRM = NULL;             // CRRM Instance
#endif

Prefs3D    g_prefs3D;                    // 3D Preferences
bool       ntsp3;                        // Running NT Service Pack 3

static HRESULT WINAPI enumFunc
    (GUID*, char*, char*, D3DDEVICEDESC*, D3DDEVICEDESC*, void*);

static void UpdateUserPreferences (PrivatePreferences*, Bool);

static void ReleaseD3DRM1 (void);
static void ReleaseD3DRM3 (void);

    // The D3D device descriptor list contains the chosen software and hardware
    // rendering devices corresponding to specific DirectDraw objects.

static class D3DDeviceNode *D3DDeviceList = NULL;

class D3DDeviceNode
{
  public:

    D3DDeviceNode (IDirectDraw *ddraw) : _ddraw(ddraw)
    {
        _devs = NEW ChosenD3DDevices;
        _next = D3DDeviceList;
        D3DDeviceList = this;

        _devs->software.guid = GUID_NULL;
        _devs->hardware.guid = GUID_NULL;

        // Enumerate the 3D rendering devices using the DX5 enumeration
        // function if possible (this will include MMX renderers).  If not
        // at DX5+, then use the base 3D device enumeration.  Note that we
        // query for the D3D interface first, and then query for the D3D2
        // interface from that -- since we're using DDrawEx, we can't
        // immediately query for D3D2.

        IDirect3D  *d3d1;
        IDirect3D2 *d3d2;

        TD3D (ddraw->QueryInterface (IID_IDirect3D, (void**)&d3d1));

        if (SUCCEEDED (d3d1->QueryInterface (IID_IDirect3D2, (void**)&d3d2)))
        {   TD3D (d3d2->EnumDevices (enumFunc, _devs));
            d3d2->Release();
        }
        else
        {   TD3D (d3d1->EnumDevices (enumFunc, _devs));
        }

        d3d1->Release();
    }

    ~D3DDeviceNode () { delete _devs; }

    IDirectDraw      *_ddraw;   // DirectDraw Object
    ChosenD3DDevices *_devs;    // Chosen D3D Device Info
    D3DDeviceNode    *_next;    // Next Node
};



/*****************************************************************************
3D Modules Initialization and De-Initialization
*****************************************************************************/

extern void InitDDRender     (void);
extern void ShutdownDDRender (void);

void InitializeModule_3D (void)
{
    D3DUtilCritSect = NEW CritSect;
    ExtendPreferenceUpdaterList (UpdateUserPreferences);

    InitDDRender();
}

void DeinitializeModule_3D (bool shutdown)
{
    ShutdownDDRender();

    if (!shutdown)
    {   ReleaseD3DRM3 ();    // Release global shared D3D objects.
        ReleaseD3DRM1 ();
    }

    if (hInstD3D) FreeLibrary (hInstD3D);

#ifdef BUILD_USING_CRRM
    if (hInstCRRM) FreeLibrary (hInstCRRM);
#endif

    // Free up the list of chosen D3D devices.

    while (D3DDeviceList)
    {   D3DDeviceNode *ptr = D3DDeviceList;
        D3DDeviceList = ptr->_next;
        delete ptr;
    }

    delete D3DUtilCritSect;
}



/*****************************************************************************
This procedure snapshots the user preferences from the registry and stores the
values in the global 3D preferences structure.
*****************************************************************************/

static void UpdateUserPreferences (
    PrivatePreferences *prefs,
    Bool                isInitializationTime)
{
    g_prefs3D.lightColorMode =
        prefs->_rgbMode ? D3DCOLOR_RGB : D3DCOLOR_MONO;

    switch (prefs->_fillMode)
    {   default:
        case 0:  g_prefs3D.fillMode = D3DRMFILL_SOLID;      break;
        case 1:  g_prefs3D.fillMode = D3DRMFILL_WIREFRAME;  break;
        case 2:  g_prefs3D.fillMode = D3DRMFILL_POINTS;     break;
    }

    switch (prefs->_shadeMode)
    {   default:
        case 0:  g_prefs3D.shadeMode = D3DRMSHADE_FLAT;     break;
        case 1:  g_prefs3D.shadeMode = D3DRMSHADE_GOURAUD;  break;
        case 2:  g_prefs3D.shadeMode = D3DRMSHADE_PHONG;    break;
    }

    g_prefs3D.texturingQuality =
        prefs->_texturingQuality ? D3DRMTEXTURE_LINEAR : D3DRMTEXTURE_NEAREST;

    g_prefs3D.qualityFlags =
        g_prefs3D.fillMode | g_prefs3D.shadeMode | D3DRMLIGHT_ON;

    g_prefs3D.useMMX = prefs->_useMMX;

    g_prefs3D.dithering      = (prefs->_dithering != 0);
    g_prefs3D.texmapPerspect = (prefs->_texmapPerspect != 0);
    g_prefs3D.texmapping     = (prefs->_texmapping != 0);
    g_prefs3D.useHW          = (prefs->_useHW != 0);
    g_prefs3D.worldLighting  = (prefs->_worldLighting != 0);
}



/*****************************************************************************
This function returns a pointer to the main D3D retained-mode object.
*****************************************************************************/

static IDirect3DRM *d3drm1 = 0;   // Local Static Handle To Main D3DRM Object

static void LoadD3DRM1 (void)
{
    CritSectGrabber csg(*D3DUtilCritSect);

    // Catch the case where another thread loaded D3DRM while this thread was
    // blocked & waiting.

    if (d3drm1) return;

    if (!hInstD3D)
    {
        hInstD3D = LoadLibrary ("d3drm.dll");

        if (!hInstD3D)
        {   Assert(!"LoadLibrary of d3drm.dll failed");
            RaiseException_ResourceError (IDS_ERR_GEO_CREATE_D3DRM);
        }
    }

    FARPROC fptr = GetProcAddress (hInstD3D, "Direct3DRMCreate");

    if (!fptr)
    {   Assert( ! "GetProcAddress of Direct3DRMCreate failed");
        RaiseException_ResourceError (IDS_ERR_GEO_CREATE_D3DRM);
    }

    typedef HRESULT (WINAPI *D3DRMCreatorFunc)(IDirect3DRM* FAR *lplpD3D);

    D3DRMCreatorFunc creatorFunc = (D3DRMCreatorFunc)(fptr);
    HRESULT result = (*creatorFunc)(&d3drm1);

    if (result != D3DRM_OK)
        RaiseException_ResourceError (IDS_ERR_GEO_CREATE_D3DRM);

    // @@@ SRH DX3
    // Determine if we're running NT SP3 by looking at the version of
    // DirectX that we're running.

    ntsp3 = sysInfo.IsNT() && (sysInfo.VersionD3D() == 3) && !GetD3DRM3();

    TraceTag
        ((tagGRenderObj, "First call to GetD3DRM1 returns %x", d3drm1));

    // Now force the loading of the IDirect3DRM3 object if present.  This will
    // ensure that we're in right-hand mode if we're on RM6+.

    if (GetD3DRM3())
    {   TraceTag ((tagGRenderObj, "IDirect3DRM3 present"));
    }
}

/****************************************************************************/

static void ReleaseD3DRM1 (void)
{
    if (d3drm1)
    {   d3drm1->Release();
        d3drm1 = 0;
    }
}

/****************************************************************************/

#ifdef BUILD_USING_CRRM
IDirect3DRM3* GetD3DRM3 (void);
#endif

IDirect3DRM* GetD3DRM1 (void)
{
#ifdef BUILD_USING_CRRM
    if (!d3drm1) 
        d3drm1 = (IDirect3DRM*)GetD3DRM3();
#endif
    if (!d3drm1) LoadD3DRM1();

    return d3drm1;
}



/*****************************************************************************
This method returns the main RM6 interface.
*****************************************************************************/

static IDirect3DRM3 *d3drm3 = 0;         // Local Static Handle to D3DRM3
static bool d3drm3_initialized = false;  // Initialization Flag

void LoadD3DRM3 (void)
{
    #if _DEBUG
    {
        if (IsTagEnabled (tag3DForceDX3))
        {   d3drm3 = 0;
            d3drm3_initialized = true;
            return;
        }
    }
    #endif

    CritSectGrabber csg(*D3DUtilCritSect);

    // Catch the case where another thread loaded D3DRM3 while this thread was
    // blocked & waiting.

    if (d3drm3_initialized) return;

#ifdef BUILD_USING_CRRM
    if (!hInstCRRM)
    {
        hInstCRRM = LoadLibrary ("crrm.dll");

        if (!hInstCRRM)
        {   Assert(!"LoadLibrary of crrm.dll failed");
            RaiseException_ResourceError (IDS_ERR_GEO_CREATE_D3DRM);
        }
    }

    HRESULT result =
        CoCreateInstance(CLSID_CCrRM, NULL, CLSCTX_INPROC_SERVER,
                         IID_IDirect3DRM3, (LPVOID*)&d3drm3);
#else
    HRESULT result =
        GetD3DRM1()->QueryInterface (IID_IDirect3DRM3, (void**)&d3drm3);
#endif

    if (FAILED(result))
        d3drm3 = 0;
    else
    {
        // Set up D3DRM3 to be native right-handed.  This should never fail, so the
        // code will just assume it works.  We could fall back to RM1 in this
        // case, but that's just as bad an arbitrary failure as a handedness
        // problem.

        result = d3drm3->SetOptions (D3DRMOPTIONS_RIGHTHANDED);

        AssertStr (SUCCEEDED(result), "Right-handed mode failed.");
    }

    d3drm3_initialized = true;
}

/****************************************************************************/

static void ReleaseD3DRM3 (void)
{
    if (d3drm3)
    {   d3drm3 -> Release();
        d3drm3 = 0;
        d3drm3_initialized = false;
    }
}

/****************************************************************************/

IDirect3DRM3* GetD3DRM3 (void)
{
    if (!d3drm3_initialized) LoadD3DRM3();
    return d3drm3;
}




/*****************************************************************************
This procedure loads an Appelles transform into the D3DMATRIX4D.  D3D matrices
have their translation components in row 4, while Appelles matrices have their
translation components in column 4.
*****************************************************************************/

void LoadD3DMatrix (D3DRMMATRIX4D &d3dmat, Transform3 *xform)
{
    const Apu4x4Matrix *const M = &xform->Matrix();

    d3dmat[0][0] = D3DVAL (M->m[0][0]);
    d3dmat[0][1] = D3DVAL (M->m[1][0]);
    d3dmat[0][2] = D3DVAL (M->m[2][0]);
    d3dmat[0][3] = D3DVAL (M->m[3][0]);

    d3dmat[1][0] = D3DVAL (M->m[0][1]);
    d3dmat[1][1] = D3DVAL (M->m[1][1]);
    d3dmat[1][2] = D3DVAL (M->m[2][1]);
    d3dmat[1][3] = D3DVAL (M->m[3][1]);

    d3dmat[2][0] = D3DVAL (M->m[0][2]);
    d3dmat[2][1] = D3DVAL (M->m[1][2]);
    d3dmat[2][2] = D3DVAL (M->m[2][2]);
    d3dmat[2][3] = D3DVAL (M->m[3][2]);

    d3dmat[3][0] = D3DVAL (M->m[0][3]);
    d3dmat[3][1] = D3DVAL (M->m[1][3]);
    d3dmat[3][2] = D3DVAL (M->m[2][3]);
    d3dmat[3][3] = D3DVAL (M->m[3][3]);
}



/*****************************************************************************
This function returns a Transform3* from a D3D matrix.  The D3D matrix is in
the transpose form compared to the Transform3 matrices.  In other words, the
translation components are in the bottom row.
*****************************************************************************/

Transform3 *GetTransform3 (D3DRMMATRIX4D &d3dmat)
{
    return Transform3Matrix16
           (    d3dmat[0][0], d3dmat[1][0], d3dmat[2][0], d3dmat[3][0],
                d3dmat[0][1], d3dmat[1][1], d3dmat[2][1], d3dmat[3][1],
                d3dmat[0][2], d3dmat[1][2], d3dmat[2][2], d3dmat[3][2],
                d3dmat[0][3], d3dmat[1][3], d3dmat[2][3], d3dmat[3][3]
           );
}



/*****************************************************************************
This helper function returns the D3D color from a Color *value and an opacity.
*****************************************************************************/

    static inline int cval8bit (Real number) {
        return int (255 * CLAMP (number, 0, 1));
    }

D3DCOLOR GetD3DColor (Color *color, Real alpha)
{
    // D3D color components must lie in the range from 0 to 255.
    // Unfortunately, these colors are clamped to this range here rather than
    // in rendering since they are packed into a single 32-bit value, so we
    // can't support things like super lights or dark lights, even though D3D
    // IM supports it.

    return RGBA_MAKE
    (   cval8bit (color->red),
        cval8bit (color->green),
        cval8bit (color->blue),
        cval8bit (alpha)
    );
}



/*****************************************************************************
Conversion between D3D/D3DRM and DA Math Primitives
*****************************************************************************/

void LoadD3DVec (D3DVECTOR &d3dvec, Vector3Value &V)
{
    d3dvec.x = V.x;
    d3dvec.y = V.y;
    d3dvec.z = V.z;
}

void LoadD3DVec (D3DVECTOR &d3dvec, Point3Value &P)
{
    d3dvec.x = P.x;
    d3dvec.y = P.y;
    d3dvec.z = P.z;
}

void LoadD3DRMRay (D3DRMRAY &d3dray, Ray3 &ray)
{
    LoadD3DVec (d3dray.dvDir, ray.Direction());
    LoadD3DVec (d3dray.dvPos, ray.Origin());
}



/*****************************************************************************
This function is called by the Direct3D device-enumeration callback.  It
examines each device in turn to find the best matching hardware or software
device.
*****************************************************************************/

static HRESULT WINAPI enumFunc (
    GUID          *guid,      // This Device's GUID
    char          *dev_desc,  // Device Description String
    char          *dev_name,  // Device Name String
    D3DDEVICEDESC *hwDesc,    // HW Device Description
    D3DDEVICEDESC *swDesc,    // SW Device Description
    void          *context)   // Private enumArgs Struct Above
{

    // Use MMX device in preference to RGB device
    // the "special chrome" MMX device = standard MMX device now

    if (!(g_prefs3D.useMMX) && (*guid == IID_IDirect3DMMXDevice))
    {   TraceTag ((tag3DDevSelect, "Skipping MMX rendering device."));
        return D3DENUMRET_OK;
    }

    // Skip the reference rasterizer; it's only useful for visual validation
    // of 3D rendering devices (and it's slow).

    if (*guid == IID_IDirect3DRefDevice)
    {   TraceTag ((tag3DDevSelect, "Skipping reference rasterizer."));
        return D3DENUMRET_OK;
    }

    ChosenD3DDevices *chosenDevs = (ChosenD3DDevices*) context;

    // Determine if this is a hardware device by looking at the color model
    // field of the hardware driver description.  If the color model is 0
    // (invalid), then it's a software driver.

    bool hardware = (hwDesc->dcmColorModel != 0);

    D3DDeviceInfo *chosen;
    D3DDEVICEDESC *devdesc;

    if (hardware)
    {   chosen  = &chosenDevs->hardware;
        devdesc = hwDesc;
    }
    else
    {   chosen  = &chosenDevs->software;
        devdesc = swDesc;
    }

    #if _DEBUG
    if (IsTagEnabled(tag3DDevSelect))
    {
        char buff[2000];

        TraceTag ((tag3DDevSelect,
            "3D %s Device Description:", hardware ? "Hardware" : "Software"));

        wsprintf
        (   buff,
            "    %s (%s)\n"
            "    Flags %x, Color Model %d%s\n"
            "    DevCaps %x:\n",
            dev_desc, dev_name,
            devdesc->dwFlags,
            devdesc->dcmColorModel,
                (devdesc->dcmColorModel == D3DCOLOR_MONO) ? " (mono)" :
                (devdesc->dcmColorModel == D3DCOLOR_RGB)  ? " (rgb)"  : "",
            devdesc->dwDevCaps
        );

        OutputDebugString (buff);

        static struct { DWORD val; char *expl; } devcaptable[] =
        {
            { D3DDEVCAPS_FLOATTLVERTEX,
              "FLOATTLVERTEX: Accepts floating point" },

            { D3DDEVCAPS_SORTINCREASINGZ,
              "SORTINCREASINGZ: Needs data sorted for increasing Z" },

            { D3DDEVCAPS_SORTDECREASINGZ,
              "SORTDECREASINGZ: Needs data sorted for decreasing Z" },

            { D3DDEVCAPS_SORTEXACT,
              "SORTEXACT: Needs data sorted exactly" },

            { D3DDEVCAPS_EXECUTESYSTEMMEMORY,
              "EXECUTESYSTEMMEMORY: Can use execute buffers from system memory" },

            { D3DDEVCAPS_EXECUTEVIDEOMEMORY,
              "EXECUTEVIDEOMEMORY: Can use execute buffers from video memory" },

            { D3DDEVCAPS_TLVERTEXSYSTEMMEMORY,
              "TLVERTEXSYSTEMMEMORY: Can use TL buffers from system memory" },

            { D3DDEVCAPS_TLVERTEXVIDEOMEMORY,
              "TLVERTEXVIDEOMEMORY: Can use TL buffers from video memory" },

            { D3DDEVCAPS_TEXTURESYSTEMMEMORY,
              "TEXTURESYSTEMMEMORY: Can texture from system memory" },

            { D3DDEVCAPS_TEXTUREVIDEOMEMORY,
              "TEXTUREVIDEOMEMORY: Can texture from device memory" },

            { D3DDEVCAPS_DRAWPRIMTLVERTEX,
              "DRAWPRIMTLVERTEX: Can draw TLVERTEX primitives" },

            { D3DDEVCAPS_CANRENDERAFTERFLIP,
              "CANRENDERAFTERFLIP: Can render without waiting for flip to complete" },

            { D3DDEVCAPS_TEXTURENONLOCALVIDMEM,
              "TEXTURENONLOCALVIDMEM: Device can texture from nonlocal video memory" },

            { 0, 0 }
        };

        unsigned int i;
        for (i=0;  devcaptable[i].val;  ++i)
        {
            if (devdesc->dwDevCaps & devcaptable[i].val)
            {
                wsprintf (buff, "        %s\n", devcaptable[i].expl);
                OutputDebugString (buff);
            }
        }

        wsprintf
        (   buff,
            "    TransformCaps %x, Clipping %d\n"
            "    Lighting: Caps %x, Model %x, NumLights %d\n"
            "    Line Caps: Misc %x, Raster %x, Zcmp %x, SrcBlend %x\n"
            "               DestBlend %x, AlphaCmp %x, Shade %x, Texture %x\n"
            "               TexFilter %x, TexBlend %x, TexAddr %x\n"
            "               Stipple Width %x, Stipple Height %x\n"
            "    Tri  Caps: Misc %x, Raster %x, Zcmp %x, SrcBlend %x\n"
            "               DestBlend %x, AlphaCmp %x, Shade %x, Texture %x\n"
            "               TexFilter %x, TexBlend %x, TexAddr %x\n"
            "               Stipple Width %x, Stipple Height %x\n"
            "    Render Depth %x, Zbuffer Depth %x\n"
            "    Max Buffer Size %d, Max Vertex Count %d\n",
            devdesc->dtcTransformCaps.dwCaps,
            devdesc->bClipping,
            devdesc->dlcLightingCaps.dwCaps,
            devdesc->dlcLightingCaps.dwLightingModel,
            devdesc->dlcLightingCaps.dwNumLights,
            devdesc->dpcLineCaps.dwMiscCaps,
            devdesc->dpcLineCaps.dwRasterCaps,
            devdesc->dpcLineCaps.dwZCmpCaps,
            devdesc->dpcLineCaps.dwSrcBlendCaps,
            devdesc->dpcLineCaps.dwDestBlendCaps,
            devdesc->dpcLineCaps.dwAlphaCmpCaps,
            devdesc->dpcLineCaps.dwShadeCaps,
            devdesc->dpcLineCaps.dwTextureCaps,
            devdesc->dpcLineCaps.dwTextureFilterCaps,
            devdesc->dpcLineCaps.dwTextureBlendCaps,
            devdesc->dpcLineCaps.dwTextureAddressCaps,
            devdesc->dpcLineCaps.dwStippleWidth,
            devdesc->dpcLineCaps.dwStippleHeight,
            devdesc->dpcTriCaps.dwMiscCaps,
            devdesc->dpcTriCaps.dwRasterCaps,
            devdesc->dpcTriCaps.dwZCmpCaps,
            devdesc->dpcTriCaps.dwSrcBlendCaps,
            devdesc->dpcTriCaps.dwDestBlendCaps,
            devdesc->dpcTriCaps.dwAlphaCmpCaps,
            devdesc->dpcTriCaps.dwShadeCaps,
            devdesc->dpcTriCaps.dwTextureCaps,
            devdesc->dpcTriCaps.dwTextureFilterCaps,
            devdesc->dpcTriCaps.dwTextureBlendCaps,
            devdesc->dpcTriCaps.dwTextureAddressCaps,
            devdesc->dpcTriCaps.dwStippleWidth,
            devdesc->dpcTriCaps.dwStippleHeight,
            devdesc->dwDeviceRenderBitDepth,
            devdesc->dwDeviceZBufferBitDepth,
            devdesc->dwMaxBufferSize,
            devdesc->dwMaxVertexCount
        );

        OutputDebugString (buff);
    }
    #endif

    // If we've already chosen the MMX device, then we don't want to choose any
    // other device over it.

    if (chosen->guid == IID_IDirect3DMMXDevice)
    {   TraceTag ((tag3DDevSelect,
            "Skipping - already have an MMX device for software rendering."));
        return D3DENUMRET_OK;
    }

    // Skip this device if it's a software renderer that doesn't support the
    // requested lighting color model.

    if (!(devdesc->dcmColorModel & g_prefs3D.lightColorMode))
    {   TraceTag ((tag3DDevSelect, "Skipping - color model %x unsupported.",
            g_prefs3D.lightColorMode));
        return D3DENUMRET_OK;
    }

    // Ensure that this device supports all lights we care about, and doesn't
    // place restrictions on the number of lights.

    if (!(devdesc->dwFlags & D3DDD_LIGHTINGCAPS))
    {   TraceTag ((tag3DDevSelect, "No lighting information available."));
    }
    else
    {
        if (devdesc->dlcLightingCaps.dwNumLights)
        {   TraceTag ((tag3DDevSelect,
                "Skipping - Limited to %d lights maximum.",
                devdesc->dlcLightingCaps.dwNumLights));
            return D3DENUMRET_OK;
        }

        const DWORD lightTypes =
            D3DLIGHTCAPS_DIRECTIONAL | D3DLIGHTCAPS_POINT | D3DLIGHTCAPS_SPOT;

        if (lightTypes != (devdesc->dlcLightingCaps.dwCaps & lightTypes))
        {   TraceTag ((tag3DDevSelect,
                "Skipping - does not support all light types."));
            return D3DENUMRET_OK;
        }
    }

    // Ensure that the device supports texmapping.

    if (!devdesc->dpcTriCaps.dwTextureCaps)
    {   TraceTag ((tag3DDevSelect,
            "Skipping - doesn't support texture-mapping."));
        return D3DENUMRET_OK;
    }

    // Ensure that the device supports the required cull modes.  If we're on
    // RM3 (DX6), then we need clockwise culling since we'll be using
    // RM's right-hand mode.

    DWORD cullmodes;

    if (GetD3DRM3())
        cullmodes = D3DPMISCCAPS_CULLCCW | D3DPMISCCAPS_CULLCW;
    else
        cullmodes = D3DPMISCCAPS_CULLCCW;

    if (!(devdesc->dpcTriCaps.dwMiscCaps & cullmodes))
    {   TraceTag ((tag3DDevSelect,
            "Skipping - doesn't support required culling orders."));
        return D3DENUMRET_OK;
    }

    // This device passes all tests; choose it.

    TraceTag ((tag3DDevSelect, "Choosing this device"));

    chosen->desc = *devdesc;
    chosen->guid = *guid;

    return D3DENUMRET_OK;
}



/*****************************************************************************
This function launches the Direct3D device enumeration sequence to find the
preferred matching 3D rendering device for both software & hardware rendering.
*****************************************************************************/

ChosenD3DDevices* SelectD3DDevices (IDirectDraw *ddraw)
{
    CritSectGrabber csg (*D3DUtilCritSect);

    Assert (ddraw);

    // First see if we've already selected D3D devices for this particular
    // DDraw object.  If so, just return the cached information.

    D3DDeviceNode *ptr = D3DDeviceList;

    TraceTag ((tag3DDevSelect,
        "Querying chosen 3D devices for DDraw object %x", ddraw));

    DebugCode (int count=0;)

    while (ptr && (ptr->_ddraw != ddraw))
    {   DebugCode (++count;)
        ptr = ptr->_next;
    }

    if (ptr)
    {   TraceTag ((tag3DDevSelect,
            "Found existing info (node %d)", 1-count));
        return ptr->_devs;
    }

    // DDraw object not present in list, so create a NEW node and return the
    // devices' description.

    TraceTag ((tag3DDevSelect, "%d nodes examined, DDraw %x not encountered",
               count, ddraw));

    D3DDeviceNode *newnode = NEW D3DDeviceNode (ddraw);

    return newnode->_devs;   // Return the winning GUID.
}



/*****************************************************************************
*****************************************************************************/

RMTextureWrap::RMTextureWrap(void)
{
    _wrapObj = NULL;
}

RMTextureWrap::RMTextureWrap(TextureWrapInfo *info,Bbox3* bbox)
{
    _wrapObj = NULL;
    Init(info,bbox);
}

RMTextureWrap::~RMTextureWrap(void)
{
    if (_wrapObj) {
        _wrapObj->Release();
    }
}

void RMTextureWrap::Init(TextureWrapInfo *info,Bbox3* bbox)
{
    if (_wrapObj) {
        _wrapObj->Release();
        _wrapObj = NULL;
    }

    _wrapU = info->wrapU;
    _wrapV = info->wrapV;

    if (info->relative && bbox && bbox->Finite()) {
        info->origin = *(bbox->Center());
        Real boxSizeX = fabs(bbox->max.x - bbox->min.x);
        Real boxSizeY = fabs(bbox->max.y - bbox->min.y);
        switch ((D3DRMWRAPTYPE) info->type) {
        case D3DRMWRAP_FLAT :
        case D3DRMWRAP_SHEET :
        case D3DRMWRAP_BOX :
            if (boxSizeX > 0.0) {
                info->texScale.x /= boxSizeX;
            }
            // fall-through
        case D3DRMWRAP_CYLINDER :
            if (boxSizeY > 0.0) {
                info->texScale.y /= boxSizeY;
            }
            break;
        default:
            break;
        }
    }
    HRESULT hr = AD3D(GetD3DRM3()->CreateWrap(
            (D3DRMWRAPTYPE) info->type, NULL,
            info->origin.x,info->origin.y,info->origin.z,
            info->z.x,info->z.y,info->z.z,
            info->y.x,info->y.y,info->y.z,
            info->texOrigin.x,info->texOrigin.y,
            info->texScale.x,info->texScale.y,
            &_wrapObj));

    if (FAILED(hr)) {
        TraceTag((tagError, "Cannot create D3DRMWrap object"));
        _wrapObj = NULL;
    }
}

HRESULT RMTextureWrap::Apply(IDirect3DRMVisual *vis)
{
    HRESULT hr = E_FAIL;

    if (_wrapObj && vis) {
        hr = RD3D(_wrapObj->Apply(vis));
    }

    return hr;
}

HRESULT RMTextureWrap::ApplyToFrame(
    IDirect3DRMFrame3   *pFrame)
{
    HRESULT hres;
    DWORD   dwI;
    DWORD   dwNumVisuals;
    IUnknown **ppIUnk;

    if (!_wrapObj) {
        return E_FAIL;
    }

    // Iterate over all visuals setting the texture topology
    hres = RD3D(pFrame->GetVisuals(&dwNumVisuals,NULL));
    if (FAILED(hres))
    {
        return (hres);
    }
    ppIUnk = new LPUNKNOWN[dwNumVisuals];
    if (!ppIUnk)
    {
        return E_OUTOFMEMORY;
    }
    hres = RD3D(pFrame->GetVisuals(&dwNumVisuals,ppIUnk));
    if (FAILED(hres))
    {
        return (hres);
    }
    for (dwI = 0; dwI < dwNumVisuals; dwI++)
    {
        LPDIRECT3DRMVISUAL pVis;
        LPDIRECT3DRMMESHBUILDER3 pMB;

        if (SUCCEEDED(ppIUnk[dwI]->QueryInterface(IID_IDirect3DRMMeshBuilder3, (LPVOID*)&pMB)))
        {
            RD3D(_wrapObj->Apply(pMB));
            pMB->Release();
        }
        ppIUnk[dwI]->Release();
    }
    delete[] ppIUnk;

    // Recurse over child frames
    LPDIRECT3DRMFRAMEARRAY pFrameArray;

    hres = RD3D(pFrame->GetChildren(&pFrameArray));
    if (FAILED(hres))
    {
        return (hres);
    }
    for (dwI = 0; dwI < pFrameArray->GetSize(); dwI++)
    {
        IDirect3DRMFrame  *pFrameTmp;
        IDirect3DRMFrame3 *pFrame;

        hres = RD3D(pFrameArray->GetElement(dwI, &pFrameTmp));
        if (FAILED(hres))
        {
            pFrameArray->Release();
            return (hres);
        }
        hres = pFrameTmp->QueryInterface(IID_IDirect3DRMFrame3,(LPVOID *) &pFrame);
        if (FAILED(hres))
        {
            pFrameTmp->Release();
            pFrameArray->Release();
            return (hres);
        }
        hres = ApplyToFrame(pFrame);
        if (FAILED(hres))
        {
            pFrame->Release();
            pFrameTmp->Release();
            pFrameArray->Release();
            return (hres);
        }
        pFrame->Release();
    }
    pFrameArray->Release();

    return (S_OK);
}

bool RMTextureWrap::WrapU(void)
{
    return _wrapU;
}

bool RMTextureWrap::WrapV(void)
{
    return _wrapV;
}


HRESULT SetRMFrame3TextureTopology(
    IDirect3DRMFrame3 *pFrame,
    bool wrapU,
    bool wrapV)
{
    HRESULT hres;
    DWORD   dwI;
    DWORD   dwNumVisuals;
    IUnknown **ppIUnk;

    // Iterate over all visuals setting the texture topology
    hres = RD3D(pFrame->GetVisuals(&dwNumVisuals,NULL));
    if (FAILED(hres))
    {
        return (hres);
    }
    ppIUnk = new LPUNKNOWN[dwNumVisuals];
    if (!ppIUnk)
    {
        return E_OUTOFMEMORY;
    }
    hres = RD3D(pFrame->GetVisuals(&dwNumVisuals,ppIUnk));
    if (FAILED(hres))
    {
        return (hres);
    }
    for (dwI = 0; dwI < dwNumVisuals; dwI++)
    {
        LPDIRECT3DRMVISUAL pVis;
        LPDIRECT3DRMMESHBUILDER3 pMB;

        if (SUCCEEDED(ppIUnk[dwI]->QueryInterface(IID_IDirect3DRMMeshBuilder3, (LPVOID*)&pMB)))
        {
            RD3D(pMB->SetTextureTopology((BOOL) wrapU, (BOOL) wrapV));
            pMB->Release();
        }
        ppIUnk[dwI]->Release();
    }
    delete[] ppIUnk;

    // Recurse over child frames
    LPDIRECT3DRMFRAMEARRAY pFrameArray;

    hres = RD3D(pFrame->GetChildren(&pFrameArray));
    if (FAILED(hres))
    {
        return (hres);
    }
    for (dwI = 0; dwI < pFrameArray->GetSize(); dwI++)
    {
        IDirect3DRMFrame  *pFrameTmp;
        IDirect3DRMFrame3 *pFrame;

        hres = RD3D(pFrameArray->GetElement(dwI, &pFrameTmp));
        if (FAILED(hres))
        {
            pFrameArray->Release();
            return (hres);
        }
        hres = pFrameTmp->QueryInterface(IID_IDirect3DRMFrame3,(LPVOID *) &pFrame);
        if (FAILED(hres))
        {
            pFrameTmp->Release();
            pFrameArray->Release();
            return (hres);
        }
        hres = SetRMFrame3TextureTopology(pFrame,wrapU,wrapV);
        if (FAILED(hres))
        {
            pFrame->Release();
            pFrameTmp->Release();
            pFrameArray->Release();
            return (hres);
        }
        pFrame->Release();
    }
    pFrameArray->Release();

    return (S_OK);
}


//----------------------------------------------------------------------------
//                        D E B U G   F U N C T I O N S
//----------------------------------------------------------------------------
#if _DEBUG

/*****************************************************************************
Debugging function to dump information about a D3D mesh object.
*****************************************************************************/

void dumpmesh (IDirect3DRMMesh *mesh)
{
    char buff[1024];

    unsigned int ngroups = mesh->GetGroupCount();

    sprintf (buff, "Dumping info for mesh %p\n    %u groups\n", mesh, ngroups);
    OutputDebugString (buff);

    unsigned int i;

    for (i=0;  i < ngroups;  ++i)
    {
        unsigned int nfaces;   // Number of Faces
        unsigned int nverts;   // Number of Vertices
        unsigned int vpface;   // Number of Vertices Per Face
        DWORD junk;

        if (SUCCEEDED (mesh->GetGroup (i, &nverts,&nfaces,&vpface, &junk, 0)))
        {
            sprintf (buff,
                "    Group %u:  %u vertices, %u faces, %u verts per face\n",
                i, nverts, nfaces, vpface);
            OutputDebugString (buff);
        }
    }
}



void
IndentStr(char *str, int indent)
{
    for (int i = 0; i < indent; i++) {
        OutputDebugString(" ");
    }
    OutputDebugString(str);
}



void
dumpbuilderhelper(IUnknown *unk, int indent)
{
    char buf[256];
    IDirect3DRMMeshBuilder3 *mb;
    HRESULT hr =
        unk->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                            (void **)&mb);

    if (FAILED(hr)) {
        IndentStr("Not a meshbuilder", indent);
        return;
    }

    IDXBaseObject *baseObj;
    TD3D(mb->QueryInterface(IID_IDXBaseObject, (void **)&baseObj));

    ULONG genId;
    TD3D(baseObj->GetGenerationId(&genId));
    baseObj->Release();

    sprintf(buf, "Meshbuilder %p, unk %p, generation id %d\n",
        mb, unk, genId);
    IndentStr(buf, indent);

    ULONG faces = mb->GetFaceCount();
    sprintf(buf, "%d faces\n", faces);
    IndentStr(buf, indent);

    D3DRMBOX rmbox;
    mb->GetBox (&rmbox);
    sprintf (buf, "       bbox {%g,%g,%g} x {%g,%g,%g}\n",
        rmbox.min.x, rmbox.min.y, rmbox.min.z,
        rmbox.max.x, rmbox.max.y, rmbox.max.z);
    IndentStr (buf, indent);

    DWORD nverts;

    if (SUCCEEDED(mb->GetVertices (0, &nverts, 0)))
    {
        sprintf (buf, "%d vertices\n", nverts);
        IndentStr (buf, indent);

        D3DVECTOR *verts = NEW D3DVECTOR[nverts];

        if (SUCCEEDED (mb->GetVertices (0, &nverts, verts)))
        {
            Bbox3 bbox;
            int i;

            for (i=0;  i < nverts;  ++i)
                bbox.Augment (verts[i].x, verts[i].y, verts[i].z);

            sprintf (buf, "actual bbox {%g,%g,%g} x {%g,%g,%g}\n",
                bbox.min.x, bbox.min.y, bbox.min.z,
                bbox.max.x, bbox.max.y, bbox.max.z);
            IndentStr (buf, indent);
        }

        delete verts;
    }

    ULONG submeshCount;
    TD3D(mb->GetSubMeshes(&submeshCount, NULL));

    sprintf(buf, "%d submeshes\n", submeshCount);
    IndentStr(buf, indent);

    IUnknown *submeshes[50];
    TD3D(mb->GetSubMeshes(&submeshCount, submeshes));

    for (int i = 0; i < submeshCount; i++) {
        sprintf(buf, "submesh %d, unk is %p\n",
                i, submeshes[i]);
        IndentStr(buf, indent);
    }

    OutputDebugString("\n");

    for (i = 0; i < submeshCount; i++) {
        dumpbuilderhelper(submeshes[i], indent + 4);
        submeshes[i]->Release();
    }

    mb->Release();
}

void dumpbuilder(IUnknown *unk)
{
    dumpbuilderhelper(unk, 0);
}



/*****************************************************************************
This debug-only function gets the DDraw surface associated with a given RM
texture.
*****************************************************************************/

IDirectDrawSurface* getTextureSurface (IUnknown *unknown)
{
    IDirect3DRMTexture3 *texture;

    if (FAILED(unknown->QueryInterface(IID_IDirect3DRMTexture3, (void**)&texture)))
    {   OutputDebugString ("Object is not an IDirect3DRMTexture3.\n");
        return 0;
    }

    IDirectDrawSurface  *surface;

    if (FAILED(texture->GetSurface(0, &surface)))
    {   OutputDebugString
            ("Couldn't get surface (texture created some other way).\n");
        texture->Release();
        return 0;
    }

    texture->Release();
    return surface;
}



/*****************************************************************************
This debug-only routine dumps info about the surface associated with an RM
texture.
*****************************************************************************/

void texsurfinfo (IUnknown *unknown)
{
    IDirectDrawSurface *surface = getTextureSurface (unknown);

    void surfinfo (IDirectDrawSurface*);

    if (surface)
    {   surfinfo (surface);
        surface->Release();
    }
}



/*****************************************************************************
This debug-only routine blits the texture image to the screen for examination.
*****************************************************************************/

void showtexture (IUnknown *unknown)
{
    IDirectDrawSurface *surface = getTextureSurface (unknown);

    if (surface)
    {   showme2(surface);
        surface->Release();
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\helpm.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\ddsurf.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

     DDSurface implementation.  A utility class to wrap and provide
     functionality for DirectDraw surfaces.

*******************************************************************************/


#include "headers.h"

#include "ddraw.h"
#include "privinc/ddsurf.h"
#include "privinc/viewport.h"




GenericSurface::GenericSurface() :
     _ref(1) // start with a ref of 1
{
}


RECT *GDISurface::GetSurfRect(void)
{
    _surfRect.left = 0;
    _surfRect.top = 0;

    HBITMAP hBitmap = (HBITMAP) GetCurrentObject(_targetDC,OBJ_BITMAP);
    SIZE    dimension;
    if (GetBitmapDimensionEx(hBitmap,&dimension)) {
        _surfRect.right = dimension.cx;
        _surfRect.bottom = dimension.cy;
    } else {
        Assert(FALSE && "GDISurface::GetSurfRect() cannot get the bitmap's dimensions");
        _surfRect.right = 0;
        _surfRect.bottom = 0;
    }

    return &_surfRect;
}


DDSurface::DDSurface(
    IDDrawSurface *surface,
    const Bbox2 &box,
    RECT *rect,
    Real res,
    DWORD colorKey,
    bool colorKeyIsValid,
    bool isWrapper,
    bool isTexture
    DEBUG_ARG1(char *explanation))
{
    _Init(surface, box, rect,
          res, colorKey, colorKeyIsValid,
          isWrapper, isTexture);

    #if _DEBUG
    //
    // DEBUG ONLY CODE
    //

    _explanation = explanation;
    Assert(_explanation);

    DDSURFACEDESC desc;  desc.dwSize=sizeof(desc);
    desc.dwFlags = DDSD_PITCH;
    _ddrval = IDDSurface()->GetSurfaceDesc(&desc);
    if(!_isWrapper) {

        bool dontCreateOne = true;
        DirectDrawViewport *vp = GetCurrentViewport( dontCreateOne );

        //Assert((vp != NULL) || IsInitializing());

        if (vp)
        {
#ifdef _DEBUGSURFACE
            vp ->Tracker()->NewSurface(this);
#endif /* _DEBUGSURFACE */
            
            TraceTag((tagViewportMemory,
                      " ------>>>DDSurface: %x created %s memory surf=%x for %x. size=(%d,%d,  %d)",
                      this,
                      IsSystemMemory() ? "system" : "video",
                      _ddsurf.p,
                      _explanation,
                      Width(), Height(),
                      desc.lPitch * Height()));
        }
    }
    #endif // _DEBUG
}

    

// called on construction
void DDSurface::_Init(
    IDDrawSurface *surface,
    const Bbox2 &box,
    RECT *rect,
    Real res,
    DWORD colorKey,
    bool colorKeyIsValid,
    bool isWrapper,
    bool isTexture)
{
    _capsReady = false;
    _res = res;

    SetSurfaceType(GenericSurface::ddrawSurface);

    SetSurfacePtr(surface);

    SetConvertedSurface(NULL);
    SetZBuffer(NULL);

    _dc = NULL;
    _dcRef = 0;
    _isWrapper = isWrapper;
    _associatedGeomDev = NULL;
    _isTextureSurf = isTexture;

    if(box != NullBbox2) {
        _bbox.min = box.min;
        _bbox.max = box.max;
    } else {
        _bbox.min.Set(0,0);
        _bbox.max.Set(0,0);
    }

    SetSurfRect(rect);
    SetInterestingSurfRect(rect);

    _colorKey = colorKey;
    _colorKeyIsValid = colorKeyIsValid;

/*
    // TODO ...the below code show be used instead of above code.

    if(colorKeyIsValid) {
        SetColorKey(colorKey);
    }
*/
    _timeStamp = -HUGE_VAL;
}


void DDSurface::_UpdateSurfCaps(void)
{
    Assert(IDDSurface());
    //
    // Get surface caps
    //
    DDSCAPS ddscaps = { 0 };
    _ddrval = IDDSurface()->GetCaps(&ddscaps);
    IfDDErrorInternal(_ddrval, "Couldn't get caps on surface");
    _systemMemorySurface = ddscaps.dwCaps & DDSCAPS_SYSTEMMEMORY ? true : false;
    _isZBufferSurface = ddscaps.dwCaps & DDSCAPS_ZBUFFER ? true : false;

    //
    // Get surface desc
    //

    DDSURFACEDESC desc;
    desc.dwSize = sizeof(desc);
    desc.dwFlags = 0;
    _ddrval = IDDSurface()->GetSurfaceDesc(&desc);
    IfDDErrorInternal(_ddrval, "Couldn't get the surface description");
    Assert((desc.dwFlags & (DDSD_HEIGHT|DDSD_WIDTH)) == (DDSD_HEIGHT|DDSD_WIDTH));
    if ((desc.dwFlags & (DDSD_HEIGHT|DDSD_WIDTH)) == (DDSD_HEIGHT|DDSD_WIDTH))
    {   
        RECT r;  
        SetRect( &r, 0, 0, desc.dwWidth, desc.dwHeight );
        SetSurfRect(&r);

        Bbox2 destBox;
        RectToBbox(desc.dwWidth, desc.dwHeight,destBox,Resolution());
        SetBbox(destBox);

    }
    
    ZeroMemory(&_pixelFormat, sizeof(_pixelFormat));
    _pixelFormat.dwSize = sizeof(_pixelFormat);
    
    if (desc.dwFlags & DDSD_PIXELFORMAT) {
        _pixelFormat = desc.ddpfPixelFormat;
    }
    else {
        _ddrval = IDDSurface()->GetPixelFormat(&_pixelFormat);
    }
    
    _capsReady = true;
}

void DDSurface::_MakeSureIDXSurface(IDXSurfaceFactory *sf)
{
    if( !_IDXSurface ) {
        // do the creation.
        HRESULT hr;

        Assert( GetPixelFormat().dwRGBBitCount == 32 );
        
        hr = CreateFromDDSurface(sf, this, &DDPF_PMARGB32, &_IDXSurface);

        if( FAILED(hr) ) {
            // Since we failed the first attempt try again but without a pixel format.
            hr = CreateFromDDSurface(sf, this, NULL, &_IDXSurface);
        }
        
        if( FAILED(hr) ) {
            RaiseException_InternalError("Create IDXSurface from DDSurface failed");
        }
    }
    Assert( _IDXSurface );
}

DDSurface::~DDSurface()
{
    Assert((_dcRef == 0) && "Bad ref on DDSurface destruction");

    if(!_isWrapper)
        DestroyGeomDevice();

    Assert(_ddsurf.p);

    if(!_isWrapper)
        _ddsurf->SetClipper (NULL);

    // purposely NOT releaseing videoReader because movieImage owns it
    // and is responsible for detroying it.
    
    TraceTag((tagViewportMemory,
              " <<<-----DDSurface: %x destroyed %s memory %ssurf=%x",
              this,
              IsSystemMemory() ? "system" : "video",
              IsZBuffer() ? "zbuffer " : "",
              _ddsurf.p));

    #if _DEBUGSURFACE
    if( !_isWrapper ) {
        DirectDrawViewport *vp = GetCurrentViewport();

        Assert((vp != NULL) || IsInitializing());
        
        if (vp)
            vp->Tracker()->DeleteSurface(this);
    }
    #endif
}


HDC DDSurface::GetDC(char *errStr)
{
    Assert(_ddsurf.p);
    if(_dcRef <= 0) {
        _ddrval = _ddsurf->GetDC(&_dc);
        if( _ddrval == DDERR_SURFACELOST ) {
            _ddrval = _ddsurf->Restore();
            if( SUCCEEDED( _ddrval ) ) // try again
                _ddrval = _ddsurf->GetDC(&_dc);         
        }
        IfDDErrorInternal(_ddrval, errStr);
    }
        
    _dcRef++;
    return _dc;
}

void DDSurface::ReleaseDC(char *errStr)
{
                       
    Assert( (_dcRef > 0) && "Bad _dcRef in DDSurface class");

    _dcRef--;
    _ddrval = DD_OK;
        
    Assert(_ddsurf.p);
    if(_dcRef <= 0) {
        _ddrval = _ddsurf->ReleaseDC(_dc);
        if( _ddrval == DDERR_SURFACELOST ) {
            _ddrval = _ddsurf->Restore();
        }
        _dc = NULL;
    }
        
    IfDDErrorInternal(_ddrval, errStr);
}
    
void DDSurface::_hack_ReleaseDCIfYouHaveOne()
{
    if( _dc ) {
        Assert(_dcRef>0);
        _ddrval = _ddsurf->ReleaseDC(_dc);
        _dc = NULL;
        _dcRef = 0;
    }
}
    
HRESULT DDSurface::SetZBuffer(DDSurface *zb)
{
    _zbuffer = zb;
    if(zb) {
        Assert(zb->Width() == Width()  && "DDSurface::SetZBuffer: diff width");
        Assert(zb->Height() == Height()&& "DDSurface::SetZBuffer: diff height");
        Assert(zb->IsZBuffer() && "SetZBuffer: surface must be zuffer");
        _ddrval = IDDSurface()->AddAttachedSurface( zb->IDDSurface() );
    }
    return _ddrval;
}

void DDSurface::DestroyGeomDevice()
{                       
    TraceTag((tagViewportMemory,
              "DDSurf %x: destroying geomDevice %x",
              this, GeomDevice()));
    delete GeomDevice();
    SetGeomDevice( NULL );
}
        
void DDSurface::UnionInterestingRect(RECT *rect)
{
    // make sure we're in the surface's bounds
    RECT intRect;
    IntersectRect(&intRect, &_surfRect, rect);
    
    // now union that rect with the current interesting rect
    UnionRect( &_interestingRect, &_interestingRect, &intRect );
}    


HRGN DDSurface::GetClipRgn()
{
    //
    // Look in the surface for a current clipper
    //
    LPDIRECTDRAWCLIPPER currClipp;
    HRESULT hr = IDDSurface()->GetClipper( &currClipp );
    if( FAILED(hr) ) {
        return NULL;
    }

    Assert( currClipp );
    
    //
    // Now grab the rectangle...
    //
    DWORD sz=0;
    currClipp->GetClipList(NULL, NULL, &sz);
    Assert(sz != 0);
        
    char *foo = THROWING_ARRAY_ALLOCATOR(char, sizeof(RGNDATA) + sz);
    RGNDATA *lpClipList = (RGNDATA *) ( &foo[0] );
    hr = currClipp->GetClipList(NULL, lpClipList, &sz);
    if(hr != DD_OK) return NULL;

    HRGN rgn = ExtCreateRegion(NULL, sz, lpClipList);
    delete foo;
    return rgn;
}

void DDSurface::SetBboxFromSurfaceDimensions(
    const Real res,
    const bool center)
{
    Assert( center == true );
    RectToBbox(Width(), Height(), _bbox, Resolution());
}

// DX3 ddraw's SetColorKey contains an uninitialized stack var which
// causes the surface to be randomly trashed if you try to disable
// colorkeying using SetColorKey(..,NULL)  (manbug 7462)
// Soln is to pre-init some stack space to 0, skip ddrawex's SetColorKey
// and call ddraw's SetColorKey directly to avoid any extra fns ddrawex might call
// which would mess up our freshly-zeroed stack.   (see qbug 32172)

void ZeroJunkStackSpace() {
    DWORD junk[32];

    ZeroMemory(junk,sizeof(junk));
}

void DDSurface::UnSetColorKey()
{
    HRESULT hr;

    _colorKeyIsValid = FALSE;

   if(sysInfo.VersionDDraw() <= 3) {
       IDirectDrawSurface *pDDS = this->IDDSurface();
       ZeroJunkStackSpace();
       hr = pDDS->SetColorKey(DDCKEY_SRCBLT, NULL);
   } else hr=_ddsurf->SetColorKey(DDCKEY_SRCBLT, NULL);

    if (FAILED(hr)) {
        Assert(!"UnSetting color key on ddsurf failed");
    }
}

void DDSurface::SetColorKey(DWORD key)
{
    Assert( _capsReady );

    // FIRST: take out alpha if it exists!  This is a color key.
    // color keys' alpha is always 0
    key = key & ~GetPixelFormat().dwRGBAlphaBitMask;
    
    DWORD oldCK = _colorKey;
    bool oldValid = _colorKeyIsValid;

    _colorKey = key;
    _colorKeyIsValid = TRUE;
        
    // Set on the ddraw surface itself, but only if we didn't last
    // set it to the same thing.

    if ((!oldValid || oldCK != _colorKey) &&
        _surfaceType == ddrawSurface && _ddsurf.p) {
            
        DDCOLORKEY ckey;

        ckey.dwColorSpaceLowValue = _colorKey;
        ckey.dwColorSpaceHighValue = _colorKey;

        HRESULT hr;

        THR( hr = _ddsurf->SetColorKey(DDCKEY_SRCBLT, &ckey) );
    }
}

HRESULT CreateFromDDSurface(
    IDXSurfaceFactory *sf,
    DDSurface *dds,
    const GUID *pFormatID,
    IDXSurface **outDXSurf )
{
    return sf->CreateFromDDSurface(
        dds->IDDSurface_IUnk(),
        pFormatID,
        0,
        NULL,
        IID_IDXSurface,
        (void **)outDXSurf);
}    

HRESULT DDSurface::MirrorUpDown(void)
{
    // take any clippers off of the surface
    LPDIRECTDRAWCLIPPER pClipper = NULL;
    if (IDDSurface()->GetClipper(&pClipper) == S_OK) {
        IDDSurface()->SetClipper(NULL);
    }

    // mirror the surface upside-down
    DDBLTFX bltfx;
    ZeroMemory(&bltfx, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(bltfx);
    bltfx.dwDDFX = DDBLTFX_MIRRORUPDOWN;
    HRESULT hr = Blt(NULL,this,NULL,DDBLT_WAIT | DDBLT_DDFX,&bltfx);
    Assert(SUCCEEDED(hr));

    // put clipper back, if we took it off
    if (pClipper) {
        IDDSurface()->SetClipper(pClipper);
        pClipper->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\geometry.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Geometric Utility Functions

*******************************************************************************/

#include "headers.h"

#include "privinc/vec3i.h"
#include "privinc/d3dutil.h"
#include "privinc/xformi.h"



/*****************************************************************************
This function, given three triangle vertices and a point P guaranteed to be
inside the triangle, returns the barycentric coordinates of that point with
respect to the vertices.
*****************************************************************************/

void GetContainedBarycentricCoords (
    Point3Value vertices[3],     // Triangle Vertices Containing P
    Point3Value P,               // Point P Inside Triangle
    Real   barycoords[3])   // Output Barycentric Coordinates
{
    //     V2 ---------------------- V1     S = V1 - V0
    //      \ ~-_              _.-~  /      T = V2 - V0
    //      _\   -_        _.-~     /_      U = P  - V0
    //      T \    -_  _.-~        / S
    //         \     ~P           /
    //          \     ^ _        /
    //           \    | U       /
    //            \    |       /
    //             \   |      /
    //              \  |     /
    //               \  |   /
    //                \ |  /
    //                 \| /
    //                  \/
    //                  V0

    Vector3Value S (vertices[1].x - vertices[0].x,      // S = V1 - V0
                    vertices[1].y - vertices[0].y,
                    vertices[1].z - vertices[0].z);

    Vector3Value T (vertices[2].x - vertices[0].x,      // T = V2 - V0
                    vertices[2].y - vertices[0].y,
                    vertices[2].z - vertices[0].z);

    // Compute the normal vector of the triangle.  The largest component of the
    // normal vector indicates most dominant normal axis.  Dropping this
    // coordinate gives us the projection to the most parallel base plane (XY,
    // YZ, or ZX), which reduces this from a 3D problem to a 2D problem.  Note
    // that the resulting barycentric coordinates will still be the same, and
    // because we are dropping the dominant normal coordinate, we won't get a
    // degenerate 2D projection unless the starting triangle was also
    // degenerate.

    Vector3Value N;
    Cross (N, S, T);
    N.x = fabs (N.x);
    N.y = fabs (N.y);
    N.z = fabs (N.z);

    int dominant_axis;    // 0:X, 1:Y, 2:Z

    if (N.x < N.y)
        dominant_axis = (N.y < N.z) ? 2 : 1;
    else
        dominant_axis = (N.x < N.z) ? 2 : 0;

    Vector2Value U;

    // Set vector U to be the 2D vector from V0 to P.  Alter 3D vectors S and
    // T to be the corresponding 2D projections, with components X and Y
    // containing the 2D coordinates.

    if (dominant_axis == 0)
    {   U.Set (P.z - vertices[0].z, P.y - vertices[0].y);
        S.x = S.z;
        T.x = T.z;
    }
    else if (dominant_axis == 1)
    {   U.Set (P.x - vertices[0].x, P.z - vertices[0].z);
        S.y = S.z;
        T.y = T.z;
    }
    else  // (dominant_axis == 2)
    {   U.Set (P.x - vertices[0].x, P.y - vertices[0].y);
    }

    // Solve for the barycentric coordinates by using the ratio of
    // subtriangles.  Referring to the above diagram, the barycentric
    // coordinate corresponding to V0 is the ratio of the area of triangle
    // <P,V1,V2> over the area of the whole triangle <V0,V1,V2>.  The area of a
    // triangle is half the magnitude of the cross-product of two of its side
    // vectors.  The barycentric coordinate for V0 is derived from the
    // knowledge that P lies inside the triangle, so we can exploit the fact
    // that for all such points, the sum of the barycentric coordinates is one.

    Real triArea  =  (S.x * T.y) - (S.y * T.x);
    barycoords[1] = ((U.x * T.y) - (U.y * T.x)) / triArea;
    barycoords[2] = ((S.x * U.y) - (S.y * U.x)) / triArea;
    barycoords[0] = 1 - barycoords[1] - barycoords[2];

    // Assert that the barycentric coordinates are within range for a point
    // inside the triangle (all bc coords in [0,1]).

    //Assert ((-0.01 < barycoords[0]) && (barycoords[0] < 1.01)
    //     && (-0.01 < barycoords[1]) && (barycoords[1] < 1.01));
}




/*****************************************************************************
This routine starts with a facet defined by a triangle fan about the first
vertex, and a point P on the face.  It determines which triangle in the face
contains the point P, and returns the three vertex positions and vertex
surface coordinates in the triPos[] and triUV[] arguments, respectively.  It
also returns the triangle number (starting with 1) of the hit triangle.  Thus,
the triangle vertices are V0, Vi, Vi+1
*****************************************************************************/

int GetFacetTriangle (
    Point3Value   P,           // Point In Facet
    unsigned int  N,           // Number of Facet Vertices
    D3DRMVERTEX  *fVerts,      // Facet Vertices
    Point3Value   triPos[3],
    Point2Value  *triUV)    // Containing-Triangle Surface Coordinates
{
    unsigned int i = 2;            // Current Triangle Last Vertex

    // V0 is the pivot vertex of the trianle fan.

    Point3Value V0
        (fVerts[0].position.x, fVerts[0].position.y, fVerts[0].position.z);

    // Test each triangle unless there's only one triangle in the fan,
    // or unless the given point is the same as the pivot vertex.
    
    if ((N > 3) && ((P.x != V0.x) || (P.y != V0.y) || (P.z != V0.z)))
    {
        // V is the unit vector from the pivot vertex to the point P.

        Vector3Value V (P.x - V0.x, P.y - V0.y, P.z - V0.z);

        V.Normalize ();

        Vector3Value A                     // Vector A is the first side of
        (   fVerts[1].position.x - V0.x,   // the triangle we're currently
            fVerts[1].position.y - V0.y,   // testing to see if it contains P.
            fVerts[1].position.z - V0.z
        );

        A.Normalize();

        // Test each triangle in the fan to find one that contains the point P.

        for (i=2;  i < N;  ++i)
        {
            Vector3Value B                    // Vector B is the second side of
            (   fVerts[i].position.x - V0.x,  // the triangle we're currently
                fVerts[i].position.y - V0.y,  // testing for containment of P.
                fVerts[i].position.z - V0.z
            );

            B.Normalize();

            // @@@SRH
            // The "volatile" keyword below is a workaround for a VC 4.x
            // compiler bug.  When we're on VC 5.0, remove this and verify for
            // both debug and release builds.

                     Real cosThetaAB = Dot (A, B);
                     Real cosThetaAV = Dot (A, V);
            volatile Real cosThetaVB = Dot (V, B);

            //   V0 +-------------> A   If the cosine of theta1 is greater
            //      \~~--..__           than the cosine of theta2, then
            //       \       ~~> V      the angle V(i-1),V0,P is more
            //        \                 acute than the angle V(i-1),V0,Vi,
            //         \                so P must lie within the sector of
            //          B               this triangle.

            if ((cosThetaAV >= cosThetaAB) && (cosThetaVB >= cosThetaAB))
                break;

            A = B;   // The current triangle second side now becomes the first
                     // side of the next triangle.
        }
    }

    // Ensure that the intersect point lies inside some triangle in the fan.
    // Note that the following should really be an assert, but Dx2 on NT has
    // broken picking.  So if this condition is true, then things have gone
    // very wrong -- just return the pivot vertex.

    if (i >= N)
    {
        triPos[0].Set (V0.x, V0.y, V0.z);

        triPos[1].Set
            (fVerts[1].position.x, fVerts[1].position.y, fVerts[1].position.z);

        triPos[2].Set
            (fVerts[2].position.x, fVerts[2].position.y, fVerts[2].position.z);

        if (triUV)
        {   triUV[0].Set (fVerts[0].tu, fVerts[0].tv);
            triUV[1].Set (fVerts[1].tu, fVerts[1].tv);
            triUV[2].Set (fVerts[2].tu, fVerts[2].tv);
        }

        return 1;
    }

    // Fill in the vertex positions of the containing triangle.

    triPos[0].Set
      (V0.x, V0.y, V0.z);

    triPos[1].Set
      (fVerts[i-1].position.x, fVerts[i-1].position.y, fVerts[i-1].position.z);

    triPos[2].Set
      (fVerts[i].position.x,   fVerts[i].position.y,   fVerts[i].position.z);

    
    if(triUV) {
        // Fill in the vertex surface coordinates of the containing triangle.
        
        triUV[0].Set (fVerts[ 0 ].tu, fVerts[ 0 ].tv);
        triUV[1].Set (fVerts[i-1].tu, fVerts[i-1].tv);
        triUV[2].Set (fVerts[ i ].tu, fVerts[ i ].tv);
    }

    return i-1;  //  triangle index
}


void GetTriFanBaryCoords(
    Point3Value   P,           // Point In Facet
    unsigned int  N,           // Number of Facet Vertices
    D3DRMVERTEX  *fVerts,      // Facet Vertices
    Real          barycoords[3],
    int          *index)
{
    Point3Value triPos[3];
    *index = GetFacetTriangle(P, N, fVerts, triPos, NULL);
    GetContainedBarycentricCoords(triPos, P, barycoords);
}



/*****************************************************************************
This routine gets the texture-map intersection point given the geometry winner
data structure.
*****************************************************************************/

Point2Value *GetTexmapPoint (HitInfo &hit)
{
    unsigned int vCount;      // Vertex Count
    unsigned int fCount;      // Face Count
    unsigned int vPerFace;    // Vertices Per Face
    DWORD        fDataSize;   // Size of Face Data Buffer

    // First Query to see how large the face data array will be.

    TD3D (hit.mesh->GetGroup
        (hit.group, &vCount, &fCount, &vPerFace, &fDataSize, 0));

    // Fill in the face data array.

    unsigned int *fData = NEW unsigned int [fDataSize];

    TD3D (hit.mesh->GetGroup (hit.group, 0,0,0, &fDataSize, fData));

    // Seek to the beginning of the hit face data.  If the number of vertices
    // per face is zero, then the faces have a varying number of vertices, and
    // each face's vertex list is preceded by the vertex count.  If the number
    // of vertices per face is non-zero, then all faces have that many vertices.

    int fstart = 0;
    int faceNumVerts = 0;

    if (vPerFace != 0)
    {   fstart = vPerFace * hit.face;
        faceNumVerts = vPerFace;
    }
    else
    {   unsigned int faceNum = 0;
        while (faceNum < hit.face)
        {   fstart += fData[fstart] + 1;
            ++ faceNum;
        }
        faceNumVerts = fData[fstart++];
    }

    Assert ((3 <= faceNumVerts) && (faceNumVerts <= (int(fDataSize)-fstart)));

    D3DRMVERTEX *fVerts = NEW D3DRMVERTEX [faceNumVerts];

    int i;
    for (i=0;  i < faceNumVerts;  ++i)
        TD3D (hit.mesh->GetVertices (hit.group, fData[fstart+i], 1, fVerts+i));

    delete [] fData;

    // Convert the intersection point from world coordinates to the primitive
    // model coordinates (where the native vertex information lies).

    Point3Value intersect (hit.wcoord.x, hit.wcoord.y, hit.wcoord.z);

    Transform3 *inv = hit.lcToWc->Inverse();

    if (!inv) return origin2;
    
    intersect.Transform (inv);

    Point3Value triVerts [3];
    Point2Value triUVs   [3];

    GetFacetTriangle (intersect, faceNumVerts, fVerts, triVerts, triUVs);

    delete [] fVerts;

    Real bc[3];    // Barycentric Coordinates of Intersection Point

    GetContainedBarycentricCoords (triVerts, intersect, bc);

    return NEW Point2Value
    (   (bc[0] * triUVs[0].x) + (bc[1] * triUVs[1].x) + (bc[2] * triUVs[2].x),
        (bc[0] * triUVs[0].y) + (bc[1] * triUVs[1].y) + (bc[2] * triUVs[2].y)
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\debug.cpp ===
////////////////////////////////////////////////////////////////
//
// File: debug.cpp
//
// Support for internal debugging
//
// Microsoft Corporation Copyright (c) 1995-96
//
////////////////////////////////////////////////////////////////

    // Define & register the trace tags.
#include "headers.h"

#if _DEBUG

#include "appelles/common.h"
#include <stdio.h>
#include <windows.h>

#define DEFINE_TAGS 1
#include "privinc/debug.h"
#include "backend/bvr.h"

typedef void (*PrintFunc)(char*);

static PrintFunc fp = NULL;

extern HINSTANCE hInst;

extern void
SetDebugPrintFunc(PrintFunc f)
{
    fp = f;
}

// Use this function as you would use printf(char *format, ...).
// This results in the information being printed to the
// debugger.
void
DebugPrint(char *format, ...)
{
    char tmp[1024];
    va_list marker;
    va_start(marker, format);
    wvsprintf(tmp, format, marker);

    // Win32 call to output the string to the "debugger" window.
    if (fp)
        (*fp)(tmp);
    else
        OutputDebugStr(tmp);
}

#if _USE_PRINT
/*
 * Package debug output as C++ output stream.
 * To do this we need to define a unbuffered stream buffer
 * that dumps its characters to the debug console.
 *
 * cdebug is the externed global for the resulting ostream
 */
class DebugStreambuf : public streambuf
{
 public:
    DebugStreambuf();
    virtual int overflow(int);
    virtual int underflow();
};

DebugStreambuf::DebugStreambuf()
{
    unbuffered(1);
}

int
DebugStreambuf::overflow(int c)
{
    char buf[2] = {(CHAR)c, 0};

    if (fp)
        (*fp)(buf);
    else
        OutputDebugStr(buf);

    return 0;
}

int
DebugStreambuf::underflow()
{
    return EOF;
}

static DebugStreambuf debugstreambuf;
extern ostream cdebug(&debugstreambuf);

const int MAXSIZE = 32000;
const int LINESIZE = 80;
static char printObjBuf[MAXSIZE];

extern "C" void DumpDebugBuffer(int n)
{
    // Debug output seems to have a line size limit, so chop them
    // off into smaller lines.
    int i = n, j = 0;
    char linebuf[LINESIZE + 2];
    linebuf[LINESIZE] = '\n';
    linebuf[LINESIZE+1] = 0;

    while (i > 0) {
        if (i > LINESIZE) 
            strncpy(linebuf, &printObjBuf[j], LINESIZE);
        else {
            strncpy(linebuf, &printObjBuf[j], i);
            linebuf[i] = '\n';
            linebuf[i+1] = 0;
        }
        i -= LINESIZE;
        j += LINESIZE;
        OutputDebugStr(linebuf);
    } 
}

extern "C" void PrintObj(GCBase* b)
{
    TCHAR szResultLine[MAX_PATH];

    TCHAR szTmpPath[MAX_PATH];
    TCHAR szTmpInFile[MAX_PATH], szTmpOutFile[MAX_PATH];
    TCHAR szCmd[MAX_PATH];

    TCHAR szModulePath[MAX_PATH];

    ofstream outFile;

    ostrstream ost(printObjBuf, MAXSIZE);
    b->Print(ost);
    ost << endl << ends;

    int n = strlen(ost.str());
    if (n < LINESIZE)
        OutputDebugStr(ost.str());
    else {
        DumpDebugBuffer(n);
    }

#ifdef UNTILWORKING
    if ( GetTempPath( MAX_PATH, szTmpPath ) == 0 )
    {
        TraceTag(( tagError, _T("Could not create temporary file for pretty printing purposes")));
        return;
    }

    strcpy( szTmpInFile, szTmpPath );
    strcat( szTmpInFile, _T("EXPRESSION") );

    strcpy( szTmpOutFile, szTmpPath );
    strcat( szTmpOutFile, _T("EXPRESSION.OUT") );

    // Send results to temporary file
    outFile.open( szTmpInFile );
    outFile << ost.str();
    outFile.close();

    GetModuleFileName( hInst, szModulePath, sizeof(szModulePath) );

    // Put a terminating NULL at the first blackslash
    TCHAR *psz = szModulePath+strlen(szModulePath)-1;
    while ( psz != szModulePath )
    {
        if ( *psz == '\\' )
        {
            *psz = 0;
            break;
        }
        --psz;
    }

    strcpy( szCmd, _T("PERL.EXE "));
    strcat( szCmd, szModulePath );
    strcat( szCmd, _T("\\..\\..\\tools\\x86\\utils\\ppfactor.pl "));
    strcat( szCmd, szTmpInFile );
    strcat( szCmd, _T(" > ") );
    strcat( szCmd, szTmpOutFile );

    // For now comment out since it brings up dialogs all over the place
    //    in Win98
//    system( szCmd );

    FILE *fp;
    
    if ( (fp = fopen( szTmpOutFile, "r" )) == NULL )
    {
        TraceTag(( tagError, _T("Could not open pretty printing temporary result file")));
        return;
    }

    while ( !feof( fp ) )
    {
        _fgetts( szResultLine, sizeof(szResultLine), fp );
        OutputDebugStr( szResultLine );
    }

    fclose( fp );
#endif
}
#endif


// Strictly for debugging... don't count on the results
extern "C" int DumpRefCount(IUnknown *obj)
{
    int refCountOnAdd = obj->AddRef();
    int refCountOnRelease = obj->Release();

    return refCountOnRelease;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "privinc/server.h"


#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\except.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   Define the exception hierarchy to use for C++ exception
   handling in Appelles.

--*/

#include "headers.h"
#include "appelles/common.h"
#include "privinc/except.h"
#include "privinc/server.h"
#include "privinc/resource.h"
#include "privinc/debug.h"
#include <stdarg.h>


// Simply proxy to emit a trace tag and allow for a place to set a
// breakpoint. 
inline void RaiseExceptionProxy(DWORD code,
                                DWORD flags,
                                DWORD numArgs,
                                DWORD *lpArgs)
{
#if DEVELOPER_DEBUG
    if(DAGetLastError() != S_OK) {
#if _DEBUG
        TraceTag((tagError, 
                  "DA Error: %hr, %ls",
                  DAGetLastError(),
                  DAGetLastErrorString()));
#else
        char buf[1024];
        wsprintf(buf, 
                 "DA Error: %lx, %ls\n", 
                 DAGetLastError(),
                 DAGetLastErrorString());
        OutputDebugString(buf);
#endif
    }
#endif
    RaiseException(code, flags, numArgs, (DWORD_PTR*)lpArgs);
}
    


/////////////////////////////////////////////////////////////////////////////
// Exception helper: called from withing the except clause
// for example:  __except( _HandleAnyDaException(...) )
// IT'S IMPORTANT THAT THIS FUNCTION BE STACK NEUTRAL SO IT ALWAYS
// SUCCEEDS WITHOUT RAISING AN EXCEPTION!!  <ESPECIALLY A STACK FAULT>
/////////////////////////////////////////////////////////////////////////////
DWORD _HandleAnyDaException( DWORD code )
{
  // Usually out of mem means somethings NULL, however 
  // creating a critical section can raise the STATUS_NO_MEMORY exception
  // which we handle here and make it look like an out of mem exception
  if( code == STATUS_NO_MEMORY ) code = EXCEPTION_DANIM_OUTOFMEMORY;

    if( ( code >= _EXC_CODES_BASE) &&
        ( code <= _EXC_CODES_END) ) {
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}


// forward decl: Internal use in this file only.
void vDASetLastError(HRESULT reason, int resid, va_list args);


/////////////////////////////////////////////////////////////////////////////
////// RaiseException_XXXXX  routines
/////////////////////////////////////////////////////////////////////////////

// Internal
void _RaiseException_InternalError(DEBUGARG(char *m))
{
    DASetLastError(E_UNEXPECTED, IDS_ERR_INTERNAL_ERROR DEBUGARG1(m));
    RaiseExceptionProxy(EXCEPTION_DANIM_INTERNAL, EXCEPTION_NONCONTINUABLE ,0,0);
}

void _RaiseException_InternalErrorCode(HRESULT code DEBUGARG1(char *m))
{
    DASetLastError(code, IDS_ERR_INTERNAL_ERROR DEBUGARG1(m));
    RaiseExceptionProxy(EXCEPTION_DANIM_INTERNAL, EXCEPTION_NONCONTINUABLE ,0,0);
}

// User
void RaiseException_UserError()
{
    // TODO: invalid arg ??  not sure this is the right error
    // Assume it is already set
//    DASetLastError(E_FAIL, IDS_ERR_INVALIDARG); 
    RaiseExceptionProxy(EXCEPTION_DANIM_USER, EXCEPTION_NONCONTINUABLE ,0,0);
}
void RaiseException_UserError(HRESULT result, int resid, ...)
{
    va_list args;
    va_start(args, resid) ;
    vDASetLastError(result, resid, args);
    RaiseExceptionProxy(EXCEPTION_DANIM_USER, EXCEPTION_NONCONTINUABLE ,0,0);
}

// Resource
void RaiseException_ResourceError()
{
    DASetLastError(E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    RaiseExceptionProxy(EXCEPTION_DANIM_RESOURCE, EXCEPTION_NONCONTINUABLE ,0,0);
}
void RaiseException_ResourceError(char *m)
{
    DASetLastError(E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY, m);
    RaiseExceptionProxy(EXCEPTION_DANIM_RESOURCE, EXCEPTION_NONCONTINUABLE ,0,0);
}
void RaiseException_ResourceError(int resid, ...)
{ 
    va_list args;
    va_start(args, resid) ;
    vDASetLastError(E_OUTOFMEMORY, resid, args);
    RaiseExceptionProxy(EXCEPTION_DANIM_RESOURCE, EXCEPTION_NONCONTINUABLE ,0,0);
}

// Surface Cache
void RaiseException_SurfaceCacheError(char *m)
{
    DASetLastError(S_OK, IDS_ERR_OUT_OF_MEMORY, m);
    RaiseExceptionProxy(EXCEPTION_DANIM_RESOURCE, EXCEPTION_NONCONTINUABLE ,0,0);
}

// Hardware
void RaiseException_StackFault()
{
    DASetLastError(E_FAIL, IDS_ERR_STACK_FAULT);
    RaiseExceptionProxy(EXCEPTION_DANIM_STACK_FAULT, EXCEPTION_NONCONTINUABLE ,0,0);
}
void RaiseException_DivideByZero()
{
    DASetLastError(E_FAIL, IDS_ERR_DIVIDE_BY_ZERO);
    RaiseExceptionProxy(EXCEPTION_DANIM_DIVIDE_BY_ZERO, EXCEPTION_NONCONTINUABLE ,0,0);
}

// Memory
void _RaiseException_OutOfMemory(DEBUGARG2(char *msg, int size))
{
    #if _DEBUG
    DASetLastError(E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY_DBG, size, msg);
    #else
    DASetLastError(E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    #endif
    RaiseExceptionProxy(EXCEPTION_DANIM_OUTOFMEMORY, EXCEPTION_NONCONTINUABLE ,0,0);
}

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

/////////////////// Handle All This Stuff ////////////////////////

// Throws an out of memory exception if the ptr is NULL, else returns
// ptr. 
void *
ThrowIfFailed(void *ptr)
{
    if (ptr == NULL) {
#if _MEMORY_TRACKING
        OutputDebugString("\nDirectAnimation: Out Of Memory\n");
        F3DebugBreak();
#endif
        RaiseException_OutOfMemory("In THROWING_ALLOCATOR", 0);
    }

    return ptr;
}

#if _DEBUGMEM
void *
AxAThrowingAllocatorClass::operator new(size_t s,
                                        int block,
                                        char *filename,
                                        int line)
{
    void *result = (void *)new(block, filename, line) char[s];
    TraceTag((tagGCDebug,
              "AxAThrowingAllocatorClass::operator new %s:Line(%d) Addr: %lx size= %d.\n",
              filename, line, result, s));
    return ThrowIfFailed(result);
}
#endif

void *
AxAThrowingAllocatorClass::operator new(size_t s)
{
    return (void *)THROWING_ARRAY_ALLOCATOR(char, s);
}

void *
AxAThrowingAllocatorClass::operator new(size_t s, void *ptr)
{
    return ptr;
}

//////////////////////////////////////////////////////////////////

// Use 0xffffffff since it is the error return value as well
static DWORD errorTlsIndex = 0xFFFFFFFF;

class DAErrorInfo
{
  public:
    DAErrorInfo() : _reason(S_OK), _msg(NULL) {}
    // No destructor since we never free the class

    void Free() { delete _msg; _msg = NULL; }
    void Clear() { Free(); _reason = S_OK; }
    void Set(HRESULT reason, LPCWSTR msg);
    
    HRESULT GetReason() { return _reason; }
    LPCWSTR GetMsg() { return _msg; }
  protected:
    HRESULT _reason;
    LPWSTR _msg;
};

void
DAErrorInfo::Set(HRESULT reason, LPCWSTR msg)
{
    // Set the reason
    
    _reason = reason;

    // Free any associated memory
    
    Free();
    
    // Try to store the new message - if it fails indicate out of
    // memory if the reason was S_OK
    
    if (msg) {
        _msg = CopyString(msg);
        if (!_msg) {
            if (_reason == S_OK)
                _reason = E_OUTOFMEMORY;
            
            Assert (!"Out of memory in SetError");
        }
    }
}
    

DAErrorInfo *
TLSGetErrorValue()
{
    // Grab what is stored in TLS at this index.
    DAErrorInfo * result = (DAErrorInfo *) TlsGetValue(errorTlsIndex);

    // If null, then we haven't created the memory for this thread yet
    // or we failed sometime earlier
    
    if (result == NULL) {
        Assert((GetLastError() == NO_ERROR) && "Error in TlsGetValue()");
        result = NEW DAErrorInfo;
        Assert (result);
        TlsSetValue(errorTlsIndex, result);
    }

    return result;
}

void
TLSSetError(HRESULT reason, LPCWSTR msg)
{
    // Get the error info object for this thread
    DAErrorInfo* ei = TLSGetErrorValue();

    // If it fails then we had a memory failure and just skip the rest
    
    if (ei)
        ei->Set(reason, msg);
}

void
DASetLastError(HRESULT reason, int resid, ...)
{
    va_list args;
    va_start(args, resid) ;
        
    vDASetLastError (reason, resid, args) ;
}

void
vDASetLastError(HRESULT reason, int resid, va_list args)
{
#if 0
    LPVOID  lpv;
    HGLOBAL hgbl;
    HRSRC   hrsrc;

    hrsrc = FindResource(hInst,
                         MAKEINTRESOURCE(resid),
                         RT_STRING);
    Assert (hrsrc) ;

    DWORD d = GetLastError () ;
    
    if (!hrsrc) return ;
    
    hgbl = LoadResource(hInst, hrsrc);
    Assert (hgbl) ;

    lpv = LockResource(hgbl);
    Assert (lpv) ;

    vSetError((char *)lpv, args) ;
    
#ifndef _MAC
    //  Win95 is said to need this
    FreeResource(hgbl);
#endif
#else
    if (resid) {
        char buf[1024];
        LoadString (hInst, resid, buf, sizeof(buf));
        
        char * hTmpMem = NULL ;
        
        if (!FormatMessage (FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            (LPVOID)buf,
                            0,
                            0,
                            (char *)&hTmpMem,
                            0,
                            &args)) {
            
            Assert(!"Failed to format error message.");
            TLSSetError(reason, NULL);
        } else {
            USES_CONVERSION;
            TLSSetError(reason, A2W(hTmpMem));
            LocalFree ((HLOCAL) hTmpMem);
        }
    } else {
        TLSSetError(reason, NULL);
    }
#endif
}

void
DASetLastError(HRESULT reason, LPCWSTR msg)
{ TLSSetError(reason, msg); }

HRESULT
DAGetLastError()
{
    // Get the error info object for this thread
    DAErrorInfo* ei = TLSGetErrorValue();

    // If errorinfo is null then there was a memory failure
    
    if (ei)
        return ei->GetReason();
    else
        return E_OUTOFMEMORY;
}

LPCWSTR
DAGetLastErrorString()
{
    // Get the error info object for this thread
    DAErrorInfo* ei = TLSGetErrorValue();

    // If errorinfo is null then there was a memory failure
    
    if (ei)
        return ei->GetMsg();
    else
        return NULL;
}

void
DAClearLastError()
{
    // Get the error info object for this thread
    DAErrorInfo* ei = TLSGetErrorValue();

    // If it fails then we had a memory failure and just skip the rest
    
    if (ei)
        ei->Clear();
}

//////////////////////////////////////////////////////////////////

void
InitializeModule_Except()
{
    errorTlsIndex = TlsAlloc();
    // If result is 0xFFFFFFFF, allocation failed.
    Assert(errorTlsIndex != 0xFFFFFFFF);
}

void
DeinitializeModule_Except(bool bShutdown)
{
    if (errorTlsIndex != 0xFFFFFFFF)
        TlsFree(errorTlsIndex);
}

void
DeinitializeThread_Except()
{
    // Grab what is stored in TLS at this index.
    DAErrorInfo * result = (DAErrorInfo *) TlsGetValue(errorTlsIndex);

    if (result)
    {
        delete result;
        TlsSetValue(errorTlsIndex, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\helpds.cpp ===
#include "headers.h"
#include "appelles/common.h"
#include <wtypes.h>
#include <dsound.h>
#include <stdio.h>
#include <math.h>
#include "privinc/helpds.h"
#include "privinc/util.h"
#include "privinc/debug.h"
#include "privinc/registry.h"
#include "privinc/miscpref.h"
#include "privinc/pcm.h"
#include "privinc/hresinfo.h"

// definition of DSbuffer static members
int DSbuffer::_minDSfreq =    100; // these values come from dsound docs
int DSbuffer::_maxDSfreq = 100000;
int DSbuffer::_minDSpan  = -10000;
int DSbuffer::_maxDSpan  =  10000;
int DSbuffer::_minDSgain = -10000;
int DSbuffer::_maxDSgain =      0;

extern miscPrefType miscPrefs; // the structure setup in miscpref.cpp

void
DSbuffer::setPtr(int bytePosition)
{
    TraceTag((tagSoundDSound, "::setPtr %d", bytePosition));
    TDSOUND(_dsBuffer->SetCurrentPosition(bytePosition)); 
}


void
DSstaticBuffer::setPtr(int bytePosition)
{
    TraceTag((tagSoundDSound, "DSstaticBuffer(%#lx)::setPtr %d",
              _dsBuffer,
              bytePosition));
    
    // There appears to be a bug in dsound where if we do not stop the
    // sound before moving it sometimes will fail to play the sound.
    // We are not exactly sure about the failure but this seems to
    // make everything happy.
    
    TDSOUND(THR(_dsBuffer->Stop()));
    TDSOUND(THR(_dsBuffer->SetCurrentPosition(bytePosition))); 

    // one shot sounds will stop after the sound is played to the end
    if(playing && !_paused) {
        TraceTag((tagSoundDSound,
                  "DSstaticBuffer(%#lx)::setPtr PLAY",
                  _dsBuffer));

        TDSOUND(THR(_dsBuffer->Play(NULL, NULL, (_loopMode)?DSBPLAY_LOOPING:0)));
    }
    // XXX dsound really needs to give us a play at location...
}

/* dsound helper routines which should be in the dsoundbuffer base class    */
/* XXX: eventualy this stuff should be inherited into the other ds classes! */

// clone the buffer
DSstaticBuffer::DSstaticBuffer(DirectSoundProxy *dsProxy, 
                               IDirectSoundBuffer *donorBuffer)
: _dsProxy(NULL)
{
    TDSOUND(dsProxy->DuplicateSoundBuffer(donorBuffer, &_dsBuffer));

#if _DEBUG
    if(IsTagEnabled(tagSoundStats)) {
        printBufferCapabilities();        // What buffer did we get?
        printDScapabilities(dsProxy);     // What hw look like?
    }
#endif /* _DEBUG */

    duplicate = TRUE;           // gluh, gluh, we're a clone
}


// create new buffer, and copy samples to it
DSstaticBuffer::DSstaticBuffer(DirectSoundProxy *dsProxy, 
                               PCM *newPCM, unsigned char *samples)
: _dsProxy(NULL)
{
    Assert(newPCM->GetNumberBytes());
    pcm.SetPCMformat(newPCM); // setup our pcm format 

    CreateDirectSoundBuffer(dsProxy, false); // create secondary buffer

    // copy the snd's buffer to the dsBuffer (+ orig buffer freed)
    CopyToDSbuffer(samples, false, pcm.GetNumberBytes());

    _dsProxy = dsProxy;
}


/* 
Determine the best we can the 'best possible' primary buffer settings

XXX: Much of this code can not be realy tested w/o weird audio boards...
     S'pose we could simulate conditions...
*/
extern "C"
void
DSbufferCapabilities(DirectSoundProxy *dsProxy, int *channels, 
int *sampleBytes,  int *sampleRate)
{
    DSCAPS hwCapabilities;
    hwCapabilities.dwSize = sizeof(DSCAPS); // XXX why should this be needed?
    int frameRate = miscPrefs._frameRate;   // determine the desired frame rate

    TDSOUND(dsProxy->GetCaps((LPDSCAPS)&hwCapabilities));

    // try to get as close to cannonical rate (16bit 22050Hz Stereo unless
    // over-ridden using registry) as we can

    // determine if the HW supports stereo sound
    if(hwCapabilities.dwFlags & DSCAPS_PRIMARYSTEREO)
        *channels = 2; // stereo is supported
    else if(hwCapabilities.dwFlags & DSCAPS_PRIMARYMONO)
        *channels = 1; // only mono is supported
    else
        RaiseException_InternalError("No Stereo or Mono Audio support!\n"); 

    // determine if the HW supports 16 bit samples
    if(hwCapabilities.dwFlags & DSCAPS_PRIMARY16BIT)
        *sampleBytes = 2; // 16 bit samples are supported
    else if(hwCapabilities.dwFlags & DSCAPS_PRIMARY8BIT)
        *sampleBytes = 1; // 8 bit samples are supported
    else
        RaiseException_InternalError("No 16 or 8 bit sample Audio support!\n"); 


    // detemine if the desired frame rate is supported 
    if( (hwCapabilities.dwMinSecondarySampleRate <= frameRate) &&
        (hwCapabilities.dwMaxSecondarySampleRate >= frameRate))
        *sampleRate = frameRate; // samplerate supported
    else { // use the max supported rate!
        *sampleRate = hwCapabilities.dwMaxSecondarySampleRate;

        // XXX hack code to work around dsound bug on SB16
        if(hwCapabilities.dwMaxSecondarySampleRate==0)
            *sampleRate = frameRate;  // try forceing desired rate

        // lets detect the err
#if _DEBUG
       if(hwCapabilities.dwMaxSecondarySampleRate==0) {
           TraceTag((tagSoundErrors, "DSOUND BUG: dwMAXSecondarySampleRate==0"));
       }
#endif
    }
}


DSprimaryBuffer::DSprimaryBuffer(HWND hwnd, DirectSoundProxy *dsProxy) :
 DSbuffer()
{
    int probeChannels;
    int probeSampleBytes;
    int probeSampleRate;

    // Set Co-op level to priority so we may set the primary buffer format
    // attempt to determine best HW settings
    DSbufferCapabilities(dsProxy, &probeChannels, &probeSampleBytes,
        &probeSampleRate);

#if _DEBUG
    if(IsTagEnabled(tagSoundStats)) {
        char string[100];

        sprintf(string, "Primary buffer: %dHz %dbit %s\n", probeSampleRate,
            probeSampleBytes*8, (probeChannels==1)?"MONO":"STEREO"); 
        TraceTag((tagSoundStats, string));
    }


#endif /* _DEBUG */

    pcm.SetPCMformat(probeSampleBytes, probeChannels, probeSampleRate);
    pcm.SetNumberBytes(0); // Zero for the primary buffer

    TDSOUND(dsProxy->SetCooperativeLevel(hwnd, DSSCL_PRIORITY)); 

    // create primary buffer; thereby setting the output format!
    CreateDirectSoundBuffer(dsProxy, true);  // create primary buffer

    // play the primary buffer so they will not stop DMA during idle times
    // XXX Note: we might want to be more lazy about this...
    
    TDSOUND(_dsBuffer->Play(NULL, NULL, DSBPLAY_LOOPING)); // Must loop primary
}


void DSbuffer::initialize()  
{
    int frameRate   = miscPrefs._frameRate;   // determine desired frame rate
    int sampleBytes = miscPrefs._sampleBytes; // determine desired format

    // set the format sampleBytes, MONO, frameRate
    pcm.SetPCMformat(sampleBytes, 1, frameRate);

    playing             =                FALSE;
    _paused             =                FALSE;

    _currentAttenuation =                    0;
    _currentFrequency   =   pcm.GetFrameRate();
    _currentPan         =                    0;

    // setup buffer stats
    _firstStat          =                 TRUE;  // haven't collected stats yet
    _bytesConsumed      =                    0;

    _dsBuffer           =                 NULL;

    _allocated          =                 FALSE;
    duplicate           =                 FALSE;
    _loopMode           =                    0;
    _flushing           =                    0;

    tail                =                    0;

    outputFrequency     =                    0;

    _lastHead           =                    0;
    _firstStat          =                 FALSE;
}


void DSbuffer::SetGain(double dB_attenuation)
{
    int dsAttenuation = // convert to dSound 1/100th dB integer format
        saturate(_minDSgain, _maxDSgain, dBToDSounddB(dB_attenuation)); 

    TraceTag((tagSoundDSound, "::SetGain %d", dsAttenuation));

    // dd format is less granular than the internal fp examine dd for change
    if(_currentAttenuation!=dsAttenuation) {
        TDSOUND(_dsBuffer->SetVolume(dsAttenuation));
        _currentAttenuation = dsAttenuation;  // cache the devidedependent value
    }
}


void DSbuffer::SetPan(double dB_pan, int direction)
{
    int dsPan = direction * dBToDSounddB(-1.0 * dB_pan);

    TraceTag((tagSoundDSound, "::SetPan %d", dsPan));

    // dd format is less granular than the internal fp examine dd for change
    if(_currentPan != dsPan) {
        TDSOUND(_dsBuffer->SetPan(dsPan));
        _currentPan = dsPan;
    }
}


void DSbuffer::setPitchShift(int frequency)
{
// NOTE: This is the only post-init location where _paused is modified!!

    if(_currentFrequency != frequency) {
        if(frequency == 0) {
            TraceTag((tagSoundDSound, "::setPitchShift STOP (paused)"));
            TDSOUND(_dsBuffer->Stop());
            _paused = TRUE;
        }
        else {
            int freq = saturate(_minDSfreq, _maxDSfreq, frequency);
            TDSOUND(_dsBuffer->SetFrequency(freq));

            TraceTag((tagSoundDSound, "::setPitchShift freq=%d", freq));

            if(_paused) {
                TraceTag((tagSoundDSound, "::setPitchShift PLAY (resume)"));
                TDSOUND(_dsBuffer->Play( // resume the buffer
                    NULL, NULL, (_loopMode)?DSBPLAY_LOOPING:0));
                _paused = FALSE;
            }
        }

        _currentFrequency = frequency;
    }
}


void DSbuffer::play(int loop)
{
    if(!_paused) {
        TraceTag((tagSoundDSound, "::play PLAY"));
        TDSOUND(_dsBuffer->Play(NULL, NULL, (loop)?DSBPLAY_LOOPING:0));
    } else
        TraceTag((tagSoundDSound, "::play NOP (paused)!!!"));

    _loopMode = loop;
    _flushing =    0;       // reset flushing mode
     playing  = TRUE;
}


void DSbuffer::stop()
{
    if(_dsBuffer) {
        TraceTag((tagSoundDSound, "::stop STOP"));
        TDSOUND(_dsBuffer->Stop());
    }
    
    playing = FALSE;
}


int DSbuffer::isPlaying()
{
    // XXX this shouldn't side efect _playing!
    bool deadBuffer = false;
    DWORD status;

    TDSOUND(_dsBuffer->GetStatus(&status));

    if(status & DSBSTATUS_BUFFERLOST)
        RaiseException_InternalErrorCode(status, "Status: dsound bufferlost");

    if(!(status & DSBSTATUS_PLAYING))
        deadBuffer = TRUE;  // the buffer stopped

    TraceTag((tagSoundDSound, "::isPlaying %d", !deadBuffer));

    return(!deadBuffer);
}


int DSbuffer::bytesFree()
{
    DWORD head, head2;
    int bytesFree;

    TDSOUND(_dsBuffer->GetCurrentPosition(&head, &head2));

    bytesFree= head - tail;
    bytesFree+= (bytesFree<0)?pcm.GetNumberBytes():0;

    // XXX this is a terrible hack!
    if(!playing)
        bytesFree= (pcm.GetNumberBytes()/2) & 0xFFFFFFF8;

    return(bytesFree);
}


void DSbuffer::updateStats()
{
    // this needs to be polled to keep track of buffer statistics
    // should probably be called on every streaming write!
    
    // NOTE: This code assumes that it is called often enough that the buffer
    //       could not have 'wraped' since we last called it!

    DWORD currentHead, head2;
    int bytesConsumed;

    // get head position
    TDSOUND(_dsBuffer->GetCurrentPosition(&currentHead, &head2)); 

    // mutexed since can be called/polled from synth thread and sampling loop!
    { // mutex scope
        MutexGrabber mg(_byteCountLock, TRUE); // Grab mutex

        if(!_firstStat) {  // only can compute distance if we have a previous val!
            bytesConsumed   = currentHead - _lastHead;
            bytesConsumed  += (bytesConsumed<0)?pcm.GetNumberBytes():0;
            _bytesConsumed += bytesConsumed;  // track the total
        }
        else {
            _firstStat = FALSE;
        }

        _lastHead = currentHead; // save this value for next time
        // release mutex as we go out of scope
    }
}


Real DSbuffer::getMediaTime()
{
    LONGLONG bytesConsumed;

    { // mutex scope
        MutexGrabber mg(_byteCountLock, TRUE); // Grab mutex

        updateStats(); // freshen up the values!
        bytesConsumed = _bytesConsumed;
    } // release mutex as we go out of scope

    return(pcm.BytesToSeconds(bytesConsumed));  // return the mediaTime
}


// XXX note blocking, high, low-watermarks not implemented!
void
DSbuffer::writeBytes(void *buffer, int numBytesToXfer)
{
    CopyToDSbuffer((void *)buffer, tail, numBytesToXfer);
    tail = (tail + numBytesToXfer)%pcm.GetNumberBytes();
}


void
DSbuffer::writeSilentBytes(int numBytesToFill)
{
    // unsigned 8bit pcpcm!
    FillDSbuffer(tail, numBytesToFill, (pcm.GetSampleByteWidth()==1)?0x80:0x00);
    tail = (tail + numBytesToFill)%pcm.GetNumberBytes();
}


DSbuffer::~DSbuffer()
{
    if(_dsBuffer) {
        TDSOUND(_dsBuffer->Stop());  // always make sure they are stopped!
        int status = _dsBuffer->Release();
    }
}


/**********************************************************************
Create a stopped, cleared==silent dsound streaming secondary buffer of 
the desired rate and format.
**********************************************************************/
DSstreamingBuffer::DSstreamingBuffer(DirectSoundProxy *dsProxy, PCM *newPCM)
{
    // conservatively sz buffer due to jitter
    pcm.SetPCMformat(newPCM);
    pcm.SetNumberFrames(pcm.SecondsToFrames(0.5)); 

    tail = 0;  // XXX we should really servo the initial tail!

    _currentFrequency =  pcm.GetFrameRate(); // setup initial _currentFrequency

    // create secondary streaming buffer (must call after PCM setup!)
    CreateDirectSoundBuffer(dsProxy, false);  // create secondary buffer

    // silence buffer keeping in mind unsigned 8bit pcpcm!
    // XXX move this to a method soon!
    ClearDSbuffer(pcm.GetNumberBytes(), (pcm.GetSampleByteWidth()==1)?0x80:0x0); 
}


#ifdef _DEBUG
void 
DSbuffer::printBufferCapabilities()
{
    DSBCAPS bufferCapabilities;

    bufferCapabilities.dwSize = sizeof(DSBCAPS);

    TDSOUND(_dsBuffer->GetCaps((LPDSBCAPS)&bufferCapabilities));

    // XXX explore the bufferCapabilities structure
    printf("xfer-rate= %d, cpu=%d%, size:%d bytes, location: %s\n",
        bufferCapabilities.dwUnlockTransferRate,
        bufferCapabilities.dwPlayCpuOverhead,
        bufferCapabilities.dwBufferBytes,
        (bufferCapabilities.dwFlags & DSBCAPS_LOCHARDWARE)?
            "HW Buffer":"Main memory");
}

// XXX this method should be moved to the dsound device!
void 
printDScapabilities(DirectSoundProxy *dsProxy)
{
    DSCAPS dsc;

    dsc.dwSize = sizeof(dsc);
    dsProxy->GetCaps(&dsc);

    printf("free hw memory= %dkb, free hw buffers= %d\n",
        (dsc.dwFreeHwMemBytes+512)/1024, dsc.dwFreeHwMixingAllBuffers);
}
#endif


void
DSbuffer::CreateDirectSoundBuffer(DirectSoundProxy *dsProxy, bool primary)
{
    DSBUFFERDESC        dsbdesc;

    // Set up DSBUFFERDESC structure.
    memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); // Zero it out.
    dsbdesc.dwSize = sizeof(DSBUFFERDESC);

    dsbdesc.dwFlags = (primary) ? 
        DSBCAPS_PRIMARYBUFFER :  // primary buffer (no other flags)
        (
        // get pan, vol, freq controls explicitly DSBCAPS_CTRLDEFAULT was remove
        DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY
        | DSBCAPS_STATIC        //  downloadable buffers
        | DSBCAPS_LOCSOFTWARE   //  XXX for PDC, BLOCK HW BUFFERS! :(
                                //  (buffer dup. fails weirdly on AWE32)
        | DSBCAPS_GLOBALFOCUS   //  global focus requires DSound >= 3!
        );

    dsbdesc.dwBufferBytes =  pcm.GetNumberBytes();

    dsbdesc.lpwfxFormat = NULL; // must be null for primary buffers
    int result;

    if(primary) { // open up a primary buffer so we may set the format
        WAVEFORMATEX        pcmwf;

        // try to create buffer
        TDSOUND(dsProxy->CreateSoundBuffer(&dsbdesc, &_dsBuffer, NULL));

        // Setup format structure
        // XXX really should provide this capability in PCM class!
        memset(&pcmwf, 0, sizeof(PCMWAVEFORMAT));
        pcmwf.wFormatTag     = WAVE_FORMAT_PCM;
        pcmwf.nChannels      = (WORD)pcm.GetNumberChannels();
        pcmwf.nSamplesPerSec = pcm.GetFrameRate(); //they realy mean frames!
        pcmwf.nBlockAlign    = pcm.FramesToBytes(1);
        pcmwf.nAvgBytesPerSec= pcm.SecondsToBytes(1.0);
        pcmwf.wBitsPerSample = pcm.GetSampleByteWidth() * 8;

        TDSOUND(_dsBuffer->SetFormat(&pcmwf)); // set primary buffer format
    }
    else { // secondary buffer
        PCMWAVEFORMAT pcmwf;

        Assert(dsbdesc.dwBufferBytes);

        // Set up wave format structure.
        dsbdesc.lpwfxFormat = (LPWAVEFORMATEX)&pcmwf;
        memset(&pcmwf, 0, sizeof(PCMWAVEFORMAT));
        pcmwf.wf.wFormatTag     = WAVE_FORMAT_PCM;
        pcmwf.wf.nChannels      = (WORD)pcm.GetNumberChannels();
        pcmwf.wf.nSamplesPerSec = pcm.GetFrameRate(); // they realy mean frames!
        pcmwf.wf.nBlockAlign    = pcm.FramesToBytes(1);
        pcmwf.wf.nAvgBytesPerSec= pcm.SecondsToBytes(1.0);
        pcmwf.wBitsPerSample    = pcm.GetSampleByteWidth() * 8;

        // Create buffer.
        TDSOUND(dsProxy->CreateSoundBuffer(&dsbdesc, &_dsBuffer, NULL));
        
#if _DEBUG
        if(IsTagEnabled(tagSoundStats)) {
            printBufferCapabilities(); // What buffer did we get?
            printDScapabilities(dsProxy); // What hw look like?
        }
#endif /* _DEBUG */

    }
}


void
DSbuffer::ClearDSbuffer(int numBytes, char value)
{
    LPVOID  ptr1, ptr2;
    DWORD   bytes1, bytes2;

    // Obtain write ptr (beggining of buffer, whole buffer)
    TDSOUND(_dsBuffer->Lock(0, numBytes, &ptr1, &bytes1, &ptr2, &bytes2, NULL));
    
    memset((void *)ptr1, value, bytes1);     // clear 
    if(ptr2)
        memset((void *)ptr2, value, bytes2); // clear crumb

    TDSOUND(_dsBuffer->Unlock(ptr1, bytes1, ptr2, bytes2));
}


void
DSbuffer::CopyToDSbuffer(void *samples, int tail, int numBytes)
{
    LPVOID  ptr1, ptr2;
    DWORD   bytes1, bytes2;

    // Obtain write ptr (beggining of buffer, whole buffer)
    TDSOUND(_dsBuffer->Lock(tail, numBytes, &ptr1, &bytes1, &ptr2, &bytes2, 0));
    //XXX realy should catch err and try to restore the stolen buffer+retry

    memcpy((void *)ptr1, samples, bytes1);                    // copy samples
    if(ptr2)
        memcpy((void *)ptr2, (char *)samples+bytes1, bytes2); // copy crumb

    TDSOUND(_dsBuffer->Unlock(ptr1, bytes1, ptr2, bytes2));
}


void
DSbuffer::FillDSbuffer(int tail, int numBytes, char value)
{
    void   *ptr1, *ptr2;
    DWORD   bytes1, bytes2;

    // Obtain write ptr (beggining of buffer, whole buffer)
    TDSOUND(_dsBuffer->Lock(tail, numBytes, &ptr1, &bytes1,
                                   &ptr2, &bytes2, NULL));
    //XXX should catch err and try to restore the stolen buffer and retry...
    
    memset(ptr1, value, bytes1);

    if(ptr2)
        memset(ptr2, value, bytes2);  // fill crumb

    TDSOUND(_dsBuffer->Unlock(ptr1, bytes1, ptr2, bytes2));
}


/**********************************************************************
Pan is not setup to be multiplicative as of now.  It directly maps to 
log units (dB).  This is OK since pan is not exposed.  We mainly use it
to assign sounds to channels within the implementation.

Pan ranges from -10000 to 10000, where -10000 is left, 10000 is right.
dsound actualy doesn't implement a true pan, more of a 'balance control'
is provided.  A true pan would equalize the total energy of the system
between the two channels as the pan==center of energy moves. Therefore
a value of zero gives both channels full on.
**********************************************************************/
int DSbuffer::dBToDSounddB(double dB)
{
    // The units for DSound (and DShow) are 1/100 ths of a decibel. 
    int result = fsaturate(_minDSgain, -1.0 *_minDSgain, dB * 100.0);
    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\htimer.cpp ===
/**********************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This module contains the member functions for the HiresTimer class
    which manages the vaguaries of the systems PerformanceCounter!

    Test: Create empty file headers.h in \tmp.
    cl /Yd /Zi -D_TIMERTEST_ -I.. -I\tmp htimer.cpp

**********************************************************************/

#include <headers.h>

#ifdef _TIMERTEST_
#include <windows.h>
#include <stdio.h>
#define Assert(s)
#endif
#include "privinc/htimer.h"


class HiresTimerImpl : public HiresTimer {
  public:

    HiresTimerImpl();

    virtual double GetTime();
    virtual double GetFrequency();
    
    BOOL Supported() { return _supported; }
    
    void SetInitialTime(LONG hi, DWORD lo);
    void Reset();

  private:
    double UnmungeTime(LARGE_INTEGER newTime, LARGE_INTEGER initialTime,
       double frequency);

    LARGE_INTEGER _initialTime;
    double        _clockFrequency;      // in ticks per second
    BOOL _supported;
};


HiresTimerImpl::HiresTimerImpl()
{
// XXX LARGE_INTERGER: Ughh.  Cant we operate on long longs here?
    LARGE_INTEGER tmpTime;
    LARGE_INTEGER zeroTime = { 0, 0 };

    BOOL _supported = QueryPerformanceFrequency(&tmpTime);

    Assert(_supported && "Doesn't have hires timer, using GetTickCount");
    
    _clockFrequency   = UnmungeTime(tmpTime, zeroTime, 1.0);

    QueryPerformanceCounter(&_initialTime);  // to cut largeTime to 32bit!
}


void
HiresTimerImpl::Reset()
{ 
    LARGE_INTEGER tmpTime;

    QueryPerformanceCounter(&tmpTime);
    _initialTime.HighPart = tmpTime.HighPart;
    _initialTime.LowPart  = tmpTime.LowPart;
}


double
HiresTimerImpl::GetTime()
{
    double result;
    LARGE_INTEGER tmpTime;

    QueryPerformanceCounter(&tmpTime);
    result = UnmungeTime(tmpTime, _initialTime, _clockFrequency);

    return(result);
}


double
HiresTimerImpl::GetFrequency()
{
    return(_clockFrequency);
}


double
HiresTimerImpl::UnmungeTime(LARGE_INTEGER newTime,
                            LARGE_INTEGER initialTime,
                            double frequency)
{
    double whole;

    if (newTime.HighPart == initialTime.HighPart) {
        
        Assert(newTime.LowPart >= initialTime.LowPart);

        return (newTime.LowPart - initialTime.LowPart) / frequency;

    } else if (newTime.LowPart < initialTime.LowPart) {
        
        // Borrow one from the High Part.
        // Assuming unsigned long 32 bits.

        Assert(sizeof(unsigned long) == 4);

        // The compiler needs to do this first, otherwise possible
        // overflow. 
        unsigned long forceSubtract =
            0xFFFFFFFF - initialTime.LowPart;
        newTime.LowPart = 
            forceSubtract + newTime.LowPart + 1;
        newTime.HighPart =
            newTime.HighPart - initialTime.HighPart - 1;
    } else {
        newTime.LowPart = newTime.LowPart - initialTime.LowPart;
        newTime.HighPart -= initialTime.HighPart;
    }

    whole = newTime.LowPart + newTime.HighPart * 4294967296.0;

    return whole/frequency;
}


void
HiresTimerImpl::SetInitialTime(LONG hi, DWORD lo)
{
    _initialTime.HighPart = hi;
    _initialTime.LowPart = lo;
}


class LoresTimer : public HiresTimer {
  public:

    LoresTimer() : _lastTick(0), _curTime(0.0) { GetTime(); }

    void Reset() { _curTime = 0; }

    virtual double GetTime() {
        if (_curTime == 0.0 && _lastTick == 0) {
            _lastTick = GetTickCount () ;
        } else {
            DWORD curtick = GetTickCount () ;

            if (curtick >= _lastTick) {
                _curTime += ((double) (curtick - _lastTick)) / 1000 ;
            } else {
                _curTime +=
                    ((double) (curtick + (0xffffffff - _lastTick))) / 1000 ;
            }

            _lastTick = curtick ;
        }

        return _curTime;
    }
    
    // Don't know what to return.
    virtual double GetFrequency() { return 1.0; }

  private:
    DWORD _lastTick;
    double _curTime;
};


HiresTimer& CreateHiresTimer()
{
    HiresTimerImpl* timer = NEW HiresTimerImpl();

    if (timer->Supported())
        return *timer;
    else {
        delete timer;
        return *(NEW LoresTimer());
    }
}


void
TimeStamp::Reset()
{
    _timeStamp = GetCurrentTime();
}


double 
TimeStamp::GetTimeStamp() 
{
    Assert(_timeStamp != -1.0);
    return(_timeStamp);
}


double 
TimeStamp::GetAge() 
{
    Assert(_timeStamp != -1.0);
    return(GetCurrentTime() - _timeStamp);
}


#ifdef _TIMERTEST_
void test(HiresTimerImpl& timer)
{
    printf("%15.5f\n", timer.GetTime());
    Sleep(1000);
    printf("%15.5f\n", timer.GetTime());
}


void main()
{
    HiresTimerImpl timer;

    printf("frequency = %15.5f\n", timer.GetFrequency());

    test(timer);

    timer.SetInitialTime(1, 0xFFFFFFFF);

    test(timer);

    timer.Reset();

    test(timer);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\init.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    General initialization for appel.dll.
*******************************************************************************/

#include "headers.h"
#include "privinc/registry.h"

// Macro refers to a function of the name InitializeModule_Name,
// assumed to be defined, and then calls it.  If it's not defined,
// we'll get a link time error.
#define INITIALIZE_MODULE(ModuleName)           \
  extern void InitializeModule_##ModuleName();  \
  InitializeModule_##ModuleName();

#define DEINITIALIZE_MODULE(ModuleName,bShutdown)               \
  extern void DeinitializeModule_##ModuleName(bool);            \
  DeinitializeModule_##ModuleName(bShutdown);

#define INITIALIZE_THREAD(ModuleName)           \
  extern void InitializeThread_##ModuleName();  \
  InitializeThread_##ModuleName();

#define DEINITIALIZE_THREAD(ModuleName)               \
  extern void DeinitializeThread_##ModuleName();  \
  DeinitializeThread_##ModuleName();

int
InitializeAllAppelModules()
{
    // Place module initializations in whatever order is required for
    // proper initialization.

    // Initialize ATL first
    INITIALIZE_MODULE(ATL);

    // Registry initialization must come early, as it defines the
    // preference list that is extended by other initialization.
    INITIALIZE_MODULE(Registry);

    // Moving storage up towards front -- needed for transient heaps.
    INITIALIZE_MODULE(Storage);

    // Initialize IPC stuff
    // !!! No threads can be created before this !!!
    INITIALIZE_MODULE(IPC);

    // Push the init heap
    DynamicHeapPusher dhp(GetInitHeap()) ;

    // GC needs to be before backend
    INITIALIZE_MODULE(Gc);
    INITIALIZE_MODULE(GcThread);

    // Needs to go before Backend
    INITIALIZE_MODULE(Values);

    // Needs to go before DirectX modules
    INITIALIZE_MODULE(MiscPref);

    INITIALIZE_MODULE(Constant);

    INITIALIZE_MODULE(Bvr);
    INITIALIZE_MODULE(Bbox2);
    INITIALIZE_MODULE(Bbox3);
    INITIALIZE_MODULE(Color);
    INITIALIZE_MODULE(Vec2);
    INITIALIZE_MODULE(Vec3);
    INITIALIZE_MODULE(Xform2);
    INITIALIZE_MODULE(Xform3);

    INITIALIZE_MODULE(bground);
    INITIALIZE_MODULE(Camera);
    INITIALIZE_MODULE(Control);
    INITIALIZE_MODULE(3D);
    INITIALIZE_MODULE(dsdev);
    INITIALIZE_MODULE(Viewport);
    // CRView must be after viewport because of dummy device
    INITIALIZE_MODULE(CRView);
    INITIALIZE_MODULE(Except);
    INITIALIZE_MODULE(Geom);
    INITIALIZE_MODULE(Image);
    INITIALIZE_MODULE(Import);
    INITIALIZE_MODULE(Light);
    INITIALIZE_MODULE(LineStyle);
    INITIALIZE_MODULE(Matte);
    INITIALIZE_MODULE(Mic);
    INITIALIZE_MODULE(Montage);

#if ONLY_IF_DOING_EXTRUSION
    INITIALIZE_MODULE(Path2);
#endif 
    
#if INCLUDE_VRML
    INITIALIZE_MODULE(ReadVrml);
#endif
    
    INITIALIZE_MODULE(SinSynth);
    INITIALIZE_MODULE(Sound);
    INITIALIZE_MODULE(Text);
    INITIALIZE_MODULE(Util);

    // FontStyle must be *after* Text, since it depends on
    // serifProportional being initialized.
    INITIALIZE_MODULE(FontStyle);

    INITIALIZE_MODULE(APIBasic);
    INITIALIZE_MODULE(API);
    INITIALIZE_MODULE(APIMisc);
    INITIALIZE_MODULE(APIBvr);
    INITIALIZE_MODULE(PickEvent);
    INITIALIZE_MODULE(View);
    INITIALIZE_MODULE(CBvr);
    INITIALIZE_MODULE(COMConv);
    INITIALIZE_MODULE(PlugImg);
    INITIALIZE_MODULE(Server);

    // This needs to be last
    INITIALIZE_MODULE(Context);

    return 0;
}

void
DeinitializeAllAppelModules(bool bShutdown)
{
    {
        DynamicHeapPusher dhp(GetInitHeap()) ;
        
        DEINITIALIZE_MODULE(IPC,      bShutdown);

        DEINITIALIZE_MODULE(3D,       bShutdown);
        // CRView must be before viewport because of dummy device
        DEINITIALIZE_MODULE(CRView,   bShutdown);
        DEINITIALIZE_MODULE(Viewport, bShutdown);
        DEINITIALIZE_MODULE(Registry, bShutdown);
        DEINITIALIZE_MODULE(dsdev,    bShutdown);
        DEINITIALIZE_MODULE(PlugImg,  bShutdown);
        DEINITIALIZE_MODULE(CBvr,     bShutdown);
        DEINITIALIZE_MODULE(Import,   bShutdown);
        DEINITIALIZE_MODULE(Image,    bShutdown);
        DEINITIALIZE_MODULE(Context,  bShutdown);
        DEINITIALIZE_MODULE(Gc,       bShutdown);
        DEINITIALIZE_MODULE(GcThread, bShutdown);
        DEINITIALIZE_MODULE(Control,  bShutdown);
        DEINITIALIZE_MODULE(bground,  bShutdown);
        DEINITIALIZE_MODULE(Bvr,      bShutdown);
        DEINITIALIZE_MODULE(View,     bShutdown);
        DEINITIALIZE_MODULE(Util,     bShutdown);
        DEINITIALIZE_MODULE(Except,   bShutdown);
        DEINITIALIZE_MODULE(BvrTI,    bShutdown);
        DEINITIALIZE_MODULE(APIMisc,  bShutdown);
        DEINITIALIZE_MODULE(APIBasic, bShutdown);
        
#if ONLY_IF_DOING_EXTRUSION
        DEINITIALIZE_MODULE(Path2,    bShutdown);
#endif
        
    }
    
    // This must be last to ensure that no one needs the memory
    // stored in the system heap
    DEINITIALIZE_MODULE (Storage,bShutdown);

    // Make this last since it depends on no other system resources
    DEINITIALIZE_MODULE (ATL,bShutdown);
}


void
InitializeAllAppelThreads()
{
}

void
DeinitializeAllAppelThreads()
{
    DEINITIALIZE_THREAD(Storage);
    DEINITIALIZE_THREAD(Except);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\imgutil.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File:       imgutil.cpp
 *  Content:    Routines for loading image bitmaps
 *
 ***************************************************************************/
#include "headers.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <string.h>
#include "privinc/urlbuf.h"
#include "privinc/except.h"
#include "privinc/resource.h"
#include "privinc/ddutil.h"
#include "privinc/debug.h"
#include "privinc/bbox2i.h"
#include "include/appelles/hacks.h"

#define IMGTYPE_UNKNOWN 0
#define IMGTYPE_BMP     1
#define IMGTYPE_GIF     2
#define IMGTYPE_JPEG    3

extern HBITMAP *LoadGifImage(LPCSTR szFileName,
                             IStream *stream,
                             int dx, int dy,
                             COLORREF **colorKeys, 
                             int *numGifs,
                             int **delays,
                             int *loop); // in loadgif.cpp

///////////////////////////////////////////////////////////////////////////
// Attempt to determine, from the supplied filename, what type of
// bitmap a file contains.
//
int _GetImageType(LPCSTR szFileName) {
  LPSTR pExt;
  int len;
  int result;

  result = IMGTYPE_UNKNOWN;

  if ((NULL == szFileName) || (0 == (len = lstrlen(szFileName)))) return result;

  pExt = StrRChrA(szFileName,NULL,'.');
  if (NULL == pExt) return result;

// Compare against known extensions that we don't punt to the plugin
// decoders 
//
  if (!lstrcmpi(pExt,".bmp")) result = IMGTYPE_BMP;
  else if (!lstrcmpi(pExt,".gif"))  result = IMGTYPE_GIF;
  else if (!lstrcmpi(pExt,".giff")) result = IMGTYPE_GIF;
  else if (!lstrcmpi(pExt,".jpg")) result = IMGTYPE_JPEG;
  else if (!lstrcmpi(pExt,".jpeg")) result = IMGTYPE_JPEG;

  return result;
}

///////////////////////////////////////////////////////////////////////////
HBITMAP * 
UtilLoadImage(LPCSTR szFileName,
              IStream * pstream,
              int dx,int dy,
              COLORREF **colorKeys, 
              int *numBitmaps,
              int **delays,
              int *loop){

    *numBitmaps = 1;
    *colorKeys = NULL;      
    HBITMAP bitmap = NULL;
    HBITMAP *bitmapArray = NULL;
    
    switch (_GetImageType(szFileName)) {
        
      case IMGTYPE_BMP:
        {

        bitmap = (HBITMAP) LoadImage(NULL,
                                     szFileName,
                                     IMAGE_BITMAP,
                                     dx, dy,
                                     LR_LOADFROMFILE|LR_CREATEDIBSECTION);
        }
        break;
        
      case IMGTYPE_GIF:
        // changes numBitmaps if needed
        {
            if(pstream) {
                
                /*  
                #if _DEBUGMEM                 
                static _CrtMemState diff, oldState, newState;
                _CrtMemCheckpoint(&oldState);
                #endif
                */

                bitmapArray = LoadGifImage(szFileName,
                                           pstream,                                           
                                           dx,dy,
                                           colorKeys,
                                           numBitmaps,
                                           delays,
                                           loop);

                /*
                #if _DEBUGMEM
                _CrtMemCheckpoint(&newState);
                _CrtMemDifference(&diff, &oldState, &newState);
                _CrtMemDumpStatistics(&diff);
                _CrtMemDumpAllObjectsSince(&oldState);                
                TraceTag((tagImport,
                  "%x and %x, are normal return arrays and not leaks",
                  delays,
                  bitmapArray));
                #endif
                */
            }
            break;
        }
      
      case IMGTYPE_JPEG:
      case IMGTYPE_UNKNOWN:
      default:
        break;
    }
    
    if((bitmapArray == NULL) && (bitmap == NULL))
        return NULL;

    //XXXX HACKHACKHACK return -1 to disable plugins
    if (bitmap == (HBITMAP)-1)
        return (HBITMAP*)-1;

    if((bitmapArray == NULL) && (bitmap != NULL)) {
        bitmapArray = (HBITMAP *)AllocateFromStore(sizeof(HBITMAP));
        bitmapArray[0] = bitmap;
    }
    
    return bitmapArray;
}


// Convert a DA Point to a discrete integer based point assuming that
// we have an image centered about the DA origin, and that the pixel
// width and height are as given.
void CenteredImagePoint2ToPOINT(Point2Value	*point, // in
                                LONG		 width, // in
                                LONG		 height, // in
                                POINT		*pPOINT) // out
{
    pPOINT->x = LONG(point->x * ViewerResolution()) + width / 2;
    pPOINT->y = height - (LONG(point->y * ViewerResolution()) + height / 2);
}


// Given a GDI point (pPOINT) on a width x height bitmap that is
// assumed to have referenceImg mapped to it, find the corresponding
// DA point (point2) on the reference image.  Note that the aspect
// ratio between the image and the width x height might be different
// and need to be compensated for.

void CenteredImagePOINTToPoint2(POINT		*pPOINT, // in
                                LONG		 width, // in
                                LONG		 height, // in
                                Image		*referenceImg, // in
                                Point2Value	*pPoint2) // out
{
    // GDI coord is positive down...
    Real pctFromTop = (Real)(pPOINT->y) / (Real)height;
    Real pctFromLeft = (Real)(pPOINT->x) / (Real)width;

    Bbox2 dstBox = referenceImg->BoundingBox();

    Real dstWidth = dstBox.Width();
    Real dstHeight = dstBox.Height();

    // Go from left (min)
    pPoint2->x = dstBox.min.x + pctFromLeft * dstWidth;

    // Go from top (max)
    pPoint2->y = dstBox.max.y - pctFromTop * dstHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\helpaa.cpp ===
/**********************************************************************
Audio Active helper functions
**********************************************************************/
#include "headers.h"
#include "appelles/common.h"
#include <wtypes.h>
#include <msimusic.h>
#include <stdio.h>
#include "privinc/debug.h"
#include "privinc/helpaa.h"
#include "privinc/except.h"
#include "privinc/resource.h"

AAengine::AAengine()
{
    _simpleInit      = NULL;  // null out all function pointers!
    _loadSectionFile = NULL;
    _setAAdebug      = NULL;
    _panic           = NULL;

    LoadDLL();    // cause the msimusic dll to be loaded and fn ptrs to be set
    SimpleInit(); // instantiate the engine
    _realTime = _engine->GetRealTime();  // handle to realTime object

#ifdef MESSWITHCLOCK
    _clock = realTime->GetClock();
    if(!_clock)
        RaiseException_InternalError("GetClock: Unknown Err");
#endif /* MESSWITHCLOCK */

    _currentRate = 0.0;
    _paused = TRUE;     // make sure we play it the first time
}


AAengine::~AAengine()
{
    int tmp;

    // stop the engine immediately (stops playing at next measure by default)
    if(_engine) {
        _engine->Stop(AAF_IMMEDIATE);
        _engine->Release(); // this releases all personalities, and styles
    }

    if(_realTime)
        tmp = _realTime->Release();

#ifdef DEALWITHCLOCK
    if(_clock)
        tmp = _clock->Release();     // release Clock
#endif /* DEALWITHCLOCK */

    if(_aaLibrary)
        FreeLibrary(_aaLibrary);     // decrement the msimusic.dll refcount
}


void AAengine::LoadDLL()
{
    // NOTE: This code contains munged C++ dll entrypoints!

    _aaLibrary = LoadLibrary("msimusic.dll");
    if(_aaLibrary == NULL)
        RaiseException_InternalError("Failed to LoadLibrary msimusic.dll\n");

    // load suceeded: set function pointers
    _simpleInit = 
        (SimpleInitFn)GetProcAddress(_aaLibrary, "_MusicEngineSimpleInit@12");
    if(!_simpleInit) 
        RaiseException_InternalError("Failed to find MusicEngineSimpleInit\n");
 
    _loadSectionFile = 
        (LoadSectionFn)GetProcAddress(_aaLibrary, "_LoadSectionFile@12");
    if(!_loadSectionFile) 
        RaiseException_InternalError("Failed to find LoadSectionFile\n");

    _setAAdebug = (SetAAdebugFn)GetProcAddress(_aaLibrary, "_SetAADebug@4");
    if(!_setAAdebug) 
        RaiseException_InternalError("Failed to find SetAADebug\n");
 
    _panic = (PanicFn)GetProcAddress(_aaLibrary, "_Panic@4");
    if(!_panic) 
        RaiseException_InternalError("Failed to find Panic\n");
 
}


void AAengine::SetGain(double gain)
{
    setAArelVolume(_realTime, gain);
}


void AAengine::SetRate(double rate)
{
    if(rate!=_currentRate) {
        if(rate==0.0) {
            // stop the sound
            Pause(); // stop realTime
            _paused = TRUE;
        }
        else {
            setAArelTempo(_realTime, rate);

            if(_paused) {
                // start it playing
                Resume(); // start realTime
                _paused = FALSE;
            }
        }
    _currentRate = rate;
    }
}


void
AAengine::Stop()
{
    stopAAengine(_engine, AAF_IMMEDIATE); // stop the engine
}


void
AAengine::Pause()
{
    // send an all notes off to all channels!
    Assert(_panic && "_panic not set; loadLibrary must have failed");
    switch(int status = _panic(_engine)) {
        case S_OK: TraceTag((tagSoundMIDI, "AMI Panic OK\n")); break;
        case E_INVALIDARG: RaiseException_InternalError("AMIPanic bad engine pointer\n");
        default: RaiseException_InternalError("AMI Panic Failed.\n");
    }

    // XXX Panic doesn't seem to be working so we will drop volume instead?
    // XXX Nah, lets manualy try sending all notes off???

    // stop the realTime object effectively pausing the engine
    switch(int status = _realTime->Stop()) {
        case S_OK: TraceTag((tagSoundMIDI, "_realTime->Stop OK\n")); break;
        default: RaiseException_InternalError("_realTime->Stop Failed.\n");
    }
}


void
AAengine::Resume()
{
    switch(int status = _realTime->Start()) {
        case S_OK: TraceTag((tagSoundMIDI, "_realTime->Play OK\n")); break;
        default: RaiseException_InternalError("_realTime->Play Failed.\n");
    }
}


void
AAengine::RegisterSink(IAANotifySink *sink)
{
registerAAsink(_engine, sink);
}


void 
AAengine::LoadSectionFile(char *fileName, IAASection **section)
{
    Assert(_loadSectionFile && 
           "_loadSectionFile not set; loadLibrary must have failed");

    switch(_loadSectionFile(_engine, fileName, section)) {
        case  S_OK:
            TraceTag((tagSoundMIDI, "LoadSectionFile: OK!"));
        break;

        // XXX NOTE: we get these on bad tempo'd MIDI files, too...
        case  E_OUTOFMEMORY:
            TraceTag((tagSoundMIDI,
                      "LoadSectionFile: out of memory > %s", fileName));
            RaiseException_InternalError(IDS_ERR_OUT_OF_MEMORY);
    
        case  E_INVALIDARG:
            TraceTag((tagSoundMIDI,
                      "LoadSectionFile: invalid argument > %s", fileName));
            RaiseException_InternalError(IDS_ERR_INVALIDARG);
    
        case  E_FAIL:
            TraceTag((tagSoundMIDI,
                      "LoadSectionFile: failed to load > %s", fileName));
            RaiseException_UserError(E_FAIL, IDS_ERR_SND_LOADSECTION_FAIL,fileName);
    
        default:
            TraceTag((tagSoundMIDI,
                      "LoadSectionFile: could not load section file > %s", fileName));
            RaiseException_UserError(E_FAIL, IDS_ERR_SND_LOADSECTION_FAIL,fileName);
    }
}


void 
AAengine::PlaySection(IAASection *section)
{
playAAsection(_engine, section);
}


void
AAengine::SimpleInit()
{
    int status;

    Assert(_simpleInit && "_simpleInit not set; loadLibrary must have failed");

    _engine = NULL; // they require the ptr to be initialized to zero!
    switch(status = _simpleInit(&_engine, NULL, NULL)) {
        case S_OK: TraceTag((tagSoundMIDI, "AAsimpleInit OK\n")); break;
        case E_OUTOFMEMORY: RaiseException_OutOfMemory
            ("MusicEngineSimpleInit: out of memory", 0); 
            //XXX we don't know sz of request so we return 0...
        case E_INVALIDARG:  RaiseException_InternalError
            ("MusicEngineSimpleInit: invalid arg");
        default: RaiseException_InternalError("AAsimpleInit Failed.  No MIDI\n");
        }

    Assert(_setAAdebug && "_setAAdebug not set; loadLibrary must have failed");
#if _DEBUG
    _setAAdebug(5);  // 3 send all error and warning messages to stdout
                     // 5 informational messages included
#else    
    _setAAdebug(0);  // no err messages sent to stdout (debug output window)
#endif /* _DEBUG */
}


extern "C" void 
stopAAengine(IAAEngine *engine, AAFlags mode)
{
    switch(engine->Stop(mode)) {
    case S_OK: TraceTag((tagSoundMIDI, "AA enine->Stop OK\n")); break;
    default:            RaiseException_InternalError
        ("AA engine->Stop(): Unknown Err");
    }
}


extern "C" void 
registerAAsink(IAAEngine *engine, IAANotifySink *sink)
{
    switch(engine->SetNotifySink(sink)) { // register notify sink
    case S_OK: TraceTag((tagSoundMIDI, "AA enine->SetNotifySink OK\n")); break;
    default:            RaiseException_InternalError
        ("AA engine->Stop(): Unknown Err");
    }
}


void playAAsection(IAAEngine *engine, IAASection *section)
{
    HRESULT err = engine->PlaySection(section, AAF_IMMEDIATE, 0);

    switch(err) {
        case  S_OK: TraceTag((tagSoundMIDI, "Play OK")); break;
        case  E_NOTIMPL: TraceTag((tagSoundErrors,
                            "Play E_NOTIMPL (audioActive is whacked!"));
        break;

        case  E_POINTER:
            TraceTag((tagSoundErrors, "Play: invalid section"));
            RaiseException_UserError("Play: invalid section");
        break;

        case  E_INVALIDARG:
            TraceTag((tagSoundErrors, "Play: invalid argument"));
            RaiseException_UserError(E_INVALIDARG,IDS_ERR_INVALIDARG);
        break;

        case  E_FAIL:
            TraceTag((tagSoundErrors, "Play: failed, section already playing"));
            RaiseException_UserError("Play: failed, section already playing");
        break;

        default:
            TraceTag((tagSoundErrors, "Play: Unknown Err (0x%0X)", err));
            RaiseException_UserError("Play: Unknown Err");
    }
}


// Move to a helper helper?
int clamp(int min, int max, int value)
{
int answer;

if(value>max)
    answer = max;
else if(value<min)
    answer = min;
else
    answer = value;

return(answer);
}


void setAArelVolume(IAARealTime *realTime, double volume)
{
int _volume = (int)(100.0*volume);

// XXX These values must be saturated to 0 - 200!
realTime->SetRelVolume(clamp(0, 200, _volume));

// XXX add fancy err checks!
}


void setAArelTempo(IAARealTime *realTime, double rate)
{
int _rate = (int)(100.0*rate);

// XXX These values must be saturated to 0 - 200!
realTime->SetRelTempo(clamp(0, 200, _rate));

// XXX add fancy err checks!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\makefile.inc ===
!include $(ROOT)\src\make\make1.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\helpq.cpp ===
/**********************************************************************
Copyright (c) 1997 Microsoft Corporation

helpq.cpp:

    Quart filter graph support
**********************************************************************/
#include "headers.h"
#include "ddraw.h" // DDPIXELFORMAT
#include "privinc/helpq.h"
#include "privinc/util.h"  // saturate
#include "privinc/resource.h"
#include "privinc/viewport.h" // GetDirectDraw
#include "privinc/dddevice.h" // DirectDrawImageDevice

#define USE_AMMSF_NOSTALL

Mutex avModeMutex;

QuartzRenderer::QuartzRenderer() : _MIDIgraph(NULL), _audioControl(NULL),
     _mediaControl(NULL), _mediaPosition(NULL), _mediaEvent(NULL)
{
    _rate0paused = FALSE;
    _playing     = FALSE;
}


void 
QuartzRenderer::Open(char *fileName)
{
    HRESULT hr;

    if(!_MIDIgraph) {
        // create instance of the quartz graph
        if(FAILED(hr = CoCreateInstance(CLSID_FilterGraph, NULL,
                              CLSCTX_INPROC_SERVER, IID_IGraphBuilder,
                              (void **)&_MIDIgraph)))
            RaiseException_InternalError("Failed to CoCreateInstance quartz\n");

        // get the event notification handle so we can wait for completion
        if(FAILED(hr = _MIDIgraph->QueryInterface(IID_IMediaEventEx,
                                              (void **)&_mediaEvent)))
            RaiseException_InternalError("Failed QueryInterface(_MIDIgraph)\n");
        if(FAILED(hr = _mediaEvent->SetNotifyFlags(1)))
            RaiseException_InternalError("Failed SetNotifyFlags\n");
        _mediaEvent->GetEventHandle((OAEVENT *)&_oaEvent);


        // ask the graph to render our file
        WCHAR path[MAX_PATH];  // unicode path
        MultiByteToWideChar(CP_ACP, 0, fileName, -1,
                            path, sizeof(path)/sizeof(path[0]));

        if(FAILED(hr = _MIDIgraph->RenderFile(path, NULL))) {
            RaiseException_UserError(hr, IDS_ERR_FILE_NOT_FOUND, fileName);
        }


        // get the BasicAudio interface so we can control this thing!
        if(FAILED(hr = _MIDIgraph->QueryInterface(IID_IBasicAudio,
                                              (void**)&_audioControl)))
            RaiseException_InternalError("BasicAudio QueryInterface Failed\n");


        // get the filtergraph control interface
        if(FAILED(hr = _MIDIgraph->QueryInterface(IID_IMediaControl,
                                              (void**)&_mediaControl)))
            RaiseException_InternalError("mediaControl QueryInterface Failed\n");


        // get the filtergraph media position interface
        if(FAILED(hr = _MIDIgraph->QueryInterface(IID_IMediaPosition,
                                             (void**)&_mediaPosition)))
            RaiseException_InternalError("mediaPosition QueryInterface Failed\n");
    }

    _rate0paused = FALSE;
    _playing     = FALSE;
}


void
QuartzRenderer::CleanUp()
{
    if(_audioControl)   _audioControl->Release();
    if(_mediaControl)   _mediaControl->Release();
    if(_mediaPosition)  _mediaPosition->Release();
    if(_MIDIgraph)      _MIDIgraph->Release();
    if(_mediaEvent)     _mediaEvent->Release();
}


double
QuartzRenderer::GetLength()
{
    REFTIME length; // XXX this is a double?
    HRESULT hr;

    Assert(_mediaPosition);
    if(FAILED(hr = _mediaPosition->get_Duration(&length)))
        RaiseException_InternalError("mediaPosition get_duration Failed\n");

    return(length);
}


void
QuartzRenderer::Play()
{
    HRESULT hr;

    Assert(_mediaControl);
    if(FAILED(hr = _mediaControl->Pause()))
        RaiseException_InternalError("quartz pause Failed\n");

    if(FAILED(hr = _mediaControl->Run()))
        RaiseException_InternalError("quartz run Failed\n");

    _rate0paused = FALSE;
    _playing     = TRUE;
}


void
QuartzRenderer::Position(double seconds)
{
    HRESULT hr;

    Assert(_mediaPosition);
    if(FAILED(hr = _mediaPosition->put_CurrentPosition(seconds)))
        RaiseException_InternalError("quartz put_CurrentPosition Failed\n");
}


void
QuartzRenderer::Stop()
{
    HRESULT hr;

    if (_mediaControl) {
            if(FAILED(hr = _mediaControl->Stop()))
                    RaiseException_InternalError("quartz stop Failed\n");
        }

    _rate0paused = FALSE;
    _playing     = FALSE;
}


void
QuartzRenderer::Pause()
{
    HRESULT hr;

    if (_mediaControl) {
                if(FAILED(hr = _mediaControl->Pause()))
                        RaiseException_InternalError("quartz pause Failed\n");
        }

    // we don't change the pause state here, only for rate zero pause!
}


void
QuartzRenderer::SetRate(double rate)
{
    HRESULT hr;

    //NOTE: the MIDI renderer becomes confused on extreemely lorates under 0.1
    if(rate < 0.1) {
        Assert(_mediaControl);
        if(FAILED(hr = _mediaControl->Pause())) // pause the graph
            RaiseException_InternalError("quartz pause Failed\n");
       _rate0paused = TRUE;
    }
    else { // normal case
        if(_playing && _rate0paused) {
            Assert(_mediaControl);
            if(FAILED(hr = _mediaControl->Run())) // unpause the graph
                RaiseException_InternalError("quartz run Failed\n");

            _rate0paused = FALSE;
        }

        double quartzRate = fsaturate(0.1, 3.0, rate);
        Assert(_mediaPosition);
        _mediaPosition->put_Rate(quartzRate);
    }
}


void
QuartzRenderer::SetGain(double dBgain)
{
    HRESULT hr;

    Assert(_audioControl);
    double suggestedGain = dBToQuartzdB(dBgain);
    int gain = saturate(-10000, 0, suggestedGain);
    if(FAILED(hr = _audioControl->put_Volume(gain)))
        RaiseException_InternalError("quartz put_Volume Failed\n");
}


void
QuartzRenderer::SetPan(double pan, int direction)
{
    HRESULT hr;

    Assert(_audioControl);

    double qPan = direction * dBToQuartzdB(-1.0 * pan);
    qPan = fsaturate(-10000, 10000, qPan);
    if(FAILED(hr = 
        _audioControl->put_Balance(qPan)))
        RaiseException_InternalError("quartz put_Balance Failed\n");
}


bool 
QuartzRenderer::QueryDone()
{
    bool done = false;

    if(!_rate0paused) {
        Assert(_oaEvent);

#ifdef NEWFANGLED_UNPROVEN
        Assert(_mediaEvent);

        while(WaitForSingleObject(_oaEvent, 0) == WAIT_OBJECT_0) {
            long event, param1, param2;
            while(SUCCEEDED(_mediaEvent->GetEvent(
                &event, &param1, &param2, 0))) {
                _mediaEvent->FreeEventParams(event, param1, param2);
                if(event == EC_COMPLETE) 
                    done = true;
            }
        }
#else
        if(WaitForSingleObject(_oaEvent, 0) == WAIT_OBJECT_0)
            done = true;
#endif
    }

    return(done);
}


QuartzMediaStream::QuartzMediaStream() : 
    _multiMediaStream(NULL), _clockAdjust(NULL)
{
    HRESULT hr;

    // create instance of the quartz graph
    if(FAILED(hr = CoCreateInstance(CLSID_AMMultiMediaStream, NULL, 
                     CLSCTX_INPROC_SERVER, IID_IAMMultiMediaStream, 
                     (void **)&_multiMediaStream)))
        RaiseException_InternalError("Failed to CoCreateInstance amStream\n");
    TraceTag((tagAMStreamLeak, "leak MULTIMEDIASTREAM %d created", 
        _multiMediaStream));

    if(FAILED(hr = _multiMediaStream->QueryInterface(IID_IAMClockAdjust, 
                                                    (void **)&_clockAdjust))) {

        TraceTag((tagError, "Old amstream w/o ClockAdjust interface detected %hr", hr));

        // no longer an error (for now we tolerate old amstreams!
        //RaiseException_InternalError("Failed to QueryInterface clockAdjust\n");
    }
    TraceTag((tagAMStreamLeak, "leak CLOCKADJUST %d created", _clockAdjust));

    if(FAILED(hr = _multiMediaStream->Initialize(STREAMTYPE_READ, 0, NULL)))
        RaiseException_InternalError("Failed to initialize amStream\n");


#ifdef PROGRESSIVE_DOWNLOAD
    // things for progressive download
    //IGraphBuilder *graphBuilder;
    //IMediaSeeking *seeking;
    //_multiMediaStream->GetFilterGraph(graphBuilder);
    //hr =_graphBuilder->QueryInterface(IID_IMediaSeeking, (void **)&seeking); 
    //graphBuilder->Release();

    // determine how much has been downloaded to calculate statistics for 
    // progressive download
    //seeking->GetAvailable(&ealiest, &latest);
#endif
}


bool
QuartzReader::QueryPlaying()
{
    HRESULT hr;
    STREAM_STATE streamState;

    if(FAILED(hr = _multiMediaStream->GetState(&streamState)))
        RaiseException_InternalError("Failed to GetState amStream\n");

    bool playing = (streamState == STREAMSTATE_RUN);
    return(playing);
}


bool
QuartzReader::Stall()
{
    bool value = _stall;
    _stall = false;        // reset the value

    return(value);
}


void
QuartzReader::SetStall()
{
    bool setValue = true;
#if _DEBUG
        if(IsTagEnabled(tagMovieStall)) 
            setValue = _stall;
#endif /* _DEBUG */
    _stall = setValue;
}

void
QuartzAVstream::InitializeStream()
{
    if (!QuartzVideoReader::IsInitialized()) {
        VideoInitReader(GetCurrentViewport()->GetTargetPixelFormat());
    }
}

bool
QuartzAVstream::SafeToContinue()
{
    // check to see if either A or V time is 0 and the other is above threashold
    const double threashold = 0.5;
    bool safe = true;
    double videoSeconds = AVquartzVideoReader::GetSecondsRead();
    double audioSeconds = AVquartzAudioReader::GetSecondsRead();

    if( ((videoSeconds==0) || (audioSeconds==0)) &&
        ((videoSeconds>threashold) || (audioSeconds>threashold)))
        safe = false;

    return(safe);
}


int
QuartzAVstream::ReadFrames(int numSamples, unsigned char *buffer, bool blocking)
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex
    int framesRead = 
        AVquartzAudioReader::ReadFrames(numSamples, buffer, blocking);

    // XXX maybe CleanUp is too severe... Possibly only release the samples
    //     in a dissable call?
    if(QuartzAudioReader::Stall())      // check for stall
        QuartzVideoReader::Disable();   // perform lockout 

    return(framesRead);
} // end mutex context


HRESULT
QuartzAVstream::GetFrame(double time, IDirectDrawSurface **ppSurface)
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex
    HRESULT hr = AVquartzVideoReader::GetFrame(time, ppSurface);

    // XXX maybe CleanUp is too severe... Possibly only release the samples
    //     in a dissable call?
    if(QuartzVideoReader::Stall())      // check for stall
        QuartzAudioReader::Disable();   // perform lockout 

    return(hr);
} // end mutex context


int
AVquartzAudioReader::ReadFrames(int numSamples, unsigned char *buffer, 
    bool blocking)
{
    int framesRead = -1;

    if(_initialized) { // for AV mode fallback dectection!
        framesRead = 
            QuartzAudioReader::ReadFrames(numSamples, buffer, blocking);
        double secondsRead = pcm.FramesToSeconds(framesRead);
        AddReadTime(secondsRead);
    }
    else {
        TraceTag((tagAVmodeDebug, "AVquartzAudioReader::ReadFrames() FALLBACK"));
        // this stream must have been dissabled
        // XXX throw something
        //     so something upwind of us can fallback and create a vstream...
        //     (maybe AVstream needs a clone call?)
        //
        // XXX or maybe returning -1 is enough?
    }

    return(framesRead);
}


HRESULT 
AVquartzVideoReader::GetFrame(double time, IDirectDrawSurface **ppSurface)
{
    HRESULT hr = 0;

    hr = QuartzVideoReader::GetFrame(time, ppSurface);

    AddReadTime(0.3); // we don't know how far dshow skipped
                          // guess we have to compare time stamps
    return(hr);
}


void
QuartzMediaStream::CleanUp()
{
    if(_multiMediaStream) {
        int result =_multiMediaStream->Release();
        TraceTag((tagAMStreamLeak, "leak MULTIMEDIASTREAM %d released (%d)", 
            _multiMediaStream, result));
        _multiMediaStream = NULL;
    }

    if(_clockAdjust) {
        int result = _clockAdjust->Release();
        TraceTag((tagAMStreamLeak, "leak CLOCKADJUST %d released (%d)", 
            _clockAdjust, result));
        //Assert(!result);
        _clockAdjust = NULL;
    }
}


// default to non-seekable == self clocking
void
QuartzVideoStream::Initialize(char *url, DDSurface *surface, bool seekable)
{
    HRESULT hr;
    char string[200];

    Assert(QuartzMediaStream::_multiMediaStream);

    GetDirectDraw(&_ddraw, NULL, NULL);
    TraceTag((tagAMStreamLeak, "leak DDRAW %d create", _ddraw));

    DWORD flags = NULL;
#ifdef USE_AMMSF_NOSTALL
    if(!seekable)
        flags |= AMMSF_NOSTALL;
#endif
    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->AddMediaStream(_ddraw,
                 &MSPID_PrimaryVideo, flags, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to AddMediaStream amStream\n");
    }

    flags = seekable ? AMMSF_NOCLOCK : NULL;
    if(FAILED(hr = 
        QuartzMediaStream::_multiMediaStream->OpenFile(GetQURL(), flags))) {

        TraceTag((tagError, "Quartz Failed to OpenFile <%s> %hr\n", url, hr));
        CleanUp();
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE, url);
    }

    if(!VideoSetupReader(QuartzMediaStream::_multiMediaStream, 
        QuartzMediaStream::_clockAdjust, surface, seekable)) {
        // video stream not there
    }
}


QuartzVideoReader::QuartzVideoReader(char *url, StreamType streamType) :
    QuartzReader(url, streamType), _ddrawStream(NULL),
    _async(false), _seekable(false), _ddrawSample(NULL),
    _ddrawSurface(NULL), _height(NULL), _width(NULL), _hrCompStatus(NULL),
    _curSampleStart(0), _curSampleEnd(0), _curSampleValid(false), _surface(NULL)
{
}


void
QuartzVideoReader::VideoInitReader(DDPIXELFORMAT pixelFormat)
{
    HRESULT     hr;

    if(!_ddrawStream) // this is a hacky check to fix the audio initialize case
                      // if only audio is used in an import...
        return;  

    IDDrawSurface *ddSurface = NULL; // the actual ddSurface from the wrapper
    if(_surface)
        ddSurface = _surface->IDDSurface(); // extract actual surf from wrapper

    _initialized = true;
    _deleteable  = false;


    { // set the desired pixel format
        DDSURFACEDESC ddsc;
        ddsc.dwSize = sizeof(DDSURFACEDESC);

        // get the movie's native format
        if(FAILED(hr = _ddrawStream->GetFormat(&ddsc, NULL, NULL, NULL))) {
            CleanUp();
            RaiseException_InternalError("Failed to GetFormat\n");
        }

        // Set the format and system memory
        ddsc.dwFlags = DDSD_PIXELFORMAT;
        ddsc.ddpfPixelFormat = pixelFormat;

        if(FAILED(hr = _ddrawStream->SetFormat(&ddsc, NULL))) {
            CleanUp();
            RaiseException_InternalError("Failed to SetFormat\n");
        }

    }

    // setup pcm
#ifdef XXX  // might have to add quartz timing to pcm?
    if(FAILED(hr = _audioStream->GetFormat(&waveFormat))) {
        CleanUp();
        RaiseException_InternalError("Failed to GetFormat\n");
    }
    pcm.SetPCMformat(waveFormat);        // configure our PCM info
    pcm.SetNumberSeconds(GetDuration()); // length, too!
#endif

#ifdef USE_QUARTZ_EVENTS
    _event = CreateEvent(FALSE, NULL, NULL, FALSE);
#endif USE_QUARTZ_EVENTS

#if _DEBUG
    if(ddSurface)
        TraceTag((tagAVmodeDebug, "creating sample with surf=%x", ddSurface));
    else
        TraceTag((tagAVmodeDebug, "creating sample without surface"));
#endif

    if(FAILED(hr =
            _ddrawStream->CreateSample(ddSurface, NULL, 0, &_ddrawSample))) {
        CleanUp();
        RaiseException_InternalError("Failed to CreateSample\n");
    }
    TraceTag((tagAMStreamLeak, "leak DDRAWSAMPLE %d created", _ddrawSample));

    if(FAILED(hr = _ddrawSample->GetSurface(&_ddrawSurface, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to GetSurface\n");
    }
    TraceTag((tagAMStreamLeak, "leak DDRAWSURFACE %d created", _ddrawSurface));

    if(FAILED(hr = _multiMediaStream->SetState(STREAMSTATE_RUN))) {
        CleanUp();
        RaiseException_InternalError("Failed to SetState\n");
    }

        // XXX why is this call being made?  Is it prefetch?  Do we need it?
#ifdef TEST_GOING_AWAY
    if(_async)
        _ddrawSample->Update(SSUPDATE_ASYNC | SSUPDATE_CONTINUOUS,
            NULL, NULL, 0);
#endif
}


// cache intensions which will actually be late bound by VideoInitReader
// called by QuartzVideoReader::GetFrames()'s first use
// fails if video not on the stream
bool
QuartzVideoReader::VideoSetupReader(IAMMultiMediaStream *multiMediaStream,
    IAMClockAdjust *clockAdjust, DDSurface *surface, bool seekMode)
{
    HRESULT hr;
    bool status = true;

    _deleteable = false;

    if(surface) {
        Assert(!_surface); // this should be the first and only time through

        _surface = surface; // keep ptr so we can release the wrapper in cleanup
    }

    _multiMediaStream = multiMediaStream;  // we don't only, are only sharing
    _clockAdjust      = clockAdjust;

    { // determine _async and _seekable
        DWORD       dwStreamFlags;
        STREAM_TYPE streamType;

        if(FAILED(hr = _multiMediaStream->GetInformation(&dwStreamFlags,
                                                         &streamType))) {
            CleanUp();
            RaiseException_InternalError("Failed to GetInformation\n");
        }


        _async = (dwStreamFlags & (MMSSF_HASCLOCK | MMSSF_ASYNCHRONOUS)) ==
                        (MMSSF_HASCLOCK | MMSSF_ASYNCHRONOUS);

        _seekable = (dwStreamFlags & MMSSF_SUPPORTSEEK) ? true : false;
    }

    if(FAILED(hr =
        _multiMediaStream->GetMediaStream(MSPID_PrimaryVideo, &_mediaStream))) {
        CleanUp();
        RaiseException_InternalError("Failed to GetMediaStream\n");
    }
    TraceTag((tagAMStreamLeak, "leak MEDIASTREAM %d create", _mediaStream));

    if(FAILED(hr = _mediaStream->QueryInterface(IID_IDirectDrawMediaStream,
                                                (void**)&_ddrawStream))) {
        CleanUp();
        RaiseException_InternalError("Failed to GetMediaStream\n");
    }
    TraceTag((tagAMStreamLeak, "leak DDRAWSTREAM %d created", _ddrawStream));
   

    { // determine video dimensions
        DDSURFACEDESC ddsc;
        ddsc.dwSize = sizeof(DDSURFACEDESC);

        if(FAILED(hr = _ddrawStream->GetFormat(&ddsc, NULL, NULL, NULL))) {
            status = false;
        }
        else {
            _height = ddsc.dwHeight;
            _width  = ddsc.dwWidth;
        }
    }

    return(status);
}


void 
QuartzVideoReader::Seek(double time)
{
    if (!AlreadySeekedInSameTick()) {
        LONGLONG quartzTime = pcm.SecondsToQuartzTime(time);

        if (_multiMediaStream) {
            _multiMediaStream->Seek(quartzTime);
        }
    }
}


void
QuartzReader::CleanUp()
{
    if(_mediaStream) {
        int result = _mediaStream->Release();
        TraceTag((tagAMStreamLeak, "leak MEDIASTREAM %d released (%d)", 
            _mediaStream, result));
        _mediaStream = NULL;
    }

    if(_url) {
        delete(_url);
        _url = NULL;
    }

    if(_qURL) {
        delete[] _qURL;
        _qURL = NULL;
    }
}


void
QuartzVideoReader::CleanUp() 
{ // mutex scope
    //MutexGrabber mg(_readerMutex, TRUE); // Grab mutex

    //TraceTag((tagError, "QuartzVideoReader::CleanUp()  this=%x", this));

    if(_ddrawStream) {
        int result = _ddrawStream->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAWSTREAM %d released (%d)", 
            _ddrawStream, result));
        _ddrawStream = NULL;
    }

    if(_ddrawSample) {
        // Stop any pending operation
        HRESULT hr = _ddrawSample->CompletionStatus(
                 COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE); 
        int result = _ddrawSample->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAWSAMPLE %d released (%d)", 
            _ddrawSample, result));
        _ddrawSample = NULL;
    }

    if(_ddrawSurface) {
        int result = _ddrawSurface->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAWSURFACE %d released (%d)", 
            _ddrawSurface, result));
        _ddrawSurface = NULL;
    }

    _surface.Release();

    _initialized = false;  // this to keep us safe if attempted to use
    _deleteable  = true;   // this is to allow potential avstream to be deleted
} // end mutex scope


void
QuartzVideoReader::Disable() 
{ // mutex scope

    // basically we can't just call CleanUp because the _ddrawSurface is
    // still in use...  (_initialized should save us from improper use!)

    if(_ddrawSample) {
        // Stop any pending operation
        HRESULT hr = _ddrawSample->CompletionStatus(
                 COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE); 
        int result =_ddrawSample->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAWSAMPLE %d released (%d)", 
            _ddrawSample, result));
        _ddrawSample = NULL;
    }

    // NOTE: we are NOT _deleteable!
    _initialized = false;  // this to keep us safe if attempted to use
} // end mutex scope


void
QuartzVideoStream::CleanUp()
{
    QuartzVideoReader::CleanUp();
    QuartzMediaStream::CleanUp();

    if(_ddraw) {
        int result = _ddraw->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAW %d released (%d)", _ddraw, result));
        _ddraw = NULL;
    }
}


void QuartzVideoReader::UpdateTimes(bool bJustSeeked, STREAM_TIME SeekTime)
{
    if(_hrCompStatus != S_OK && _hrCompStatus != MS_S_NOUPDATE) {
        _curSampleEnd = -1;    // BUGBUG -- What the heck am I thinking?
    } else {
        STREAM_TIME NewStartTime, NewEndTime;
        _ddrawSample->GetSampleTimes(&NewStartTime, &NewEndTime, 0);
        if (NewStartTime > SeekTime) {
            if (bJustSeeked) {
                NewStartTime = SeekTime;
            } else {
                if (NewStartTime > _curSampleEnd+1)
                    NewStartTime = _curSampleEnd+1;
            }
        }
        _curSampleStart = NewStartTime;
        _curSampleEnd   = NewEndTime;
        _curSampleValid = true;
    }
}


// XXX convert to PCM?
#define STREAM_TIME_TO_SECONDS(x) ((x) * 0.0000001)
#define SECONDS_TO_STREAM_TIME(x) ((x) * 10000000.0)


HRESULT 
QuartzVideoReader::GetFrame(double time, IDirectDrawSurface **ppSurface)
{
    if(!_initialized)
        VideoInitReader(GetCurrentViewport()->GetTargetPixelFormat());

    *ppSurface = NULL;

    STREAM_TIME SeekTime = SECONDS_TO_STREAM_TIME(time);

    // XXX I think this terminates previous pending renders...
    if(_async) {
        _hrCompStatus = _ddrawSample->CompletionStatus(COMPSTAT_NOUPDATEOK |
                                                     COMPSTAT_WAIT, INFINITE);
        UpdateTimes(false, SeekTime);
    }

    if(_async) {  // we are asynchronous (the hard way, no seeking!)
        if(!_curSampleValid || (_curSampleEnd < SeekTime)) {
            // determine what time AMstream thinks it is
            STREAM_TIME amstreamTime;
            HRESULT hr = _multiMediaStream->GetTime(&amstreamTime);
            STREAM_TIME delta = SeekTime - amstreamTime;

            TraceTag((tagAVmodeDebug, "GetFrame time %g", time));

#if DEBUG_ONLY_CODE
            char string[100];
#include <mmsystem.h>
            sprintf(string, "GetFrame time: d:%f==(%10d-%10d) %10d", 
                (double)(delta/10000.0), SeekTime, amstreamTime,
                 timeGetTime());
            TraceTag((tagAVmodeDebug, string));
#endif

            // tell AMstream what time we think it is
            if(_clockAdjust) // might be unavailable on old amstreams...
                _clockAdjust->SetClockDelta(delta); // cause them to sync up

            // AV clocked mode...
            _hrCompStatus = _ddrawSample->Update(SSUPDATE_ASYNC, NULL, NULL, 0);

            // if we wait 0 we can determine if the data was available
            // XXX err, no, can't wait 0, lets wait a reasonable worst case time
            // Well what we really want is for amstream to tell us if they 
            // have the data to decode, then we will wait, or if they don't
            // have the data we will use the cached image
            // XXX I should colour the cached image in debug mode!
            _hrCompStatus = _ddrawSample->CompletionStatus(COMPSTAT_WAIT, 300);

            switch(_hrCompStatus) {
                case 0: break;      // all is well

                case MS_S_PENDING: 
                case MS_S_NOUPDATE: 
                    TraceTag((tagAVmodeDebug, 
                        "QuartzAudioReader Completion Status:%s",
                        (hr==MS_S_PENDING)?"PENDING":"NOUPDATE"));
                    // Stop the pending operation
                    hr = _ddrawSample->CompletionStatus(
                             COMPSTAT_WAIT|COMPSTAT_ABORT, INFINITE); 

                    // video can still stall on audio...
                    SetStall(); // inform the reader that we stalled
                    TraceTag((tagAVmodeDebug, 
                        "QuartzVideoReader::GetFrame() STALLED"));
                break;

                case MS_S_ENDOFSTREAM: 
                    // _completed = true;
                break;

                default:
                    Assert(0);      // we don't anticipate this case!
                break;
            }

            UpdateTimes(false, SeekTime);
        }
    } 
    else { // !_asynch
        // XXX need some code to decide what to do if !_seekable...
        for(int count = 0; count < 10; count++) {
            // is the requested time within the current sample?
            if( _curSampleValid              &&
               (_curSampleStart <= SeekTime) &&
               ((_curSampleEnd >= SeekTime)||
               (_hrCompStatus == MS_S_ENDOFSTREAM)
               )) {
                TraceTag((tagAVmodeDebug, "GetFrame within existing frame"));
                break;
            }

            // are we beyond where we want to be?
            bool bJustSeeked = false;
            if( (!_curSampleValid) || (_hrCompStatus == MS_S_ENDOFSTREAM) ||
               (_curSampleStart > SeekTime) ||
               ((_curSampleEnd + (SECONDS_TO_STREAM_TIME(1)/4)) < SeekTime)){
                _hrCompStatus = _multiMediaStream->Seek(SeekTime);
                TraceTag((tagAVmodeDebug, "GetFrame seeking %d", SeekTime));

                if(FAILED(_hrCompStatus))
                    break;
                bJustSeeked = true;
            }
            _hrCompStatus = _ddrawSample->Update(0, NULL, NULL, 0);
            TraceTag((tagAVmodeDebug, "GetFrame updated %d", SeekTime));
            UpdateTimes(bJustSeeked, SeekTime);

            if(bJustSeeked)
                break;
        }

#if _DEBUG
    { // draw on the movie if we are not asynch
        HDC hdcSurface;
        // RECT rectangle = {1, 1, 10, 10};

        if(SUCCEEDED(_ddrawSurface->GetDC(&hdcSurface))) {
            //DrawRect(dc, &rectangle, 255, 0, 255, 0, 0, 0);
            TextOut(hdcSurface, 20, 20, "Synchronous seek mode", 19);
            _ddrawSurface->ReleaseDC(hdcSurface); // ALWAYS to bypass NT4.0 DDraw bug
        }

    }
#endif

    }

    if(SUCCEEDED(_hrCompStatus))
        *ppSurface = _ddrawSurface;

    return((_hrCompStatus == MS_S_NOUPDATE) ? S_OK : _hrCompStatus);
}


QuartzAudioReader::QuartzAudioReader(char *url, StreamType streamType) : 
    QuartzReader(url, streamType), 
    _audioStream(NULL), _audioSample(NULL), _audioData(NULL), _completed(false)
{
}


void
QuartzAudioReader::CleanUp()
{ // mutex scope
    MutexGrabber mg(_readerMutex, TRUE); // Grab mutex

    if(_audioData)   {
        int result = _audioData->Release();
        TraceTag((tagAMStreamLeak, "leak AUDIODATA %d released (%d)", 
            _audioData, result));
        _audioData = NULL;
    }

    if(_audioSample) {
        // Stop any pending operation
        HRESULT hr = _audioSample->CompletionStatus(
                 COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE); 
        int result = _audioSample->Release();
        TraceTag((tagAMStreamLeak, "leak AUDIOSAMPLE %d released (%d)", 
            _audioSample, result));
        _audioSample = NULL;
    }

    if(_audioStream) {
        int result =_audioStream->Release();
        TraceTag((tagAMStreamLeak, "leak AUDIOSTREAM %d released (%d)", 
            _audioStream, result));
        _audioStream = NULL;
    }

    _initialized = false;
    _deleteable  = true;

} // end mutex scope


void
QuartzAudioReader::Disable()
{ // mutex scope
    MutexGrabber mg(_readerMutex, TRUE); // Grab mutex

    // release the sample so that video may continue
    if(_audioSample) {
        // Stop any pending operation
        HRESULT hr = _audioSample->CompletionStatus(
                 COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE); 
        int result =_audioSample->Release();
        TraceTag((tagAMStreamLeak, "leak AUDIOSAMPLE %d released (%d)", 
            _audioSample, result));
        _audioSample = NULL;
    }

    _initialized = false;
    // NOTE: We are NOT deleteable.  We may still be held by a bufferElement!
} // end mutex scope


QuartzReader::QuartzReader(char *url, StreamType streamType) : 
    _streamType(streamType), _multiMediaStream(NULL), 
    _mediaStream(NULL), _deleteable(true), _initialized(false),
    _secondsRead(0.0), _stall(false), _clockAdjust(NULL), 
    _url(NULL), _qURL(NULL), _nextFrame(0)
{
    _url = CopyString(url);

    int numChars = strlen(url) + 1;
    _qURL = NEW WCHAR[numChars];
    MultiByteToWideChar(CP_ACP, 0, url, -1, _qURL, numChars);
}


double
QuartzReader::GetDuration()
{
    STREAM_TIME qTime;
    HRESULT hr;
    double seconds;

    Assert(_multiMediaStream);

    // Not all files will give us valid duration!
    if(FAILED(hr = _multiMediaStream->GetDuration(&qTime)))
        RaiseException_InternalError("Failed to GetDuration\n");
    // else if(hr==VFW_S_ESTIMATED) // some durations are estimated!

    if(hr != 1)
        seconds = pcm.QuartzTimeToSeconds(qTime);
    else
        seconds = HUGE_VAL;  // XXX what else can we do, say its unknown?

    return(seconds);
}

bool
QuartzAudioReader::AudioInitReader(IAMMultiMediaStream *multiMediaStream,
    IAMClockAdjust *clockAdjust)
{
    HRESULT hr;
    WAVEFORMATEX waveFormat;
    bool status = true;

    _deleteable  = false; // set this first

    _multiMediaStream = multiMediaStream;  // we don't only, are only sharing
    _clockAdjust      = clockAdjust;

    if(FAILED(hr = 
        _multiMediaStream->GetMediaStream(MSPID_PrimaryAudio, &_mediaStream)))
        RaiseException_InternalError("Failed to GetMediaStream\n");
    TraceTag((tagAMStreamLeak, "leak MEDIASTREAM %d create", _mediaStream));

    if(FAILED(hr = _mediaStream->QueryInterface(IID_IAudioMediaStream,
                                                (void**)&_audioStream)))
        RaiseException_InternalError("Failed to GetMediaStream\n");
    TraceTag((tagAMStreamLeak, "leak AUDIOSTREAM %d created", _audioStream));

    if(FAILED(hr = _audioStream->GetFormat(&waveFormat)))
        status = false;
    else {
        pcm.SetPCMformat(waveFormat);        // configure our PCM info
        pcm.SetNumberSeconds(GetDuration()); // length, too!

        if(FAILED(hr = CoCreateInstance(CLSID_AMAudioData, NULL, 
            CLSCTX_INPROC_SERVER, IID_IAudioData, (void **)&_audioData)))
            RaiseException_InternalError("Failed CoCreateInstance CLSID_AMAudioData\n");
        TraceTag((tagAMStreamLeak, "leak AUDIODATA %d created", _audioData));

        if(FAILED(hr = _audioData->SetFormat(&waveFormat)))
            RaiseException_InternalError("Failed to SetFormat\n");

        #ifdef USE_QUARTZ_EVENTS
        _event = CreateEvent(FALSE, NULL, NULL, FALSE);
        #endif USE_QUARTZ_EVENTS

        if(FAILED(hr = _audioStream->CreateSample(_audioData, 0, &_audioSample)))
            RaiseException_InternalError("Failed to CreateSample\n");
        TraceTag((tagAMStreamLeak, "leak AUDIOSAMPLE %d created", _audioSample));

        _initialized = true; // set this last
    }

    return(status);
}


// open an amstream shared for audio and video!
QuartzAVstream::QuartzAVstream(char *url) :
    AVquartzVideoReader(url, AVSTREAM), 
    AVquartzAudioReader(url, AVSTREAM), QuartzMediaStream(),
    _tickID(0), _seeked(0), _audioValid(true), _videoValid(true)
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex
    HRESULT       hr;
    char          string[200];
    IDirectDraw  *ddraw = NULL;

    GetDirectDraw(&ddraw, NULL, NULL);

    Assert(QuartzMediaStream::_multiMediaStream);  // should be setup by base class initializer


    DWORD flags = AMMSF_STOPIFNOSAMPLES;
#ifdef USE_AMMSF_NOSTALL
    flags |= AMMSF_NOSTALL;
#endif
    // seems that we need to add video before audio for amstream to work!
    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->AddMediaStream(ddraw,
                 &MSPID_PrimaryVideo, flags, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to AddMediaStream amStream\n");
    }

    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->AddMediaStream(NULL, 
                 &MSPID_PrimaryAudio, AMMSF_STOPIFNOSAMPLES, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to AddMediaStream amStream\n");
    }

    // open it in clocked mode
    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->OpenFile(
        AVquartzAudioReader::GetQURL(), NULL))) {
        TraceTag((tagError, "Quartz Failed to OpenFile <%s> %hr", url, hr));
        CleanUp();
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE, url);
    }

    if(!AudioInitReader(QuartzMediaStream::_multiMediaStream,
        QuartzMediaStream::_clockAdjust))
        _audioValid = false; // indicate audio steam not present
    if(!VideoSetupReader(QuartzMediaStream::_multiMediaStream, 
        QuartzMediaStream::_clockAdjust, NULL, false)) { // no seek, unknown surf
        _videoValid = false; // indicate video stream isn't there
    }

} // end mutex scope

bool
QuartzAVstream::AlreadySeekedInSameTick()
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex

    bool result;
    
    if ((_seeked==0) || (_seeked != _tickID)) {
        _seeked = _tickID;
        result = false;
    } else {
        // multiple seek case, ignore
        result = true;
    }

    return result;
}

void
QuartzAVstream::SetTickID(DWORD id)
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex

    _tickID = id;
}

void
QuartzAVstream::Release()
{
    bool terminate = false;

    { // mutex scope
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex

    // determine if both audio and video are gone so we can destroy the object
    bool audioDeleteable = QuartzAudioReader::IsDeleteable();
    bool videoDeleteable = QuartzVideoReader::IsDeleteable();

    if(audioDeleteable && videoDeleteable)
       terminate = true;
    } // end mutex scope

    if(terminate) {
        TraceTag((tagAVmodeDebug, 
            "QuartzAVstream: Audio and Video Released; GOODBYE!"));
        QuartzAVstream::CleanUp(); // wash up
        delete this;               // then say GoodBye!
    }
}


void
QuartzAudioStream::Release()
{
    QuartzAudioStream::CleanUp(); // wash up
    delete this;                  // then say GoodBye!
}


void
QuartzVideoStream::Release()
{
    QuartzVideoStream::CleanUp(); // wash up
    delete this;                  // then say GoodBye!
}


void
QuartzReader::Release()
{
}


void
QuartzVideoReader::Release()
{
    QuartzVideoReader::CleanUp();
}


void
QuartzAudioReader::Release()
{
    QuartzAudioReader::CleanUp();
}


// open an amstream exclusively for audio!
QuartzAudioStream::QuartzAudioStream(char *url) : 
    QuartzAudioReader(url, ASTREAM), QuartzMediaStream()
{
    HRESULT hr;
    char string[200];

    Assert(QuartzMediaStream::_multiMediaStream);  // should be setup by base class initializer

    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->AddMediaStream(NULL, 
                                                     &MSPID_PrimaryAudio, 
                                                     0, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to AddMediaStream amStream\n");
        }

    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->OpenFile(GetQURL(), 
                                        AMMSF_RUN | AMMSF_NOCLOCK))) {
        TraceTag((tagError, "Quartz Failed to OpenFile <%s> %hr\n", url, hr));
        CleanUp();
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE, url);
    }

    if(!AudioInitReader(QuartzMediaStream::_multiMediaStream,
        QuartzMediaStream::_clockAdjust)) {
        TraceTag((tagError, 
            "QuartzAudioStream: Audio stream failed to init"));
        CleanUp();
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE, url);
    }
}


void
QuartzAudioStream::CleanUp()
{
    QuartzAudioReader::CleanUp();
    QuartzMediaStream::CleanUp();
}


void
QuartzAVstream::CleanUp()
{
    QuartzAudioReader::CleanUp();
    QuartzVideoReader::CleanUp();
    QuartzMediaStream::CleanUp();
}


QuartzAudioStream::~QuartzAudioStream()
{
    CleanUp();
}


int
QuartzAudioStream::ReadFrames(int numSamples, unsigned char *buffer, 
    bool blocking_is_ignored)
{
    // NOTE: we are forcing blocking to true ignoring the blocking parameter!
    return(QuartzAudioReader::ReadFrames(numSamples, buffer, true));
}


void
QuartzAudioReader::SeekFrames(long frames)
{
    if (!AlreadySeekedInSameTick()) {
        LONGLONG quartzTime = pcm.FramesToQuartzTime(frames);

        _multiMediaStream->Seek(quartzTime);
        _nextFrame = frames + 1;
    }
}


int
QuartzAudioReader::ReadFrames(int samplesRequested, unsigned char *buffer,
    bool blocking)
{
    HRESULT hr, hr2;
    DWORD bytesRead;
    int framesRead = 0;
    long bytesRequested;

    Assert(_audioData); 
    Assert(_audioStream);
    Assert(_initialized);

    if(bytesRequested = pcm.FramesToBytes(samplesRequested)) {
        // setup a new audioSample each time to change ptr, size
        if(FAILED(hr = _audioData->SetBuffer(bytesRequested, buffer, 0)))
            RaiseException_InternalError("Failed to init\n");

        DWORD flags = blocking ? 0 : SSUPDATE_ASYNC;
        if(FAILED(hr = _audioSample->Update(flags, NULL, NULL, 0))) {
            if(hr != MS_E_BUSY) 
                RaiseException_InternalError("Failed to update\n");
        }

        // block for completion!
        //HANDLE         _event;
        //hr = WaitForSingleObject(_event, 500);  // for testing

        // XXX tune timeout!!
        hr = _audioSample->CompletionStatus(COMPSTAT_WAIT, 300); 
        // XXX maybe we should stop the pending update if we time out?
        switch(hr) {
            case 0: break;      // all is well

            case MS_S_PENDING: 
            case MS_S_NOUPDATE: 
                TraceTag((tagAVmodeDebug, 
                    "QuartzAudioReader Completion Status:%s",
                    (hr==MS_S_PENDING)?"PENDING":"NOUPDATE"));
                // Stop the pending operation
                hr = _audioSample->CompletionStatus(
                         COMPSTAT_WAIT|COMPSTAT_ABORT, INFINITE); 
                SetStall(); // inform the reader that we stalled
                TraceTag((tagAVmodeDebug, 
                    "QuartzAudioReader::ReadFrames() STALLED"));
            break;

            case MS_S_ENDOFSTREAM: 
                _completed = true; break;

            default:
                Assert(0);      // we don't anticipate this case!
            break;
        }

        _audioData->GetInfo(NULL, NULL, &bytesRead);
        framesRead = pcm.BytesToFrames(bytesRead);
        _nextFrame+= framesRead;
    }
    
    return(framesRead);
}


/**********************************************************************
Pan is not setup to be multiplicative as of now.  It directly maps to 
log units (dB).  This is OK since pan is not exposed.  We mainly use it
to assign sounds to channels within the implementation.

Pan ranges from -10000 to 10000, where -10000 is left, 10000 is right.
dsound actualy doesn't implement a true pan, more of a 'balance control'
is provided.  A true pan would equalize the total energy of the system
between the two channels as the pan==center of energy moves. Therefore
a value of zero gives both channels full on.
**********************************************************************/
int QuartzRenderer::dBToQuartzdB(double dB)
{
    // The units for DSound (and DShow) are 1/100 ths of a decibel. 
    return (int)fsaturate(-10000.0, 10000.0, dB * 100.0);
}


bool QuartzAVmodeSupport()
{
    // XXX Hmm.  How am I going to check for a current AMStream?
    // guess I can try QIing for clockAdjust...

    static int result = -1;  // default to not initialized

    if(result == -1) {
        HRESULT hr;
        IAMMultiMediaStream *multiMediaStream = NULL;
        IAMClockAdjust      *clockAdjust      = NULL;
        result = 1; // be optimistic

        // do the check
        if(FAILED(hr = CoCreateInstance(CLSID_AMMultiMediaStream, NULL, 
                         CLSCTX_INPROC_SERVER, IID_IAMMultiMediaStream, 
                         (void **)&multiMediaStream)))
            result = 0;
        TraceTag((tagAMStreamLeak, "leak MULTIMEDIASTREAM %d created", multiMediaStream));

        if(result) {
            if(FAILED(hr = multiMediaStream->QueryInterface(IID_IAMClockAdjust, 
                                            (void **)&clockAdjust))) 
                result = 0;
            TraceTag((tagAMStreamLeak, "leak CLOCKADJUST %d created", clockAdjust));
        }

        if(clockAdjust) {
            int result = clockAdjust->Release();
            TraceTag((tagAMStreamLeak, "leak CLOCKADJUST %d released (%d)", 
                clockAdjust, result));
        }

        if(multiMediaStream) {
            int result = multiMediaStream->Release();
            TraceTag((tagAMStreamLeak, "leak MULTIMEDIASTREAM %d released (%d)", 
                multiMediaStream, result));
        }
    }

    return(result==1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\loadgif.cpp ===
#include "headers.h"

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <privinc/debug.h>
#include <privinc/ddutil.h>

/*-- 
Structs from IE img.hxx 
--*/

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};

typedef struct _GCEDATA // data from GIF Graphic control extension
{
    unsigned int uiDelayTime;           // frame duration, initialy 1/100ths seconds
                                    // converted to milliseconds
    unsigned int uiDisposalMethod;      // 0 - none specified.
                                    // 1 - do not dispose - leave bits in place.
                                    // 2 - replace with background color.
                                    // 3 - restore previous bits
                                    // >3 - not yet defined
    BOOL                  fTransparent;         // TRUE is ucTransIndex describes transparent color
    unsigned char ucTransIndex;         // transparent index

} GCEDATA; 

typedef struct _GIFFRAME
{
    struct _GIFFRAME    *pgfNext;
    GCEDATA                             gced;           // animation parameters for frame.
    int                                 top;            // bounds relative to the GIF logical screen 
    int                                 left;
    int                                 width;
    int                                 height;
    unsigned char               *ppixels;       // pointer to image pixel data
    int                                 cColors;        // number of entries in pcolors
    PALETTEENTRY                *pcolors;
    PBITMAPINFO                 pbmi;
    HRGN                                hrgnVis;                // region describing currently visible portion of the frame
    int                                 iRgnKind;               // region type for hrgnVis
} GIFFRAME, *PGIFFRAME;

typedef struct {
    BOOL        fAnimating;                 // TRUE if animation is (still) running
    DWORD       dwLoopIter;                 // current iteration of looped animation, not actually used for Netscape compliance reasons
    _GIFFRAME * pgfDraw;                    // last frame we need to draw
    DWORD       dwNextTimeMS;               // Time to display pgfDraw->pgfNext, or next iteration
} GIFANIMATIONSTATE, *PGIFANIMATIONSTATE;

#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a        ((DWORD)89)  // GIF89a file format.

typedef struct _GIFANIMDATA
{
    BOOL                        fAnimated;                      // TRUE if cFrames and pgf define a GIF animation
    BOOL                        fLooped;                        // TRUE if we've seen a Netscape loop block
    BOOL                        fHasTransparency;       // TRUE if a frame is transparent, or if a frame does
                                        // not cover the entire logical screen.
    BOOL            fNoBWMapping;       // TRUE if we saw more than two colors in anywhere in the file.
    DWORD           dwGIFVer;           // GIF Version <see defines above> we need to special case 87a backgrounds
    unsigned short      cLoops;                         // A la Netscape, we will treat this as 
                                        // "loop forever" if it is zero.
    PGIFFRAME           pgf;                            // animation frame entries
    PALETTEENTRY        *pcolorsGlobal;         // GIF global colors - NULL after GIF prepared for screen
    PGIFFRAME       pgfLastProg;        // remember the last frame to be drawn during decoding
    DWORD           dwLastProgTimeMS;   // time at which pgfLastProg was displayed.

} GIFANIMDATA, *PGIFANIMDATA;

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long BitPixel;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct _GIFINFO
{
    IStream *stream;
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif();
      ~CImgGif();

      unsigned char * ReadGIFMaster();
      BOOL Read(unsigned char *buffer, long len);
      long ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE]);
      long DoExtension(long label);
      long GetDataBlock(unsigned char *buf);
      unsigned char * ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame);
      long readLWZ();
      long nextLWZ();
      long nextCode(long code_size);
      BOOL initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL growTables();
      BITMAPINFO * FinishDithering();

   // Data members
   public:
      LPCSTR              _szFileName;
      BOOL                _fInterleaved;
      BOOL                _fInvalidateAll;
      int                 _yLogRow;
      GIFINFO             _gifinfo;
      GIFANIMATIONSTATE   _gas;
      GIFANIMDATA         _gad;
      PALETTEENTRY        _ape[256];
      int                 _xWidth;
      int                 _yHeight;
      LONG                _lTrans;
      BYTE *              _pbBits;

} GIFIMAGE;


CImgGif::CImgGif() {
   _gifinfo.pstack = NULL;
   _gifinfo.table[0] = NULL;
   _gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() {
   free(_gifinfo.pstack);
   free(_gifinfo.table[0]);
   free(_gifinfo.table[1]);
   PGIFFRAME nextPgf, curPgf;
   curPgf = _gad.pgf;
   while(curPgf != NULL) {
      nextPgf = curPgf->pgfNext;
      free(curPgf->ppixels);
      free(curPgf->pcolors);
      free(curPgf->pbmi);
      free(curPgf);
      curPgf = nextPgf;
   }
}

static int GetColorMode() { return 0; };

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, long len)
{
   DWORD lenout;
   /* read len characters into buffer */
   _gifinfo.stream->Read(buffer,len,&lenout);

   return (lenout == len);
}

long CImgGif::ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE])
{
        long i;
        unsigned char rgb[3];

        for (i = 0; i < number; ++i)
        {
                if (!Read(rgb, sizeof(rgb)))
                {
                        TraceTag((tagImageDecode, "bad gif colormap."));
                        RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                        //return (TRUE);
                }
                buffer[CM_RED][i] = rgb[0];
                buffer[CM_GREEN][i] = rgb[1];
                buffer[CM_BLUE][i] = rgb[2];
        }
        return FALSE;
}

long
CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
          return -1;
   }
   _gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
          return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2

BOOL CImgGif::initLWZ(long input_code_size)
{
   if(input_code_size < MINIMUM_CODE_SIZE)
     return FALSE;

   _gifinfo.set_code_size = input_code_size;
   _gifinfo.code_size = _gifinfo.set_code_size + 1;
   _gifinfo.clear_code = 1 << _gifinfo.set_code_size;
   _gifinfo.end_code = _gifinfo.clear_code + 1;
   _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
   _gifinfo.max_code = _gifinfo.clear_code + 2;

   _gifinfo.curbit = _gifinfo.lastbit = 0;
   _gifinfo.last_byte = 2;
   _gifinfo.get_done = FALSE;

   _gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        _gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        _gifinfo.stacksize = MIN_STACK_SIZE;

        if ( _gifinfo.pstack != NULL )
                free( _gifinfo.pstack );
        if ( _gifinfo.table[0] != NULL  )
                free( _gifinfo.table[0] );
        if ( _gifinfo.table[1] != NULL  )
                free( _gifinfo.table[1] );

 
    _gifinfo.table[0] = 0;
    _gifinfo.table[1] = 0;
    _gifinfo.pstack = 0;

    _gifinfo.pstack = (unsigned short *) malloc((_gifinfo.stacksize)*sizeof(unsigned short));
    if(_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    _gifinfo.sp = _gifinfo.pstack;

    // Initialize the two tables.
    _gifinfo.tablesize = (_gifinfo.max_code_size);

    _gifinfo.table[0] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    _gifinfo.table[1] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    if((_gifinfo.table[0] == 0) || (_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(_gifinfo.pstack){
        free(_gifinfo.pstack);
        _gifinfo.pstack = 0;
    }

    if(_gifinfo.table[0]){
        free(_gifinfo.table[0]);
        _gifinfo.table[0] = 0;
    }

    if(_gifinfo.table[1]){
        free(_gifinfo.table[1]);
        _gifinfo.table[1] = 0;
    }

    return FALSE;
}

long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &_gifinfo.buf[0];

   if (_gifinfo.return_clear)
   {
          _gifinfo.return_clear = FALSE;
          return _gifinfo.clear_code;
   }

   end = _gifinfo.curbit + code_size;

   if (end >= _gifinfo.lastbit)
   {
          long count;

          if (_gifinfo.get_done)
          {
                  return -1;
          }
          buf[0] = buf[_gifinfo.last_byte - 2];
          buf[1] = buf[_gifinfo.last_byte - 1];

          if ((count = GetDataBlock(&buf[2])) == 0)
                  _gifinfo.get_done = TRUE;
          if (count < 0)
          {
                  return -1;
          }
          _gifinfo.last_byte = 2 + count;
          _gifinfo.curbit = (_gifinfo.curbit - _gifinfo.lastbit) + 16;
          _gifinfo.lastbit = (2 + count) * 8;

          end = _gifinfo.curbit + code_size;

   // Okay, bug 30784 time. It's possible that we only got 1
   // measly byte in the last data block. Rare, but it does happen.
   // In that case, the additional byte may still not supply us with
   // enough bits for the next code, so, as Mars Needs Women, IE
   // Needs Data.
   if ( end >= _gifinfo.lastbit && !_gifinfo.get_done )
   {
      // protect ourselve from the ( theoretically impossible )
      // case where between the last data block, the 2 bytes from
      // the block preceding that, and the potential 0xFF bytes in
      // the next block, we overflow the buffer.
      // Since count should always be 1,
      Assert ( count == 1 );
      // there should be enough room in the buffer, so long as someone
      // doesn't shrink it.
      if ( count + 0x101 >= sizeof( _gifinfo.buf ) )
      {
          Assert ( FALSE ); // 
          return -1;
      }

              if ((count = GetDataBlock(&buf[2 + count])) == 0)
                      _gifinfo.get_done = TRUE;
              if (count < 0)
              {
                      return -1;
              }
              _gifinfo.last_byte += count;
              _gifinfo.lastbit = _gifinfo.last_byte * 8;

              end = _gifinfo.curbit + code_size;
   }
   }

   j = end / 8;
   i = _gifinfo.curbit / 8;

   if (i == j)
          ret = buf[i];
   else if (i + 1 == j)
          ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
          ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (_gifinfo.curbit % 8)) & maskTbl[code_size];

   _gifinfo.curbit += code_size;

        return ret;
}

// Grows the stack and returns the top of the stack.
unsigned short *
CImgGif::growStack()
{
    long index;
    unsigned short *lp;
    
        if (_gifinfo.stacksize >= MAX_STACK_SIZE) return 0;

    index = (_gifinfo.sp - _gifinfo.pstack);
    lp = (unsigned short *)realloc(_gifinfo.pstack, (_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(lp == 0)
        return 0;
        
    _gifinfo.pstack = lp;
    _gifinfo.sp = &(_gifinfo.pstack[index]);
    _gifinfo.stacksize = (_gifinfo.stacksize)*2;
    lp = &(_gifinfo.pstack[_gifinfo.stacksize]);
    return lp;
}

BOOL
CImgGif::growTables()
{
    unsigned short *lp;

    lp = (unsigned short *) realloc(_gifinfo.table[0], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[0] = lp;
    
    lp = (unsigned short *) realloc(_gifinfo.table[1], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[1] = lp;

    return TRUE;

}

inline
long CImgGif::readLWZ()
{
   return((_gifinfo.sp > _gifinfo.pstack) ? *--(_gifinfo.sp) : nextLWZ());
}

#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
        long code, incode;
        unsigned short usi;
        unsigned short *table0 = _gifinfo.table[0];
        unsigned short *table1 = _gifinfo.table[1];
        unsigned short *pstacktop = &(_gifinfo.pstack[_gifinfo.stacksize]);

        while ((code = nextCode(_gifinfo.code_size)) >= 0)
        {
                if (code == _gifinfo.clear_code)
                {
                        /* corrupt GIFs can make this happen */
                        if (_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
                        {
                                return -2;
                        }

                
                        _gifinfo.code_size = _gifinfo.set_code_size + 1;
                        _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
                        _gifinfo.max_code = _gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                        
            table0 = _gifinfo.table[0];
            table1 = _gifinfo.table[1];

                        _gifinfo.tablesize = _gifinfo.max_code_size;


                        for (usi = 0; usi < _gifinfo.clear_code; ++usi)
                        {
                                table1[usi] = usi;
                        }
                        memset(table0,0,sizeof(unsigned short )*(_gifinfo.tablesize));
                        memset(&table1[_gifinfo.clear_code],0,sizeof(unsigned short)*((_gifinfo.tablesize)-_gifinfo.clear_code));
                        _gifinfo.sp = _gifinfo.pstack;
                        do
                        {
                                _gifinfo.firstcode = _gifinfo.oldcode = nextCode(_gifinfo.code_size);
                        }
                        while (_gifinfo.firstcode == _gifinfo.clear_code);

                        return _gifinfo.firstcode;
                }
                if (code == _gifinfo.end_code)
                {
                        long count;
                        unsigned char buf[260];

                        if (_gifinfo.ZeroDataBlock)
                        {
                                return -2;
                        }

                        while ((count = GetDataBlock(buf)) > 0)
                                ;

                        if (count != 0)
                        return -2;
                }

                incode = code;

                if (code >= _gifinfo.max_code)
                {
            if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (_gifinfo.firstcode));
                        code = _gifinfo.oldcode;
                }

#if FEATURE_FAST
                // BUGBUG (andyp) easy speedup here for ie3.1 (too late for ie3.0):
                //
                // 1. move growStack code out of loop (use max 12-bit/4k slop).
                // 2. do "sp = _gifinfo.sp" so it will get enreg'ed.
                // 3. un-inline growStack (and growTables).
                // 4. change short's to int's (benefits win32) (esp. table1 & table2)
                // (n.b. int not long, so we'll keep win3.1 perf)
                // 5. change long's to int's (benefits win16) (esp. code).
                //
                // together these will make the loop very tight w/ everything kept
                // enregistered and no 66 overrides.
                //
                // one caveat is that on average this loop iterates 4x so it's
                // not clear how much the speedup will really gain us until we
                // look at the outer loop as well.
#endif
                while (code >= _gifinfo.clear_code)
                {
                        if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = table1[code];
                        if (code == (long)(table0[code]))
                        {
                                return (code);
                        }
                        code = (long)(table0[code]);
                }

        if (_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }
                _gifinfo.firstcode = (long)table1[code];
        *(_gifinfo.sp)++ = table1[code];

                if ((code = _gifinfo.max_code) < (1 << MAX_LWZ_BITS))
                {
                        table0[code] = (_gifinfo.oldcode) & CODE_MASK;
                        table1[code] = (_gifinfo.firstcode) & CODE_MASK;
                        ++_gifinfo.max_code;
                        if ((_gifinfo.max_code >= _gifinfo.max_code_size) && (_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
                        {
                                _gifinfo.max_code_size *= 2;
                                ++_gifinfo.code_size;
                                if(!growTables())
                                    return -2;
       
                table0 = _gifinfo.table[0];
                table1 = _gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                memset(&(table1[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                _gifinfo.tablesize = (_gifinfo.max_code_size);


                        }
                }

                _gifinfo.oldcode = incode;

                if (_gifinfo.sp > _gifinfo.pstack)
                        return ((long)(*--(_gifinfo.sp)));
        }
        return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

unsigned char *
CImgGif::ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame)
{
    unsigned char *dp, c;
    long v;
    long xpos = 0, ypos = 0, pass = 0;
    unsigned char *image;
    long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks ( up to terminator ) into
    //ULONG ulCoversImg = IMGBITS_PARTIAL;

    /*
       **  Initialize the Compression routines
     */
    if (!Read(&c, 1))
    {
        return (NULL);
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
     */

     cbImage = padlen * height * sizeof(char);

     if (   cbImage > dwMaxGIFBits
        ||  (image = (unsigned char *) calloc(1, cbImage)) == NULL)
    {
         TraceTag((tagImageDecode, "Cannot allocate space for gif image data\n"));
         RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
        //return (NULL);
    }

        if (c == 1)
        {
                // Netscape seems to field these bogus GIFs by filling treating them
                // as transparent. While not the optimal way to simulate this effect,
                // we'll fake it by pushing the initial code size up to a safe value,
                // consuming the input, and returning a buffer full of the transparent
                // color or zero, if no transparency is indicated.
                if (initLWZ(MINIMUM_CODE_SIZE))
                        while (readLWZ() >= 0);
                else {
          TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
          RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
        }

                if (_gifinfo.Gif89.transparent != -1)
                        FillMemory(image, cbImage, _gifinfo.Gif89.transparent);
                else // fall back on the background color 
                        FillMemory(image, cbImage, 0);
                
                return image;
        }
        else if (initLWZ(c) == FALSE)
        {
                free(image);
        TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
        return NULL;
        }

    if (!fGIFFrame)
        _pbBits = image;

    if (fInterlace)
    {
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            _fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
//              message("readimage, logical=%d, offset=%d\n", i, padlen * ((height-1) - ypos));
            dp = &image[padlen * ((height-1) - ypos)];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
                /*if (!fGIFFrame && pass == 1)
                {
                    ulCoversImg = IMGBITS_TOTAL;
                }*/
            }
            if (!fGIFFrame)
            {
                _yLogRow = i;

                /*if ((i & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/

        if (!fGIFFrame && height <= 4)
        {
            _yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            _yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &image[padlen * ypos];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            if (!fGIFFrame)
            {
                _yLogRow++;
//                  message("readimage, logical=%d, offset=%d\n", _yLogRow, padlen * ypos);
                /*if ((_yLogRow & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/
    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0)
                                ;
    return (image);

abort:
    /*if (!fGIFFrame)
        OnProg(TRUE, ulCoversImg);*/
    return NULL;
}

long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                    if ( count >= 3 )
                    {
                        _gad.fLooped = TRUE;
                        _gad.cLoops = (buf[2] << 8) | buf[1];
                    }
                }
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                TraceTag((tagImageDecode, "GIF comment: %s\n", buf));                
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                _gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                _gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                _gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0)
                    _gifinfo.Gif89.transparent = buf[3];
                else
                    _gifinfo.Gif89.transparent = -1;
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
        default:
            break;
    }

    while (GetDataBlock((unsigned char *) buf) > 0)
        ;

    return FALSE;
}

BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}


PBITMAPINFO x_8BPIBitmap(int xsize, int ysize)
{
        PBITMAPINFO pbmi;

        if (GetColorMode() == 8)
        {
                pbmi = (PBITMAPINFO) calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(WORD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        else
        {
                pbmi = (PBITMAPINFO) calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        return pbmi;
}

/*
    For color images.
        This routine should only be used when drawing to an 8 bit palette screen.
        It always creates a DIB in DIB_PAL_COLORS format.
*/
PBITMAPINFO BIT_Make_DIB_PAL_Header(int xsize, int ysize)
{
        int i;
        PBITMAPINFO pbmi;
        WORD *pw;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        pw = (WORD *) pbmi->bmiColors;

        for (i = 0; i < 256; i++)
        {
                pw[i] = (WORD)i;
        }

        return pbmi;
}

/*
    For color images.
        This routine is used when drawing to the nonpalette screens.  It always creates
        DIBs in DIB_RGB_COLORS format.
        If there is a transparent color, it is modified in the palette to be the
        background color for the window.
*/
PBITMAPINFO BIT_Make_DIB_RGB_Header_Screen(int xsize, int ysize,
                                           int cEntries, PALETTEENTRY * rgpe, int transparent)
{
        int i;
        PBITMAPINFO pbmi;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        for (i = 0; i < cEntries; i++)
        {
                pbmi->bmiColors[i].rgbRed = rgpe[i].peRed;
                pbmi->bmiColors[i].rgbGreen = rgpe[i].peGreen;
                pbmi->bmiColors[i].rgbBlue = rgpe[i].peBlue;
                pbmi->bmiColors[i].rgbReserved = 0;
        }

/*
        if (transparent != -1)
        {
                COLORREF color;

                color = PREF_GetBackgroundColor();
                pbmi->bmiColors[transparent].rgbRed     = GetRValue(color);
                pbmi->bmiColors[transparent].rgbGreen   = GetGValue(color);
                pbmi->bmiColors[transparent].rgbBlue    = GetBValue(color);
        }
*/
        return pbmi;
}

unsigned char *
CImgGif::ReadGIFMaster()
{
        unsigned char buf[16];
        unsigned char c;
        unsigned char localColorMap[3][MAXCOLORMAPSIZE];
        long useGlobalColormap;
        long imageCount = 0;
        long imageNumber = 1;
        unsigned char *image = NULL;
        unsigned long i;
        GIFSCREEN GifScreen;
        long bitPixel;
        PGIFFRAME pgfLast = NULL;
        PGIFFRAME pgfNew;

        _gifinfo.ZeroDataBlock = 0;

        /*
         * Initialize GIF89 extensions
         */
        _gifinfo.Gif89.transparent = -1;
        _gifinfo.Gif89.delayTime = 5;
        _gifinfo.Gif89.inputFlag = -1;
        _gifinfo.Gif89.disposal = 0;
        _gifinfo.lGifLoc = 0;

        // initialize our animation fields
        _gad.fAnimated = FALSE;          // set to TRUE if we see more than one image
        _gad.fLooped = FALSE;                    // TRUE if we've seen a Netscape loop block
        _gad.fHasTransparency = FALSE; // until proven otherwise
    _gad.fNoBWMapping = FALSE;
    _gad.dwGIFVer = dwGIFVerUnknown;
        _gad.cLoops = 0;                
        _gad.pgf = NULL;
        _gad.pcolorsGlobal = NULL;

        if (!Read(buf, 6))
        {
      TraceTag((tagImageDecode, "GIF: error reading magic number\n"));
      RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                //goto exitPoint;
        }

    if (!IsGifHdr(buf)) {
      TraceTag((tagImageDecode, "GIF: Malformed header\n"));
      RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
      //goto exitPoint;
    }

    _gad.dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;

        if (!Read(buf, 7))
        {
      TraceTag((tagImageDecode, "GIF: failed to read screen descriptor\n"));
      RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                //goto exitPoint;
        }

        GifScreen.Width = LM_to_uint(buf[0], buf[1]);
        GifScreen.Height = LM_to_uint(buf[2], buf[3]);
        GifScreen.BitPixel = 2 << (buf[4] & 0x07);
        GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
        GifScreen.Background = buf[5];
        GifScreen.AspectRatio = buf[6];

        if (BitSet(buf[4], LOCALCOLORMAP))
        {                                                       /* Global Colormap */
                int scale = 65536 / MAXCOLORMAPSIZE;

                if (ReadColorMap(GifScreen.BitPixel, GifScreen.ColorMap))
                {
            TraceTag((tagImageDecode, "error reading global colormap\n"));
            RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                        //goto exitPoint;
                }
                for (i = 0; i < GifScreen.BitPixel; i++)
                {
                        int tmp;

                        tmp = (BYTE) (GifScreen.ColorMap[0][i]);
                        _ape[i].peRed = (BYTE) (GifScreen.ColorMap[0][i]);
                        _ape[i].peGreen = (BYTE) (GifScreen.ColorMap[1][i]);
                        _ape[i].peBlue = (BYTE) (GifScreen.ColorMap[2][i]);
                        _ape[i].peFlags = (BYTE) 0;
                }
                for (i = GifScreen.BitPixel; i < MAXCOLORMAPSIZE; i++)
                {
                        _ape[i].peRed = (BYTE) 0;
                        _ape[i].peGreen = (BYTE) 0;
                        _ape[i].peBlue = (BYTE) 0;
                        _ape[i].peFlags = (BYTE) 0;
                }
        }

        if (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49)
        {
                float r;
                r = ((float) (GifScreen.AspectRatio) + (float) 15.0) / (float) 64.0;
        TraceTag((tagImageDecode, "Warning: non-square pixels!\n"));
        }

        for (;; ) // our appetite now knows no bounds save termination or error
        {
                if (!Read(&c, 1))
                {
            TraceTag((tagImageDecode, "EOF / read error on image data\n"));
            RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                        //goto exitPoint;
                }

                if (c == ';')
                {                                               /* GIF terminator */
                        if (imageCount < imageNumber)
                        {
                TraceTag((tagImageDecode, "No images found in file\n"));
                RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                                //goto exitPoint;
                        }
                        break;
                }

                if (c == '!')
                {                                               /* Extension */
                        if (!Read(&c, 1))
                        {
                TraceTag((tagImageDecode, "EOF / read error on extension function code\n"));
                RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                                //goto exitPoint;
                        }
                        DoExtension(c);
                        continue;
                }

                if (c != ',')
                {                                               /* Not a valid start character */
                        break;
                }

                ++imageCount;

                if (!Read(buf, 9))
                {
             TraceTag((tagImageDecode, "couldn't read left/top/width/height\n"));
             RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                        //goto exitPoint;
                }

                useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);

                bitPixel = 1 << ((buf[8] & 0x07) + 1);

                /*
                 * We only want to set width and height for the imageNumber
                 * we are requesting.
                 */
                if (imageCount == imageNumber)
                {
            // Replicate some of Netscape's special cases:
            // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
            // Don't use the logical screen if the first image spills out of the logical screen.
            // These are artifacts of primitive authoring tools falling into the hands of hapless users.
            RECT    rectImage;  // rect defining bounds of GIF
            RECT    rectLS;     // rect defining bounds of GIF logical screen.
            RECT    rectSect;   // intersection of image an logical screen
            BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
            BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases

            rectImage.left = LM_to_uint(buf[0], buf[1]);
            rectImage.top = LM_to_uint(buf[2], buf[3]);
            rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
            rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);
            rectLS.left = rectLS.top = 0;
            rectLS.right = GifScreen.Width;
            rectLS.bottom = GifScreen.Height;
            IntersectRect( &rectSect, &rectImage, &rectLS );
            fNoSpill = EqualRect( &rectImage, &rectSect );
            fGoofy87a = FALSE;
            if (_gad.dwGIFVer == dwGIFVer87a)
            {
                // netscape ignores the logical screen if the image is flush against
                // either the upper left or lower right corner
                fGoofy87a = (rectImage.top == 0 && rectImage.left == 0) ||
                            (rectImage.bottom == rectLS.bottom &&
                             rectImage.right == rectLS.right);
            }   

            if (!fGoofy87a && fNoSpill)
            {
                            _xWidth = GifScreen.Width;  
                            _yHeight = GifScreen.Height;
            }
            else
            {
                // Something is amiss. Fall back to the image's dimensions.

                // If the sizes match, but the image is offset, or we're ignoring
                // the logical screen cuz it's a goofy 87a, then pull it back to 
                // to the origin
                if ((LM_to_uint(buf[4], buf[5]) == GifScreen.Width &&
                      LM_to_uint(buf[6], buf[7]) == GifScreen.Height) ||
                     fGoofy87a)
                {
                    buf[0] = buf[1] = 0; // left corner to zero
                    buf[2] = buf[3] = 0; // top to zero.
                }

                            _xWidth = LM_to_uint(buf[4], buf[5]);
                            _yHeight = LM_to_uint(buf[6], buf[7]);
            }

                        _lTrans = _gifinfo.Gif89.transparent;

            // Post WHKNOWN
            //OnSize(_xWidth, _yHeight, _lTrans);
                }

                if (!useGlobalColormap)
                {
                        if (ReadColorMap(bitPixel, localColorMap))
                        {
            TraceTag((tagImageDecode, "error reading local colormap\n"));
            RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                                //goto exitPoint;
                        }
                }

                // We allocate a frame record for each imag in the GIF stream, including
                // the first/primary image.
                pgfNew = (PGIFFRAME) calloc(1, sizeof(GIFFRAME));

                if ( pgfNew == NULL )
                {
            TraceTag((tagImageDecode, "not enough memory for GIF frame\n"));
            RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
                        //goto exitPoint;
                }

                if ( _gifinfo.Gif89.delayTime != -1 )
                {
                        // we have a fresh control extension for this block

            // convert to milliseconds
                        pgfNew->gced.uiDelayTime = _gifinfo.Gif89.delayTime * 10;


                        //REVIEW(seanf): crude hack to cope with 'degenerate animations' whose timing is set to some
                        //                               small value becaue of the delays imposed by Netscape's animation process
                        if ( pgfNew->gced.uiDelayTime <= 50 ) // assume these small values imply Netscape encoding delay
                                pgfNew->gced.uiDelayTime = 100;   // pick a larger value s.t. the frame will be visible
                        pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
                        pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
                        pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;

                }
                else
                {   // fake one up s.t. GIFs that rely solely on Netscape's delay to time their animations will play
                    // The spec says that the scope of one of these blocks is the image after the block.
            // Netscape says 'until further notice'. So we play it their way up to a point. We
            // propagate the disposal method and transparency. Since Netscape doesn't honor the timing
            // we use our default timing for these images.
            pgfNew->gced.uiDelayTime = 100;
                        pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
                        pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
                        pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
                }

                pgfNew->top = LM_to_uint(buf[2], buf[3]);               // bounds relative to the GIF logical screen 
                pgfNew->left = LM_to_uint(buf[0], buf[1]);
                pgfNew->width = LM_to_uint(buf[4], buf[5]);
                pgfNew->height = LM_to_uint(buf[6], buf[7]);

                // Images that are offset, or do not cover the full logical screen are 'transparent' in the
                // sense that they require us to matte the frame onto the background.

        if (!_gad.fHasTransparency && (pgfNew->gced.fTransparent ||
                                       pgfNew->top != 0 ||
                                       pgfNew->left != 0 ||
                                       (UINT)pgfNew->width != (UINT)GifScreen.Width ||
                                       (UINT)pgfNew->height != (UINT)GifScreen.Height))
        {
            _gad.fHasTransparency = TRUE;
            //if (_lTrans == -1)
            //    OnTrans(0);
        }

                // We don't need to allocate a handle for the simple region case.
        // FrancisH says Windows is too much of a cheapskate to allow us the simplicity
        // of allocating the region once and modifying as needed. Well, okay, he didn't
        // put it that way...
                pgfNew->hrgnVis = NULL;
                pgfNew->iRgnKind = NULLREGION;

                if (!useGlobalColormap)
                {
            // remember that we saw a local color table and only map two-color images
            // if we have a homogenous color environment
            _gad.fNoBWMapping = _gad.fNoBWMapping || bitPixel > 2;

            // CALLOC will set unused colors to <0,0,0,0>
                        pgfNew->pcolors = (PALETTEENTRY *) calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
                        if ( pgfNew->pcolors == NULL )
                        {
                                DeleteRgn( pgfNew->hrgnVis );
                                free( pgfNew );

                TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
                                //goto exitPoint;
                        }
                        else
                        {
                                for (i = 0; i < (ULONG)bitPixel; ++i)
                                {
                                        pgfNew->pcolors[i].peRed = localColorMap[CM_RED][i];
                                        pgfNew->pcolors[i].peGreen = localColorMap[CM_GREEN][i];
                                        pgfNew->pcolors[i].peBlue = localColorMap[CM_BLUE][i];
                                }
                                pgfNew->cColors = bitPixel;
                        }
                }
                else
                {
                        if ( _gad.pcolorsGlobal == NULL )
                        { // Whoa! Somebody's interested in the global color table
              // CALLOC will set unused colors to <0,0,0,0>
                            _gad.pcolorsGlobal = (PALETTEENTRY *) calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
                                _gad.fNoBWMapping = _gad.fNoBWMapping || GifScreen.BitPixel > 2;
                if ( _gad.pcolorsGlobal != NULL )
                                {
                                        CopyMemory(_gad.pcolorsGlobal, _ape,
                                                                GifScreen.BitPixel * sizeof(PALETTEENTRY) );
                                }
                                else
                                {
                                        DeleteRgn( pgfNew->hrgnVis );
                                        free( pgfNew );
                    TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                    RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
                                        //goto exitPoint;
                                }
                        }
                        pgfNew->cColors = GifScreen.BitPixel;
                        pgfNew->pcolors = _gad.pcolorsGlobal;
                }

                // Get this in here so that GifStrectchDIBits can use it during progressive
                // rendering.
                if ( _gad.pgf == NULL )
                        _gad.pgf = pgfNew;

        pgfNew->ppixels = ReadImage(LM_to_uint(buf[4], buf[5]), // width
                                    LM_to_uint(buf[6], buf[7]), // height
                                    BitSet(buf[8], INTERLACE),
                                    imageCount != imageNumber);

                if ( pgfNew->ppixels != NULL )
                {
                        // Oh JOY of JOYS! We got the pixels!
                        if (pgfLast != NULL)
            {
                int transparent = (pgfNew->gced.fTransparent) ? (int) pgfNew->gced.ucTransIndex : -1;

                            _gad.fAnimated = TRUE; // say multi-image == animated

                if (GetColorMode() == 8) // palettized, use DIB_PAL_COLORS
                {   // This will also dither the bits to the screen palette

                    pgfNew->pbmi = BIT_Make_DIB_PAL_Header(pgfNew->width, pgfNew->height);
                    //if (x_Dither(pgfNew->ppixels, pgfNew->pcolors, pgfNew->width, pgfNew->height, transparent))
                    //    goto exitPoint;
                }
                else // give it an RGB header
                {
                    pgfNew->pbmi = BIT_Make_DIB_RGB_Header_Screen(
                        pgfNew->width,
                        pgfNew->height,
                        pgfNew->cColors, pgfNew->pcolors,
                        transparent);
                }

                // Okay, so we've done any mapping on the GIFFRAME, so there's
                // no need to keep the pcolors around.  Let's go can clear out
                // the pcolors.
                // REVIEW(seanf): This assumes a common palette is used by all
                // clients of the image
                if ( pgfNew->pcolors != NULL && pgfNew->pcolors != _gad.pcolorsGlobal )
                    free( pgfNew->pcolors );
                pgfNew->pcolors = NULL;

                pgfLast->pgfNext = pgfNew;

                // Do something to here to get the new frame on the screen.

                _fInvalidateAll = TRUE;
                //super::OnProg(FALSE, IMGBITS_TOTAL);
            }
                        else
                        { // first frame
                                _gad.pgf = pgfNew;

                _gad.pgfLastProg = pgfNew;
                _gad.dwLastProgTimeMS = 0;
                // set up a temporary animation state for use in progressive draw
                _gas.fAnimating = TRUE; 
                _gas.dwLoopIter = 0;
                _gas.pgfDraw = pgfNew;

                                if ( imageCount == imageNumber )
                                        image = pgfNew->ppixels;
                        }
                        pgfLast = pgfNew;
                }

                // make the _gifinfo.Gif89.delayTime stale, so we know if we got a new
                // GCE for the next image
                _gifinfo.Gif89.delayTime = -1;

        }

        if ( imageCount > imageNumber )
                _gad.fAnimated = TRUE; // say multi-image == animated

#ifdef FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
    // RAID #23709 - If an animation is sufficiently long, we treat it as indefinite...
    // Indefinite stays indefinite.
    // 5/29/96 - JCordell sez we shouldn't introduce this gratuitous NS incompatibility.
    //           We'll keep it around inside this ifdef in case we decide we want it.
    if ( _gad.fLooped &&
        (_gad.dwLoopDurMS * _gad.cLoops) / 1000 > dwIndefiniteGIFThreshold ) // if longer than five minutes
        _gad.cLoops = 0; // set to indefinite looping.
#endif // FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE

//exitPoint:
        return image;
}

BITMAPINFO *
CImgGif::FinishDithering()
{
    BITMAPINFO * pbmi;
    
    if (GetColorMode() == 8)
    {
        pbmi = BIT_Make_DIB_PAL_Header(_gad.pgf->width, _gad.pgf->height);
    }
    else
    {
        pbmi = BIT_Make_DIB_RGB_Header_Screen(_gad.pgf->width, _gad.pgf->height,
               _gad.pgf->cColors, _gad.pgf->pcolors, _lTrans);
    }

    return pbmi;
}


HBITMAP* LoadGifImage( LPCSTR szFileName,
                       IStream *stream,                       
                       int dx, int dy,
                       COLORREF **colorKeys,
                       int *numBitmaps,
                       int **delays,
                       int *loop)
{
   /* 
      The odd approach here lets us keep the original IE GIF code unchanged while removing
      DA specific inserts (except error reporting). The progressive rendering and palette 
      dithering found in the IE code is also not supported yet.
   */
   CImgGif gifimage;
   gifimage._szFileName = szFileName;
   gifimage._gifinfo.stream = stream;
   BYTE *pbBits = gifimage.ReadGIFMaster();

   if (pbBits) {
      gifimage._pbBits = pbBits;
      gifimage._gad.pgf->pbmi = gifimage.FinishDithering(); 
   }

   /*
      Extract information from GIF decoder, and format it into an array of bitmaps.
   */
   *delays = NULL;
   vector<HBITMAP> vhbmp;
   vector<COLORREF> vcolorKey;
   vector<int> vdelay;
   LPVOID  image = NULL;
   LPVOID  lastBits = pbBits;
   LPVOID  bitsBeforeLastBits = NULL;
   HBITMAP *hImage = NULL;
   PBITMAPINFO pbmi = NULL;
   HBITMAP hbm;
   PGIFFRAME pgf = gifimage._gad.pgf;
   bool fUseOffset = false; 
   bool fFirstFrame = true;
   long pgfWidth,pgfHeight,     // animation frame dims
        fullWidth,fullHeight,   // main frame dims
        fullPad, pgfPad,        // row padding vals
        fullSize, pgfSize;

   // TODO: Dither global palette to display palette

   fullWidth = gifimage._xWidth;
   fullHeight = gifimage._yHeight;
   fullPad = (((fullWidth + 3) / 4) * 4) - fullWidth;  
   fullSize = (fullPad+fullWidth)*fullHeight; 
    
   while(1) {     
      pbmi = pgf->pbmi;
      Assert(pbmi);

      // TODO: It would be nice to pass local palettes up so they could
      // be mapped to system palettes.       

      // Check to see if frame is offset from logical frame      
      if(pgf->top != 0 ||
         pgf->left != 0 || 
         pgf->width != fullWidth ||
         pgf->height != fullHeight) 
      {
         fUseOffset = true;    
         pgfWidth = pbmi->bmiHeader.biWidth;    
         pgfHeight = pbmi->bmiHeader.biHeight;  
         pbmi->bmiHeader.biWidth = fullWidth;      
         pbmi->bmiHeader.biHeight = fullHeight; 
         pgfPad = (((pgfWidth + 3) / 4) * 4) - pgfWidth; 
         pgfSize = (pgfPad+pgfWidth)*pgfHeight;
      }

      hbm = CreateDIBSection(NULL, pbmi, DIB_RGB_COLORS, (LPVOID *) &image, NULL, 0);        
      if(!hbm) RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
       
      // Correctly composite bitmaps based on disposal method specified        
      unsigned int disp = pgf->gced.uiDisposalMethod;
      // If the frame is offset, fill it with          
      if( (disp == gifRestorePrev) && (bitsBeforeLastBits != NULL) )
         memcpy(image, bitsBeforeLastBits, fullSize);
      else if( (disp == gifRestoreBkgnd) || (disp == gifRestorePrev) || fFirstFrame ) // fill with bgColor      
         memset(image, pgf->gced.ucTransIndex, fullSize);           
      else // fill with last frames data                                              
         memcpy(image, lastBits, fullSize);      
         
      
      // For offset gifs allocate an image the size of the first frame 
      // and then fill in the bits at the offset location.        
      if(fUseOffset) {         
         for(int i=0; i<pgfHeight; i++) {               
            BYTE *dst, *src;                     
            // the destination is the address of the image data plus the frame and row offset. 
            int topOffset = fullHeight - pgfHeight - pgf->top;
            dst = (BYTE*)image +                                  
                  ( ((topOffset + i) *(fullPad+fullWidth)) + pgf->left );
            // copy from the frame's nth row
            src = pgf->ppixels + i*(pgfPad+pgfWidth);                
            for(int j=0; j<pgfWidth; j++) {     
                // copy the frame row data, excluding transparent bytes    
                if(src[j] != pgf->gced.ucTransIndex)
                    dst[j] = src[j];
            }
         }
      }     
      else {
         // Overwritten accumulated bits with current bits. If the 
         // new image contains transparency we need to take it into 
         // account. Since this is slower, special case it.
         if(pgf->gced.fTransparent) {            
            for(int i=0; i<((fullPad+fullWidth)*fullHeight); i++) {        
                if(pgf->ppixels[i] != pgf->gced.ucTransIndex)
                    ((BYTE*)image)[i] = ((BYTE*)pgf->ppixels)[i];
            }
         }
         else // Otherwise, just copy over the offset window's bytes
            memcpy(image, pgf->ppixels, (fullPad+fullWidth)*fullHeight);  
      }

      /* 
          If we got a transparent color extension, convert it to a COLORREF
      */
      COLORREF colorKey = -1;
      if (pgf->gced.fTransparent) {      
          int transparent = pgf->gced.ucTransIndex;
          colorKey = RGB(pgf->pbmi->bmiColors[transparent].rgbRed,
                         pgf->pbmi->bmiColors[transparent].rgbGreen,
                         pgf->pbmi->bmiColors[transparent].rgbBlue);
      }

      vcolorKey.push_back(colorKey);
      vhbmp.push_back(hbm);
      
      /* 
         The delay times are frame specific and can be different, these
         should be propagated as an array to the sampling code.  
      */      
      vdelay.push_back(pgf->gced.uiDelayTime);      

      bitsBeforeLastBits = lastBits;        
      lastBits = image;
      fUseOffset = false;
      if(pgf->pgfNext == NULL) break;
      pgf = pgf->pgfNext;
      fFirstFrame = FALSE;      
   } 
 
   
   // The number of times to loop are also propagated.  Note we add one because 
   // all other GIF decoders appear to treat the loop as the number of times to 
   // loop AFTER the first run through the frames.
   *loop = gifimage._gad.cLoops;
   *numBitmaps = vhbmp.size();

   // Since the vector will go out of scope, move contents over to heap
   // Allocations below assume current heap is GC heap.
   Assert(&GetHeapOnTopOfStack() == &GetGCHeap());
   hImage  = (HBITMAP *)AllocateFromStore(vhbmp.size() * sizeof(HBITMAP));
   *delays = (int*)AllocateFromStore(vhbmp.size() * sizeof(int));
   *colorKeys = (COLORREF*)AllocateFromStore(vcolorKey.size() * sizeof(COLORREF));

   for(int i=0; i < vhbmp.size(); i++) {
      hImage[i] = vhbmp[i];
      (*colorKeys)[i] = vcolorKey[i];
      (*delays)[i] = vdelay[i];
   }
          
   return hImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\helps.cpp ===
/**********************************************************************
helps  Generic sound helper functions
**********************************************************************/
#include "headers.h"
#include "privinc/util.h"
#include "privinc/helps.h"
#include <float.h>              // DBL_MAX
#include <math.h>               // log10 and pow

unsigned int
SecondsToBytes(Real seconds, int sampleRate,
               int numChannels, int bytesPerSample)
{
    return (unsigned int)(seconds * sampleRate * numChannels * bytesPerSample);
}

Real
FramesToSeconds(int frames, int sampleRate)
{
    return (float)frames / (float)(sampleRate);
}

Real
BytesToSeconds(unsigned int bytes, int sampleRate,
               int numChannels, int bytesPerSample)
{
    return (float)bytes / (float)(sampleRate * numChannels * bytesPerSample);
}

unsigned int
BytesToFrames(unsigned int bytes, int numChannels, int bytesPerSample)
{
    return bytes / (numChannels * bytesPerSample);
}

unsigned int
SamplesToBytes(unsigned int samples, int numChannels, int bytesPerSample)
{
    return samples * numChannels * bytesPerSample;
}

unsigned int
FramesToBytes(unsigned int frames, int numChannels, int bytesPerSample)
{
    return frames * numChannels * bytesPerSample;
}


void
Pan::SetLinear(double linearPan)
{
    _direction   = (linearPan >= 0) ? 1 : -1;
    _dBmagnitude = LinearTodB(1.0 - fabs(linearPan));
}

void
PanGainToLRGain(double pan, double gain, double& lgain, double& rgain)
{
    // this implements the balance pan
    // GR
    //         ---
    //        /
    //       /
    //      /

    // GL
    //      ---
    //         \
    //          \
    //           \
        
    lgain = gain;
    rgain = gain;

    if (pan>0.0) {
        lgain = gain * (1 - pan);
    } else if (pan<0.0) {
        rgain = gain * (1 + pan);
    }
}

void
SetPanGain(double lgain, double rgain, Pan& pan, double& gainDb)
{
    double gain = MAX(lgain, rgain);

    pan.SetLinear((rgain - lgain) / gain);

    gainDb = LinearTodB(gain);
}

/**********************************************************************
Takes an input range of 0 to 1 and converts it to a log range of 
0 to -BigNumber

20 * log base 10 is the standard decibel power conversion equation.
**********************************************************************/
double LinearTodB(double linear) {
    double result;

    if(linear <= 0.0)
        result = -DBL_MAX; // Largest negative is the best we can do
    else
        result = 20.0 * log10(linear);

    return(result);
}

double DBToLinear(double db)
{
    return pow(10, db/20.0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\ipc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "privinc/ipc.h"

#pragma warning(disable:4200)  

DeclareTag(tagIPCEntry, "IPC", "Entry/Exit");
DeclareTag(tagIPC, "IPC", "General Msgs");

UINT DAMessageId;
static DWORD DAThreadTlsIndex = 0xFFFFFFFF;
static CritSect * threadCS = NULL;

typedef list <DAThread *> DAThreadList;
static DAThreadList * threadList = NULL;

#define DATHREAD_CLASS "ThreadClass"

bool
DAIPCWorker::AttachToThread()
{
    DetachFromThread();
    
    _hwnd = ::CreateWindow (DATHREAD_CLASS, 
                            "",
                            0, 0, 0, 0, 0, NULL, NULL, hInst, NULL);

    if (!_hwnd)
        return false;

    // Store the object in the user data area of the window
    
    SetWindowLongPtr (_hwnd, GWLP_USERDATA, (LONG_PTR) this) ;

    _dwThreadId = GetCurrentThreadId();

#if DEVELOPER_DEBUG
    char buf[1024];

    wsprintf(buf,
             "IPCWorker(%s): Attaching to thread - threadid -  %#lx, hwnd - %#lx\n",
             GetName(),
             _dwThreadId,
             _hwnd);
    
    OutputDebugString(buf);
#endif

    return true;
}

void
DAIPCWorker::DetachFromThread()
{
    // Cleanup by removing everything associated with the hwnd
    if (_hwnd) {
#if DEVELOPER_DEBUG
        char buf[1024];
        
        wsprintf(buf,
                 "IPCWorker(%s): Detaching from thread - threadid -  %#lx, hwnd - %#lx\n",
                 GetName(),
                 _dwThreadId,
                 _hwnd);
        
        OutputDebugString(buf);
#endif
        SetWindowLongPtr (_hwnd, GWLP_USERDATA, NULL) ;
        DestroyWindow(_hwnd);
        _hwnd = NULL;
        _dwThreadId = 0;
    }
}

bool
DAIPCWorker::SendMsg(DWORD dwMsg,
                     DWORD dwTimeout,
                     DWORD dwNum,
                     va_list args)
{
    bool ret;
    
    // Create the packet to send
    DAIPCPacket * packet = MakePacket(dwMsg,
                                      dwTimeout != 0,
                                      dwNum,
                                      args);
    
    if (packet) {
        ret = SendPacket(*packet, dwTimeout);
    } else {
        ret = false;
    }
    
    if (packet)
        packet->Release();

    return ret;
}


DAIPCWorker::DAIPCPacket *
DAIPCWorker::MakePacket(DWORD dwMsg,
                        bool bSync,
                        DWORD dwNum,
                        va_list args)
{
    // Create the packet to send
    DAIPCWorker::DAIPCPacket * packet = new (dwNum) DAIPCWorker::DAIPCPacket;

    if (packet == NULL)
        return NULL;
    
    // Setup the basic information
    if (!packet->Init(dwMsg, bSync)) {
        delete packet;
        return NULL;
    }
        
    // Get the arguments
    
    DWORD * p = packet->GetParams();
    
    for (int i = 0; i < dwNum; i++)
        p[i] = va_arg(args, DWORD);
    
    return packet;
}

bool
DAIPCWorker::SendPacket(DAIPCPacket & p, DWORD dwTimeout)
{
    // Create the message to send
    
    // If we are calling from the same thread and we are synchronous
    // then we need to call directly otherwise just queue the message
    if (_dwThreadId == GetCurrentThreadId() && p.IsSync()) {
        LRESULT r;
        IPCProc(_hwnd, DAMessageId, (WPARAM) &p, 0, r);
        return true;
    } else {
        // Add a reference for the posted message queue
        p.AddRef();

        // Post the message to the window
        if (!PostMessage(_hwnd, DAMessageId, (WPARAM) &p, 0)) {
            // If we failed to post the message then we need to
            // release the packet since the receiver will not do it
            
            p.Release();
            return false;
        }

        if (p.IsSync()) {
            // Need to wait for the message to be processed
            // TODO: Should add a reasonable timeout
            // TODO: Should add some diagnostics to detect deadlock

            // TODO: We should wait for a smaller period of time and
            // poll to see if the thread has terminated or we can do a
            // waitformultipleobjects on the thread handle
            WaitForSingleObject(p.GetSync(), dwTimeout);
        }
    }
    
    return true;
}

bool
DAIPCWorker::IPCProc (HWND hwnd,
                      UINT msg,
                      WPARAM wParam,
                      LPARAM lParam,
                      LRESULT & res)
{
    res = 0;

    if (msg != DAMessageId)
        return true;

    DAIPCPacket * p = (DAIPCPacket *)wParam;
    
    ProcessMsg(p->GetMsg(),
               p->GetNumParam(),
               p->GetParams());

    if (p->IsSync())
        SetEvent(p->GetSync());

    p->Release();
    
    return false;
}

LRESULT CALLBACK
DAIPCWorker::WindowProc (HWND   hwnd,
                         UINT   msg,
                         WPARAM wParam,
                         LPARAM lParam)
{
    TraceTag((tagIPCEntry,
              "WindowProc: 0x%lx, 0x%lx, 0x%lx, 0x%lx",
              hwnd, msg, wParam, lParam));
    
    // Get the worker data associated with the window
    DAIPCWorker * t = (DAIPCWorker *) GetWindowLongPtr (hwnd, GWLP_USERDATA) ;

    LRESULT res;
    
    // Callthe IPCProc and if it returns true call the default winproc
    if (!t || t->IPCProc(hwnd, msg, wParam, lParam, res))
        res = DefWindowProc (hwnd, msg, wParam, lParam);

    return res;
}

//
// DAThread
//

DAThread::DAThread()
: _dwThreadId(0),
  _hThread(NULL),
  _hMsgQEvent(NULL),
  _bDoingWork(false)
{
    if (threadList) {
        // Add ourselves to the list of threads
        
        CritSectGrabber csg(*threadCS);
        threadList->push_back(this);
    }
}

DAThread::~DAThread()
{
    // Ensure the thread is stopped
    Stop();

    if (threadList) {
        CritSectGrabber csg(*threadCS);
        threadList->remove(this);
    }
}

bool
DAThread::Start()
{
    if (IsStarted())
        return true;
    
    if (!AddRefDLL())
        return false;

    // Create necessary events first
    
    _hMsgQEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
        
    if (_hMsgQEvent != NULL) {
    
        // Create the thread
        
        _hThread = CreateThread(NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)DAWorker,
                                this,
                                0,
                                (LPDWORD)&_dwThreadId);
    
        if (_hThread != NULL) {
            // wait until the message queue has been created
            DWORD dwRes ;
    
            {
                // make the expected event be first so we can check it
                // below
                // TODO: We may want to add a timeout here to ensure
                // we did not lock up for some reason
                
                HANDLE h[] = { _hMsgQEvent,_hThread } ;
                dwRes = WaitForMultipleObjects(2,h,FALSE,INFINITE) ;
            }
    
            CloseHandle(_hMsgQEvent);
            _hMsgQEvent = NULL;
            // Check the result to see if the event was signalled or the
            // thread exited unexpectedly
    
            // The expected event is the first in the array above
            // Return true indicating everything is going fine
            if (dwRes == WAIT_OBJECT_0) {
                return true;
            }

            // Fall through if we failed
            TraceTag((tagError,
                      "GarbageCollector::StartThread: Thread terminated unexpectedly"));
        } else {
            TraceTag((tagError,
                      "DAThread:Start: Failed to create thread"));
        }
    } else {
        TraceTag((tagError,
                  "DAThread:Start: Failed to create terminate event"));
    }
        
    ReleaseDLL();
    
    Kill();

    return false;
}

bool
DAThread::Terminate(bool bKill)
{
    bool ret = true;
    
    // See if the thread is alive
    
    if (_dwThreadId) {
        if (bKill) {
            if (_dwThreadId != GetCurrentThreadId())
                ::TerminateThread(_hThread, 0);
        } else {
            // Send terminate message to ensure the thread wakes up
            
            SendAsyncMsg(DAT_TERMINATE);
        }
        
        _dwThreadId = 0;

        Assert (_hThread);
        CloseHandle(_hThread);
        _hThread = NULL;
    }

    if (_hMsgQEvent) {
        CloseHandle(_hMsgQEvent);
        _hMsgQEvent = NULL;
    }

    return ret;
}

int
DAThread::workerRoutine()
{
    if (!InitThread()) {
        DeinitThread();
        return -1;
    }

    MSG msg;
    while (GetMessage(&msg, NULL, NULL, NULL)) {
        if (msg.message == DAMessageId &&
            ((DAIPCPacket *)msg.wParam)->GetMsg() == DAT_TERMINATE)
            break;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    if (!DeinitThread())
        return -1;

    return 0;
}

bool
DAThread::InitThread()
{
    if (!AttachToThread())
        return false;
    
    {
        MSG msg;
        
        // force message queue to be created
        PeekMessage(&msg, NULL, NULL, NULL, PM_NOREMOVE);
    }

    // set event that indicates thread's msg queue created
    SetEvent(_hMsgQEvent); 

    if (!TlsSetValue(DAThreadTlsIndex, this))
        return false;

    // CoInitialize so we can call COM stuff

    // this doesn't exist on ie3.02 platfroms.
    //CoInitializeEx(NULL, COINIT_MULTITHREADED);
    CoInitialize(NULL);

    return true;
}

bool
DAThread::DeinitThread()
{
    DetachFromThread();
    
    // Clean up COM
    CoUninitialize();
    
    FreeLibraryAndExitThread(hInst, 0);
    
    return true;
}

bool
DAThread::AddRefDLL()
{
    bool bRet = false;

    char buf[MAX_PATH + 1];
    
    if (GetModuleFileName(hInst, buf, ARRAY_SIZE(buf)) == 0)
    {
        TraceTag((tagError,
                  "DAThread::AddRefDLL: Failed to getmodulefilename - %hr", GetLastError()));
        goto done;
    }
    
    HINSTANCE new_hinst;
    
    new_hinst = LoadLibrary(buf);
    
    if (new_hinst == NULL)
    {
        TraceTag((tagError,
                  "DAThread::AddRefDLL: Failed to LoadLibrary(%s) - %hr",
                  buf,
                  GetLastError()));
        goto done;
    }
    
    Assert(new_hinst == hInst);

    bRet = true;
  done:
    return bRet;
}

void
DAThread::ReleaseDLL()
{
    FreeLibrary(hInst);
}

//
// General IPC stuff
//

DAThread *
GetCurrentDAThread()
{
    return (DAThread *) TlsGetValue(DAThreadTlsIndex);
}

static void RegisterWindowClass ()
{
    WNDCLASS windowclass;

    memset (&windowclass, 0, sizeof(windowclass));

    windowclass.style         = 0;
    windowclass.lpfnWndProc   = DAIPCWorker::WindowProc;
    windowclass.hInstance     = hInst;
    windowclass.hCursor       = NULL;
    windowclass.hbrBackground = NULL;
    windowclass.lpszClassName = DATHREAD_CLASS;

    RegisterClass (&windowclass);
}

// =========================================
// Initialization
// =========================================
void
InitializeModule_IPC()
{
    RegisterWindowClass();
    DAMessageId = RegisterWindowMessage(_T("IPCMessage"));

    DAThreadTlsIndex = TlsAlloc();

    // If result is 0xFFFFFFFF, allocation failed.
    Assert(DAThreadTlsIndex != 0xFFFFFFFF);

    threadCS = THROWING_ALLOCATOR(CritSect);
    threadList = THROWING_ALLOCATOR(DAThreadList);
}

void
DeinitializeModule_IPC(bool bShutdown)
{
    // Iterate through the list and stop all the threads - but do not
    // destroy them

    if (threadList) {
        for (DAThreadList::iterator i = threadList->begin();
             i != threadList->end();
             i++) {
            (*i)->Terminate(bShutdown);
        }
    }

    // We need to set the threadList and threadCS to NULL to ensure
    // that when the thread objects are destroyed later on during
    // deinitialization they do not try to access the no longer
    // valid list
    
    delete threadList;
    threadList = NULL;

    delete threadCS;
    threadCS = NULL;

    if (DAThreadTlsIndex != 0xFFFFFFFF)
        TlsFree(DAThreadTlsIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\hresinfo.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    This file contains a function that converts HRESULT values into an English
string (no localization).
*******************************************************************************/

#include "headers.h"
#include "privinc/hresinfo.h"
#include <dsound.h>
#include <dxterror.h>


/*****************************************************************************
Return the string describing the facility portion of the HRESULT.
*****************************************************************************/

static const char *FacilityString (HRESULT hresult)
{
    int code     = HRESULT_CODE (hresult);
    int facility = HRESULT_FACILITY (hresult);

    switch (facility)
    {
        case FACILITY_NULL:     return "None";
        case FACILITY_WINDOWS:  return "Windows";
        case FACILITY_WIN32:    return "Win32";
        case FACILITY_INTERNET: return "Internet";
        case FACILITY_ITF:      return "Interface";
        case FACILITY_STORAGE:  return "Storage";
        case FACILITY_RPC:      return "RPC";
        case FACILITY_CONTROL:  return "Control";
        case FACILITY_DISPATCH: return "Dispatch";

        case _FACDS:            return "DirectSound";

        // Direct3D uses the DirectDraw facility code; catch it here.

        case _FACDD:
            return ((700 <= code) && (code < 800))? "Direct3D" : "DirectDraw";
    }

    return "Unknown";
}



/*****************************************************************************
This routine checks the HRESULT return code from D3D functions.
*****************************************************************************/

HRESULT CheckReturnImpl
    #if _DEBUG
        (HRESULT hResult, char *file, int line, bool except)
    #else
        (HRESULT hResult, bool except)
    #endif
{
    Assert (FAILED(hResult));

    char buf[1024];

    int code = HRESULT_CODE(hResult);        // Error Code ID

    #if !_DEBUG
        buf[0] = 0;     // String is not used when not in dev debug.
    #else
    {
        HresultInfo *info = GetHresultInfo (hResult);

        if(info) {
            sprintf(buf, "%s[%d]:\n    %s, HRESULT %s\n    \"%s\"",
                file, line, FacilityString(hResult), 
                info->hresult_str, info->explanation);
        }
        else {
            sprintf(buf, "%s[%d]:\n    %s, HRESULT %08x",
                file, line, FacilityString(hResult), hResult);
        }
    }
    #endif

    if (except)
    {   RaiseException_InternalErrorCode (hResult, buf);
    }
    else
    {   AssertStr (0, buf);
    }

    return hResult;
}


#if DEVELOPER_DEBUG 

    // This is the lookup table for error strings.  The table is terminated
    // with a zero code (which means all OK).

HresultInfo errtable[] =
{
    /*************************/
    /*** DirectDraw Errors ***/
    /*************************/

    {DDERR_ALREADYINITIALIZED, "DDERR_ALREADYINITIALIZED",
        "This object is already initialized"},

    {DDERR_CANNOTATTACHSURFACE, "DDERR_CANNOTATTACHSURFACE",
        "This surface can not be attached to the requested surface"},

    {DDERR_CANNOTDETACHSURFACE, "DDERR_CANNOTDETACHSURFACE",
        "This surface can not be detached from the requested surface"},

    {DDERR_CURRENTLYNOTAVAIL, "DDERR_CURRENTLYNOTAVAIL",
        "Support is currently not available"},

    {DDERR_EXCEPTION, "DDERR_EXCEPTION",
        "An exception was encountered while performing the requested "
        "operation"},

    {DDERR_GENERIC, "DDERR_GENERIC",
        "Generic failure"},

    {DDERR_HEIGHTALIGN, "DDERR_HEIGHTALIGN",
        "Height of rectangle provided is not a multiple of required "
        "alignment"},

    {DDERR_INCOMPATIBLEPRIMARY, "DDERR_INCOMPATIBLEPRIMARY",
        "Unable to match primary surface creation request with existing "
        "primary surface"},

    {DDERR_INVALIDCAPS, "DDERR_INVALIDCAPS",
        "One or more of the caps bits passed to the callback are incorrect"},

    {DDERR_INVALIDCLIPLIST, "DDERR_INVALIDCLIPLIST",
        "DirectDraw does not support provided Cliplist"},

    {DDERR_INVALIDMODE, "DDERR_INVALIDMODE",
        "DirectDraw does not support the requested mode"},

    {DDERR_INVALIDOBJECT, "DDERR_INVALIDOBJECT",
        "DirectDraw received a pointer that was an invalid DIRECTDRAW object"},

    {DDERR_INVALIDPARAMS, "DDERR_INVALIDPARAMS",
        "One or more of the parameters passed to the callback function "
        "are incorrect"},

    {DDERR_INVALIDPIXELFORMAT, "DDERR_INVALIDPIXELFORMAT",
        "Pixel format was invalid as specified"},

    {DDERR_INVALIDRECT, "DDERR_INVALIDRECT",
        "Rectangle provided was invalid"},

    {DDERR_LOCKEDSURFACES, "DDERR_LOCKEDSURFACES",
        "Operation could not be carried out because one or more surfaces "
        "are locked"},

    {DDERR_NO3D, "DDERR_NO3D",
        "There is no 3D present"},

    {DDERR_NOALPHAHW, "DDERR_NOALPHAHW",
        "Operation could not be carried out because there is no alpha "
        "accleration hardware present or available"},

    {DDERR_NOCLIPLIST, "DDERR_NOCLIPLIST",
        "No clip list available"},

    {DDERR_NOCOLORCONVHW, "DDERR_NOCOLORCONVHW",
        "Operation could not be carried out because there is no color "
        "conversion hardware present or available"},

    {DDERR_NOCOOPERATIVELEVELSET, "DDERR_NOCOOPERATIVELEVELSET",
        "Create function called without DirectDraw object method "
        "SetCooperativeLevel being called"},

    {DDERR_NOCOLORKEY, "DDERR_NOCOLORKEY",
        "Surface doesn't currently have a color key"},

    {DDERR_NOCOLORKEYHW, "DDERR_NOCOLORKEYHW",
        "Operation could not be carried out because there is no "
        "hardware support of the destination color key"},

    {DDERR_NODIRECTDRAWSUPPORT, "DDERR_NODIRECTDRAWSUPPORT",
        "No DirectDraw support possible with current display driver"},

    {DDERR_NOEXCLUSIVEMODE, "DDERR_NOEXCLUSIVEMODE",
        "Operation requires the application to have exclusive mode "
        "but the application does not have exclusive mode"},

    {DDERR_NOFLIPHW, "DDERR_NOFLIPHW",
        "Flipping visible surfaces is not supported"},

    {DDERR_NOGDI, "DDERR_NOGDI",
        "There is no GDI present"},

    {DDERR_NOMIRRORHW, "DDERR_NOMIRRORHW",
        "Operation could not be carried out because there is "
        "no hardware present or available"},

    {DDERR_NOTFOUND, "DDERR_NOTFOUND",
        "Requested item was not found"},

    {DDERR_NOOVERLAYHW, "DDERR_NOOVERLAYHW",
        "Operation could not be carried out because there is "
        "no overlay hardware present or available"},

    {DDERR_NORASTEROPHW, "DDERR_NORASTEROPHW",
        "Operation could not be carried out because there is "
        "no appropriate raster op hardware present or available"},

    {DDERR_NOROTATIONHW, "DDERR_NOROTATIONHW",
        "Operation could not be carried out because there is "
        "no rotation hardware present or available"},

    {DDERR_NOSTRETCHHW, "DDERR_NOSTRETCHHW",
        "Operation could not be carried out because there is "
        "no hardware support for stretching"},

    {DDERR_NOT4BITCOLOR, "DDERR_NOT4BITCOLOR",
        "DirectDrawSurface is not in 4 bit color palette and "
        "the requested operation requires 4 bit color palette"},

    {DDERR_NOT4BITCOLORINDEX, "DDERR_NOT4BITCOLORINDEX",
        "DirectDrawSurface is not in 4 bit color index palette "
        "and the requested operation requires 4 bit color index palette"},

    {DDERR_NOT8BITCOLOR, "DDERR_NOT8BITCOLOR",
        "DirectDraw Surface is not in 8 bit color mode "
        "and the requested operation requires 8 bit color"},

    {DDERR_NOTEXTUREHW, "DDERR_NOTEXTUREHW",
        "Operation could not be carried out because there is "
        "no texture mapping hardware present or available"},

    {DDERR_NOVSYNCHW, "DDERR_NOVSYNCHW",
        "Operation could not be carried out because there is "
        "no hardware support for vertical blank synchronized operations"},

    {DDERR_NOZBUFFERHW, "DDERR_NOZBUFFERHW",
        "Operation could not be carried out because there is "
        "no hardware support for zbuffer blting"},

    {DDERR_NOZOVERLAYHW, "DDERR_NOZOVERLAYHW",
        "Overlay surfaces could not be z layered based on their "
        "BltOrder because the hardware does not support z layering of overlays"},

    {DDERR_OUTOFCAPS, "DDERR_OUTOFCAPS",
        "The hardware needed for the requested operation has "
        "already been allocated"},

    {DDERR_OUTOFMEMORY, "DDERR_OUTOFMEMORY",
        "DirectDraw does not have enough memory to perform the operation"},

    {DDERR_OUTOFVIDEOMEMORY, "DDERR_OUTOFVIDEOMEMORY",
        "DirectDraw does not have enough memory to perform the operation"},

    {DDERR_OVERLAYCANTCLIP, "DDERR_OVERLAYCANTCLIP",
        "hardware does not support clipped overlays"},

    {DDERR_OVERLAYCOLORKEYONLYONEACTIVE, "DDERR_OVERLAYCOLORKEYONLYONEACTIVE",
        "Can only have ony color key active at one time for overlays"},

    {DDERR_PALETTEBUSY, "DDERR_PALETTEBUSY",
        "Access to this palette is being refused because the palette "
        "is already locked by another thread"},

    {DDERR_COLORKEYNOTSET, "DDERR_COLORKEYNOTSET",
        "No src color key specified for this operation"},

    {DDERR_SURFACEALREADYATTACHED, "DDERR_SURFACEALREADYATTACHED",
        "This surface is already attached to the surface it is "
        "being attached to"},

    {DDERR_SURFACEALREADYDEPENDENT, "DDERR_SURFACEALREADYDEPENDENT",
        "This surface is already a dependency of the surface it "
        "is being made a dependency of"},

    {DDERR_SURFACEBUSY, "DDERR_SURFACEBUSY",
        "Access to this surface is being refused because the surface "
        "is already locked by another thread"},

    {DDERR_SURFACEISOBSCURED, "DDERR_SURFACEISOBSCURED",
        "Access to Surface refused because Surface is obscured"},

    {DDERR_SURFACELOST, "DDERR_SURFACELOST",
        "The DIRECTDRAWSURFACE object representing this surface "
        "should have Restore called on it.  Access to this surface is "
        "being refused because the surface is gone"},

    {DDERR_SURFACENOTATTACHED, "DDERR_SURFACENOTATTACHED",
        "The requested surface is not attached"},

    {DDERR_TOOBIGHEIGHT, "DDERR_TOOBIGHEIGHT",
        "Height requested by DirectDraw is too large"},

    {DDERR_TOOBIGSIZE, "DDERR_TOOBIGSIZE",
        "Size requested by DirectDraw is too large.  The individual height "
        "and width are OK"},

    {DDERR_TOOBIGWIDTH, "DDERR_TOOBIGWIDTH",
        "Width requested by DirectDraw is too large"},

    {DDERR_UNSUPPORTED, "DDERR_UNSUPPORTED",
        "Action not supported"},

    {DDERR_UNSUPPORTEDFORMAT, "DDERR_UNSUPPORTEDFORMAT",
        "FOURCC format requested is unsupported by DirectDraw"},

    {DDERR_UNSUPPORTEDMASK, "DDERR_UNSUPPORTEDMASK",
        "Bitmask in the pixel format requested is unsupported by DirectDraw"},

    {DDERR_VERTICALBLANKINPROGRESS, "DDERR_VERTICALBLANKINPROGRESS",
        "vertical blank is in progress"},

    {DDERR_WASSTILLDRAWING, "DDERR_WASSTILLDRAWING",
        "Informs DirectDraw that the previous Blt which is "
        "transfering information to or from this Surface is incomplete"},

    {DDERR_XALIGN, "DDERR_XALIGN",
        "Rectangle provided was not horizontally aligned on required boundary"},

    {DDERR_INVALIDDIRECTDRAWGUID, "DDERR_INVALIDDIRECTDRAWGUID",
        "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver "
        "identifier"},

    {DDERR_DIRECTDRAWALREADYCREATED, "DDERR_DIRECTDRAWALREADYCREATED",
        "A DirectDraw object representing this driver has already been "
        "created for this process"},

    {DDERR_NODIRECTDRAWHW, "DDERR_NODIRECTDRAWHW",
        "A hardware only DirectDraw object creation was attempted "
        "but the driver did not support any hardware"},

    {DDERR_PRIMARYSURFACEALREADYEXISTS, "DDERR_PRIMARYSURFACEALREADYEXISTS",
        "This process already has created a primary surface"},

    {DDERR_NOEMULATION, "DDERR_NOEMULATION",
        "Software emulation not available"},

    {DDERR_REGIONTOOSMALL, "DDERR_REGIONTOOSMALL",
        "Region passed to Clipper::GetClipList is too small"},

    {DDERR_CLIPPERISUSINGHWND, "DDERR_CLIPPERISUSINGHWND",
        "An attempt was made to set a clip list for a clipper objec that is "
        "already monitoring an hwnd"},

    {DDERR_NOCLIPPERATTACHED, "DDERR_NOCLIPPERATTACHED",
        "No clipper object attached to surface object"},

    {DDERR_NOHWND, "DDERR_NOHWND",
        "Clipper notification requires an HWND or no HWND has previously "
        "been set as the CooperativeLevel HWND"},

    {DDERR_HWNDSUBCLASSED, "DDERR_HWNDSUBCLASSED",
        "HWND used by DirectDraw CooperativeLevel has been subclassed, "
        "this prevents DirectDraw from restoring state"},

    {DDERR_HWNDALREADYSET, "DDERR_HWNDALREADYSET",
        "The CooperativeLevel HWND has already been set.  It can not be "
        "reset while the process has surfaces or palettes created"},

    {DDERR_NOPALETTEATTACHED, "DDERR_NOPALETTEATTACHED",
        "No palette object attached to this surface"},

    {DDERR_NOPALETTEHW, "DDERR_NOPALETTEHW",
        "No hardware support for 16 or 256 color palettes"},

    {DDERR_BLTFASTCANTCLIP, "DDERR_BLTFASTCANTCLIP",
        "If a clipper object is attached to the source surface passed "
        "into a BltFast call"},

    {DDERR_NOBLTHW, "DDERR_NOBLTHW",
        "No blitter hardware"},

    {DDERR_NODDROPSHW, "DDERR_NODDROPSHW",
        "No DirectDraw ROP hardware"},

    {DDERR_OVERLAYNOTVISIBLE, "DDERR_OVERLAYNOTVISIBLE",
        "GetOverlayPosition called on a hidden overlay"},

    {DDERR_NOOVERLAYDEST, "DDERR_NOOVERLAYDEST",
        "GetOverlayPosition called on a overlay that "
        "UpdateOverlay has never been called on to establish a destination"},

    {DDERR_INVALIDPOSITION, "DDERR_INVALIDPOSITION",
        "The position of the overlay on the destination is "
        "no longer legal for that destination"},

    {DDERR_NOTAOVERLAYSURFACE, "DDERR_NOTAOVERLAYSURFACE",
        "Overlay member called for a non-overlay surface"},

    {DDERR_EXCLUSIVEMODEALREADYSET, "DDERR_EXCLUSIVEMODEALREADYSET",
        "An attempt was made to set the cooperative level when it was "
        "already set to exclusive"},

    {DDERR_NOTFLIPPABLE, "DDERR_NOTFLIPPABLE",
        "An attempt has been made to flip a surface that is not flippable"},

    {DDERR_CANTDUPLICATE, "DDERR_CANTDUPLICATE",
        "Can't duplicate primary & 3D surfaces, or surfaces that are "
        "implicitly created"},

    {DDERR_NOTLOCKED, "DDERR_NOTLOCKED",
        "Surface was not locked.  An attempt to unlock a surface that was "
        "not locked at all, or by this process, has been attempted"},

    {DDERR_CANTCREATEDC, "DDERR_CANTCREATEDC",
        "Windows can not create any more DCs"},

    {DDERR_NODC, "DDERR_NODC",
        "No DC was ever created for this surface"},

    {DDERR_WRONGMODE, "DDERR_WRONGMODE",
        "This surface can not be restored because it was created in a "
        "different mode"},

    {DDERR_IMPLICITLYCREATED, "DDERR_IMPLICITLYCREATED",
        "This surface can not be restored because it is an implicitly "
        "created surface"},

    {DDERR_NOTPALETTIZED, "DDERR_NOTPALETTIZED",
        "The surface being used is not a palette-based surface"},

    {DDERR_UNSUPPORTEDMODE, "DDERR_UNSUPPORTEDMODE",
        "The display is currently in an unsupported mode"},


    /******************/
    /*** D3D Errors ***/
    /******************/


    {D3DERR_BADMAJORVERSION, "D3DERR_BADMAJORVERSION",
        "Bad major version"},

    {D3DERR_BADMINORVERSION, "D3DERR_BADMINORVERSION",
        "Bad minor version"},

    {D3DERR_DEVICEAGGREGATED, "D3DERR_DEVICEAGGREGATED",
        "SetRenderTarget attempted on a device "
        "that was QI'd off the render target"},

    {D3DERR_EXECUTE_CREATE_FAILED, "D3DERR_EXECUTE_CREATE_FAILED",
        "Execute buffer create failed"},

    {D3DERR_EXECUTE_DESTROY_FAILED, "D3DERR_EXECUTE_DESTROY_FAILED",
        "Execute buffer destroy failed"},

    {D3DERR_EXECUTE_LOCK_FAILED, "D3DERR_EXECUTE_LOCK_FAILED",
        "Execute buffer lock failed"},

    {D3DERR_EXECUTE_UNLOCK_FAILED, "D3DERR_EXECUTE_UNLOCK_FAILED",
        "Execute buffer unlock failed"},

    {D3DERR_EXECUTE_LOCKED, "D3DERR_EXECUTE_LOCKED",
        "Execute buffer locked"},

    {D3DERR_EXECUTE_NOT_LOCKED, "D3DERR_EXECUTE_NOT_LOCKED",
        "Execute buffer not locked"},

    {D3DERR_EXECUTE_FAILED, "D3DERR_EXECUTE_FAILED",
        "Execute buffer execute failed"},

    {D3DERR_EXECUTE_CLIPPED_FAILED, "D3DERR_EXECUTE_CLIPPED_FAILED",
        "Execute buffer execute clipped failed"},

    {D3DERR_TEXTURE_NO_SUPPORT, "D3DERR_TEXTURE_NO_SUPPORT",
        "Texture not supported"},

    {D3DERR_TEXTURE_CREATE_FAILED, "D3DERR_TEXTURE_CREATE_FAILED",
        "Texture create failed"},

    {D3DERR_TEXTURE_DESTROY_FAILED, "D3DERR_TEXTURE_DESTROY_FAILED",
        "Texture destroy failed"},

    {D3DERR_TEXTURE_LOCK_FAILED, "D3DERR_TEXTURE_LOCK_FAILED",
        "Texture lock failed"},

    {D3DERR_TEXTURE_UNLOCK_FAILED, "D3DERR_TEXTURE_UNLOCK_FAILED",
        "Texture unlock failed"},

    {D3DERR_TEXTURE_LOAD_FAILED, "D3DERR_TEXTURE_LOAD_FAILED",
        "Texture load failed"},

    {D3DERR_TEXTURE_SWAP_FAILED, "D3DERR_TEXTURE_SWAP_FAILED",
        "Texture swap failed"},

    {D3DERR_TEXTURE_LOCKED, "D3DERR_TEXTURE_LOCKED",
        "Texture locked"},

    {D3DERR_TEXTURE_NOT_LOCKED, "D3DERR_TEXTURE_NOT_LOCKED",
        "Texture not locked"},

    {D3DERR_TEXTURE_GETSURF_FAILED, "D3DERR_TEXTURE_GETSURF_FAILED",
        "Texture get surface failed"},

    {D3DERR_MATRIX_CREATE_FAILED, "D3DERR_MATRIX_CREATE_FAILED",
        "Matrix create failed"},

    {D3DERR_MATRIX_DESTROY_FAILED, "D3DERR_MATRIX_DESTROY_FAILED",
        "Matrix destroy failedj"},

    {D3DERR_MATRIX_SETDATA_FAILED, "D3DERR_MATRIX_SETDATA_FAILED",
        "Matrix set data failed"},

    {D3DERR_MATRIX_GETDATA_FAILED, "D3DERR_MATRIX_GETDATA_FAILED",
        "Matrix get data failed"},

    {D3DERR_SETVIEWPORTDATA_FAILED, "D3DERR_SETVIEWPORTDATA_FAILED",
        "Set viewport data failed"},

    {D3DERR_INVALIDCURRENTVIEWPORT, "D3DERR_INVALIDCURRENTVIEWPORT", 
        "Current viewport is invalid"},

    {D3DERR_INVALIDPRIMITIVETYPE, "D3DERR_INVALIDPRIMITIVETYPE",
        "Primitive type is invalid"},

    {D3DERR_INVALIDVERTEXTYPE, "D3DERR_INVALIDVERTEXTYPE",
        "Vertex type is invalid"},

    {D3DERR_TEXTURE_BADSIZE, "D3DERR_TEXTURE_BADSIZE",
        "Texture has bad size"},

    {D3DERR_MATERIAL_CREATE_FAILED, "D3DERR_MATERIAL_CREATE_FAILED",
        "Material create failed"},

    {D3DERR_MATERIAL_DESTROY_FAILED, "D3DERR_MATERIAL_DESTROY_FAILED",
        "Material destroy failed"},

    {D3DERR_MATERIAL_SETDATA_FAILED, "D3DERR_MATERIAL_SETDATA_FAILED",
        "Material set data failed"},

    {D3DERR_MATERIAL_GETDATA_FAILED, "D3DERR_MATERIAL_GETDATA_FAILED",
        "Material get data failed"},

    {D3DERR_INVALIDPALETTE, "D3DERR_INVALIDPALETTE",
        "Color palette is bad"},

    {D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY, "D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY",
        "ZBuffer needs system memory"},

    {D3DERR_ZBUFF_NEEDS_VIDEOMEMORY, "D3DERR_ZBUFF_NEEDS_VIDEOMEMORY",
        "ZBuffer needs video memory"},

    {D3DERR_SURFACENOTINVIDMEM, "D3DERR_SURFACENOTINVIDMEM",
        "Surface is not in video memory"},

    {D3DERR_LIGHT_SET_FAILED, "D3DERR_LIGHT_SET_FAILED",
        "Light set failed"},

    {D3DERR_LIGHTHASVIEWPORT, "D3DERR_LIGHTHASVIEWPORT",
        ""},

    {D3DERR_LIGHTNOTINTHISVIEWPORT, "D3DERR_LIGHTNOTINTHISVIEWPORT",
        ""},

    {D3DERR_SCENE_IN_SCENE, "D3DERR_SCENE_IN_SCENE",
        "Scene in scene"},

    {D3DERR_SCENE_NOT_IN_SCENE, "D3DERR_SCENE_NOT_IN_SCENE",
        "Scene not in scene"},

    {D3DERR_SCENE_BEGIN_FAILED, "D3DERR_SCENE_BEGIN_FAILED",
        "Scene begin failed"},

    {D3DERR_SCENE_END_FAILED, "D3DERR_SCENE_END_FAILED",
        "Scene end failed"},

    {D3DERR_INBEGIN, "D3DERR_INBEGIN",
        ""},

    {D3DERR_NOTINBEGIN, "D3DERR_NOTINBEGIN",
        ""},

    {D3DERR_NOVIEWPORTS, "D3DERR_NOVIEWPORTS",
        ""},

    {D3DERR_VIEWPORTDATANOTSET, "D3DERR_VIEWPORTDATANOTSET",
        ""},

    {D3DERR_VIEWPORTHASNODEVICE, "D3DERR_VIEWPORTHASNODEVICE",
        ""},


    /*************************************/
    /*** Direct3D Retained-Mode Errors ***/
    /*************************************/

    {D3DRMERR_BADOBJECT, "D3DRMERR_BADOBJECT",
        "Object expected in argument"},

    {D3DRMERR_BADTYPE, "D3DRMERR_BADTYPE",
        "Bad argument type passed"},

    {D3DRMERR_BADALLOC, "D3DRMERR_BADALLOC",
        "Out of memory"},

    {D3DRMERR_FACEUSED, "D3DRMERR_FACEUSED",
        "Face already used in a mesh"},

    {D3DRMERR_NOTFOUND, "D3DRMERR_NOTFOUND",
        "Object not found in specified place"},

    {D3DRMERR_NOTDONEYET, "D3DRMERR_NOTDONEYET",
        "Unimplemented"},

    {D3DRMERR_FILENOTFOUND, "D3DRMERR_FILENOTFOUND",
        "File cannot be opened"},

    {D3DRMERR_BADFILE, "D3DRMERR_BADFILE",
        "Data file is corrupt or has incorrect format"},

    {D3DRMERR_BADDEVICE, "D3DRMERR_BADDEVICE",
        "Device is not compatible with renderer"},

    {D3DRMERR_BADVALUE, "D3DRMERR_BADVALUE",
        "Bad argument value passed"},

    {D3DRMERR_BADMAJORVERSION, "D3DRMERR_BADMAJORVERSION",
        "Bad DLL major version"},

    {D3DRMERR_BADMINORVERSION, "D3DRMERR_BADMINORVERSION",
        "Bad DLL minor version"},

    {D3DRMERR_UNABLETOEXECUTE, "D3DRMERR_UNABLETOEXECUTE",
        "Unable to carry out procedure"},

    {D3DRMERR_LIBRARYNOTFOUND, "D3DRMERR_LIBRARYNOTFOUND",
        "Library not found"},

    {D3DRMERR_INVALIDLIBRARY, "D3DRMERR_INVALIDLIBRARY",
        "Invalid library"},

    {D3DRMERR_PENDING, "D3DRMERR_PENDING",
        "Data required to supply the requested information "
        "has not finished loading"},

    {D3DRMERR_NOTENOUGHDATA, "D3DRMERR_NOTENOUGHDATA",
        "Not enough data has been loaded to perform the requested operation"},

    {D3DRMERR_REQUESTTOOLARGE, "D3DRMERR_REQUESTTOOLARGE",
        "An attempt was made to set a level of detail in a progressive mesh "
        "greater than the maximum available"},

    {D3DRMERR_REQUESTTOOSMALL, "D3DRMERR_REQUESTTOOSMALL",
        "An attempt was made to set the minimum rendering detail of a "
        "progressive mesh smaller than the detail in the base mesh "
        "(the minimum for rendering)"},

    {D3DRMERR_CONNECTIONLOST, "D3DRMERR_CONNECTIONLOST",
        "Data connection was lost during a load, clone, or duplicate"},

    {D3DRMERR_LOADABORTED, "D3DRMERR_LOADABORTED",
        "Load aborted"},

    {D3DRMERR_NOINTERNET, "D3DRMERR_NOINTERNET",
        "Not Internet"},

    {D3DRMERR_BADCACHEFILE, "D3DRMERR_BADCACHEFILE",
        "Bad cache file"},

    {D3DRMERR_BOXNOTSET, "D3DRMERR_BOXNOTSET",
        "An attempt was made to access a bounding box when no bounging box "
        "was set on the frame" },

    {D3DRMERR_BADPMDATA, "D3DRMERR_BADPMDATA",
        "The data in the .x file is corrupted or of an incorrect format.  "
        "The conversion to a progressive mesh succeeded but produced an "
        "invalid progressive mesh in the .x file" },

    {D3DRMERR_CLIENTNOTREGISTERED, "D3DRMERR_CLIENTNOTREGISTERED",
        "Client not registered"},

    {D3DRMERR_NOTCREATEDFROMDDS, "D3DRMERR_NOTCREATEDFROMDDS",
        "Not created from DDS"},

    {D3DRMERR_NOSUCHKEY, "D3DRMERR_NOSUCHKEY",
        "No such key"},

    {D3DRMERR_INCOMPATABLEKEY, "D3DRMERR_INCOMPATABLEKEY",
        "Incompatable key"},

    {D3DRMERR_ELEMENTINUSE, "D3DRMERR_ELEMENTINUSE",
        "Element in use"},


    /***************************/
    /*** Direct Sound Errors ***/
    /***************************/

    {DSERR_ALLOCATED, "DSERR_ALLOCATED",
        "resources already being used"},

    {DSERR_CONTROLUNAVAIL, "DSERR_CONTROLUNAVAIL",
        "control (vol,pan,etc.) requested by the caller not available"},

    {DSERR_INVALIDPARAM, "DSERR_INVALIDPARAM",
        "invalid parameter was passed to the returning function"},

    {DSERR_INVALIDCALL, "DSERR_INVALIDCALL",
        "call not valid for current state of object"},

    {DSERR_GENERIC, "DSERR_GENERIC",
        "undetermined error occured inside DSound subsystem"},

    {DSERR_PRIOLEVELNEEDED, "DSERR_PRIOLEVELNEEDED",
        "invalid priority level"},

    {DSERR_OUTOFMEMORY, "DSERR_OUTOFMEMORY",
        "Out of memory"},

    {DSERR_BADFORMAT, "DSERR_BADFORMAT",
        "PCM format not supported"},

    {DSERR_UNSUPPORTED, "DSERR_UNSUPPORTED",
        "The function called is not supported at this time"},

    {DSERR_NODRIVER, "DSERR_NODRIVER",
        "No sound driver is available for use"},

    {DSERR_NOINTERFACE, "DSERR_NODRIVER",
        "Requested COM interface not available"},

    {DSERR_ALREADYINITIALIZED, "DSERR_ALREADYINITIALIZED",
        "object already initialized"},

    {DSERR_NOAGGREGATION, "DSERR_NOAGGREGATION",
        "object does not support aggregation"},

    {DSERR_BUFFERLOST, "DSERR_BUFFERLOST",
        "buffer memory lost, must be restored"},

    {DSERR_OTHERAPPHASPRIO, "DSERR_OTHERAPPHASPRIO",
        "Another app has higher priority level causing failure"},

    {DSERR_UNINITIALIZED, "DSERR_UNINITIALIZED",
        "Direct Sound Object uninitialized"},

    
    /************************************/
    /*** DX2D/DXTRANSFORMS error msgs ***/
    /************************************/

    {DXTERR_UNINITIALIZED, "DXTERR_UNINITIALIZED",
     "The object (transform, surface, etc.) has not been properly initialized"},

    {DXTERR_ALREADY_INITIALIZED, "DXTERR_ALREADY_INITIALIZED",
     "The object (surface) has already been properly initialized"},

    {DXTERR_UNSUPPORTED_FORMAT, "DXTERR_UNSUPPORTED_FORMAT",
     "The caller has specified an unsupported format"},

    {DXTERR_COPYRIGHT_IS_INVALID, "DXTERR_COPYRIGHT_IS_INVALID",
     "The caller has specified an unsupported format"},

    {DXTERR_INVALID_BOUNDS, "DXTERR_INVALID_BOUNDS",
     "The caller has specified invalid bounds for this operation"},

    {DXTERR_INVALID_FLAGS, "DXTERR_INVALID_FLAGS",
     "The caller has specified invalid flags for this operation"},

    {DXT_S_HITOUTPUT, "DXT_S_HITOUTPUT",
     "The specified point intersects the generated output"},

    /************************************/
    /*** Miscellaneous Windows Errors ***/
    /************************************/

    {ERROR_INVALID_PARAMETER, "ERROR_INVALID_PARAMETER",
     "Invalid parameter" },

    {ERROR_NOT_ENOUGH_MEMORY, "ERROR_NOT_ENOUGH_MEMORY",
     "Insufficient memory available" },

    {ERROR_OUTOFMEMORY, "ERROR_OUTOFMEMORY", "Out of memory" },

    {E_NOINTERFACE, "E_NOINTERFACE", "No such interface supported" },

    {E_POINTER, "E_POINTER", "Invalid pointer" },

    {CLASS_E_CLASSNOTAVAILABLE, "CLASS_E_CLASSNOTAVAILABLE",
        "ClassFactory cannot supply requested class" },

    {0,0,0}
};



/*****************************************************************************
This function takes a return code and returns the corresponding error string.
*****************************************************************************/

HresultInfo *GetHresultInfo (HRESULT hresult)
{
    // Scan through the entries until we either hit the zero code, or until
    // we get a match.

    HresultInfo *hresinfo = errtable;

    while ((hresinfo->hresult != hresult) && (hresinfo->hresult != 0))
        ++ hresinfo;

    return (hresinfo->hresult) ? hresinfo : NULL;
}



/*****************************************************************************
This debugger-callable function dumps out information for a given HRESULT
value.
*****************************************************************************/

void hresult (HRESULT hresult)
{
    if (0 == hresult)
    {   OutputDebugString ("HRESULT 0x0 = NO_ERROR\n");
        return;
    }

    char outbuff[240];

    sprintf (outbuff, "HRESULT %08x [Facility 0x%x, Code 0x%x (%d)]\n",
        hresult, HRESULT_FACILITY(hresult),
        HRESULT_CODE(hresult), HRESULT_CODE(hresult));

    OutputDebugString (outbuff);

    // Find the matching hresinfo entry.

    HresultInfo *hresinfo = GetHresultInfo(hresult);

    if (hresinfo)
    {
        sprintf (outbuff, "    %s: %s\n    %s\n",
            FacilityString(hresult), hresinfo->hresult_str,
            hresinfo->explanation);
    }
    else
    {   sprintf (outbuff, "    Facility %s\n", FacilityString(hresult));
    }

    OutputDebugString (outbuff);
}


#endif /* DEVELOPER_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\loadjpeg.cpp ===
//////////////////////////////////////////////////////////////////////////
// Copyright 1996 Microsoft Corporation
// All Rights Reserved.
//
// LoadJPEG.CPP
//
// Load a JPEG image from a file and create a DIBSECTION bitmap
// Uses code from the Independent JPEG group's JPEG decompression library
//

#include "headers.h"
#include <memory.h>
#include <string.h>
#include <jpeglib.h>
#include "privinc/dastream.h"

// Error handling code for IJG's decompressor
#include <setjmp.h>

/////////////////////////////////////////////////////////////////////////
struct my_error_mgr {
  struct jpeg_error_mgr pub;
  jmp_buf setjmp_buffer;
};

typedef struct my_error_mgr * my_error_ptr;

////////////////////////////////////////////////////////////////////////
METHODDEF void my_error_exit ( j_common_ptr cinfo) {
  my_error_ptr myerr = (my_error_ptr) cinfo->err;

/* Return control to the setjmp point */
  longjmp(myerr->setjmp_buffer, 1);
}

//////////////////////////////////////////////////////////////////////////
HBITMAP _jpeg_create_bitmap(j_decompress_ptr cinfo) {
  int bytes_per_line;
  LPBYTE  image    = NULL;
  LPBITMAPINFO pBi = NULL;
  HBITMAP hImage   = NULL;
  LPBYTE pBuffer;

// Set up windows bitmap info header
//
  pBi = (LPBITMAPINFO) ThrowIfFailed(malloc(sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD))));
  if (NULL == pBi) return NULL; // couldn't allocate bitmap info structure

  pBi->bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
  pBi->bmiHeader.biWidth    =   cinfo->output_width;
  pBi->bmiHeader.biHeight   = - (int) cinfo->output_height;
  pBi->bmiHeader.biPlanes   = 1;
  pBi->bmiHeader.biBitCount = 8;
  pBi->bmiHeader.biCompression   = BI_RGB;
  pBi->bmiHeader.biSizeImage     = 0;
  pBi->bmiHeader.biXPelsPerMeter = 0;
  pBi->bmiHeader.biYPelsPerMeter = 0;
  pBi->bmiHeader.biClrUsed       = 0;   // maximum # of colors
  pBi->bmiHeader.biClrImportant  = 0;   // all colors are important

// If the decompressor has quantized the color to 8-bit for us.
//
  if (cinfo->quantize_colors) {

    int byteperpix = 1; //cinfo->output_components;

// Set up palette for new image

    int i;   // Loop Counter

    switch (cinfo->jpeg_color_space) {

        case JCS_GRAYSCALE:
            for (i=0;  i < 256;  ++i) {
                pBi->bmiColors[i].rgbRed   =
                pBi->bmiColors[i].rgbGreen =
                pBi->bmiColors[i].rgbBlue  = cinfo->colormap[0][i];
                pBi->bmiColors[i].rgbReserved = 0;
            }
            break;

        case JCS_YCbCr:
            // YUV entries are already converted to RGB.
            // ** FALL THROUGH **

        case JCS_RGB:
            for (i=0;  i < 256;  ++i) {
                pBi->bmiColors[i].rgbRed   = cinfo->colormap[2][i];
                pBi->bmiColors[i].rgbGreen = cinfo->colormap[1][i];
                pBi->bmiColors[i].rgbBlue  = cinfo->colormap[0][i];
                pBi->bmiColors[i].rgbReserved = 0;
            }
            break;

        case JCS_YCCK:
            // YUV entries are already converted to RGB.
            // ** FALL THROUGH **

        case JCS_CMYK:
            // For CMYK, the CMY channels have already been converted to RGB,
            // and the K channel has been inverted.  The CMY entries have been
            // scaled to the range [0,255], covering the spectrum in [K,255].
            // For example, C' = K + (C/255)(255-K).

            for (i=0;  i < 256;  ++i) {
                unsigned int C = 255 - cinfo->colormap[0][i];
                unsigned int M = 255 - cinfo->colormap[1][i];
                unsigned int Y = 255 - cinfo->colormap[2][i];
                unsigned int K = 255 - cinfo->colormap[3][i];

                pBi->bmiColors[i].rgbRed   = (BYTE)(255 - (K+C-((C*K)/255)));
                pBi->bmiColors[i].rgbGreen = (BYTE)(255 - (K+M-((M*K)/255)));
                pBi->bmiColors[i].rgbBlue  = (BYTE)(255 - (K+Y-((Y*K)/255)));
                pBi->bmiColors[i].rgbReserved = 0;
            }
            break;

        default:
            // If the colorspace is unknown or unhandled, then leave the
            // color lookup table as-is.

            Assert (!"Unknown or unhandled JPEG colorspace.");
            break;
    }

    bytes_per_line = (cinfo->output_width + 3) & -4; // even # of DWORDs

// Else, if the compressor has not quantized color (and we're either a
// grey scale or a 24bpp image)
//
  } else {

// Make sure it's a format we can handle. (BUGBUG - For now, we only handle
// 24bpp color)
//
    int byteperpix = cinfo->out_color_components;
    if (byteperpix != 3) goto jpeg_error;

    pBi->bmiHeader.biBitCount = byteperpix * 8;

    bytes_per_line = ((cinfo->output_width * byteperpix) + 3) & -4;

  }

// Create our DIBSECTION bitmap...
//
  hImage = CreateDIBSection(NULL,pBi,DIB_RGB_COLORS,(LPVOID *) &image,NULL,0);
  if (NULL == hImage) goto jpeg_error;

// Read the image data
//
  pBuffer = image;

  while (cinfo->output_scanline < cinfo->output_height) {
    jpeg_read_scanlines(cinfo, &pBuffer, 1);
    pBuffer += bytes_per_line;
  }

  free (pBi);
  return hImage;

jpeg_error:
  if (pBi) free (pBi);
  if (hImage) DeleteObject(hImage);

  return NULL;
}

///////////////////////////////////////////////////////////////////////////
HBITMAP LoadJPEGImage(LPCSTR filename,int dx,int dy) {
  FILE* infile;    /* source file */
  struct jpeg_decompress_struct cinfo; //the IJG jpeg structure
  struct my_error_mgr jerr;

  dx; dy; // just for reference
  // disable our jpeg decoder
  if (1) return NULL;

  if ((infile = fopen(filename, "rb")) == NULL) return NULL;

// Step 1: allocate and initialize JPEG decompression object
// We set up the normal JPEG error routines, then override error_exit.
//
  cinfo.err = jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;

// Establish the setjmp return context for my_error_exit to use.
// If we get here, the JPEG code has signaled an error.
// We need to clean up the JPEG object, close the input file, and return.
//
  if (setjmp(jerr.setjmp_buffer)) {
    jpeg_destroy_decompress(&cinfo);
    fclose(infile);
    return (HBITMAP)NULL;
  }

// Now we can initialize the JPEG decompression object.
//
  jpeg_create_decompress(&cinfo);

/* Step 2: specify data source (eg, a file) */

  jpeg_stdio_src(&cinfo, infile);

/* Step 3: read file parameters with jpeg_read_header() */

  (void) jpeg_read_header(&cinfo, TRUE);
/* We can ignore the return value from jpeg_read_header since
 *   (a) suspension is not possible with the stdio data source, and
 *   (b) we passed TRUE to reject a tables-only JPEG file as an error.
 * See libjpeg.doc for more info.
*/

/* Step 4: set parameters for decompression */
  if(cinfo.out_color_space == JCS_GRAYSCALE)
  {
    cinfo.quantize_colors = TRUE;
  }
  else
  {
// Bugbug - this limits us to 8-bit color for now!
//
    cinfo.quantize_colors = TRUE;
  }

/* In this example, we don't need to change any of the defaults set by
 * jpeg_read_header(), so we do nothing here.
*/

  /* Step 5: Start decompressor */

  (void) jpeg_start_decompress(&cinfo);
  /* We can ignore the return value since suspension is not possible
   * with the stdio data source.
   */


  /* Step 6: while (scan lines remain to be read) */
  /*           jpeg_read_scanlines(...); */
   HBITMAP hImage = _jpeg_create_bitmap(&cinfo);

  /* Step 7: Finish decompression */
 
  (void) jpeg_finish_decompress(&cinfo);

  /* Step 8: Release JPEG decompression object */
  jpeg_destroy_decompress(&cinfo);

  /* After finish_decompress, we can close the input file.
   * Here we postpone it until after no more JPEG errors are possible,
   * so as to simplify the setjmp error logic above.  (Actually, I don't
   * think that jpeg_destroy can do an error exit, but why assume anything...)
   */
  fclose(infile);

  return hImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\mutex.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the classes that simplify mutex programming.

--*/

#include "headers.h"
#include <windows.h>
#include "privinc/mutex.h"

////////////////////////  Mutexes  //////////////////////////////

Mutex::Mutex()
{
    HANDLE m = CreateMutex(NULL,  // default security
                           FALSE, // don't initially assume ownership
                           NULL); // no name

    if (m == NULL) {
        RaiseException_InternalError("Mutex creation failed");
    }

    // Stash in new object as a void*.  NOTE: This cast is only valid
    // if HANDLE is the same size as a void *, that is, HANDLE is
    // presumed to be a pointer (which it is in Win32).  We do this
    // cast so that mutex.h doesn't need to mention HANDLE in its
    // declarations, otherwise we would have to #include <windows.h>
    // there.
    Assert((sizeof(void *) == sizeof(HANDLE)) && "HANDLE and void * are not the same size");

    mutex = (void *)m;
}

Mutex::~Mutex()
{
    if (!CloseHandle((HANDLE)mutex)) {
        RaiseException_InternalError("Mutex destruction failed");
    }
}

void
Mutex::Grab()
{
    // Wait potentially forever for the mutex to be available, and
    // then grab it.  TODO:  May be overly naive.  May need to add a
    // timeout, or some indication of the conditions under which this
    // function returns.
    if (WaitForSingleObject((HANDLE)mutex, INFINITE) == WAIT_FAILED) {
        RaiseException_InternalError("Attempt to grab mutex failed.");
    }
}

void
Mutex::Release()
{
    if (!ReleaseMutex((HANDLE)mutex)) {
        RaiseException_InternalError(
          "Mutex release failed.  Releasing thread doesn't own the mutex");
    }
}

////// Mutex Grabber //////

MutexGrabber::MutexGrabber(Mutex& m, Bool grabIt)
: mutex(m), grabbed(grabIt)
{
    if (grabIt) mutex.Grab();
}

MutexGrabber::~MutexGrabber()
{
    if (grabbed) mutex.Release();
}

////////////////////////  CritSect  //////////////////////////////

CritSect::CritSect()
{
    InitializeCriticalSection(&_cs) ;
}

CritSect::~CritSect()
{
    DeleteCriticalSection(&_cs) ;
}

void
CritSect::Grab()
{
    EnterCriticalSection(&_cs) ;
}

void
CritSect::Release()
{
    LeaveCriticalSection(&_cs) ;
}

////// CritSect Grabber //////

CritSectGrabber::CritSectGrabber(CritSect& cs, Bool grabIt)
: _cs(cs), grabbed(grabIt)
{
    if (grabIt) _cs.Grab();
}

CritSectGrabber::~CritSectGrabber()
{
    if (grabbed) _cs.Release();
}

/////////////////////////  Semaphores  //////////////////////

Semaphore::Semaphore(int initialCount, int maxCount)
{
    HANDLE s = CreateSemaphore(NULL,  // default security
                               initialCount,
                               maxCount,
                               NULL); // no name

    if (s == NULL) {
        RaiseException_InternalError("Semaphore creation failed");
    }

    // Stash in new object as a void*.  NOTE: This cast is only valid
    // if HANDLE is the same size as a void *, that is, HANDLE is
    // presumed to be a pointer (which it is in Win32).  We do this
    // cast so that mutex.h doesn't need to mention HANDLE in its
    // declarations, otherwise we would have to #include <windows.h>
    // there.
    Assert((sizeof(void *) == sizeof(HANDLE)) && "HANDLE and void * are not the same size");

    _semaphore = (void *)s;

#if _DEBUG
    _count = initialCount;
    _maxCount = maxCount;
#endif
    
}

Semaphore::~Semaphore()
{
    if (!CloseHandle((HANDLE)_semaphore)) {
        RaiseException_InternalError("Semaphore destruction failed");
    }
}

void
Semaphore::Decrement(int times)
{
    // Wait potentially forever for the semaphore to be available, and
    // then grab it.  TODO:  May be overly naive.  May need to add a
    // timeout, or some indication of the conditions under which this
    // function returns.

    // Note that we go through this loop 'times' times, as specified
    // by the call to Decrement().
    for (int i = 0; i < times; i++) {
        if (WaitForSingleObject((HANDLE)_semaphore, INFINITE) ==
            WAIT_FAILED) {
            RaiseException_InternalError("Attempt to grab Semaphore failed.");
        }
    }

#if _DEBUG
    _count--;
#endif    

}

int
Semaphore::Increment(int times)
{
    // Release with count increment specified in 'times'.
    LONG previousCount;
    if (!ReleaseSemaphore((HANDLE)_semaphore, times, &previousCount)) {
        RaiseException_InternalError("Semaphore release failed");
    }

#if _DEBUG
    _count += times;
    Assert(_count <= _maxCount);
//    Assert(_count == previousCount + times);
#endif

    return previousCount + times;
}

Win32Event::Win32Event(bool bManualReset,bool bInitState)
: _bManual(bManualReset)
{
    _hEvent = CreateEvent(NULL,
                          bManualReset,
                          bInitState,
                          NULL);

    if (_hEvent == NULL)
        RaiseException_InternalError("Could not create event");
}

Win32Event::~Win32Event()
{
    if (_hEvent && !CloseHandle(_hEvent))
        RaiseException_InternalError("Could not close event");
}

void
Win32Event::Wait()
{
    if (WaitForSingleObject(_hEvent, INFINITE) == WAIT_FAILED)
        RaiseException_InternalError("Attempt to wait on event failed.");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\privpref.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    General implementation of user preference management

*******************************************************************************/


#include "headers.h"
#include "privinc/comutil.h"
#include "privinc/privpref.h"
#include "privinc/registry.h"

bool bShowFPS;  // flag for showing the frame rate.


PrivatePreferences::PrivatePreferences()
{
    // Load up the 3D preferences from the registry.
    IntRegistryEntry lightColorMode ("3D", PREF_3D_RGB_LIGHTING,    1);
    IntRegistryEntry fillMode       ("3D", PREF_3D_FILL_MODE,       0);
    IntRegistryEntry shadeMode      ("3D", PREF_3D_SHADE_MODE,      1);
    IntRegistryEntry dithering      ("3D", PREF_3D_DITHER_ENABLE,   1);
    IntRegistryEntry perspCorr      ("3D", PREF_3D_PERSP_CORRECT,   1);
    IntRegistryEntry texmapping     ("3D", PREF_3D_TEXTURE_ENABLE,  1);
    IntRegistryEntry texquality     ("3D", PREF_3D_TEXTURE_QUALITY, 0);
    IntRegistryEntry useHW          ("3D", PREF_3D_USEHW,           1);
    IntRegistryEntry useMMX         ("3D", PREF_3D_USEMMX,          0x2);

    IntRegistryEntry worldLighting  ("3D", PREF_3D_WORLDLIGHTING,   0);

    // 2D Preferences
    IntRegistryEntry colorKeyR_ModeEntry("2D", PREF_2D_COLOR_KEY_RED, 1);
    IntRegistryEntry colorKeyG_ModeEntry("2D", PREF_2D_COLOR_KEY_GREEN, 254);
    IntRegistryEntry colorKeyB_ModeEntry("2D", PREF_2D_COLOR_KEY_BLUE, 245);

    // Engine preferences
    IntRegistryEntry maxFPS("Engine", PREF_ENGINE_MAX_FPS, 30);
    IntRegistryEntry perfReporting("Engine", "Enable Performance Reporting", 0);
    IntRegistryEntry engineOptimizationEntry("Engine",
                                             PREF_ENGINE_OPTIMIZATIONS_ON,
                                             1);
    IntRegistryEntry engineRetainedMode("Engine", PREF_ENGINE_RETAINEDMODE, 0);

    // Statistics...
    IntRegistryEntry gcStatEntry("Engine", "GC Stat", 1);
    IntRegistryEntry jitterStatEntry("Engine", "Jitter Stat", 1);
    IntRegistryEntry heapSizeStatEntry("Engine", "Heap Size Stat", 1);
    IntRegistryEntry dxStatEntry("Engine", "DirectX Stat", 1);

    // Overrid preference.  If 1, the preferences that come from the
    // application are ignored, and the ones from the registry always
    // win.
    IntRegistryEntry overrideAppPrefs("Engine",
                                      PREF_ENGINE_OVERRIDE_APP_PREFS,
                                      0);

    _overrideMode = (overrideAppPrefs.GetValue() != 0);

    // 3D Preferences
    _rgbMode = (lightColorMode.GetValue() != 0);

    _fillMode = fillMode.GetValue();
    _shadeMode = shadeMode.GetValue();

    _dithering      = (dithering.GetValue() != 0);
    _texmapPerspect = (perspCorr.GetValue() != 0);
    _texmapping     = (texmapping.GetValue() != 0);

    _texturingQuality = texquality.GetValue();

    _useHW  = useHW.GetValue();
    _useMMX = useMMX.GetValue();

    _worldLighting = worldLighting.GetValue();

    // 2D Preferences
    _clrKeyR = colorKeyR_ModeEntry.GetValue();
    _clrKeyG = colorKeyG_ModeEntry.GetValue();
    _clrKeyB = colorKeyB_ModeEntry.GetValue();


    // Engine preferences
    _gcStat = gcStatEntry.GetValue();
    _jitterStat = jitterStatEntry.GetValue() != 0;
    _heapSizeStat = heapSizeStatEntry.GetValue() != 0;
    _dxStat = dxStatEntry.GetValue() != 0;
    _engineOptimization = engineOptimizationEntry.GetValue();

    if (maxFPS.GetValue())
        _minFrameDuration = 1 / (double) maxFPS.GetValue();
    else
        _minFrameDuration = 0.0;

    #if !_DEBUG
        if(perfReporting.GetValue())
            bShowFPS = true;    // we want to show the FPS...
    #endif

    _spritify = engineRetainedMode.GetValue();

    // Non-registry preferences.

    _dirtyRectsOn = true;
    _BitmapCachingOn = true;
    _dynamicConstancyAnalysisOn = true;
    _volatileRenderingSurface = true;
}

HRESULT
GetVariantBool(VARIANT& v, Bool *b)
{
    VARIANT *pVar;

    if (V_ISBYREF(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    CComVariant vnew;

    if (FAILED(vnew.ChangeType(VT_BOOL, pVar)))
        return DISP_E_TYPEMISMATCH;

    *b = V_BOOL(&vnew);
    return S_OK;
}

HRESULT
GetVariantInt(VARIANT& v, int *i)
{
    VARIANT *pVar;

    if (V_ISBYREF(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    CComVariant vnew;

    if (FAILED(vnew.ChangeType(VT_I4, pVar)))
        return DISP_E_TYPEMISMATCH;

    *i = V_I4(&vnew);
    return S_OK;
}

HRESULT
GetVariantDouble(VARIANT& v, double *dbl)
{
    VARIANT *pVar;

    if (V_ISBYREF(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    CComVariant vnew;

    if (FAILED(vnew.ChangeType(VT_R8, pVar)))
        return DISP_E_TYPEMISMATCH;

    *dbl = V_R8(&vnew);
    return S_OK;
}

HRESULT
PrivatePreferences::DoPreference(char *prefName,
                                 Bool puttingPref,
                                 VARIANT *pV)
{
    HRESULT hr = S_OK;
    Bool b;
    double dbl;
    int i;

    if (!puttingPref) {
        VariantClear(pV);
    }

    INT_ENTRY(PREF_2D_COLOR_KEY_BLUE,  _clrKeyB);
    INT_ENTRY(PREF_2D_COLOR_KEY_GREEN, _clrKeyG);
    INT_ENTRY(PREF_2D_COLOR_KEY_RED,   _clrKeyR);

    INT_ENTRY  (PREF_3D_FILL_MODE,       _fillMode);
    INT_ENTRY  (PREF_3D_TEXTURE_QUALITY, _texturingQuality);
    INT_ENTRY  (PREF_3D_SHADE_MODE,      _shadeMode);
    BOOL_ENTRY (PREF_3D_RGB_LIGHTING,    _rgbMode);
    BOOL_ENTRY (PREF_3D_DITHER_ENABLE,   _dithering);
    BOOL_ENTRY (PREF_3D_PERSP_CORRECT,   _texmapPerspect);
    INT_ENTRY  (PREF_3D_USEMMX,          _useMMX);

    BOOL_ENTRY(PREF_ENGINE_OPTIMIZATIONS_ON, _engineOptimization);

    if (0 == lstrcmp(prefName, "Max FPS")) {

        if (puttingPref) {
            EXTRACT_DOUBLE(*pV, &dbl);
            _minFrameDuration = (dbl == 0.0 ? 0.0 : 1.0 / dbl);
        } else {
            b = (_minFrameDuration == 0.0 ? 0.0 : 1.0 / _minFrameDuration);
            INJECT_DOUBLE(b, pV);
        }

        return S_OK;
    }

    // Only allow getting of the Override property and the 3D hw usage
    // property...
    if (!puttingPref) {
        BOOL_ENTRY(PREF_ENGINE_OVERRIDE_APP_PREFS, _overrideMode);
    }

    BOOL_ENTRY(PREF_3D_USEHW, _useHW);
    BOOL_ENTRY("UseVideoMemory", _useHW);
    BOOL_ENTRY("DirtyRectsOptimization", _dirtyRectsOn);

    BOOL_ENTRY("BitmapCachingOptimization", _BitmapCachingOn);
    
    BOOL_ENTRY("EnableDynamicConstancyAnalysis", _dynamicConstancyAnalysisOn);

    BOOL_ENTRY("VolatileRenderingSurface", _volatileRenderingSurface);

    // If we get here, we've hit an invalid entry.
    DASetLastError(E_INVALIDARG, IDS_ERR_INVALIDARG);
    return E_INVALIDARG;
}

HRESULT
PrivatePreferences::PutPreference(char *prefName, VARIANT v)
{
    // If we are in the mode where we always override the application's
    // preferences, just return immediately without doing the set.
    if (_overrideMode) {
        return S_OK;
    } else {
        // Actually do the work.
        return DoPreference(prefName, TRUE, &v);
    }
}
HRESULT
PrivatePreferences::GetPreference(char *prefName, VARIANT *pV)
{
    return DoPreference(prefName, FALSE, pV);
}


void
PrivatePreferences::Propagate()
{
    UpdateAllUserPreferences(this, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\registry.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    For storing and retrieving user preferences to and from the Registry

*******************************************************************************/

#include "headers.h"
#include "privinc/registry.h"

static const char *axaRegistryPreferencePrefix =
  "Software\\Microsoft\\DirectAnimation";

RegistryEntry::RegistryEntry() {}

RegistryEntry::RegistryEntry(char *subdir, char *item) :
       _subdirectory(subdir), _item(item)
{
    // Just stash off info, don't actually open anything yet.
}

void
RegistryEntry::SetEntry(char *subdirectory, char *item)
{
    _subdirectory = subdirectory;
    _item = item;
}

bool
RegistryEntry::Open(HKEY *phk)
{
    DWORD dwErrorCode;

    char key[1024];
    wsprintf(key, "%s\\%s", axaRegistryPreferencePrefix, _subdirectory);
    
    dwErrorCode = RegOpenKeyEx(HKEY_CURRENT_USER,
                               key,
                               0,
                               KEY_ALL_ACCESS,
                               phk);

    if (dwErrorCode != ERROR_SUCCESS) {
        dwErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   key,
                                   0,
                                   KEY_ALL_ACCESS,
                                   phk);
    }
    
    return (dwErrorCode == ERROR_SUCCESS);
}

void
RegistryEntry::Close(HKEY hk)
{
    DWORD dwErrorCode;

    dwErrorCode = RegCloseKey(hk);
    
    if (dwErrorCode != ERROR_SUCCESS) {
        TraceTag((tagError,
                  "Error closing registry key %s\\%s, %hr",
                  axaRegistryPreferencePrefix,
                  _subdirectory,
                  dwErrorCode));
        
        RaiseException_UserError(E_FAIL, IDS_ERR_REGISTRY_ERROR);
    }
}

////////////////  Integer Registry Entry   ///////////////////

IntRegistryEntry::IntRegistryEntry() {}

IntRegistryEntry::IntRegistryEntry(char *subdir, char *item,
                                   int initialValue)
    : RegistryEntry(subdir, item), _defaultVal(initialValue)
{
}

void
IntRegistryEntry::SetEntry(char *subdirectory, char *item)
{
    RegistryEntry::SetEntry(subdirectory, item);
}


int
IntRegistryEntry::GetValue()
{
    HKEY  hk;
    DWORD type;
    DWORD data;
    DWORD buffSize = sizeof(data);
    
    if (!Open(&hk))
        return _defaultVal;
    
    LONG lRes = RegQueryValueEx(hk,
                                _item,
                                NULL,
                                &type,
                                (LPBYTE)&data,
                                &buffSize);

    Close(hk);

    if (lRes != ERROR_SUCCESS) {

        return _defaultVal;
        
    } else {

        Assert(lRes == ERROR_SUCCESS);
        Assert(buffSize == sizeof(data));

        //Assert(type = REG_DWORD);
        Assert(type == REG_DWORD);

        return (int)(data);
    }
    
}


///////////////////////  Preference Updater Functions //////////

static vector<UpdaterFuncType> *updaterFunctions = NULL;

void
ExtendPreferenceUpdaterList(UpdaterFuncType updaterFunc)
{
    updaterFunctions->push_back(updaterFunc);
}

void
UpdateAllUserPreferences(PrivatePreferences *prefs, Bool isInitializationTime)
{
    vector<UpdaterFuncType>::iterator i;

    for (i = updaterFunctions->begin(); i != updaterFunctions->end(); i++) {
        (*i)(prefs, isInitializationTime);
    }
}

void
InitializeModule_Registry()
{
    updaterFunctions = new vector<UpdaterFuncType>;
}

void
DeinitializeModule_Registry(bool bShutdown)
{
    delete updaterFunctions;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\path.cpp ===
/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Static tree path class

    We need to form addresses based on ID'd nodes in the performance tree.
    "C" wrappers are provided so methods may be accessed from ML.

    NOTE:  This is a brute force first pass implementation
*******************************************************************************/

#include "headers.h"
#include "privinc/soundi.h"
#include "privinc/storeobj.h"
#include "privinc/path.h"
#include "privinc/debug.h"
#ifndef _NO_CRT
#include <iostream>
#endif

typedef vector<int> PathType;
typedef vector<AVPath> PathListType;

class AVPathImpl : public StoreObj
{
  public:

    AVPathImpl() {
        path = NEW PathType();
        GetHeapOnTopOfStack().RegisterDynamicDeleter
            (NEW DynamicPtrDeleter<PathType>(path));
    }
    
    bool ContainsNode(int value);

    // This won't be called if it's allocated on the transient heap.
    // XXX ? ~AVPathImpl() { delete path; }

    void Push(int node) { path->push_back(node); }

    void Pop() { path->pop_back(); }

    // Our path is usually different at the end, so this is more
    // efficient than == which uses begin() & end().
    int Equal(AVPath otherPath) {
        //return (*path) == otherPath->GetAddr();
        PathType& x = *path;
        PathType& y = otherPath->GetAddr();
        return
            x.size() == y.size() && std::equal(x.rbegin(), x.rend(), y.rbegin());
    }

    int ContainsPostfix(AVPath postfix);
    
    // Don't know why this does work
    /*
    void Copy(AVPath srcPath)
    {
        copy(srcPath->GetAddr().begin(),
             srcPath->GetAddr().end(),
             path.begin());
    }
    */

#if _USE_PRINT
    void Print();
    void Print(char *);
#endif
    PathType& GetAddr() { return *path; }

 private:
    PathType *path;
};

int
AVPathImpl::ContainsPostfix(AVPath postfix)
{
    PathType& pv = postfix->GetAddr();

    int pathSize = path->size();
    int postfixSize = pv.size();

    if (postfixSize > pathSize)
        return FALSE;

    for (int i=0; i<postfixSize; i++)
        if (pv[i] != (*path)[(pathSize - postfixSize) + i])
            return FALSE;

    return TRUE;
}


bool
AVPathImpl::ContainsNode(int value)
{
    return(std::find(path->begin(), path->end(), value) != path->end());
}


#if _USE_PRINT
void
AVPathImpl::Print()
{
    std::ostream_iterator<int> out(std::cout, ":");

    std::cout << "path:(";
    std::copy(path->begin(), path->end(), out);
    std::cout << ")\n";
}


void
AVPathImpl::Print(char *string)
{
    char num[20];
    PathType::iterator i;

    string[0] = 0;
    for(i= path->begin(); i != path->end(); i++) {
        itoa(*i, num, 10);
        lstrcat(string, num);
        lstrcat(string, ",");
    }
}
#endif

AVPath AVPathCreate() { return NEW AVPathImpl; }
void AVPathDelete(AVPath p) { delete p; }
void AVPathPush(int i, AVPath p) { p->Push(i); }
void AVPathPop(AVPath p) { p->Pop(); }
int AVPathEqual(AVPath a, AVPath b) { return a->Equal(b); }
#if _USE_PRINT
void AVPathPrint(AVPath p) { p ->Print(); }
void AVPathPrintString(AVPath p, char *string) { p ->Print(string); }
#endif
int AVPathContainsPostfix(AVPath p, AVPath postfix)
{ return p->ContainsPostfix(postfix); }
bool AVPathContains(AVPath p, int value) { return p->ContainsNode(value); }

static char sbuffer[1024];

#if _USE_PRINT
char* AVPathPrintString2(AVPath p)
{
    AVPathPrintString(p, sbuffer);

    return sbuffer;
}
#endif

AVPath AVPathCopy(AVPath src)
{
    AVPath p = NEW AVPathImpl;

    PathType::iterator i1 = src->GetAddr().begin();

    while (i1 != (src->GetAddr().end()))
    {
        int i = *i1;

        AVPathPush(i, p);

        i1++;
    }

    /* p->Copy(src); */

    return p;
}


AVPath AVPathCopyFromLast(AVPath src, int start)
{
    AVPath path= NEW AVPathImpl;

    PathType sp= src->GetAddr();

    for(int i= sp.size() - 1; i > 0; i--) {
        if(sp[i]==start)
            break;
    }

    Assert(i >= 0);

    for(int n= i; n<sp.size(); n++)
        AVPathPush(sp[n], path);

    return path;
}


class AVPathListImpl : public AxAThrowingAllocatorClass
{
  public:
    AVPathListImpl() {
        plist = NEW PathListType();
    }

    ~AVPathListImpl() { delete plist; }

    void Push(AVPath p) { plist->push_back(p); }

    int IsEmpty() { return plist->empty(); }

    int Find(AVPath);

  private:
    PathListType* plist;
};

int
AVPathListImpl::Find(AVPath p)
{

#if _DEBUG
#if _USE_PRINT
    // Check to avoid AVPathPrintString call
    if (IsTagEnabled(tagSoundPath)) {
        TraceTag((tagSoundPath, "AVPathListImpl::Find finding <%s>",
                  AVPathPrintString2(p)));
    }
#endif
#endif

    for(PathListType::iterator i = plist->begin();
        i != plist->end(); i++)
    {

#if _DEBUG
#if _USE_PRINT
        // Check to avoid AVPathPrintString call
        if (IsTagEnabled(tagSoundPath)) {
            TraceTag((tagSoundPath, "AVPathListImpl::Find comparing <%s>",
                      AVPathPrintString2(*i)));
        }
#endif
#endif

        if (AVPathEqual(*i, p))
            return 1;
    }

    return 0;
}

AVPathList AVPathListCreate()
{
    BEGIN_LEAK
    AVPathList result = NEW AVPathListImpl;
    END_LEAK

    return result;
}

void AVPathListDelete(AVPathList plst) { delete plst; }
void AVPathListPush(AVPath p, AVPathList plst) { plst->Push(p); }
int AVPathListFind(AVPath p, AVPathList plst) { return plst->Find(p); }

static AVPathList emptyPathList = NULL;

AVPathList AVEmptyPathList() { return emptyPathList; }

int AVPathListIsEmpty(AVPathList plst) { return plst->IsEmpty(); }

void
InitializeModule_Path()
{
    emptyPathList = AVPathListCreate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\timer.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This module contains the member functions for the Timer class, in addition
    to 'double RealTime()', which returns the current timestamp as a real-
    valued number of seconds since the Dawn of Unix (around 1970).  See
    timer.h for a description of the Timer class.

--*/


#include "headers.h"
#include <sys/types.h>
#include <sys/timeb.h>
#include "timer.h"



/*****************************************************************************
This function returns the current time as seconds elapsed since the magic
date (from the ftime function).
*****************************************************************************/

double RealTime (void)
{
    struct timeb t;
    ftime (&t);
    return double(t.time) + (double(t.millitm)/1000);
}



/*****************************************************************************
This function constructs a timer variable.  Note that a side effect of the
timer construction is that timer is created running.  This can be useful if
you want to calculate the total time in a function, for example.
*****************************************************************************/

Timer::Timer (void)
{
    this->total = 0;
    this->tstart = RealTime();
}



/*****************************************************************************
This function resets the timer to 0, non-running.
*****************************************************************************/

void Timer::reset (void)
{
    total = 0;
    tstart = -1;
}



/*****************************************************************************
This function starts the timer running again.  If the timer was already
running, it resets the current start time (but not the elapsed time).
*****************************************************************************/

void Timer::start (void)
{
    tstart = RealTime();
}



/*****************************************************************************
This function resets the timer and then starts it running again.
*****************************************************************************/

void Timer::restart (void)
{
    reset();
    start();
}



/*****************************************************************************
This function stops the timer and adds the current lap time to the elapsed
time.  If the timer is not running, this has no effect.
*****************************************************************************/

void Timer::stop (void)
{
    if (tstart > 0)
    {   total += RealTime() - tstart;
        tstart = -1;
    }
}



/*****************************************************************************
This function read the current total elapsed time of the timer.  It has no
effect on the run state of the timer.
*****************************************************************************/

double Timer::read (void)
{
    if (tstart <= 0)
            return total;
    else
            return total + (RealTime() - tstart);
}



/*****************************************************************************
This function read the current lap time.  It has no effect on the run state
of the timer.
*****************************************************************************/

double Timer::read_lap (void)
{
    return (tstart <= 0) ? 0 : (RealTime() - tstart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\storeobj.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of objects that allocate off of dynamically scoped
    storage heaps.

--*/

#include "headers.h"
#include <malloc.h>
#include "backend/gci.h"
#include "appelles/common.h"
#include "privinc/debug.h"
#include "privinc/opt.h"

#include <stdio.h>
#include <windows.h> // Needed for va_start, why?

#include "privinc/except.h"

DeclareTag(tagGCStoreObj, "GC", "GC StoreObj trace");


////// Implementation of public interface //////

#if _DEBUGMEM
#ifdef new
#define _STOREOBJ_NEWREDEF
#undef new
#endif

void *
StoreObj::operator new(size_t size, int block, char * szFileName, int nLine)
{
    DynamicHeap *heap;
    
    StoreObj *p = (StoreObj*) AllocateFromStoreFn(size,
                                                  szFileName,
                                                  nLine,
                                                  &heap);

    if (heap == &GetGCHeap()) {
        GCAddToAllocated(p);

        TraceTag((tagGCStoreObj, "StoreObj::operator new %s:Line(%d) Addr: %lx size= %d.\n", szFileName, nLine, p, size));
    }

    return p;
}

#ifdef STOREOBJ_NEWREDEF
#undef STOREOBJ_NEWREDEF
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

#else

void *
StoreObj::operator new(size_t size)
{
    DynamicHeap *heap;
    
    StoreObj *p = (StoreObj*) AllocateFromStoreFn(size, &heap);

    if (heap == &GetGCHeap()) GCAddToAllocated(p);

    return p;
}
#endif  // _DEBUGMEM

void
StoreObj::operator delete(void *ptr)
{
    // If the GCFREEING flag is not set, probably there is an
    // exception in the constructor, and we're unwinding.
    // So we need to remove it from the GC allocated list.
    if (&GetHeapOnTopOfStack() == &GetGCHeap()) {
        if (((GCBase*)(ptr))->GetType() != GCBase::GCFREEING)
            GCRemoveFromAllocated((GCBase*) ptr);
    }

    //Assert(GetHeapOnTopOfStack().ValidateMemory(ptr));
    
    TraceTag((tagGCStoreObj, "StoreObj::operator delete Addr: %lx.\n", ptr));
    
    DeallocateFromStore(ptr);
}

// Allocate memory from the current store.
#if _DEBUGMEM
void *
AllocateFromStoreFn(size_t size, char * szFileName, int nLine,
                    DynamicHeap **ppHeap)
{
    DynamicHeap &heap = GetHeapOnTopOfStack();

    if (ppHeap) {
        *ppHeap = &heap;
    }
    
    return heap.Allocate(size, szFileName, nLine);
}
#else
void *
AllocateFromStoreFn(size_t size, DynamicHeap **ppHeap)
{
    DynamicHeap &heap = GetHeapOnTopOfStack();

    if (ppHeap) {
        *ppHeap = &heap;
    }
    
    return heap.Allocate(size);
}
#endif  // _DEBUGMEM

#if _DEBUGMEM
void *StoreAllocateFn(DynamicHeap& heap, size_t size, char * szFileName, int nLine)
{
    return heap.Allocate(size, szFileName, nLine);
}
#else
void *StoreAllocateFn(DynamicHeap& heap, size_t size)
{
    return heap.Allocate(size);
}
#endif // _DEBUGMEM

// Deallocate memory that was allocated on the current store.  Results
// are undefined if the memory was allocated on a different store.
void
DeallocateFromStore(void *ptr)
{
    // Here, we assume that this pointer was allocated on the same
    // heap that it's being freed on.  We don't know this, for sure,
    // though.
    GetHeapOnTopOfStack().Deallocate(ptr);
}

void StoreDeallocate(DynamicHeap& heap, void *ptr)
{
    heap.Deallocate(ptr);
}

Real *
RealToRealPtr(Real val)
{
    // Copy the value to the store on the top of the heap stack, and
    // return a pointer to that place.
    Real *place = (Real *)AllocateFromStore(sizeof(Real));
    *place = val;
    return place;
}

AxAValue
AxAValueObj::Cache(AxAValue obj, CacheParam &p)
{
    Image *origImage = NULL;
    
    if (obj->GetTypeInfo() == ImageType) {
        origImage = SAFE_CAST(Image *, obj);
        Image *cache = origImage->GetCachedImage();

        if (cache) return cache;
    }

    AxAValue c = obj->_Cache(p);

    if (origImage) {
        Image *newImage = SAFE_CAST(Image *, c);
        origImage->SetCachedImage(newImage);
    }
    
    return c;
}


AxAValue
AxAValueObj::_Cache(CacheParam &p)
{ 
    if (p._pCacheToReuse) {
        *p._pCacheToReuse = NULL;
    }
    return this;
}


AxAValue
AxAValueObj::RewriteOptimization(RewriteOptimizationParam &param)
{
    return this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\stlsubst.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

  Provide a specific set of helper functions for void* containers.
  Avoids STL template code bloat.  Rule is that individual functions
  that are large in size should have helper functions here, so they're
  not expanded at every use.

*******************************************************************************/

#include "headers.h"
#include "privinc/stlsubst.h"

// Push onto the end of vectors
void
VectorPushBackPtr(vector<void*>& vec, void *newElt)
{
    vec.push_back(newElt);
}

// Push onto stacks.
void
StackVectorPushPtr(stack<void* >& vec,
                   void *newElt)
{
    vec.push(newElt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\sndfile.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Generic file read interface for all sound file types and compression
    schemes.

    XXX Initialy only .wav is supported
        We can only read files
        And the code isn't setup for multiple formats

--*/

#include "headers.h"
#include <windows.h>
#include <string.h>
#include <mbstring.h>
#include <urlmon.h>
#include "privinc/debug.h"
#include "privinc/sndfile.h"
#include "privinc/except.h"
#include "privinc/resource.h"


SndFile *CreateSoundFile(char *fn)
{
// determine what kind of sound file we are dealing with using
// file extension or magic

// return that kind of sound file reading object
return NEW WaveSoundFile(fn);
}


WaveSoundFile::WaveSoundFile(char *fn)
{
    char        string[1024];
    MMIOINFO    mmioInfo;
    int         err;
    int         iSize;
    WAVEFORMAT *pfmt = 0;

    // copy fileName
    _fileName = (char *)ThrowIfFailed(malloc(strlen(fn)+1));
    lstrcpy(_fileName, fn);

    // open the file   //XXX we realy need to know the mode R|W
    memset(&mmioInfo, 0, sizeof(MMIOINFO)); // these things are horrible!
    _fileHandle = mmioOpen((char *)_fileName, &mmioInfo,
                           MMIO_READ | MMIO_ALLOCBUF);
    if(!_fileHandle) {
         err = mmioInfo.wErrorRet;
         switch(err) {
             case MMIOERR_FILENOTFOUND:
             case MMIOERR_PATHNOTFOUND:
                 RaiseException_UserError(E_FAIL, IDS_ERR_FILE_NOT_FOUND,_fileName);

             case MMIOERR_OUTOFMEMORY: 
                 RaiseException_OutOfMemory("mmio: out of memory", 0);
                 
             case MMIOERR_ACCESSDENIED:
                 RaiseException_UserError(E_FAIL, IDS_ERR_ACCESS_DENIED, string);

             case MMIOERR_INVALIDFILE:
                 RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_fileName);

             case MMIOERR_NETWORKERROR:     
                 RaiseException_InternalError("mmio: Network Error");

             case MMIOERR_SHARINGVIOLATION:
                 RaiseException_UserError(E_FAIL, IDS_ERR_SHARING_VIOLATION, string);

             case MMIOERR_TOOMANYOPENFILES: 
                 RaiseException_InternalError("mmio: Too many open files");
             default: 
                 RaiseException_InternalError("mmio: Unknown Error");
         }
    }

    // read the header
    char errbuff[1024];

    // Check whether it's a RIFF WAVE file.
    MMCKINFO ckFile;
    ckFile.fccType = mmioFOURCC('W','A','V','E');

    if (mmioDescend(_fileHandle, &ckFile, NULL, MMIO_FINDRIFF) != 0) {
        TraceTag((tagSoundErrors, _fileName));
        RaiseException_UserError(E_FAIL, IDS_ERR_SND_WRONG_FILETYPE, _fileName);
    }

    // Find the 'fmt ' chunk.
    MMCKINFO ckChunk;
    ckChunk.ckid = mmioFOURCC('f','m','t',' ');
    if (mmioDescend(_fileHandle, &ckChunk, &ckFile, MMIO_FINDCHUNK) != 0) {
        wsprintf(errbuff, "WavSoundClass mmioDescend failed, no fmt chunk");
        TraceTag((tagSoundErrors, errbuff));
        RaiseException_InternalError(errbuff);
    }

    // Allocate some memory for the fmt chunk.
    iSize = ckChunk.cksize;
    pfmt = (WAVEFORMAT*) malloc(iSize);
    if (!pfmt) {
        wsprintf(errbuff,
        "WavSoundClass malloc failed, couldn't allocate WAVEFORMAT");
        TraceTag((tagSoundErrors, errbuff));
#if _MEMORY_TRACKING
        OutputDebugString("\nDirectAnimation: Out Of Memory\n");
        F3DebugBreak();
#endif
        RaiseException_InternalError(errbuff);
    }

    // Read the fmt chunk.
    if (mmioRead(_fileHandle, (char*)pfmt, iSize) != iSize) {
        wsprintf(errbuff,
        "WavSoundClass mmioRead failed, couldn't read fmt chunk");
        TraceTag((tagSoundErrors, errbuff));
        RaiseException_InternalError(errbuff);
    }

    // record the format info
    _fileNumChannels    = pfmt->nChannels;
    _fileSampleRate     = pfmt->nSamplesPerSec;
    _fileBytesPerSample = pfmt->nBlockAlign/pfmt->nChannels;


    mmioAscend(_fileHandle, &ckChunk, 0); // Get out of the fmt chunk.

    // Find the 'data' chunk.
    ckChunk.ckid = mmioFOURCC('d','a','t','a');
    if (mmioDescend(_fileHandle, &ckChunk, &ckFile, MMIO_FINDCHUNK) != 0) {
        wsprintf(errbuff, "WavSoundClass mmioDescend failed, no data chunk");
        TraceTag((tagSoundErrors, errbuff));
        RaiseException_InternalError(errbuff);
    }

    // gather data chunk statistics
    _fileNumSampleBytes = ckChunk.cksize;
    _fileNumFrames      = ckChunk.cksize/_fileNumChannels/_fileBytesPerSample;
    _fileLengthSeconds  = _fileNumFrames/_fileSampleRate;

    // determine location of the data block
    _dataBlockLocation = mmioSeek(_fileHandle, 0, SEEK_CUR);
    if(_dataBlockLocation == -1) {
        wsprintf(errbuff, "WavSoundClass mmioSeek failed");
        TraceTag((tagSoundErrors, errbuff));
        RaiseException_InternalError(errbuff);
    }

    // compute the location of the end of data block
    _eoDataBlockLocation = _dataBlockLocation + _fileNumSampleBytes;
}


WaveSoundFile::~WaveSoundFile()
{
// XXX flush the file if it is open

// close the file if it is open
if(_fileHandle)
    mmioClose(_fileHandle, 0);
}


void
WaveSoundFile::SeekFrames(long frameOffset, int whence)
{
    long byteLocation;  // location we are going to compute then seek to
    long relativeBytes = frameOffset * _fileNumChannels * _fileBytesPerSample;
    long startLocation; // location offset from
    char string[1024];


    switch(whence) {
        case SEEK_SET: startLocation = _dataBlockLocation;   break;
        case SEEK_CUR: startLocation =
                           mmioSeek(_fileHandle, 0, SEEK_CUR); break;
        case SEEK_END: startLocation = _eoDataBlockLocation; break;

        default: 
            RaiseException_InternalError("SeekFrames: unknown relative parameter\n");
    }
    byteLocation = startLocation + relativeBytes;
    if(mmioSeek(_fileHandle, byteLocation, SEEK_SET)==-1) {
        wsprintf(string, "mmioSeek failed");
        TraceTag((tagSoundErrors, string));
        RaiseException_InternalError(string);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\storage.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Implements dynamically scoped storage, and the stack of these guys.

*******************************************************************************/

#include "headers.h"
#include "privinc/storeobj.h"
#include "privinc/mutex.h"
#include "privinc/debug.h"
#include "privinc/stlsubst.h"
#include "privinc/except.h"
#include "privinc/tls.h"

#if DEVELOPER_DEBUG
class TransientHeapImpl;
typedef list<TransientHeapImpl *> DynamicHeapList;
DynamicHeapList * g_heapList = NULL;
CritSect * g_heapListCS = NULL;
#endif

// Make the global systemHeap initially be NULL.
DynamicHeap *systemHeap = NULL;
DynamicHeap& GetSystemHeap() { return *systemHeap; }

DynamicHeap *initHeap = NULL;
DynamicHeap& GetInitHeap() { return *initHeap; }

// Base-class virtual destructor doesn't do anything.
DynamicHeap::~DynamicHeap()
{
}

///////////////// Transient Heap /////////////////////////
//
//  This class of Dynamic Heap allocates memory out of a set of fixed
// size memory chunks, and, if the chunks run out, a new one is
// allocated.  Individually allocated memory is never explicitly
// deallocated.  Rather, the Reset() method resets the pointer to
// start allocating from the first chunk again.  This is used
// primarily in per-frame generation, where memory used for one frame
// isn't accessed on subsequent frames.
//
//////////////////////////////////////////////////////////

class MemoryChunk : public AxAThrowingAllocatorClass {
  public:

    // Allocate the memory chunk with the specified size.
    MemoryChunk(size_t size, HANDLE heap);

    // Destroy the chunk simply by freeing the associated memory.
    ~MemoryChunk() {
        HeapFree(_heap, HEAP_NO_SERIALIZE, _block);       
    }

    // Allocate approp num of bytes from chunk, or return NULL if not
    // available. 
    void *Allocate(size_t bytesToAlloc);

    // Reset the pointers from which allocation occurs.  Clear if
    // appropriate.
    void Reset(Bool clear) {

        _currPtr = _block;
        _bytesLeft = _size;

#if DEVELOPER_DEBUG
        // If debugging, set the entire memory chunk to an easily
        // recognized value.  This also ensures that code is unable to
        // usefully access memory that's already been "freed"
        if (clear) {
            memset(_block, 0xCC, _size);
        }

        // used to tell Purify to color memory properly
        PurifyMarkAsUninitialized(_block,_size);
#endif DEBUG

    }

#if DEVELOPER_DEBUG
    void Dump() const {
        TraceTag((tagTransientHeapLifetime,
          "Chunk @ 0x%x, CurrPtr @ 0x%x, %d/%d (%5.1f%%) bytes used",
                     _block, _currPtr, _size - _bytesLeft, _size,
                     ((Real)(_size - _bytesLeft)) * 100 / ((Real)_size)));
    }
#endif
#if DEVELOPER_DEBUG
    bool ValidateMemory(void * ptr) {
        return ((ptr >= _block) && (ptr < _currPtr));
    }
#endif

  protected:
    char        *_block;
    char        *_currPtr;
    size_t       _bytesLeft;
    const size_t _size;
    HANDLE       _heap;
};

// Allocate the memory chunk with the specified size.
MemoryChunk::MemoryChunk(size_t size, HANDLE heap) : _size(size), _heap(heap)
{
    _block = (char *)HeapAlloc(_heap, HEAP_NO_SERIALIZE, _size);
    if (!_block)
    {
        RaiseException_OutOfMemory("MemoryChunk::MemoryChunk()", _size);
    }
#if _DEBUG
    // used to tell Purify to color memory properly
    PurifyMarkAsUninitialized(_block,_size);
#endif

    _currPtr = _block;
    _bytesLeft = _size;
}

// Allocate approp num of bytes from chunk, or return NULL if not
// available. 
void *
MemoryChunk::Allocate(size_t bytesToAlloc) {

    void *returnVal = NULL;

    // Adjust the bytesToAlloc to be 8 byte aligned so that we do not
    // lose performance or cause problems for system components
    
    bytesToAlloc = (bytesToAlloc + 0x7) & ~0x7;
    
    // If there's enough space, adjust the values and return the
    // current pointer, else return NULL.
    if (bytesToAlloc <= _bytesLeft) {
        returnVal = _currPtr;
        _currPtr += bytesToAlloc;
        _bytesLeft -= bytesToAlloc;
#if _DEBUG
        // used to tell Purify to color memory properly
        PurifyMarkAsInitialized(_currPtr,bytesToAlloc);
#endif
    }

    return returnVal;
}

static void DoDeleters(set<DynamicHeap::DynamicDeleter*>& deleters)
{
    // Free the deleters
    for (set<DynamicHeap::DynamicDeleter*>::iterator s = deleters.begin();
         s != deleters.end(); s++) {
        (*s)->DoTheDeletion();
        delete (*s);
    }

    deleters.erase(deleters.begin(), deleters.end());
}


class TransientHeapImpl : public DynamicHeap {
  public:
    TransientHeapImpl(char *name, size_t initialSize, Real growthRate);
    ~TransientHeapImpl();
#if _DEBUGMEM
    void *Allocate(size_t size, char * szFileName, int nLine) { return Allocate(size); }
#endif
    void *Allocate(size_t size);
    void Deallocate(void *ptr);
    void Reset(Bool);
    void RegisterDynamicDeleter(DynamicDeleter *deleter);

    void UnregisterDynamicDeleter(DynamicDeleter* deleter);
        
    size_t PtrSize(void *ptr) { return 0; }

    bool IsTransientHeap() { return true; }

#if DEVELOPER_DEBUG
    void  Dump() const;
    char *Name() const { return _name; }
    size_t BytesUsed() { return _totalAlloc; }
    bool  ValidateMemory(void *ptr);
#endif

  protected:
    char                   *_name;
    Real                    _growthRate;
    size_t                  _sizeOfLast;
    int                     _maxChunkIndex;

#if DEVELOPER_DEBUG
    size_t                  _totalAlloc;
#endif

    vector<MemoryChunk*>    _chunks;
    MemoryChunk            *_currentChunk;
    int                     _currentChunkIndex;
    HANDLE                  _heap; // to alloc chunks onto.

    set<DynamicDeleter* > deleters;
};

TransientHeapImpl::TransientHeapImpl(char *n,
                                     size_t size,
                                     Real growthR)
: _name(NULL),
  _maxChunkIndex(0),
  _growthRate(growthR),
  _sizeOfLast(size),
  _heap(NULL)
{
    _name = CopyString(n);

    // Create the heap that the memory will be allocated from
    _heap = HeapCreate(HEAP_NO_SERIALIZE, 0, 0);

    if (_heap == NULL ||
        _name == NULL)
    {
        RaiseException_OutOfMemory ("Could not allocate heap", sizeof(_heap)) ;
    }
    
    // Create the first memory chunk, and add it to the chunks list.
    VECTOR_PUSH_BACK_PTR(_chunks, NEW MemoryChunk(size, _heap));

    _currentChunk = _chunks[0];
    _currentChunkIndex = 0;

#if DEVELOPER_DEBUG    
    _totalAlloc = size;

    {
        CritSectGrabber _csg(*g_heapListCS);
        g_heapList->push_back(this);
    }
#endif    
}

TransientHeapImpl::~TransientHeapImpl()
{
#if DEVELOPER_DEBUG
    {
        CritSectGrabber _csg(*g_heapListCS);
        g_heapList->remove(this);
    }
#endif

    TraceTag((tagTransientHeapLifetime, "Dumping, then deleting %s", _name));

#if DEVELOPER_DEBUG
    Dump();
#endif

    DoDeleters(deleters);

    for (int i = 0; i < _maxChunkIndex + 1; i++) {
        delete _chunks[i];
    }

    delete [] _name;

    if (_heap)
    {
        Assert(HeapValidate(_heap, NULL, NULL));

        if (HeapValidate(_heap, NULL, NULL)) {
            HeapDestroy(_heap);
        }

        _heap = NULL;
    }
}

#if DEVELOPER_DEBUG
bool
TransientHeapImpl::ValidateMemory(void *ptr)
{
    vector<MemoryChunk*>::iterator beginning = _chunks.begin();
    vector<MemoryChunk*>::iterator ending =
        beginning + _currentChunkIndex + 1;

    // Iterate through the chunks, calling Reset() on each.
    vector<MemoryChunk*>::iterator i;
    for (i = beginning; i < ending; i++) {
        if ((*i)->ValidateMemory(ptr))
            return TRUE;
    }

    return FALSE;
}
#endif

void *
TransientHeapImpl::Allocate(size_t size)
{
    void *returnVal = _currentChunk->Allocate(size);

    // If successful, just return result
    if (returnVal != NULL) {
        return returnVal;
    }

    // See if there is a next chunk to move to...

    if (_currentChunkIndex == _maxChunkIndex) {

        // ...need to create a new chunk

        // Figure out its size
        size_t newSize = (size_t)(_sizeOfLast * _growthRate);
        if (newSize < size) {
            newSize = size;
        }

        // Allocate a new chunk with the new size.
        VECTOR_PUSH_BACK_PTR(_chunks, NEW MemoryChunk(newSize, _heap));

        // update counters, etc.
        _maxChunkIndex++;
        _sizeOfLast = newSize;

#if DEVELOPER_DEBUG
        _totalAlloc += newSize;
#endif
        
    }

    // Move to the next chunk (may be newly created)
    _currentChunkIndex++;
    _currentChunk = _chunks[_currentChunkIndex];

    // Recursively call this method, and try again on the new
    // chunk we're on.
    return Allocate(size);
}

void
TransientHeapImpl::Deallocate(void *ptr)
{
    Assert (ValidateMemory(ptr));

    // De-allocating from a TransientHeap doesn't really make sense.
    // Don't do anything.
}

void
TransientHeapImpl::Reset(Bool clear)
{
    // Do the deletions first and then reset the chunks
    DoDeleters(deleters);

    // Stash off this value so that it needn't be computed, including
    // call to begin(), on every time through the loop.
    vector<MemoryChunk*>::iterator beginning = _chunks.begin();
    vector<MemoryChunk*>::iterator ending =
        beginning + _currentChunkIndex + 1;

    // Iterate through the chunks, calling Reset() on each.
    vector<MemoryChunk*>::iterator i;
    for (i = beginning; i < ending; i++) {
        (*i)->Reset(clear);
    }

    // Start again at the first chunk.
    _currentChunkIndex = 0;
    _currentChunk = _chunks[0];
}

void
TransientHeapImpl::RegisterDynamicDeleter(DynamicDeleter *deleter)
{
    // Just push it onto the vector.  This will be called and deleted
    // when reset is invoked.
    deleters.insert(deleter);
}

void
TransientHeapImpl::UnregisterDynamicDeleter(DynamicDeleter *deleter)
{
    deleters.erase(deleter);
}

#if DEVELOPER_DEBUG

void
TransientHeapImpl::Dump() const
{
    TraceTag((tagTransientHeapLifetime,
              "%s\tNum Chunks %d\tCurrent Chunk Index %d\tGrowth Rate %8.5f\tLast Size %d",
               _name,
               _maxChunkIndex + 1,
               _currentChunkIndex,
               _growthRate,
               _sizeOfLast));

    // Just use array indexing here rather than iterators, as its
    // easier to write, and performance isn't important here.
    for (int i = 0; i < _maxChunkIndex + 1; i++) {
        TraceTag((tagTransientHeapLifetime, "Chunk %d: ", i));
        _chunks[i]->Dump();
    }

    TraceTag((tagTransientHeapLifetime, "\n"));

}

#endif

DynamicHeap&
TransientHeap(char *name, size_t initial_size, Real growthRate)
{
    return *NEW TransientHeapImpl(name, initial_size, growthRate);
}

void
DestroyTransientHeap(DynamicHeap& heap)
{
    delete &heap;
}

///////
/////// Win32 Heap
///////

class Win32Heap : public DynamicHeap
{
  public:
    Win32Heap(char *name,
              DWORD fOptions,
              DWORD dwInitialSize,
              DWORD dwMaxSize) ;
    ~Win32Heap() ;

#if _DEBUGMEM
    void *Allocate(size_t size, char * szFileName, int nLine) {
        void *result;

        result = _malloc_dbg(size, _NORMAL_BLOCK, szFileName, nLine);

        return result;
    }
#endif
    
    void *Allocate(size_t size) ;

    void Deallocate(void *ptr) {
        free(ptr);
    }

    void Reset(Bool) ;

    // Win32 heap is never reset, so we never will call the deleter,
    // so we just delete it right away.
    void  RegisterDynamicDeleter(DynamicDeleter* deleter) {
        delete deleter;
    }

    void UnregisterDynamicDeleter(DynamicDeleter* deleter) { }
        
    size_t PtrSize(void *ptr) { return _msize(ptr); }

    bool IsTransientHeap() { return false; }

#if DEVELOPER_DEBUG
    virtual bool ValidateMemory(void *ptr) {
        // TODO:
        return false;
    }
        
    void Dump() const {
        TraceTag((tagTransientHeapLifetime, "Win32 Heap"));
    }

    char *Name() const { return _name; }

    size_t BytesUsed() {
        CritSectGrabber csg(_debugcs);
        return _totalAlloc;
    }
#endif
    
  protected:
    char * _name ;
    HANDLE _heap ;
    DWORD _fOptions ;
    DWORD _dwInitialSize ;
    DWORD _dwMaxSize ;

#if DEVELOPER_DEBUG
    size_t _totalAlloc;
    CritSect _debugcs;
#endif    
};

Win32Heap::Win32Heap(char *name,
                     DWORD fOptions,
                     DWORD dwInitialSize,
                     DWORD dwMaxSize)
: _fOptions(fOptions),
  _dwInitialSize(dwInitialSize),
  _dwMaxSize(dwMaxSize),
#if DEVELOPER_DEBUG
  _totalAlloc(0),
#endif
  _heap(NULL),
  _name(NULL)
{
    TraceTag((tagTransientHeapLifetime, "Creating win32 heap store"));

    _name = new char[lstrlen(name) + 1];
    lstrcpy(_name, name);
}

Win32Heap::~Win32Heap()
{
    delete [] _name;
}

void *
Win32Heap::Allocate(size_t size)
{
    void *result = malloc(size);
    if (!result)
    {
        RaiseException_OutOfMemory("Win32Heap::Allocate() - out of memory", size);
    }

#if DEVELOPER_DEBUG
    CritSectGrabber csg(_debugcs);
    // Use the size returned from the heap since it is can be greater
    // than the size we asked for
    _totalAlloc += _msize(result);
#endif

    return result;
}

void
Win32Heap::Reset(Bool clear)
{
    Assert(false && "Cannot reset Win32 Heaps");
}

DynamicHeap&
CreateWin32Heap(char *name,
                DWORD fOptions,
                DWORD dwInitialSize,
                DWORD dwMaxSize)
{
    return * NEW Win32Heap (name,
                            fOptions,
                            dwInitialSize,
                            dwMaxSize) ;
}

void DestroyWin32Heap(DynamicHeap& heap)
{ delete &heap ; }


///////
/////// Heap Stack implementation
///////

// Create a new stack and store it into the TLS location given by
// incoming index.
LPVOID
CreateNewStructureForThread(DWORD tlsIndex)
{
    ThreadLocalStructure *tlstruct = NEW ThreadLocalStructure(); 

    // TODO:  Need to have a means of intercepting threads when they
    // are about to terminate, in order to free up any storage
    // associated with them in TLS.

    TraceTag((tagTransientHeapLifetime,
              "Created New Struct for Thread %u at 0x%x",
               GetCurrentThreadId(),
               tlstruct));

    // Set the TLS data to the new stack.
    LPVOID result = (LPVOID)tlstruct;
    BOOL ok = TlsSetValue(tlsIndex, result);
    Assert((ok == TRUE) && "Error in TlsSetValue");

    return result;
}

// Will be initialized in initialization function below.
DWORD localStructureTlsIndex = 0xFFFFFFFF;

inline stack<DynamicHeap* > *
GetThreadLocalStack()
{
    return &(GetThreadLocalStructure()->_stackOfHeaps);
}


DynamicHeap&
GetHeapOnTopOfStack()
{
#ifdef _DEBUG
    int sz = GetThreadLocalStack()->size();
    Assert (sz > 0  && "GetHeapOnTopOfStack: empty heap stack on this thread (there should be a dynamicHeap on here)!") ;
#endif
    return *GetThreadLocalStack()->top();
}

void
PushDynamicHeap(DynamicHeap& heap)
{
    TraceTag((tagTransientHeapDynamic, "Pushing %s", heap.Name()));
    STACK_VECTOR_PUSH_PTR(*GetThreadLocalStack(), &heap);
}

void
PopDynamicHeap()
{
    TraceTag((tagTransientHeapDynamic, "Popping %s",
              GetHeapOnTopOfStack().Name()));
    GetThreadLocalStack()->pop();
}

void
ResetDynamicHeap(DynamicHeap& heap)
{
    // Always TRUE, no clear code would be generated in debug mode.
    heap.Reset(TRUE);
}

StoreObj::StoreObj()
{
    // Can't do it here because this is not called only at new.
#if 0
    if (&GetHeapOnTopOfStack() == &GetGCHeap())
        GCAddToAllocated(this);
#endif
    
    SetType(STOREOBJTYPE);
}

#if DEVELOPER_DEBUG
size_t
DynamicHeapBytesUsed()
{
    size_t size = 0;
    
    CritSectGrabber _csg(*g_heapListCS);

    for (DynamicHeapList::iterator i = g_heapList->begin();
         i != g_heapList->end();
         i++)
    {
        size += (*i)->BytesUsed();
    }

    return size;
}

bool
OnAnyTransientHeap(void *ptr)
{
    CritSectGrabber _csg(*g_heapListCS);

    for (DynamicHeapList::iterator i = g_heapList->begin();
         i != g_heapList->end();
         i++)
    {
        if ((*i)->ValidateMemory(ptr))
            return true;
    }

    return false;
}
#endif

void
InitializeModule_Storage()
{
    localStructureTlsIndex = TlsAlloc();

    // If result is 0xFFFFFFFF, allocation failed.
    Assert(localStructureTlsIndex != 0xFFFFFFFF);

#if DEVELOPER_DEBUG
    g_heapList = NEW DynamicHeapList;
    g_heapListCS = NEW CritSect;
#endif

    // Create the system heap
    systemHeap = NEW Win32Heap("System Heap",0,0,0) ;

    initHeap = NEW TransientHeapImpl("Init Heap", 1000, 1.5) ;
}

void
DeinitializeModule_Storage(bool bShutdown)
{
    if (systemHeap) {
        delete systemHeap;
        systemHeap = NULL;
    }

    if (initHeap) {
        delete initHeap;
        initHeap = NULL;
    }

    if (localStructureTlsIndex != 0xFFFFFFFF)
        TlsFree(localStructureTlsIndex);

#if DEVELOPER_DEBUG
    delete g_heapList;
    g_heapList = NULL;
    
    delete g_heapListCS;
    g_heapListCS = NULL;
#endif
}

void
DeinitializeThread_Storage()
{
    // Grab what is stored in TLS at this index.
    ThreadLocalStructure * result = (ThreadLocalStructure *) TlsGetValue(localStructureTlsIndex);

    if (result)
    {
        delete result;
        TlsSetValue(localStructureTlsIndex, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\urlbuf.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <urlmon.h>
#include <wininet.h>
#include "privinc/debug.h"
#include "privinc/urlbuf.h"
#include "privinc/util.h"
#include "privinc/except.h"
#include "privinc/resource.h"
#include "privinc/server.h"
#include "privinc/mutex.h"

daurlstream::daurlstream(const char * url)
{
    TraceTag((tagNetIO, "daurlstream::daurlstream"));

    HRESULT hr ;

    hr = THR(URLOpenBlockingStream(NULL,
                                   url,
                                   &_stream,0,bsc._pbsc));
    if (hr != S_OK)
        RaiseException_UserError (STG_E_FILENOTFOUND,
                            IDS_ERR_FILE_NOT_FOUND,
                            url) ;
}

INetTempFile::INetTempFile ()
: _url(NULL),
  _tmpfilename(NULL)
{
    TraceTag((tagNetIO, "INetTempFile::INetTempFile"));
}

INetTempFile::INetTempFile (LPCSTR szURL)
: _url(NULL),
  _tmpfilename(NULL)
{
    TraceTag((tagNetIO, "INetTempFile::INetTempFile(%s)", szURL));

    if (!Open(szURL)) {
        RaiseException_UserError (STG_E_FILENOTFOUND,
                            IDS_ERR_FILE_NOT_FOUND,
                            szURL) ;
    }
}

BOOL
INetTempFile::Open (LPCSTR szURL)
{
    BOOL        fRet = TRUE;

    TraceTag((tagNetIO, "INetTempFile::Open(%s)", szURL));

    Close () ;

    if (!szURL)
        return (FALSE) ;

    int len = lstrlen(szURL) ;

    _url = THROWING_ARRAY_ALLOCATOR(char, len+1);
    lstrcpy (_url, szURL) ;

    char    szOutPath[MAX_PATH];
    HRESULT hr;
    CBSCWrapper bsc;

    szOutPath[0] = 0;

    // TODO: Use the current container but it dies with the
    // current async scheme

    hr = THR(URLDownloadToCacheFile(NULL,
                                    _url,
                                    szOutPath,
                                    MAX_PATH,
                                    NULL,
                                    bsc._pbsc));

    if (hr) {

        TraceTag((tagError, "URLDownloadToCacheFile(%s):0x%X", _url, hr));
        TraceTag((tagError, "-- szOutPath = %s", szOutPath));

        goto Error;
    }
    
    _tmpfilename = THROWING_ARRAY_ALLOCATOR(char, lstrlen(szOutPath) + 1);      

    lstrcpy (_tmpfilename, szOutPath);

    TraceTag((tagNetIO, "-- _tmpfilename=%s", _tmpfilename));

  Cleanup:

    return fRet;

  Error:
    delete _url ;
    _url = NULL ;

    fRet = FALSE;

    goto Cleanup;
}

void INetTempFile::Close ()
{
    if (_url) {
        TraceTag((tagNetIO, "INetTempFile::Close(%s)", _url));

        if (_tmpfilename != _url)
        {
            delete _tmpfilename ;
            _tmpfilename = NULL ;
        }

        delete _url ;

        // This indicates we are closed
        _url = NULL ;
    }
}

INetTempFile::~INetTempFile ()
{
    TraceTag((tagNetIO, "INetTempFile::~INetTempFile"));

    Close () ;
}



//+-------------------------------------------------------------------------
//
//  CDXMBindStatusCallback implementation
//
//  Generic implementation of IBindStatusCallback.  This is the root
//  class.
//
//--------------------------------------------------------------------------

CDXMBindStatusCallback::CDXMBindStatusCallback(void)
{
    m_pbinding = NULL;
    m_cRef =  1;
}


CDXMBindStatusCallback::~CDXMBindStatusCallback(void)
{
    if (m_pbinding)
        m_pbinding->Release();
}


STDMETHODIMP
CDXMBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) (IBindStatusCallback *) this;
    }
    else if (IsEqualIID(riid, IID_IBindStatusCallback))
    {
        *ppv = (IBindStatusCallback *) this;
    }
    else if (IsEqualIID(riid, IID_IAuthenticate))
    {
        TraceTag((tagNetIO, "CDXMBindStatusCallback::QI for IAuthenticate"));
        *ppv = (IAuthenticate *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CDXMBindStatusCallback::AddRef(void)
{
    return m_cRef++;
}


STDMETHODIMP_(ULONG)
CDXMBindStatusCallback::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CDXMBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnStartBinding"));

    if (m_pbinding != NULL)
    {
        m_pbinding->Release();
    }

    m_pbinding = pbinding;
    if (m_pbinding != NULL)
    {
        m_pbinding->AddRef();
    }

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::GetPriority(LONG* pnPriority)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::GetPriority"));
        return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnLowResource"));
    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnProgress(
        ULONG ulProgress,
        ULONG ulProgressMax,
        ULONG ulStatusCode,
        LPCWSTR szStatusText)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnProgress"));
    TraceTag((tagNetIO, "-- ulProg    = %d", ulProgress));
    TraceTag((tagNetIO, "-- ulProgMax = %d", ulProgressMax));
    TraceTag((tagNetIO, "-- ulStatus  = %d", ulStatusCode));
    TraceTag((tagNetIO, "-- szStatus  = %ls", szStatusText));

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR szError)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnStopBinding hrStatus: %lx", hrStatus));

    if (m_pbinding)
    {
        m_pbinding->Release();
        m_pbinding = NULL;
    }

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::GetBindInfo(DWORD * pgrfBINDF, BINDINFO * pbindInfo)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::GetBindInfo"));

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnDataAvailable(
        DWORD grfBSCF,
        DWORD dwSize,
        FORMATETC * pfmtetc,
        STGMEDIUM * pstgmed)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnDataAvailable"));

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnObjectAvailable"));

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::Authenticate(
        HWND * phwnd,
        LPWSTR * pwszUser,
        LPWSTR * pwszPassword)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::Authenticate"));

    if ((phwnd == NULL) || (pwszUser == NULL) || (pwszPassword == NULL))
    {
        return E_INVALIDARG;
    }

    *phwnd = GetDesktopWindow();
    *pwszUser = NULL;
    *pwszPassword = NULL;

    TraceTag((
            tagNetIO,
            "-- hwnd=%lx, user=%ls, password=%ls",
            *phwnd,
            *pwszUser,
            *pwszPassword));

    return S_OK;
}


CBSCWrapper::CBSCWrapper(void)
{
    _pbsc = new CDXMBindStatusCallback;
}


CBSCWrapper::~CBSCWrapper(void)
{
    _pbsc->Release();
}

URLRelToAbsConverter::URLRelToAbsConverter(LPSTR baseURL,
                                           LPSTR relURL)
{
    DWORD len = INTERNET_MAX_URL_LENGTH ;

    if (!InternetCombineUrlA (baseURL, relURL, _url, &len, ICU_NO_ENCODE)) {
        // If we cannot determine if the path is absolute then assume
        // it is absolute
        lstrcpyn (_url, relURL, INTERNET_MAX_URL_LENGTH) ;
    }

    _url[INTERNET_MAX_URL_LENGTH] = '\0';
}

URLCanonicalize::URLCanonicalize(LPSTR path)
{
    DWORD len = INTERNET_MAX_URL_LENGTH ;

    if (!InternetCanonicalizeUrlA (path, _url, &len, ICU_NO_ENCODE)) {
        // If we cannot determine if the path is absolute then assume
        // it is absolute
        lstrcpyn (_url, path, INTERNET_MAX_URL_LENGTH) ;
    }

    _url[INTERNET_MAX_URL_LENGTH] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\project.inc ===
# project.inc - project specific settings

APPEL_INC_DIRS=$(SDKDIR) $(TOOLSINCLUDE) $(ATLINCLUDE) $(SRCROOT)\appel\include $(SRCROOT)\appel $(SRCROOT)\include
_USERCFLAGS=$(_USERCFLAGS) /DNDEBUG /DOS_WIN_NT_3_5 /DNOMINMAX
!if "$(_DEBUG)" == "1"
_USERCFLAGS=$(_USERCFLAGS) /GR
!endif

_NO_INCREMENTAL_LINK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\timer.h ===
#ifndef _TIMER_H
#define _TIMER_H

/*++

Copyright (c) 1995-96 Microsoft Corporation

Module Name:
    timer.h

Abstract:
    See below.

Revision:
    $Header: /appelles/src/utils/timer.h 2     5/08/95 11:07a Stevehol $

--*/

/*******************************************************************************

        ``For time is the longest distance between two places.''
                    Tennessee Williams, in The Glass Menagerie, sc. 7.

DESCRIPTION

    The timer class models a stopwatch with lap times.  The timer is started
    on construction in case the programmer wants to get the time since
    creation (possibly useful for block/function lifespan.   The timer units
    are seconds.  The following operations are supported:


FUNCTIONS

    reset:     Resets the elapsed time to zero and sets the timer to
               non-running.

    restart:   Resets the elapsed time and starts the timer running.

    start:     Starts the timer running.  This begins a new lap if the timer
               is not currently running.  If the timer is already running, it
               resets the start of the current lap.

    stop:      This stops the timer.  Note that it does not reset the elapsed
               time to zero (you need to use reset or restart to do this).

    read:      Reads the current elapsed time, including the current lap.
               This does not affect the run-state of the timer.

    read_lap:  Reads the elapsed time since the last timer start.


EXAMPLES

    To find the amount of time spent in a block:

        {
            Timer timer;
            ...
            printf ("Time in block: %lf\n", timer.read());
        }

    To find time across a function call inside a loop:

        Timer timer;

        for (...)
        {
            ...
            timer.start();
            function ();
            timer.stop();
        }

        printf ("Total time in function: %lf\n", timer.read();

*******************************************************************************/

class Timer
{
    public:

    void   reset    (void);   // Resets timer to not-running, Zero.
    void   start    (void);   // Starts the timer running again.
    void   restart  (void);   // Resets timer and then starts it running.
    void   stop     (void);   // Stops the timer.
    double read     (void);   // Current Total Seconds Elapsed
    double read_lap (void);   // Current Seconds in Lap

    Timer ();

    private:

    double total;        // Elapsed Time of Previous Laps
    double tstart;       // Current Start Time
};


double RealTime (void);  // Returns the Timestamp as Seconds (to 4 dec places)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\_netio.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Private header for netio

--*/

#ifndef __NETIOPRIV_H
#define __NETIOPRIV_H

#define AVR_PREFIX "AVR"

extern HINSTANCE hInst;

class CNetIO;

HRESULT     CreateNetIO(HAVRCONTEXT hcontext, CNetIO ** ppNetIO);
HRESULT     AddNetIOToList(CNetIO * pNetIO);
CNetIO *    FindNetIO(HAVRCONTEXT hcontext);


class CNetIO
{
  public:
    CNetIO(HAVRCONTEXT hcontext);
    ~CNetIO(void);

    HAVRCONTEXT     GetContext(void) { return m_hcontext; }
    LPOLESTR        GetRootPath(void) { return m_szRootPath; }
    char *          GetLocalPath(void) { return m_szLocalPath; }
    char *          GetLocalHyperlinkPath(void) { return m_szLocalHyperlinkPath; }
    HRESULT         GetRootMoniker(IMoniker ** ppmk);
    HRESULT         SetRootPath(LPOLESTR szRoot);
    void            ReleasePathStrings(void);
    void            CreateTempFileName(LPSTR pszName, LPSTR pszTempName);
    BOOL            CopyFileToTemp(LPSTR szInName, LPSTR szOutName);
    BOOL            MakeMonikerAndContext(
                            LPSTR szName,
                            IMoniker ** ppmk,
                            IBindCtx ** ppbc);

  private:
    HAVRCONTEXT     m_hcontext;
    LPOLESTR        m_szRootPath;
    char *          m_szLocalPath;
    char *          m_szLocalHyperlinkPath;
};


struct SNetIOList
{
    CNetIO *        pNetIO;
    SNetIOList *    pNext;
};


struct TEMPFILEINFO
{
  LPSTR         pszName;
  HANDLE        hFile;
  DWORD         cbSize;
  IMoniker *    pmk;
  IBindCtx *    pbc;
  IBindStatusCallback *pbsc;
  unsigned      fDone : 1;
  unsigned      fError : 1;

  TEMPFILEINFO() { memset(this, 0, sizeof(TEMPFILEINFO)); }
};


class CBscTempFile : public CBindStatusCallback
{
  public:
    // IBindStatusCallback methods overrides
    STDMETHOD(OnStopBinding)(HRESULT hrResult, LPCWSTR szError);
    STDMETHOD(GetBindInfo)(DWORD * pgrfBINDF, BINDINFO * pbindInfo);
    STDMETHOD(OnDataAvailable)(
                DWORD grfBSCF,
                DWORD dwSize,
                FORMATETC *pfmtetc,
                STGMEDIUM* pstgmed);

    // constructors/destructors
    CBscTempFile(TEMPFILEINFO * pFi);
    ~CBscTempFile(void);

    // data members
    DWORD           m_cbOld;
    TEMPFILEINFO *  m_pfi;
};


#endif  // __NETIOPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\utils\util.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Simple utility functions.
*******************************************************************************/

#include "headers.h"
#include "privinc/util.h"
#include <sys/types.h>
#include <sys/timeb.h>
#include <eh.h>
#include "privinc/except.h"
#include "../backend/perf.h"  // for Param
#include "../backend/timetran.h"


// This function returns TRUE if we are running on 64 bit platform in 32 bit emulation mode (WOW64).
// It will also return TRUE of we cannot load kernel32.dll, and that is OK because currently this
// call is only used to disable the 3D functionality on WOW64, and it is safe to assume that when
// the call fails we should not use 3D. 
#ifndef _IA64_
BOOL IsWow64()
{
    typedef BOOL (WINAPI *PFN_ISWOW64PROC)( HANDLE hProcess, PBOOL Wow64Process );
    HINSTANCE hInst = NULL;
    if(!hInst)
        hInst = LoadLibrary( "kernel32.dll" );
    if(!hInst)
        return TRUE;
    PFN_ISWOW64PROC pfnIsWow64 = NULL;
    pfnIsWow64 = (PFN_ISWOW64PROC)GetProcAddress( (HMODULE)hInst, "IsWow64Process" );
    // We assume that if this function is not available, then it is some OS where
    // WOW64 does not exist
    if( pfnIsWow64 ) 
    {
        BOOL wow64Process;
        if (pfnIsWow64(GetCurrentProcess(), &wow64Process) && wow64Process)
        {
            FreeLibrary(hInst);
            return TRUE;
        } 
    }
    FreeLibrary(hInst);
    return FALSE;
}
#endif // _IA64_


RawString
CopyWideString(WideString bstr)
{
    long len = lstrlenW(bstr);
    // I am not sure why the buffer has to be 2 times the size
    // required but I think the conversion function must copy the
    // string first and then convert it inplace.
    RawString buf = (RawString) AllocateFromStore((len + 1) * 2 * sizeof(char)) ;
    // Need to pass in len + 1 to get the terminator
    AtlW2AHelper(buf,bstr,len + 1);
    return buf ;
}

WideString
CopyRawString(RawString str)
{
    long len = lstrlen(str);
    WideString buf = (WideString) AllocateFromStore((len + 1) * sizeof(WCHAR)) ;
    // Need to pass in len + 1 to get the terminator
    AtlA2WHelper(buf,str,len + 1);
    return buf ;
}

bool IntersectHorzRightRay(Point2Value *rayToRight, Point2Value *a, Point2Value *b)
{
    Real sx = b->x - a->x;
    Real sy = b->y - a->y;

    Real x = a->x + (sx * (rayToRight->y - a->y) / sy);

    return (x > rayToRight->x);
}



/*****************************************************************************
Given N, this function returns the smallest 2^P such that 2^P >= N.  For
example, if given 27, this function returns 32.
*****************************************************************************/

int CeilingPowerOf2 (int num)
{
    int value = 1;

    while (value && (value < num))
        value <<= 1;

    return value;
}


/*****************************************************************************
Get the current system time as a double.
*****************************************************************************/

double GetCurrTime (void)
{
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);

    ULARGE_INTEGER li100nano; // 10E-7 period
    li100nano.LowPart = ft.dwLowDateTime;
    li100nano.HighPart = ft.dwHighDateTime;

    // Convert to 1 mS period
    ULARGE_INTEGER li1mill ;

    li1mill.QuadPart = li100nano.QuadPart / 10000; // 10E-3 period

    double dlow = (double) li1mill.LowPart ;

    // Multiply by 2^32
    double dhigh = ((double) li1mill.HighPart) * 4294967296.0;

    double d1mill = dlow + dhigh;

    // Convert from 10E-3 to 1.
    return d1mill / 1000.0;
}


#if 0  /* Not required by 3D device enumeration now */
/*****************************************************************************
Indicate whether the current processor supports MMX instructions.
*****************************************************************************/

#ifndef _M_IX86

    bool MMX_Able (void) { return false; }

#else

    // Disable the warning about illegal instruction size

    #pragma warning(disable:4409)
    int IsMMX (void)
    {
        int result = 0;

        __asm xor eax,eax          ; Save everything
        __asm pushad

        __asm mov eax,1            ; Execute a CPUID instruction.
        __asm __emit 0x0F;
        __asm __emit 0xA2;

        __asm test edx,00800000h   ; Test the MMX support bit (23)

        __asm popad                ; Restore everything

        __asm setnz result         ; Set low byte to 00 (no-MMX) or 01 (MMX)

        return result;
    }
    #pragma warning(default:4409)

    static bool MMX_Able_NonNT (SYSTEM_INFO &si)
    {
        return (si.dwProcessorType == PROCESSOR_INTEL_PENTIUM) && IsMMX();
    }

    static bool MMX_Able_NT (SYSTEM_INFO &si)
    {
        bool result = false;

        if (  (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
           || (si.wProcessorLevel >= 5))
        {
            __try
            {
                // Emits an emms instruction.  This file needs to compile for
                // non-Pentium processors, so we can't use inline asm since we're
                // in the wrong processor mode.

                __asm __emit 0xf;
                __asm __emit 0x77;
                result = true;
            }
            __except ( EXCEPTION( STATUS_ILLEGAL_INSTRUCTION ) )
            {
            }
        }

        return result;
    }

    bool MMX_Able (void)
    {
        static bool initialized = false;
        static bool result = false;

        if (!initialized)
        {
            SYSTEM_INFO si;
            GetSystemInfo (&si);

            result = sysInfo.IsNT() ? MMX_Able_NT(si) : MMX_Able_NonNT(si);

            initialized = true;
        }

        return result;
    }

#endif
#endif /* 0 */


/*****************************************************************************
Compare two RECT structures (windows RECTangle)
*****************************************************************************/

int operator== (RECT &r1, RECT &r2)
{
    return (r1.left   == r2.left)
        && (r1.top    == r2.top)
        && (r1.right  == r2.right)
        && (r1.bottom == r2.bottom);
}



/*****************************************************************************
Given an IEEE floating point number, decremement/increment the mantissa by the
given amount.  Note that due to the nature of IEEE floating point numbers, an
underflow/overflow will properly adjust the exponent.
*****************************************************************************/

float MantissaDecrement (float n, int decrement)
{   *(int*)(&n) -= decrement;
    return n;
}

float MantissaIncrement (float n, int increment)
{   *(int*)(&n) += increment;
    return n;
}



DWORD
GetPerfTickCount()
{
    LARGE_INTEGER lpc;
    BOOL result = QueryPerformanceCounter(&lpc);
    return lpc.LowPart;
}

#if PERFORMANCE_REPORTING

/**************  Performance Timer  ***************/

PerformanceTimer::PerformanceTimer()
{
    _totalTicks = 0;
    _localStart = 0;
    _isStarted = false;
}

void
PerformanceTimer::Start()
{
    CritSectGrabber grab(_criticalSection);

    if (_isStarted) {
        #if _DEBUG
        if(GetCurrentThreadId() == _threadStartedOn) {
            TraceTag((tagWarning, "Timer already started on this thread"));
        }
        #endif

        // Ignore starts on other thread if we're already started.
        return;
    }

    _isStarted = true;
    _threadStartedOn = GetCurrentThreadId();
    _localStart = GetPerfTickCount();

#if _DEBUG    
    static PerformanceTimer *stopOnThisOne = NULL;

    if (stopOnThisOne == this) {
        int breakHere = 0;
    }
#endif
    
}



/*****************************************************************************
The stop function takes an HRESULT (default value 0), which it returns after
the timer has stopped.  This is useful for timing statements.
*****************************************************************************/

HRESULT
PerformanceTimer::Stop (HRESULT result)
{
    CritSectGrabber grab(_criticalSection);

    // Only honor request if we are on the thread we were started on.
    if (_isStarted && (GetCurrentThreadId() == _threadStartedOn)) {
        _totalTicks += (GetPerfTickCount() - _localStart);
        _isStarted = false;
    }

    return result;
}

void
PerformanceTimer::Reset()
{
    CritSectGrabber grab(_criticalSection);

    _totalTicks = 0;
}

double
PerformanceTimer::GetTime()
{
    CritSectGrabber grab(_criticalSection);

    if (_isStarted) {
        // Make sure this is being called from a thread other than
        // what it is started on, else this is a logic error.
        #if _DEBUG
        if(GetCurrentThreadId() != _threadStartedOn) {
            TraceTag((tagWarning, "Getting time on the same thread that a started timer is on"));
        }
        #endif
        
        return 0.0;
    }

    return (double)(_totalTicks) / (double)(perfFrequency);
}

DWORD
PerformanceTimer::Ticks()
{
    CritSectGrabber grab(_criticalSection);

    if (_isStarted) {
        // Make sure this is being called from a thread other than
        // what it is started on, else this is a logic error.
        #if _DEBUG
        if(GetCurrentThreadId() != _threadStartedOn) {
            TraceTag((tagWarning, "Getting ticks on the same thread that a started timer is on"));
        }
        //Assert(GetCurrentThreadId() != _threadStartedOn && "Getting ticks on the same thread that a started timer is on");
        #endif
        

        return 0;
    }

    return _totalTicks;
}
#endif

#if PERFORMANCE_REPORTING

void
vPerfPrintf(char *format, va_list args)
{
    Assert (format);

    char buf[4096];

#if 0
    wvsprintf(buf,format,args);
#else
    vsprintf(buf,format,args);
#endif

    OutputDebugString(buf);
    //DebugCode(printf(buf););
}



void
PerfPrintf(char *format, ...)
{
    va_list args;

    va_start(args, format) ;

    vPerfPrintf(format,args);
}

void
PerfPrintLine(char *format, ...)
{
    va_list args;
    va_start(args, format) ;
    if (format) {
        vPerfPrintf(format,args);
    }

    vPerfPrintf("\n",args);

    va_end(args);

    //DebugCode(fflush(stdout););
}

#endif

DWORD perfFrequency = 0;

static DWORD srvutilTlsIndex = 0xFFFFFFFF;

LPVOID
GetSrvUtilData()
{
    return TlsGetValue(srvutilTlsIndex);
}

void
SetSrvUtilData(LPVOID lpv)
{
    BOOL ok = TlsSetValue(srvutilTlsIndex, lpv);
    Assert(ok && "Error in TlsSetValue");
}

void Win32Translator (unsigned int u, EXCEPTION_POINTERS * pExp)
{
    // WARNING: Do not do too much here since we may not have much stack

    switch (pExp->ExceptionRecord->ExceptionCode) {
      case EXCEPTION_FLT_DIVIDE_BY_ZERO:
      case EXCEPTION_INT_DIVIDE_BY_ZERO:
        RaiseException_DivideByZero () ;
        break ;
      case EXCEPTION_STACK_OVERFLOW:
        RaiseException_StackFault ();
        break ;
    }
}

void CatchWin32Faults (BOOL b)
{
    if (b) {
        _se_translator_function prev = _set_se_translator (Win32Translator) ;

        if (prev != Win32Translator) {
            SetSrvUtilData (prev) ;
        }
    } else {
        _se_translator_function cur = _set_se_translator (Win32Translator) ;

        if (cur == Win32Translator) {
            _set_se_translator ((_se_translator_function) GetSrvUtilData ()) ;
        }
    }
}

void
InitializeModule_Util()
{
    LARGE_INTEGER lpc;
    QueryPerformanceFrequency(&lpc);
    perfFrequency = lpc.LowPart;

    srvutilTlsIndex = TlsAlloc();
    Assert((srvutilTlsIndex != 0xFFFFFFFF) &&
           "TlsAlloc() failed");
}

void
DeinitializeModule_Util(bool bShutdown)
{
    if (srvutilTlsIndex != 0xFFFFFFFF)
        TlsFree(srvutilTlsIndex);
}


bool 
isNear(double value, double test, double epsilon)
{
    return((fabs(value - test)) < epsilon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\fullattr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Master, coalesced attributer class for Geometry

*******************************************************************************/

#include "headers.h"

#include "fullattr.h"

#include "privinc/dispdevi.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"

#include "privinc/colori.h"
#include "privinc/ddrender.h"
#include "privinc/lighti.h"
#include "privinc/soundi.h"
#include "privinc/probe.h"
#include "privinc/opt.h"


    // Function Declarations

Geometry *applyTexture (Image *texture, Geometry*, bool oldStyle);



FullAttrStateGeom::FullAttrStateGeom()
{
    _validAttrs = 0;
    _mostRecent = 0;
}


#if _USE_PRINT
ostream&
FullAttrStateGeom::Print(ostream& os)
{
    return os << "FullAttrGeom(" << _geometry << ")";
}
#endif

#define COPY_IF_SET(flag, member) \
  if (src->IsAttrSet(flag)) member = src->member;

void
FullAttrStateGeom::CopyStateFrom(FullAttrStateGeom *src)
{
    COPY_IF_SET(FA_DIFFUSE, _diffuseColor);
    COPY_IF_SET(FA_BLEND,   _blend);
    COPY_IF_SET(FA_XFORM,   _xform);
    COPY_IF_SET(FA_TEXTURE, _textureBundle);
    COPY_IF_SET(FA_OPACITY, _opacity);

    DWORD otherMatProps =
        FA_AMBIENT | FA_EMISSIVE | FA_SPECULAR | FA_SPECULAR_EXP;

    // Trivially reject entire batches
    if (src->IsAttrSet(otherMatProps)) {
        COPY_IF_SET(FA_AMBIENT, _ambientColor);
        COPY_IF_SET(FA_EMISSIVE, _emissiveColor);
        COPY_IF_SET(FA_SPECULAR, _specularColor);
        COPY_IF_SET(FA_SPECULAR_EXP, _specularExpPower);
    }

    DWORD rareProps =
        FA_LIGHTCOLOR | FA_LIGHTRANGE | FA_LIGHTATTEN | FA_UNDETECTABLE;

    // Trivially reject entire batches
    if (src->IsAttrSet(rareProps)) {
        COPY_IF_SET(FA_LIGHTCOLOR, _lightColor);
        COPY_IF_SET(FA_LIGHTRANGE, _lightRange);
        COPY_IF_SET(FA_UNDETECTABLE, _undetectable);

        if (src->IsAttrSet(FA_LIGHTATTEN)) {
            _atten0 = src->_atten0;
            _atten1 = src->_atten1;
            _atten2 = src->_atten2;
        }
    }

    _flags = src->GetFlags();
    _geometry = src->_geometry;
    _mostRecent = src->_mostRecent;
    _validAttrs = src->_validAttrs;
}

void
FullAttrStateGeom::SetGeometry(Geometry *geo)
{
    _geometry = geo;
    _flags = geo->GetFlags();
}

void
FullAttrStateGeom::Render(GenericDevice& genDev)
{
    GeomRenderer& dev = SAFE_CAST(GeomRenderer&, genDev);

    if (!dev.IsShadowing()) {
        if (IsAttrSet(FA_OPACITY) && (_opacity < (1./255.))) {
            // Just skip rendering entirely, object is effectively
            // completely transparent.
            return;
        }
    }

    // Push all necessary state
    if (IsAttrSet(FA_AMBIENT)) { dev.PushAmbient(_ambientColor); }
    if (IsAttrSet(FA_EMISSIVE)) { dev.PushEmissive(_emissiveColor); }
    if (IsAttrSet(FA_SPECULAR)) { dev.PushSpecular(_specularColor); }
    if (IsAttrSet(FA_SPECULAR_EXP)) { dev.PushSpecularExp(_specularExpPower); }
    if (IsAttrSet(FA_BLEND)) { dev.PushTexDiffBlend(_blend); }

    Transform3 *xformSave;
    if (IsAttrSet(FA_XFORM)) {
        xformSave = dev.GetTransform();
        dev.SetTransform(TimesXformXform(xformSave, _xform));
    }

    // GeomRenderer.GetOpacity may return -1 if no opacity is currently active.

    Real opacitySave;

    if (IsAttrSet(FA_OPACITY)) {
        opacitySave = dev.GetOpacity();

        if (opacitySave < 0)
            dev.SetOpacity (_opacity);
        else
            dev.SetOpacity (opacitySave * _opacity);
    }

    bool doBoth = IsAttrSet(FA_BLEND) && _blend;

    bool pushedDiffuse = false;
    bool pushedTexture = false;

    if (_mostRecent == FA_DIFFUSE ||
        (doBoth && (IsAttrSet(FA_DIFFUSE)))) {

        Assert(IsAttrSet(FA_DIFFUSE));
        dev.PushDiffuse(_diffuseColor);
        pushedDiffuse = true;
    }

    if (_mostRecent == FA_TEXTURE ||
        (doBoth && (IsAttrSet(FA_TEXTURE)))) {

        Assert(IsAttrSet(FA_TEXTURE));

        void *texToUse = _textureBundle._nativeRMTexture ?
                             _textureBundle._rmTexture._voidTex :
                             _textureBundle._daTexture._d3dRMTexture;

        dev.PushTexture(texToUse);
        pushedTexture = true;
    }

    // Render
    _geometry->Render(dev);

    // Pop all pushed state

    if (pushedDiffuse) { dev.PopDiffuse(); }
    if (pushedTexture) { dev.PopTexture(); }

    if (IsAttrSet(FA_OPACITY)) { dev.SetOpacity(opacitySave); }
    if (IsAttrSet(FA_XFORM)) { dev.SetTransform(xformSave); }
    if (IsAttrSet(FA_BLEND)) { dev.PopTexDiffBlend(); }
    if (IsAttrSet(FA_SPECULAR_EXP)) { dev.PopSpecularExp(); }
    if (IsAttrSet(FA_SPECULAR)) { dev.PopSpecular(); }
    if (IsAttrSet(FA_EMISSIVE)) { dev.PopEmissive(); }
    if (IsAttrSet(FA_AMBIENT)) { dev.PopAmbient(); }
}


void
FullAttrStateGeom::CollectSounds(SoundTraversalContext &ctx)
{
    Transform3 *xformSave;
    bool isSet = IsAttrSet(FA_XFORM);

    if (isSet) {
        xformSave = ctx.getTransform();
        ctx.setTransform (TimesXformXform(xformSave, _xform));
    }

    _geometry->CollectSounds(ctx);

    if (isSet) {
        ctx.setTransform(xformSave);
    }
}

void
FullAttrStateGeom::CollectLights(LightContext &ctx)
{
    Transform3 *xformSave;
    bool isXfSet = IsAttrSet(FA_XFORM);
    bool isAttenSet = IsAttrSet(FA_LIGHTATTEN);
    bool isColSet = IsAttrSet(FA_LIGHTCOLOR);
    bool isRangeSet = IsAttrSet(FA_LIGHTRANGE);

    if (isXfSet) {
        xformSave = ctx.GetTransform();
        ctx.SetTransform(TimesXformXform(xformSave, _xform));
    }

    if (isAttenSet) { ctx.PushAttenuation(_atten0, _atten1, _atten2); }
    if (isColSet) { ctx.PushColor(_lightColor); }
    if (isRangeSet) { ctx.PushRange(_lightRange); }

    _geometry->CollectLights(ctx);

    if (isRangeSet) { ctx.PopRange(); }
    if (isColSet) { ctx.PopColor(); }
    if (isAttenSet) { ctx.PopAttenuation(); }
    if (isXfSet) { ctx.SetTransform(xformSave); }
}


void
FullAttrStateGeom::CollectTextures(GeomRenderer &device)
{

    // Only need to do anything if we're texturing with a non-native
    // RM texture.

    // If we are not texturing, then we need to process what's below
    // us.

    if (IsAttrSet(FA_TEXTURE) && !_textureBundle._nativeRMTexture) {
        DATextureBundle &dat = _textureBundle._daTexture;
        dat._d3dRMTexture =
            device.DeriveTextureHandle (dat._texture, false, dat._oldStyle);
    } else {
        _geometry->CollectTextures(device);
    }
}

void
FullAttrStateGeom::RayIntersect(RayIntersectCtx &context)
{
    if (IsAttrSet(FA_UNDETECTABLE) && _undetectable) {
        return;
    }

    bool isDATexture =
        IsAttrSet(FA_TEXTURE) && (!_textureBundle._nativeRMTexture);

    bool isXfSet = IsAttrSet(FA_XFORM);

    if (isDATexture) {
        context.SetTexmap(_textureBundle._daTexture._texture,
            _textureBundle._daTexture._oldStyle);
    }

    Transform3 *xformSave;
    if (isXfSet) {
        xformSave = context.GetLcToWc();
        context.SetLcToWc(TimesXformXform(xformSave, _xform));
    }

    _geometry->RayIntersect(context);

    if (isXfSet) { context.SetLcToWc(xformSave); }
    if (isDATexture) { context.EndTexmap(); }
}


Bbox3 *
FullAttrStateGeom::BoundingVol()
{
    Bbox3 *underlying = _geometry->BoundingVol();
    Bbox3 *result;

    if (IsAttrSet(FA_XFORM)) {
        result = TransformBbox3(_xform, underlying);
    } else {
        result = underlying;
    }

    return result;
}

// Forward decl.
Geometry *applyTextureImage(Image *texture, Geometry *geo);

AxAValue
FullAttrStateGeom::_Cache(CacheParam &p)
{
    // Cache the native DA image.
    if (IsAttrSet(FA_TEXTURE) && !_textureBundle._nativeRMTexture) {

        AxAValue result;

        // Always pre-calc the RM texture for the cache.
        CacheParam txtrParam = p;
        txtrParam._isTexture = true;

        Image *image = _textureBundle._daTexture._texture;

        Image *newImage =
            SAFE_CAST(Image *, AxAValueObj::Cache(image, txtrParam));

        if (newImage == image) {

            // Cache is identical to the original image.  It's
            // possible that the system attempted to cache it as a
            // bitmap and failed.  However, in this context, we know
            // we're going to be used as a texture, so bypass the
            // "Cache" method (which looks up its results) and go
            // straight to the raw _Cache method to compute again
            // (this time it will try as a texture)

            if (!(image->GetFlags() & IMGFLAG_CONTAINS_GRADIENT)) {
                
                // HACK!! Disallow caching of gradients for use as
                // textures.  Currently messed up (bug 28131).
                
                newImage =
                    SAFE_CAST(Image *, image->_Cache(txtrParam));

                // We stash it away even though it may be invalid for
                // certain other uses.  For instance, when an image
                // is used as a texture and as a regular image, we
                // probably don't want to hit the texture cache for
                // the regular image usage.  We'll live with that
                // restriction for now.
                image->SetCachedImage(newImage);

            }
        }
        
        if (newImage != image) {

            // Just texture "this" with the new image.  Since textures
            // override, this will result in creating a new
            // FullAttrStateGeom and replacing the existing texture
            // ("image") with this one, and we'll lose our reference
            // to "image".

            return applyTexture
                (newImage, this, _textureBundle._daTexture._oldStyle);

        }

        // Note we don't proceed down the geometry.  That's on the
        // assumption that it's not yet interesting to actually cache
        // geometry other than the texture, and that any texture below
        // would be ignored, since we're applying an outer texture
        // here.

    }

    return this;
}


void
FullAttrStateGeom::DoKids(GCFuncObj proc)
{
    (*proc)(_geometry);
    if (IsAttrSet(FA_AMBIENT)) (*proc)(_ambientColor);
    if (IsAttrSet(FA_DIFFUSE)) (*proc)(_diffuseColor);
    if (IsAttrSet(FA_EMISSIVE)) (*proc)(_emissiveColor);
    if (IsAttrSet(FA_SPECULAR)) (*proc)(_specularColor);
    if (IsAttrSet(FA_XFORM)) (*proc)(_xform);
    if (IsAttrSet(FA_LIGHTCOLOR)) (*proc)(_lightColor);

    if (IsAttrSet(FA_TEXTURE)) {
        if (!_textureBundle._nativeRMTexture) {
            (*proc)(_textureBundle._daTexture._texture);
        } else {
            (*proc)(_textureBundle._rmTexture._gcUnk);
        }
    }
}



////////////////////   C O N S T R U C T O R S   /////////////////////////


FullAttrStateGeom *
CombineState(Geometry *geo)
{
    FullAttrStateGeom *f = NEW FullAttrStateGeom;

    if (geo->GetValTypeId() == FULLATTRGEOM_VTYPEID) {

        // If the geometry we're attributing is a FullAttrStateGeom
        // itself, then we just copy over its state, and lose our
        // reference to the original one.
        FullAttrStateGeom *old =
            SAFE_CAST(FullAttrStateGeom *, geo);
        f->CopyStateFrom(old);

    } else {

        // Otherwise, we just have the new one's geometry point to the
        // old geometry, and thus keep a reference to the old
        // geometry.
        f->SetGeometry(geo);
    }

    return f;
}

Geometry *
UndetectableGeometry(Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_UNDETECTABLE);
    f->_undetectable = true;
    return f;
}

Geometry *applyDiffuseColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_DIFFUSE);
    f->SetMostRecent(FA_DIFFUSE); // for blend
    f->_diffuseColor = color;
    return f;
}


Geometry *applyEmissiveColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_EMISSIVE);
    f->_emissiveColor = color;
    return f;
}

Geometry *applyAmbientColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_AMBIENT);
    f->_ambientColor = color;
    return f;
}

Geometry *applySpecularColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_SPECULAR);
    f->_specularColor = color;
    return f;
}

Geometry *applySpecularExponent(AxANumber *power, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_SPECULAR_EXP);
    f->_specularExpPower = NumberToReal(power);
    return f;
}

Geometry *BlendTextureDiffuse (Geometry *geo, AxABoolean *blended)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_BLEND);
    f->_blend = blended->GetBool();
    return f;
}

Geometry *applyTexture (Image *texture, Geometry *geo, bool oldStyle)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);

    // Don't worry about releasing a current texture if one is
    // there... nothing is being held onto.

    f->SetAttr(FA_TEXTURE);
    f->SetMostRecent(FA_TEXTURE); // for blend
    f->_textureBundle._nativeRMTexture = false;
    f->_textureBundle._daTexture._texture = texture;
    f->_textureBundle._daTexture._d3dRMTexture = NULL;
    f->_textureBundle._daTexture._oldStyle = oldStyle;

    return f;
}

Geometry *applyTextureMap(Image *texture, Geometry *geo)
{
    return applyTexture (texture, geo, true);
}

Geometry *applyTextureImage(Image *texture, Geometry *geo)
{
    return applyTexture(texture, geo, false);
}

Geometry *applyTransform(Transform3 *xform, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    Transform3 *newXf;
    if (f->IsAttrSet(FA_XFORM)) {
        newXf = TimesXformXform(xform, f->_xform);
    } else {
        newXf = xform;
    }

    f->SetAttr(FA_XFORM);
    f->_xform = newXf;

    return f;
}

Geometry *applyOpacityLevel(AxANumber *opac, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    Real o = NumberToReal(opac);
    Real newOpac;
    if (f->IsAttrSet(FA_OPACITY)) {
        // Multiply the opacity in to combine
        newOpac = f->_opacity * o;
    } else {
        newOpac = o;
    }

    f->SetAttr(FA_OPACITY);
    f->_opacity = o;

    return f;
}

Geometry *applyLightColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_LIGHTCOLOR);
    f->_lightColor = color;
    return f;
}

Geometry *applyLightRange(Real range, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_LIGHTRANGE);
    f->_lightRange = range;
    return f;
}

Geometry *applyLightRange(AxANumber *range, Geometry *geometry)
{
    return applyLightRange(NumberToReal(range), geometry);
}

Geometry *applyLightAttenuation(Real A0, Real A1, Real A2, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    // If all attenuation parameters are zero, then do not attenuate.
    if ((A0==0) && (A1==0) && (A2==0))
        A0 = 1;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_LIGHTATTEN);
    f->_atten0 = A0;
    f->_atten1 = A1;
    f->_atten2 = A2;
    return f;
}

Geometry *applyLightAttenuation(AxANumber *A0,
                                AxANumber *A1,
                                AxANumber *A2,
                                Geometry *geo)
{
    return applyLightAttenuation(NumberToReal(A0),
                                 NumberToReal(A1),
                                 NumberToReal(A2),
                                 geo);
}

/////////////   D E B U G G I N G   F A C I L I T I E S   /////////////////

#if _DEBUG

void
PrintAttrStateColor(char *descrip, Color *col)
{
    char buf[256];
    sprintf(buf, "%s: %8.5f %8.5f %8.5f\n",
            descrip, col->red, col->green, col->blue);
    OutputDebugString(buf);
}

void
PrintAttrStateNum(char *descrip, Real num)
{
    char buf[256];
    sprintf(buf, "%s: %8.5f\n", descrip, num);
    OutputDebugString(buf);
}

void
PrintAttrState(FullAttrStateGeom *g)
{
    char buf[256];
    sprintf(buf, "Size of FullAttrStateGeom is %d bytes\n",
            sizeof(FullAttrStateGeom));
    OutputDebugString(buf);

    if (g->IsAttrSet(FA_AMBIENT))
        PrintAttrStateColor("Ambient", g->_ambientColor);

    if (g->IsAttrSet(FA_DIFFUSE))
        PrintAttrStateColor("Diffuse", g->_diffuseColor);

    if (g->IsAttrSet(FA_EMISSIVE))
        PrintAttrStateColor("Emissive", g->_emissiveColor);

    if (g->IsAttrSet(FA_SPECULAR))
        PrintAttrStateColor("Specular", g->_specularColor);

    if (g->IsAttrSet(FA_SPECULAR_EXP))
        PrintAttrStateNum("Specular Exp", g->_specularExpPower);

    if (g->IsAttrSet(FA_OPACITY))
        PrintAttrStateNum("Opacity", g->_opacity);

    if (g->IsAttrSet(FA_BLEND))
        PrintAttrStateNum("Blend", g->_blend ? 1 : 0);

    if (g->IsAttrSet(FA_XFORM))
        PrintAttrStateNum("Xform Present", 1);

    if (g->IsAttrSet(FA_TEXTURE))
        PrintAttrStateNum("Texture Present", 1);

    if (g->IsAttrSet(FA_LIGHTCOLOR))
        PrintAttrStateColor("Light Color", g->_lightColor);

    if (g->IsAttrSet(FA_LIGHTATTEN)) {
        PrintAttrStateNum("Atten0", g->_atten0);
        PrintAttrStateNum("Atten1", g->_atten1);
        PrintAttrStateNum("Atten2", g->_atten2);
    }

    if (g->IsAttrSet(FA_LIGHTRANGE))
        PrintAttrStateNum("Light Range", g->_lightRange);

    if (g->IsAttrSet(FA_UNDETECTABLE))
        PrintAttrStateNum("Undetectable", g->_undetectable);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\billboard.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

    Billboard geometries face the camera on rendering or picking, aligned with
    either the camera up vector or with an optionally-supplied axis of
    rotation.

*******************************************************************************/

#include "headers.h"
#include "appelles/geom.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"
#include "privinc/camerai.h"
#include "privinc/lighti.h"
#include "privinc/ddrender.h"



class BillboardGeo : public Geometry
{
  public:

    BillboardGeo (Geometry *geo, Vector3Value *axis);

    void Render (GenericDevice &gendev);

    void CollectLights   (LightContext &context);
    void CollectSounds   (SoundTraversalContext &context);
    void CollectTextures (GeomRenderer &device);

    void RayIntersect (RayIntersectCtx &context);

    Bbox3* BoundingVol (void);

    void DoKids (GCFuncObj proc);

    #if _USE_PRINT
        virtual ostream& Print (ostream& os);
    #endif

  private:

    Transform3* BBTransform (Camera*, Transform3*);

    // These members define the billboard.

    Geometry       *_geometry;        // Geometry to Billboard
    Vector3Value    _axis;            // Rotation Axis
    bool            _constrained;     // Constrained to Rotation Axis?
};



/*****************************************************************************
The constructor for the billboard geometry transform
*****************************************************************************/

BillboardGeo::BillboardGeo (Geometry *geo, Vector3Value *axis)
    : _geometry (geo),
      _axis     (*axis)
{
    Real axisLenSq = _axis.LengthSquared();

    if (axisLenSq == 0)
    {
        _constrained = false;
    }
    else
    {
        // If a billboard axis is supplied, normalize it.

        _constrained = true;
        _axis /= sqrt(axisLenSq);
    }
}



/*****************************************************************************
Mark value object members currently in use.
*****************************************************************************/

void BillboardGeo::DoKids (GCFuncObj proc)
{
    (*proc)(_geometry);
}



/*****************************************************************************
This method prints out the text description of the billboard geometry.
*****************************************************************************/

#if _USE_PRINT
ostream& BillboardGeo::Print (ostream &os)
{
    return os << "BillboardGeo("
              << _geometry
              << ",{"
              << _axis.x << ","
              << _axis.y << ","
              << _axis.z
              << "})";
}
#endif



/*****************************************************************************
Visually render the billboard geometry.
*****************************************************************************/

void BillboardGeo::Render (GenericDevice &gendev)
{
    GeomRenderer &renderer = SAFE_CAST (GeomRenderer&, gendev);

    Transform3 *xform = renderer.GetTransform();
    Transform3 *bbxform = BBTransform (renderer.CurrentCamera(), xform);

    // Replace the modeling transform with the billboard transform, render,
    // and then restor the modeling transform.

    renderer.SetTransform (bbxform);
    _geometry->Render (renderer);
    renderer.SetTransform (xform);
}



/*****************************************************************************
Collect the lights contained in the billboard geometry.
*****************************************************************************/

void BillboardGeo::CollectLights (LightContext &context)
{
    GeomRenderer *renderer = context.Renderer();
    Transform3   *xform = context.GetTransform();

    // Update the billboard transform.  If the light context doesn't know about
    // a geometry renderer (and hence doesn't know about the camera), pass NULL
    // in for the camera.

    Transform3 *bbxform;

    if (renderer)
        bbxform = BBTransform (renderer->CurrentCamera(), xform);
    else
        bbxform = BBTransform (NULL, xform);

    // Set the new billboard transform, continue light collection, and restore
    // the initial transform.

    context.SetTransform (bbxform);
    _geometry->CollectLights (context);
    context.SetTransform (xform);
}



/*****************************************************************************
This method collects the sounds in the billboarded geometry.  Since we don't
know the camera at the CollectSounds traversal, this essentially no-ops the
billboard transform.
*****************************************************************************/

void BillboardGeo::CollectSounds (SoundTraversalContext &context)
{
    _geometry->CollectSounds (context);
}



/*****************************************************************************
Collect all 3D texture maps from the contained geometry.
*****************************************************************************/

void BillboardGeo::CollectTextures (GeomRenderer &device)
{
    // Billboarding does not affect what texture maps we contain; just descend.

    _geometry->CollectTextures (device);
}



/*****************************************************************************
Perform ray-intersection test on the billboarded geometry.  We can fetch both
the camera and the model transform from the context parameter.
*****************************************************************************/

void BillboardGeo::RayIntersect (RayIntersectCtx &context)
{
    Transform3 *xform = context.GetLcToWc();
    Transform3 *bbxform = BBTransform (context.GetCamera(), xform);

    context.SetLcToWc (bbxform);         // Set Billboard Transform
    _geometry->RayIntersect (context);
    context.SetLcToWc (xform);           // Restore Model Transform
}



/*****************************************************************************
This method function returns the bounding box of the billboard geometry.
Since we don't know the camera at this time, we calculate the worst-case
bounding box, which is encloses the spherical space swept out by all possible
orientations of the billboard geometry.
*****************************************************************************/

Bbox3* BillboardGeo::BoundingVol (void)
{
    // The sphere that encloses all possible orientations of the billboard
    // geometry is centered at the model coordinate origin (since that's what
    // the billboard pivots around), and is swept out by the farthest corner
    // of the bounding box.  Iterate through the three dimensions, picking the
    // farthest point for each one, and construct the vector to that farthest
    // corner.

    Bbox3 *bbox = _geometry->BoundingVol();

    Vector3Value v;   // Vector to Farthest BBox Corner
    Real A, B;   // Work Variables

    A = fabs (bbox->min.x);
    B = fabs (bbox->max.x);
    v.x = MAX (A,B);

    A = fabs (bbox->min.y);
    B = fabs (bbox->max.y);
    v.y = MAX (A,B);

    A = fabs (bbox->min.z);
    B = fabs (bbox->max.z);
    v.z = MAX (A,B);

    Real radius = v.Length();

    return NEW Bbox3 (-radius, -radius, -radius, radius, radius, radius);
}



/*****************************************************************************
This method updates the billboard transform based on the current modeling
transform and the current position/orientation of the camera.
*****************************************************************************/

Transform3* BillboardGeo::BBTransform (Camera *camera, Transform3 *modelXform)
{
    Assert (modelXform);

    if (!camera)
    {
        // If we don't have a camera available, then we can't compute the true
        // billboard transform.  In this case, make the billboard transform the
        // same as the modeling transform.

        return modelXform;
    }

    // Extract the transform basic components from the camera.

    const Apu4x4Matrix &xfmatrix = modelXform->Matrix();

    Point3Value  origin = xfmatrix.Origin();
    Vector3Value Bx     = xfmatrix.BasisX();
    Vector3Value By     = xfmatrix.BasisY();
    Vector3Value Bz     = xfmatrix.BasisZ();

    // Save the basis vector lengths to preserve them.

    Real Sx = Bx.Length();
    Real Sy = By.Length();
    Real Sz = Bz.Length();

    // Set the billboard basis Z to point toward the camera with unit
    // length.

    Bz = camera->WCProjPoint() - origin;

    // If the camera is located at the model xform origin, then we don't have
    // a viewing axis, so just return the unmodified model xform.

    if (Bz.LengthSquared() == 0.)
        return modelXform;

    Bz.Normalize();

    if (_constrained)
    {
        // If the billboard is constrained to a rotation axis, we need to
        // map the basis Y vector to this axis and adjust the direction
        // vector (Bz) to be perpendicular to it.  Note that _axis is
        // already normalized.

        Bx = Cross (_axis, Bz);

        // If the viewing axis and billboard axis are parallel, then there's
        // no particular billboard rotation that is better than any other;
        // just return the model xform in this case.

        if (Bx.LengthSquared() == 0.)
            return modelXform;

        Bx.Normalize();

        By = _axis;

        Bz = Cross (Bx, By);
    }
    else
    {
        // If the billboard is unconstrained by a rotation axis, rotate
        // around the direction vector to match the billboard up vector
        // with the camera's up vector.

        Vector3Value Cy = camera->Basis()->Matrix().BasisY();

        Bx = Cross (Cy, Bz);

        // If the model up vector is parallel to the viewing axis, then just
        // return the model xform.

        if (Bx.LengthSquared() == 0.)
            return modelXform;

        Bx.Normalize();

        By = Cross (Bz, Bx);
    }

    // Restore original model transform scale factors.

    Bx *= Sx;
    By *= Sy;
    Bz *= Sz;

    return TransformBasis (&origin, &Bx, &By, &Bz);
}



/*****************************************************************************
This is the procedural entry point for creating a billboarded geometry.  The
axis specifies the axis of rotation as the geometry aims toward the camera.
If the axis is the zero vector, then the geometry swivels freely and aligns
with the camera's up vector.
*****************************************************************************/

Geometry* Billboard (Geometry *geo, Vector3Value *axis)
{
    return NEW BillboardGeo (geo, axis);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\fullattr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Master, coalesced attributer class for Geometry

*******************************************************************************/


#ifndef _FULLATTR_H
#define _FULLATTR_H

const int FA_AMBIENT            (1L << 0);
const int FA_DIFFUSE            (1L << 1);
const int FA_SPECULAR           (1L << 2);
const int FA_SPECULAR_EXP       (1L << 3);
const int FA_EMISSIVE           (1L << 4);
const int FA_OPACITY            (1L << 5);
const int FA_BLEND              (1L << 6);
const int FA_XFORM              (1L << 7);
const int FA_TEXTURE            (1L << 8);
const int FA_LIGHTATTEN         (1L << 9);
const int FA_LIGHTCOLOR         (1L << 10);
const int FA_LIGHTRANGE         (1L << 11);
const int FA_UNDETECTABLE       (1L << 12);


class DATextureBundle {
  public:
    Image      *_texture;
    void       *_d3dRMTexture;
    bool        _oldStyle;      // True for 4.01 Texturing
};

class RMTextureBundle {
  public:
    bool   _isRMTexture3;
    union {
        IDirect3DRMTexture  *_texture1;
        IDirect3DRMTexture3 *_texture3;
    };
    void       *_voidTex;
    GCIUnknown *_gcUnk;
};

class TextureBundle {
  public:
    bool _nativeRMTexture;
    union {
        DATextureBundle _daTexture;
        RMTextureBundle _rmTexture;
    };
};

class FullAttrStateGeom : public Geometry {
  public:
    FullAttrStateGeom();

    inline bool IsAttrSet(DWORD attr) {
        return (_validAttrs & attr) ? true : false;
    }

    inline void SetAttr(DWORD attr) { _validAttrs |= attr; } 
    inline void SetMostRecent(DWORD mostRecent) { _mostRecent = mostRecent; }
    inline void AppendFlag(DWORD dw) { _flags |= dw; }
    
    void CopyStateFrom(FullAttrStateGeom *src);
    void SetGeometry(Geometry *g);

    /////  Geometry-class methods
    
    void Render(GenericDevice& device);

    void CollectSounds(SoundTraversalContext &context);

    void CollectLights(LightContext &context);

    void  CollectTextures(GeomRenderer &device);

    void RayIntersect(RayIntersectCtx &context);

    Bbox3 *BoundingVol();

    AxAValue _Cache(CacheParam &p);

    void DoKids(GCFuncObj proc);

    #if _USE_PRINT
        ostream& Print(ostream& os);
    #endif

    VALTYPEID GetValTypeId() { return FULLATTRGEOM_VTYPEID; }


    /////****  Attributes are publically available  ****/////

    ///// Underlying geometry
    Geometry      *_geometry;
    
    ///// Material properties
    Color         *_ambientColor;
    Color         *_diffuseColor;
    Color         *_emissiveColor;
    Color         *_specularColor;
    
    Real           _specularExpPower;
    Real           _opacity;     
    bool           _blend;

    ///// Spatial transform
    Transform3    *_xform;

    ///// Texture properties
    TextureBundle  _textureBundle;

    ///// Light properties
    Real           _atten0, _atten1, _atten2;
    Color         *_lightColor;
    Real           _lightRange;

    ///// Misc
    bool           _undetectable;

  protected:
    DWORD          _validAttrs;
    DWORD          _mostRecent;
};


FullAttrStateGeom *CombineState(Geometry *geo);

#endif /* _FULLATTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\gattr.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Implementation of geometry attributers.  Here we express how to process
geometry attributers in graphics contexts.

*******************************************************************************/
#include "headers.h"

#include "privinc/dispdevi.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"

#include "privinc/colori.h"
#include "privinc/ddrender.h"
#include "privinc/lighti.h"
#include "privinc/soundi.h"
#include "privinc/probe.h"
#include "privinc/opt.h"


/*****************************************************************************
 Implementation of default methods for attributed geometry.
*****************************************************************************/

AttributedGeom::AttributedGeom (Geometry *geometry) :
    _geometry(geometry)
{
    Assert(_geometry && "Constructing AttributedGeom with null geometry.");
    _flags = _geometry->GetFlags();
}

void AttributedGeom::Render (GenericDevice& device)
{
    Render3D (SAFE_CAST(GeomRenderer&,device));
}

void AttributedGeom::Render3D (GeomRenderer& gdev)
{
    _geometry->Render(gdev);    // Just descend by default.
}

void AttributedGeom::CollectSounds (SoundTraversalContext &context)
{
    _geometry->CollectSounds (context);
}

void AttributedGeom::CollectLights (LightContext &context)
{
    _geometry->CollectLights (context);
}

void AttributedGeom::RayIntersect (RayIntersectCtx &context)
{
    _geometry->RayIntersect (context);
}

Bbox3 *AttributedGeom::BoundingVol (void)
{
    return _geometry->BoundingVol();
}

AxAValue
AttributedGeom::_Cache(CacheParam &p)
{
    _geometry =
        SAFE_CAST(Geometry *, AxAValueObj::Cache(_geometry, p));

    return this;
}


/*****************************************************************************
The clipped geometry subjected to a clip against a plane.
*****************************************************************************/

class ClippedGeom : public AttributedGeom
{
  public:

    ClippedGeom (Point3Value *planePt, Vector3Value *planeVec, Geometry *geometry)
        : AttributedGeom(geometry), _plane(*planeVec, *planePt) {}

    void Render3D (GeomRenderer &ddrenderer)
    {
        Bbox3 *boundingVol = _geometry->BoundingVol();
        if (boundingVol->Clip(_plane) != CLIPCODE_OUT) {
            Plane3 *xformedPlane = NEW Plane3(_plane);
            *xformedPlane *= ddrenderer.GetTransform();
            DWORD planeID;
            HRESULT hr = ddrenderer.SetClipPlane(xformedPlane,&planeID);
            _geometry->Render(ddrenderer);
            if (SUCCEEDED(hr)) {
                ddrenderer.ClearClipPlane(planeID);
            }
        }
    }

    #if _USE_PRINT
    virtual ostream& Print (ostream& os) {
        return os << "ClippedGeom(" << _plane << ","
                  << _geometry << ")";
    }
    #endif

  protected:

    Plane3 _plane;
};


Geometry *applyModelClip(Point3Value *planePt, Vector3Value *planeVec,
                         Geometry *geometry)
{
    if (!geometry) {
        return emptyGeometry;
    }

    if (planePt && planeVec) {
        return NEW ClippedGeom(planePt,planeVec,geometry);
    } else {
        return geometry;
    }
}


/*****************************************************************************
Attributor that allows lighting to be set on or off
*****************************************************************************/

class LightingGeom : public AttributedGeom
{
  public:

    LightingGeom (bool lighting, Geometry *geometry)
        : AttributedGeom(geometry), _doLighting(lighting) {}

    void Render3D (GeomRenderer &ddrenderer)
    {
        ddrenderer.PushLighting(_doLighting);
        _geometry->Render(ddrenderer);
        ddrenderer.PopLighting();
    }

    #if _USE_PRINT
        virtual ostream& Print (ostream& os) {
            return os << "LightingGeom(" << _doLighting << ","
                      << _geometry << ")";
        }
    #endif

  protected:

    bool _doLighting;
};


Geometry *applyLighting (AxABoolean *lighting, Geometry *geo)
{
    if (!geo) {
        return emptyGeometry;
    }

    if (lighting) {
        return NEW LightingGeom(lighting->GetBool(),geo);
    } else {
        return geo;
    }
}



/*****************************************************************************
The overriding-opacity attribute controls whether opacity overrides or
multiplies with opacities contained in X files and other imported geometry.
*****************************************************************************/

class OverridingOpacityGeom : public AttributedGeom
{
  public:

    OverridingOpacityGeom (Geometry *geometry, bool override)
        : AttributedGeom(geometry), _override(override) {}

    void Render3D (GeomRenderer &ddrenderer)
    {
        ddrenderer.PushOverridingOpacity (_override);
        _geometry->Render(ddrenderer);
        ddrenderer.PopOverridingOpacity();
    }

    #if _USE_PRINT
        virtual ostream& Print (ostream& os) {
            return os << "OverridingOpacityGeom(" << _override << ","
                      << _geometry << ")";
        }
    #endif

  protected:

    bool _override;
};

Geometry* OverridingOpacity (Geometry *geo, bool override)
{
    if (!geo || (geo == emptyGeometry))
        return emptyGeometry;

    return NEW OverridingOpacityGeom (geo, override);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "privinc/server.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\geom.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Basic geometry functionality.

*******************************************************************************/

#include "headers.h"
#include <stdio.h>

#include "appelles/common.h"

#include "privinc/geomi.h"
#include "privinc/dispdevi.h"
#include "privinc/vecutil.h"
#include "privinc/bbox3i.h"
#include "privinc/vec2i.h"
#include "privinc/lighti.h"
#include "privinc/soundi.h"
#include "privinc/probe.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/opt.h"



Geometry *emptyGeometry = NULL;



/*****************************************************************************
*****************************************************************************/

Geometry::Geometry (void)
    : _flags(0),
      _creationID (PERF_CREATION_ID_BUILT_EACH_FRAME)
{
}



/*****************************************************************************
When performing the RayIntersect method on bounded geometry, continue
interogating the contained geometry only if the ray intersects the bounding
volume of the geometry, and the intersection point is closer than the current
winning pick point.
*****************************************************************************/

bool
TrivialReject(Bbox3 *bvol, RayIntersectCtx &ctx)
{
    // If we're looking for a submesh, and already got it, no need to
    // go on, so reject.
    if (ctx.GotTheSubmesh()) {
        return true;
    }

    // If looking for a submesh, ignore the bbox, since the lc points
    // aren't accurate here.
    if (ctx.LookingForSubmesh()) {
        return false;
    }

    Bbox3  *wcBbox = TransformBbox3 (ctx.GetLcToWc(), bvol);
    Point3Value *hit = wcBbox->Intersection (ctx.WCPickRay());

    DebugCode
    (
        if (IsTagEnabled (tagPick3Bbox))
        {
            if (!hit)
                TraceTag ((tagPick3Bbox, "Ray missed bbox %x.", bvol));
            else if (ctx.CloserThanCurrentHit(*hit))
                TraceTag ((tagPick3Bbox, "Ray hit bbox %x (closer).", bvol));
            else
                TraceTag ((tagPick3Bbox, "Ray hit bbox %x (farther).", bvol));
        }
    )

    // Return true if we can trivially reject the intersection based on
    // the bounding volume
    return !(hit && ctx.CloserThanCurrentHit(*hit));
}


/*==========================================================================*/

Bbox3 *GeomBoundingBox (Geometry *geo)
{
    return geo->BoundingVol();
}

/*==========================================================================*/
// Binary Geometry Aggregation

class AggregateGeom : public Geometry
{
  public:

    AggregateGeom (Geometry *g1, Geometry *g2);

    void Render(GenericDevice& _dev) {
        // Just render one followed by the other
        _geo1->Render(_dev);
        _geo2->Render(_dev);
    }

    void CollectSounds (SoundTraversalContext &context) {
        // Just render one followed by the other (pushing down the
        // transform)
        _geo1->CollectSounds(context);
        _geo2->CollectSounds(context);
    }

    void CollectLights (LightContext &context)
    {
        _geo1->CollectLights (context);
        _geo2->CollectLights (context);
    }

    void CollectTextures(GeomRenderer &device) {
        _geo1->CollectTextures (device);
        _geo2->CollectTextures (device);
    }

    void RayIntersect (RayIntersectCtx &context) {
        if (!TrivialReject(_bvol, context)) {
            _geo1->RayIntersect(context);

            if (!context.GotTheSubmesh()) {
                _geo2->RayIntersect(context);
            }
        }
    }

    #if _USE_PRINT
        ostream& Print(ostream& os) {
            return os << "union(" << _geo1 << "," << _geo2 << ")";
        }
    #endif

    Bbox3 *BoundingVol (void)
    {
        return _bvol;
    }
    
    AxAValue _Cache(CacheParam &p) {

        CacheParam newParam = p;
        newParam._pCacheToReuse = NULL;

        // Just go through and cache the individual geoms
        _geo1 =  SAFE_CAST(Geometry *, AxAValueObj::Cache(_geo1, newParam));
        _geo2 =  SAFE_CAST(Geometry *, AxAValueObj::Cache(_geo2, newParam));

        return this;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_geo1);
        (*proc)(_geo2);
        (*proc)(_bvol);
    }

    VALTYPEID GetValTypeId() { return AGGREGATEGEOM_VTYPEID; }

  protected:
    Geometry *_geo1, *_geo2;
    Bbox3    *_bvol;
};


AggregateGeom::AggregateGeom (Geometry *g1, Geometry *g2)
    : _geo1(g1), _geo2(g2)
{
    _flags = g1->GetFlags() | g2->GetFlags();
    _bvol = Union (*_geo1->BoundingVol(), *_geo2->BoundingVol());
}



Geometry *PlusGeomGeom (Geometry *geom1, Geometry *geom2)
{
    if (geom1 == emptyGeometry) {
        return geom2;
    } else if (geom2 == emptyGeometry) {
        return geom1;
    } else {
        return NEW AggregateGeom (geom1, geom2);
    }
}

/*==========================================================================*/
// Multiple Aggregrate Geometry
class MultiAggregateGeom : public Geometry
{
  public:
    MultiAggregateGeom() {
        _numGeos = 0;
        _geometries = NULL;
        _bvol = NULL;
    }

    void Init(AxAArray *geos);
    ~MultiAggregateGeom();

    virtual void     Render (GenericDevice& dev);
            void     CollectSounds (SoundTraversalContext &context);
            void     CollectLights (LightContext &context);
            void     CollectTextures(GeomRenderer &device);
    void     RayIntersect (RayIntersectCtx &context);

    #if _USE_PRINT
        ostream& Print (ostream& os);
    #endif

    Bbox3 *BoundingVol() {
        return _bvol;
    }

    AxAValue _Cache(CacheParam &p);

    virtual void DoKids(GCFuncObj proc) {
        for (int i=0; i<_numGeos; i++) {
            (*proc)(_geometries[i]);
        }
        (*proc)(_bvol);
    }

    VALTYPEID GetValTypeId() { return MULTIAGGREGATEGEOM_VTYPEID; }

  protected:
    int        _numGeos;
    Geometry **_geometries;
    Bbox3     *_bvol;
};

void
MultiAggregateGeom::Init(AxAArray *geos)
{
    _numGeos = geos->Length();
    Assert((_numGeos > 2) && "Multi-aggregate should have more than 2 geometries");

    _geometries = (Geometry **)AllocateFromStore(_numGeos * sizeof(Geometry*));

    _bvol = NEW Bbox3;

    for (int i = 0; i < _numGeos; i++) {
        Geometry *g = SAFE_CAST(Geometry *, (*geos)[i]);

        _geometries[i] = g;

        _bvol->Augment(*g->BoundingVol());

        // Accumulate geometry flags.  Note that the _flags member has been
        // initialized to zero in the Geometry class constructor.

        _flags |= g->GetFlags();
    }
}

MultiAggregateGeom::~MultiAggregateGeom()
{
    DeallocateFromStore(_geometries);
}

void
MultiAggregateGeom::Render(GenericDevice& _device)
{
    Geometry **geo = _geometries;   // Geometry Traversal Pointer

    for (int i = 0; i < _numGeos; i++, geo++) { // call render on each geometry
        (*geo)->Render(_device);
    }
}

void MultiAggregateGeom::CollectSounds (SoundTraversalContext &context)
{
    Geometry **geo;    // Geometry Traversal Pointer
    int       count;  // Iteration Counter

    for (geo=_geometries, count=_numGeos;  count--;  ++geo)
        (*geo)->CollectSounds (context);
}



/*****************************************************************************
This function collects the lights from the geometries in a MultiAggregateGeom.
Ordering is unimportant, we just need to get all lights from each component
geometry.  Here we just traverse the geometries, collecting lights as we go.
*****************************************************************************/

void MultiAggregateGeom::CollectLights (LightContext &context)
{
    Geometry **geo;    // Geometry Traversal Pointer
    int       count;  // Iteration Counter

    for (geo=_geometries, count=_numGeos;  count--;  ++geo)
        (*geo)->CollectLights (context);
}


void MultiAggregateGeom::CollectTextures(GeomRenderer &device)
{
    Geometry **geo;    // Geometry Traversal Pointer
    int       count;  // Iteration Counter

    for (geo=_geometries, count=_numGeos;  count--;  ++geo)
        (*geo)->CollectTextures (device);
}


AxAValue
MultiAggregateGeom::_Cache(CacheParam &p)
{
    Geometry **geo;    // Geometry Traversal Pointer
    int       count;  // Iteration Counter

    CacheParam newParam = p;
    newParam._pCacheToReuse = NULL;

    // Just go through and cache the individual geoms
    for (geo=_geometries, count=_numGeos;  count--;  ++geo) {
        (*geo) =
            SAFE_CAST(Geometry *, AxAValueObj::Cache((*geo), newParam));
    }

    return this;
}

void MultiAggregateGeom::RayIntersect (RayIntersectCtx &context)
{
    if (!TrivialReject(_bvol, context)) {

        Geometry **geo;    // Geometry Traversal Pointer
        int       count;  // Iteration Counter

        for (geo=_geometries, count=_numGeos;
             count-- && !context.GotTheSubmesh();
             ++geo) {

            (*geo)->RayIntersect (context);

        }

    }
}



#if _USE_PRINT
ostream&
MultiAggregateGeom::Print(ostream& os)
{
    os << "MultiGeometry(" << _numGeos ;

    for (int i = 0; i < _numGeos; i++) {
        os << "," << _geometries[i] << ")";
    }

    return os;
}
#endif


Geometry *
UnionArray(AxAArray *geos)
{
    geos = PackArray(geos);

    int numGeos = geos->Length();

    switch (numGeos) {
      case 0:
        return emptyGeometry;

      case 1:
        return SAFE_CAST(Geometry *, (*geos)[0]);

      case 2:
        return PlusGeomGeom(SAFE_CAST(Geometry *, (*geos)[0]),
                            SAFE_CAST(Geometry *, (*geos)[1]));

      default:
        {
            MultiAggregateGeom *mag = NEW MultiAggregateGeom();
            mag->Init(geos);
            return mag;
        }
    }
}



#if _USE_PRINT
ostream&
operator<<(ostream& os, Geometry *geo)
{
    return geo->Print(os);
}
#endif



/*==========================================================================*/
// Primitives And Constants

//// The "empty" geometry...

class EmptyGeom : public Geometry {
  public:
    virtual void  Render (GenericDevice& dev)  {}
            void  CollectSounds (SoundTraversalContext &context)  {}
            void  CollectLights (LightContext &context)  {}
            void  RayIntersect (RayIntersectCtx &context) {}
            void  CollectTextures(GeomRenderer &device) {}

    // Bounding volume of the empty geometry is the null bbox.

    Bbox3 *BoundingVol() { return nullBbox3; }

    #if _USE_PRINT
        ostream& Print(ostream& os) { return os << "emptyGeometry"; }
    #endif

    VALTYPEID GetValTypeId() { return EMPTYGEOM_VTYPEID; }
};



/*****************************************************************************
The geometry extended attributer understand the following:

    "OpacityOverrides" <bool>   // Opacity overrides rather than multiplies
                                // with opacities in imported geometry.

*****************************************************************************/

AxAValue
Geometry::ExtendedAttrib(char *attrib, VARIANT& val)
{
    // Unless we get something we understand, the result is the unmodified geo.

    Geometry *result = this;

    CComVariant variant;

    if (  (0 == lstrcmp (attrib, "OpacityOverrides"))
       && (SUCCEEDED (variant.ChangeType (VT_BOOL, &val)))
       )
    {
        result = OverridingOpacity (this, variant.boolVal != 0);
    } else if (  (0 == lstrcmp (attrib, "AlphaShadows"))
       && (SUCCEEDED (variant.ChangeType (VT_BOOL, &val)))
       )
    {
        result = AlphaShadows (this, variant.boolVal != 0);
    }

    return result;
}



/*****************************************************************************
Initialization for Geometry Objects
*****************************************************************************/

void
InitializeModule_Geom()
{
    // The single "empty geometry" is just an instantiation of the
    // above class.
    emptyGeometry = NEW EmptyGeom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\light.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation
*******************************************************************************/

#include "headers.h"

#include "appelles/light.h"

#include "privinc/colori.h"
#include "privinc/lighti.h"
#include "privinc/xformi.h"
#include "privinc/ddrender.h"



    /**  Canonical Lights -- initialized at bottom  **/

Geometry *ambientLight     = NULL;
Geometry *directionalLight = NULL;
Geometry *pointLight       = NULL;


/*****************************************************************************
This is the constructor for the light context.  It initializes the state
maintenance and sets all attributes to their default values.
*****************************************************************************/

LightContext::LightContext (GeomRenderer *rdev)
{
    Initialize (rdev, NULL, NULL);
}

LightContext::LightContext (LightCallback *callback, void *callback_data)
{
    Initialize (NULL, callback, callback_data);
}

void LightContext::Initialize (
    GeomRenderer  *rdev,
    LightCallback *callback,
    void          *callback_data)
{
    _rdev = rdev;
    _callback = callback;
    _callback_data = callback_data;

    // Set defaults for all attributes.

    _transform = identityTransform3;

    _color = white;
    _range = 0;     // infinite

    _atten0 = 1;
    _atten1 = 0;
    _atten2 = 0;

    _depthColor = 0;
    _depthRange = 0;
    _depthAtten = 0;
}



/*****************************************************************************
Methods for setting & querying the light transform.
*****************************************************************************/

void LightContext::SetTransform (Transform3 *transform)
{   _transform = transform;
}

Transform3 *LightContext::GetTransform (void)
{   return _transform;
}



/*****************************************************************************
Methods for manipulating the light color.
*****************************************************************************/

void LightContext::PushColor (Color *color)
{   if (_depthColor++ == 0) _color = color;
}

void LightContext::PopColor (void)
{   if (--_depthColor == 0) _color = white;
}

Color* LightContext::GetColor (void) { return _color; }



/*****************************************************************************
Methods for manipulating the light range.
*****************************************************************************/

void LightContext::PushRange (Real range)
{   if (_depthRange++ == 0) _range = range;
}

void LightContext::PopRange (void)
{   if (--_depthRange == 0) _range = 0;
}

Real LightContext::GetRange (void) { return _range; }



/*****************************************************************************
Methods for setting & querying the light attenuation.
*****************************************************************************/

void LightContext::PushAttenuation (Real a0, Real a1, Real a2)
{
    if (_depthAtten++ == 0)
    {   _atten0 = a0;
        _atten1 = a1;
        _atten2 = a2;
    }
}

void LightContext::PopAttenuation (void)
{
    if (--_depthAtten == 0)
    {   _atten0 = 1;
        _atten1 = 0;
        _atten2 = 0;
    }
}

void LightContext::GetAttenuation (Real &a0, Real &a1, Real &a2)
{   a0 = _atten0;
    a1 = _atten1;
    a2 = _atten2;
}



/*****************************************************************************
This subroutine adds a light to the given context.
*****************************************************************************/

void LightContext::AddLight (Light &light)
{
    Assert (_rdev || _callback);

    if (_rdev)
        _rdev->AddLight (*this, light);
    else
        (*_callback) (*this, light, _callback_data);
}



/*****************************************************************************
This subroutine prints out the given light object to the given ostream.
*****************************************************************************/

#if _USE_PRINT
ostream& Light::Print (ostream &os) 
{
    switch (_type)
    {
        case Ltype_Ambient:     return os << "ambientLight";
        case Ltype_Directional: return os << "directionalLight";
        case Ltype_Point:       return os << "pointLight";

        case Ltype_Spot:
            return os <<"spotLight("
                      <<_fullcone <<","
                      <<_cutoff   <<")";

        default:
            return os << "<UNDEFINED LIGHT>";
    }
}
#endif



/*****************************************************************************
Spotlights have a position and direction.  In addition, the contribution of
illumination falls off as the illuminated point moves from the spotlight axis.
*****************************************************************************/

Geometry *SpotLight (Real fullcone, Real cutoff)
{
    return NEW Light (Ltype_Spot, fullcone, cutoff);
}

Geometry *SpotLight (AxANumber *fullcone, AxANumber *cutoff)
{
    return SpotLight (NumberToReal(fullcone), NumberToReal(cutoff));
}

/*****************************************************************************
This routine initializes the static light values in this module.
*****************************************************************************/

void InitializeModule_Light (void)
{
    ambientLight     = NEW Light (Ltype_Ambient);
    directionalLight = NEW Light (Ltype_Directional);
    pointLight       = NEW Light (Ltype_Point);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\pickgeom.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for pickable geometries.

*******************************************************************************/


#include "headers.h"
#include "appelles/gattr.h"
#include "privinc/geomi.h"
#include "privinc/probe.h"

class PickableGeom : public AttributedGeom {
  public:

    PickableGeom(Geometry *geom, int id, bool uType = false,
                 GCIUnknown *u = NULL)
    : AttributedGeom(geom), _eventId(id), _hasData(uType), _long(u) {}

    virtual void DoKids(GCFuncObj proc) {
        AttributedGeom::DoKids(proc);
        (*proc)(_long);
    }
    
#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "PickableGeometry(" << _geometry << ")";
    }
#endif

    void  RayIntersect(RayIntersectCtx& ctx) {
        // Tell the context that this pickable image is a candidate for
        // picking, perform the pick on the underlying geometry, then
        // remove this pickable as a candidate by popping it off of the
        // stack. 
        ctx.PushPickableAsCandidate(_eventId, _hasData, _long);
        _geometry->RayIntersect(ctx);
        ctx.PopPickableAsCandidate();
    }

  protected:
    int      _eventId;
    bool _hasData;
    GCIUnknown *_long;
};

// Note that this is called with a pick event ID generated through
// CAML. 
Geometry *PRIVPickableGeometry(Geometry *geo,
                               AxANumber *id,
                               AxABoolean *ignoresOcclusion)
{
    return NEW PickableGeom(geo, (int)NumberToReal(id));
}

AxAValue PRIVPickableGeomWithData(AxAValue geo,
                                  int id,
                                  GCIUnknown *data,
                                  bool)
{
    return NEW PickableGeom(SAFE_CAST(Geometry*,geo), id, true, data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\rmvisgeo.cpp ===
/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Building a geometry out of a D3D retained mode visual.
*******************************************************************************/

#include "headers.h"
#include <d3drmdef.h>
#include "privinc/rmvisgeo.h"
#include "privinc/geomi.h"
#include "privinc/bbox3i.h"
#include "privinc/xformi.h"
#include "privinc/ddrender.h"
#include "privinc/debug.h"
#include "privinc/d3dutil.h"
#include "privinc/comutil.h"
#include "privinc/importgeo.h"
#include <dxtrans.h>

static Color colorNone (-1, -1, -1);



/*****************************************************************************
Methods for MeshInfo, which instruments a D3DRM mesh for DA attribute
management.
*****************************************************************************/

MeshInfo::MeshInfo ()
    : _mesh (NULL),
      _opacityBugWorkaroundID (-1),
      _defaultAttrs (NULL),
      _optionalBuilder (NULL)
{
}



void MeshInfo::SetMesh (IDirect3DRMMesh* mesh)
{
    Assert (mesh);
    AssertStr ((_mesh == NULL), "Illegal attempt to reset MeshInfo object.");

    _mesh = mesh;
    _mesh->AddRef();

    _numGroups = _mesh->GetGroupCount();

    _defaultAttrs = NEW AttrState [_numGroups];

    if (!_defaultAttrs)
        RaiseException_ResourceError ("Couldn't create D3DRM mesh attribute info");

    // Fill in the default values.

    int group;
    for (group=0;  group < _numGroups;  ++group)
    {
        D3DCOLOR color = _mesh->GetGroupColor(group);
        _defaultAttrs[group].diffuse.SetD3D (color);
        _defaultAttrs[group].opacity = RGBA_GETALPHA(color) / 255.0;

        TD3D (_mesh->GetGroupTexture (group, &_defaultAttrs[group].texture));

        // NOTE:  In some cases, the material returned may be null, without
        // a D3D error.  In these cases we just fill in the blanks with the
        // standard DA default material values.

        DAComPtr<IDirect3DRMMaterial> mat;
        TD3D (_mesh->GetGroupMaterial (group, &mat));

        D3DVALUE Er=0,Eg=0,Eb=0, Sr=0,Sg=0,Sb=0;

        if (mat.p)
        {   TD3D (mat->GetEmissive(&Er,&Eg,&Eb));
            TD3D (mat->GetSpecular(&Sr,&Sg,&Sb));
        }

        _defaultAttrs[group].emissive.SetRGB (Er,Eg,Eb);
        _defaultAttrs[group].specular.SetRGB (Sr,Sg,Sb);

        // For some reason, GetPower can return zero (which is an invalid
        // D3DRM value).  Interpret this value as the DA default of 1.

        Real specexp = mat.p ? mat->GetPower() : 1;
        _defaultAttrs[group].specularExp = (specexp < 1) ? 1 : specexp;
    }

    _overrideAttrs.emissive    = colorNone;
    _overrideAttrs.diffuse     = colorNone;
    _overrideAttrs.specular    = colorNone;
    _overrideAttrs.specularExp = -1;
    _overrideAttrs.opacity     = 1;
    _overrideAttrs.texture     = NULL;
    _overrideAttrs.shadowMode  = false;
}



/*****************************************************************************
This method returns the bounding box of the underlying mesh.  If the bbox
fetch fails, this returns the null bbox.
*****************************************************************************/

Bbox3 MeshInfo::GetBox (void)
{
    Assert (_mesh);

    D3DRMBOX rmbox;

    if (SUCCEEDED(AD3D(_mesh->GetBox(&rmbox))))
        return Bbox3 (rmbox);
    else
        return *nullBbox3;
}




/*****************************************************************************
Override the mesh attributes with the given attributes.
*****************************************************************************/

void MeshInfo::SetMaterialProperties (
    Color *emissive,
    Color *diffuse,
    Color *specular,
    Real   specularExp,
    Real   opacity,
    IDirect3DRMTexture *texture,
    bool   shadowMode,
    int    renderDevID)
{
    AssertStr (_mesh, "SetMaterialProperties on null MeshInfo.");

    int group;  // Group Index

    // Override textures if we're changing shadow modes, or if we're specifying
    // a different texture override.

    if (  (shadowMode != _overrideAttrs.shadowMode)
       || (texture != _overrideAttrs.texture))
    {
        for (group=0;  group < _numGroups;  ++group)
        {
            // Override the textures if we're in shadow mode (overriding to
            // null), or if the texture is not null.

            if (shadowMode || texture)
                TD3D (_mesh->SetGroupTexture (group, texture));
            else
                TD3D (_mesh->SetGroupTexture
                    (group, _defaultAttrs[group].texture));

            // @@@ SRH DX3
            // This is a workaround for a bug in NT SP3 (DX3) which causes a
            // crash in D3DRM when you set a new texture on a given mesh.  It
            // forces RM to take a different (working) code path.

            if (ntsp3)
            {   D3DRMVERTEX v;
                _mesh->GetVertices (0,0,1, &v);
                _mesh->SetVertices (0,0,1, &v);
            }
        }

        _overrideAttrs.texture = texture;
    }

    // Handle the diffuse/opacity bundle.  We only need to set properties on
    // the mesh if one of the overrides have changed.  If we're doing the
    // initial render, we artificially lower the opacity to work around a D3DRM
    // bug which "sticks" opacity to one if that's the first value used.

    if ((_opacityBugWorkaroundID != renderDevID) && (opacity >= 1.0))
    {   opacity = 0.95;
        _opacityBugWorkaroundID = renderDevID;
    }

    if (  (_overrideAttrs.opacity != opacity)
       || (_overrideAttrs.diffuse != (diffuse ? *diffuse : colorNone))
       )
    {
        Color Cd;   // Diffuse Color
        Real  Co;   // Opacity

        if (diffuse) Cd = *diffuse;

        for (group=0;  group < _numGroups;  ++group)
        {
            if (!diffuse) Cd = _defaultAttrs[group].diffuse;
            Co = opacity * _defaultAttrs[group].opacity;

            TD3D (_mesh->SetGroupColor (group, GetD3DColor(&Cd,Co)));
        }

        _overrideAttrs.opacity = opacity;
        _overrideAttrs.diffuse = (diffuse ? *diffuse : colorNone);
    }

    if (  (_overrideAttrs.emissive != (emissive ? *emissive : colorNone))
       || (_overrideAttrs.specular != (specular ? *specular : colorNone))
       || (_overrideAttrs.specularExp != specularExp)
       )
    {
        DAComPtr<IDirect3DRMMaterial> mat;

        TD3D (GetD3DRM1()->CreateMaterial (D3DVAL(1), &mat));

        for (group=0;  group < _numGroups;  ++group)
        {
            D3DVALUE R,G,B;

            if (emissive)
            {   R = D3DVAL (emissive->red);
                G = D3DVAL (emissive->green);
                B = D3DVAL (emissive->blue);
            }
            else
            {   R = D3DVAL (_defaultAttrs[group].emissive.red);
                G = D3DVAL (_defaultAttrs[group].emissive.green);
                B = D3DVAL (_defaultAttrs[group].emissive.blue);
            }

            TD3D (mat->SetEmissive(R,G,B));

            if (specular)
            {   R = D3DVAL (specular->red);
                G = D3DVAL (specular->green);
                B = D3DVAL (specular->blue);
            }
            else
            {   R = D3DVAL (_defaultAttrs[group].specular.red);
                G = D3DVAL (_defaultAttrs[group].specular.green);
                B = D3DVAL (_defaultAttrs[group].specular.blue);
            }

            TD3D (mat->SetSpecular(R,G,B));

            Assert ((specularExp == -1) || (specularExp >= 1));

            if (specularExp == -1)
                TD3D (mat->SetPower(D3DVAL(_defaultAttrs[group].specularExp)));
            else
                TD3D (mat->SetPower(D3DVAL(specularExp)));

            TD3D (_mesh->SetGroupMaterial (group, mat.p));
        }

        _overrideAttrs.emissive = emissive ? *emissive : colorNone;
        _overrideAttrs.specular = specular ? *specular : colorNone;
        _overrideAttrs.specularExp = specularExp;
    }

    _overrideAttrs.shadowMode = shadowMode;
}



/*****************************************************************************
The CleanUp routine handles the freeing of all memory and system objects.
Note that this method should be safe to call multiple times.
*****************************************************************************/

void MeshInfo::CleanUp (void)
{
    TraceTag ((tagGCMedia, "Cleanup: MeshInfo %08x", this));

    if (_mesh)
    {   _mesh->Release();
        _mesh = 0;
    }

    // Clean up default attributes

    if (_defaultAttrs)
    {
        int group;
        for (group=0;  group < _numGroups;  ++group)
        {
            IDirect3DRMTexture *tex = _defaultAttrs[group].texture;
            if (tex) tex->Release();
        }

        delete [] _defaultAttrs;

        _defaultAttrs = NULL;
    }

    if (_optionalBuilder)
    {   _optionalBuilder->Release();
        _optionalBuilder = NULL;
    }
}



LPDIRECT3DRMMESHBUILDER MeshInfo::GetMeshBuilder()
{
    Assert(_mesh);

    if (!_optionalBuilder) {

        TD3D(GetD3DRM1()->CreateMeshBuilder(&_optionalBuilder));
        TD3D(_optionalBuilder->AddMesh(_mesh));
    }

    return _optionalBuilder;
}



/*****************************************************************************
*****************************************************************************/

RMVisualGeo::RMVisualGeo (void)
{
    RMVisGeoDeleter *deleter = NEW RMVisGeoDeleter (this);

    GetHeapOnTopOfStack().RegisterDynamicDeleter (deleter);
}



/*****************************************************************************
This method handles all of the non-render modes, and gets the reference to
the actual geometry renderer.
*****************************************************************************/

void RMVisualGeo::Render (GenericDevice &device)
{
    Render (SAFE_CAST (GeomRenderer&, device));
}


// When picking, submit the visual to the ray-intersection contxt.

// POSSIBLE BUG: If there are multiple instances of this geometry,
// this submesh traversal doesn't distinguish them.  Could be a
// problem for multiple instancing!!  Possible fix: begin second
// traversal from just above the DXTransform, rather than from the
// top, to avoid these other instances.

void RMVisualGeo::RayIntersect (RayIntersectCtx &context)
{
    float tu, tv;
    Geometry *pickedSubGeo = context.GetPickedSubGeo(&tu, &tv);

    if (pickedSubGeo == this) {

        // In this case, we're picking back to the hit submesh of a
        // geometry dxtransform.  In this case, we can't know the
        // model coordinate hit point on the input (because the xform
        // is arbitrary), nor is the face index or hit visual
        // important.  And, for hit info,
        context.SubmitWinner(-1, *origin3, tu, tv, -1, NULL);

    } else if (!pickedSubGeo) {

        context.Pick(Visual());

    } else {

        // pickedSubGeo is non-NULL, but points to a different
        // geometry.  In this case, we don't want to do anything.
    }
}



/*****************************************************************************
Methods for RM1MeshGeo objects
*****************************************************************************/

RM1MeshGeo::RM1MeshGeo (
    IDirect3DRMMesh *mesh,
    bool             trackGenIDs)
    : _baseObj (NULL)
{
    _meshInfo.SetMesh (mesh);

    _bbox = _meshInfo.GetBox ();

    TraceTag ((tagGCMedia, "New RMMeshGeo %08x, mesh %08x", this, mesh));
}



/*****************************************************************************
The CleanUp method releases any resources by the RM1MeshGeo.
*****************************************************************************/

void RM1MeshGeo::CleanUp (void)
{
    TraceTag ((tagGCMedia, "CleanUp: RM1MeshGeo %08x", this));

    // Note that the eager cleanup below assumes that meshInfo.CleanUp() may
    // be invoked multiple times.

    _meshInfo.CleanUp();
}



/*****************************************************************************
This method renders the RM mesh, handling DXTransform meshes if necessary.
*****************************************************************************/

void RM1MeshGeo::Render(GeomRenderer &gdev)
{
    Assert (!_meshInfo.IsEmpty());

    gdev.Render(this);
}



void RM1MeshGeo::SetMaterialProperties (
    Color *emissive,
    Color *diffuse,
    Color *specular,
    Real   specularExp,
    Real   opacity,
    IDirect3DRMTexture *texture,
    bool   shadowMode,
    int    renderDevID)
{
    Assert (!_meshInfo.IsEmpty());

    _meshInfo.SetMaterialProperties
    (   emissive, diffuse, specular, specularExp,
        opacity, texture, shadowMode, renderDevID
    );
}



void RM1MeshGeo::SetD3DQuality (D3DRMRENDERQUALITY qual)
{
    Assert (!_meshInfo.IsEmpty());

    TD3D(_meshInfo.GetMesh()->SetGroupQuality(-1, qual));
}



void RM1MeshGeo::SetD3DMapping (D3DRMMAPPING m)
{
    Assert (!_meshInfo.IsEmpty());

    TD3D(_meshInfo.GetMesh()->SetGroupMapping(-1, m));
}



/*****************************************************************************
Handle cases where the underlying mesh geometry changes (e.g. via dynamic
trimeshes).
*****************************************************************************/

void RM1MeshGeo::MeshGeometryChanged (void)
{
    Assert (!_meshInfo.IsEmpty());

    // Reset the bounding box by fetching it again from the underlying mesh
    // object.

    _bbox = _meshInfo.GetBox ();
}



/*****************************************************************************
RM1FrameGeo Methods
*****************************************************************************/

RM1FrameGeo::RM1FrameGeo (
    IDirect3DRMFrame         *frame,
    vector<IDirect3DRMMesh*> *internalMeshes,
    Bbox3                    *bbox)
{
    TraceTag ((tagGCMedia, "New RMFrameGeo %08x, frame %08x", this, frame));

    _frame =  frame;
    _frame -> AddRef();

    _bbox = *bbox;

    _numMeshes = internalMeshes->size();
    _meshes = (MeshInfo **)AllocateFromStore(_numMeshes * sizeof(MeshInfo *));

    MeshInfo **info = _meshes;
    vector<IDirect3DRMMesh*>::iterator i;
    for (i = internalMeshes->begin(); i != internalMeshes->end(); i++) {
        *info = NEW MeshInfo;
        (*info)->SetMesh(*i);
        info++;
    }

    Assert(info == _meshes + _numMeshes);
}



/*****************************************************************************
The cleanup method is called either from the object destructor or directly to
release all resources held by the object.  Note that this method is safe for
multiple calls.
*****************************************************************************/

void RM1FrameGeo::CleanUp (void)
{
    // Note that the MeshInfo structures are GC objects, so we don't need to
    // (shouldn't) explicitly delete each of them here.

    if (_meshes)
    {   DeallocateFromStore (_meshes);
        _meshes = NULL;
    }

    if (_frame)
    {   _frame->Release();
        _frame = NULL;
    }

    TraceTag ((tagGCMedia, "CleanUp: RMFrameGeo %08x", this));
}



void RM1FrameGeo::SetMaterialProperties (
    Color *emissive,
    Color *diffuse,
    Color *specular,
    Real   specularExp,
    Real   opacity,
    IDirect3DRMTexture *texture,
    bool   shadowMode,
    int    renderDevID)
{
    Assert (_meshes);

    MeshInfo **m = _meshes;
    for (int i = 0; i < _numMeshes; i++) {
        (*m++) -> SetMaterialProperties
            (emissive, diffuse, specular, specularExp,
             opacity, texture, shadowMode, renderDevID);
    }
}



void RM1FrameGeo::SetD3DQuality (D3DRMRENDERQUALITY qual)
{
    Assert (_meshes);

    MeshInfo **m = _meshes;
    for (int i = 0; i < _numMeshes; i++) {
        TD3D((*m++)->GetMesh()->SetGroupQuality(-1, qual));
    }
}



void RM1FrameGeo::SetD3DMapping (D3DRMMAPPING mp)
{
    Assert (_meshes);

    MeshInfo **m = _meshes;
    for (int i = 0; i < _numMeshes; i++) {
        TD3D((*m++)->GetMesh()->SetGroupMapping(-1, mp));
    }
}



void RM1FrameGeo::DoKids (GCFuncObj proc)
{
    RM1VisualGeo::DoKids(proc);

    // Ensure that we only mark submeshes if we haven't already been cleaned
    // up.

    if (_meshes)
    {
        for (int i=0; i<_numMeshes; i++)
            (*proc) (_meshes[i]);
    }
}



/*****************************************************************************
The RM3MBuilderGeo represents a D3DRM MeshBuilder3 object.
*****************************************************************************/

RM3MBuilderGeo::RM3MBuilderGeo (
    IDirect3DRMMeshBuilder3 *mbuilder,
    bool                     trackGenIDs)
    :
    _mbuilder (mbuilder),
    _baseObj (NULL)
{
    Assert (_mbuilder);

    _mbuilder->AddRef();

    SetBbox();

    TraceTag ((tagGCMedia, "New RM3MBuilderGeo %x, mb %x", this, mbuilder));
}

RM3MBuilderGeo::RM3MBuilderGeo (IDirect3DRMMesh *mesh)
    : _mbuilder(NULL), _baseObj(NULL), _bbox(*nullBbox3)
{
    Assert (mesh);

    // Create the meshbuilder that will house the given mesh.

    TD3D (GetD3DRM3()->CreateMeshBuilder (&_mbuilder));

    // Add the given mesh to the newly-created meshbuilder.

    TD3D (_mbuilder->AddMesh (mesh));

    SetBbox();
}



/*****************************************************************************
This method resets the meshbuilder to the contents of the given mesh.
*****************************************************************************/

void RM3MBuilderGeo::Reset (IDirect3DRMMesh *mesh)
{
    Assert (_mbuilder);

    // Empty the previous contents.

    TD3D (_mbuilder->Empty(0));

    // Reset to contain the given mesh, and fetch new bounding box.

    TD3D (_mbuilder->AddMesh (mesh));
    SetBbox();
}



/*****************************************************************************
This method examines the D3D bounding box of the meshbuilder and caches the
value as a DA 2D bbox.
*****************************************************************************/

void RM3MBuilderGeo::SetBbox (void)
{
    Assert (_mbuilder);

    D3DRMBOX rmbox;

    if (SUCCEEDED (AD3D (_mbuilder->GetBox (&rmbox))))
        _bbox = rmbox;
    else
        _bbox = *nullBbox3;
}



/*****************************************************************************
The CleanUp routine for RM3MBuilderGeo is called from the d'tor, or directly.
Note that this method is safe across multiple invocations.
*****************************************************************************/

void RM3MBuilderGeo::CleanUp (void)
{
    if (_mbuilder)
    {   _mbuilder->Release();
        _mbuilder = NULL;
    }

    TraceTag ((tagGCMedia, "CleanUp: RM3MBuilderGeo %x", this));
}



/*****************************************************************************
The Render method for RM3MBuilderGeo also handles DXTransform'ed mbuilders.
*****************************************************************************/

void RM3MBuilderGeo::Render (GeomRenderer &geomRenderer)
{
    Assert (_mbuilder);
    geomRenderer.Render (this);
}



/*****************************************************************************
Wraps a RM3MBuilderGeo with texture coordinates
*****************************************************************************/

void RM3MBuilderGeo::TextureWrap (TextureWrapInfo *info)
{
    Assert (info);
    Assert (_mbuilder);

    RMTextureWrap wrap(info,&_bbox);
    wrap.Apply(_mbuilder);
    TD3D(_mbuilder->SetTextureTopology((BOOL) wrap.WrapU(), (BOOL) wrap.WrapV()));
}



/*****************************************************************************
This method optimizes the RM meshbuilder.
*****************************************************************************/

void RM3MBuilderGeo::Optimize (void)
{
    Assert (_mbuilder);
    TD3D (_mbuilder->Optimize(0));
}



/*****************************************************************************
The constructor for the RM3FrameGeo object needs to get the hierarchical
bounding box of the entire frame.
*****************************************************************************/

RM3FrameGeo::RM3FrameGeo (IDirect3DRMFrame3 *frame)
    : _frame(frame)
{
    _frame->AddRef();

    // Get the bounding box of the frame hierarchy.  Frame3::GetHierarchyBox()
    // returns the bounding box of all contained visuals without factoring in
    // the transform on that frame.  Thus, we need to create a dummy frame to
    // contain the frame we're interested in, and GetHierarchyBox off the
    // containing frame.  If any of this fails, we leave the _bbox member as
    // nullBbox3.

    D3DRMBOX box;
    IDirect3DRMFrame3 *container_frame;

    if (  SUCCEEDED(AD3D(GetD3DRM3()->CreateFrame (0, &container_frame)))
       && SUCCEEDED(AD3D(container_frame->AddVisual(_frame)))
       && SUCCEEDED(AD3D(container_frame->GetHierarchyBox(&box)))
       )
    {
        _bbox = box;

        AD3D(container_frame->DeleteVisual(_frame));
        container_frame->Release();
    }
    else
    {
        _bbox = *nullBbox3;
        AssertStr (0,"GetHierarchyBox failed on Frame3 Object.");
    }
}



/*****************************************************************************
The cleanup method for the RM3FrameGeo object needs only to release the
frame interface.  This method is safe across multiple invocations.
*****************************************************************************/

void RM3FrameGeo::CleanUp (void)
{
    if (_frame)
    {   _frame->Release();
        _frame = NULL;
    }
}



/*****************************************************************************
Wraps a RM3FrameGeo with texture coordinates
*****************************************************************************/

void RM3FrameGeo::TextureWrap (TextureWrapInfo *info)
{
    Assert (info);

    RMTextureWrap wrap(info,&_bbox);
    //  wrap.Apply(_frame);
    wrap.ApplyToFrame(_frame);
    //  TD3D(_frame->SetTextureTopology((BOOL) wrap.WrapU(), (BOOL) wrap.WrapV()));
    SetRMFrame3TextureTopology(_frame,wrap.WrapU(),wrap.WrapV());
}



/*****************************************************************************
                        RM3 Progressive Mesh Geometry
*****************************************************************************/

RM3PMeshGeo::RM3PMeshGeo (IDirect3DRMProgressiveMesh *pmesh)
    : _pmesh (pmesh)
{
    Assert (_pmesh);

    _pmesh->AddRef();

    // The bounding box returned for the pmesh will be the maximal bounding box
    // for all possible refinements of the pmesh.

    D3DRMBOX rmbox;

    if (SUCCEEDED (AD3D(_pmesh->GetBox(&rmbox))))
    {   _bbox = rmbox;
    }
    else
    {   _bbox = *nullBbox3;
    }
}



/*****************************************************************************
The cleanup method releases the pmesh reference made in the constructor.
This method is safe across multiple invocations.
*****************************************************************************/

void RM3PMeshGeo::CleanUp (void)
{
    if (_pmesh)
    {   _pmesh->Release();
        _pmesh = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\shadow.cpp ===
/*******************************************************************************
Copyright (c) 1997-1998 Microsoft Corporation.  All rights reserved.

    This code implements 3D rendered shadows.

*******************************************************************************/

#include "headers.h"

#include "appelles/gattr.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"
#include "privinc/lighti.h"
#include "privinc/ddrender.h"
#include "privinc/d3dutil.h"



/*****************************************************************************
This class implements a shadow geometry.
*****************************************************************************/

class ShadowGeom : public AttributedGeom
{
  public:

    ShadowGeom (Geometry      *geoToShadow,
                Geometry      *geoContainingLights,
                Point3Value   *planePoint,
                Vector3Value  *planeNormal)
           : AttributedGeom (geoToShadow),
             _shadowPlane (*planeNormal,*planePoint),
             _geoContainingLights (geoContainingLights)
    {
        // ensure that shadow plane normal isn't zero-length

        if (_shadowPlane.Normal().LengthSquared() == 0.0) {
            Vector3Value defaultNormal(0.0,1.0,0.0);
            Plane3 newPlane(defaultNormal,*planePoint);
            _shadowPlane = newPlane;
        }
    }

    void Render3D(GeomRenderer &ddrenderer)
    {
        Point3Value geoCenter = *((_geometry->BoundingVol())->Center());

        // is object on correct side of shadow plane?
        if (geoCenter.Clip(_shadowPlane) == CLIPCODE_IN) {

            if (ddrenderer.StartShadowing(&_shadowPlane)) {

                // collect geometry to be shadowed into one single frame
                _geometry->Render(ddrenderer);

                // find all the lights casting shadows, create shadows
                LightContext lctx(&ddrenderer);
                _geoContainingLights->CollectLights(lctx);

                // finish up
                ddrenderer.StopShadowing();
            }
        }
    }

    Bbox3 *BoundingVol (void);

    static void bbox_callback (LightContext&, Light&, void*);

    void DoKids(GCFuncObj proc)
    {
        AttributedGeom::DoKids(proc);
        (*proc)(_geoContainingLights);
    }

    VALTYPEID GetValTypeId()
    {
        return SHADOWGEOM_VTYPEID;
    }

    #if _USE_PRINT
        ostream& Print (ostream &os)
            { return os <<"shadow(" << _geometry <<")"; }
    #endif

  protected:

    Plane3    _shadowPlane;
    Geometry *_geoContainingLights;
    Bbox3     _bbox;
};



/*****************************************************************************
This method computes the bounding box of the shadows (on the shadow plane) of
the shadow geometry.
*****************************************************************************/

Bbox3* ShadowGeom::BoundingVol (void)
{
    _bbox = *nullBbox3;    // Initialize bbox to null.

    // Initiate a light-collection traversal over the light-containing
    // geometry, which will call back to the bbox_callback function below for
    // each light source encountered.  The bounding box will be augmented with
    // the shadow projection (on the shadow plane) for each light source.

    LightContext context (&bbox_callback, this);
    _geoContainingLights->CollectLights (context);

    // Return the resulting bounding box of all shadows on the shadow plane.

    return NEW Bbox3 (_bbox);
}



/*****************************************************************************
This function is called back for each light geometry encountered in the light
geometry graph.  It calculates the projection of each vertex of the geometry
bounding box on the shadow plane and augments the total bounding box of all
shadows cast on the shadow plane.
*****************************************************************************/

void ShadowGeom::bbox_callback (
    LightContext &context,     // Light Traversal Context
    Light        &light,       // Specific Light Object Encountered
    void         *data)        // Pointer to Shadow Geometry
{
    // We can't use SAFE_CAST here since we're casting from a void*.

    ShadowGeom * const shadow = (ShadowGeom*) data;

    // Skip ambient lights, since they cast no shadows.

    if (light.Type() == Ltype_Ambient)
        return;

    // Enumerate the eight vertices of the bounding box for the shadowed geom.

    Point3Value boxverts[8];
    shadow->_geometry->BoundingVol()->GetPoints (boxverts);

    switch (light.Type())
    {
        default:
            Assert (!"Invalid light type encountered.");
            break;

        case Ltype_Directional:
        {
            // For directional lights, cast rays from the vertices of the bbox
            // corners onto the shadow plane, in the same direction as the
            // directional light.  Use these projected corners to augment the
            // bounding box of all cast shadows.

            Vector3Value Ldir = *context.GetTransform() * (-(*zVector3));

            unsigned int i;
            for (i=0;  i < 8;  ++i)
            {
                Ray3 ray (boxverts[i], Ldir);
                Real t = Intersect (ray, shadow->_shadowPlane);

                // Use the projected point to augment the bounding box as long
                // as the light projects the point onto the plane, and the
                // light ray is not parallel to the shadow plane.

                if ((t > 0) && (t < HUGE_VAL))
                {   shadow->_bbox.Augment (ray.Evaluate(t));
                    Assert (fabs(Distance(shadow->_shadowPlane,ray.Evaluate(t))) < 1e6);
                }
            }

            break;
        }

        case Ltype_Point:
        case Ltype_Spot:
        {
            // For positioned lights (we ignore any other properties of
            // spotlights), cast rays from the light position through the bbox
            // corners onto the shadow plane.  Use these projected corners to
            // augment the bounding box of all cast shadows.

            Point3Value Lpos = *context.GetTransform() * (*origin3);

            // The light/object pair will cast a shadow only if the following
            // are true:  the light is on the positive side of the plane, and
            // the center of the object's bbox is on the positive side of the
            // plane, and at least one of the bbox's corner vertices lies
            // between the light and the plane.

            Plane3 &plane = shadow->_shadowPlane;

            unsigned int i;
            bool casts_shadow = false;

            const Real lightdist = Distance (plane, Lpos);

            if (lightdist > 0)
            {
                Point3Value *center =
                    shadow->_geometry->BoundingVol()->Center();

                if (Distance (plane, *center) > 0)
                {
                    for (i=0;  i < 8;  ++i)
                    {
                        if (Distance(plane,boxverts[i]) < lightdist)
                        {   casts_shadow = true;
                            break;
                        }
                    }
                }
            }

            if (casts_shadow)
            {
                for (i=0;  i < 8;  ++i)
                {
                    Ray3 ray (Lpos, boxverts[i] - Lpos);
                    Real t = Intersect (ray, plane);

                    if ((t > 0) && (t < HUGE_VAL))
                    {
                        // Use the projected point to augment the bounding box
                        // as long as the light projects the point onto the
                        // plane, and the light ray is not parallel to the
                        // shadow plane.

                        shadow->_bbox.Augment (ray.Evaluate(t));
                    }
                    else
                    {
                        // The ray goes away from the plane, so "chop" it down
                        // to 99% of the height of the light position.  This is
                        // the same hack that D3DRM uses.

                        Vector3Value N = plane.Normal();   // Unit Plane Normal
                        N.Normalize();

                        // Figure out the directed offset to bring the point to
                        // closer to the plane than the light source, and apply
                        // to get a new point.

                        Real offset = 1.01 * Dot (N, ray.Direction());

                        // If the ray is parallel to the plane, then the above
                        // dot product will be zero.  In this case, just offset
                        // the corner point toward the shadow plane by 1% of
                        // the distance from the plane.

                        if (offset <= 1e-6)
                            offset = 0.01;

                        Point3Value P2 = boxverts[i] - (offset * N);

                        // Now intersect the ray with the new point, which is
                        // closer to the plane than the light source, and hence
                        // guaranteed to intersect the plane.

                        Ray3 ray2 (Lpos, P2 - Lpos);
                        t = Intersect (ray2, plane);

                        Assert (t < HUGE_VAL);
                        shadow->_bbox.Augment (ray2.Evaluate(t));
                    }
                }
            }

            break;
        }
    }
}



Geometry *ShadowGeometry (
    Geometry     *geoToShadow,
    Geometry     *lightsgeo,
    Point3Value  *planePoint,
    Vector3Value *planeNormal)
{
    return NEW ShadowGeom (geoToShadow, lightsgeo, planePoint, planeNormal);
}



/*****************************************************************************
This class of geometry enables RM's advanced shadow-rendering.
*****************************************************************************/

class AlphaShadowGeom : public AttributedGeom
{
  public:

    AlphaShadowGeom (Geometry *geometry, bool alphaShadows)
        : AttributedGeom(geometry), _alphaShadows(alphaShadows) {}

    void Render3D (GeomRenderer &ddrenderer)
    {
        ddrenderer.PushAlphaShadows(_alphaShadows);
        _geometry->Render(ddrenderer);
        ddrenderer.PopAlphaShadows();
    }

    #if _USE_PRINT
        virtual ostream& Print (ostream& os) {
            return os << "AlphaShadowGeom(" << _alphaShadows << ","
                      << _geometry << ")";
        }
    #endif

  protected:

    bool _alphaShadows;
};



Geometry*
AlphaShadows (Geometry *geo, bool alphaShadows)
{
    if (!geo || (geo == emptyGeometry))
        return emptyGeometry;

    return NEW AlphaShadowGeom (geo, alphaShadows);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\soundgeo.cpp ===
/*++
********************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for Geometry *constructed from sound.

********************************************************************************
--*/

#include "headers.h"
#include <privinc/soundi.h>
#include <privinc/geomi.h>
#include <privinc/mici.h>
#include <appelles/vec3.h>
#include <privinc/lighti.h>
#include <privinc/snddev.h>
#include <math.h>


class SoundGeometry : public Geometry {
  public:
    SoundGeometry(Sound *snd) : _sound(snd) {}

    void Render (GenericDevice& dev) { _sound->Render(dev); }

    void CollectLights (LightContext &context) {}
    void CollectSounds (SoundTraversalContext &context)
        { context.addSound (context.getTransform(), _sound); }
    void CollectTextures(GeomRenderer &device) {}

    // Rays don't intersect sound geometries.
    void RayIntersect(RayIntersectCtx& ctx) {}

    // Bounding volume of a sound is the null bbox.
    Bbox3 *BoundingVol() { return nullBbox3; }

#if _USE_PRINT
    ostream& Print(ostream& os)
        { return os << "SoundSource(" << _sound << ")"; }
#endif

    virtual void DoKids(GCFuncObj proc) { (*proc)(_sound); }

    VALTYPEID GetValTypeId() { return SOUNDGEOM_VTYPEID; }

  protected:
    Sound *_sound;
};


Geometry *SoundSource(Sound *snd)
{
    if (snd == silence) {
        return emptyGeometry;
    } else {
        return NEW SoundGeometry(snd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\trimesh.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

    Triangle Mesh Geometry

*******************************************************************************/

#include "headers.h"
#include "d3drm.h"
#include "backend/bvr.h"
#include "privinc/geomi.h"
#include "privinc/d3dutil.h"
#include "privinc/rmvisgeo.h"



/*****************************************************************************
This object manages the behavior of a triangle mesh.
*****************************************************************************/

class TriMeshBvrImpl : public BvrImpl
{
  friend class TriMeshPerfImpl;

  public:

    TriMeshBvrImpl (void);
    ~TriMeshBvrImpl (void);

    bool Init (TriMeshData&);
    void CleanUp (void);

    DXMTypeInfo GetTypeInfo (void);

    // Return the constant value for this behavior if one exists.

    AxAValue GetConst (ConstParam &);

    // Mark member values as in-use.

    void _DoKids (GCFuncObj procedure);

    // Construct a TriMesh performance from this behavior.

    Perf _Perform (PerfParam &);

  protected:

    // Private Methods

    bool ValidateParams (TriMeshData &);

    bool BuildStaticMesh (TriMeshData &);
    bool SetupDynamicMesh (TriMeshData &);

    // Member Data Fields

    IDirect3DRMMesh *_mesh;     // Underlying RM Mesh Object
    D3DRMVERTEX     *_verts;    // D3DRM Vertices
    unsigned int     _nVerts;   // Count of D3DRMVertices

    Bvr *_vPosBvr;      // Dynamic Vertex Positions
    Bvr *_vNormBvr;     // Dynamic Vertex Normals
    Bvr *_vUVBvr;       // Dynamic Vertex Surface Coords

    Perf _constPerf;    // Constant Performance of this Behavior

    bool _fullyStatic;  // True if Mesh is Fully Constant
    bool _posStatic;    // True if Vertex Positions   are Fully Constant
    bool _normStatic;   // True if Vertex Normals     are Fully Constant
    bool _uvStatic;     // True if Vertex Surf Coords are Fully Constant
};



/*****************************************************************************
This object manages the performance of a triangle mesh behavior.
*****************************************************************************/

class TriMeshPerfImpl : public PerfImpl
{
  public:

    TriMeshPerfImpl (TriMeshBvrImpl&);
    ~TriMeshPerfImpl (void);

    bool Init (PerfParam&);
    void CleanUp (void);

    // Return a static value of this performance.

    AxAValue _Sample (Param &);

    // Mark member values as in-use.

    void _DoKids (GCFuncObj procedure);

  private:

    TriMeshBvrImpl &_tmbvr;     // Master TriMesh Behavior

    Perf *_vPos;    // Vertex Position  Performances (when positions dynamic)
    Perf *_vNorm;   // Vertex Normal    Performances (when normals dynamic)
    Perf *_vUV;     // Vertex SurfCoord Performances (when surfcoords dynamic)

    IDirect3DRMMesh *_mesh;     // Perf-local Copy of RM Mesh
    RM1MeshGeo      *_meshgeo;  // Mesh Geo for RM1 (pre DX6)
    RM3MBuilderGeo  *_mbgeo;    // MeshBuilder Geo for RM3 and Above (DX6+)
};



/*****************************************************************************
These structures are used to manage static vertex objects.
*****************************************************************************/

    // This STL comparison class is used to lexicographically compare two RM
    // vertices while ignoring the color field (which we'll use to assign
    // vertex id's temporarily).

class RMVertLess
{
  public:

    bool operator() (const D3DRMVERTEX &lhs, const D3DRMVERTEX &rhs) const
    {
        if (lhs.position.x < rhs.position.x) return true;
        if (lhs.position.x > rhs.position.x) return false;
        if (lhs.position.y < rhs.position.y) return true;
        if (lhs.position.y > rhs.position.y) return false;
        if (lhs.position.z < rhs.position.z) return true;
        if (lhs.position.z > rhs.position.z) return false;
        if (lhs.normal.x   < rhs.normal.x)   return true;
        if (lhs.normal.x   > rhs.normal.x)   return false;
        if (lhs.normal.y   < rhs.normal.y)   return true;
        if (lhs.normal.y   > rhs.normal.y)   return false;
        if (lhs.normal.z   < rhs.normal.z)   return true;
        if (lhs.normal.z   > rhs.normal.z)   return false;
        if (lhs.tu         < rhs.tu)         return true;
        if (lhs.tu         > rhs.tu)         return false;
        if (lhs.tv         < rhs.tv)         return true;
        return false;
    }
};

typedef set<D3DRMVERTEX, RMVertLess> VertSet;



/*****************************************************************************
These structures are used to manage dynamic vertex objects.
*****************************************************************************/

    // This structure holds information for a vertex in a dynamic context.
    // Sometimes all instances of a given vertex property will be constant
    // (e.g. when UV's come in as float tuples), and sometimes only some
    // properties will be constant (e.g. instances of constant position
    // behaviors mixed with dynamic ones).  The isBvrXxx flags denote each
    // property type for each vertex.  The index is used to hold the final RM
    // index into the RM mesh topology.

struct DynVertData
{
    int  index;           // Vertex Index in RM Mesh Topology
    bool isBvrPos;        // If true, position is a Point3 behavior.
    bool isBvrNorm;       // If true, normal is a Vector3 behavior.
    bool isBvrUV;         // If true, UV is a Point2 behavior.

    union { Bvr bvr;  float floats[3]; } pos;    // Position   Data
    union { Bvr bvr;  float floats[3]; } norm;   // Normal     Data
    union { Bvr bvr;  float floats[2]; } uv;     // Surf Coord Data
};


    // This method compares two instances of dynamic vertex data to determine
    // whether the first argument is less than the second one.  The ordering is
    // inconsequential, but it needs to be rigorous to ensure that the STL set
    // that uses this function will properly track which vertices already exist
    // in the vertex set.

class DynVertLess
{
  public:

    bool operator() (const DynVertData &A, const DynVertData &B) const
    {
        // First compare the vertex position.  Behavior pointers are ranked
        // less than float triples.

        if (A.isBvrPos)
        {
            if (B.isBvrPos)
            {   if (A.pos.bvr < B.pos.bvr) return true;
                if (A.pos.bvr > B.pos.bvr) return false;
            }
            else
            {   return true;
            }
        }
        else
        {
            if (B.isBvrPos)
            {   return false;
            }
            else
            {   if (A.pos.floats[0] < B.pos.floats[0]) return true;
                if (A.pos.floats[0] > B.pos.floats[0]) return false;
                if (A.pos.floats[1] < B.pos.floats[1]) return true;
                if (A.pos.floats[1] > B.pos.floats[1]) return false;
                if (A.pos.floats[2] < B.pos.floats[2]) return true;
                if (A.pos.floats[2] > B.pos.floats[2]) return false;
            }
        }

        // Next compare the vertex normal.  Behavior pointers are ranked
        // less than float triples.

        if (A.isBvrNorm)
        {
            if (B.isBvrNorm)
            {   if (A.norm.bvr < B.norm.bvr) return true;
                if (A.norm.bvr > B.norm.bvr) return false;
            }
            else
            {   return true;
            }
        }
        else
        {
            if (B.isBvrNorm)
            {   return false;
            }
            else
            {   if (A.norm.floats[0] < B.norm.floats[0]) return true;
                if (A.norm.floats[0] > B.norm.floats[0]) return false;
                if (A.norm.floats[1] < B.norm.floats[1]) return true;
                if (A.norm.floats[1] > B.norm.floats[1]) return false;
                if (A.norm.floats[2] < B.norm.floats[2]) return true;
                if (A.norm.floats[2] > B.norm.floats[2]) return false;
            }
        }

        // Next compare the vertex surface coordinates.  Behavior pointers are
        // ranked less than float tuples.

        if (A.isBvrUV)
        {
            if (B.isBvrUV)
            {   if (A.uv.bvr < B.uv.bvr) return true;
                if (A.uv.bvr > B.uv.bvr) return false;
            }
            else
            {   return true;
            }
        }
        else
        {
            if (B.isBvrUV)
            {   return false;
            }
            else
            {   if (A.uv.floats[0] < B.uv.floats[0]) return true;
                if (A.uv.floats[0] > B.uv.floats[0]) return false;
                if (A.uv.floats[1] < B.uv.floats[1]) return true;
                if (A.uv.floats[1] > B.uv.floats[1]) return false;
            }
        }

        // At this point, all elements must have compared equal, so A is not
        // less than B.

        return false;
    }
};

    // This STL set holds dynamic vertices.

typedef set<DynVertData, DynVertLess> DynVertSet;




//============================================================================
//===================  V E R T E X   I T E R A T O R S  ======================
//============================================================================




/*****************************************************************************
This is the base class for trimesh vertex iterators, which iterate through the
vertices of a fully-static trimesh.
*****************************************************************************/

class ATL_NO_VTABLE TMVertIterator
{
  public:

    TMVertIterator (TriMeshData &tmdata) : _tm(tmdata) { }
    virtual bool Init (void) = 0;

    virtual void Reset (void) = 0;
    virtual bool NextVert (D3DRMVERTEX &v) = 0;
    virtual bool NextVert (DynVertData &v) = 0;

    void LoadVert (D3DRMVERTEX &v, int ipos, int inorm, int iuv);
    void LoadVert (DynVertData &v, int ipos, int inorm, int iuv);

  protected:

    TriMeshData &_tm;   // Triangle Mesh Data

    int _currTri;       // Current Triangle
    int _currTriVert;   // Current Triangle Vertex
};



/*****************************************************************************
This method loads the referenced static vertex data according to the indices
given for position, normal and UV.
*****************************************************************************/

void TMVertIterator::LoadVert (
    D3DRMVERTEX &v,
    int ipos,
    int inorm,
    int iuv)
{
    // Load up the vertex position.

    ConstParam dummy;

    if (_tm.vPosFloat)
    {
        v.position.x = _tm.vPosFloat [(3*ipos) + 0];
        v.position.y = _tm.vPosFloat [(3*ipos) + 1];
        v.position.z = _tm.vPosFloat [(3*ipos) + 2];
    }
    else
    {
        Point3Value *vpos =
            SAFE_CAST (Point3Value*, _tm.vPosPoint3[ipos]->GetConst(dummy));

        v.position.x = vpos->x;
        v.position.y = vpos->y;
        v.position.z = vpos->z;
    }

    // Load up the vertex normal values.

    if (_tm.vNormFloat)
    {
        v.normal.x = _tm.vNormFloat [(3*inorm) + 0];
        v.normal.y = _tm.vNormFloat [(3*inorm) + 1];
        v.normal.z = _tm.vNormFloat [(3*inorm) + 2];
    }
    else
    {   Vector3Value *vnorm =
            SAFE_CAST (Vector3Value*, _tm.vNormVector3[inorm]->GetConst(dummy));
        v.normal.x = vnorm->x;
        v.normal.y = vnorm->y;
        v.normal.z = vnorm->z;
    }

    // Normalize the normal vector to ensure that it has unit length, but let
    // zero normals pass through as zero vectors.

    const Real lensq = (v.normal.x * v.normal.x)
                     + (v.normal.y * v.normal.y)
                     + (v.normal.z * v.normal.z);

    if ((lensq != 1) && (lensq > 0))
    {
        const Real len = sqrt(lensq);
        v.normal.x /= len;
        v.normal.y /= len;
        v.normal.z /= len;
    }

    // Load up the vertex surface coordinate.

    if (_tm.vUVFloat)
    {
        v.tu = _tm.vUVFloat [(2*iuv) + 0];
        v.tv = _tm.vUVFloat [(2*iuv) + 1];
    }
    else
    {
        Point2Value *vuv =
            SAFE_CAST (Point2Value*, _tm.vUVPoint2[iuv]->GetConst(dummy));

        v.tu = vuv->x;
        v.tv = vuv->y;
    }

    // We need to flip the V coordinate from DA's standard cartesian
    // coordinates (origin lower-left, V increases upwards) to RM's windows
    // coordinates (origin upper-left, V increases downwards).

    v.tv = 1 - v.tv;
}



/*****************************************************************************
This method loads the referenced dynamic vertex data according to the indices
given for position, normal and UV.
*****************************************************************************/

void TMVertIterator::LoadVert (
    DynVertData &v,
    int ipos,
    int inorm,
    int iuv)
{
    // Load up the vertex position.

    ConstParam dummy;

    if (_tm.vPosPoint3)
    {
        // We know that this position is given as a behavior, but it may be
        // a constant behavior.  If it's not constant, load the data as a
        // behavior, otherwise load the vertex's constant value (as floats).

        Point3Value *vpos =
            SAFE_CAST (Point3Value*, _tm.vPosPoint3[ipos]->GetConst(dummy));

        if (!vpos)
        {   v.isBvrPos = true;
            v.pos.bvr = _tm.vPosPoint3[ipos];
        }
        else
        {   v.isBvrPos = false;
            v.pos.floats[0] = vpos->x;
            v.pos.floats[1] = vpos->y;
            v.pos.floats[2] = vpos->z;
        }
    }
    else
    {
        v.isBvrPos = false;
        v.pos.floats[0] = _tm.vPosFloat [(3*ipos) + 0];
        v.pos.floats[1] = _tm.vPosFloat [(3*ipos) + 1];
        v.pos.floats[2] = _tm.vPosFloat [(3*ipos) + 2];
    }

    // Load up the vertex normal.

    if (_tm.vNormVector3)
    {
        // This normal is given as a behavior, but it may be constant.  If it's
        // not constant, load the normal behavior, otherwise load the normal's
        // constant value (as floats).

        Vector3Value *vnorm =
            SAFE_CAST (Vector3Value*, _tm.vNormVector3[inorm]->GetConst(dummy));

        if (!vnorm)
        {   v.isBvrNorm = true;
            v.norm.bvr = _tm.vNormVector3[inorm];
        }
        else
        {   v.isBvrNorm = false;
            v.norm.floats[0] = vnorm->x;
            v.norm.floats[1] = vnorm->y;
            v.norm.floats[2] = vnorm->z;
        }
    }
    else
    {
        v.isBvrNorm = false;
        v.norm.floats[0] = _tm.vNormFloat [(3*inorm) + 0];
        v.norm.floats[1] = _tm.vNormFloat [(3*inorm) + 1];
        v.norm.floats[2] = _tm.vNormFloat [(3*inorm) + 2];
    }

    // If the normal vector is constant, then normalize here to unit length.
    // Keep zero normal vectors as zero normal vectors.

    if (!v.isBvrNorm)
    {
        const Real lensq = (v.norm.floats[0] * v.norm.floats[0])
                         + (v.norm.floats[1] * v.norm.floats[1])
                         + (v.norm.floats[2] * v.norm.floats[2]);

        if ((lensq != 1) && (lensq > 0))
        {
            const Real len = sqrt(lensq);
            v.norm.floats[0] /= len;
            v.norm.floats[1] /= len;
            v.norm.floats[2] /= len;
        }
    }

    // Load up the vertex surface coordinate.

    if (_tm.vUVPoint2)
    {
        // This UV is a behavior, but it may be constant.  If it's not
        // constant, load the UV behavior, otherwise load the UV's constant
        // value (as floats).

        Point2Value *vuv =
            SAFE_CAST (Point2Value*, _tm.vUVPoint2[iuv]->GetConst(dummy));

        if (!vuv)
        {   v.isBvrUV = true;
            v.uv.bvr = _tm.vUVPoint2[iuv];
        }
        else
        {   v.isBvrUV = false;
            v.uv.floats[0] = vuv->x;
            v.uv.floats[1] = vuv->y;
        }
    }
    else
    {
        v.isBvrUV = false;
        v.uv.floats[0] = _tm.vUVFloat [(2*iuv) + 0];
        v.uv.floats[1] = _tm.vUVFloat [(2*iuv) + 1];
    }

    // For static UV values, flip the V coordinate to convert from DA's
    // standard cartesian coordinates (origin lower-left, V increasing upwards)
    // to RM's windows coordinates (origin upper-left, V increasing downwards).

    if (!v.isBvrUV)
    {
        v.uv.floats[1] = 1 - v.uv.floats[1];
    }
}



/*****************************************************************************
This trimesh vertex iterator works on non-indexed trimeshes.
*****************************************************************************/

class TMVertIteratorNonIndexed : public TMVertIterator
{
  public:

    TMVertIteratorNonIndexed (TriMeshData &tmdata);
    bool Init (void);

    void Reset (void);
    bool NextVert (D3DRMVERTEX &v);
    bool NextVert (DynVertData &v);

  private:

    void IncrementVert (void);

    int _currVert;      // Current Vertex
};



TMVertIteratorNonIndexed::TMVertIteratorNonIndexed (TriMeshData &tmdata)
    : TMVertIterator(tmdata)
{
    Reset();
}



bool TMVertIteratorNonIndexed::Init (void)
{
    return true;
}


void TMVertIteratorNonIndexed::Reset (void)
{
    _currTri  = 0;
    _currVert = 0;
    _currTriVert  = 0;
}



/*****************************************************************************
This method increments the vertex index.
*****************************************************************************/

void TMVertIteratorNonIndexed::IncrementVert (void)
{
    // Increment the TriMesh vertex and the triangle vertex number.
    // Increment the triangle counter if the previous vertex was a third
    // triangle vertex.

    ++ _currVert;
    ++ _currTriVert;

    if (_currTriVert >= 3)
    {
        _currTriVert = 0;
        ++ _currTri;
    }
}




/*****************************************************************************
This method gets the next static vertex of the non-indexed trimesh.
*****************************************************************************/

bool TMVertIteratorNonIndexed::NextVert (D3DRMVERTEX &v)
{
    Assert (_currTri < _tm.numTris);

    LoadVert (v, _currVert, _currVert, _currVert);

    IncrementVert();

    return true;
}



/*****************************************************************************
This method gets the next dynamic vertex of the non-indexed trimesh.
*****************************************************************************/

bool TMVertIteratorNonIndexed::NextVert (DynVertData &v)
{
    Assert (_currTri < _tm.numTris);

    LoadVert (v, _currVert, _currVert, _currVert);

    IncrementVert();

    return true;
}



/*****************************************************************************
This trimesh vertex iterator works on static indexed triangle meshes.
*****************************************************************************/

class TMVertIteratorIndexed : public TMVertIterator
{
  public:

    TMVertIteratorIndexed (TriMeshData &tmdata);
    bool Init (void);

    void Reset (void);
    bool NextVert (D3DRMVERTEX &v);
    bool NextVert (DynVertData &v);

  private:

    bool GetIndices (int &ipos, int &inorm, int &iuv);
    void IncrementVert (void);

    int _posIndex;     // Index for Vertex Position Index
    int _posStride;    // Stride for Position Indices
    int _posIMax;      // Maximum Valid Index for Positions

    int _normIndex;    // Index for Vertex Normal Index
    int _normStride;   // Stride for Normal Indices
    int _normIMax;     // Maximum Valid Index for Normals

    int _uvIndex;      // Index for Vertex UV Index
    int _uvStride;     // Stride for UV Indices
    int _uvIMax;       // Maximum Valid Index for UVs
};



/*****************************************************************************
*****************************************************************************/

TMVertIteratorIndexed::TMVertIteratorIndexed (TriMeshData &tmdata)
    : TMVertIterator(tmdata)
{
}



/*****************************************************************************
*****************************************************************************/

bool TMVertIteratorIndexed::Init (void)
{
    if (_tm.numIndices < 7)
    {   DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_MIN_INDICES);
        return false;
    }

    // Set up the index strides.

    _posStride  = _tm.indices[1];
    _normStride = _tm.indices[3];
    _uvStride   = _tm.indices[5];

    // Set up max valid index.  This is the last legal index of the start
    // of the last vertex data.

    _posIMax  = _tm.numPos  - ((_tm.vPosPoint3)   ? 1 : 3);
    _normIMax = _tm.numNorm - ((_tm.vNormVector3) ? 1 : 3);
    _uvIMax   = _tm.numUV   - ((_tm.vUVPoint2)    ? 1 : 2);

    Reset();

    return true;
}



void TMVertIteratorIndexed::Reset (void)
{
    _currTri     = 0;
    _currTriVert = 0;

    _posIndex   = _tm.indices[0];
    _normIndex  = _tm.indices[2];
    _uvIndex    = _tm.indices[4];
}



/*****************************************************************************
This method gets the next indices for the vertex properties (position, normal,
UV), based on the index array and the specified step/stride offsets.
*****************************************************************************/

bool TMVertIteratorIndexed::GetIndices (int &ipos, int &inorm, int &iuv)
{
    // Validate Vertex Position Indices

    if ((_posIndex < 0) || (_tm.numIndices <= _posIndex))
    {
        char arg[32];
        wsprintf (arg, "%d", _posIndex);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_OOB_PINDEX, arg);
        return false;
    }

    ipos = _tm.indices[_posIndex];

    if ((ipos < 0) || (_posIMax < ipos))
    {
        char arg[32];
        wsprintf (arg, "%d", ipos);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_BAD_PINDEX, arg);
        return false;
    }

    // Validate Vertex Normal Indices

    if ((_normIndex < 0) || (_tm.numIndices <= _normIndex))
    {
        char arg[32];
        wsprintf (arg, "%d", _normIndex);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_OOB_NINDEX, arg);
        return false;
    }

    inorm = _tm.indices[_normIndex];

    if ((inorm < 0) || (_normIMax < inorm))
    {
        char arg[32];
        wsprintf (arg, "%d", inorm);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_BAD_NINDEX, arg);
        return false;
    }

    // Validate Vertex UV Indices

    if ((_uvIndex < 0) || (_tm.numIndices <= _uvIndex))
    {
        char arg[32];
        wsprintf (arg, "%d", _uvIndex);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_OOB_UINDEX, arg);
        return false;
    }

    iuv = _tm.indices[_uvIndex];

    if ((iuv < 0) || (_uvIMax < iuv))
    {
        char arg[32];
        wsprintf (arg, "%d", iuv);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_BAD_UINDEX, arg);
        return false;
    }

    return true;
}



/*****************************************************************************
This method increments the vertex property indices.
*****************************************************************************/

void TMVertIteratorIndexed::IncrementVert (void)
{
    // Increment the TriMesh vertex and the triangle vertex number.
    // Increment the triangle counter if the previous vertex was a third
    // triangle vertex.

    ++ _currTriVert;

    if (_currTriVert >= 3)
    {
        _currTriVert = 0;
        ++ _currTri;
    }

    _posIndex  += _posStride;
    _normIndex += _normStride;
    _uvIndex   += _uvStride;
}



/*****************************************************************************
This method fetches the next static vertex of the indexed trimesh.
*****************************************************************************/

bool TMVertIteratorIndexed::NextVert (D3DRMVERTEX &v)
{
    Assert (_currTri < _tm.numTris);

    int ipos, inorm, iuv;

    if (!GetIndices (ipos, inorm, iuv))
        return false;

    LoadVert (v, ipos, inorm, iuv);

    IncrementVert();

    return true;
}



/*****************************************************************************
This method fetches the next dynamic vertex of the indexed trimesh.  It
returns true if it successfully did it.
*****************************************************************************/

bool TMVertIteratorIndexed::NextVert (DynVertData &v)
{
    Assert (_currTri < _tm.numTris);

    int ipos, inorm, iuv;

    if (!GetIndices (ipos,inorm,iuv))
        return false;

    LoadVert (v, ipos, inorm, iuv);

    IncrementVert();

    return true;
}



/*****************************************************************************
This method returns a new vertex iterator appropriate to the indexing of the
given trimesh data.
*****************************************************************************/

TMVertIterator* NewTMVertIterator (TriMeshData &tm)
{
    TMVertIterator *tmviterator;

    if (tm.numIndices && tm.indices)
        tmviterator = NEW TMVertIteratorIndexed (tm);
    else
        tmviterator = NEW TMVertIteratorNonIndexed (tm);

    if (!tmviterator)
        DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    else if (!tmviterator->Init())
        tmviterator = NULL;

    return tmviterator;
}




//============================================================================
//===========  T R I M E S H   B E H A V I O R   M E T H O D S  ==============
//============================================================================



/*****************************************************************************
The constructor for the TriMeshBvrImpl trivially initializes the device.  The
Init() method must be invoked (and the return value checked) to activate the
object.
*****************************************************************************/

TriMeshBvrImpl::TriMeshBvrImpl (void)
    : _mesh (NULL),
      _verts (NULL),
      _nVerts (0),
      _vPosBvr (NULL),
      _vNormBvr(NULL),
      _vUVBvr  (NULL),
      _constPerf (NULL),
      _fullyStatic (true),
      _posStatic (true),
      _normStatic (true),
      _uvStatic (true)
{
}

bool TriMeshBvrImpl::Init (TriMeshData &tmdata)
{
    if (!ValidateParams (tmdata))
        return false;

    // Check to see if all vertex properties are constant.

    ConstParam dummy;

    if (tmdata.vPosPoint3)
    {
        int i = tmdata.numPos;
        while (i--)
        {
            if (!tmdata.vPosPoint3[i]->GetConst(dummy))
            {
                _fullyStatic = false;
                _posStatic = false;
                i=0;
            }
        }
    }

    if (tmdata.vNormVector3)
    {
        int i = tmdata.numNorm;
        while (i--)
        {
            if (!tmdata.vNormVector3[i]->GetConst(dummy))
            {
                _fullyStatic = false;
                _normStatic = false;
                i=0;
            }
        }
    }

    if (tmdata.vUVPoint2)
    {
        int i = tmdata.numUV;
        while (i--)
        {
            if (!tmdata.vUVPoint2[i]->GetConst(dummy))
            {
                _fullyStatic = false;
                _uvStatic = false;
                i=0;
            }
        }
    }

    if (_fullyStatic)
    {
        if (!BuildStaticMesh (tmdata))
            return false;

        Geometry *geo;

        if (GetD3DRM3())
        {
            RM3MBuilderGeo *mbgeo;

            geo = mbgeo = NEW RM3MBuilderGeo(_mesh);

            if (!geo)
            {   DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
                return false;
            }

            // Invoke RM optimization on fully-static meshbuilder.

            mbgeo->Optimize();
        }
        else
        {
            geo = NEW RM1MeshGeo(_mesh);

            if (!geo)
            {   DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
                return false;
            }
        }

        _constPerf = ConstPerf (geo);
    }
    else
    {
        if (!SetupDynamicMesh (tmdata))
            return false;
    }

    return true;
}



/*****************************************************************************
The destruction and cleanup of a TriMeshBvrImpl are both related, and CleanUp
implements the actual cleanup of the TriMeshBvrImpl resources.
*****************************************************************************/

TriMeshBvrImpl::~TriMeshBvrImpl (void)
{
    CleanUp();
}

void TriMeshBvrImpl::CleanUp (void)
{
    if (_mesh)
    {   _mesh->Release();
        _mesh = NULL;
    }

    if (_verts)
    {   delete [] _verts;
        _verts = NULL;
    }

    if (_vPosBvr)
    {   delete [] _vPosBvr;
        _vPosBvr = NULL;
    }

    if (_vNormBvr)
    {   delete [] _vNormBvr;
        _vNormBvr = NULL;
    }

    if (_vUVBvr)
    {   delete [] _vUVBvr;
        _vUVBvr = NULL;
    }
}



/*****************************************************************************
This method claims garbage-collected objects as still in-use.
*****************************************************************************/

void TriMeshBvrImpl::_DoKids (GCFuncObj procedure)
{
    // Mark all time-varying vertex properties as used.

    unsigned int i;

    if (_vPosBvr)
    {
        for (i=0;  i < _nVerts;  ++i)
            if (_vPosBvr[i])
                (*procedure) (_vPosBvr[i]);
    }

    if (_vNormBvr)
    {
        for (i=0;  i < _nVerts;  ++i)
            if (_vNormBvr[i])
                (*procedure) (_vNormBvr[i]);
    }

    if (_vUVBvr)
    {
        for (i=0;  i < _nVerts;  ++i)
            if (_vUVBvr[i])
                (*procedure) (_vUVBvr[i]);
    }

    (*procedure) (_constPerf);
}



/*****************************************************************************
This method returns the type info for a TriMeshBvrImpl.
*****************************************************************************/

DXMTypeInfo TriMeshBvrImpl::GetTypeInfo (void)
{
    return GeometryType;
}



/*****************************************************************************
This method builds a fully-static triangle mesh.  It returns true if it
succeeded.
*****************************************************************************/

bool TriMeshBvrImpl::BuildStaticMesh (TriMeshData &tmdata)
{
    TMVertIterator *tmviterator = NewTMVertIterator (tmdata);

    if (!tmviterator) return false;

    // Allocate memory for the trimesh face data.

    unsigned int *fdata = THROWING_ARRAY_ALLOCATOR
                          (unsigned int, 3*tmdata.numTris);

    VertSet       vset;                        // Unique Vertex Set
    unsigned int  vcount   = 0;                // Vertex Counter
    unsigned int *fdptr    = fdata;            // Face Data Traversal Pointer
    unsigned int  trisleft = tmdata.numTris;   // Number of Triangles Remaining
    bool          dx3      = !GetD3DRM3();

    while (trisleft)
    {
        using std::pair;

        // Set Insertion Result
        pair<set<D3DRMVERTEX, RMVertLess>::iterator, bool> vsetResult;

        D3DRMVERTEX rmvert;    // RM Vertex

        // Add each of the three vertices for the current face.

        int i;

        for (i=0;  i < 3;  ++i)
        {
            // Get the next vertex from the iterator.  If this fails, then
            // something's wrong with the given data.

            if (!tmviterator->NextVert (rmvert))
                return false;

            // Try to insert the current vertex into the vertex set.  Note that
            // we overload the otherwise unused DWORD color field of the RM
            // vertex to hold the vertex index.

            rmvert.color = vcount;

            vsetResult = vset.insert (rmvert);

            if (!vsetResult.second)
            {
                // If the insertion failed (because of a collision with an
                // identical vertex already in the set), then use the ID of
                // the already existing vertex.

                *fdptr = (vsetResult.first)->color;
            }
            else
            {
                // If the insertion succeeded, then no other vertex in the set
                // had the same data.

                *fdptr = vcount;
                ++ vcount;
            }

            // Increment the face-data pointer to hold the next vertex id.

            ++fdptr;
        }

        // If we're on DX3, then we need clockwise vertex orientation, so flip
        // the last two vertices of the previous triangle.

        if (dx3)
        {
            const int temp = fdptr[-2];
            fdptr[-2] = fdptr[-1];
            fdptr[-1] = temp;
        }

        -- trisleft;
    }

    // Done with the trimesh vertex iterator; release it.

    delete tmviterator;

    // Ensure that we wrote as many vertex indices as we expected.

    Assert ((fdptr - fdata) == (tmdata.numTris * 3));

    // Ensure that the vertex set holds as many vertices as we expect.

    Assert (vset.size() == vcount);

    // Create the RM mesh.

    TD3D (GetD3DRM1()->CreateMesh (&_mesh));

    // Add the trimesh face data to the mesh.

    D3DRMGROUPINDEX resultIndex;

    TD3D (_mesh->AddGroup (vcount, static_cast<unsigned> (tmdata.numTris),
                           3, fdata, &resultIndex));

    Assert (resultIndex == 0);    // Expect that this is the only group.

    // Done with the face data; delete it.

    delete [] fdata;

    // Now allocate and populate the vertex buffer.

    D3DRMVERTEX *rmvdata = THROWING_ARRAY_ALLOCATOR (D3DRMVERTEX, vcount);

    VertSet::iterator vseti = vset.begin();

    while (vseti != vset.end())
    {
        const int i = (*vseti).color;
        rmvdata[i] = (*vseti);
        rmvdata[i].color = 0;

        ++ vseti;
    }

    // Set the vertex data on the RM mesh.

    TD3D (_mesh->SetVertices (resultIndex, 0, vcount, rmvdata));

    // Done with the vertex data; delete it.

    delete [] rmvdata;

    return true;
}



/*****************************************************************************
This method sets up a dynamic mesh behavior for subsequent sampling via the
Perform() method on the TriMeshBvr.  It will collapse the vertex set as much
as possible, generate the final mesh topology, and keep track of the vertex
property behaviors for subsequent sampling.  Note that TriMesh performances
will have a reference to the TriMesh behavior that spawned them, and will use
many of the member fields of the TriMesh behavior object.  Also note that this
process assumes that no TriMesh performance will be sampled at the same time
as another TriMesh performance based on the same TriMesh behavior.  This
method returns true if it succeeded.
*****************************************************************************/

bool TriMeshBvrImpl::SetupDynamicMesh (TriMeshData &tmdata)
{
    TMVertIterator *tmviterator = NewTMVertIterator (tmdata);

    if (!tmviterator) return false;

    // Allocate memory for the trimesh face data.

    unsigned int *fdata = THROWING_ARRAY_ALLOCATOR
                          (unsigned int, 3*tmdata.numTris);

    // Traverse all triangles in the trimesh, collecting up the vertices into
    // a set of unique vertices, and building RM mesh topology as we go.

    DynVertSet    vset;                        // Unique Vertex Set
    unsigned int  vcount   = 0;                // Vertex Counter
    unsigned int *fdptr    = fdata;            // Face Data Traversal Pointer
    unsigned int  trisleft = tmdata.numTris;   // Number of Triangles Remaining
    bool          dx3      = !GetD3DRM3();

    while (trisleft)
    {
        using std::pair;

        // Set Insertion Result
        pair<set<DynVertData, DynVertLess>::iterator, bool> vsetResult;

        DynVertData vert;    // RM Vertex

        // Add each of the three vertices for the current face.

        int i;

        for (i=0;  i < 3;  ++i)
        {
            // Get the next vertex from the iterator.  If this fails, then
            // something's wrong with the given data.

            if (!tmviterator->NextVert (vert))
                return false;

            // Try to insert the current vertex into the vertex set.

            vert.index = vcount;

            vsetResult = vset.insert (vert);

            if (!vsetResult.second)
            {
                // If the insertion failed (because of a collision with an
                // identical vertex already in the set), then use the index of
                // the already existing vertex.

                *fdptr = (vsetResult.first)->index;
            }
            else
            {
                // If the insertion succeeded, then no other vertex in the set
                // had the same data.

                *fdptr = vcount;
                ++ vcount;
            }

            // Increment the face-data pointer to hold the next vertex id.

            ++fdptr;
        }

        // If we're on DX3, then we need clockwise vertex orientation, so flip
        // the last two vertices of the previous triangle.

        if (dx3)
        {
            const int temp = fdptr[-2];
            fdptr[-2] = fdptr[-1];
            fdptr[-1] = temp;
        }

        -- trisleft;
    }

    // Done with the trimesh vertex iterator; release it.

    delete tmviterator;

    // Ensure that we wrote as many vertex indices as we expected.

    Assert ((fdptr - fdata) == (tmdata.numTris * 3));

    // Ensure that the vertex set holds as many vertices as we expect.

    _nVerts = vset.size();

    Assert (_nVerts == vcount);

    // Create the RM mesh.

    TD3D (GetD3DRM1()->CreateMesh (&_mesh));

    // Add the trimesh face data to the mesh.

    D3DRMGROUPINDEX resultIndex;

    TD3D (_mesh->AddGroup (vcount, static_cast<unsigned> (tmdata.numTris),
                           3, fdata, &resultIndex));

    Assert (resultIndex == 0);    // Expect that this is the only group.

    // Done with the face data; delete it.

    delete [] fdata;

    // Allocate the array of RM vertices we'll use to update the vertex values.

    _verts = THROWING_ARRAY_ALLOCATOR (D3DRMVERTEX, _nVerts);

    // At this point, we need to set everything up for the dynamic properties
    // of the trimesh vertex data.  Allocate behavior arrays for those
    // properties that contain dynamic elements (that are not fully static)

    if (!_posStatic)   _vPosBvr  = THROWING_ARRAY_ALLOCATOR (Bvr, _nVerts);
    if (!_normStatic)  _vNormBvr = THROWING_ARRAY_ALLOCATOR (Bvr, _nVerts);
    if (!_uvStatic)    _vUVBvr   = THROWING_ARRAY_ALLOCATOR (Bvr, _nVerts);

    // Write out all of the static vertex property values to the D3DRMVERTEX
    // array, and load up the vertex behavior arrays.

    DynVertSet::iterator vi;

    for (vi=vset.begin();  vi != vset.end();  ++vi)
    {
        const DynVertData &v = (*vi);
        const int index = v.index;

        if (v.isBvrPos)
            _vPosBvr[index] = v.pos.bvr;
        else
        {
            if (_vPosBvr)
                _vPosBvr[index] = NULL;

            _verts[index].position.x = v.pos.floats[0];
            _verts[index].position.y = v.pos.floats[1];
            _verts[index].position.z = v.pos.floats[2];
        }

        if (v.isBvrNorm)
            _vNormBvr[index] = v.norm.bvr;
        else
        {
            if (_vNormBvr)
                _vNormBvr[index] = NULL;

            _verts[index].normal.x = v.norm.floats[0];
            _verts[index].normal.y = v.norm.floats[1];
            _verts[index].normal.z = v.norm.floats[2];
        }

        if (v.isBvrUV)
            _vUVBvr[index] = v.uv.bvr;
        else
        {
            if (_vUVBvr)
                _vUVBvr[index] = NULL;

            _verts[index].tu = v.uv.floats[0];
            _verts[index].tv = v.uv.floats[1];
        }

        _verts[index].color = 0;
    }

    return true;
}



/*****************************************************************************
This routine is used to validate the incoming TriMesh parameters as much as
possible.  TriMesh should be pretty much bulletproof with respect to parameter
handling.
*****************************************************************************/

bool TriMeshBvrImpl::ValidateParams (TriMeshData &tm)
{
    // Ensure that the number of triangles is valid, and that the number of
    // vertex elements for each datatype is non-zero.

    if ((tm.numTris<1) || (tm.numPos<1) || (tm.numNorm<1) || (tm.numUV<1))
    {   DASetLastError (E_INVALIDARG, IDS_ERR_INVALIDARG);
        return false;
    }

    // Make sure we've got vertex data.

    if (  ((!tm.vPosFloat)  && (!tm.vPosPoint3))
       || ((!tm.vNormFloat) && (!tm.vNormVector3))
       || ((!tm.vUVFloat)   && (!tm.vUVPoint2))
       )
    {
        DASetLastError (E_INVALIDARG, IDS_ERR_INVALIDARG);
        return false;
    }

    // If the trimesh is unindexed, then make sure that we have the expected
    // number of vertex elements.

    if (tm.numIndices == 0)
    {
        // For non-indexed trimeshes, we expect a list of 3*nTris vertex
        // elements.

        const int nVerts = 3 * tm.numTris;

        // Calculate the number of data elements for the given number of
        // triangles.  This is either n floats or 1 DA behavior per vertex.

        const int posEltsMin  = nVerts * ((tm.vPosFloat  != 0) ? 3 : 1);
        const int normEltsMin = nVerts * ((tm.vNormFloat != 0) ? 3 : 1);
        const int uvEltsMin   = nVerts * ((tm.vUVFloat   != 0) ? 2 : 1);

        // Validate vertex data array sizes.

        if (tm.numPos < posEltsMin)
        {
            char arg1[32], arg2[32], arg3[32];
            wsprintf (arg1, "%d", tm.numPos);
            wsprintf (arg2, "%d", tm.numTris);
            wsprintf (arg3, "%d", posEltsMin);

            DASetLastError
                (E_INVALIDARG, IDS_ERR_GEO_TMESH_MIN_POS, arg1,arg2,arg3);

            return false;
        }

        if (tm.numNorm < normEltsMin)
        {
            char arg1[32], arg2[32], arg3[32];
            wsprintf (arg1, "%d", tm.numNorm);
            wsprintf (arg2, "%d", tm.numTris);
            wsprintf (arg3, "%d", normEltsMin);

            DASetLastError
                (E_INVALIDARG, IDS_ERR_GEO_TMESH_MIN_NORM, arg1,arg2,arg3);

            return false;
        }

        if (tm.numUV < uvEltsMin)
        {
            char arg1[32], arg2[32], arg3[32];
            wsprintf (arg1, "%d", tm.numUV);
            wsprintf (arg2, "%d", tm.numTris);
            wsprintf (arg3, "%d", uvEltsMin);

            DASetLastError
                (E_INVALIDARG, IDS_ERR_GEO_TMESH_MIN_UV, arg1,arg2,arg3);

            return false;
        }
    }
    else
    {
        // If the trimesh has an indices block, then you need at least the
        // three step-stride pairs, plus at least one index.

        if (tm.numIndices <= 6)
        {
            DASetLastError (E_INVALIDARG, IDS_ERR_GEO_TMESH_MIN_INDICES);
            return false;
        }
    }

    return true;
}



/*****************************************************************************
*****************************************************************************/

AxAValue TriMeshBvrImpl::GetConst (ConstParam&)
{
    if (_fullyStatic)
    {   
        return GetPerfConst(_constPerf);
    }

    return NULL;
}



/*****************************************************************************
*****************************************************************************/

Perf TriMeshBvrImpl::_Perform (PerfParam &perfdata)
{
    if (_fullyStatic)
        return _constPerf;

    TriMeshPerfImpl *tmperf = NEW TriMeshPerfImpl (*this);

    if (!tmperf)
    {
        DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    }
    else if (!tmperf->Init(perfdata))
    {
        tmperf->CleanUp();
        tmperf = NULL;
    }

    return tmperf;
}



/*****************************************************************************
This is the generator function for TriMesh behaviors.
*****************************************************************************/

Bvr TriMeshBvr (TriMeshData &tm)
{
    TriMeshBvrImpl *tmesh = NEW TriMeshBvrImpl();

    if (!tmesh)
    {
        DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    }
    else if (!tmesh->Init(tm))
    {
        tmesh->CleanUp();
        tmesh = NULL;
    }

    return tmesh;
}




//============================================================================
//========  T R I M E S H   P E R F O R M A N C E   M E T H O D S  ===========
//============================================================================



/*****************************************************************************
TriMesh Performance Constructor:  This just does trivial construction; the
Init function is used to activate this object.
*****************************************************************************/

TriMeshPerfImpl::TriMeshPerfImpl (TriMeshBvrImpl &tmbvr)
    : _tmbvr (tmbvr),
      _vPos (NULL),
      _vNorm (NULL),
      _vUV (NULL),
      _mesh (NULL),
      _meshgeo (NULL),
      _mbgeo (NULL)
{
}


bool TriMeshPerfImpl::Init (PerfParam &perfdata)
{
    // Allocate arrays of vertex property performances for those properties
    // that are time-varying.

    if (_tmbvr._vPosBvr)
    {
        _vPos = THROWING_ARRAY_ALLOCATOR (Perf, _tmbvr._nVerts);

        unsigned int i;
        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            const Bvr bvr = _tmbvr._vPosBvr[i];

            if (bvr)
                _vPos[i] = bvr->Perform (perfdata);
            else
                _vPos[i] = NULL;
        }
    }

    if (_tmbvr._vNormBvr)
    {
        _vNorm = THROWING_ARRAY_ALLOCATOR (Perf, _tmbvr._nVerts);

        unsigned int i;
        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            const Bvr bvr = _tmbvr._vNormBvr[i];

            if (bvr)
                _vNorm[i] = bvr->Perform (perfdata);
            else
                _vNorm[i] = NULL;
        }
    }

    if (_tmbvr._vUVBvr)
    {
        _vUV = THROWING_ARRAY_ALLOCATOR (Perf, _tmbvr._nVerts);

        unsigned int i;
        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            const Bvr bvr = _tmbvr._vUVBvr[i];

            if (bvr)
                _vUV[i] = bvr->Perform (perfdata);
            else
                _vUV[i] = NULL;
        }
    }

    // Clone the mesh from the spawning trimesh behavior to get the topology.

    IUnknown *mesh_unknown;
    TD3D (_tmbvr._mesh->QueryInterface (IID_IUnknown, (void**)&mesh_unknown));

    TD3D (_tmbvr._mesh->Clone
             (mesh_unknown, IID_IDirect3DRMMesh, (void**)&_mesh));

    return true;
}



/*****************************************************************************
The destruction and cleanup of a TriMeshPerfImpl are both related, and CleanUp
implements the actual cleanup of the TriMeshPerfImpl resources.
*****************************************************************************/


TriMeshPerfImpl::~TriMeshPerfImpl (void)
{
    CleanUp();
}

void TriMeshPerfImpl::CleanUp (void)
{
    if (_vPos)
    {   delete [] _vPos;
        _vPos = NULL;
    }

    if (_vNorm)
    {   delete [] _vNorm;
        _vNorm = NULL;
    }

    if (_vUV)
    {   delete [] _vUV;
        _vUV = NULL;
    }

    if (_mesh)
    {   _mesh->Release();
        _mesh = NULL;
    }
}



/*****************************************************************************
This method claims all AxAValueObj objects as in-use, so they aren't discarded
from the transient heap.
*****************************************************************************/

void TriMeshPerfImpl::_DoKids (GCFuncObj procedure)
{
    // First claim the TriMeshBvr that spawned us.

    (*procedure) (&_tmbvr);

    // Claim all vertex property performances.

    unsigned int i;   // Performance Index

    if (_vPos)
    {
        for (i=0;  i < _tmbvr._nVerts;  ++i)
            if (_vPos[i])
                (*procedure) (_vPos[i]);
    }

    if (_vNorm)
    {
        for (i=0;  i < _tmbvr._nVerts;  ++i)
            if (_vNorm[i])
                (*procedure) (_vNorm[i]);
    }

    if (_vUV)
    {
        for (i=0;  i < _tmbvr._nVerts;  ++i)
            if (_vUV[i])
                (*procedure) (_vUV[i]);
    }

    (*procedure) (_meshgeo);
    (*procedure) (_mbgeo);
}



/*****************************************************************************
This method samples the dynamic trimesh for a given time and returns the
geometry that represents the current value.  Note that this works with the
assumption that trimesh performances of the same trimesh behavior will not
be sampled simultaneously.
*****************************************************************************/

AxAValue TriMeshPerfImpl::_Sample (Param &sampledata)
{
    // Sample vertex positions if they're dynamic.

    unsigned int i;
    D3DRMVERTEX *rmvert;

    if (_vPos)
    {
        Perf *posperf = _vPos;

        rmvert = _tmbvr._verts;

        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            if (*posperf)
            {
                Point3Value *posvalue =
                    SAFE_CAST (Point3Value*, (*posperf)->Sample(sampledata));

                rmvert->position.x = posvalue->x;
                rmvert->position.y = posvalue->y;
                rmvert->position.z = posvalue->z;
            }

            ++ posperf;
            ++ rmvert;
        }
    }

    // Sample vertex normals if they're dynamic.  We also need to normalize the
    // normal vectors to ensure they're unit length.

    if (_vNorm)
    {
        Perf *normperf = _vNorm;

        rmvert = _tmbvr._verts;

        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            if (*normperf)
            {
                Vector3Value *normvalue =
                    SAFE_CAST (Vector3Value*, (*normperf)->Sample(sampledata));

                const Real lensq = normvalue->LengthSquared();

                if ((lensq != 1) && (lensq > 0))
                {
                    const Real len = sqrt (lensq);
                    rmvert->normal.x = normvalue->x / len;
                    rmvert->normal.y = normvalue->y / len;
                    rmvert->normal.z = normvalue->z / len;
                }
                else
                {
                    rmvert->normal.x = normvalue->x;
                    rmvert->normal.y = normvalue->y;
                    rmvert->normal.z = normvalue->z;
                }
            }

            ++ normperf;
            ++ rmvert;
        }
    }

    // Sample vertex surface coordinates if they're dynamic.  Note that DA's
    // surface coordinates are standard cartesian (origin lower-left,
    // V increasing upwards), while RM's surface coordinates mirror windows
    // (origin upper-left, increasing downwards).  Thus, we flip the V
    // coordinate when we sample.

    if (_vUV)
    {
        Perf *uvperf = _vUV;

        rmvert = _tmbvr._verts;

        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            if (*uvperf)
            {
                Point2Value *uvvalue =
                    SAFE_CAST (Point2Value*, (*uvperf)->Sample(sampledata));

                rmvert->tu =     uvvalue->x;
                rmvert->tv = 1 - uvvalue->y;
            }

            ++ uvperf;
            ++ rmvert;
        }
    }

    // Now that we've updated all of the dynamic elements for the RM vertices,
    // update the vertices in the RM mesh.

    TD3D (_mesh->SetVertices(0, 0, _tmbvr._nVerts, _tmbvr._verts));

    // Normally, we'll be sampled on the transient heap, so it's safe to side-
    // effect the underlying mesh.  However, if we're being snapshotted, we
    // need to return a new mesh that isn't changed by side-effect (subsequent
    // samples).  If we're not transient (i.e. we need a persistent value),
    // we clone the mesh here.

    AxAValueObj *result;

    if (GetHeapOnTopOfStack().IsTransientHeap())
    {
        // Since we're on the transient heap, it's safe to side-effect the
        // result value (this performance won't be kept across frames).  Thus
        // we can just return the updated/side-effected RMVisualGeo result.

        if (GetD3DRM3())
        {
            // Use the existing RM3MeshBuilderGeo if we've got one, otherwise
            // create one for the first time.

            if (_mbgeo)
                _mbgeo->Reset (_mesh);
            else
            {
                DynamicHeapPusher dhp (GetGCHeap());
               _mbgeo = NEW RM3MBuilderGeo (_mesh);
            }

            result = _mbgeo;
        }
        else
        {
            // If we haven't yet wrapped the underlying mesh in the RM1MeshGeo
            // object, wrap it here.  Changes to the underlying mesh will
            // transparently manifest themselves in the wrapped object.

            if (_meshgeo)
            {
                _meshgeo->MeshGeometryChanged();
            }
            else
            {
                DynamicHeapPusher dhp (GetGCHeap());
                _meshgeo = NEW RM1MeshGeo (_mesh);
            }

            result = _meshgeo;
        }
    }
    else
    {
        // We're not on the transient heap, so the returned value must be
        // persistent (and not side-effected).  This will happen when the
        // performance is being snapshotted, for example.  In this case, we
        // must return a new mesh result that we don't change in the future.
        // To do this, clone the underlying mesh and wrap it in the appropriate
        // RMVisualGeo object.

        IUnknown        *mesh_unknown;    // Needed for Mesh Cloning
        IDirect3DRMMesh *mesh;            // Cloned RM Mesh

        TD3D (_mesh->QueryInterface (IID_IUnknown, (void**)&mesh_unknown));
        TD3D (_mesh->Clone (mesh_unknown, IID_IDirect3DRMMesh, (void**)&mesh));

        // Wrap the cloned mesh in the appropriate RMVisualGeo object.

        if (GetD3DRM3())
            result = NEW RM3MBuilderGeo (mesh);
        else
            result = NEW RM1MeshGeo (mesh);

        if (!result)
            DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);

        // Done with our reference to the cloned mesh (the RMVisualGeo wrapper
        // holds a reference).

        mesh->Release();
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\xfile.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Reading a .X File as a Geometry.

*******************************************************************************/

#include "headers.h"
#include <d3drm.h>
#include <d3drmdef.h>
#include "appelles/gattr.h"
#include "appelles/readobj.h"
#include "privinc/urlbuf.h"
#include "privinc/bbox3i.h"
#include "privinc/resource.h"
#include "privinc/debug.h"
#include "privinc/d3dutil.h"
#include "privinc/rmvisgeo.h"
#include "privinc/stlsubst.h"
#include "privinc/importgeo.h"
#include "privinc/comutil.h"



class FrameContext;

void    RM1LoadCallback (IDirect3DRMObject*, REFIID, void*);
void    RM3LoadCallback (IDirect3DRMObject*, REFIID, void*);
void    RM1LoadCallback_helper (IDirect3DRMObject*, REFIID, void*);
void    RM3LoadCallback_helper (IDirect3DRMObject*, REFIID, void*);
HRESULT RM1LoadTexCallback (char*, void*, IDirect3DRMTexture**);
HRESULT RM1LoadTexCallback_helper (char*, void*, IDirect3DRMTexture**);
HRESULT RM3LoadTexCallback (char*, void*, IDirect3DRMTexture3**);
HRESULT RM3LoadTexCallback_helper (char*, void*, IDirect3DRMTexture3**);
bool    MeshBuilderToMesh (IDirect3DRMMeshBuilder*, IDirect3DRMMesh**, bool);
void    TraverseD3DRMFrame (IDirect3DRMFrame*, FrameContext&);
void    GatherVisuals (IDirect3DRMFrame*, FrameContext&);


/*****************************************************************************
A base class for maintaining error results.
*****************************************************************************/

class D3DErrorCtx
{
  public:
    D3DErrorCtx() : _error(false) {}

    void SetError() { _error = true; }
    bool Error() { return _error; }

  protected:
    bool _error;
};



/*****************************************************************************
The following class manages the context for .X file loading callbacks.
*****************************************************************************/

class XFileData : public D3DErrorCtx
{
  public:

    XFileData (bool v1Compatible, TextureWrapInfo *wrapinfo) :
        _aggregate (emptyGeometry),
        _wrapInfo (wrapinfo),
        _v1Compatible (v1Compatible)
    {
    }

    ~XFileData (void)
    {
    }

    // This function is called for each object read in from the .X file.
    // We just aggregate this geometry with the current geometry union.

    void AddGeometry (Geometry *geometry)
    {   _aggregate = PlusGeomGeom (_aggregate, geometry);
    }

    // Add and null-name encountered meshbuilders.  This is due to the lack of
    // object-name scoping in RM and our need for backwards-compatiblity.

    void AddMBuilder (IDirect3DRMMeshBuilder3*);
    void ClearMBNames (void);

    // This function returns the aggregation of all given geometries.

    Geometry *GetAggregateGeometry (void)
    {   return _aggregate;
    }

    // this function stashes away the absolute URL of the .X file, which
    // is used to build the absolute URLs of the texture files referenced
    // by the .X file

    void SaveHomeURL(char *homeURL)
    {
        lstrcpyn(_home_url,homeURL,INTERNET_MAX_URL_LENGTH);
        _home_url[INTERNET_MAX_URL_LENGTH - 1] = '\0';
        return;
    }

    // get the absolute URL of the .X file that we stashed away

    char* GetHomeURL(void)
    {
        return _home_url;
    }

    TextureWrapInfo *_wrapInfo;
    bool             _v1Compatible;

  protected:

    bool      _error;
    Geometry *_aggregate;
    char      _home_url[INTERNET_MAX_URL_LENGTH];

    vector<IDirect3DRMMeshBuilder3*> _mblist;
};



/*****************************************************************************
These routines add mbuilders and clear mbuilder names (for backwards compat,
and due to the lack of object-name scoping in RM).
*****************************************************************************/

void XFileData::AddMBuilder (IDirect3DRMMeshBuilder3 *mb)
{
    VECTOR_PUSH_BACK_PTR (_mblist, mb);
}


void XFileData::ClearMBNames (void)
{
    while (_mblist.size() > 0)
    {   
        IDirect3DRMMeshBuilder3 *mb = _mblist.back();
        _mblist.pop_back();
        AD3D (mb->SetName(NULL));
    }
}



/*****************************************************************************
This function takes the pathname of a .X file and returns the Geometry read in
from that file.
*****************************************************************************/

Geometry* ReadXFileForImport (
    char            *pathname,   // Full URL
    bool             v1Compatible,
    TextureWrapInfo *pWrapInfo)
{
    // The DX3 Alpha platform has too many problems with 3D.

    #ifdef _ALPHA_
    {   if (!GetD3DRM3())
            return emptyGeometry;
    }
    #endif

    #ifndef _IA64_
        if(IsWow64())
            return emptyGeometry;
    #endif

    // 3D is disabled on pre-DX3 systems.

    if (sysInfo.VersionD3D() < 3)
        RaiseException_UserError (E_FAIL, IDS_ERR_PRE_DX3);

    Assert (pathname);

    INetTempFile tempFile(pathname);
    char *tempFileName = tempFile.GetTempFileName();

    Assert (tempFileName);

    TraceTag ((tagReadX, "Importing \"%s\"", pathname));

    XFileData xdata (v1Compatible, pWrapInfo);   // Load Callback Context

    // Save .X file's absolute URL so we can form absolute URLs to texture
    // files referenced by .X file.

    xdata.SaveHomeURL (pathname);

    // Call the generic D3DRM load call.  This sets up callbacks for objects
    // (meshbuilders or frames) or textures read in from the file.

    HRESULT result;

    if (GetD3DRM3())
    {
        const int guidlistcount = 3;

        static IID *guidlist [guidlistcount] =
        {   (GUID*) &IID_IDirect3DRMMeshBuilder3,
            (GUID*) &IID_IDirect3DRMFrame3,
            (GUID*) &IID_IDirect3DRMProgressiveMesh
        };

        Assert (guidlistcount == (sizeof(guidlist) / sizeof(guidlist[0])));

        // If we catch an exception here then we must have incorrectly
        // failed to catch an exception we threw in one of the
        // callbacks.  This would be a BAD bug
        //
        // Disabled for now since it cannot compile with the inlined
        // try block
        #if _DEBUG1
        __try {
        #endif
        result = GetD3DRM3()->Load
                 (   tempFileName, NULL, guidlist, guidlistcount,
                     D3DRMLOAD_FROMFILE, RM3LoadCallback_helper, &xdata,
                     RM3LoadTexCallback_helper, &xdata, NULL
                 );
        #if _DEBUG1
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            Assert(false && "BUG:  Failed to catch an exception in D3DRM callback.");
        }
        #endif

        // Now that we're done with the file, we need to null-out the mbuilder
        // object names so they don't get used in future .X files.  For example,
        // if a mbuilder with name "Arrow" is defined here, it will be used in
        // a subsequent X file even if a different mbuilder with the name
        // "Arrow" is defined in that file.  To work around this, we clear all
        // of the names of mbuilders from this file.

        xdata.ClearMBNames();
    }
    else
    {
        const int guidlistcount = 2;

        static IID *guidlist [guidlistcount] =
        {   (GUID*) &IID_IDirect3DRMMeshBuilder,
            (GUID*) &IID_IDirect3DRMFrame
        };

        Assert (guidlistcount == (sizeof(guidlist) / sizeof(guidlist[0])));

        // If we catch an exception here then we must have incorrectly
        // failed to catch an exception we threw in one of the
        // callbacks.  This would be a BAD bug
        //
        // Disabled for now since it cannot compile with the inlined
        // try block
        #if _DEBUG1
        __try {
        #endif
        result = GetD3DRM1()->Load
                 (   tempFileName, NULL, guidlist, guidlistcount,
                     D3DRMLOAD_FROMFILE, RM1LoadCallback_helper, &xdata,
                     RM1LoadTexCallback_helper, &xdata, NULL
                 );
        #if _DEBUG1
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            Assert(false && "BUG:  Failed to catch an exception in D3DRM callback.");
        }
        #endif
    }

    if (xdata.Error()) {
        TraceTag((tagError, "D3DRM Get error"));
        RaiseException_InternalError("D3DRM Get error");
    }

    switch (result)
    {
        case D3DRM_OK: break;

        default:                  // If we don't know the error, then just pass
            TD3D (result);        // it to the regular HRESULT error handler.
            return emptyGeometry;

        case D3DRMERR_FILENOTFOUND:
            RaiseException_UserError (E_FAIL, IDS_ERR_FILE_NOT_FOUND, pathname);

        case D3DRMERR_BADFILE:
            RaiseException_UserError (E_FAIL, IDS_ERR_CORRUPT_FILE, pathname);
    }

    return xdata.GetAggregateGeometry ();
}



/*****************************************************************************
This class maintains the context during the traversal of a DX3 (RM1) frame
hierarchy.
*****************************************************************************/

class FrameContext : public D3DErrorCtx
{
  public:

    // Define a mapping between meshbuilders and meshes, and the number of
    // references to each meshbuilder.  We need to do this to ensure that we
    // properly handle multiply-referenced leaf geometries, and to keep a list
    // of all meshes in the frame.

    typedef map <IDirect3DRMMeshBuilder*, IDirect3DRMMesh*> MeshMap;

    typedef vector<IDirect3DRMMesh*> MeshVector;

    FrameContext ()
    : _xform (identityTransform3), depth(0) {}

    ~FrameContext ()
    {
        for (MeshMap::iterator i = _meshmap.begin();
             i != _meshmap.end(); i++) {
            // We've been holding on to the meshbuilder handles to ensure that
            // pointers to each meshbuilder are unique to handle multiply-
            // instanced geometries.  Release the last instance here.

            (*i).first->Release();
            (*i).second->Release();
        }

        _meshmap.erase (_meshmap.begin(), _meshmap.end());
    }

    // These methods manage the transform stack while traversing frame graphs.

    void        SetTransform (Transform3 *xf) { _xform = xf; }
    Transform3 *GetTransform (void)           { return _xform; }

    void AddTransform (Transform3 *xf)
    {   _xform = TimesXformXform (_xform, xf);
    }

    // These methods build up and return the bounding box for the entire
    // frame graph.

    void AugmentModelBbox (Bbox3 *box) {
        _bbox.Augment (*TransformBbox3 (_xform, box));
    }

    Bbox3 *GetBbox (void) {
        return NEW Bbox3 (_bbox);
    }

    // This method loads all of the meshes we've converted from meshbuilders
    // into a single vector element (to be used with RM1FrameGeo objects).

    void LoadMeshVector (MeshVector *mvec)
    {
        MeshMap::iterator mi = _meshmap.begin();

        while (mi != _meshmap.end())
        {
            VECTOR_PUSH_BACK_PTR (*mvec, (*mi).second);

            ++ mi;
        }
    }

    // The traversal depth.  The first frame is depth 1.

    int depth;

    // These methods manage which meshes correspond to which meshbuilders.
    // The mapping between the two is noted because a meshbuilder may be
    // instanced several times in a frame graph.

    IDirect3DRMMesh *GetMatchingMesh (IDirect3DRMMeshBuilder *mb)
    {   MeshMap::iterator mi = _meshmap.find (mb);
        return (mi == _meshmap.end()) ? NULL : (*mi).second;
    }

    // This routine is called to establish a relation between a meshbuilder and
    // a corresponding mesh.  NOTE:  GetMatchingMesh() should be called first
    // to ensure that there isn't already an existing match for the given
    // meshbuilder object.

    void AddMesh (IDirect3DRMMeshBuilder *builder, IDirect3DRMMesh *mesh)
    {
        // Ensure that this is a new entry.

        #if _DEBUG
        {   MeshMap::iterator mi = _meshmap.find (builder);
            Assert (mi == _meshmap.end());
        }
        #endif

        builder->AddRef();    // Hang on to the builder until context destruct.

        _meshmap[builder] = mesh;   // Set the association.
    }

  protected:

    Transform3  *_xform;       // Current Accumulated Transform
    Bbox3        _bbox;        // Total Frame Bounding Box
    MeshMap      _meshmap;     // Mesh/Builder Pairs
};


void RM1LoadCallback_helper (
    IDirect3DRMObject *object,      // The Generic D3D RM Object
    REFIID             id,          // The Object's GUID
    void              *user_data)   // Our Data (== XFileData*)
{
    __try {
        RM1LoadCallback(object, id, user_data);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ((XFileData*)user_data)->SetError();
    }

    object->Release();
}

/*****************************************************************************
The following is the main callback function for reading frames or meshes from
.X files using the RM1 interface (DX3).  This function is called for each
meshbuilder and each frame in the file.
*****************************************************************************/

void RM1LoadCallback (
    IDirect3DRMObject *object,      // The Generic D3D RM Object
    REFIID             id,          // The Object's GUID
    void              *user_data)   // Our Data (== XFileData*)
{
    XFileData &xdata = *(XFileData*)(user_data);

    if (id == IID_IDirect3DRMMeshBuilder)
    {
        TraceTag ((tagReadX, "RM1LoadCallback (mbuilder %x)", object));

        DAComPtr<IDirect3DRMMeshBuilder> meshBuilder;

        if (FAILED(AD3D(object->QueryInterface
                    (IID_IDirect3DRMMeshBuilder, (void**)&meshBuilder))))
        {
            xdata.SetError();
            return;
        }

        // Convert the meshbuilder object to a mesh, and flip over to the
        // right-handed coordinate system.

        DAComPtr<IDirect3DRMMesh> mesh;

        if (!MeshBuilderToMesh (meshBuilder, &mesh, true))
            xdata.SetError();

        xdata.AddGeometry (NEW RM1MeshGeo (mesh));
    }
    else if (id == IID_IDirect3DRMFrame)
    {
        TraceTag ((tagReadX, "RM1LoadCallback (frame %x)", object));

        DAComPtr<IDirect3DRMFrame> frame;

        if (FAILED(AD3D(object->QueryInterface
                    (IID_IDirect3DRMFrame, (void**)&frame))))
        {
            xdata.SetError();
            return;
        }

        // Add a top-level scale of -1 in Z to convert to RH coordinates.

        if (FAILED(AD3D(frame->AddScale (D3DRMCOMBINE_BEFORE, 1,1,-1))))
        {
            xdata.SetError();
            return;
        }

        FrameContext context;

        TraverseD3DRMFrame (frame, context);

        // Now get a list of all the meshes in the frame.

        FrameContext::MeshVector meshvec;
        context.LoadMeshVector (&meshvec);

        xdata.AddGeometry (NEW RM1FrameGeo (frame,&meshvec,context.GetBbox()));

        if (context.Error())
            xdata.SetError();
    }
    else
    {
        AssertStr (0, "Unexpected type fetched from RM1LoadCallback.");
    }
}



/*****************************************************************************
This callback procedure is invoked for each object loaded from an X file using
the RM3 (DX6) load procedure.
*****************************************************************************/

void RM3LoadCallback_helper (
    IDirect3DRMObject *object,      // The Generic D3D RM Object
    REFIID             id,          // The Object's GUID
    void              *user_data)   // Our Data (== XFileData*)
{
    __try {
        RM3LoadCallback(object, id, user_data);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ((XFileData*)user_data)->SetError();
    }

    object->Release();
}

void RM3LoadCallback (
    IDirect3DRMObject *object,      // The Generic D3D RM Object
    REFIID             id,          // The Object's GUID
    void              *user_data)   // Our Data (== XFileData*)
{
    XFileData &xdata = *(XFileData*)(user_data);

    DAComPtr<IDirect3DRMMeshBuilder3>    mbuilder;
    DAComPtr<IDirect3DRMFrame3>          frame;
    DAComPtr<IDirect3DRMProgressiveMesh> pmesh;

    if (SUCCEEDED(RD3D(object->QueryInterface
                      (IID_IDirect3DRMMeshBuilder3, (void**)&mbuilder))))
    {
        TraceTag ((tagReadX, "RM3LoadCallback (mbuilder3 %x)", mbuilder));

        xdata.AddMBuilder (mbuilder);

        RM3MBuilderGeo *builder = NEW RM3MBuilderGeo (mbuilder, false);
        if (xdata._wrapInfo) {
            builder->TextureWrap (xdata._wrapInfo);
        }

        builder->Optimize();    // Invoke RM Optimization

        xdata.AddGeometry (builder);
    }
    else if (SUCCEEDED(RD3D(object->QueryInterface
                           (IID_IDirect3DRMFrame3, (void**)&frame))))
    {
        TraceTag ((tagReadX, "RM3LoadCallback (frame3 %x)", frame));

        if (xdata._v1Compatible)
        {
            // Unless we're using the new wrapped geometry import, break the
            // imported frame transform to maintain backwards compatibility.
            // We do this by cancelling out the valid Zflip on one side of
            // the transform and placing it on the incorrect side.

            HRESULT result;

            result = RD3D(frame->AddScale (D3DRMCOMBINE_BEFORE, 1, 1, -1));
            AssertStr (SUCCEEDED(result), "Combine before-xform failure");

            result = RD3D(frame->AddScale (D3DRMCOMBINE_AFTER,  1, 1, -1));
            AssertStr (SUCCEEDED(result), "Combine after-xform failure");
        }

        RM3FrameGeo *rm3frame = NEW RM3FrameGeo (frame);

        if (xdata._wrapInfo) {
            rm3frame->TextureWrap (xdata._wrapInfo);
        }

        xdata.AddGeometry (rm3frame);
    }
    else if (SUCCEEDED(RD3D(object->QueryInterface
                           (IID_IDirect3DRMProgressiveMesh, (void**)&pmesh))))
    {
        TraceTag ((tagReadX, "RM3LoadCallback (pmesh %x)", pmesh));

        xdata.AddGeometry (NEW RM3PMeshGeo (pmesh));
    }
    else
    {
        AssertStr (0, "Unexpected type fetched from RM3LoadCallback.");
    }
}



/*****************************************************************************
This function is called back for each texture in the RM1 load of an X file.
*****************************************************************************/

HRESULT RM1LoadTexCallback_helper (
    char                *name,           // Texture File Name
    void                *user_data,      // Our Data (== XFileData*)
    IDirect3DRMTexture **texture)        // Destination Texture Handle
{
    HRESULT ret;

    __try {
        ret = RM1LoadTexCallback(name, user_data, texture);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ret = DAGetLastError();
    }

    return ret;
}



HRESULT RM1LoadTexCallback (
    char                *name,           // Texture File Name
    void                *user_data,      // Our Data (== XFileData*)
    IDirect3DRMTexture **texture)        // Destination Texture Handle
{
    TraceTag ((tagReadX,"RM1LoadTexCallback \"%s\", texture %x",name,texture));
    HRESULT ret;

    // Get the absolute URL of the texture file.

    XFileData *const xdata = (XFileData*) user_data;
    URLRelToAbsConverter absoluteURL(xdata->GetHomeURL(),name);
    char *resultURL = absoluteURL.GetAbsoluteURL();

    // get it over to local machine

    INetTempFile tempFile;

    *texture = NULL;
    if (!tempFile.Open(resultURL)) {

        ret = D3DRMERR_FILENOTFOUND;
        TraceTag ((tagError,"RM1LoadTexCallback: \"%s\" not found",resultURL));

    } else {

        // Get the local file name and pass it along to RM to load texture.

        char *tempFileName = tempFile.GetTempFileName();
        ret = RD3D(GetD3DRM1()->LoadTexture (tempFileName, texture));

        TraceTag ((tagGTextureInfo, "Loaded RM texture %x from \"%s\"",
                   texture, resultURL));

    }

    return ret;
}



/*****************************************************************************
This function is called back for each texture in the RM3 load of an X file.
*****************************************************************************/

HRESULT RM3LoadTexCallback_helper (
    char                 *name,           // Texture File Name
    void                 *user_data,      // Our Data (== XFileData*)
    IDirect3DRMTexture3 **texture)        // Destination Texture Handle
{
    HRESULT ret;

    __try {
        ret = RM3LoadTexCallback(name, user_data, texture);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ret = DAGetLastError();
    }

    return ret;
}



HRESULT RM3LoadTexCallback (
    char                 *name,           // Texture File Name
    void                 *user_data,      // Our Data (== XFileData*)
    IDirect3DRMTexture3 **texture)        // Destination Texture Handle
{
    TraceTag ((tagReadX,"RM3LoadTexCallback \"%s\", texture %x",name,texture));
    HRESULT ret;

    // Get the absolute URL of the texture file.

    XFileData *const xdata = (XFileData*) user_data;
    URLRelToAbsConverter absoluteURL(xdata->GetHomeURL(),name);
    char *resultURL = absoluteURL.GetAbsoluteURL();

    // get it over to local machine

    INetTempFile tempFile;

    *texture = NULL;
    if (!tempFile.Open(resultURL)) {

        ret = D3DRMERR_FILENOTFOUND;
        TraceTag ((tagError,"RM3LoadTexCallback: \"%s\" not found",resultURL));

    } else {

        // Get the local file name and pass it along to RM to load texture.

        char *tempFileName = tempFile.GetTempFileName();
        ret = RD3D(GetD3DRM3()->LoadTexture (tempFileName, texture));

        TraceTag ((tagGTextureInfo, "Loaded RM texture %x from \"%s\"",
                   texture, resultURL));

    }

    return ret;
}



/*****************************************************************************
This procedure recursively traverses D3DRM frames, constructing the bounding
box for the entire frame, and tracking the internal meshes as it goes.
*****************************************************************************/

void TraverseD3DRMFrame (
    IDirect3DRMFrame *frame,
    FrameContext     &context)
{
    ++ context.depth;

    // Accumulate the current frame's modeling transform.

    Transform3 *oldxf = context.GetTransform();

    D3DRMMATRIX4D d3dxf;

    if (FAILED(AD3D (frame->GetTransform (d3dxf))))
    {   context.SetError();
        return;
    }

    context.AddTransform (GetTransform3(d3dxf));

    GatherVisuals(frame, context);

    // Traverse all of the child frames.

    IDirect3DRMFrameArray *children;

    if (FAILED(AD3D(frame->GetChildren(&children))))
    {   context.SetError();
        return;
    }

    DWORD count = children->GetSize();

    #if _DEBUG
    {   if (count)
            TraceTag ((tagReadX, "%d: %d children", context.depth, count));

        D3DRMMATERIALMODE matmode = frame->GetMaterialMode();

        TraceTag ((tagReadX, "%d: Material Mode is %s",
            context.depth,
            (matmode == D3DRMMATERIAL_FROMMESH)   ? "From-Mesh" :
            (matmode == D3DRMMATERIAL_FROMPARENT) ? "From-Parent" :
            (matmode == D3DRMMATERIAL_FROMFRAME)  ? "From-Frame" : "Unknown"));
    }
    #endif

    for (int i=0;  i < count;  ++i)
    {
        IDirect3DRMFrame *child;

        if (FAILED(AD3D (children->GetElement (i, &child))))
        {   context.SetError();
            return;
        }

        // We should just do an assert instead, this is to guard
        // against DX2.

        if (!child) {
            context.SetError();
            return;
        }

        TraceTag ((tagReadX, "%d: Traversing child %d.", context.depth, i));
        TraverseD3DRMFrame (child, context);
        TraceTag ((tagReadX, "%d: Return from child %d.", context.depth, i));

        child->Release();
    }

    children->Release();

    context.SetTransform (oldxf);

    -- context.depth;
}



/*****************************************************************************
This procedure gathers all visuals for a particular frame node, and
accumulates the state in the given frame context.
*****************************************************************************/

void GatherVisuals (IDirect3DRMFrame *frame, FrameContext& context)
{
    // Gather all of the visuals from the frame.

    DWORD count;   // Generic Array Count

    IDirect3DRMVisualArray *visuals;

    if (FAILED(AD3D(frame->GetVisuals(&visuals))))
    {   context.SetError();
        return;
    }

    count = visuals->GetSize();

    #if _DEBUG
        if (count)
            TraceTag ((tagReadX, "%d: %d visuals", context.depth, count));
    #endif

    HRESULT result;
    int     i;

    for (i=0;  i < count;  ++i)
    {
        IDirect3DRMVisual      *visual;
        IDirect3DRMMeshBuilder *builder;

        // See if the object is a mesh builder (this is what we expect).

        if (FAILED(AD3D(visuals->GetElement (i, &visual))))
        {   context.SetError();
            return;
        }

        Assert (visual);

        result = visual->QueryInterface
                         (IID_IDirect3DRMMeshBuilder, (void**)&builder);

        if (result != D3DRM_OK) {

            Assert (!"Unexpected visual type in .X file (not meshBuilder)");

        } else {
            TraceTag ((tagReadX, "%d: Visual %08x [%d] is a meshbuilder",
                context.depth, visual, i));

            // Remove the meshbuilder from the tree; we'll be using a mesh
            // in its stead.

            if (FAILED(AD3D(frame->DeleteVisual (builder))))
            {   context.SetError();
                return;
            }

            // First try to see if we've already dealt with this particular
            // meshbuilder (some meshes may be referenced more than once in the
            // scene graph).

            IDirect3DRMMesh *mesh = context.GetMatchingMesh (builder);

            // If we've already handled this meshbuilder, then just use the
            // resultant mesh and get the model-coord bounding box.

            D3DRMBOX d3dbox;

            if (mesh) {

                TraceTag ((tagReadX,
                    "%d: Builder %08x already mapped to mesh %08x",
                    context.depth, builder, mesh));

                // Augment the scene bbox with the bbox of the current mesh.

                if (FAILED(AD3D(mesh->GetBox(&d3dbox))))
                {   context.SetError();
                    return;
                }

            } else {

                // If we have NOT seen this meshbuilder before, then convert it
                // to a mesh and add the pair to the context.  Also keep it
                // from flipping the Z coordinates, since we do that at the
                // root of this frame graph.

                if (!MeshBuilderToMesh (builder, &mesh, false))
                    context.SetError();

                TraceTag ((tagReadX, "%d: Builder %08x converted to mesh %08x",
                           context.depth, builder, mesh));

                context.AddMesh (builder, mesh);

                if (FAILED(AD3D(builder->GetBox(&d3dbox))))
                {   context.SetError();
                    return;
                }
            }

            // Release the meshbuilder object.

            builder->Release();

            // Augment the scene bbox with the bbox of this mesh's instance.

            context.AugmentModelBbox (NEW Bbox3 (d3dbox));

            // Replace the meshbuilder object with the corresponding mesh.

            if (FAILED(AD3D(frame->AddVisual(mesh))))
            {   context.SetError();
                return;
            }
        }

        visual->Release();
    }

    visuals->Release();
}



/*****************************************************************************
Converts the mesh builder to a mesh, converts the vertex coords to right-hand
cartesian (position and surface coords).  Returns true if successful.
*****************************************************************************/

bool MeshBuilderToMesh (
    IDirect3DRMMeshBuilder  *inputBuilder,    // Mesh Builder Object
    IDirect3DRMMesh        **outputMesh,      // Resultant Mesh Object
    bool                     flipZ)           // If true, invert Z coord.
{
    *outputMesh = 0;

    // Convert to right-handed coordinate system if needed.

    if (flipZ) {
        Assert (!GetD3DRM3() && "Shouldn't do flipz when D3DRM3 available.");

        if (FAILED(AD3D(inputBuilder->Scale(D3DVAL(1),D3DVAL(1),D3DVAL(-1)))))
            return false;
    }

    // Generate a mesh which will be stored with this Geometry object.

    if (FAILED(AD3D(inputBuilder->CreateMesh(outputMesh))))
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\cachdimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include "privinc/cachdimg.h"
#include "privinc/dddevice.h"
#include "privinc/path2i.h"
#include "include/appelles/color.h"
#include "include/appelles/path2.h"
#include "include/appelles/linestyl.h"

CachedImage::CachedImage(Image *underlyingImage,
                         bool   usedAsTexture)
{
    _dev = NULL;
    _image = underlyingImage;
    _usedAsTexture = usedAsTexture;
}

CachedImage::~CachedImage()
{
    CleanUp();
}

void
CachedImage::InitializeWithDevice(ImageDisplayDev *dev, Real res)
{
    _resolution = res;
    _dev = (DirectDrawImageDevice *)dev;
    _bbox = _image->BoundingBox();
    
    _nominalWidth = (unsigned long) ((_bbox.max.x - _bbox.min.x ) * GetResolution());
    _nominalHeight = (unsigned long)((_bbox.max.y - _bbox.min.y ) * GetResolution());

    // fix up the width and height.
    if(_nominalWidth %2)  _nominalWidth++;
    if(_nominalHeight %2) _nominalHeight++;
    _nominalWidth +=4;
    _nominalHeight+=4;

    short w, h;
    _image->ExtractRenderResolution(&w, &h, true);
    _width = w;
    _height = h;

    // Can't both be 0.
    if (_width == 0 && _height == 0) {

        // Bogus, just use the defaults
        _width = -1;
        _height = -1;
    }

    if (_width == -1) {
        if (_usedAsTexture) {
            _width = DEFAULT_TEXTURE_WIDTH;
        } else {
            _width = _nominalWidth;
        }
    }

    if (_height == -1) {
        if (_usedAsTexture) {
            _height = DEFAULT_TEXTURE_HEIGHT;
        } else {
            _height = _nominalHeight;
        }
    }

    if ((_width == 0 || _height == 0) &&
        (_nominalHeight != 0 && _nominalWidth != 0)) {

        Assert(!(_width == 0 && _height == 0));
        
        // Maintain aspect ratio.
        short anchoredDimension =
            _width == 0 ? _height : _width;

        if (_nominalHeight > _nominalWidth) {
            
            Real factor = (Real)(_nominalWidth) /
                          (Real)(_nominalHeight);

            _height = anchoredDimension;
            _width = anchoredDimension * factor;
            
        } else {
            
            Real factor = (Real)(_nominalHeight) /
                          (Real)(_nominalWidth);

            _width = anchoredDimension;
            _height = anchoredDimension * factor;
        }
    }
    SetRect(&_rect, 0,0, _width, _height);

    _membersReady = TRUE;
    _bboxReady = TRUE;
}

void
CachedImage::InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev)
{
    Assert(_membersReady && "members not initialized in CachedImage::InitIntoSurface");
    Assert((ddSurf->Width() >= GetPixelWidth()) && "given surf wrong size!");
    Assert((ddSurf->Height() >= GetPixelHeight()) && "given surf wrong size!");

    bool bScaled = false;
    Image *imgToUse;
    
    if (_width != _nominalWidth || _height != _nominalHeight) {

        // Rescale the image so all of it will fit into the surface
        // it's being rendered onto.
        Real wscale = ((Real)_width) / ((Real)_nominalWidth);
        Real hscale = ((Real)_height) / ((Real)_nominalHeight);
        Transform2 *xf = ScaleRR(wscale, hscale);
        
        // This will disappear after we render it so we don't hang on to
        // any references.
        imgToUse = NEW Transform2Image(xf, _image);
        bScaled = true;
        
    } else {
        imgToUse = _image;    
    }

#if _DEBUG

    if (IsTagEnabled(tagCachedImagesVisuals)) {
        Bbox2 box2 = imgToUse->BoundingBox();

        // Make an 'X' inside a box over the image
        Point2 pts[8];
        pts[0] = box2.min;
        pts[1].Set(box2.min.x, box2.max.y);
        pts[2] = box2.max;
        pts[3].Set(box2.max.x, box2.min.y);
        pts[4] = pts[0];
        pts[5] = pts[2];
        pts[6] = pts[1];
        pts[7] = pts[3];
        
        Path2 *path = InternalPolyLine2(8, pts);
        

        Color *col = NEW Color(1, 1, 1);
        LineStyle *ls = LineColor(col, defaultLineStyle);

        Image *border = DrawPath(ls, path);
        imgToUse = Overlay(border, imgToUse);        
    }
    
#endif

    
    DirectDrawImageDevice *ddDev =
        SAFE_CAST(DirectDrawImageDevice *, dev);

    Bbox2 origbox;
    if(bScaled) {
        // save off orig bbox & switch
        origbox = ddSurf->Bbox();
        Real sizeh = (_height / GetResolution()) /2;
        Real sizew = (_width  / GetResolution()) /2;
        ddSurf->SetBbox(-sizew, -sizeh, sizew, sizeh);
    }
    ddDev->RenderImageOnDDSurface(imgToUse, ddSurf); // showme(ddSurf)
    if(bScaled) {
        // reset orig bbox if we switched it.
        ddSurf->SetBbox(origbox);
    }
}

Bool
CachedImage::DetectHit(PointIntersectCtx & ctx)
{
    return _image->DetectHit(ctx);
}

/* Render: if any dimension is being scaled up, just rerender the
   underlying image.

   This avoids pixellation problems.

   TODO: cache the re-render image at the appropriate resolution.
*/

void
CachedImage::Render(GenericDevice& dev)
{
    DirectDrawImageDevice &idev = SAFE_CAST(DirectDrawImageDevice &, dev);

    // if there's tiny scale or any complex transforms on the cached
    // image, render natively.
    
    if (    idev.IsScale(1.00000001) ||
         ! (idev.GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)) ) {        

        _image->Render(dev);

    } else {
        DiscreteImage::Render(dev);
    }
}

void
CachedImage::DoKids(GCFuncObj proc)
{
    DiscreteImage::DoKids(proc);
    (*proc)(_image);
}

void CachedImage::CleanUp()
{
    DiscreteImageGoingAway(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\colorkeyedimage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

*******************************************************************************/


#include "headers.h"

#include <privinc/imagei.h>
#include <privinc/ColorKeyedImage.h>

ColorKeyedImage::
ColorKeyedImage(Image *underlyingImage, Color *clrKey) :
     AttributedImage(underlyingImage),
     _colorKey(clrKey)
{
}

void ColorKeyedImage::
Render(GenericDevice& dev)
{
    ImageDisplayDev &idev = SAFE_CAST(ImageDisplayDev &, dev);

    bool wasSet = idev.ColorKeyIsSet();
    Color *oldKey;
    if( wasSet ) {
        oldKey = idev.GetColorKey();
    }

    // set my key
    idev.SetColorKey( GetColorKey() );

    //
    // RENDER
    //
    idev.RenderColorKeyedImage(this);

    // unstash
    if( wasSet ) {
        idev.SetColorKey( oldKey );
    } else {
        idev.UnsetColorKey();
    }        
}

void ColorKeyedImage::
DoKids(GCFuncObj proc)
{
    AttributedImage::DoKids(proc);
    (*proc)( _colorKey );
}

extern Color *emptyColor;

Image *ConstructColorKeyedImage( Image *image, Color *clrKey )
{
    if(clrKey == emptyColor) {
        return image;
    } else {
        return NEW ColorKeyedImage( image, clrKey );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\geom\txtrgeom.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for texturing geometry with DAImages and RMTexture
    handles.

*******************************************************************************/


#include "headers.h"

#include "privinc/dispdevi.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"

#include "privinc/colori.h"
#include "privinc/ddrender.h"
#include "privinc/lighti.h"
#include "privinc/soundi.h"
#include "privinc/probe.h"
#include "privinc/opt.h"
#include "privinc/comutil.h"
#include "privinc/server.h"
#include "backend/perf.h"
#include "backend/bvr.h"
#include "fullattr.h"

Geometry *
NewRMTexturedGeom(RMTextureBundle texInfo, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);

    // Don't worry about releasing a current texture if one is
    // there... nothing is being held onto.

    f->AppendFlag(GEOFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT);

    f->SetAttr(FA_TEXTURE);
    f->SetMostRecent(FA_TEXTURE); // for blend
    f->_textureBundle._nativeRMTexture = true;
    f->_textureBundle._rmTexture = texInfo;

    return f;
}

AxAValue
ConstHelper(AxAValue constGeoVal, RMTextureBundle *texInfo)
{
    AxAValue result;

    if (constGeoVal) {

        Geometry *constGeo = SAFE_CAST(Geometry *, constGeoVal);
        result = NewRMTexturedGeom(*texInfo, constGeo);

    } else {

        result = NULL;

    }

    return result;
}

class RMTexturedGeomBvr : public DelegatedBvr {
  friend class RMTexturedGeomPerf;

  public:
    RMTexturedGeomBvr(Bvr             geometry,
                      GCIUnknown     *data,
                      IDXBaseObject  *baseObj,
                      RMTextureBundle texInfo)
    : DelegatedBvr(geometry)
    {
        _data = data;
        _texInfo = texInfo;

        // Don't maintain an internal reference.  The guy we call
        // will.
        _baseObj = baseObj;
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        // Can never assume we're fully const, since the texture can
        // change outside of DA's control.
        return NULL;
    }

    virtual Perf _Perform(PerfParam& p);

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_data);
    }

  private:
    GCIUnknown             *_data;
    RMTextureBundle         _texInfo;
    IDXBaseObject          *_baseObj;
};

class RMTexturedGeomPerf : public DelegatedPerf {
  public:
    RMTexturedGeomPerf(Perf geo, RMTexturedGeomBvr *bvr)
    : DelegatedPerf(geo), _bvr(bvr)
    {
        if (_bvr->_baseObj) {
            HRESULT hr =
                _bvr->_baseObj->GetGenerationId(&_previousTextureAge);

            Assert(SUCCEEDED(hr));
        }
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_bvr);
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        // Can never assume we're fully const, since the texture can
        // change outside of DA's control.
        return NULL;
    }

    virtual AxAValue _GetRBConst(RBConstParam& p) {

        // Treat like a switcher, and we'll trigger an event when it
        // changes.
        //
        // TODO: This is probably heavier weight than it
        // needs to be, since we're going to generate an event each
        // time the texture changes, invalidating the entire view!!!
        
        p.AddChangeable(this);
        return ConstHelper(_base->GetRBConst(p), &_bvr->_texInfo);
    }

    bool CheckChangeables(CheckChangeablesParam &ccp) {
        
        IDXBaseObject *bo = _bvr->_baseObj;
        
        if (bo) {
            ULONG currAge;
            HRESULT hr = bo->GetGenerationId(&currAge);
            Assert(SUCCEEDED(hr));

            if (currAge != _previousTextureAge) {

                // Tell the current view that an event has happened to
                // it.

                TraceTag((tagSwitcher,
                          "Texture changed for view 0x%x, txtrGeom 0x%x - %d -> %d",
                          IntGetCurrentView(),
                          _bvr,
                          _previousTextureAge,
                          currAge));
                
                _previousTextureAge = currAge;

                return true;
            }
        }

        return false;
    }
    
    virtual AxAValue _Sample(Param& p) {

        Geometry *sampledGeo =
            SAFE_CAST(Geometry *, _base->Sample(p));

        return NewRMTexturedGeom(_bvr->_texInfo, sampledGeo);
    }

  private:
    RMTexturedGeomBvr *_bvr;
    ULONG              _previousTextureAge;
};

Perf
RMTexturedGeomBvr::_Perform(PerfParam& p)
{
    return NEW RMTexturedGeomPerf(::Perform(_base, p), this);
}


Bvr
applyD3DRMTexture(Bvr geo, IUnknown *texture)
{
    HRESULT hr;

    if (texture == NULL) {
        RaiseException_UserError(E_FAIL, IDS_ERR_GEO_BAD_RMTEXTURE);
    }

    RMTextureBundle texInfo;

    
    hr = texture->QueryInterface(IID_IDirect3DRMTexture3,
                                 (void **)&texInfo._texture3);

    if (SUCCEEDED(hr)) {
        texInfo._isRMTexture3 = true;

        // Don't want the extra reference.
        texInfo._texture3->Release();

    } else {

        texInfo._isRMTexture3 = false;
        hr = texture->QueryInterface(IID_IDirect3DRMTexture,
                                     (void **)&texInfo._texture1);
        if (FAILED(hr)) {
            // Not a texture at all
            RaiseException_UserError(E_FAIL, IDS_ERR_GEO_BAD_RMTEXTURE);
        }

        // Don't want the extra reference
        texInfo._texture1->Release();
    }

    GCIUnknown *gciunk = NEW GCIUnknown(texture);

    DAComPtr<IDXBaseObject> baseObj;
    hr = texture->QueryInterface(IID_IDXBaseObject,
                                 (void **)&baseObj);

    if (FAILED(hr)) {
        // Should happen automatically, but doesn't always (RM for
        // instance doesn't do this as a matter of course.)
        baseObj = NULL;
    }

    // We'll make a more intelligent distinction between texture1
    // and texture3 in the future.
    if (texInfo._isRMTexture3) {
        texInfo._voidTex = texInfo._texture3;
    } else {
        texInfo._voidTex = texInfo._texture1;
    }

    texInfo._gcUnk = gciunk;

    return NEW RMTexturedGeomBvr(geo, gciunk, baseObj, texInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\dxxf.cpp ===
/*******************************************************************************
Copyright (c) 1997-1998 Microsoft Corporation.  All rights reserved.

    Support the hosting of DXTransforms from inside of DirectAnimation.

*******************************************************************************/

#include "headers.h"
#include "privinc/imagei.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "backend/timeln.h"
#include "privinc/dxxf.h"
#include "privinc/bbox2i.h"
#include "privinc/ddsurf.h"
#include "privinc/ddsimg.h"
#include "privinc/dddevice.h"
#include "privinc/server.h"
#include "privinc/ddrender.h"
#include "privinc/viewport.h"
#include "privinc/overimg.h"
#include "privinc/rmvisgeo.h"
#include "privinc/d3dutil.h"
#include "privinc/dxmatl.h"
#include "privinc/comutil.h"
#include "privinc/opt.h"
#include "privinc/meshmaker.h"
#include <d3drmvis.h>
#include <dxterror.h>


DeclareTag(tagDXTransformPerPixelAlphaOutputOff, "DXTransforms", "Turn off output per pixel alpha support");

DeclareTag(tagDXTransformTracePick, "DXTransforms", "Trace picking");

// Forward decl.
// If necessary, do a Setup.  Do an Execute.  In all cases, fill in
// outputValue with the output for this.
HRESULT
DXXFSetupAndExecute(Bvr bvr,                   /* in */
                    IUnknown **newInputArray,  /* in */
                    REFIID     outputIID,      /* in */
                    DirectDrawViewport *viewport, /* in - img only */
                    int        requestedWidth, /* in - img only */
                    int        requestedHeight, /* in - img only */
                    bool       invokedAsExternalVisual, /* in */
                    bool       executeRequired, /* in */
                    void     **outputValue);   /* out */

// All of these MAX values are for programming convenience for the
// time being (and are reasonable maximum values).  When it becomes a
// priority, they should be made more dynamic.
#define MAX_INPUTS_TO_CACHE 5
#define MAX_INPUTS          10
#define MAX_PARAM_BVRS      20


void GetRenderDimensions(Image *im,
                         unsigned short *pWidth,
                         unsigned short *pHeight)
{
    if (im->CheckImageTypeId(DISCRETEIMAGE_VTYPEID)) {
                
        DiscreteImage *discImg =
            SAFE_CAST(DiscreteImage *, im);

        *pWidth = discImg->GetPixelWidth();
        *pHeight = discImg->GetPixelHeight();
                
    } else {

        short w, h;
        im->ExtractRenderResolution(&w, &h, true);
        if (w != -1) {

            *pWidth = w;
            *pHeight = h;
                    
        } else {

            *pWidth = DEFAULT_TEXTURE_WIDTH;
            *pHeight = DEFAULT_TEXTURE_HEIGHT;

        }
    }
}

class GeometryInputBundle {
  public:
    GeometryInputBundle() {
        _geo = NULL;
        _creationID = 0;
    }

    void Validate(Geometry *geo,
                  DirectDrawImageDevice *dev)
    {
        if (_geo != geo ||
            _creationID != geo->GetCreationID() ||
            _creationID == PERF_CREATION_ID_BUILT_EACH_FRAME) {

            _geo = geo;

            _mb.Release();
            DumpGeomIntoBuilder(geo,
                                dev,
                                &_mb);

            _creationID = geo->GetCreationID();
      
        } else {

            // TODO: What to do about generation id's if the original
            // visuals that contributed are changing?
      
        }
    
    }

    IUnknown *GetUnknown() {
        _mb->AddRef();
        return _mb;
    }
    
  protected:
    Geometry                         *_geo;
    long                              _creationID;
    DAComPtr<IDirect3DRMMeshBuilder3> _mb;
};

class ImageAsDXSurfaceBundle {
  public:
    ImageAsDXSurfaceBundle() {
        _im = NULL;
        _lastSurfFromPool = false;
    }

    void Validate(Image *im,
                  DirectDrawImageDevice *dev,
                  IDXSurfaceFactory *f,
                  SurfacePool *sourcePool,
                  ULONG inputNumber) {

        if (im != _im ||
            im->GetCreationID() != _creationID ||
            _creationID == PERF_CREATION_ID_BUILT_EACH_FRAME) {

            // Not the same as last time.
            
            _im = im;
            _creationID = _im->GetCreationID();

            GetRenderDimensions(im, &_w, &_h);
            
            DWORD ck;
            bool  junk1;
            bool  junk2;
            bool  doFitToDimensions = true;

            if (_ddsurface && _lastSurfFromPool) {
                // Put old surface back on pool to be picked up
                // again. 
                sourcePool->AddSurface(_ddsurface);
            }
                    
            DDSurfPtr<DDSurface> dds;

            DDSurface *result =
                dev->RenderImageForTexture(im, _w, _h,
                                           &ck, &junk1, junk2,
                                           doFitToDimensions,
                                           sourcePool,
                                           NULL,
                                           _ddsurface,
                                           &_lastSurfFromPool,
                                           &dds,
                                           false);

            // If *either* the DDSurface is the same, or the
            // underlying IDirectDrawSurface is the same, just
            // increment the generation id.  Note that the
            // IDirectDrawSurface might be the same without the
            // ddsurface being the same if someone uses a new
            // DDSurface with the same underlying IDirectDrawSurface.
            // Trident3D does this with HTML textures and animated
            // GIFs.
            
            if (dds == _ddsurface ||
                (_ddsurface &&
                 (dds->IDDSurface_IUnk() == _ddsurface->IDDSurface_IUnk()))) { 

                // Only relevant if dds==_ddsurface
                Assert(dds->IDDSurface_IUnk() ==
                       _ddsurface->IDDSurface_IUnk());

                if (dds != _ddsurface) {
                    // Underlying IDirectDrawSurface's are the same,
                    // but ddsurf's aren't, so release the old and keep
                    // the new..
                    _ddsurface.Release();
                    _ddsurface = dds;
                }
                
                // depending on the nature of the surface pools, this
                // may be the same surface used as last time.  In this
                // case, that's fine, and we bump the gen id on the
                // dxsurface.
                _dxsurf->IncrementGenerationId(true);
                
            } else {

                // otherwise, replace members with new ones.
                
                _ddsurface.Release();
                _ddsurface = dds;

                // This is HACK and should be pulled once we correct the TODO in ddsurf.cpp _INIT(
                if(dds->ColorKeyIsValid()) {
                    DWORD key = dds->ColorKey();
                    dds->UnSetColorKey();
                    dds->SetColorKey(key);
                }
                // end of HACK

                _iddsurf.Release();
                _iddsurf = dds->IDDSurface();

                _dxsurf.Release();
                HRESULT hr = f->CreateFromDDSurface(_iddsurf,
                                                    NULL,
                                                    0,
                                                    NULL,
                                                    IID_IDXSurface,
                                                    (void **)&_dxsurf);

                if (SUCCEEDED(hr)) {
                    // Label with input number
                    hr = _dxsurf->SetAppData(inputNumber);
                }
                    
                if (FAILED(hr)) {
                    RaiseException_InternalError("Creation of DXSurf failed");
                }

            }

        }
    }

    IUnknown *GetUnknown() {
        _dxsurf->AddRef();
        return _dxsurf;
    }

    void GetDimensions(unsigned short *pW, unsigned short *pH) {
        *pW = _w;
        *pH = _h;
    }

    Image                        *_im;
    long                          _creationID;
    DDSurfPtr<DDSurface>          _ddsurface;
    DAComPtr<IDirectDrawSurface>  _iddsurf;
    DAComPtr<IDXSurface>          _dxsurf;
    bool                          _lastSurfFromPool;
    unsigned short                _w, _h;
};

class InputBundle {
  public:
    // Note that ideally these would be a union, but we can't get that
    // to work, presumably because they contain DAComPtr's which have
    // destructors, and that would be ambiguous.  In the meantime,
    // just keep both around.  Doesn't waste too much space.
    GeometryInputBundle    _geoBundle;
    ImageAsDXSurfaceBundle _imgBundle;
};

class ApplyDXTransformBvrImpl;

class MyDeletionNotifier : public SurfacePool::DeletionNotifier {
  public:
    MyDeletionNotifier(ApplyDXTransformBvrImpl &bvr) : _bvr(bvr) {}
    
    void Advise(SurfacePool *pool);

  protected:
    ApplyDXTransformBvrImpl &_bvr;
};

class ApplyDXTransformBvrImpl : public BvrImpl {
  public:
    ApplyDXTransformBvrImpl(IDXTransform *theXf,
                            IDispatch *theXfAsDispatch,
                            LONG numInputs,
                            Bvr *inputBvrs,
                            Bvr  evaluator);

    ~ApplyDXTransformBvrImpl();

    void Init();

    // Custom methods for this subclass of BvrImpl
    HRESULT AddBehaviorProperty(BSTR property,
                                Bvr  bvrToAdd);

    // Standard methods
    virtual Perf _Perform(PerfParam& p);
    virtual void _DoKids(GCFuncObj proc);
    virtual DWORD GetInfo(bool recalc);
        

    virtual DXMTypeInfo GetTypeInfo () { return _outputType; }
    virtual AxAValue GetConst(ConstParam & cp);

    SurfacePool *GetSurfacePool(DirectDrawImageDevice *dev) {
        
        if (!_surfPool) {
            _surfPool = dev->_freeTextureSurfacePool;
            _surfPool->RegisterDeletionNotifier(&_poolDeletionNotifier);
        }

        if (dev->_freeTextureSurfacePool != _surfPool) {
            RaiseException_InternalError(
                "Uggh!! Transforms can only currently be used on one device");
        }
        
        return _surfPool;
    }

    // Keeping all this member data public, since it's only used by
    // code in this file.
    
    DAComPtr<IDXTransform>              _theXf;
    DAComPtr<IDispatch>                 _theXfAsDispatch;
    DAComPtr<IDXEffect>                 _theXfAsEffect;
    DAComPtr<IDirect3DRMExternalVisual> _theXfAsExternalVisual;
    DAComPtr<IDXSurfacePick>            _theXfAs2DPickable;
    
    DAComPtr<IDirect3DRMFrame3>         _framedExternalVisual;
    
    LONG                   _numInputs;
    Bvr                   *_inputBvrs;
    DXMTypeInfo            _inputTypes[MAX_INPUTS];
    DXMTypeInfo            _outputType;

    InputBundle            _inputBundles[MAX_INPUTS];
    
    Bvr                    _evaluator;
    DWORD                  _miscFlags;
    bool                   _miscFlagsValid;
    IUnknown              *_cachedInputs[MAX_INPUTS_TO_CACHE];
    IUnknown              *_cachedOutput;
    bool                   _neverSetup;

    // Only one of these will be valid, depending on the output type
    // of the behavior.  Note that we *don't* keep a reference for
    // this guy, since we know that _cachedOutput has one.
    union {
        IDirect3DRMMeshBuilder3 *_cachedOutputAsBuilder;
        // Put other type-specific possibilities here as they're
        // needed.  
    };

    // For image producing transforms only
    short                  _cachedSurfWidth;
    short                  _cachedSurfHeight;
    DDSurfPtr<DDSurface>   _cachedDDSurf;

    // Lists additional behaviors being used as parameters.
    LONG                   _numParams;
    DISPID                 _paramDispids[MAX_PARAM_BVRS];
    Bvr                    _paramBvrs[MAX_PARAM_BVRS];
    ULONG                  _previousAge;

    // Just need at most one of these.  We protect construction and
    // destruction of this with a critical section.
    IDXTransformFactory *_transformFactory;
    IDXSurfaceFactory   *_surfaceFactory;
    DWORD                  _info;

    SurfacePool       *_surfPool;
    MyDeletionNotifier _poolDeletionNotifier;
    bool               _surfPoolHasBeenDeleted;

  protected:
    // For things we really know aren't needed beyond this class...

    void ValidateInputs(bool *pInvolvesGeometry,
                        bool *pInvolvesImage);
    void InitializeTransform(bool involvesGeometry,
                             bool involvesImage);
    void QueryForAdditionalInterfaces();

};


void
MyDeletionNotifier::Advise(SurfacePool *pool)
{
    // Surface pool is going away... mark it as such in the behavior.
    // Note that the surfacemgr crit sect is held here.
    Assert(_bvr._surfPool == pool);
    _bvr._surfPoolHasBeenDeleted = true;
    _bvr._surfPool = NULL;

    // Go through and release out the ddsurf ptrs since the holding pool
    // is gone, and thus the surfaces are too.  They won't need to be
    // accessed again.  If we delayed release until the image bundle
    // went away, then the ddraw stuff would be gone, and we'd crash. 
    for (int i = 0; i < _bvr._numInputs; i++) {
        _bvr._inputBundles[i]._imgBundle._ddsurface.Release();
    }
    
}



////////////// Input processing utility /////////////////

IUnknown **
ProcessInputs(ApplyDXTransformBvrImpl &xf,
              AxAValue                *vals,
              DirectDrawImageDevice   *imgDev)
{
    IUnknown **rawInputs = THROWING_ARRAY_ALLOCATOR(LPUNKNOWN, xf._numInputs);

    for (int i = 0; i < xf._numInputs; i++) {
        if (vals[i] == NULL) {
      
            rawInputs[i] = NULL;
      
        } else {

            if (xf._inputTypes[i] == GeometryType) {
                Geometry *geo = SAFE_CAST(Geometry *, vals[i]);
                xf._inputBundles[i]._geoBundle.Validate(geo,
                                                        imgDev);

                rawInputs[i] =
                    xf._inputBundles[i]._geoBundle.GetUnknown();
                
            } else if (xf._inputTypes[i] == ImageType) {
                
                Image *im = SAFE_CAST(Image *, vals[i]);

                xf._inputBundles[i]._imgBundle.Validate(
                    im,
                    imgDev,
                    xf._surfaceFactory,
                    xf.GetSurfacePool(imgDev),
                    i+1);

                rawInputs[i] = xf._inputBundles[i]._imgBundle.GetUnknown();

#if _DEBUG
                if ((IsTagEnabled(tagDXTransformsImg0) && i == 0) ||
                    (IsTagEnabled(tagDXTransformsImg1) && i == 1)) {

                    showme2(xf._inputBundles[i]._imgBundle._iddsurf);
                    
                }
#endif _DEBUG           

            }
        }
    }

    // Finally, return our successful output
    return rawInputs;
}

////////////// Bounds calculation utility /////////////////

// Calculate bounds of output (either 2D or 3D) from bounds of inputs
// by calling MapBoundsIn2Out.
void
CalcBounds(ApplyDXTransformBvrImpl &xf, // input
           AxAValue                *vals, // input
           DXBNDS                  *pOutputBounds)
{    
    DXBNDS inputBounds[MAX_INPUTS];

    bool haveAGeometryInput = false;

        // Zero the array of bounds information...
    ZeroMemory(inputBounds, sizeof(inputBounds[0]) * MAX_INPUTS);

    for (int i = 0; i < xf._numInputs; i++) {

        if (xf._inputTypes[i] == GeometryType) {

            haveAGeometryInput = true;

            inputBounds[i].eType = DXBT_CONTINUOUS;
            DXCBND *bnd = inputBounds[i].u.C;

            if (vals[i]) {
                Geometry *geo = SAFE_CAST(Geometry *, vals[i]);
                Bbox3 *result = geo->BoundingVol();
                Point3Value& pMin = result->min;
                Point3Value& pMax = result->max;
                
                // The following will be the case if there's an empty
                // geometry. 
                if (pMin.x > pMax.x || pMin.y > pMax.y || pMin.z > pMax.z) {

                    bnd[0].Min = bnd[1].Min =
                        bnd[2].Min = bnd[0].Max =
                        bnd[1].Max = bnd[2].Max = 0.0;
                
                } else {
                
                    bnd[0].Min = pMin.x;
                    bnd[1].Min = pMin.y;
                    bnd[2].Min = pMin.z;
                    bnd[0].Max = pMax.x;
                    bnd[1].Max = pMax.y;
                    bnd[2].Max = pMax.z;
                
                }
                
            } else {
                memset(bnd, 0, sizeof(DXCBND)*4);
            }
                
        } else if (xf._inputTypes[i] == ImageType) {

            // Give image resolution as discrete pixels.
            inputBounds[i].eType = DXBT_DISCRETE;
            DXDBND *bnd = inputBounds[i].u.D;

            if (vals[i]) {
                
                bnd[0].Min = 0;
                bnd[1].Min = 0;

                Image *im = SAFE_CAST(Image *, vals[i]);
                unsigned short w, h;
                GetRenderDimensions(im, &w, &h);
                bnd[0].Max = w;
                bnd[1].Max = h;

            } else {
                memset(bnd, 0, sizeof(DXDBND)*4);
            }

        }
    }

        
    HRESULT hr =
        TIME_DXXFORM(
            xf._theXf->MapBoundsIn2Out(inputBounds,
                                       xf._numInputs,
                                       0,
                                       pOutputBounds));

    // Aargh!! This is only here because not all xforms report their
    // bounds.
    if (FAILED(hr)) {
    
        // TODO: HACKHACK temporary, last minute beta1 workaround for
        // 19448 until DXTransforms actually implement MapBoundsIn2Out
        // correctly.  Just take input bounds, and scale up by some
        // factor. 

        // Need to zero out the structure to take care of values we might
        // not set.
        ZeroMemory(pOutputBounds, sizeof(DXBNDS));

        if (haveAGeometryInput && xf._numInputs == 1) {
        
            const float hackScaleAmt = 10.0;
            (*pOutputBounds).eType = DXBT_CONTINUOUS;
            DXCBND *outBnd = (*pOutputBounds).u.C;
            DXCBND *inBnd = inputBounds[0].u.C;

            double mid, half, halfScaled;
        
            mid = inBnd[0].Min + (inBnd[0].Max - inBnd[0].Min) / 2;
            half = inBnd[0].Max - mid;
            halfScaled = half * hackScaleAmt;
            outBnd[0].Min = mid - halfScaled;
            outBnd[0].Max = mid + halfScaled;
        
            mid = inBnd[1].Min + (inBnd[1].Max - inBnd[1].Min) / 2;
            half = inBnd[1].Max - mid;
            halfScaled = half * hackScaleAmt;
            outBnd[1].Min = mid - halfScaled;
            outBnd[1].Max = mid + halfScaled;
        
            mid = inBnd[2].Min + (inBnd[2].Max - inBnd[2].Min) / 2;
            half = inBnd[2].Max - mid;
            halfScaled = half * hackScaleAmt;
            outBnd[2].Min = mid - halfScaled;
            outBnd[2].Max = mid + halfScaled;
        
        } else {

            // If not a single input geo, just make up some bounds
            (*pOutputBounds).eType = DXBT_CONTINUOUS;
            DXCBND *outBnd = (*pOutputBounds).u.C;
            outBnd[0].Min = outBnd[1].Min = outBnd[2].Min = -10.0;
            outBnd[0].Max = outBnd[1].Max = outBnd[2].Max =  10.0;
            //RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
        }
    }
        
}
                
const Bbox2
BNDSToBBox2(DXBNDS &bnds)
{
    double minx, maxx, miny, maxy;
    DXCBND *cbnd;
    DXDBND *dbnd;
            
    switch (bnds.eType) {

      case DXBT_CONTINUOUS:
        cbnd = bnds.u.C;
        minx = cbnd[0].Min;
        miny = cbnd[1].Min;

        maxx = cbnd[0].Max;
        maxy = cbnd[1].Max;
        break;

      case DXBT_DISCRETE:

        {
            // When the bounds are discrete, assume they have their origin
            // at the lower left and are in pixels.  In this case, we need
            // to convert to meters and center.
            dbnd = bnds.u.D;
            Assert(dbnd[0].Min == 0.0);
            Assert(dbnd[1].Min == 0.0);

            maxx = dbnd[0].Max;
            maxy = dbnd[1].Max;

            Real twiceRes = 2.0 * ::ViewerResolution();
            maxx /= twiceRes;
            maxy /= twiceRes;

            minx = -maxx;
            miny = -maxy;
        }
        
        break;

      default:
        RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
        break;
    }

    return Bbox2(minx, miny, maxx, maxy);
}

Bbox3 *
BNDSToBBox3(DXBNDS &bnds)
{
    double minx, maxx, miny, maxy, minz, maxz;
    DXCBND *cbnd;
    DXDBND *dbnd;
            
    switch (bnds.eType) {

      case DXBT_CONTINUOUS:
        cbnd = bnds.u.C;
        minx = cbnd[0].Min;
        miny = cbnd[1].Min;
        minz = cbnd[2].Min;

        maxx = cbnd[0].Max;
        maxy = cbnd[1].Max;
        maxz = cbnd[2].Max;
        break;

      case DXBT_DISCRETE:

        {
            // When the bounds are discrete, assume they have their origin
            // at the lower left and are in pixels.  In this case, we need
            // to convert to meters and center.
            dbnd = bnds.u.D;
            Assert(dbnd[0].Min == 0.0);
            Assert(dbnd[1].Min == 0.0);
            Assert(dbnd[2].Min == 0.0);

            maxx = dbnd[0].Max;
            maxy = dbnd[1].Max;
            maxz = dbnd[2].Max;

            Real twiceRes = 2.0 * ::ViewerResolution();
            maxx /= twiceRes;
            maxy /= twiceRes;
            maxz /= twiceRes;

            minx = -maxx;
            miny = -maxy;
            minz = -maxz;
        }
        
        break;

      default:
        RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
        break;
    }

    return NEW Bbox3(minx, miny, minz, maxx, maxy, maxz);
}

void
CalcBoundsToBbox2(ApplyDXTransformBvrImpl &xf, // input
                 AxAValue                *vals, // input
                 Bbox2     &bbox2Out)  // output
{
    DXBNDS outputBounds;
    CalcBounds(xf, vals, &outputBounds);
    bbox2Out = BNDSToBBox2(outputBounds);
}

void
CalcBoundsToBbox3(ApplyDXTransformBvrImpl &xf, // input
                 AxAValue                *vals, // input
                 Bbox3     **ppBbox3Out)  // output
{
    DXBNDS outputBounds;
    CalcBounds(xf, vals, &outputBounds);
    *ppBbox3Out = BNDSToBBox3(outputBounds);
}

////////////// ApplyDXTransformGeometry Subclass /////////////////

class CtxAttrStatePusher {
  public:
    CtxAttrStatePusher(GeomRenderer &dev) : _dev(dev) {
        _dev.PushAttrState();
    }

    ~CtxAttrStatePusher() {
        _dev.PopAttrState();
    }

  protected:
    GeomRenderer &_dev;
};

class ApplyDXTransformGeometry : public Geometry {
  public:

    ApplyDXTransformGeometry(ApplyDXTransformBvrImpl *xfBvr,
                             AxAValue                *vals) {
        
        _xfBvr = xfBvr;
        _vals = vals;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_xfBvr);
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            (*proc)(_vals[i]);
        }
    }

    // Collect up all the lights, sounds, and textures from the input
    // geometries.
    void  CollectLights(LightContext &context) {
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            if (_xfBvr->_inputTypes[i] == GeometryType) {
                Geometry *g = SAFE_CAST(Geometry *, _vals[i]);
                g->CollectLights(context);
            }
        }
    }

    void  CollectSounds(SoundTraversalContext &context) {
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            if (_xfBvr->_inputTypes[i] == GeometryType) {
                Geometry *g = SAFE_CAST(Geometry *, _vals[i]);
                g->CollectSounds(context);
            }
        }
    }

    void  CollectTextures(GeomRenderer &device) {
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            if (_xfBvr->_inputTypes[i] == GeometryType) {
                Geometry *g = SAFE_CAST(Geometry *, _vals[i]);
                g->CollectTextures(device);
            }
        }
    }
    
    void  RayIntersect (RayIntersectCtx &context) {

        if (context.LookingForSubmesh()) {

            // Picking into the inputs of the transform
            for (int i = 0; i < _xfBvr->_numInputs; i++) {
                if (_xfBvr->_inputTypes[i] == GeometryType) {
                    Geometry *geo =
                        SAFE_CAST(Geometry *, _vals[i]);

                    if (geo) {
                        geo->RayIntersect(context);
                    }
                    
                }
            }
            
        } else if (_xfBvr->_cachedOutput) {
            
            // Do this only if our bvr's output is valid.
            context.SetDXTransformInputs(_xfBvr->_numInputs,
                                         _vals,
                                         this);

            context.Pick(_xfBvr->_cachedOutputAsBuilder);
            
            context.SetDXTransformInputs(0, NULL, NULL);

        }
        
    }

    // Produces a printed representation on the debugger.
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "ApplyDXTransformGeometry";
    }
#endif

    Bbox3 *BoundingVol() {

        // For transforms that take all geometries in, create empty
        // meshbuilder inputs and do a single setup/execute if we've
        // never been setup before.  Otherwise, the transforms may not
        // be able to compute the bounds correctly.
        if (_xfBvr->_neverSetup) {
            
            bool allGeo = true;
            int i;
            for (i = 0; i < _xfBvr->_numInputs && allGeo; i++) {
                if (_xfBvr->_inputTypes[i] != GeometryType) {
                    allGeo = false;
                }
            }

            IUnknown *rawInputs[MAX_INPUTS];
            
            if (allGeo) {
                for (i = 0; i < _xfBvr->_numInputs; i++) {
                    IDirect3DRMMeshBuilder3 *mb;
                    TD3D(GetD3DRM3()->CreateMeshBuilder(&mb));
                    TD3D(mb->QueryInterface(IID_IUnknown,
                                            (void **)&rawInputs[i]));
                    RELEASE(mb);
                }

                IDirect3DRMMeshBuilder3 *outputBuilder;
                
                HRESULT hr =
                    DXXFSetupAndExecute(_xfBvr,
                                        rawInputs,
                                        IID_IDirect3DRMMeshBuilder3,
                                        NULL, 0, 0,
                                        false,
                                        false,
                                        (void **)&outputBuilder);

                for (i = 0; i < _xfBvr->_numInputs; i++) {
                    RELEASE(rawInputs[i]);
                }

                RELEASE(outputBuilder);
            }
        }
        
        Bbox3 *pBbox3;
        CalcBoundsToBbox3(*_xfBvr, _vals, &pBbox3);
        return pBbox3;
    }

    void Render(GenericDevice& genDev) {

        GeomRenderer& geomRenderer = SAFE_CAST(GeomRenderer&, genDev);

        if (geomRenderer.CountingPrimitivesOnly_DoIncrement()) {
            return;
        }
        
        ApplyDXTransformBvrImpl& x = *_xfBvr;
        DirectDrawImageDevice& imgDev = geomRenderer.GetImageDevice();

        // Do things differently based on number and types of inputs.
        IUnknown **rawInputs = ProcessInputs(x, _vals, &imgDev);

        bool topOfChain = !geomRenderer.IsMeshmaker();
        bool invokeAsExternalVisual =
            x._theXfAsExternalVisual && topOfChain;

        if (rawInputs) {
            IDirect3DRMMeshBuilder3 *outputBuilder;

            HRESULT hr = DXXFSetupAndExecute(_xfBvr,
                                             rawInputs,
                                             IID_IDirect3DRMMeshBuilder3,
                                             NULL, 0, 0,
                                             invokeAsExternalVisual,
                                             true,
                                             (void **)&outputBuilder);


            for (int i = 0; i < x._numInputs; i++) {
                RELEASE(rawInputs[i]);
            }
                
            delete [] rawInputs;

            if (SUCCEEDED(hr)) {
                if (invokeAsExternalVisual) {

                    // If we haven't put the extvis in a frame yet,
                    // then do so, and keep it around.  Otherwise, RM
                    // ends up re-initializing the extvis all the
                    // time. 
                    if (!x._framedExternalVisual) {
                        
                        TD3D(GetD3DRM3()->
                               CreateFrame(NULL,
                                           &x._framedExternalVisual));

                        TD3D(x._framedExternalVisual->
                               AddVisual(x._theXfAsExternalVisual));
                        
                    }

                    
                    // Submit the external visual to the renderer directly.

                    RM3FrameGeo *extVisGeo =
                        NEW RM3FrameGeo (x._framedExternalVisual);

                    geomRenderer.Render(extVisGeo);

                    extVisGeo->CleanUp();    // Done with the frame geo.
                    
                } else {
                    geomRenderer.RenderMeshBuilderWithDeviceState(outputBuilder);
                    RELEASE(outputBuilder);
                }
            } else {
                RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
            }
          
        }
    }

    VALTYPEID GetValTypeId() { return DXXFGEOM_VTYPEID; }
    
  protected:
    ApplyDXTransformBvrImpl *_xfBvr;
    AxAValue                *_vals;
};

////////////// ApplyDXTransformImage Subclass /////////////////



class ApplyDXTransformImage : public Image {


  public:
    ApplyDXTransformImage(ApplyDXTransformBvrImpl *xfBvr,
                          AxAValue                *vals) {
        
        _xfBvr = xfBvr;
        _vals = vals;
    }

    virtual void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
        (*proc)(_xfBvr);
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            (*proc)(_vals[i]);
        }
    }

    virtual const Bbox2 BoundingBox(void) {
        Bbox2 bbox2;
        CalcBoundsToBbox2(*_xfBvr, _vals, bbox2);
        return bbox2;
    }

#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
#error "Fill in"
    }
#endif  // BOUNDINGBOX_TIGHTER

    virtual const Bbox2 OperateOn(const Bbox2 &box) {
        return box;
    }

    // Helper to just pick against the output surface if there is
    // one. 
    Bool PickOutputSurf(PointIntersectCtx& ctx) {
        Bool result = FALSE;
        
        if (_xfBvr->_cachedDDSurf) {

            // Image will not be used immediately after we're done
            // here, so don't worry about releasing it.
            Image *tmpImg =
                ConstructDirectDrawSurfaceImageWithoutReference(
                    _xfBvr->_cachedDDSurf->IDDSurface());

            result = tmpImg->DetectHit(ctx);

        }

        TraceTag((tagDXTransformTracePick,
                  "Picking against output surf = %s",
                  result ? "TRUE" : "FALSE"));
            
        return result;
    }
    
    // Process an image for hit detection.  TODO: Need to ask the
    // DXTransform about this... this is logged as bug 12755 against
    // DXTransforms.  For now, just return false.
    virtual Bool  DetectHit(PointIntersectCtx& ctx) {

        HRESULT hr;
        
        Bool result = FALSE;
        
        // If we don't know how to pick into a 2D xform, then we have
        // to consider it unpicked, and just try to pick the output. 
        if (!_xfBvr->_theXfAs2DPickable) {

            result = PickOutputSurf(ctx);

        } else if (_xfBvr->_cachedDDSurf) {

            // Pick into the transform's inputs.

            // First transform the input point to the space of the
            // transform.
            Assert(_xfBvr->_cachedSurfHeight != -1);
            Assert(_xfBvr->_cachedSurfWidth != -1);
            Point2Value *outputHitDaPoint = ctx.GetLcPoint();

            // singular transform 
            if (!outputHitDaPoint)
                return FALSE;    
            
            POINT   outputHitGdiPoint;
            CenteredImagePoint2ToPOINT(outputHitDaPoint,
                                       _xfBvr->_cachedSurfWidth,
                                       _xfBvr->_cachedSurfHeight,
                                       &outputHitGdiPoint);

            DXVEC dxtransPtOnOutput, dxtransPtOnInput;
            ULONG inputSurfaceIndex;

            dxtransPtOnOutput.eType = DXBT_DISCRETE;
            dxtransPtOnOutput.u.D[0] = outputHitGdiPoint.x;
            dxtransPtOnOutput.u.D[1] = outputHitGdiPoint.y;
            dxtransPtOnOutput.u.D[2] = 0;
            dxtransPtOnOutput.u.D[3] = 0;
            
            hr = TIME_DXXFORM(_xfBvr->_theXfAs2DPickable->
                                  PointPick(&dxtransPtOnOutput,
                                            &inputSurfaceIndex,
                                            &dxtransPtOnInput));

            TraceTag((tagDXTransformTracePick,
                      "Image picked into DA point (%8.5f,%8.5f) == DXT point (%d, %d).  HRESULT is 0x%x",
                      outputHitDaPoint->x,
                      outputHitDaPoint->y,
                      outputHitGdiPoint.x,
                      outputHitGdiPoint.y,
                      hr));

            switch (hr) {
              case S_OK:

                // Now we know which input was hit, and where that
                // input was hit.  Convert back to DA coordinates, and
                // continue traversing.
                if (inputSurfaceIndex < _xfBvr->_numInputs) {

                    AxAValue v = _vals[inputSurfaceIndex];
                    if (v->GetTypeInfo() == ImageType) {

                        Image *inputIm = SAFE_CAST(Image *, v);

                        POINT  inputHitGdiPoint;

                        Assert(dxtransPtOnInput.eType == DXBT_DISCRETE);
                        inputHitGdiPoint.x = dxtransPtOnInput.u.D[0];
                        inputHitGdiPoint.y = dxtransPtOnInput.u.D[1];

                        unsigned short w, h;
                        _xfBvr->
                            _inputBundles[inputSurfaceIndex].
                            _imgBundle.GetDimensions(&w, &h);

                        Point2Value inputHitDaPoint;
                        CenteredImagePOINTToPoint2(&inputHitGdiPoint,
                                                   w,
                                                   h,
                                                   inputIm,
                                                   &inputHitDaPoint);

                        TraceTag((tagDXTransformTracePick,
                                  "Hit input surface %d at DXT point (%d, %d) == DA point (%8.5f, %8.5f)",
                                  inputSurfaceIndex,
                                  inputHitGdiPoint.x,
                                  inputHitGdiPoint.y,
                                  inputHitDaPoint.x,
                                  inputHitDaPoint.y));

                        // Grab and stash current traversal data.  We
                        // basically reset our pick context's info to
                        // pick in the world coordinates of the input
                        // image, then reset our state back.
                        
                        Point2Value *stashedPoint = ctx.GetWcPoint();
                        Transform2 *stashedXf = ctx.GetTransform();
                        Transform2 *stashedImgXf = ctx.GetImageOnlyTransform();

                        // It's possible that the input image will
                        // have a huge coordinate system.  If this is
                        // the case, the conversion to GDI will result
                        // in out of range values.
                        // Thus, scale down both the image and the
                        // pick point by an equivalent amount.  Map to
                        // what would be 512 pixels on the longer
                        // side.

                        const int destPixelDim = 512;
                        Bbox2 origBox = inputIm->BoundingBox();

                        Real origH = origBox.max.y - origBox.min.y;
                        Real origW = origBox.max.x - origBox.min.x;

                        Real centerX = origBox.min.x + origW / 2.0;
                        Real centerY = origBox.min.y + origH / 2.0;

                        Real srcDim = origH > origW ? origH : origW;
                        Real dstDim =
                            (Real)(destPixelDim) / ViewerResolution();

                        Real scaleFac = dstDim / srcDim;

                        Image *imToUse = inputIm;

                        // Only need to scale if we would be scaling
                        // down.  ScaleFacs >= 1 mean that the image
                        // will work fine as it is.
                        if (scaleFac < 1) {

                            Image *centeredIm =
                                TransformImage(TranslateRR(-centerX, -centerY),
                                               imToUse);

                            Image *scaledIm =
                                TransformImage(ScaleRR(scaleFac, scaleFac),
                                               centeredIm);

                            imToUse = scaledIm;

                            // Translate the hit point similarly.
                            inputHitDaPoint.x -= centerX;
                            inputHitDaPoint.y -= centerY;
                            
                            // Scale the input hit point down similarly. 
                            inputHitDaPoint.x *= scaleFac;
                            inputHitDaPoint.y *= scaleFac;

                        }
                        
                        ctx.PushNewLevel(&inputHitDaPoint);

                        result = imToUse->DetectHit(ctx);

                        ctx.RestoreOldLevel(stashedPoint,
                                            stashedXf,
                                            stashedImgXf);

                    }

                }
                break;

              case DXT_S_HITOUTPUT:
                // Didn't hit the inputs, but the output was hit.
                TraceTag((tagDXTransformTracePick, "Got DXT_S_HITOUTPUT"));
                result = TRUE;
                break;

              case S_FALSE:
                // Didn't hit anything.
                TraceTag((tagDXTransformTracePick, "Got S_FALSE"));
                result = FALSE;
                break;

              case E_NOTIMPL:
                // Transform may say this isn't implemented.  In this
                // case, just pick the output surface.
                TraceTag((tagDXTransformTracePick, "Got E_NOTIMPL"));
                result = PickOutputSurf(ctx);
                break;
                
              default:
                // unexpected hr.
                TraceTag((tagDXTransformTracePick, "Got unexpected result"));
                RaiseException_UserError(E_FAIL,
                                         IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
                break;
            }

        } else {

            // No output surface, can't do any picking.
        }

        return result;
    }

    void Render(GenericDevice& genDev) {

        HRESULT hr;

        DirectDrawImageDevice *dev =
            SAFE_CAST(DirectDrawImageDevice *, &genDev);

        DirectDrawViewport &viewport = dev->_viewport;

        IUnknown **rawInputs = ProcessInputs(*_xfBvr, _vals, dev);

        DXBNDS outputBounds;
        CalcBounds(*_xfBvr, _vals, &outputBounds);

        Assert(outputBounds.eType == DXBT_DISCRETE);
        DXDBND *dbnd = outputBounds.u.D;

        int resultWidth = dbnd[0].Max;
        int resultHeight = dbnd[1].Max;

        DAComPtr<IDirectDrawSurface> outputSurf;
        hr = DXXFSetupAndExecute(_xfBvr,
                                 rawInputs,
                                 IID_IDirectDrawSurface,
                                 &viewport,
                                 resultWidth,
                                 resultHeight,
                                 false,
                                 true,
                                 (void **)&outputSurf);

#if _DEBUG
        if (IsTagEnabled(tagDXTransformsImgOut)) {
            showme2(outputSurf);
        }
#endif _DEBUG   

        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            RELEASE(rawInputs[i]);
        }
                
        delete [] rawInputs;

        if (SUCCEEDED(hr)) {
            
            Image *tmpImg;

            #if _DEBUG
            if(IsTagEnabled(tagDXTransformPerPixelAlphaOutputOff)) {
                tmpImg =
                    ConstructDirectDrawSurfaceImageWithoutReference(
                        _xfBvr->_cachedDDSurf->IDDSurface());
            } else 
            #endif
              {
                  // give it the iddsurface and the idxsurface
                  tmpImg =
                      ConstructDirectDrawSurfaceImageWithoutReference(
                          _xfBvr->_cachedDDSurf->IDDSurface(),
                          _xfBvr->_cachedDDSurf->GetIDXSurface(_xfBvr->_surfaceFactory));
              }
            
            tmpImg->Render(genDev);

        } else {

            RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
            
        }

        // output surf released on exit
    }   


    // Print a representation to a stream.
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        return os << "ApplyDXTransformImage";
    }
#endif

    // Ok, we can cache these, but now we're supporting per pixel
    // alpha output on dxtransforms.  which means... no more caching,
    // sorry.  Also, there's a bug with caching dxtransforms.  has to
    // do with dimensions.  
    virtual int Savings(CacheParam&) { return 0; }

  protected:
    ApplyDXTransformBvrImpl     *_xfBvr;
    AxAValue                    *_vals;
};





////////////// Performance //////////////////

// Helper function just sets a dispatch-property to a specified
// value.
HRESULT PutProperty(IDispatch *pDisp,
                    DISPID dispid,
                    AxAValue val)
{
    DISPID propPutDispid = DISPID_PROPERTYPUT;
    DISPPARAMS dispparams;
    VARIANTARG varArg;
    ::VariantInit(&varArg); // Initialize the VARIANT

    dispparams.rgvarg = &varArg;
    dispparams.rgdispidNamedArgs = &propPutDispid;
    dispparams.cArgs = 1;
    dispparams.cNamedArgs = 1;
            
    DXMTypeInfo ti = val->GetTypeInfo();
    if (ti == AxANumberType) {

        double num = ValNumber(val);
                
        dispparams.rgvarg[0].vt = VT_R4;
        dispparams.rgvarg[0].fltVal = num;

        TraceTag((tagDXTransforms,
                  "Setting dispid %d to floating point %8.3f",
                  dispid,
                  num));

    } else if (ti == AxAStringType) {

        WideString wstr = ValString(val);

        dispparams.rgvarg[0].vt = VT_BSTR;
        dispparams.rgvarg[0].bstrVal = SysAllocString(wstr);

        TraceTag((tagDXTransforms,
                  "Setting dispid %d to string %ls",
                  dispid,
                  wstr));
                        
    } else if (ti == AxABooleanType) {

        BOOL bval = BooleanTrue(val);
    
        dispparams.rgvarg[0].vt = VT_BOOL;
        dispparams.rgvarg[0].boolVal = (VARIANT_BOOL)bval;
        
    } else {
        // Shouldn't get here.  Type mismatch should have been
        // caught upon construction of the behavior. 
        Assert(!"Shouldn't be here... ");
    }

    HRESULT hr = pDisp->Invoke(dispid,
                               IID_NULL,
                               LOCALE_SYSTEM_DEFAULT,
                               DISPATCH_PROPERTYPUT,
                               &dispparams,
                               NULL,
                               NULL,
                               NULL);

    TraceTag((tagDXTransforms,
              "Invoke resulted in %hr",
              hr));

    // need to free the information that we put into dispparams
    if(dispparams.rgvarg[0].vt == VT_BSTR) {
        SysFreeString(dispparams.rgvarg[0].bstrVal); 
    }
    ::VariantClear(&varArg); // clears the CComVarient

    return hr;
}

AxAValue
ConstructAppropriateDXTransformStaticValue(ApplyDXTransformBvrImpl *bvr,
                                           AxAValue                *vals) {
    AxAValue result;

    if (bvr->_outputType == ImageType) {
        result = NEW ApplyDXTransformImage(bvr, vals);
    } else if (bvr->_outputType == GeometryType) {
        result = NEW ApplyDXTransformGeometry(bvr, vals);
    } else {
        Assert(!"Unsupported output type for DXTransforms");
    }
    
    return result;
}
                                               
class ApplyDXTransformPerfImpl : public PerfImpl {
  public:
    ApplyDXTransformPerfImpl(PerfParam& pp,
                             ApplyDXTransformBvrImpl *bvr,
                             Perf *inputPerfs,
                             long  numParams,
                             Perf *paramPerfs,
                             Perf  evalPerf) {
        _tt = pp._tt;
        _bvr = bvr;
        _inputPerfs = inputPerfs;
        _evalPerf = evalPerf;

        Assert(numParams < MAX_PARAM_BVRS);
        for (int i = 0; i < MAX_PARAM_BVRS; i++) {

            if (i < numParams) {
                _paramPerfsInThisPerf[i] = paramPerfs[i];
            } else {
                _paramPerfsInThisPerf[i] = NULL;
            }
            
        }

    }

    ~ApplyDXTransformPerfImpl() {
        StoreDeallocate(GetSystemHeap(), _inputPerfs);
    }

    virtual AxAValue _GetRBConst(RBConstParam& rbp) {

        rbp.AddChangeable(this);

        return CommonSample(NULL, &rbp);
    }
    
    virtual bool CheckChangeables(CheckChangeablesParam& ccp) {

        ULONG age;
        HRESULT hr =
            _bvr->_theXf->GetGenerationId(&age);

        Assert(SUCCEEDED(hr));

        if (age != _bvr->_previousAge) {
            // The DXTransform has changed externally to DA.
            return true;
        }

        return false;
    }

    virtual AxAValue _Sample(Param& p) {
        return CommonSample(&p, NULL);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "ApplyDXTransformPerfImpl"; }
#endif
    
    virtual void _DoKids(GCFuncObj proc) {
        for (long i=0; i< _bvr->_numInputs; i++) {
            (*proc)(_inputPerfs[i]);
        }
        for (i = 0; i< _bvr->_numParams; i++) {
            (*proc)(_paramPerfsInThisPerf[i]);
        }
        (*proc)(_bvr);
        (*proc)(_tt);
        (*proc)(_evalPerf);
    }

  protected:

    // Support both Sample and GetRBConst.
    AxAValue CommonSample(Param *p, RBConstParam *rbp) {

        // Only one should be non-null.
        Assert((p && !rbp) || (rbp && !p));
        
        AxAValue *vals = (AxAValue *)
            AllocateFromStore(_bvr->_numInputs * sizeof(AxAValue));

        long idx;
        bool failedRBConst = false;
        for (idx = 0; idx < _bvr->_numInputs && !failedRBConst; idx++) {
            Perf perf = _inputPerfs[idx];
            if (perf) {
                AxAValue val;
                if (p) {
                    vals[idx] = perf->Sample(*p);
                    Assert(vals[idx]);
                } else {
                    vals[idx] = perf->GetRBConst(*rbp);
                    if (!vals[idx]) {
                        failedRBConst = true;
                    }
                }
            } else {
                vals[idx] = NULL;
            }
        }

        if (failedRBConst) {
            Assert(rbp);
            DeallocateFromStore(vals);
            return NULL;
        }

        // Apply the sampled parameters to the filter.  Use *all* the
        // bvr's params, not just those in the perf.
        for (idx = 0; idx < _bvr->_numParams && !failedRBConst; idx++) {

            // First check to see if the corresponding param bvr is non-
            // NULL in the parent bvr.  If it is NULL, then this has been
            // removed, and we shouldn't execute it.
            if (_bvr->_paramBvrs[idx] == NULL) {

                // Null out corresponding performance so it will be
                // collected. 
                if (_paramPerfsInThisPerf[idx] != NULL) {
                    _paramPerfsInThisPerf[idx] = NULL;
                }

            } else {

                // If bvr was added since the last sample, then
                // perform it and store it here.
                if (_paramPerfsInThisPerf[idx] == NULL) {
                    
                    DynamicHeapPusher h(GetGCHeap());
                    
                    // Perform at the current time
                    Param *theP;
                    if (p) {
                        theP = p;
                    } else {
                        theP = &rbp->GetParam();
                    }
                    
                    PerfParam pp(theP->_time,
                                 Restart(_tt, theP->_time, *theP));
                    
                    _paramPerfsInThisPerf[idx] =
                        ::Perform(_bvr->_paramBvrs[idx], pp);
                }

                Assert(_paramPerfsInThisPerf[idx]);

                AxAValue val;
                if (p) {
                    val = _paramPerfsInThisPerf[idx]->Sample(*p);
                    Assert(val);
                } else {
                    val = _paramPerfsInThisPerf[idx]->GetRBConst(*rbp);
                    if (!val) {
                        failedRBConst = true;
                    }
                }

                if (val) {
                    HRESULT hr = ::PutProperty(_bvr->_theXfAsDispatch,
                                               _bvr->_paramDispids[idx],
                                               val);

                    // Nothing interesting for us to do with an error
                    // here. 
                }
                
            }
        }

        // Establish the time on the effect if allowed.
        if (_evalPerf && _bvr->_theXfAsEffect) {
            AxAValue evalTime;

            if (p) {
                evalTime = _evalPerf->Sample(*p);
                Assert(evalTime);
            } else {
                evalTime = _evalPerf->GetRBConst(*rbp);
                if (!evalTime) {
                    failedRBConst = true;
                }
            }

            if (evalTime) {
                
                double evalTimeDouble = ValNumber(evalTime);

                float currProgress;
                _bvr->_theXfAsEffect->get_Progress(&currProgress);

                float evalTimeFloat = evalTimeDouble;

                if (evalTimeFloat != currProgress) {

                    _bvr->_theXfAsEffect->put_Progress(evalTimeFloat);

                } else {

                    // For setting breakpoints.
                    DebugCode(int breakHere = 0);
                    
                }
                
            }
        }

        AxAValue result;
        if (failedRBConst) {
            Assert(rbp);
            DeallocateFromStore(vals);
            result = NULL;
        } else {
            result = ConstructAppropriateDXTransformStaticValue(_bvr, vals);
        }

        return result;
    }

    
    TimeXform                _tt;
    ApplyDXTransformBvrImpl *_bvr;         // backpointer
    Perf                    *_inputPerfs;
    Perf                     _evalPerf;
    Perf                     _paramPerfsInThisPerf[MAX_PARAM_BVRS];
};


////////////// Behavior //////////////////

bool
TypeSupported(const GUID& candidateGuid,
              GUID *acceptableGuids,
              int   numAcceptable)
{
    GUID *g = &acceptableGuids[0];
    for (int i = 0; i < numAcceptable; i++) {
        if (candidateGuid == *g++) {
            return true;
        }
    }

    return false;
}

// Return type info of specified input or output or, if input or
// output doesn't exist, or it is a type we don't understand, return
// NULL. 
DXMTypeInfo 
FindType(IDXTransform *xf,
         bool isOutput,
         int index,
         bool *pIsOptional)
{
    HRESULT hr;
    DXMTypeInfo result = NULL;

    const int maxTypes = 5;
    ULONG count = maxTypes;
    GUID  allowedTypes[maxTypes];
    DWORD pdwFlags;

    hr = xf->GetInOutInfo(isOutput,
                          index,
                          &pdwFlags,
                          allowedTypes,
                          &count,
                          NULL);

    if (hr != S_OK) {
        return NULL;
    }

    if (pIsOptional) {
        *pIsOptional = (pdwFlags & DXINOUTF_OPTIONAL) ? true : false;
    }
    
    // Figure out what the output of this transform is going to be.
    // TODO: Support multiple output types as tuples.  For now, we
    // just fail on multiple output types.

    if (TypeSupported(IID_IDirect3DRMMeshBuilder, allowedTypes, count) ||
        TypeSupported(IID_IDirect3DRMMeshBuilder2, allowedTypes, count) ||
        TypeSupported(IID_IDirect3DRMMeshBuilder3, allowedTypes, count)) {
        
        result = GeometryType;
        
    } else if (TypeSupported(IID_IDirectDrawSurface, allowedTypes, count) ||
               TypeSupported(IID_IDirectDrawSurface2, allowedTypes, count)) {
        
        result = ImageType;
        
    };

    // Anything else, we don't understand yet.
    return result;
}
         
              

ApplyDXTransformBvrImpl::ApplyDXTransformBvrImpl(IDXTransform *theXf,
                                                 IDispatch *theXfAsDispatch,
                                                 LONG numInputs,
                                                 Bvr *inputBvrs,
                                                 Bvr  evaluator)
: _transformFactory(NULL),
  _surfaceFactory(NULL),
  _poolDeletionNotifier(*this)
{
    _theXf = theXf;
    _theXfAsDispatch = theXfAsDispatch;
    _numInputs = numInputs;
    _inputBvrs = inputBvrs;
    _evaluator = evaluator;

    memset(_cachedInputs, 0, sizeof(_cachedInputs));
    _numParams = 0;
    
    _cachedOutput = NULL;
    _surfPool = NULL;
    _surfPoolHasBeenDeleted = false;
}

// Separate out initialization so we don't throw an exception in a
// constructor.
void
ApplyDXTransformBvrImpl::Init()
{
    _previousAge = 0xFFFFFFFF;
    
    bool involvesGeometry, involvesImage;
    
    ValidateInputs(&involvesGeometry, &involvesImage);
    InitializeTransform(involvesGeometry, involvesImage);
    QueryForAdditionalInterfaces();

    HRESULT hr = _theXf->GetMiscFlags(&_miscFlags);
    _miscFlagsValid = SUCCEEDED(hr);

    if (_miscFlagsValid) {
        // Clear "blend with output" flag, since we're always
        // rendering image transforms to intermediate surfaces.
        _miscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
        
        hr = _theXf->SetMiscFlags(_miscFlags);
        Assert(SUCCEEDED(hr));  // better not fail.
    }
    
    _neverSetup = true;
}

void
ApplyDXTransformBvrImpl::ValidateInputs(bool *pInvolvesGeometry,
                                        bool *pInvolvesImage)
{
    _cachedSurfWidth = -1;
    _cachedSurfHeight = -1;

    if (_numInputs > MAX_INPUTS) {
        RaiseException_InternalError("Too many inputs to DXTransform");
    }

    // First be sure there's only one output by making sure output
    // index 1 fails.
    DXMTypeInfo ti = FindType(_theXf, true, 1, NULL);

    if (ti != NULL) {
        RaiseException_UserError(DISP_E_TYPEMISMATCH,
                                 IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
    }

    // Now get the output types on the first output.
    _outputType = FindType(_theXf, true, 0, NULL);

    if (!_outputType) {
        RaiseException_UserError(DISP_E_TYPEMISMATCH,
                                 IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
    }

    *pInvolvesGeometry = (_outputType == GeometryType);
    *pInvolvesImage = (_outputType == ImageType);
    
    // Be sure the input types are valid.
    for (int i = 0; i < _numInputs; i++) {

        bool ok = false;

        if (_inputBvrs[i]) {
            
            _inputTypes[i] = _inputBvrs[i]->GetTypeInfo();

            if (_inputTypes[i] == GeometryType) {
                *pInvolvesGeometry = true;
            } else if (_inputTypes[i] == ImageType) {
                *pInvolvesImage = true;
            }
        
            DXMTypeInfo expectedType = FindType(_theXf, false, i, NULL);

            if (expectedType == _inputTypes[i]) {
                ok = true;
            }
            
        } else {

            // Be sure the input is optional
            bool isOptional;
            DXMTypeInfo expectedType = FindType(_theXf, false, i, &isOptional);

            if (isOptional) {
                ok = true;
                _inputTypes[i] = expectedType;
            }
            
        }

        if (!ok) {
            RaiseException_UserError(DISP_E_TYPEMISMATCH,
                               IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
        }
        
    }

    // Be sure there aren't additional required inputs.
    bool isOptional;
    DXMTypeInfo nextType =
        FindType(_theXf, false, _numInputs, &isOptional);

    if (nextType && !isOptional) {
        RaiseException_UserError(DISP_E_TYPEMISMATCH,
                                 IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
    }

    // D3DRM3 interface needs to be available for us to deal with
    // transforms that involve geometry.  If it's not, we need to fail
    // out. 
    if (*pInvolvesGeometry && GetD3DRM3() == NULL) {
        RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_NEED_DX6);
    }

    // Once we've validated our inputs, do this...
    GetInfo(true);
}

void
ApplyDXTransformBvrImpl::InitializeTransform(bool involvesGeometry,
                                             bool involvesImage)
{
    HRESULT hr;
    
    hr = CoCreateInstance( CLSID_DXTransformFactory,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IDXTransformFactory,
                           (void **)&_transformFactory);

    if (FAILED(hr)) {
        RaiseException_InternalError("Creation of DXTransformFactory failed");
    }

    DAComPtr<IServiceProvider> sp;
    hr = _transformFactory->QueryInterface(IID_IServiceProvider,
                                                 (void **)&sp);
    
    if (FAILED(hr)) {
        RaiseException_InternalError("QI for ServiceProvider failed");
    }
            
    hr = sp->QueryService(SID_SDXSurfaceFactory,
                          IID_IDXSurfaceFactory,
                          (void **)&_surfaceFactory);
    
    if (FAILED(hr)) {
        RaiseException_InternalError("QueryService of DXSurfaceFactory failed");
    }

    // Ensure that the D3DRM service is established on the
    // factory if this is a geometry-based transform
    if (involvesGeometry) {
        HRESULT hr = _transformFactory->SetService(SID_SDirect3DRM,
                                                   GetD3DRM3(),
                                                   FALSE);
        if (FAILED(hr)) {
            Assert(!"SetService failed");
            RaiseException_InternalError("SetService failed");
        }
    }

    if (involvesImage) {
        IDirectDraw3 *ddraw3;
        HRESULT hr = GetDirectDraw(NULL, NULL, &ddraw3);
        if (FAILED(hr)) {
            Assert(!"GetDdraw3 failed");
            RaiseException_InternalError("No ddraw3");
        }
        
        hr = _transformFactory->SetService(SID_SDirectDraw,
                                           ddraw3,
                                           FALSE);
        if (FAILED(hr)) {
            Assert(!"SetService failed");
            RaiseException_InternalError("SetService failed");
        }
    }

    // Tell the factory about this transform.
    hr = _transformFactory->InitializeTransform(_theXf,
                                                      NULL, 0, NULL, 0,
                                                      NULL, NULL);
    if (FAILED(hr)) {
        RaiseException_InternalError("Init from DXTransformFactory failed");
    }
}

void
ApplyDXTransformBvrImpl::QueryForAdditionalInterfaces()
{
    /////////// Query for IDXEffect /////////////////
    
    HRESULT hr =
        _theXf->QueryInterface(IID_IDXEffect, (void **)&_theXfAsEffect);

    // Be sure we set _theXfAsEffect correctly.
    Assert((SUCCEEDED(hr) && _theXfAsEffect) ||
           (FAILED(hr) && !_theXfAsEffect));

    // If we're an effect, and the evaluator hasn't been specified,
    // create a meaningful one.
    if (_theXfAsEffect && !_evaluator) {
        float dur;
        hr = _theXfAsEffect->get_Duration(&dur);

        if (SUCCEEDED(hr) && (dur > 0.0)) {
            // make the evaluator go from 0 to 1 over dur seconds.
            _evaluator = InterpolateBvr(zeroBvr,
                                        oneBvr,
                                        ConstBvr(RealToNumber(dur)));
        }
    }

    /////////// Query for IDirect3DRMExternalVisual /////////////////
    
    hr = _theXf->QueryInterface(IID_IDirect3DRMExternalVisual,
                                (void **)&_theXfAsExternalVisual);

    // Be sure we set _theXfAsExternalVisual correctly.
    Assert((SUCCEEDED(hr) && _theXfAsExternalVisual) ||
           (FAILED(hr) && !_theXfAsExternalVisual));

    /////////// Query for IDXSurfacePick /////////////////

    if (_outputType == ImageType) {
        
        hr = _theXf->QueryInterface(IID_IDXSurfacePick,
                                    (void **)&_theXfAs2DPickable);

        // Be sure we set _theXfAs2DPickable correctly.
        Assert((SUCCEEDED(hr) && _theXfAs2DPickable) ||
               (FAILED(hr) && !_theXfAs2DPickable));
        
    }
    
}

ApplyDXTransformBvrImpl::~ApplyDXTransformBvrImpl()
{
    for (int i = 0; i < MAX_INPUTS_TO_CACHE; i++) {
        RELEASE(_cachedInputs[i]);
    }
    RELEASE(_cachedOutput);
    RELEASE(_transformFactory);
    RELEASE(_surfaceFactory);

    if (_surfPool && !_surfPoolHasBeenDeleted) {

        // Advise the surface mgr to remove our deletion notifier
        _surfPool->UnregisterDeletionNotifier(&_poolDeletionNotifier);

        // The normal destruction process will return the
        // ddsurfs to the pool, since they're in DDSurfPtr<>
        // templates. 
            
            
    } else {

        // Just to put a breakpoint on.  Surfaces already null'd
        // out on the advise.
        Assert(true && "Surface pool deleted already.");
    }
}

// Custom method for this subclass of BvrImpl.  Apply the bvrToAdd
// each frame to the specified property.  Write over any previously
// established behavior.  If bvrToAdd is NULL, this removes the
// association with the property.
HRESULT
ApplyDXTransformBvrImpl::AddBehaviorProperty(BSTR property,
                                             Bvr  bvrToAdd)
{
    // First, lookup the property to be sure it's available on the
    // IDispatch.
    DISPID dispid;
    HRESULT hr =
        _theXfAsDispatch->GetIDsOfNames(IID_NULL,
                                        &property,
                                        1,
                                        LOCALE_SYSTEM_DEFAULT,
                                        &dispid);

    TraceTag((tagDXTransforms,
              "Property %ls becomes dispid %d with hr %hr",
              property, dispid, hr));
    
    if (FAILED(hr)) {
        return hr;
    }

    if (bvrToAdd) {
        
        // Be sure that the type of the behavior is consistent with
        // the property's type.  If not, we should fail here. 
    
        DXMTypeInfo ti = bvrToAdd->GetTypeInfo();
        CComVariant VarResult;
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
       
        hr = _theXfAsDispatch->Invoke(dispid,
                                      IID_NULL,
                                      LOCALE_SYSTEM_DEFAULT,
                                      DISPATCH_PROPERTYGET,
                                      &dispparamsNoArgs, 
                                      &VarResult,NULL,NULL);
        if (FAILED(hr)) {   
            return hr;
        }  
    
        CComVariant var;
        if(ti == AxAStringType) {
            WideString wstr = L"Just a test string";
            var.bstrVal = SysAllocString(wstr);
        } else if (ti == AxABooleanType) {
            var.boolVal = FALSE;  
        } else if (ti == AxANumberType) {
            var.fltVal = 100.00;
        } else {
            Assert(!"Shouldn't be here");
        }
        hr  = var.ChangeType(VarResult.vt, NULL);
        if (FAILED(hr)) 
            RaiseException_UserError(E_FAIL, DISP_E_TYPEMISMATCH,IDS_ERR_TYPE_MISMATCH);

    }

    // Search through existing parameters and replace if
    // necessary.  Don't decrement _numParams, since we're just poking
    // holes in the list if the bvr is NULL, not compacting it.  
    bool foundIt = false;
    for (int i = 0; i < _numParams && !foundIt; i++) {
        if (_paramDispids[i] == dispid) {
            foundIt = true;
            _paramBvrs[i] = bvrToAdd;
        }
    }

    // Else, add on to the list if non-null behavior. 
    if (!foundIt && bvrToAdd != NULL) {

        if (_numParams == MAX_PARAM_BVRS) {
            return E_FAIL;
        }

        _paramDispids[_numParams] = dispid;
        _paramBvrs[_numParams] = bvrToAdd;

        _numParams++;
    }

    return S_OK;
}

Perf ApplyDXTransformBvrImpl::_Perform(PerfParam& p)
{
    Perf *inputPerfs =
        (Perf *)StoreAllocate(GetSystemHeap(),
                              sizeof(Perf) * _numInputs);
    
    Perf  paramPerfs[MAX_PARAM_BVRS];

    for (long i=0; i<_numInputs; i++) {
        Bvr b = _inputBvrs[i];
        inputPerfs[i] = b ? ::Perform(b, p) : NULL;
    }

    // Construct the list of parameter performances for as many
    // parameters as we *currently* have.  Subsequently added bvrs
    // will be performed on the next sample by the Performance.
    for (i = 0; i < _numParams; i++) {
        // Might be null if removed
        if (_paramBvrs[i] == NULL) {
            paramPerfs[i] = NULL;
        } else {
            paramPerfs[i] =  ::Perform(_paramBvrs[i], p);
        }
    }

    Perf evalPerf =
        _evaluator ? ::Perform(_evaluator, p) : NULL;

    return NEW ApplyDXTransformPerfImpl(p,
                                        this,
                                        inputPerfs,
                                        _numParams,
                                        paramPerfs, 
                                        evalPerf);
}

void
ApplyDXTransformBvrImpl::_DoKids(GCFuncObj proc)
{
    for (long i=0; i<_numInputs; i++) {
        (*proc)(_inputBvrs[i]);
    }

    (*proc)(_evaluator);

    for (i = 0; i < _numParams; i++) {
        (*proc)(_paramBvrs[i]);
    }
}

DWORD
ApplyDXTransformBvrImpl::GetInfo(bool recalc)
{
    _info = BVR_IS_CONSTANT;
    
    for (long i=0; i<_numInputs; i++) {
        Bvr b = _inputBvrs[i];
        if (b) {
            _info &= b->GetInfo(recalc);
        }
    }

    for (i = 0; i < _numParams; i++) {
        _info &= _paramBvrs[i]->GetInfo(recalc);
    }

    return _info;
}


// We disable constant folding for dxtransforms since we don't
// currently have a way of recognizing that something became
// "un-constant" through the addition of a new property after the
// bvr's been started.  Thus, for now, assume that they're *never*
// constant, and try to come up with some smart approaches later.
// Note that there was a previous version of this code that did the
// the right constant folding (assuming that the properties wouldn't
// be set after the fact).  This can be found in SLM versions v20 and
// prior (prior to 12/23/98).
AxAValue
ApplyDXTransformBvrImpl::GetConst(ConstParam & cp)
{
    return NULL;
}
    
Bvr
ConstructDXTransformApplier(IDXTransform *theXf,
                            IDispatch *theXfAsDispatch,
                            LONG numInputs,
                            Bvr *inputBvrs,
                            Bvr  evaluator)
{
    ApplyDXTransformBvrImpl *obj =
        NEW ApplyDXTransformBvrImpl(theXf,
                                    theXfAsDispatch,
                                    numInputs,
                                    inputBvrs,
                                    evaluator);

    obj->Init();

    return obj;
}


HRESULT
DXXFAddBehaviorPropertyToDXTransformApplier(BSTR property,
                                            Bvr  bvrToAdd,
                                            Bvr  bvrToAddTo)
{
    ApplyDXTransformBvrImpl *dxxfBvr =
        SAFE_CAST(ApplyDXTransformBvrImpl *, bvrToAddTo);

    return dxxfBvr->AddBehaviorProperty(property, bvrToAdd);
}

// TODO: Someday, may want to make this more
// object-oriented... separate out image from geom stuff...  Certainly
// not critical, though.

HRESULT
DXXFSetupAndExecute(Bvr bvr,
                    IUnknown          **newInputArray,
                    REFIID              outputIID,
                    DirectDrawViewport *viewport,
                    int                 requestedWidth,
                    int                 requestedHeight,
                    bool                invokeAsExternalVisual,
                    bool                executeRequired,
                    void              **outputValue)
{
    ApplyDXTransformBvrImpl &bv =
        *(SAFE_CAST(ApplyDXTransformBvrImpl *, bvr));

    HRESULT hr = S_OK;
    bool mustSetup = false;
    
    // Have to be pessimistic
    if (bv._numInputs > MAX_INPUTS_TO_CACHE) {
        
        mustSetup = true;
        
    } else {

        // Go through each cached input and compare pointers with the
        // incoming one.  If any differ, then we will need to redo setup.
        // In this case, also stash the values into the cache.
        for (int i = 0; i < bv._numInputs; i++) {
            if (newInputArray[i] != bv._cachedInputs[i]) {
            
                mustSetup = true;
            
                RELEASE(bv._cachedInputs[i]);
            
                newInputArray[i]->AddRef();
                bv._cachedInputs[i] = newInputArray[i];

            }
        }

        if (!mustSetup && !bv._cachedOutput && !invokeAsExternalVisual) {
            // Assert that the only way we can think we don't need to
            // setup and yet our output cache is nil is if there are no
            // inputs.  In this case, we really do want to setup.
            Assert(bv._numInputs == 0);
            mustSetup = true;
        }

    }

    // May also need to setup again if our output surface isn't the
    // right size.
    bool needToCreateNewOutputSurf = false;
    if (bv._outputType == ImageType) {
        needToCreateNewOutputSurf = 
            (bv._cachedSurfWidth != requestedWidth ||
             bv._cachedSurfHeight != requestedHeight);

        if (needToCreateNewOutputSurf) {
            mustSetup = true;
        }
    }

    if (mustSetup) {
        
        if (bv._outputType == GeometryType) {

            RELEASE(bv._cachedOutput);
            
            TD3D(GetD3DRM3()->CreateMeshBuilder(&bv._cachedOutputAsBuilder));

            hr = bv._cachedOutputAsBuilder->
                    QueryInterface(IID_IUnknown, 
                                   (void **)&bv._cachedOutput);

            // QI'ing for IUnknown had better not fail!!
            Assert(SUCCEEDED(hr));

            // We don't want to keep a ref for this guy, since we have
            // a ref in _cachedOutput itself.
            bv._cachedOutputAsBuilder->Release();
            
        } else if (bv._outputType == ImageType) {

            // If we don't need a new output surf, just recycle the
            // existing one through the next Setup call.
            if (needToCreateNewOutputSurf) {

                RELEASE(bv._cachedOutput);

                // Release whatever old one we had.
                bv._cachedDDSurf.Release();


                DDPIXELFORMAT pf;
                ZeroMemory(&pf, sizeof(pf));
                pf.dwSize = sizeof(pf);
                pf.dwFlags = DDPF_RGB;
                pf.dwRGBBitCount = 32;
                pf.dwRBitMask = 0xff0000;
                pf.dwGBitMask = 0x00ff00;
                pf.dwBBitMask = 0x0000ff;
                
                viewport->CreateSizedDDSurface(&bv._cachedDDSurf,
                                               pf,
                                               requestedWidth,
                                               requestedHeight,
                                               NULL,
                                               notVidmem);

                #if _DEBUG
                if(IsTagEnabled(tagDXTransformPerPixelAlphaOutputOff)) {
                    bv._cachedDDSurf->SetColorKey(viewport->GetColorKey());
                    bv._cachedOutput = bv._cachedDDSurf->IDDSurface_IUnk();
                    bv._cachedOutput->AddRef();
                } else
                #endif

                  {
                      // UNSET the color key
                      bv._cachedDDSurf->UnSetColorKey();
                      
                      // get the iunk of the idxsurf in _cachedOutput
                      bv._cachedDDSurf->GetIDXSurface(bv._surfaceFactory)->
                          QueryInterface(IID_IUnknown, (void **) &(bv._cachedOutput));
                  }
                
                bv._cachedSurfWidth = (SHORT)requestedWidth;
                bv._cachedSurfHeight = (SHORT)requestedHeight;
                
            }
            
        } else {
            
            Assert(!"Unsupported type for setup caching");
            
        }
    }

    if (invokeAsExternalVisual) {
        *outputValue = NULL;
    } else {
        // This does an AddRef
        hr = bv._cachedOutput->QueryInterface(outputIID,
                                              outputValue);
    }

    Assert(SUCCEEDED(hr));      // else internal error.

    if (mustSetup) {
        hr = TIME_DXXFORM(bv._theXf->Setup(newInputArray,
                                           bv._numInputs,
                                           &bv._cachedOutput,
                                           1,
                                           0));

        TraceTag((tagDXTransforms, "Called Setup() on 0x%x",
                  bv._theXf));
            
        if (FAILED(hr)) {
            if (executeRequired) {
                RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
            } else {
                // If we don't require an execute, then tolerate
                // failures of Setup, as some transforms don't want to
                // setup with empty meshbuilder inputs (Melt, for
                // one.)
                hr = S_OK;
            }
        }

        if (bv._neverSetup) {
            bv._neverSetup = false;
        }
    }

    // Only execute if we're not invoked as an external visual.
    if (executeRequired && !invokeAsExternalVisual) {
        // If the transform's generation id hasn't changed, then we don't
        // need to call Execute.
        ULONG age;
        hr = bv._theXf->GetGenerationId(&age);
        if (FAILED(hr) || (age != bv._previousAge) || mustSetup) {

            // If an image output, clear the image to the color key,
            // since the transform will not necessarily write all
            // bits.
            
            if (bv._outputType == ImageType) {
                viewport->
                    ClearDDSurfaceDefaultAndSetColorKey(bv._cachedDDSurf);
            }

            hr = TIME_DXXFORM(bv._theXf->Execute(NULL, NULL, NULL));
        
            TraceTag((tagDXTransforms, "Called Execute() on 0x%x",
                      bv._theXf));
            
            if (FAILED(hr)) {
                RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
            }

            // Re-get the gen id.  It may have changed during Execute().
            hr = bv._theXf->GetGenerationId(&age);
            if (SUCCEEDED(hr)) {
                bv._previousAge = age;
            }
        
        }
        
    } 
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\ddsimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include <privinc/ddsimg.h>


DirectDrawSurfaceImage::DirectDrawSurfaceImage(
    IDDrawSurface *ddsurf,
    bool holdReference)
{
    _Init(holdReference);
    _InitSurfaces(ddsurf, NULL);
}


DirectDrawSurfaceImage::DirectDrawSurfaceImage(
    IDDrawSurface *iddSurf,
    IDXSurface *idxSurf,
    bool holdReference)
{
    Assert( iddSurf && idxSurf );
    _Init(holdReference);
    _InitSurfaces(iddSurf, idxSurf);
}
    
void DirectDrawSurfaceImage::_Init( bool holdReference )
{
    _resolution = ViewerResolution();
    _holdReference = holdReference;

    // Only reason we need to register this is to allow for deletion
    // when needed.
    if (holdReference) {
        DynamicPtrDeleter<DirectDrawSurfaceImage> *dltr =
            new DynamicPtrDeleter<DirectDrawSurfaceImage>(this);
        GetHeapOnTopOfStack().RegisterDynamicDeleter(dltr);
    }

    _flags |= IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT;
    #if DEVELOPER_DEBUG
    _surfacesSet = false;
    #endif
}

DirectDrawSurfaceImage::~DirectDrawSurfaceImage()
{
    CleanUp();
}

void
DirectDrawSurfaceImage::CleanUp()
{
    // todo: consider telling the device we KNOW we are associated
    // with that we're oging away, instead of telling all the views
    DiscreteImageGoingAway(this);
    TraceTag((tagGCMedia, "DirectDrawSurfaceImage::CleanUp %x", this));

    if (_holdReference) {
        RELEASE(_iddSurf);
        RELEASE(_idxSurf);
    }
}

void
DirectDrawSurfaceImage::Render(GenericDevice& dev)
{
    ImageDisplayDev &idev = (ImageDisplayDev &)dev;
    idev.RenderDirectDrawSurfaceImage(this);
}


void
DirectDrawSurfaceImage::InitIntoDDSurface(DDSurface *ddSurf,
                                          ImageDisplayDev *dev)
{
    if( _iddSurf && !_idxSurf ) {
        Assert(ddSurf->IDDSurface() == _iddSurf);

        // Need to set the color key on the DDSurface.  First grab
        // from the IDirectDrawSurface.
        DDCOLORKEY ckey;
        HRESULT hr = _iddSurf->GetColorKey(DDCKEY_SRCBLT, &ckey);

        if (hr == DDERR_NOCOLORKEY) {
            // It's fine to not have a color key, just return
            return;
        } else if (FAILED(hr)) {
            RaiseException_InternalError("GetColorKey failed");
        } else {
            // And set on the DDSurface.
            ddSurf->SetColorKey(ckey.dwColorSpaceLowValue);
        }
    }
}

void DirectDrawSurfaceImage::
GetIDDrawSurface(IDDrawSurface **outSurf)
{
    Assert( outSurf );
    *outSurf = _iddSurf;
    if(_iddSurf) _iddSurf->AddRef();
}

void DirectDrawSurfaceImage::
GetIDXSurface(IDXSurface **outSurf)
{
    Assert( outSurf );
    *outSurf = _idxSurf;
    if(_idxSurf) _idxSurf->AddRef();
}

void DirectDrawSurfaceImage::
_InitSurfaces(IDDrawSurface *iddSurf,  IDXSurface *idxSurf)
{
    Assert( (iddSurf  && !idxSurf) ||
            (iddSurf  &&  idxSurf) );

    #if DEVELOPER_DEBUG
    Assert(_surfacesSet == false);
    #endif

    _idxSurf = idxSurf;
    _iddSurf = iddSurf;
    if(_holdReference) {
        if(_idxSurf) _idxSurf->AddRef();
        _iddSurf->AddRef();
    }

    #if DEVELOPER_DEBUG
    _surfacesSet = true;
    #endif

    _bboxReady = FALSE;

    // OPTIMIZE: if this happens every frame
    // we should be able to do better.
    GetSurfaceSize(_iddSurf, &_width, &_height);
    SetRect(&_rect, 0,0,_width,_height);
    _membersReady = TRUE;
}
    

Image *ConstructDirectDrawSurfaceImage(IDDrawSurface *dds)
{
    return NEW DirectDrawSurfaceImage(dds, true);
}

Image *ConstructDirectDrawSurfaceImageWithoutReference(IDDrawSurface *idds)
{
    return NEW DirectDrawSurfaceImage(idds, false);
}

Image *ConstructDirectDrawSurfaceImageWithoutReference(IDDrawSurface *idds, IDXSurface *idxs)
{
    return NEW DirectDrawSurfaceImage(idds, idxs, false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\discimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include "privinc/dibimage.h"
#include "privinc/discimg.h"


const Bbox2 DiscreteImage::BoundingBox(void)
{
    if(!_bboxReady) {
        //
        // Build bounding box
        //
        Assert( (_width>0) && (_height>0) && "width or height invalid in DiscreteImage::BoundingBox");
        Assert( (_resolution>0) && "_resolution invalid in DiscreteImage::BoundingBox");

        _bbox.Set(Real( - GetPixelWidth() ) * 0.5 / GetResolution(),
                  Real( - GetPixelHeight() ) * 0.5 / GetResolution(),
                  Real( GetPixelWidth() ) * 0.5 / GetResolution(),
                  Real( GetPixelHeight() ) * 0.5 / GetResolution());
        _bboxReady = TRUE;
    }
    return _bbox;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\cropdimg.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the CroppedImage class, a subclass
    of Image.

--*/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/probe.h"
#include "privinc/imgdev.h"
#include "privinc/vec2i.h"      // For access to Point2 class
#include "privinc/except.h"
#include "privinc/overimg.h"
#include "privinc/cropdimg.h"
#include "privinc/opt.h"


void
CroppedImage::Render(GenericDevice& d)
{
    // Make sure the cast is legal.
    Assert(DYNAMIC_CAST(ImageDisplayDev *, &d) != NULL);

    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, d);

    dev.PushCroppedImage(this);

    dev.SmartRender(_image, ATTRIB_CROP);
    
    dev.PopCroppedImage();
}


Real
CroppedImage::DisjointBBoxAreas(DisjointCalcParam &param)
{
    DisjointCalcParam newParam;
    param.CalcNewParamFromBox(_croppingBox, &newParam);

    return _image->DisjointBBoxAreas(newParam);
}

void
CroppedImage::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    Bbox2 oldClipBox = ctx.GetClipBox();

    ctx.AccumulateClipBox(_croppingBox);

    CollectDirtyRects(_image, ctx);
    
    ctx.SetClipBox(oldClipBox);
}


Bool
CroppedImage::DetectHit(PointIntersectCtx& ctx)
{
    // If the local coordinate point is outside of the cropping box,
    // then no hit, otherwise perform operation on the image.
    Point2Value *lcPt = ctx.GetLcPoint();

    if (!lcPt) return FALSE;    // singular transform
    
    if (_croppingBox.Contains(Demote(*lcPt))) {
        return _image->DetectHit(ctx);
    } else {
        return FALSE;
    }
}


Image *CreateCropImage(const Point2& botLeft, const Point2 &topRight, Image *image)
{
    if ((topRight.x <= botLeft.x) || (topRight.y <= botLeft.y)) {
        return emptyImage;
    }

    Bbox2 box(botLeft, topRight);

#if BADIDEA

    if (image->CheckImageTypeId(OVERLAYEDIMAGE_VTYPEID)) {
        
        //
        // Dynamic expression reduction
        //
        OverlayedImage *overImg = (OverlayedImage *)image;
        
        Image *newTop = NEW CroppedImage(box, overImg->Top());
        Image *newBot = NEW CroppedImage(box, overImg->Bottom());
        overImg->SetTopBottom(newTop, newBot);
        return overImg;
    } else if(image->CheckImageTypeId(OPAQUEIMAGE_VTYPEID)) {

        //
        // Opaque Image
        //
        AttributedImage *opcImg = (AttributedImage *)image;

        if(opcImg->_image->CheckImageTypeId(OVERLAYEDIMAGE_VTYPEID)) {
            
            OverlayedImage *overImg = (OverlayedImage *)opcImg->_image;

            //
            // Push xf past opacity, under overlay
            //
            overImg->SetTopBottom(NEW CroppedImage(box, overImg->Top()),
                                  NEW CroppedImage(box, overImg->Bottom()));
            
            opcImg->_image = overImg;
            return opcImg;
        } else {
            // !over
            // !opac
            // => error
            Assert(FALSE && "There's something wrong with dynamic image reduction");
        }
    }
        
#endif  BADIDEA

    return NEW CroppedImage(box, image);
}


Image *CropImage(Point2Value *botLeft, Point2Value *topRight, Image *image)
{
    return CreateCropImage(Demote(*botLeft),Demote(*topRight),image);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\dibimage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for DIB images from DIB and BMP files

*******************************************************************************/

#include "headers.h"

#include <strstrea.h>
#include "privinc/dibimage.h"
#include "privinc/probe.h"
#include "privinc/imgdev.h"
#include "privinc/ddutil.h"
#include "privinc/util.h"
#include "privinc/bbox2i.h"
#include "privinc/ddSurf.h"
#include "privinc/vec2i.h"
#include "appelles/readobj.h"
#include "privinc/viewport.h"
#include "privinc/dddevice.h"
#include "privinc/error.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/resource.h"


DibImageClass::DibImageClass(HBITMAP hbm,
                             COLORREF colorRef,
                             Real resolution)
{
    if(resolution < 0) {
        _resolution = ViewerResolution();
    } else {
        _resolution = resolution;
    }

    _noDib      = TRUE;
    _hbm        = hbm;
    _colorRef   = colorRef;

    TraceTag((tagDibImageInformative, "Dib Image %x has HBM %x and clrKey %x", this, _hbm, _colorRef));
    
    ConstructWithHBM();
    _noDib = FALSE;

    _2ndCkValid = false;
    _2ndClrKey  = 0xffffffff;
}


void
DibImageClass::ConstructWithHBM()
{
    BITMAP              bm;

    //
    // get size of the first bitmap.  assumption: all bitmaps are same size
    //
    GetObject(_hbm, sizeof(bm), &bm);      // get size of bitmap

    //
    // Set members
    //
    _width = bm.bmWidth;
    _height = bm.bmHeight;
    SetRect(&_rect, 0,0, _width, _height);
    
    TraceTag((tagDibImageInformative,
              "Dib %x NEW w,h = pixel: (%d, %d)",
              this, _width, _height));
    
    _membersReady=TRUE;
}

void DibImageClass::CleanUp()
{
    BOOL ret;
    if(_hbm) {
        TraceTag((tagGCMedia, "Dib Image %x deleting HBM %x", this, _hbm));
        ret = DeleteObject( _hbm );
        IfErrorInternal(!ret, "Could not delete hbm in dibImageClass destructor");
        DiscreteImageGoingAway(this);
    }
}


Bool
DibImageClass::DetectHit(PointIntersectCtx& ctx)
{
    // Check to see if the local point is in the bounding region.
    Point2Value *lcPt = ctx.GetLcPoint();

    if (!lcPt) return FALSE;    // singular transform
    
    if (BoundingBox().Contains(Demote(*lcPt))) {
        if (_colorRef != INVALID_COLORKEY) {
            // TODO: the device should be part of the point intersect
            // context.  that should be set before we do picking.
            DirectDrawImageDevice *dev =
                GetImageRendererFromViewport( GetCurrentViewport() );
            
            DDSurface *ddSurf = dev->LookupSurfaceFromDiscreteImage(this);
            if(!ddSurf) return FALSE;

            LPDDRAWSURFACE surface = ddSurf->IDDSurface();
            if(!surface) return FALSE;


            HDC hdc;
            COLORREF clr;
            hdc = ddSurf->GetDC("Couldn't get DC for DibImageClass::detectHit for dib");

            if(hdc) {

                // color key is set, see if hit is a transparent pixel.
                POINT pt;
                CenteredImagePoint2ToPOINT(lcPt, _width, _height, &pt);

                clr = GetPixel(hdc, pt.x, pt.y);
                ddSurf->ReleaseDC("couldn't releaseDC for DibImageClass::detectHit");
                return clr != _colorRef;
            } else {
                TraceTag((tagError, "Couldn't get DC on surface for DetectHit for transparent dib"));
                return FALSE;
            }
        } else
            return TRUE;
    } else 
        return FALSE;
}


void
DibImageClass::InitIntoDDSurface(DDSurface *ddSurf,
                                 ImageDisplayDev *dev)
{
    Assert( !_noDib && "There's no dib available in InitIntoSurface");
    Assert(_hbm && "No HBM in DibImageClass for InitIntoSurface");

    Assert( ddSurf->IDDSurface() );
    
    if( FAILED( ddSurf->IDDSurface()->Restore() ) ) {
        RaiseException_InternalError("Restore on ddSurf in DibImageClass::InitIntoDDSurface");
    }
    
    HRESULT ddrval = DDCopyBitmap(ddSurf->IDDSurface(), _hbm, 0, 0, 0, 0);
    TraceTag((tagDibImageInformative, "Dib %x Copied _hbm %x to surface %x", this, _hbm, ddSurf->IDDSurface()));
    IfDDErrorInternal(ddrval, "Couldn't copy bitmap to surface in DibImage");

    // Turn the colorkey into the physical color that it actually got
    // mapped to.  TODO: Note that if multiple views share this
    // object, the last one will be the one that wins.  That is, if
    // there are multiple physical colors that this gets mapped to
    // through different views, only one (the last one) will be
    // recorded.  
    if (_colorRef != INVALID_COLORKEY) {

        HDC hdc;
        if (ddSurf->IDDSurface()->GetDC(&hdc) == DD_OK) {
            DWORD oldPixel = GetPixel(hdc, 0, 0);
            SetPixel(hdc, 0, 0, _colorRef); // put in
            _colorRef = GetPixel(hdc, 0, 0); // pull back out
            SetPixel(hdc, 0, 0, oldPixel);
            ddSurf->IDDSurface()->ReleaseDC(hdc);
        }
        
    }
}



//////////////////////////////////////////
// IMPORT DIB.  Return NULL if no match for the filename. 
//////////////////////////////////////////

Image **
ReadDibForImport(char *urlPathname,
                 char *cachedFilename,
                 IStream * pstream,
                 bool useColorKey,
                 BYTE ckRed,
                 BYTE ckGreen,
                 BYTE ckBlue,
                 int *count,
                 int **delays,
                 int *loop)
{
    TraceTag((tagImport, "Read Image file %s for URL %s",
              cachedFilename,
              urlPathname));

    // Allocations below assume current heap is GC heap.
    Assert(&GetHeapOnTopOfStack() == &GetGCHeap());

    HBITMAP *bitmapArray = NULL;
    COLORREF *colorKeys = NULL;
    Image **imArr = NULL;         

    bitmapArray = UtilLoadImage(cachedFilename, 
                                pstream,
                                0, 0,
                                &colorKeys, 
                                count,
                                delays,
                                loop);
    if (!bitmapArray) {
        imArr = (Image **)AllocateFromStore(sizeof(Image **));
        *imArr = PluginDecoderImage(urlPathname,
                                    cachedFilename,
                                    pstream,
                                    useColorKey,
                                    ckRed,
                                    ckGreen,
                                    ckBlue);
        if (*imArr == NULL) {
            delete imArr;
            imArr = NULL;
        }
        else {
            *count = 1;
        }
    }
    else {
        Assert((*count > 0) && "Bad bitmapCount in ReadDibForImaport");

        COLORREF userColorRef = useColorKey ? 
            RGB(ckRed, ckGreen, ckBlue) : INVALID_COLORKEY;        

        imArr = (Image **)AllocateFromStore((*count) * sizeof(Image **));
        for(int i=0; i < *count; i++) {
            // If the file itself didn't provide us with a color key, and one
            // is specified, use it.
            COLORREF curColorRef;
            if(colorKeys) {
                curColorRef = (colorKeys[i] != -1) ? colorKeys[i] : userColorRef;            
            }
            else 
                curColorRef = userColorRef;
            
            imArr[i] = NEW DibImageClass(bitmapArray[i],curColorRef);
        }

        if (colorKeys)
            StoreDeallocate(GetGCHeap(), colorKeys);

        if (bitmapArray)
            StoreDeallocate(GetGCHeap(), bitmapArray);

    }

    TraceTag((tagImport, "Loaded %d hbms from file: %s", *count, cachedFilename));

    return imArr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\hatchimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of hatch image values

*******************************************************************************/

#include "headers.h"

#include "privinc/imagei.h"
#include "privinc/linei.h"
#include "privinc/polygon.h"
#include "privinc/colori.h"
#include "backend/values.h"
#include "privinc/path2i.h"

class Point2Value;
class Color;

Image *
ConstructHatch(int numLines, Real *pts, Color* lineClr, Real dt) {
    Image *hatch = emptyImage;
    LineStyle *ls = NEW LineColorStyleClass(lineClr, defaultLineStyle);
    for(int i=0; i<numLines*4; i+=4) {
      Path2 *ln = Line2(Point2(pts[i],pts[i+1]), 
                        Point2(pts[i+2],pts[i+3]) );
      hatch = Overlay( LineImageConstructor(ls, ln), hatch );
    }
    Point2 minPt(-.5*dt,-.5*dt),
           maxPt(.5*dt,.5*dt);

    return TileImage(CreateCropImage(minPt, maxPt, hatch));
}

Image *HatchHorizontal(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, .5*dt, dt, .5*dt, -dt, -.5*dt, dt, -.5*dt } ; 
    return ConstructHatch(2, pts, lineClr, dt);
}

Image *HatchVertical(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -.5*dt, -dt, -.5*dt, dt, .5*dt, -.5*dt, .5*dt, .5*dt } ; 
    return ConstructHatch(2, pts, lineClr, dt);
}

Image *HatchForwardDiagonal(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, -dt, dt, dt, 0, dt, -dt, 0, dt, 0, 0, -dt } ; 
    return ConstructHatch(2, pts, lineClr, dt);
}

Image *HatchBackwardDiagonal(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, dt, dt, -dt, 0, dt, dt, 0, -dt, 0, 0, -dt } ; 
    return ConstructHatch(2, pts, lineClr, dt);
}

Image *HatchCross(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, .5*dt, dt, .5*dt, -dt, -.5*dt, dt, -.5*dt, 
                 -.5*dt, -dt, -.5*dt, dt, .5*dt, -.5*dt, .5*dt, .5*dt } ; 
    return ConstructHatch(4, pts, lineClr, dt);
}

Image *HatchDiagonalCross(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, dt, dt, -dt, 0, dt, dt, 0, -dt, 0, 0, -dt,  
                   -dt, -dt, dt, dt, 0, dt, -dt, 0, dt, 0, 0, -dt } ; 
    return ConstructHatch(4, pts, lineClr, dt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\geomimg.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Implements the projected geometry class.

*******************************************************************************/

#include <headers.h>
#include "privinc/imgdev.h"
#include "privinc/geomimg.h"
#include "privinc/dispdevi.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"
#include "appelles/geom.h"
#include "privinc/ddrender.h"
#include "privinc/geomi.h"
#include "privinc/opt.h"
#include "privinc/probe.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/bbox3i.h"
#include "privinc/camerai.h"
#include "privinc/except.h"
#include "privinc/dddevice.h"
#include "privinc/d3dutil.h"
#include "privinc/tls.h"

//////////////  Image from projected geometry  ////////////////////

ProjectedGeomImage::ProjectedGeomImage(Geometry *g, Camera *cam) :
    _geo(g), _camera(cam), _bbox(NullBbox2), _bboxIsSet(false)
{
    // Propagate external changers into images
    if (g->GetFlags() & GEOFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT) {
        _flags |= IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT;
    }

    // And opacity
    if (g->GetFlags() & GEOFLAG_CONTAINS_OPACITY) {
        _flags |= IMGFLAG_CONTAINS_OPACITY;
    }
}


void
ProjectedGeomImage::Render(GenericDevice& _dev)
{
    if(_dev.GetDeviceType() != IMAGE_DEVICE)
       return; // nothing to do here, no reason to traverse

    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);

    dev.RenderProjectedGeomImage(this, _geo, _camera);
}



/*****************************************************************************
Compute the 2D bounding box of projected geometry.  Note that this actually
computes the bounding box of the projected geometry's 3D bounding box, so
there may be a considerable amount of "slop" around the 3D object.
*****************************************************************************/

static int neighbor[8][3] =               //  3---7    Bbox Vertex Neighbors
{   {1,2,4}, {0,3,5}, {0,3,6}, {1,2,7},   // 2---6|
    {0,5,6}, {1,4,7}, {2,4,7}, {3,5,6}    // |1--|5    Index 1: Vertex
};                                        // 0---4     Index 2: Neighbor[0..2]

    // Returns true if the point is behind the image plane (other side of the
    // projection point).  Recall that camera coordinates are left-handed.

static inline int BehindImagePlane (bool right_handed, Point3Value *p)
{
    return (right_handed == (p->z < 0));
}

    // Calculate the intersection of the line between the two points and the
    // image (Z=0) plane.  Augment the bounding box with this intersection.

static void AddZ0Intersect (Bbox2 &bbox,Real Sx,Real Sy, Point3Value *P, Point3Value *Q)
{
    Real t = P->z / (P->z - Q->z);       // Get the intersection point from
    Real x = P->x + t*(Q->x - P->x);     // P to Q with the Z=0 plane.
    Real y = P->y + t*(Q->y - P->y);
    bbox.Augment (x/Sx, y/Sy);
}


const Bbox2 ProjectedGeomImage::BoundingBox (void)
{
    if ( !_bboxIsSet )
    {
        Real sx, sy;     // Camera X/Y Scaling Factors
        _camera->GetScale (&sx, &sy, 0);

        // Generate the eight corner vertices of the 3D bounding box.  Though
        // the bounding box is axis-aligned in world coordinates, this may not
        // be true for camera coordinates.

        Bbox3  *vol = _geo->BoundingVol();

        if (vol->Positive()) {
            
            Point3Value *vert[8];

            vert[0] = NEW Point3Value (vol->min.x, vol->min.y, vol->min.z);
            vert[1] = NEW Point3Value (vol->min.x, vol->min.y, vol->max.z);
            vert[2] = NEW Point3Value (vol->min.x, vol->max.y, vol->min.z);
            vert[3] = NEW Point3Value (vol->min.x, vol->max.y, vol->max.z);
            vert[4] = NEW Point3Value (vol->max.x, vol->min.y, vol->min.z);
            vert[5] = NEW Point3Value (vol->max.x, vol->min.y, vol->max.z);
            vert[6] = NEW Point3Value (vol->max.x, vol->max.y, vol->min.z);
            vert[7] = NEW Point3Value (vol->max.x, vol->max.y, vol->max.z);

            // Transform the eight corner vertices to camera coordinates.

            int i;

            Transform3 *wToC = _camera->WorldToCamera();
            if (!wToC) {
                return NullBbox2;
            }
        
            Point3Value *xVert[8];
            for (i=0;  i < 8;  ++i)
                xVert[i] = TransformPoint3 (wToC, vert[i]);

            // Now find the intersection of the line from the camera projection
            // point to each corner vertex on the other side of the image plane.
            // If a vertex is on the same side as the projection point, then we
            // use instead the intersection points of the three edges emanating
            // from that vertex.  The bounding box of these intersection points
            // will be the bounding box for the projected geometry image.

            bool right_handed = (GetD3DRM3() != 0);
            for (i=0;  i < 8;  ++i)
              {
                  if (BehindImagePlane (right_handed, xVert[i]))
                    {
                        Point2 projPt = Demote(*(_camera->Project(vert[i])));
                        _bbox.Augment(projPt.x,projPt.y);
                    }
                  else
                    {
                        if (BehindImagePlane (right_handed, xVert[neighbor[i][0]]))
                            AddZ0Intersect (_bbox,sx,sy, xVert[i], xVert[neighbor[i][0]]);

                        if (BehindImagePlane (right_handed, xVert[neighbor[i][1]]))
                            AddZ0Intersect (_bbox,sx,sy, xVert[i], xVert[neighbor[i][1]]);

                        if (BehindImagePlane (right_handed, xVert[neighbor[i][2]]))
                            AddZ0Intersect (_bbox,sx,sy, xVert[i], xVert[neighbor[i][2]]);
                    }
              }

        } else {

            _bbox = NullBbox2;
            
        }

        _bboxIsSet = true;
    }

    return _bbox;
}



/*****************************************************************************
To pick a projected geometry image, fire a picking ray through the camera into
the scene defined by the geometry.
*****************************************************************************/

Bool ProjectedGeomImage::DetectHit (PointIntersectCtx& context2D)
{
    RayIntersectCtx context3D;

    bool result = false;

    if (context3D.Init (context2D, _camera, _geo))
    {
        _geo->RayIntersect (context3D);
        result = context3D.ProcessEvents();
    }

    return result;
}



Image *RenderImage (Geometry *geo, Camera *cam)
{
    return NEW ProjectedGeomImage (geo, cam);
}

int ProjectedGeomImage::Savings(CacheParam& p)
{
    if (GetThreadLocalStructure()->_geometryBitmapCaching == PreferenceOff) {
        return 0;
    } else {
        return 5;
    }
}

AxAValue
ProjectedGeomImage::_Cache(CacheParam &p)
{
    _geo = SAFE_CAST(Geometry *, AxAValueObj::Cache(_geo, p));
    return this;
}


void ProjectedGeomImage::DoKids(GCFuncObj proc)
{ 
    Image::DoKids(proc);
    (*proc)(_geo);
    (*proc)(_camera);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\gradimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of gradient image values

*******************************************************************************/

#include "headers.h"

#include "privinc/imagei.h"
#include "privinc/polygon.h"
#include "privinc/colori.h"
#include "privinc/vec2i.h"
#include "privinc/bbox2i.h"
#include "privinc/GradImg.h"
#include "backend/values.h"

#define  USE_RADIAL_GRADIENT_RASTERIZER 0

class Point2Value;
class Color;

const Real SMALLNUM = 1.0e-10;

class GradientImage : public Image {

    friend Image *NewGradientImage(
        int numPts,
        Point2Value **pts,
        Color **clrs);

  private:
    GradientImage() {
        _flags |= IMGFLAG_CONTAINS_GRADIENT;
    }

    void PostConstructorInitialize(
        int numPts,
        Point2Value **pts,
        Color **clrs)
    {
        _numPts = numPts;
        _pts = pts;
        _clrs = clrs;
        _polygon = NewBoundingPolygon();
        _polygon->AddToPolygon(_numPts, _pts);
    }
    
  public:
    void Render(GenericDevice& dev) {
        ImageDisplayDev &idev = SAFE_CAST(ImageDisplayDev &, dev);
        idev.RenderGradientImage(this, _numPts, _pts, _clrs);
    }
        
    
    const Bbox2 BoundingBox(void) {
        return _polygon->BoundingBox();
    }

    #if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return _polygon->BoundingBoxTighter(bbctx);
    }
    #endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {
        return box;
    }

    // Process an image for hit detection
    Bool  DetectHit(PointIntersectCtx& ctx) {
        Point2Value *lcPt = ctx.GetLcPoint();

        if (!lcPt) return FALSE;        // singular transform

        return _polygon->PtInPolygon(lcPt);
    }

    int Savings(CacheParam& p) { return 2; }
    
#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "GradientImage"; }
#endif
    
    virtual void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
        (*proc)(_polygon);
        for (int i=0; i<_numPts; i++) {
            (*proc)(_pts[i]);
            (*proc)(_clrs[i]);
        }
    }

  private:
    int _numPts;
    BoundingPolygon *_polygon;
    Point2Value **_pts;
    Color **_clrs;
};

//
// helper function to create a gradient image and initialize it
// the right way.  Note that PostConstructorInitialize can raise and exception
//
Image *NewGradientImage(
    int numPts,
    Point2Value **pts,
    Color **clrs)
{
    GradientImage *gi = NEW GradientImage;
    gi->PostConstructorInitialize(numPts, pts, clrs);
    return gi;
}
    



//
// helper function to create a gradient image and initialize it
// the right way.  Note that PostConstructorInitialize can raise and exception
//
Image *NewMulticolorGradientImage(
    int numOffsets,
    double *offsets,
    Color **clrs,
    MulticolorGradientImage::gradientType type)
{
    MulticolorGradientImage *gi = NULL;
    
    switch( type ) {
      case MulticolorGradientImage::radial:
        gi = NEW RadialMulticolorGradientImage;
        break;
      case MulticolorGradientImage::linear:
        gi = NEW LinearMulticolorGradientImage;
        break;
      default:
        Assert(!"Error gradient type");
    }
    
    gi->PostConstructorInitialize(numOffsets, offsets, clrs);
    return gi;
}
    


Image *GradientPolygon(AxAArray *ptList, AxAArray *clrList)
{
    int numPts = ptList->Length();

    if(numPts < 3)
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_NOT_ENOUGH_PTS_3);

    if(numPts != clrList->Length())
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_ARRAY_MISMATCH);
    
    Point2Value **pts = (Point2Value **)AllocateFromStore((numPts) * sizeof(Point2Value *));
    for (int i = 0; i < numPts; i++) 
        pts[i] = (Point2Value *)(*ptList)[i];

    Color **clrs = (Color **)AllocateFromStore((numPts) * sizeof(Color *));
    for (i = 0; i < numPts; i++)
        clrs[i] = (Color *)(*clrList)[i];

    // TODO: It should use AxAArray directly...
    return NewGradientImage(numPts, pts, clrs);
}

Image *RadialGradientPolygon(Color *inner, Color *outer, 
                             DM_ARRAYARG(Point2Value*, AxAArray*) points, AxANumber *fallOff)
{
    #if USE_RADIAL_GRADIENT_RASTERIZER
    double *offs = (double *)AllocateFromStore(2*sizeof(double));
    offs[0] = 0.0; offs[1] = 1.0;
    Color **clrs =  (Color **)AllocateFromStore(2*sizeof(Color *));
    clrs[0] = inner; clrs[1]= outer;
    return NewMulticolorGradientImage(2, offs, clrs);
    #endif
    
    
    int numPts = points->Length();
    int i;
    Image *shape = emptyImage;

    // Calculate the boundingBox of the array of points.  This
    // wouldn't be necessary if we we being passed a path, since we would have the Bbox.
    Real maxX, maxY, minX, minY;
    for(i=0; i<numPts; i++) {
        Real cX = ((Point2Value *)(*points)[i])->x;
        Real cY = ((Point2Value *)(*points)[i])->y;
        if (i == 0) {
            minX = cX;
            minY = cY;
            maxX = cX;
            maxY = cY;
        } else {
            minX = (cX < minX) ? cX : minX;
            minY = (cY < minY) ? cY : minY;
            maxX = (cX > maxX) ? cX : maxX;
            maxY = (cY > maxY) ? cY : maxY;
        }
    }
    Point2Value *origin = NEW Point2Value((minX+maxX)/2,(minY+maxY)/2);

    for(i=0; i<numPts; i++) {
        // TODO: Consider moving these out into more static storage, so
        // they are not allocated every time we construct one of these.
        Point2Value **pts = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
        
        pts[0] = origin;
        pts[1] = (Point2Value *)(*points)[i];       
        pts[2] = (Point2Value *)(*points)[(i+1)%numPts];

        Color **clrs = (Color **)AllocateFromStore(3 * sizeof(Color *));    
        clrs[0] = inner;
        clrs[1] = outer;
        clrs[2] = outer;

        shape = Overlay(shape, NewGradientImage(3, pts, clrs));
    }
    return shape;
}

Image *
GradientSquare(Color *lowerLeft,
               Color *upperLeft,
               Color *upperRight,
               Color *lowerRight)
{
    // This creates a unit-sized square, centered at the origin.
    
    // TODO: Consider moving these out into more static storage, so
    // they are not allocated every time we construct one of these.
    Point2Value **p1 = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
    Point2Value **p2 = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
    Point2Value **p3 = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
    Point2Value **p4 = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
    p1[0] = p2[0] = p3[0] = p4[0] = origin2;
    p1[1] = p4[2] = NEW Point2Value(-0.5, -0.5);
    p1[2] = p2[1] = NEW Point2Value(-0.5,  0.5);
    p2[2] = p3[1] = NEW Point2Value(0.5, 0.5);
    p3[2] = p4[1] = NEW Point2Value(0.5, -0.5);

    Color **c1 = (Color **)AllocateFromStore(3 * sizeof(Color *));
    Color **c2 = (Color **)AllocateFromStore(3 * sizeof(Color *));
    Color **c3 = (Color **)AllocateFromStore(3 * sizeof(Color *));
    Color **c4 = (Color **)AllocateFromStore(3 * sizeof(Color *));
    
    // This first color is the bilinear average of the others.
    Real r = (lowerLeft->red + upperLeft->red +
              upperRight->red + lowerRight->red) / 4.0;
    
    Real g = (lowerLeft->green + upperLeft->green +
              upperRight->green + lowerRight->green) / 4.0;
    
    Real b = (lowerLeft->blue + upperLeft->blue +
              upperRight->blue + lowerRight->blue) / 4.0;
    Color *mid =  NEW Color(r, g, b);
    
    c1[0] = c2[0] = c3[0] = c4[0] = mid;
    c1[1] = c4[2] = lowerLeft;
    c1[2] = c2[1] = upperLeft;
    c2[2] = c3[1] = upperRight;
    c3[2] = c4[1] = lowerRight;

    Image *t1 = NewGradientImage(3, p1, c1);
    Image *t2 = NewGradientImage(3, p2, c2);
    Image *t3 = NewGradientImage(3, p3, c3);
    Image *t4 = NewGradientImage(3, p4, c4);
    
    return Overlay(t1, Overlay(t2, Overlay(t3, t4)));
}

Image *
GradientHorizontal(Color *start, Color *stop, AxANumber *fallOff)
{    
    // TODO: IHammer code integration will need to occur to do
    // nonlinear fallOff.  For now, we ignore the falloff and this
    // simply becomes a call to gradientSquare;
    return GradientSquare(start,start,stop,stop);
}

// Constructs a gradient square in which the color radiates linearly outward 
Image *
RadialGradientSquare(Color *inner, Color *outer, AxANumber *fallOff)
{
    #if USE_RADIAL_GRADIENT_RASTERIZER
    double *offs = (double *)AllocateFromStore(2*sizeof(double));
    offs[0] = 0.0; offs[1] = 1.0;
    Color **clrs =  (Color **)AllocateFromStore(2*sizeof(Color *));
    clrs[0] = inner; clrs[1]= outer;
    return NewMulticolorGradientImage(2, offs, clrs);
    #endif
    
    // TODO: IHammer code integration will need to occur to do
    // nonlinear fallOff.  For now, we ignore the falloff.

    // This creates a unit-sized square, centered at the origin.
    Image *square = emptyImage;
    for(int i=0; i<4; i++) {
        // TODO: Consider moving these out into more static storage, so
        // they are not allocated every time we construct one of these.
        Point2Value **pts = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
        pts[0] = origin2;
        pts[1] = NEW Point2Value(0.5, 0.5);
        pts[2] = NEW Point2Value(0.5, -0.5);

        Color **clrs = (Color **)AllocateFromStore(3 * sizeof(Color *));    
        clrs[0] = inner;
        clrs[1] = outer;
        clrs[2] = outer;
        Image *quad = TransformImage(RotateRealR(pi/2*i), 
            NewGradientImage(3, pts, clrs));
        square = Overlay( square, quad );        
    }
    return square;
}

// A fanned poly with specified number of outer edges to determine
// the tesselation.  The color at the center is specified in
// innerColor, and outerColor specifies the color at all of the outer
// vertices. NOTE: This is now an internal function only.
Image *
RadialGradientRegularPoly(Color *inner, Color *outer, 
                          AxANumber *numEdges, AxANumber *fallOff)
{
    #if USE_RADIAL_GRADIENT_RASTERIZER
    double *offs = (double *)AllocateFromStore(2*sizeof(double));
    offs[0] = 0.0; offs[1] = 1.0;
    Color **c =  (Color **)AllocateFromStore(2*sizeof(Color *));
    c[0] = inner; c[1]= outer;
    return NewMulticolorGradientImage(2, offs, c);
    #endif    
    
    
    // TODO: IHammer code integration will need to occur to do
    // nonlinear fallOff.  For now, we ignore the falloff.
    int numOuterPts = (int)(NumberToReal(numEdges) + 1);
    
    if(numOuterPts < 4)
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_NOT_ENOUGH_PTS_3);

    // TODO: Consider moving these out into more static storage, so
    // they are not allocated every time we construct one of these.
    Point2Value **pts = (Point2Value **)AllocateFromStore((numOuterPts + 1) *
                                                sizeof(Point2Value *));
    
    pts[0] = origin2;

    Real inc = (pi * 2.0) / (Real)(numOuterPts - 1);

    int i;
    Real ang;
    
    for (i = 0, ang = 0.0; i < numOuterPts; i++, ang += inc) {
        pts[i+1] = NEW Point2Value(.5*cos(ang), .5*sin(ang));
    }

    Color **clrs = (Color **)AllocateFromStore((numOuterPts + 1) *
                                               sizeof(Color *));
    clrs[0] = inner;
    for (i = 0; i < numOuterPts; i++) {
        clrs[i+1] = outer;
    }

    return NewGradientImage(numOuterPts + 1, pts, clrs);
}

Image *_RadialGradientMulticolor(AxAArray *offsets,
                                 AxAArray *colors,
                                 MulticolorGradientImage::gradientType type)                             
{
    int numOffsets = offsets->Length();
    Assert( numOffsets == colors->Length() );

    Color **clrs = (Color **)AllocateFromStore(numOffsets * sizeof(Color *));
    double *off  = (double *)AllocateFromStore(numOffsets * sizeof(double));
    for(int i=0; i<numOffsets; i++) {
        off[i] = ValNumber( (*offsets)[i] );
        clrs[i] = SAFE_CAST( Color *, (*colors)[i] );
        Assert(clrs[i]);
    }

    return NewMulticolorGradientImage(numOffsets, off, clrs, type);
}

Image *RadialGradientMulticolor(AxAArray *offsets, AxAArray *colors)
{
    return _RadialGradientMulticolor(offsets, colors, MulticolorGradientImage::radial);
}

Image *LinearGradientMulticolor(AxAArray *offsets, AxAArray *colors)
{
    return _RadialGradientMulticolor(offsets, colors, MulticolorGradientImage::linear);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "privinc/server.h"
#include "privinc/imagei.h"
#include "privinc/probe.h"
#include "privinc/imgdev.h"
#include "privinc/except.h"
#include "privinc/transimg.h"


#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\matteimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Defines the "clipImage" operator which applies a matte to an
    image. 

*******************************************************************************/

#include "headers.h"

#include "privinc/imagei.h"
#include "privinc/mattei.h"
#include "privinc/imgdev.h"
#include "privinc/dddevice.h"
#include "privinc/polygon.h"
#include "privinc/matteimg.h"
#include "privinc/path2i.h"
#include "privinc/opt.h"

MatteImage::MatteImage(Matte *matte, Image *imgToStencil)
      : _matte(matte), AttributedImage(imgToStencil)
{

    Bbox2 box =
        IntersectBbox2Bbox2(_matte->BoundingBox(),
                            _image->BoundingBox());

    _box = box;
}

Bool   
MatteImage::DetectHit(PointIntersectCtx& ctx)
{
    DirectDrawImageDevice* ddDev = GetImageRendererFromViewport( GetCurrentViewport() );

    // Do trivial reject in Local Coordinates
    Point2Value *lcPt = ctx.GetLcPoint();
    if (!_box.Contains(Demote(*lcPt))) {
        return FALSE;
    }

    // Do actual picking in World Coordinates
    Point2Value *pt = ctx.GetWcPoint();

    //
    // Grab a DC for whatever surface the renderer deems correct
    //
    HDC hdc;
    hdc = ddDev->RenderGetDC("Couldn't get DC in MatteImage::DetectHit");
    if(!hdc) return FALSE;

    //
    // Accumulate the rgn in region for the given DC
    //
    HRGN region;
    bool justDoPath = false;
    Matte::MatteType result = 
        _matte->GenerateHRGN(hdc,
                             NULL,
                             NULL, 
                             ctx.GetTransform(),
                             &region,
                             justDoPath);

    // Using GetLcPoint and doing this would be ok too.  Greg thinks
    // it's lower risk to use the GetWcPoint as Steve suggested.  -RY
    //_matte->GenerateHRGN(hdc, identityTransform2, &region);
    
    GDI_Deleter regionDeleter((HGDIOBJ)region);

    //
    // Dump the DC, we don't need it
    //
    ddDev->RenderReleaseDC("Coultdn't release DC in MatteImage::Render");    

    switch (result) {
      case Matte::fullyOpaque:
      case Matte::fullyClear:

        switch (result) {
          case Matte::fullyOpaque:
            // Can't see anything through matte... go on.
            return FALSE; // XXX: hey, can you detect an opaque matte ?
            break;
            
          case Matte::fullyClear:
            return _image->DetectHit(ctx);
            break;
        }
        break;

      case Matte::nonTrivialHardMatte:

        // is the point in the region ?
        Bool hit =  ddDev->DetectHit(region, pt);

        if(hit) hit = _image->DetectHit(ctx);

        return hit;
        break;
    }

    return FALSE;
}


void
MatteImage::Render(GenericDevice& genDev)
{
    DirectDrawImageDevice& ddDev = SAFE_CAST(DirectDrawImageDevice &, genDev);

    // If we have a color key set, then turn on aa_solid and force
    // dagdi to raster using sample resolution of 1
    bool popQualFlags = false;
    DWORD oldQualFlags = ddDev.GetImageQualityFlags();
    int oldSampRes = ddDev.GetSampleResolution();
    if( ddDev.ColorKeyIsSet() ) {
        popQualFlags = true;
        ddDev.SetImageQualityFlags( oldQualFlags | CRQUAL_AA_SOLIDS_ON );
        ddDev.SetSampleResolution( 1 );
    }

    ddDev.RenderMatteImage(this, _matte, _image );

    if( popQualFlags ) {
        ddDev.SetImageQualityFlags( oldQualFlags );
        ddDev.SetSampleResolution( oldSampRes );
    }   
}

Real
MatteImage::DisjointBBoxAreas(DisjointCalcParam &param)
{
    DisjointCalcParam newParam;
    param.CalcNewParamFromBox(_matte->BoundingBox(), &newParam);

    return _image->DisjointBBoxAreas(newParam);
}

void
MatteImage::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    Bbox2 oldClipBox = ctx.GetClipBox();

    ctx.AccumulateClipBox(_matte->BoundingBox());

    CollectDirtyRects(_image, ctx);
    
    ctx.SetClipBox(oldClipBox);
}


Bool
MatteImage::RenderWithCallBack(
    callBackPtr_t callBack,
    void *callBackCtx,
    HRGN *regionPtr,
    Transform2 *xform,
    bool justDoPath)
{
    Assert(callBackCtx && "callBackCtx is NULL in RenderWithCallBack");

    //
    // Accumulate the rgn in region for the given DC
    //
    Matte::MatteType result = 
        _matte->GenerateHRGN(NULL,
                             callBack,
                             callBackCtx, 
                             xform, 
                             regionPtr,
                             justDoPath);

    if( justDoPath ) return TRUE;
    
    switch (result) {
        
      case Matte::fullyOpaque:
      case Matte::fullyClear:
        
        switch (result) {
          case Matte::fullyOpaque:
            // Can't see anything through matte... go on.
            break;
            
          case Matte::fullyClear:
            // Just process as if no stencil were there
            DirectDrawImageDevice* ddDev = 
                GetImageRendererFromViewport( GetCurrentViewport() );
            _image->Render(*ddDev);
            break;
        }

        Assert( !(*regionPtr) && "A region shouldn't be defined here!");

        return FALSE;
        break;

      case Matte::nonTrivialHardMatte:

        Assert( (*regionPtr) && "A region should be defined here!");
        break;
    }
    return TRUE;
}

Image *
ClipImage(Matte *m, Image *im)
{
    Image *result = NULL;
    
    if (m == clearMatte) {
        
        // entire im shines through clearMatte
        result = im;
        
    } else if (m == opaqueMatte || im == emptyImage) {
        
        // nothing gets through opaqueMatte
        result = emptyImage;
        
    } else {

        // Specialized optimization that rewrites a potentially 
        // transformed text-path based matte with a solid color image
        // into an StringImage.  You can think of this transformation
        // as going from:
        //
        //   MatteImage(MatteFromPath(TextPath(myText).Transform(myXf)),
        //              SolidColorImage(myColor)
        //
        // to
        //
        //   StringImage(myText.Color(myColor)).Transform(myXf)
        //

        if (im->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID)) {

            Path2 *p = m->IsPathRepresentableMatte();

            if (p) {
                
                Transform2 *xf = identityTransform2;
            
                TransformedPath2 *xfp = p->IsTransformedPath();

                if (xfp) {
                    // Just work on the raw path.
                    p = xfp->GetPath();
                    xf = xfp->GetXf();
                }

                // The underlying path had better not be a transformed
                // path.
                Assert(!p->IsTransformedPath());

                TextPath2 *tp = p->IsTextPath();
            
                if (tp) {

                    Text *text = tp->GetText();
                    bool  restartClip = tp->GetRestartClip();

                    // Can't do it if it's a restart clip... 
                    if (!restartClip) {

                        SolidColorImageClass *scImg =
                            SAFE_CAST(SolidColorImageClass *, im);

                        Color *col = scImg->GetColor();

                        Text *coloredText = TextColor(col, text);
                    
                        Image *newImg = RenderTextToImage(coloredText);

                        result = TransformImage(xf, newImg);

                    }

                }

            }
            
        }

        if (!result) {
        
            result = NEW MatteImage(m, im);

        }
    }

    return result;
}

int MatteImage::Savings(CacheParam& p) {

  //    return 0;   // disable caching of matted images because of off-by-one errors
// #if 0

    // individual matted solid color images themselves don't warrant
    // much of a score, but they should contribute so that overlays of
    // them can get a meaningful savings.
    
    if (_image->GetValTypeId() == SOLIDCOLORIMAGE_VTYPEID) {
        return 1;
    } else {
        return 2;
    }
    
// #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\movieimg.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

     Implements a movie (mpeg or avi) image

*******************************************************************************/

#include <headers.h>

#include "privinc/movieImg.h"
#include "privinc/imgdev.h"
#include "privinc/geomimg.h"
#include "privinc/dispdevi.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"
#include "privinc/ddrender.h"
#include "privinc/probe.h"
#include "privinc/camerai.h"
#include "privinc/except.h"
#include "privinc/dddevice.h"
#include "appelles/readobj.h"
#include "backend/moviebvr.h"
#include "privinc/urlbuf.h"
#include "privinc/bufferl.h"  // bufferElement db stuff

//////////////  Image from movie  ////////////////////
MovieImage::MovieImage(QuartzVideoReader *videoReader, Real res)
: _dev(NULL), _url(NULL)
{
    Assert(videoReader && "no movie class!");
    Assert(res>0 && "bad res for movie image");
    _resolution = res;
    _width  = videoReader->GetWidth();
    _height = videoReader->GetHeight();

    { // keep a copy the url so we may generate new streams later
        char *url = videoReader->GetURL();
        _url = (char *)StoreAllocate(GetSystemHeap(), strlen(url)+1);
        strcpy(_url, url);
    }

    SetRect(&_rect, 0,0, _width, _height);
    _membersReady = TRUE;

    _length = videoReader->GetDuration();

    TraceTag((tagGCMedia, "MovieImage(%x)::MovieImage stream %x",
              this, videoReader));
}


void MovieImage::CleanUp()
{
    StoreDeallocate(GetSystemHeap(), _url);

    // Why are we acquiring this lock?  Never acquire a lock and call
    // a function which may also acquire a lock.  This currently
    // causes deadlock in our system - not a good thing to do.
//    extern Mutex avModeMutex;
//    MutexGrabber mg(avModeMutex, TRUE); // Grab mutex

    DiscreteImageGoingAway(this);
} // end mutex context


MovieImageFrame::MovieImageFrame(Real time, MovieImagePerf *p)
: _perf(p), _time(time)
{
    _movieImage = _perf->GetMovieImage();
    _width      = _movieImage->GetPixelWidth();
    _height     = _movieImage->GetPixelHeight();
    _resolution = _movieImage->GetResolution();
    SetRect(&_rect, 0,0, _width, _height);
    _membersReady = TRUE;
}


void
MovieImageFrame::DoKids(GCFuncObj proc)
{
    DiscreteImage::DoKids(proc);
    (*proc)(_movieImage);
    (*proc)(_perf);
}


// --------------------------------------------------
// MOVIE IMAGE FRAME:  RENDER
// --------------------------------------------------
void
MovieImageFrame::Render(GenericDevice& _dev)
{
    if(_dev.GetDeviceType() != IMAGE_DEVICE)
        return; // no sound under images...

    bool forceFallback = false;  // force a fallback?

    TimeXform tt = _perf->GetTimeXform();

    if(!tt->IsShiftXform())
        forceFallback = true;   // fallback to non-retained mode!

    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);
    dev.StashMovieImageFrame(this);
    // we will probably pass the bufferElement to this call eventualy
    dev.RenderMovieImage(GetMovieImage(), GetTime(), _perf, forceFallback);
    dev.StashMovieImageFrame(NULL);
}


void
DirectDrawImageDevice::RenderMovieImage(MovieImage *movieImage,
                                        Real time,
                                        MovieImagePerf *perf,
                                        bool forceFallback,
                                        DDSurface *targDDSurf)
{
    QuartzVideoBufferElement *bufferElement = perf->GetBufferElement();
    SurfaceMap *surfMap = GetSurfaceMap();

    bool b8Bit = (_viewport.GetTargetBitDepth() == 8)?true:false;

    // Don't render to the same targDDSurf at the same time
    // more than once per frame!
    if(targDDSurf) {
        if(time == targDDSurf->GetTimeStamp())
            return;
        else
            targDDSurf->SetTimeStamp(time);
    }

    // since movies are emptyImage outside of defined time range (0,movieLength)
    // we only do the work for the defined range and do nothing otherwise!
    //if((time >= 0.0) && (time <= movieImage->GetLength())) {
    // as a work around for the texture image when end of movie bug, I am
    // just going to allow movies to go continue rendering
    if(1){
        bool           thisIsAnOldFrame = false;
        LPDDRAWSURFACE givenMovieSurf   = NULL;

        // Get the surface associated with this movie image
        DDSurfPtr<DDSurface> mvDDSurf = perf->GetSurface();

        if (bufferElement == NULL) {
            bufferElement = perf->GrabMovieCache();

            if (bufferElement == NULL) {
                QuartzVideoStream *quartzStream =
                    NEW QuartzVideoStream(movieImage->GetURL(),
                                          mvDDSurf,
                                          forceFallback);

                bufferElement =
                    NEW QuartzVideoBufferElement(quartzStream);
            }

            perf->SetBufferElement(bufferElement);
        }

        QuartzVideoReader *videoReader =
            bufferElement->GetQuartzVideoReader();

        if(forceFallback && (videoReader->GetStreamType()==AVSTREAM))
            videoReader = bufferElement->FallbackVideo(true, mvDDSurf); // seekable

        bufferElement->FirstTimeSeek(time);

        if(!mvDDSurf) { // not cached in the performance yet, (our first time!)
            _ddrval = videoReader->GetFrame(time, &givenMovieSurf); // get surf
            if(_ddrval == MS_S_ENDOFSTREAM) // XXX query reader instead?
                perf->TriggerEndEvent();
            if(!givenMovieSurf) {
                TraceTag((tagAVmodeDebug,
                          "RenderMovieImage discovered video gone FALLBACK!!"));

                // not seekable, no surface to re-use
                videoReader = bufferElement->FallbackVideo(false, NULL);

                _ddrval = videoReader->GetFrame(time, &givenMovieSurf);
                if(!givenMovieSurf)
                    return;  // XXX hack for now
            }

            // XXX remove the SafeToContinue code?
            bool safe = videoReader->SafeToContinue();
            if(!safe) {
                // XXX call something on the stream which causes audio
                //     to be disconnected!
            }
            if(FAILED(_ddrval))
                RaiseException_InternalError("Couldn't get movie frame");

            TraceTag((tagAVmodeDebug,
                      "creating new mvDDSurf with surface = %x", givenMovieSurf));

            NEWDDSURF(&mvDDSurf,
                      givenMovieSurf,
                      movieImage->BoundingBox(),
                      movieImage->GetRectPtr(),
                      GetResolution(),
                      0, false, false, true,
                      "MovieImage Surface");

            perf->SetSurface(mvDDSurf); // Stash movie surface in performance
        } else {
            if(forceFallback && (videoReader->GetStreamType()==AVSTREAM)) {
                // seekable, re-use surface
                videoReader = bufferElement->FallbackVideo(true, mvDDSurf);
            }

            // Try to get the current frame.
            // If it's not available, use whatever's in mvDDSurf

            // Re-use an equivalent movie img frame
            if(time==mvDDSurf->GetTimeStamp()) {
                thisIsAnOldFrame = true;
            } else {
                mvDDSurf->SetTimeStamp(time);
            }

            if(!thisIsAnOldFrame) {
                _ddrval = videoReader->GetFrame(time, &givenMovieSurf);
                if(_ddrval == MS_S_ENDOFSTREAM) // XXX query reader instead?
                    perf->TriggerEndEvent();
                if(!givenMovieSurf) {
                    TraceTag((tagAVmodeDebug,
                              "RenderMovieImage discovered video gone FALLBACK!!"));

                    videoReader = bufferElement->FallbackVideo(false, mvDDSurf);
                    _ddrval = videoReader->GetFrame(time, &givenMovieSurf);
                }

                bool safe = videoReader->SafeToContinue();
                if(!safe) {
                    // XXX call something on the stream which causes audio
                    //     to be disconnected!
                }
                if(FAILED(_ddrval))  {
                    if(!mvDDSurf->IDDSurface())
                        RaiseException_InternalError("Couldn't get movie frame");
                    else
                        givenMovieSurf = mvDDSurf->IDDSurface();
                }
            }
        }

        if(!thisIsAnOldFrame) {

            // if we're paletized, convert the movie to our
            // palette
            if(b8Bit) {
                // make sure we have one stashed in mvDDSurf
                DAComPtr<IDDrawSurface> convSurf = mvDDSurf->ConvertedSurface();
                if(!convSurf) {

                    // Ok, create an identical surface and pass it
                    // on as the real thing.

                    _viewport.CreateOffscreenSurface(&convSurf,
                                                     _viewport.GetTargetPixelFormat(),
                                                     mvDDSurf->Width(),
                                                     mvDDSurf->Height());

                    _viewport.AttachCurrentPalette(convSurf);

                    mvDDSurf->SetConvertedSurface(convSurf); // stick in mvDDSurf
                }

                {
#define KEEP_FOR_DX5 0
#if KEEP_FOR_DX5
                    // convert
                    RECT rect = *(mvDDSurf->GetSurfRect());
                    HDC srcDC = mvDDSurf->GetDC("couldn't getDC for movie surf conversion (Src)");

                    HDC destDC; _ddrval = convSurf->GetDC(&destDC);
                    IfDDErrorInternal(_ddrval, "couldn't getDC for movie surf conversion (dest)");

                    int ret;
                    TIME_GDI(ret = StretchBlt(destDC,
                                              rect.left,
                                              rect.top,
                                              rect.right - rect.left,
                                              rect.bottom - rect.top,
                                              srcDC,
                                              rect.left,
                                              rect.top,
                                              rect.right - rect.left,
                                              rect.bottom - rect.top,
                                              SRCCOPY));
                    convSurf->ReleaseDC(destDC);
                    mvDDSurf->ReleaseDC("");
#endif // KEEP_FOR_DX5
                }

                {
#define CONVERT2 1
#if CONVERT2
                    //
                    // convert
                    //
                    IDDrawSurface *srcSurf = mvDDSurf->IDDSurface();

                    RECT rect = *(mvDDSurf->GetSurfRect());

                    HDC destDC; _ddrval = convSurf->GetDC(&destDC);
                    IfDDErrorInternal(_ddrval, "couldn't getDC for movie surf conversion (dest)");

                    LONG w = rect.right - rect.left;
                    LONG h = rect.bottom - rect.top;

                    struct {
                        BITMAPINFO b;
                        char foo[4096];  // big enough!
                    } bar;

                    bar.b.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                    bar.b.bmiHeader.biWidth = w; // reset below to pitch
                    bar.b.bmiHeader.biHeight = -h; // top down dib
                    bar.b.bmiHeader.biPlanes = 1;
                    bar.b.bmiHeader.biBitCount = 8;
                    bar.b.bmiHeader.biCompression = BI_RGB;
                    bar.b.bmiHeader.biSizeImage = 0;
                    bar.b.bmiHeader.biXPelsPerMeter =0;
                    bar.b.bmiHeader.biYPelsPerMeter = 0;
                    bar.b.bmiHeader.biClrUsed = 256;
                    bar.b.bmiHeader.biClrImportant = 0;

                    // Get palette
                    LPDIRECTDRAWPALETTE pal;
                    _ddrval = srcSurf->GetPalette( &pal );
                    IfDDErrorInternal(_ddrval, "can't get palette man");

                    PALETTEENTRY entries[256];
                    _ddrval = pal->GetEntries(0, 0, 256, entries);
                    IfDDErrorInternal(_ddrval, "GetEntries faild on palette in RenderMovie");
                    pal->Release();

                    RGBQUAD *quads = bar.b.bmiColors;
                    for( int i = 0; i < 256; i++ )
                      {
                          quads[i].rgbBlue = entries[i].peBlue;
                          quads[i].rgbGreen = entries[i].peGreen;
                          quads[i].rgbRed = entries[i].peRed;
                          quads[i].rgbReserved = 0;
                      }


                    // LOCK SRC SURFACE
                    DDSURFACEDESC srcDesc;
                    srcDesc.dwSize = sizeof(DDSURFACEDESC);
                    _ddrval = srcSurf->Lock(NULL, &srcDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
                    if(_ddrval != DD_OK) {  convSurf->ReleaseDC(destDC);}
                    IfDDErrorInternal(_ddrval, "Can't Get destSurf lock for AlphaBlit");

                    void *srcp = srcDesc.lpSurface;
                    long srcPitch = srcDesc.lPitch;

                    bar.b.bmiHeader.biWidth = srcPitch;

                    //  B L I T    B L I T
                    SetMapMode(destDC, MM_TEXT);

                    int ret;
                    ret = StretchDIBits(destDC,
                                        rect.left, rect.top, w, h,
                                        rect.left, rect.top, w, h,
                                        srcp,
                                        &bar.b,
                                        DIB_RGB_COLORS,
                                        SRCCOPY);
#if _DEBUG
                    if(ret==GDI_ERROR) {
                        void *msgBuf;
                        FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            GetLastError(),
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPTSTR) &msgBuf,
                            0,
                            NULL );

                        AssertStr(false, (char *)msgBuf);

                        LocalFree( msgBuf );
                    }
#endif

                    srcSurf->Unlock(srcp);
                    convSurf->ReleaseDC(destDC);

                    if(ret==GDI_ERROR) {
                        RaiseException_InternalError("StretchDIBits failed (movie 8bpp color conversion)");
                    }

#endif // convert2

                } // convert2

            }
        }

        DebugCode(
            if(givenMovieSurf) {
                // make sure the stashed surface is the same as the givensurf
                Assert((mvDDSurf->IDDSurface() == givenMovieSurf) &&
                       "Given movie surface not equal for formerly stashed surface!");
            }
            );

        IDDrawSurface *tmpSurf = NULL;
        if(b8Bit) {
            // swap surfaces.
            tmpSurf = mvDDSurf->IDDSurface();
            mvDDSurf->SetSurfacePtr( mvDDSurf->ConvertedSurface() );
        }

        if(targDDSurf) {
            // target surface has been specified.  render there to fill target
            TIME_DDRAW(targDDSurf->
                       Blt(targDDSurf->GetSurfRect(),
                           mvDDSurf, mvDDSurf->GetSurfRect(),
                           DDBLT_WAIT, NULL));
        } else { // Now that we have movie in mvDDSurf, render it like a dib...
            // Push the image onto the map
            surfMap->StashSurfaceUsingImage(movieImage, mvDDSurf); // Stash movie surface in performance
            RenderDiscreteImage(movieImage);
            surfMap->DeleteMapEntry(movieImage);  // XXX Pop it back off again!
        }


        if( tmpSurf ) { // replace surfaces
            mvDDSurf->SetConvertedSurface( mvDDSurf->IDDSurface() );
            mvDDSurf->SetSurfacePtr( tmpSurf );
        }

        // implicit release of mvDDSurf reference
    }   // end of movie defined
    else { // we are out of the defined range of the movie
        // check to see if we were playing.  If so send a trigger event
        if(0)
            perf->TriggerEndEvent();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\opaqeimg.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of an OpaqueImage, subclass
    of Image.

--*/

#include "headers.h"
#include <privinc/imagei.h>
#include <privinc/imgdev.h>

//
// yup, the OpaqueImageClass is in imagei.h
//

Image *OpaqueImage(AxANumber *opacity, Image *image)
{
   return NEW OpaqueImageClass(NumberToReal(opacity), image);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\overimg.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

-------------------------------------*/

#include "headers.h"

#include "privinc/overimg.h"
#include "privinc/dddevice.h"
#include "privinc/imgdev.h"
#include "privinc/cachdimg.h"
#include "privinc/cropdimg.h"
#include "privinc/opt.h"


// Put anything that extends to binary and n-ary aggregators
// here.
const DWORD aggregatingFlags =
                IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT |
                IMGFLAG_CONTAINS_OPACITY |
                IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX |
                IMGFLAG_CONTAINS_GRADIENT;



bool
DoesUnionSaveArea(Image *img)
{
    // Here, we take the disjoint bbox areas and check against
    // them (no fair counting open space in overlays)
    DisjointCalcParam p;
    p._accumXform = identityTransform2;
    p._accumulatedClipBox = UniverseBbox2;
    
    Real disjointArea = img->DisjointBBoxAreas(p);

    Real unionArea = img->BoundingBox().Area();

    // As long as the area of the union is within some factor
    // (larger than 1) of the sum of the areas, then the union is
    // considered to save area over the individual ones.  The factor
    // is > 1, because there are some economies gained by doing a
    // large one once rather than a bunch of small ones.
    const Real fudgeFactor = 1.50;

    return (unionArea < fudgeFactor * disjointArea);
}

bool
ShouldOverlayBeCached(Image *img, CacheParam& p)
{
    // Determine if we want to cache an overlay itself.  We do if

    // a) the area of the union of the bbox is within some constant
    //    factor of the sum of the areas of the individuals.
    // b) the sum of the caching savings of the two is beyond our
    //    acceptance threshold.
    // c) the overlay doesn't claim that it shouldn't be cached.

    DynamicHeapPusher h(GetTmpHeap());

    bool cacheOverlay = false;
    if (img->Savings(p) >= savingsThreshold) {
        cacheOverlay = DoesUnionSaveArea(img);
    }

    ResetDynamicHeap(GetTmpHeap());

    return cacheOverlay;
}


bool
ShouldTraverseSeparately(Image *img, DirtyRectCtx& ctx)
{
    bool traverseSeparately;
    int oldId = img->GetOldestConstituentID();
    
    if ((oldId != PERF_CREATION_ID_BUILT_EACH_FRAME &&
         oldId < ctx._lastSampleId) ||
        (img->GetFlags() & IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX)) {

        // This means that some of our elements are constant with
        // respect to the previous rendering or we have an
        // unrenderable image in the tree that has a bbox that we
        // don't want to include.  In these cases, traverse
        // separately.
        traverseSeparately = true;

    } else {

        traverseSeparately = false;
        // Everything is new.  Traverse separately only if there's a
        // pixel-area coverage savings in doing so.
        if (DoesUnionSaveArea(img)) {
            traverseSeparately = false;
        } else {
            traverseSeparately = true;
        }
        
    }

    return traverseSeparately;
}

OverlayedImage::OverlayedImage(Image *top, Image *bottom)
{
    _top = top;
    _bottom = bottom;
    _cached = false;
    _cachedDisjointArea = -1.0;
    
    _containsOcclusionIgnorer =
        _top->ContainsOcclusionIgnorer() ||
        _bottom->ContainsOcclusionIgnorer();

    _flags |= IMGFLAG_CONTAINS_OVERLAY;

    DWORD mask = _top->GetFlags() & aggregatingFlags;
    _flags |= mask;

    mask = _bottom->GetFlags() & aggregatingFlags;
    _flags |= mask;
    
    long tid = _top->GetOldestConstituentID();
    long bid = _bottom->GetOldestConstituentID();

    if (tid == PERF_CREATION_ID_BUILT_EACH_FRAME) {
        _oldestConstituentSampleId = bid;
    } else if (bid == PERF_CREATION_ID_BUILT_EACH_FRAME) {
        _oldestConstituentSampleId = tid;
    } else {
        _oldestConstituentSampleId = MIN(tid, bid);
    }
}

void OverlayedImage::Render(GenericDevice& dev)
{
    OverlayPairRender(_top, _bottom, dev);
}

// An overlaid image's bbox is the union of the two component
// bboxes.  TODO:  This could be computed lazily and stashed.
const Bbox2 OverlayedImage::_BoundingBox()
{
    return UnionBbox2Bbox2(_top->BoundingBox(),
                           _bottom->BoundingBox());
}

Real
OverlayedImage::DisjointBBoxAreas(DisjointCalcParam &param)
{
    if (_cachedDisjointArea < 0) {
        // For an overlay, sum the areas of the indiv. bboxes. 
        Real topArea = _top->DisjointBBoxAreas(param);
        Real botArea = _bottom->DisjointBBoxAreas(param);

        _cachedDisjointArea = topArea + botArea;
    }

    return _cachedDisjointArea;
}

void
OverlayedImage::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    bool traverseSeparately = ShouldTraverseSeparately(this, ctx); 

    if (traverseSeparately) {
        // Collect from bottom up, since order of insertion matters
        // for determining whether images switched layers.
        CollectDirtyRects(_bottom, ctx);
        CollectDirtyRects(_top, ctx);
    } else {
        // Just add this whole overlay as a single dirty rect.
        Bbox2 xformedBbox =
            TransformBbox2(ctx._accumXform, BoundingBox());

        ctx.AddDirtyRect(xformedBbox);
    }
}

Bool OverlayedImage::DetectHit(PointIntersectCtx& ctx)
{
    Bool gotTopHit = FALSE;
    // Only look at the top one if we either haven't gotten a hit
    // yet, or the top guy contains an occlusion ignorer, or we
    // are inside of an occlusion ignorer.
    if (!ctx.HaveWeGottenAHitYet() ||
        _top->ContainsOcclusionIgnorer() ||
        ctx.GetInsideOcclusionIgnorer()) {
            
        gotTopHit = _top->DetectHit(ctx);
    }

    if (gotTopHit) {
        ctx.GotAHit();
    }

    Bool gotBottomHit = FALSE;
        
    // Don't bother to catch the potential exception on this
    // one... just let it propagate up the stack, which will then
    // be interpreted as the image not being hit.

    // We continue down into the overlay stack if a) we haven't
    // gotten a hit so far, or b) we did get a hit, but the
    // bottom image contains a pickable image willing to ignore
    // occlusion.  Also continue if we're inside of an occlusion
    // ignorer. 
    if (!ctx.HaveWeGottenAHitYet() ||
        _bottom->ContainsOcclusionIgnorer() ||
        ctx.GetInsideOcclusionIgnorer()) {

        gotBottomHit = _bottom->DetectHit(ctx);
        if (gotBottomHit) {
            ctx.GotAHit();
        }
            
    }

    // TODO: Possible optimization.  If we're inside of an
    // occlusion ignorer, but there are no more nodes below us
    // that themselves are occlusion ignorers, then we can
    // potentially stop.  But *only* if we've gotten a hit within
    // our current occlusion ignorer.  Way too complex to attempt
    // right now.

    return gotTopHit || gotBottomHit;

}

int
OverlayedImage::Savings(CacheParam& p)
{
    // Consider the savings for the overlay to be the sum of the
    // savings of the individual elements.
    return _top->Savings(p) + _bottom->Savings(p);
}

//
// Overlayed image handles opacity because opacity
// is implicitly a tertiary operation: (opacity, im1, im2).
// So, each image floats the opacity of its underlying image
// up, so at this level, we can get the accumulated opacity
// from each top level image and set that opacity on the
// device and ask it to render.
// It is GUARANTEED that the device will do an alpha blit
// as the last operation at this level in the image tree
// because we floated opacity to the top of the branch.
// So, it will alwyas be the case that if there is opacity
// involved we do an alpha blit from the scratch surface
// to the current compositing surface.
//
void OverlayedImage::OverlayPairRender(Image *top,
                                       Image *bottom,
                                       GenericDevice& _dev)
{
    DirectDrawImageDevice &dev = SAFE_CAST(DirectDrawImageDevice &, _dev);
    //ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);

    // save dealtWith state. xxDeal is TRUE if we need to deal.
    Bool xfsDeal = ! dev.GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE);
    Bool xfcDeal = ! dev.GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX);
    Bool crDeal = ! dev.GetDealtWithAttrib(ATTRIB_CROP);
    Bool opDeal = ! dev.GetDealtWithAttrib(ATTRIB_OPAC);
    //printf("opDeal: %d\n",opDeal);

    //
    // Now, if there's opacity at the parent, we want to do it here
    // at ONE time.  So we CAN'T let bottom & top do their own thing.
    //
    Real topOpacity = dev.GetOpacity();
    DirectDrawViewport &vp = (dev._viewport);
    if(opDeal) {
        dev.SetDealtWithAttrib(ATTRIB_OPAC, TRUE);  // liar
        dev.SetOpacity(1.0);
        dev.GetCompositingStack()->PushCompositingSurface(doClear, scratch);
    }
    
    //
    //  B O T T O M 
    //

    // ----------------------------------------
    // Deal with opacity: Bottom
    // ----------------------------------------
    DoOpacity(bottom, dev);

    
    // ----------------------------------------
    // GET INTERESTING RECT: BOTTOM
    // ----------------------------------------
    //
    // Now, the bottom node has left the interesting rectangle on the
    // destination surface.  Find the dest surface and get the
    // interesting rect.  Reset the rect on the surface
    //
    RECT bottomRect;
    DDSurface *targetDDSurf = NULL;
    Bool droppedInTarg = TRUE;
    if(dev.AllAttributorsTrue()) {
        // it left everything in the target surface, so get the
        // interesting rect from that surf
        targetDDSurf = dev.GetCompositingStack()->TargetDDSurface();

    } else {
        // everything's in the scratch surf.  do same
        targetDDSurf = dev.GetCompositingStack()->ScratchDDSurface();
        droppedInTarg = FALSE;  // for assertions
        
    }
    CopyRect(&bottomRect, targetDDSurf->GetInterestingSurfRect());

    
    // Ok: bottom did all it can, what has it left undone ?
    // xxRemains is true if an attributor is undealt with
    Bool xfsDealt =  dev.GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE);
    Bool xfcDealt =  dev.GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX);
    Bool crDealt =  dev.GetDealtWithAttrib(ATTRIB_CROP);
    Bool opDealt =  dev.GetDealtWithAttrib(ATTRIB_OPAC);

    Image *modTop = top;

    if( (xfsDeal && xfsDealt) || (xfcDeal && xfcDealt) ) {
        //
        // top must deal with this now, since we're not sure if
        // there's an XF node in this tree, we can do one of two
        // things:
        // 1.> look for a top xf node to deal with the xfs
        // 2.> add a bogus node to artificially incite a xf
        //
        
        //
        // Add bogus xf node
        //
        modTop = NEW Transform2Image(identityTransform2, modTop);
    }
    if( crDeal && crDealt ) {
        modTop = NEW CroppedImage(UniverseBbox2, modTop);
    }
    if( opDeal && opDealt ) {
        //
        // not sure what this means yet.
        //
    }
        
        
    //
    // Reset "dealtWith" state
    //
    dev.SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, !xfsDeal);
    dev.SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, !xfcDeal);
    dev.SetDealtWithAttrib(ATTRIB_OPAC,  TRUE);
    dev.SetDealtWithAttrib(ATTRIB_CROP,  !crDeal);

    //
    //  T O P 
    //
    DoOpacity(modTop, dev);


    // ----------------------------------------
    // GET INTERESTING RECT: TOP
    // ----------------------------------------
    Assert((dev.AllAttributorsTrue() ? droppedInTarg : !droppedInTarg)
           &&  "Strange... one leaf dropped bits" &&
               "in target surf, but other leaf didn't.  BAAD!!");
    
    //
    // top left everything in the target surface, so get the
    // interesting rect from that surf
    //
    RECT topRect;
    CopyRect(&topRect, targetDDSurf->GetInterestingSurfRect());
    
    // UNION RECTS
    RECT unionedRects;
    UnionRect(&unionedRects, &topRect, &bottomRect);

    //
    // Set current interesting rect on targetsurface
    //
    targetDDSurf->SetInterestingSurfRect(&unionedRects);

    //
    // If the parent nodes have an opacity then we hid it from
    // the children, and now we'll reset the state for OPAC
    // so that our parent smartRender with do opacity for us.
    // Notice that we pulled out the targetSurface, and replaced
    // it with a compositing surface.  Now we'll move it to the
    // scratch surface and our parent will expect everything to be
    // there.
    //
    //
    // XXX: this won't work for: opac(0.5, over(opac(0.1, A), opac(0.8, B)))
    // But it will work for:
    // 1.>  opac(0.5, over(A,B))   where A & B have no opacity in them
    // 2.>  over( opac(0.4, A), opac(0.2, B) )   and there's no parent opacity
    //
    if(opDeal) {
        //printf("OverImage: set opac: FALSE\n");
        dev.SetOpacity(topOpacity);
        DirectDrawViewport &vp = dev._viewport;
        DDSurfPtr<DDSurface> dds; // my ref
        dds = dev.GetCompositingStack()->TargetDDSurface();
        dev.GetCompositingStack()->PopTargetSurface();
        if(dev.AllAttributorsTrue()) {
            //
            // Make the target the current scratch surface
            // assuming that the children left all their bits in the
            // target surface.
            //
            dev.GetCompositingStack()->ReplaceAndReturnScratchSurface(dds);
        } else {
            // ah, whoops, didn't need to replace
            // target surface.... bad. optimize.
            dev.GetCompositingStack()->PushTargetSurface(dds);
        }
        dev.SetDealtWithAttrib(ATTRIB_OPAC, FALSE);
    }

    // INVARIENT:  All the attribs that _bottom dealt with are also
    // INVARIENT:  dealt with by _top
    //Assert( xfsDealt && dev.GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE) && "bottom dealt with XFORM but top didn't");
    //Assert( xfcDealt && dev.GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) && "bottom dealt with XFORM but top didn't");
    //Assert( crDealt && dev.GetDealtWithAttrib(ATTRIB_CROP) && "bottom dealt with CROP but top didn't");

    //Assert( opDealt && dev.GetDealtWithAttrib(ATTRIB_OPAC) && "bottom dealt with OPAC but top didn't");
    
}

void OverlayedImage::
DoOpacity(Image *image, ImageDisplayDev &dev)
{
    Real origOpac = dev.GetOpacity();

    dev.SetOpacity(origOpac * image->GetOpacity());
    dev.SmartRender(image, ATTRIB_OPAC);
    dev.SetOpacity(origOpac);
}

Image *Overlay(Image *top, Image *bottom)
{
    if (top == emptyImage) {
        return bottom;
    } else if (bottom == emptyImage) {
        return top;
    } else {
        return NEW OverlayedImage(top, bottom);
    }
}


AxAValue
OverlayedImage::_Cache(CacheParam &p)
{
    Image *result = this;
    
    if (ShouldOverlayBeCached(this, p)) {
        result = CacheHelper(this, p);
    }

    if (result == this) {

        // Just cache the individual pieces
        CacheParam newParam = p;
        newParam._pCacheToReuse = NULL;
        _top = SAFE_CAST(Image *, AxAValueObj::Cache(_top, newParam));
        _bottom = SAFE_CAST(Image *, AxAValueObj::Cache(_bottom, newParam));
    }

    return result;
}

void
OverlayedImage::DoKids(GCFuncObj proc)
{
    Image::DoKids(proc);
    (*proc)(_top);
    (*proc)(_bottom);
}

//////////////////////  Overlayed Array of Images  ////////////////////

class OverlayedArrayImage : public Image {
  public:

    // Interpret the array so that the first element is on the top.
    OverlayedArrayImage(AxAArray *sourceImgs)
    : _heapCreatedOn(GetHeapOnTopOfStack())
    {
        _cached = false;
        _cachedDisjointArea = -1.0;
        
        // Incoming images are ordered so that the zero'th element is
        // on the top.
        _numImages = sourceImgs->Length();

        _images =
            (Image **)AllocateFromStore(_numImages * sizeof(Image *));
        
        _overlayTree = NULL;
        
        _containsOcclusionIgnorer = false;
        _oldestConstituentSampleId = -1;

        int n = 0;

        for (int i = 0; i < _numImages; i++) {
            Image *img = (Image *)(*sourceImgs)[i];

            if (img==emptyImage)
                continue;

            _images[n] = img;

            // If any of these contain an occlusion ignorer, then the
            // whole array does.
            if (!_containsOcclusionIgnorer) {
                _containsOcclusionIgnorer =
                    img->ContainsOcclusionIgnorer();
            }

            long oid = img->GetOldestConstituentID();
            if (oid != PERF_CREATION_ID_BUILT_EACH_FRAME &&
                (i == 0 || oid < _oldestConstituentSampleId)) {

                // Check for i == 0 to be sure we set this the first
                // time we get a non-built-each-frame image.
                _oldestConstituentSampleId = oid;
            }

            DWORD mask = img->GetFlags() & aggregatingFlags;
            _flags |= mask;

            n++;
        }

        _numImages = n;

        if (_oldestConstituentSampleId == -1) {
            // Only way to get here is if all of the constituent
            // images where built each frame, in which case we want to
            // say that this was built each frame.
            _oldestConstituentSampleId = PERF_CREATION_ID_BUILT_EACH_FRAME;
        }
        
        _flags |= IMGFLAG_CONTAINS_OVERLAY;

        // Here we generate the overlay tree.  Note that for N images,
        // this tree will have [2n - 1] nodes and will be at most
        // [log(n)] deep.  Not so bad.
        if( _numImages <= 0 ) {
            _overlayTree = emptyImage;
        } else {
            _overlayTree = _GenerateOverlayTreeFromArray(_images, _numImages);
        }
    }

    ~OverlayedArrayImage() {
        StoreDeallocate(_heapCreatedOn, _images);
    }

    void Render(GenericDevice& dev) {

        // We used to render by taking pairs of images, from the bottom,
        // and rendering them using the pairwise overlay render
        // implemented for the binary overlay.
        // However, we now generate a balanced binary overlay tree
        // since there are problems with opacity and this approach to
        // rendering the overlayedArray and we'd like this to work
        // exactly like a tree of overlays.

        _overlayTree->Render(dev);
    }

    const Bbox2 BoundingBox(void) {
        return CacheImageBbox2(this, _cached, _cachedBbox);
    }

    // An overlaid image's bbox is the union of the component
    // bboxes.  TODO:  This could be computed lazily and stashed.
    const Bbox2 _BoundingBox() {
        Bbox2 totalBbox;
        for (int i = 0; i < _numImages; i++) {
            // Grow the total bbox by augmenting with each corner of
            // the constituent ones.
            Bbox2 bb = _images[i]->BoundingBox();

            // If contents are not that of an empty bbox.
            if (!(bb == NullBbox2)) {
                totalBbox.Augment(bb.min);
                totalBbox.Augment(bb.max);
            }
        }

        return totalBbox;
    }

    Real DisjointBBoxAreas(DisjointCalcParam &param) {

        if (_cachedDisjointArea < 0) {
            Real area = 0;
            for (int i = 0; i < _numImages; i++) {
                area += _images[i]->DisjointBBoxAreas(param);
            }

            _cachedDisjointArea = area;
        }

        return _cachedDisjointArea;
    }

    void _CollectDirtyRects(DirtyRectCtx &ctx) {
        
        bool traverseSeparately = ShouldTraverseSeparately(this, ctx); 

        if (traverseSeparately) {
            
            // Collect from bottom up, since order of insertion
            // matters for determining whether images switched
            // layers. 
            for (int i = _numImages - 1; i >= 0; i--) {
                CollectDirtyRects(_images[i], ctx);
            }
            
        } else {
            
            // Just add this whole overlay as a single dirty rect.
            Bbox2 xformedBbox =
                TransformBbox2(ctx._accumXform, BoundingBox());

            ctx.AddDirtyRect(xformedBbox);
        }
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Bbox2 totalBbox;
        for (int i = 0; i < _numImages; i++) {

            // Grow the total bbox by augmenting with each corner of
            // the constituent ones.
            Bbox2 bb = _images[i]->BoundingBoxTighter(bbctx);
            if (bb != NullBbox2) {

                // Should never get here, since this bb should never
                // have been built and the only null bbox should be
                // nullBbox2.
                Assert(!(bb == NullBbox2));
                
                totalBbox.Augment(bb.min);
                totalBbox.Augment(bb.max);
            }
        }

        return totalBbox;
    }
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {
        return IntersectBbox2Bbox2(box, BoundingBox());
    }

    Bool  DetectHit(PointIntersectCtx& ctx) {
        return DetectHitOnOverlaidArray(ctx,
                                        _numImages,
                                        _images,
                                        _containsOcclusionIgnorer);
    }

#if _USE_PRINT
    ostream& Print (ostream &os) {
        os << "Overlay(" << _numImages;
        int ems = 0;
        for (int i = 0; i<_numImages; i++) {
            if (_images[i]==emptyImage)
                ems++;
        }

        double ePercent = (double) ems / (double) _numImages;

        if (ePercent>0.9) {
            for (i = 0; i<_numImages; i++) {
                if (_images[i]!=emptyImage)
                    os << ",[" << i << "," << _images[i] << "]";
            }
        } else {
            for (i = 0; i<_numImages; i++) {
                os << "," << _images[i];
            }
        }
        return os << ")";
    }
#endif

    int Savings(CacheParam& p) {
        int savings = 0;
        for (int i = 0; i < _numImages; i++) {
            savings += _images[i]->Savings(p);
        }

        return savings;
    }

    // should also check the extent of the overlap here.  If there is
    // significant overlap, we should cache just one discrete image. 
    AxAValue _Cache(CacheParam &p) {

        Image *result = this;

        if (ShouldOverlayBeCached(this, p)) {
            result = CacheHelper(this, p);
        }

        if (result == this) {

            CacheParam newParam = p;
            newParam._pCacheToReuse = NULL;
            for (int i = 0; i < _numImages; i++) {
                _images[i] =
                    SAFE_CAST(Image *,
                              AxAValueObj::Cache(_images[i], newParam));
            }
        }

        return result;
    }

    virtual VALTYPEID GetValTypeId() { return OVERLAYEDARRAYIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == OverlayedArrayImage::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
        for (int i = 0; i < _numImages; i++) {
            (*proc)(_images[i]);
        }
        (*proc)(_overlayTree);
    }

    virtual bool ContainsOcclusionIgnorer() {
        return _containsOcclusionIgnorer;
    }

    virtual void Traverse(TraversalContext &ctx) {
        for (int i = 0; i < _numImages; i++) {
            _images[i]->Traverse(ctx);
        }
    }
    
    

  protected:
    // Image 0 is on the top, image n-1 is on the bottom.
    int          _numImages;
    Image      **_images;
    DynamicHeap& _heapCreatedOn;
    bool         _cached;
    Bbox2        _cachedBbox;
    Real         _cachedDisjointArea;
    bool         _containsOcclusionIgnorer;
    Image       *_overlayTree;

    Image *_GenerateOverlayTreeFromArray(Image *imgs[], int numImages);
    Image *_TreeFromArray(Image *imgs[], int i, int j);
};


Image *OverlayedArrayImage::
_GenerateOverlayTreeFromArray(Image *imgs[], int numImages)
{
    Assert(numImages > 0);
    Image *ret = _TreeFromArray(imgs, 0, numImages-1);
    return ret;
}

Image *OverlayedArrayImage::
_TreeFromArray(Image *imgs[], int i, int j)
{
    Assert(i<=j);

    //
    // one node
    //
    if( i==j ) return imgs[i];

    //
    // two nodes
    //
    if( (j-i)==1 )
        return NEW OverlayedImage(imgs[i], imgs[j]);

    //
    // three+ nodes
    //
    
    int n = (j-i)+1;  // tot # nodes
    Assert(n>=3);
    int n2 = n/2;     // 1/2 of # of nodes
    n2 += n2 % 2;     // add 1 if needed to make it even
    Assert(n2<=j);
    
    int endi = i + (n2-1);
    int begj = endi + 1;

    // Assert that the first half is even
    Assert( ((endi - i + 1) % 2) == 0 );

    // redundant asserts (see assert above) but can make debugging easier
    Assert(i <= endi);
    Assert(endi < begj);
    Assert(begj <= j);
    
    return NEW OverlayedImage(
        _TreeFromArray(imgs, i, endi),
        _TreeFromArray(imgs, begj, j));
}

Image *OverlayArray(AxAArray *imgs)
{
    imgs = PackArray(imgs);
    
    int numImgs = imgs->Length();

    switch (numImgs) {
      case 0:
        return emptyImage;

      case 1:
        return (Image *)((*imgs)[0]);

      case 2:
        return Overlay(((Image *)((*imgs)[0])),
                       ((Image *)((*imgs)[1])));

      default:
        return NEW OverlayedArrayImage(imgs);
    }

}



// Also used by DXTransforms...

Bool DetectHitOnOverlaidArray(PointIntersectCtx& ctx,
                              LONG               numImages,
                              Image            **images,
                              bool               containsOcclusionIgnorer)
{

    Bool gotHit = ctx.HaveWeGottenAHitYet();
    bool continueLooking = true;

    // Start from the top;
    for (int i = 0; i < numImages && continueLooking; i++) {

        // If we've already gotten a hit, only pay attention to
        // the next guy if it contains an occlusion ignorer.
        // Otherwise, continue on, since ones below it may still
        // contain an occlusion ignorer.  Also, continue on if
        // we're inside of an occlusion ignorer.

        if (!gotHit ||
            images[i]->ContainsOcclusionIgnorer() ||
            ctx.GetInsideOcclusionIgnorer()) {

            Bool hitThisOne = images[i]->DetectHit(ctx);

            if (hitThisOne) {
                ctx.GotAHit();
                gotHit = true;
            }
        }

        // Keep looking if we haven't gotten a hit, or if there is
        // an occlusion ignorer in these images.  (Possible
        // optimization: figure out if there's an occlusion
        // ignorer _only_ in the images after the one we're on.
        // Would take more bookkeeping.)  Also continue on if
        // we're inside of an occlusion ignorer.
        continueLooking =
            !gotHit ||
            containsOcclusionIgnorer ||
            ctx.GetInsideOcclusionIgnorer();
    }

    return gotHit;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\montage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Private implementation of the montage type

*******************************************************************************/

#include "headers.h"
#include "appelles/montage.h"
#include "privinc/opt.h"

//// Define a container for image, depth pairs.

class ImageDepthPair {
  public:
    Image *image;
    Real  depth;
};

static int
operator<(ImageDepthPair i1, ImageDepthPair i2)
{
    return i1.depth < i2.depth;
}

static int
operator==(ImageDepthPair i1, ImageDepthPair i2)
{
    return i1.depth == i2.depth;
}

////////// Abstract Montage *implementation class  //////////////

class ATL_NO_VTABLE Montage : public AxAValueObj {
  public:

    // This method fills the vector in with any image/depth pairs in
    // the montage.  Note that it doesn't do any sorting.
    virtual void     DumpInto(vector<ImageDepthPair>& montageVec) = 0;

#if _USE_PRINT
    virtual ostream& Print(ostream& os) const = 0;
#endif

    virtual DXMTypeInfo GetTypeInfo() { return MontageType; }

};

////////////  Empty Montage *////////////

class EmptyMontage : public Montage {
  public:
    void     DumpInto(vector<ImageDepthPair>& montageVec) {}

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "emptyMontage";
    }
#endif
};

Montage *emptyMontage = NULL;

////////////  Primitive Montage *////////////

// The primitive montage simply has a single image and depth.

class PrimitiveMontage : public Montage {
  public:
    PrimitiveMontage(Image *im, Real d) : _image(im), _depth(d) {}

    void     DumpInto(vector<ImageDepthPair>& montageVec) {
        ImageDepthPair p;
        p.image = _image;
        p.depth = _depth;

#if _DEBUG      
        int s = montageVec.size();
#endif
    
        montageVec.push_back(p);

#if _DEBUG      
        Assert(montageVec.size() == s + 1);
#endif
        
    }

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "ImageMontage(" << _image << ", " << _depth << ")";
    }
#endif

    virtual AxAValue _Cache(CacheParam &p) {
        _image = SAFE_CAST(Image *, AxAValueObj::Cache(_image, p));
        return this;
    }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_image); }

  protected:
    Image *_image;
    Real   _depth;
};

Montage *ImageMontage(Image *image, AxANumber *depth)
{
    return NEW PrimitiveMontage(image, NumberToReal(depth));
}


//////////  Composite Montage *////////////////

class CompositeMontage : public Montage {
  public:
    CompositeMontage(Montage *m1, Montage *m2) : _montage1(m1), _montage2(m2) {}

    // Just ask the sub-montages to fill in.
    void     DumpInto(vector<ImageDepthPair>& montageVec) {
        _montage1->DumpInto(montageVec);
        _montage2->DumpInto(montageVec);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "(" << _montage1 << " + " << _montage2 << ")";
    }
#endif

    virtual AxAValue _Cache(CacheParam &p) {

        // Cache the individual pieces.  TODO: May want to try to
        // cache entirely as an overlay.
        // Just cache the individual pieces
        CacheParam newParam = p;
        newParam._pCacheToReuse = NULL;
        _montage1 = SAFE_CAST(Montage *, AxAValueObj::Cache(_montage1, newParam));
        _montage2 = SAFE_CAST(Montage *, AxAValueObj::Cache(_montage2, newParam));

        return this;
    }

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_montage1);
        (*proc)(_montage2);
    }

  protected:
    Montage *_montage1;
    Montage *_montage2;
};

Montage *UnionMontageMontage(Montage *m1, Montage *m2)
{
    return NEW CompositeMontage(m1, m2);
}

//////////////////////////////////////////////////

Image *Render(Montage *m)
{
    vector<ImageDepthPair> imageDepthPairs;

    // Dump all of the images and depths into this vector
    m->DumpInto(imageDepthPairs);

    int numImages = imageDepthPairs.size();

    // Sort according to the depths, but maintain relative ordering
    // for those within a single depth.
    std::stable_sort(imageDepthPairs.begin(), imageDepthPairs.end());

    AxAValue *vals = THROWING_ARRAY_ALLOCATOR(AxAValue, numImages);

    for (int i = 0; i < numImages; i++) {
        vals[i] = imageDepthPairs[numImages-i-1].image;
    }

    AxAArray *arr = MakeValueArray(vals, numImages, ImageType); 
        
    delete [] vals;

    return OverlayArray(arr);
}

#if _USE_PRINT
ostream&
operator<<(ostream& os, Montage *m)
{
    return m->Print(os);
}
#endif

// TODO: Breakout a separate class that can just aggregate all of
// these together, rather than making separate binary trees.
Montage *UnionMontage(AxAArray *montages)
{
    montages = PackArray(montages);

    int numMtgs = montages->Length();

    Montage *result;
 
    switch (numMtgs) {
      case 0:
        result = emptyMontage;
        break;
 
      case 1:
        result = SAFE_CAST(Montage *, (*montages)[0]);
        break;
      
      default:
        result = SAFE_CAST(Montage *, (*montages)[0]);
        for(int i=1; i < numMtgs; i++) {
            // Be sure to union these in in the order they appear,
            // since order within a specific depth is important.
            result =
                UnionMontageMontage(result,
                                    SAFE_CAST(Montage *,
                                              ((*montages)[i])));
        }
        break;
    }

    return result;
}


void
InitializeModule_Montage()
{
    emptyMontage = NEW EmptyMontage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\lineimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Line Image

*******************************************************************************/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"
#include "privinc/vec2i.h"
#include "privinc/bbox2i.h"
#include "privinc/probe.h"
#include "privinc/dddevice.h"
#include "privinc/path2i.h"
#include "privinc/linei.h"


//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
// Line Image
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

DeclareTag(tagEnableLineBitmap, "Optimizations", "enable line bitmap cache");

class LineImage : public Image {
  public:
    LineImage(Path2 *path, LineStyle *style)
        : _path(path), _style(style) {}

    void Render(GenericDevice& dev);

    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {return box;}
    Bool  DetectHit(PointIntersectCtx& ctx) {
        return _path->DetectHit(ctx, _style);
    }

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) { return os << "LineImage"; }
#endif

    virtual void DoKids(GCFuncObj proc) { 
        Image::DoKids(proc);
        (*proc)(_path);
        (*proc)(_style);
    }

    virtual int Savings(CacheParam& p) { 
#if _DEBUG
        if (IsTagEnabled(tagEnableLineBitmap))
            return _path->Savings(p); 
#endif 
        return 0;
    }

    void Traverse(TraversalContext &ctx) {
        ctx.SetContainsLine();
    }
    
  protected:
    Path2     *_path;
    LineStyle *_style;
};


void LineImage::
Render(GenericDevice& dev) 
{
    DirectDrawImageDevice &imgDev = SAFE_CAST(DirectDrawImageDevice &, dev);
    
    imgDev.RenderLine(_path, _style);
};


// The BoundingBox method returns the bounding box of the path, enlarged to
// accomodate the given line style.

const Bbox2 LineImage::BoundingBox (void)
{
    Bbox2 bbox = _path->BoundingBox ();
    Real Offset = 0.0;
   
    // The following calculation can make the bounding box a little
    // too big when a wide line only widens the bounding box in one
    // dimension (e.g. a horizontal wide line with flat end cap
    // doesn't increase the width of the bounding box).

    if(_style->Detail() ) {
        Offset = 1 / ViewerResolution();    // Detailed lines.. 
    }
    else {
        Offset = _style->Width()/ 2;        // NOT detailed lines..
    }
    
    bbox.Augment (bbox.max.x + Offset , bbox.min.y - Offset);
    bbox.Augment (bbox.min.x - Offset , bbox.max.y + Offset);
    
    return bbox;
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 LineImage::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Bbox2 bbox = _path->BoundingBoxTighter (bbctx);

    if( ! _style->Detail() ) {

        // The following calculation can make the bounding box a little
        // too big if xf in bbctx is shear or rotate.  It also makes the box
        // too big when a wide line only widens the bounding box in one
        // dimension (e.g. a horizontal wide line with flat end cap
        // doesn't increase the width of the bounding box).
        Real halfWidth = _style->Width() / 2;
        Vector2Value halfVec (halfWidth, halfWidth);
        bbox.min -= halfVec;
        bbox.max += halfVec;
    }

    return bbox;
}
#endif  // BOUNDINGBOX_TIGHTER

Image *LineImageConstructor(LineStyle *style, Path2 *path)
{
    if(style->GetVisible())
        return NEW LineImage(path, style);
    else
        return emptyImage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\imagei.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Implements image operations and subclasses.

*******************************************************************************/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/overimg.h"
#include "privinc/imgdev.h"
#include "privinc/ddrender.h"
#include "appelles/geom.h"
#include "appelles/camera.h"
#include "appelles/path2.h"
#include "appelles/linestyl.h"
#include "privinc/geomi.h"
#include "privinc/bbox2i.h"
#include "privinc/dddevice.h"
#include "privinc/probe.h"
#include "privinc/except.h"
#include "privinc/util.h"
#include "privinc/cachdimg.h"
#include "privinc/basic.h"
#include "privinc/xform2i.h"
#include "backend/values.h"
#include "backend/preference.h"
#include "privinc/drect.h"
#include "privinc/opt.h"

void
RenderImageOnDevice(DirectDrawViewport *vp,
                    Image *image,
                    DirtyRectState &d)
{
    vp->RenderImage(image, d);
}


Bbox2Value *BoundingBox(Image *image)
{
    return Promote(image->BoundingBox());
}

#if _USE_PRINT
// Image *printing function.
ostream&
operator<<(ostream &os, Image *image)
{
    return image->Print(os);
}
#endif

//////////////  UNRenderable IMAGE  ////////////////////

#if 0
void UnrenderableImage::Render(GenericDevice& dev) {
    if (dev.GetRenderMode() != RENDER_MODE)   return;
    ImageDisplayDev &idev = SAFE_CAST(ImageDisplayDev &, dev);
    idev.RenderUnrenderableImage();
}
#endif

//////////////  Cached IMAGE  ////////////////////

// Return incoming image if we choose not to cache.

Image *
CacheHelper(Image *imgToCache, CacheParam &p)
{
    Image *img;

    // Can't properly cache things that have elements that get
    // externally updated.  May be able to revisit and propagate
    // changes properly to cause re-caching.  Also can't deal with
    // elements with opacity.
    
    DWORD cantDoIt = IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT |
                     IMGFLAG_CONTAINS_OPACITY;
    
    if (imgToCache->GetFlags() & cantDoIt) {

        img = NULL;
        
    } else {
    
        Assert(!p._pCacheToReuse ||
               !(*p._pCacheToReuse) ||
               SAFE_CAST(Image *, *p._pCacheToReuse));
    
        img =
            p._idev->CanCacheImage(imgToCache,
                                   (Image **)p._pCacheToReuse,
                                   p);

#if _DEBUG
        if (IsTagEnabled(tagCacheOpt)) {
            Bbox2 bb = imgToCache->BoundingBox();
            float res = p._idev->GetResolution();
            int l = (int)(bb.min.x * res);
            int r = (int)(bb.max.x * res);
            int t = (int)(bb.min.y * res);
            int b = (int)(bb.max.y * res);
            TraceTag((tagCacheOpt,
                      "Caching an image: %x as %x - %s.  Bbox = (%d, %d) -> (%d, %d)",
                      imgToCache, img, img ? "SUCCEEDED" : "FAILED",
                      l, t, r, b));
        }
    
#endif    

    }
    
    return img ? img : imgToCache;
}



/*****************************************************************************
The constructor for the images, besides initializing various members, also
stamps itself with a unique identifier for use in texture and other caching.
*****************************************************************************/

static CritSect *ImageIdCritSect = NULL;   // Image Id CritSection
long   Image::_id_next = 0;                // Image ID Generator

Image::Image()
{
    _opacity = 1.0;
    _flags = IMGFLAG_IS_RENDERABLE;
    _creationID = PERF_CREATION_ID_BUILT_EACH_FRAME;
    _oldestConstituentSampleId = _creationID;
    _cachedImage = NULL;

    // Stamp the image with a unique identifier.

    {
        CritSectGrabber csg(*ImageIdCritSect);
        _id = _id_next++;
    }

    #if _DEBUG
        _desiredRenderingWidth  = -1;
        _desiredRenderingHeight = -1;
    #endif /* _DEBUG */
}


// TODO: We should also be accumulating clips and crops, as they
// affect the images bbox.  So, this should be implemented on Clipped
// and Cropped images (though it's not harmful that it's not...)
Real
Image::DisjointBBoxAreas(DisjointCalcParam &param)
{
    // By default, just get the image's bbox, transform it by the
    // accumulated xform, intersect it with the accumulated clipbox,
    // and get the result's area. 
    Bbox2 xformedBbox = TransformBbox2(param._accumXform, BoundingBox());

    Bbox2 clippedBox = IntersectBbox2Bbox2(xformedBbox,
                                            param._accumulatedClipBox);
    
    return clippedBox.Area();
}


void
Image::CollectDirtyRects(Image *img, DirtyRectCtx &ctx)
{
    // By default, we need to look at the creation ID and, based on
    // it, do one of the following:
    // a) If sample is constant since last frame, then it's not going
    //    to be part of a dirty rect.  Don't do anything in this
    //    case. 
    // b) If sample is non-constant, and contains no overlays, then
    //    get its bbox, transform it, and add to the dirty rect list
    // c) If sample is non-constant and contains overlays, proceed
    //    down the overlays.
    // d) If we've been told (via the ctx) to process everything, then
    //    just blindly continue down.

    if (img == emptyImage) {
        return;
    }
    
    int id = img->GetCreationID();
    bool process = ctx._processEverything ||
                   id == PERF_CREATION_ID_BUILT_EACH_FRAME || 
                   id > ctx._lastSampleId;

    if (process) {

        // Non-constant, determine if it has an overlay
        if (img->_flags & IMGFLAG_CONTAINS_OVERLAY) {

            // Node has overlays.  Continue down it.
            img->_CollectDirtyRects(ctx);

        } else if (img->_flags & IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX) {

            // Ignore this node, it can't have an overlay, and we
            // don't want to add it in to our context.  TODO: Note
            // that the better way to do ttis whole thing about
            // UNRENDERABLE_WITH_BOX would be just to have a bbox
            // collection context, but that would require changes to
            // the signature of bbox, which is too much work right
            // now. 
            
            // Just for setting a breakpoint...
            Assert(img);
            
        } else if (img != emptyImage) {

            // There are no overlays, and this is time varying, so
            // grab the rectangle.
            Bbox2 bb = img->BoundingBox();

            // Ignore null bounding boxes.
            if (bb != NullBbox2) {
                Bbox2 xformedBbox =
                    TransformBbox2(ctx._accumXform, bb);

                ctx.AddDirtyRect(xformedBbox);
            }
            
        }
        
    } else {

        // Record that this image was found in this frame.  Stash it
        // along with the currently accumulated bbox on the context,
        // to distinguish multiple instances of this image.  If the
        // same pair wasn't found last time, then we'll need to extend
        // our dirty rectangle list to include it.  After we're done
        // collecting, we'll see if there were any from last frame
        // that are not in this frame.  These are guys we'll need to
        // add to our dirty rectangle list as well, to restore the
        // background they've uncovered.

        Bbox2 bb = img->BoundingBox();
        Bbox2 xfBox =
            TransformBbox2(ctx._accumXform, bb);

        ctx.AddToConstantImageList(img, xfBox);

    }
}


void
Image::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    // The default dirty rectangle collector doesn't do anything.  We
    // test to be sure there are no overlays.  If there are, we've
    // made an internal logic error, since all of those nodes need to
    // override this method.
    Assert(!(_flags & IMGFLAG_CONTAINS_OVERLAY));
}


AxAValue Image::_Cache(CacheParam &p)
{
    Assert(p._idev && "NULL dev passed into cache.");

    Image *ret;

    int c = this->Savings(p);

    if (c >= savingsThreshold) {

        ret = CacheHelper(this, p);

    } else {
        
        ret = this;
        
    }

    return ret;
}


void Image::DoKids(GCFuncObj proc)
{
    (*proc)(_cachedImage);
}


// Returning -1 means that there is no conclusive rendering resolution
// for this image.
void
Image::ExtractRenderResolution(short *width, short *height, bool negOne)
{
    if (_flags & IMGFLAG_CONTAINS_DESIRED_RENDERING_RESOLUTION) {
        
        Assert(_desiredRenderingWidth != -1);
        Assert(_desiredRenderingHeight != -1);
        
        *width = _desiredRenderingWidth;
        *height = _desiredRenderingHeight;

    } else {
        
        if (negOne) {
            *width = -1;
            *height = -1;
        }
            
#if _DEBUG
        // In debug, always set these to -1.
        *width = -1;
        *height = -1;
#endif /* _DEBUG */
        
    }
}


class CachePreferenceClosure : public PreferenceClosure {
  public:
    CachePreferenceClosure(Image *im, CacheParam &p) :
    _image(im), _p(p) {}
        
    void Execute() {
        _result = AxAValueObj::Cache(_image, _p);
    }

    Image          *_image;
    CacheParam     &_p;
    AxAValue        _result;
};

class SavingsPreferenceClosure : public PreferenceClosure {
  public:
    SavingsPreferenceClosure(Image *im, CacheParam &p) :
    _image(im), _p(p) {}
        
    void Execute() {
        _result = _image->Savings(_p);
    }

    Image          *_image;
    CacheParam     &_p;
    int             _result;
};


class CachePreferenceImage : public AttributedImage {
  public:
    CachePreferenceImage(Image *img,
                         BoolPref bitmapCaching,
                         BoolPref geometryBitmapCaching)
    : AttributedImage(img)
    {
        _bitmapCaching = bitmapCaching;
        _geometryBitmapCaching = geometryBitmapCaching;
    }

    AxAValue _Cache(CacheParam &p) {
        CachePreferenceClosure cl(_image, p);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        AxAValue result = cl._result;

        return result;
    }

    int Savings(CacheParam &p) {
        SavingsPreferenceClosure cl(_image, p);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        int result = cl._result;

        return result;
    }
    
#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "CachePreference" << _image;
    }
#endif
    
  protected:
    BoolPref _bitmapCaching;
    BoolPref _geometryBitmapCaching;
};

AxAValue
Image::ExtendedAttrib(char *attrib, VARIANT& val)
{
    Image *result = this;       // unless we figure out otherwise. 

    CComVariant ccVar;
    HRESULT hr = ccVar.ChangeType(VT_BOOL, &val);

    if (SUCCEEDED(hr)) {

        bool prefOn = ccVar.boolVal ? true : false;

        bool gotOne = false;
        BoolPref bmapCaching = NoPreference;
        BoolPref geometryBmapCaching = NoPreference;
    
        if (0 == lstrcmp(attrib, "BitmapCachingOn")) {
            gotOne = true;
            bmapCaching = prefOn ? PreferenceOn : PreferenceOff;
        } else if (0 == lstrcmp(attrib, "GeometryBitmapCachingOn")) {
            gotOne = true;
            geometryBmapCaching = prefOn ? PreferenceOn : PreferenceOff;
        }

        if (gotOne) {
            result = NEW CachePreferenceImage(this,
                                              bmapCaching,
                                              geometryBmapCaching);
        }

    }

    return result;
}

///////////////////  AttributedImage  /////////////

AttributedImage::AttributedImage(Image *image)
    : _image(image)
{
    //
    // Inherit the opacity of the underlying image
    //
    SetOpacity( image->GetOpacity() );

    // Get flags from the underlying image.
    _flags = _image->GetFlags();

    short w, h;
    _image->ExtractRenderResolution(&w, &h, false);

    _desiredRenderingWidth = w;
    _desiredRenderingHeight = h;

    // For an attributed image, the oldest constituent is the oldest
    // constituent of the base image.
    _oldestConstituentSampleId = _image->GetOldestConstituentID();
}

void
AttributedImage::Render(GenericDevice& dev) {
    // By default, just delegate to the image.
    _image->Render(dev);
}   

// ---
// These methods all delegate to the image.  They can all be
// overridden in subclasses. 
// ---

// Extract a bounding box from this image, outside of which
// everything is transparent.
const Bbox2
AttributedImage::BoundingBox(void) {
    // By default, just delegate to the image

    return _image->BoundingBox();
}

Real
AttributedImage::DisjointBBoxAreas(DisjointCalcParam &param) {
    return _image->DisjointBBoxAreas(param);
}

void
AttributedImage::_CollectDirtyRects(DirtyRectCtx &ctx)
{

    if (ctx._processEverything) {

        CollectDirtyRects(_image, ctx);

    } else {
    
        // We're here because either the attribute of this image is new
        // or the underlying image is new (or both).  If the attribute is
        // new, the image will claim to be old, but we still want to
        // process it, so we set the override state in the ctx to do
        // that.

        Assert(GetCreationID() == PERF_CREATION_ID_BUILT_EACH_FRAME ||
               GetCreationID() > ctx._lastSampleId);

    
        long imId = _image->GetCreationID();
        bool imageNew = (imId == PERF_CREATION_ID_BUILT_EACH_FRAME ||
                         imId > ctx._lastSampleId);

        bool setProcessEverything =
            !imageNew && !ctx._processEverything;
    
        if (setProcessEverything) {
            ctx._processEverything = true;
        }

        CollectDirtyRects(_image, ctx);

        if (setProcessEverything) {
            Assert(ctx._processEverything);
            ctx._processEverything = false;
        }

    }
}

#if BOUNDINGBOX_TIGHTER
const Bbox2
AttributedImage::BoundingBoxTighter(Bbox2Ctx &bbctx) {
    // By default, just delegate to the image

    return _image->BoundingBoxTighter(bbctx);
}
#endif  // BOUNDINGBOX_TIGHTER

// Process an image for hit detection
Bool
AttributedImage::DetectHit(PointIntersectCtx& ctx) {
    // By default, just delegate to the image
    return _image->DetectHit(ctx);
}

int
AttributedImage::Savings(CacheParam& p)
{
    return _image->Savings(p);
}

// This, by default, just returns the box.  Certain classes will
// override. 
const Bbox2 
AttributedImage::OperateOn(const Bbox2 &box)
{
    return box;
}

void
AttributedImage::DoKids(GCFuncObj proc)
{
    Image::DoKids(proc);
    (*proc)(_image);
}

bool
AttributedImage::ContainsOcclusionIgnorer()
{
    return _image->ContainsOcclusionIgnorer();
}

AxAValue AttributedImage::_Cache(CacheParam &p)
{
    Assert(p._idev && "NULL dev passed into cache.");

    Image *ret = this;
    int c = this->Savings(p);

    if (c >= savingsThreshold) {

        // First try to cache entire image.
        Image *cachedImage = CacheHelper(this, p);

        // CacheHelper returns "this" if it's unable to successfully
        // cache. 
        if (cachedImage != this) {
            return cachedImage;
        }
    }

    // If entire attributed image can't be cached, try to cache the
    // underlying image.
    _image = SAFE_CAST(Image *, AxAValueObj::Cache(_image, p));
    
    return this;
}
    
//////////////  EmptyImage  ////////////////////

#if _DEBUG
bool g_createdEmptyImage = false;
#endif _DEBUG

class EmptyImageClass : public UnrenderableImage {
  public:
    EmptyImageClass() {
        _creationID = PERF_CREATION_ID_FULLY_CONSTANT;
        _oldestConstituentSampleId = PERF_CREATION_ID_FULLY_CONSTANT;
        

#if _DEBUG
        // Only one of these should ever be created, else our
        // assumption about the creation id is wrong.
        Assert(!g_createdEmptyImage);
        g_createdEmptyImage = true;
#endif _DEBUG   

    }
#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "emptyImage";
    }
#endif
};

Image *emptyImage = NULL;

//////////////  DetectableEmptyImage  ////////////////////

#if _DEBUG
bool g_createdTransparentPickableImage = false;
#endif _DEBUG

class TransparentPickableImageClass : public UnrenderableImage {
  public:
    TransparentPickableImageClass() {
        _creationID = PERF_CREATION_ID_FULLY_CONSTANT;
        _oldestConstituentSampleId = PERF_CREATION_ID_FULLY_CONSTANT;

        // Note that the better way to do ttis whole thing about
        // UNRENDERABLE_WITH_BOX would be just to have a bbox
        // collection context, so that bbox for this guy would return
        // NULL when we're collecting "rendering" bboxes, and
        // universalBbox when collecting "picking" bboxes, but that
        // would require changes to the signature of bbox, which is
        // too much work right now.
        _flags = IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX;

#if _DEBUG
        // Only one of these should ever be created, else our
        // assumption about the creation id is wrong.
        Assert(!g_createdTransparentPickableImage);
        g_createdTransparentPickableImage = true;
#endif _DEBUG   
        
    }

    // This image has a universal bbox, since it's detectable
    // everywhere. 
    inline const Bbox2 BoundingBox(void) { return UniverseBbox2; }

#if BOUNDINGBOX_TIGHTER
    Bbox2 *BoundingBoxTighter(Bbox2Ctx &bbctx) { return universeBbox2; }
#endif  // BOUNDINGBOX_TIGHTER

    // This image is always hit
    Bool  DetectHit(PointIntersectCtx& ctx) { return TRUE; }

#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "InternalTransparentPickableImage";
    }
#endif
};

Image *detectableEmptyImage = NULL;


/////////////////  Undetectable Image /////////////////////

class UndetectableImg : public AttributedImage {
  public:
    UndetectableImg(Image *image) : AttributedImage(image) {}

    // The undetectable image just delegates everything to the
    // subimage, except for hit detection, which is always false. 
    Bool DetectHit(PointIntersectCtx&) { return FALSE; }

#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "undetectable(" << _image << ")";
    }
#endif

};

Image *
UndetectableImage(Image *image)
{
    return NEW UndetectableImg(image);
}

Image *MapToUnitSquare(Image *img)
{
    Bbox2 bbox = img->BoundingBox();

    Point2 min = bbox.min;
    Point2 max = bbox.max;
    double xmin = min.x;
    double ymin = min.y;
    double xmax = max.x;
    double ymax = max.y;

    bool isInfinite =
        (fabs(xmin) == HUGE_VAL) ||
        (fabs(xmax) == HUGE_VAL) ||
        (fabs(ymin) == HUGE_VAL) ||
        (fabs(ymax) == HUGE_VAL);

    if (isInfinite || (xmax == xmin) || (ymax == ymin)) {
        return img;
    }
        
    double xscl = 1.0 / (xmax - xmin);
    double yscl = 1.0 / (ymax - ymin);

    Transform2 *sxf = ScaleRR(xscl, yscl);
    Transform2 *txf = TranslateRR(-xmin, -ymin);
    return TransformImage(TimesTransform2Transform2(sxf, txf),
                          img);
    
}

Image *ClipPolygon(AxAArray* points, Image* image)
{
  return ClipImage(RegionFromPath(PolyLine2(points)), image);
}

// This calls _BoundingBox if cached is false, set cached, stashed the
// bbox points into cachedBox.  It returns a Bbox2 of the same
// value of cachedBox.
// TODO: This is temp until we deal with the sharing issues later
const Bbox2 CacheImageBbox2(Image *img, bool& cached, Bbox2 &cachedBox)
{
    // use default copy constructor to copy bits
    // NOTE: don't just return &cachedBox, it'll be treated as a real
    // AxAValueObj then.
    
    if (!cached) {
        Bbox2 b = img->_BoundingBox();
        cachedBox = b;         
        cached = true;
        return b;
    }

    return cachedBox;
}

///////////////////////////////////////////////////////////

void
InitializeModule_Image()
{
    ImageIdCritSect = NEW CritSect;
    emptyImage = NEW EmptyImageClass;
    detectableEmptyImage = NEW TransparentPickableImageClass;
}

void
DeinitializeModule_Image(bool)
{
    delete ImageIdCritSect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\pickimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Define a pickable image that triggers an event when it's picked

*******************************************************************************/


#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/probe.h"

class PickableImg : public AttributedImage {
  public:

    PickableImg(Image *img, int eventId, bool ignoresOcclusion,
                bool uType = false, GCIUnknown *u = NULL)
    : AttributedImage(img), _eventId(eventId), 
      _ignoresOcclusion(ignoresOcclusion), _hasData(uType), _long(u) {}

    virtual void DoKids(GCFuncObj proc) {
        AttributedImage::DoKids(proc);
        (*proc)(_long);
    }
    
#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "PickableImage" << _image;
    };
#endif

    Bool  DetectHit(PointIntersectCtx& ctx) {

        Bool result;
        
        // Stash off if we're inside an occlusion ignorer.
        bool oldState = ctx.GetInsideOcclusionIgnorer();
        if (_ignoresOcclusion) {
            ctx.SetInsideOcclusionIgnorer(true);
        }
        
        // If the underlying image is hit, and we're currently looking
        // for picks, add this image to the context since we'll want
        // to extend.  If hit, but not currently looking, just return
        // TRUE, else return FALSE.

        bool alreadyGotUnoccludedHit = ctx.HaveWeGottenAHitYet();
        if (_image->DetectHit(ctx)) {

            // Only register the event if this node is to ignore
            // occlusion, or it's the first thing hit.
            if (_ignoresOcclusion || !alreadyGotUnoccludedHit) {
                ctx.AddEventId(_eventId, _hasData, _long);
            }
            
            result = TRUE;
            
        } else {
            
            result = FALSE;
            
        }

        if (_ignoresOcclusion) {
            ctx.SetInsideOcclusionIgnorer(oldState);
        }

        return result;
        
    }

    bool ContainsOcclusionIgnorer() {
        return _ignoresOcclusion;
    }

  protected:
    int   _eventId;
    bool  _ignoresOcclusion;
    bool _hasData;
    GCIUnknown *_long;
};

Image *PRIVPickableImage(Image *image,
                         AxANumber *id,
                         AxABoolean *ignoresOcclusionValue)
{ 
    bool ignoresOcclusion = ignoresOcclusionValue->GetBool() ? true : false;
    
    return NEW PickableImg(image,
                           (int)NumberToReal(id),
                           ignoresOcclusion);
}

AxAValue PRIVPickableImageWithData(AxAValue img,
                                   int id,
                                   GCIUnknown *data,
                                   bool ignoresOcclusion)
{
    return NEW PickableImg(SAFE_CAST(Image*,img), id,
                           ignoresOcclusion, true, data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\textimg.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

--*/

#include "headers.h"
#include "privinc/TextImg.h"
#include "privinc/texti.h"
#include "appelles/hacks.h"
#include "privinc/dddevice.h"

//////////  Rendering a text into an image  /////////////

void
TextImage::Render(GenericDevice& _dev)
{
    DirectDrawImageDevice &dev = SAFE_CAST(DirectDrawImageDevice &, _dev);
    TextCtx ctx(&dev, this);

    ctx.BeginRendering();
    _text->RenderToTextCtx(ctx);
    ctx.EndRendering();
}

void TextImage::DoKids(GCFuncObj proc)
{
    Image::DoKids(proc);
    (*proc)(_text);
}



const Bbox2
TextImage::DeriveBbox()
{
    // This is a lot like we're rendering: doing a bunch of the same work
    // that rendering does, except all we get out of it is a bbox!
    Bbox2 fooBox;
    if(_bbox == NullBbox2) {

        DirectDrawViewport *vp = GetCurrentViewport();

        if( vp ) {

            DirectDrawImageDevice *dev = GetImageRendererFromViewport( vp );
            
            TextCtx ctx(dev, this);
            
            ctx.BeginRendering(TextCtx::renderForBox);
                
            _text->RenderToTextCtx(ctx);
            
            ctx.EndRendering();
            
            // XXX: This is dumb...
            _bbox= ctx.GetStashedBbox();
        }
    }

    return _bbox;
}

Image *RenderTextToImage(Text *t)
{
    if ((t->GetStringPtr() == NULL) ||
        !StrCmpW(t->GetStringPtr(), L"")) {
        return emptyImage;
    }
    
    return NEW TextImage(t);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\quality.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Simple image attribution that doesn't get elevated automatically

*******************************************************************************/

#include <headers.h>
#include "backend/bvr.h"
#include "privinc/server.h"
#include "privinc/basic.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"

static const DWORD textTrait  = CRQUAL_AA_TEXT_ON | CRQUAL_AA_TEXT_OFF;
static const DWORD lineTrait  = CRQUAL_AA_LINES_ON | CRQUAL_AA_LINES_OFF;
static const DWORD solidTrait = CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_SOLIDS_OFF;
static const DWORD clipTrait  = CRQUAL_AA_CLIP_ON | CRQUAL_AA_CLIP_OFF;
static const DWORD htmlTrait  = CRQUAL_MSHTML_COLORS_ON | CRQUAL_MSHTML_COLORS_OFF;
static const DWORD xformTrait = CRQUAL_QUALITY_TRANSFORMS_ON | CRQUAL_QUALITY_TRANSFORMS_OFF;
static CONST DWORD allTraits  = (textTrait |
                                 lineTrait |
                                 solidTrait |
                                 clipTrait |
                                 htmlTrait |
                                 xformTrait);

class ImageQualityImage : public AttributedImage {
  public:
    ImageQualityImage(Image *underlyingImg,
                      long renderWidth,
                      long renderHeight,
                      DWORD qualityFlags) :
        AttributedImage(underlyingImg)
    {
        _renderWidth = renderWidth;
        _renderHeight = renderHeight;
        _qualityFlags = qualityFlags;
    }

    void Validate() {

        bool ok = true;

        // Be sure dimensions are reasonable.
        if (_renderWidth <= 0 ||
            _renderHeight <= 0 ||
            _renderWidth > 65536 ||
            _renderHeight > 65536) {

            ok = false;

            // We allow this exception, to indicate that this isn't
            // setting the render dimensions.
            if (_renderWidth == -1 && _renderHeight == -1) {
                ok = true;
            }
            
        } else {

            // Valid rendering dimensions.
            _flags |= IMGFLAG_CONTAINS_DESIRED_RENDERING_RESOLUTION;
            _desiredRenderingWidth = _renderWidth;
            _desiredRenderingHeight = _renderHeight;
            
        }

        // And quality flags aren't self conflicting.
        if (((_qualityFlags & CRQUAL_AA_TEXT_ON) &&
             (_qualityFlags & CRQUAL_AA_TEXT_OFF)) ||
            ((_qualityFlags & CRQUAL_AA_LINES_ON) &&
             (_qualityFlags & CRQUAL_AA_LINES_OFF)) ||
            ((_qualityFlags & CRQUAL_AA_SOLIDS_ON) &&
             (_qualityFlags & CRQUAL_AA_SOLIDS_OFF)) ||
            ((_qualityFlags & CRQUAL_AA_CLIP_ON) &&
             (_qualityFlags & CRQUAL_AA_CLIP_OFF)) ||
            ((_qualityFlags & CRQUAL_MSHTML_COLORS_ON) &&
             (_qualityFlags & CRQUAL_MSHTML_COLORS_OFF)) ||
            ((_qualityFlags & CRQUAL_QUALITY_TRANSFORMS_ON) &&
             (_qualityFlags & CRQUAL_QUALITY_TRANSFORMS_OFF)) ||
            ((_qualityFlags & ~allTraits) != 0)) {
            ok = false;
        }
        
        if (!ok) {
            RaiseException_UserError(E_INVALIDARG, IDS_ERR_INVALIDARG);
        }
    }

    void Render(GenericDevice& gdev) {
        ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, gdev);

        bool setResolution = false;
        
        // Establish render resolution
        if (_renderWidth != -1) {
            Assert(_renderHeight != -1);

            long currHeight, currWidth;
            dev.GetRenderResolution(&currWidth, &currHeight);

            // Only set if we haven't already set up on this image, since
            // this is outer-overriding.
            if (currWidth == -1) {
                dev.SetRenderResolution(_renderWidth, _renderHeight);
                setResolution = true;
            }
        }

        DWORD stashedFlags = dev.GetImageQualityFlags();
        DWORD newFlags = stashedFlags;

        // If current accumulated flags have nothing to say about a
        // trait (lines aa on or off for example) then accumulate my
        // trait.

        _DoTrait(newFlags, textTrait);
        _DoTrait(newFlags, lineTrait);
        _DoTrait(newFlags, solidTrait);
        _DoTrait(newFlags, clipTrait);
        _DoTrait(newFlags, htmlTrait);
        _DoTrait(newFlags, xformTrait);

        dev.SetImageQualityFlags(newFlags);

        _image->Render(gdev);

        if (setResolution) {
            // Set back to default value
            dev.SetRenderResolution(-1, -1);
        }

        // Restore the old (outer) flags
        dev.SetImageQualityFlags(stashedFlags);
    }


#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "ImageQualityClass" << _renderWidth
                  << _renderHeight << _qualityFlags
                  << _image;
    }
#endif
    
  protected:

    void _DoTrait(DWORD &newFlags, const DWORD &trait)  {
        if (! (newFlags & trait) ) {
            newFlags |= (_qualityFlags & trait);
        }
    }
        
    
    long  _renderWidth;
    long  _renderHeight;
    DWORD _qualityFlags;
};

Image *
MakeImageQualityImage(Image *img,
                      long width,
                      long height,
                      DWORD dwQualFlags)
{
    ImageQualityImage *im =
        NEW ImageQualityImage(img, width, height, dwQualFlags);

    im->Validate();

    return im;
}
                  
static Image *
RenderResolutionStatic(Image *img, AxALong *width, AxALong *height)
{
    return MakeImageQualityImage(img,
                                 width->GetLong(),
                                 height->GetLong(),
                                 0); 
}

Bvr
RenderResolution(Bvr imgBvr, long width, long height)
{
    Bvr wBvr = UnsharedConstBvr(LongToAxALong(width));
    Bvr hBvr = UnsharedConstBvr(LongToAxALong(height));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::RenderResolutionStatic,
                                  3,
                                  "RenderResolution",
                                  ImageType),
                        3, imgBvr, wBvr, hBvr);
}

static Image *
ImageQualityStatic(Image *img, AxALong *flags)
{
    return MakeImageQualityImage(img, -1, -1,
                                 (DWORD)(flags->GetLong()));
}

Bvr
ImageQuality(Bvr imgBvr, DWORD dwQualityFlags)
{
    Bvr flagsBvr = UnsharedConstBvr(LongToAxALong(dwQualityFlags));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::ImageQualityStatic,
                                  2,
                                  "ImageQuality",
                                  ImageType),
                        2, imgBvr, flagsBvr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\transimg.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements the Transform2Image class, a subclass of
    Image.

--*/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/probe.h"
#include "privinc/imgdev.h"
#include "privinc/except.h"
#include "privinc/overimg.h"
#include "privinc/transimg.h"
#include "privinc/xform2i.h"
#include "privinc/opt.h"

Transform2Image::Transform2Image(Transform2 *xf, Image *img)
    : _xform(xf), AttributedImage(img)
{
}

// Extract a bounding box from this image, outside of which
// everything is transparent.
// note: this creates axis aligned bbox
const Bbox2
Transform2Image::BoundingBox() {
    return TransformBbox2(_xform, _image->BoundingBox());
}

Real
Transform2Image::DisjointBBoxAreas(DisjointCalcParam &param)
{
    Transform2 *newXf =
        TimesTransform2Transform2(param._accumXform, _xform);

    DisjointCalcParam newP;
    newP._accumXform = newXf;
    newP._accumulatedClipBox = TransformBbox2(_xform,
                                              param._accumulatedClipBox);
    
    return _image->DisjointBBoxAreas(newP);
}

void
Transform2Image::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    Transform2 *stashedXf = ctx._accumXform;
    ctx._accumXform = TimesTransform2Transform2(stashedXf, _xform);

    // Now just call the _CollectDirtyRects on our superclass,
    // AttributedImage.  Do this because that method deals with the
    // ctx _processEverything flag correctly, and then invokes
    // CollectDirtyRects on the subimage.
    AttributedImage::_CollectDirtyRects(ctx);
    
    ctx._accumXform = stashedXf;
}

const Bbox2
Transform2Image::OperateOn(const Bbox2 &box) {
    return TransformBbox2(_xform, box);
}

Bool
Transform2Image::DetectHit(PointIntersectCtx& ctx) {
    Transform2 *stashedXf = ctx.GetTransform();
    ctx.SetTransform( TimesTransform2Transform2(stashedXf, _xform) );

    Transform2 *imgOnlyXf = ctx.GetImageOnlyTransform();
    ctx.SetImageOnlyTransform( TimesTransform2Transform2(imgOnlyXf, _xform) );

    Bool result = _image->DetectHit(ctx);

    ctx.SetImageOnlyTransform( imgOnlyXf );
    ctx.SetTransform(stashedXf);

    return result;
}

void
Transform2Image::Render(GenericDevice& _dev)
{
    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);

    //
    // Push state in device
    //
    Transform2 *oldXf = dev.GetTransform();
    Transform2 *newXf = TimesTransform2Transform2(oldXf, _xform);
    dev.SetTransform(newXf); 
    
    // tell device about me
    dev.PushTransform2Image(this);

    int attrib;

    if( (_xform->Type() == Transform2::Shear) ||
        (_xform->Type() == Transform2::Rotation)) {

        attrib = ATTRIB_XFORM_COMPLEX; 

    } else if((_xform->Type() == Transform2::Identity) ||
              (_xform->Type() == Transform2::Translation) ||
              (_xform->Type() == Transform2::Scale)) {

        attrib = ATTRIB_XFORM_SIMPLE;

    } else {
        // XXX: could be more efficient.. ie: create a method on xforms.  
        // XXX: also this is the common case
        Real m[6];
        _xform->GetMatrix(m);
        if( m[1] != 0  ||  m[3] !=0 ) {
            attrib = ATTRIB_XFORM_COMPLEX; 
        } else {
            attrib = ATTRIB_XFORM_SIMPLE;
        }
            
    }

    dev.SmartRender(_image, attrib);

    dev.PopTransform2Image();
    
    dev.SetTransform(oldXf); // reset state.
}

// TODO: could cache the transform being computed, but that's likely
// to only be worthwhile if we have fairly deep trees of transforms.
DiscreteImage *
Transform2Image::IsPurelyTransformedDiscrete(Transform2 **theXform)
{
    Transform2 *underXf;
    DiscreteImage *pureDiscrete = _image->IsPurelyTransformedDiscrete(&underXf);

    if (pureDiscrete) {
        
        *theXform = TimesTransform2Transform2(_xform, underXf);
        return pureDiscrete;
        
    } else {
        
        return NULL;
        
    }
}

Image *TransformImage(Transform2 *xf, Image *image)
{
    // Just be sure xf isn't singular, and that img isn't empty. 
    if (AxABooleanToBOOL(IsSingularTransform2(xf)) || image == emptyImage) {
        return emptyImage;
    }

    // Transformations of a solid color image are just the solid color
    // image. 
    if (image->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID)) {
        return image;
    }

    if (xf == identityTransform2) {
        return image;
    }

    return NEW Transform2Image(xf, image);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\solidimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements SolidImage, which is an infinite single
    colored image.  Mostly implemented in the header.

*******************************************************************************/


#include "headers.h"
#include <privinc/imagei.h>
#include <privinc/solidImg.h>


// Ok ok, SolidImage class is pretty small
// and light weight... so it's almost all implemented
// in the header.. anyoing huh ?

void
SolidColorImageClass::DoKids(GCFuncObj proc)
{
    Image::DoKids(proc);
    (*proc)(_color);
}


Image *SolidColorImage(Color *color)
{
    return NEW SolidColorImageClass(color);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\tiledimg.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Implements the TiledImage class
    which is an infinitly tiled image
    based on an aXb crop of an underlying
    image.

-------------------------------------*/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"
#include "privinc/vec2i.h"
#include "privinc/probe.h"
#include "privinc/bbox2i.h"
#include "privinc/overimg.h"
#include "appelles/xform2.h"

class TiledImage : public AttributedImage {
  public:

    TiledImage(Point2Value *minPt, Point2Value *maxPt, Image *img) :
        AttributedImage(img) 
    {
        _minPt = Demote(*minPt);
        _maxPt = Demote(*maxPt);
    }

    TiledImage(const Point2 &minPt, const Point2 &maxPt, Image *img) :
        _minPt(minPt), _maxPt(maxPt), AttributedImage(img) {}

    void Render(GenericDevice& dev);

    inline const Bbox2 BoundingBox() { return UniverseBbox2; }

    Real DisjointBBoxAreas(DisjointCalcParam &param) {
        // Could conceivably be smarter about how to calculate
        // disjoint bbox area for tiles, but returning infinity will
        // keep it on par with the Universal Bbox it returns.
        return HUGE_VAL;
    }
    
    void _CollectDirtyRects(DirtyRectCtx &ctx) {
        // A tiled image has universal extent, so just add this in.
        // TODO: Note that we should change this to pay attention to
        // cropping and matting, so that a tiled image won't
        // necessarily be considered to have universal extent.  This
        // current approach is overly pessimistic.
        ctx.AddDirtyRect(UniverseBbox2);
    }
    
#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) { return UniverseBbox2; }
#endif  // BOUNDINGBOX_TIGHTER

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "TiledImage" << " <minPt> " << " <maxPt> " << _image;
    }
#endif

    Bool  DetectHit(PointIntersectCtx& ctx);

    int Savings(CacheParam& p) { return 2; }

    virtual void DoKids(GCFuncObj proc) { 
        AttributedImage::DoKids(proc);
    }

    // tiled image is an intermediate 'other' node even though it
    // attributes other image types, it's sufficiently different and
    // intermediate that it's considered 'other' instead of its
    // underlying type.
    virtual void Traverse(TraversalContext &ctx) {
        ctx.SetContainsOther();
    }
    
  protected:
    // define image to tile: box within minPt/maxPt
    Point2 _minPt, _maxPt;
};

void
TiledImage::Render(GenericDevice& _dev)
{
    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);

    dev.RenderTiledImage(_minPt, _maxPt, _image);
}

Bool  
TiledImage::DetectHit(PointIntersectCtx& ctx) 
{
    Point2Value *ptv = ctx.GetLcPoint();

    if (!ptv) return FALSE;      // singular transform

    Point2 pt = Demote(*ptv);

    // get pt within the min/max bounds
    // then ask the underlying image if it's hit.
    
    // the point within the min/max bounds is:
    // p = min + [ (pt - min) MOD (max - min) ]
    // or: p = left + [ (pt - left) MOD width ]
    Real tileWidth = (_maxPt.x - _minPt.x);
    Real tileHeight= (_maxPt.y - _minPt.y);
    Real xRemainder = fmod(( pt.x - _minPt.x ), tileWidth);
    Real yRemainder = fmod(( pt.y - _minPt.y ), tileHeight);
    // we do this because fmod() can be negative
    Real modX = _minPt.x + (xRemainder < 0 ? (xRemainder + tileWidth)  : xRemainder);
    Real modY = _minPt.y + (yRemainder < 0 ? (yRemainder + tileHeight) : yRemainder);
    
    // Create a transform that transforms FROM the underlying
    // image space (modX,modY) TO the LcPoint (pt): pt = XF * mod
    // OR:  ptX = Tx + modX  implies:  Tx = ptX - modX
    Real tx = pt.x - modX;
    Real ty = pt.y - modY;
    Transform2 *UnderToLc = TranslateRR(tx,ty);

    // Since the transforms are encountered outside-in AND the transform
    // takes underlying image to Local, we need to put it BEFORE all the
    // encountered transforms... hence we premultiply (mult on left)
    // The net result is that the inverse of these transforms takes the
    // World Coordinate directly into the underlying image's space.
    // Note that this is different from what's done for a transformed image
    // on purpose.
    Transform2 *stashedXf = ctx.GetTransform();
    ctx.SetTransform( TimesTransform2Transform2( UnderToLc, stashedXf ) );
    Bool isHit = _image->DetectHit(ctx);
    ctx.SetTransform( stashedXf );
    
    return isHit;
}


Image *
TileImage_Old(const Point2 &minPt, const Point2 &maxPt, Image *image)
{
    // min must be lower left of max, if not return empty image
    if((minPt.x >= maxPt.x) || (minPt.y >= maxPt.y)) {
        return emptyImage;
    }

#if BADIDEA
    if (image->CheckImageTypeId(OVERLAYEDIMAGE_VTYPEID)) {
        
        //
        // Dynamic expression reduction
        //
        OverlayedImage *overImg = (OverlayedImage *)image;
        
        Image *newTop = NEW TiledImage(minPt, maxPt, overImg->Top());
        Image *newBot = NEW TiledImage(minPt, maxPt, overImg->Bottom());
        overImg->SetTopBottom(newTop, newBot);
        return overImg;
    } else if(image->CheckImageTypeId(OPAQUEIMAGE_VTYPEID)) {

        //
        // Opaque Image
        //
//        OpaqueImageClass *opcImg = (OpaqueImageClass *)image;
        AttributedImage *opcImg = (AttributedImage *)image;

        if(opcImg->_image->CheckImageTypeId(OVERLAYEDIMAGE_VTYPEID)) {
            
            OverlayedImage *overImg = (OverlayedImage *)opcImg->_image;

            //
            // Push xf past opacity, under overlay
            //
            overImg->SetTopBottom(NEW TiledImage(minPt, maxPt, overImg->Top()),
                                  NEW TiledImage(minPt, maxPt, overImg->Bottom()));
            
            opcImg->_image = overImg;
            return opcImg;
        } else {
            // !over
            // !opac
            // => error
            Assert(FALSE && "There's something wrong with dynamic image reduction");
        }
    }
#endif BADIDEA

    return NEW TiledImage(minPt, maxPt, image);
}

Image *
TileImage(Image *image)
{
    Bbox2 bbox = image->BoundingBox();

    return TileImage_Old(Point2(bbox.min.x, bbox.min.y),
                         Point2(bbox.max.x, bbox.max.y),
                         image);

    // BAD: Don't return the address of a field and pretend it's an
    // AxAValueObj!! 
    //return TileImage_Old(&bbox->min, &bbox->max, image);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\appel\values\image\plugimg.cpp ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    This is a discrete image that gets its bits filled in on the first
    rendering by reading from a pluggable image decoder.  Assume that
    there is no color-key transparency here. 

*******************************************************************************/

#include "headers.h"

#include <ddraw.h>
#include <ddrawex.h>
#include <htmlfilter.h>
#include <imgutil.h>

#include "privinc/imagei.h"
#include "privinc/discimg.h"
#include "privinc/vec2i.h"
#include "privinc/ddutil.h"
#include "privinc/debug.h"
#include "privinc/ddutil.h"
#include "privinc/ddsurf.h"
#include "privinc/dddevice.h"
#include "privinc/viewport.h"
#include "privinc/resource.h"
#include "include/appelles/hacks.h" // for viewer resolution

#define CHECK_HR(stmnt) \
  hr = stmnt;               \
  if (FAILED(hr)) {         \
      goto Error;           \
  }

// Returns whether or not the described surface will need a palette. 
bool
FillInSurfaceDesc(const GUID& bfid,
                  DDSURFACEDESC& ddsd)
{
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                          DDSCAPS_SYSTEMMEMORY;

    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;

    bool needsPalette = false;
    
    if (IsEqualGUID(bfid, BFID_INDEXED_RGB_8)) {
        // Need to OWNDC for ddrawex.dll, otherwise getting dc on 8bit
        // surf won't work (and it will never work on non-ddrawex
        // ddraws). 
        ddsd.ddsCaps.dwCaps |= DDSCAPS_OWNDC;
        ddsd.ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED8;
        ddsd.ddpfPixelFormat.dwRGBBitCount = 8;
        ddsd.ddpfPixelFormat.dwRBitMask = 0;
        ddsd.ddpfPixelFormat.dwGBitMask = 0;
        ddsd.ddpfPixelFormat.dwBBitMask = 0;
        needsPalette = true;
    } else if (IsEqualGUID(bfid, BFID_RGB_555)) {
        ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
        // Assume high-order 5 bits are red, mid-order 5 green,
        // low-order 5 blue.
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00007C00L;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x000003E0L;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x0000001FL;
    } else if (IsEqualGUID(bfid, BFID_RGB_565)) {
        ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
        // Assume high-order 5 bits are red, mid-order 6 green,
        // low-order 5 blue.
        ddsd.ddpfPixelFormat.dwRBitMask = 0x0000F800L;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x000007E0L;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x0000001FL;
    } else if (IsEqualGUID(bfid, BFID_RGB_24)) {
        ddsd.ddpfPixelFormat.dwRGBBitCount = 24;
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000L;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00L;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FFL;
    } else if (IsEqualGUID(bfid, BFID_RGB_32)) {
        ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000L;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00L;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FFL;
    } else {
        // TODO: Add support for more BFIDs
        RaiseException_InternalError("Incoming bit depth not supported");
    }

    return needsPalette;
}

class CImageDecodeEventSink : public IImageDecodeEventSink {
  public:
    CImageDecodeEventSink(bool actuallyDecode,
                          DirectDrawViewport *viewport,
                          DDSurface *finalSurface)
        : _nRefCount (0)
    {
        _actuallyDecode = actuallyDecode;
        _infoGatheringSucceeded = false;

        if (!actuallyDecode) {
            _width = -1;
            _height = -1;
        } else {
            _finalSurfToBeBlitTo = finalSurface;
            _viewport = viewport;
        }
    }
    
    
    ~CImageDecodeEventSink() {}

    ULONG STDMETHODCALLTYPE AddRef() {
        _nRefCount++;
        return (_nRefCount);
    }

    ULONG STDMETHODCALLTYPE Release() {
        _nRefCount--;
        
        if (_nRefCount == 0) {
            TraceTag((tagImageDecode,
                      "Deleting CImageDecodeEventSink"));
            delete this;
            return (0);
        }

        return (_nRefCount);
    }
    
    STDMETHOD(QueryInterface)(REFIID iid, void** ppInterface) {
        
        if (ppInterface == NULL) {
            return (E_POINTER);
        }

        *ppInterface = NULL;

        if (IsEqualGUID(iid, IID_IUnknown)) {
              *ppInterface = (IUnknown*)(IImageDecodeEventSink *)this;
        } else if (IsEqualGUID(iid, IID_IImageDecodeEventSink)) {
            *ppInterface = (IImageDecodeEventSink*)this;
        } else {
            return (E_NOINTERFACE);
        }

        //  If we're going to return an interface, AddRef it first
        if (*ppInterface) {
              ((LPUNKNOWN)*ppInterface)->AddRef();
              return S_OK;
        }

        return (S_OK);
    }


    STDMETHOD(GetSurface)(LONG nWidth, LONG nHeight,
                          REFGUID bfid, 
                          ULONG nPasses,
                          DWORD dwHints,
                          IUnknown** ppSurface) {

        if (!ppSurface) {
            return E_POINTER;
        }

        if (!_actuallyDecode) {

            // In this case, we just want to stash away the dimensions
            // and the format, and then fail, so that we won't
            // actually read anything in.
            TraceTag((tagImageDecode, "Decoding width = %d, height = %d",
                      nWidth, nHeight));
            TraceTag((tagImageDecode, "Decoding format = %s",
                      IsEqualGUID(bfid , BFID_RGB_24) ? "BFID_RGB_24"
                      : (IsEqualGUID(bfid, BFID_RGB_8) ? "BFID_RGB_8"
                         : (IsEqualGUID(bfid, BFID_RGB_555) ? "BFID_RGB_555"
                            : "Something Else"))));

        
            _width = nWidth;
            _height = nHeight;

            _infoGatheringSucceeded = true;

            // Now that we have this stuff, return E_FAIL to indicate
            // not to continue with the download.
            return E_FAIL;
            
        } else {

            TraceTag((tagImageDecode, "2nd pass through GetSurface"));


            // This surface description is generated from the BFID and is
            // needed for comparing to the final surface coming in.
            DDSURFACEDESC ddsd;
            ddsd.dwHeight = nHeight;
            ddsd.dwWidth = nWidth;
            bool needsPalette = FillInSurfaceDesc(bfid, ddsd);

            // Compare pixel formats.  If identical, use the surface passed to this
            // method.  If the target surface needs a palette, however, use a separate
            // surface to accomodate the image palette.

            DDPIXELFORMAT& pf1 = _viewport->_targetDescriptor._pixelFormat;
            DDPIXELFORMAT& pf2 = ddsd.ddpfPixelFormat;
    
            if (!needsPalette &&
                pf1.dwFlags == pf2.dwFlags &&
                pf1.dwRGBBitCount == pf2.dwRGBBitCount &&
                pf1.dwRBitMask == pf2.dwRBitMask &&
                pf1.dwGBitMask == pf2.dwGBitMask &&
                pf1.dwBBitMask == pf2.dwBBitMask &&
                pf1.dwRGBAlphaBitMask == pf2.dwRGBAlphaBitMask) {

                TraceTag((tagImageDecode, "Using incoming surface"));

                // operator= takes a reference
                _surfToDecodeTo = _finalSurfToBeBlitTo->IDDSurface();
                _usingProvidedSurface = true;

            } else {

                TraceTag((tagImageDecode, "Creating separate surface"));
        
                // Create a NEW surface.  Will release after we blit to the
                // final one. 
                _viewport->CreateSpecialSurface(
                    &_surfToDecodeTo,
                    &ddsd,
                    "Couldn't create surface for plugin image decoding");

                // If the image surface is going to need a palette, attach one here.
                // Note that we do not need to initialize it:  the palette entries will
                // be assigned from the image decoder.

                if (needsPalette) {
                    PALETTEENTRY        ape[256];
                    LPDIRECTDRAWPALETTE pDDPalette;

                    _viewport->CreateDDPaletteWithEntries (&pDDPalette, ape);
                    if (FAILED(_surfToDecodeTo->SetPalette (pDDPalette))) {
                        Assert (!"Error attaching palette to PNG target surface.");
                     }
                    pDDPalette->Release();
                }
        
                _usingProvidedSurface = false;
            }
            
            IUnknown *unk;
            
            HRESULT hr =
                _surfToDecodeTo->QueryInterface(IID_IUnknown,
                                                (void **)&unk);
            if (FAILED(hr)) {
                Assert(FALSE && "QI for IUnknown failed");
                return E_FAIL;
            }

            // The QI did the AddRef, so don't worry about doing
            // another one.
            *ppSurface = unk;

            return S_OK;
        }
        
    }
    
    STDMETHOD(OnBeginDecode)(DWORD* pdwEvents,
                             ULONG* pnFormats, 
                             GUID** ppFormats) {

        if (!pdwEvents || !pnFormats || !ppFormats) {
            return E_POINTER;
        }
        
        // No progressive downloading or palette stuff now. 
        *pdwEvents = IMGDECODE_EVENT_USEDDRAW;

        const int numberOfFormatsUsed = 3;
        GUID *pFormats =
            (GUID*)CoTaskMemAlloc(numberOfFormatsUsed * sizeof(GUID));
        
        if (pFormats == NULL) {
            return E_OUTOFMEMORY;
        }

        *ppFormats = pFormats;
        
        // Return the formats in the order we'd prefer.  Come up with
        // the first format solely based upon the bitdepth of the
        // current display, since that's what we operate in.  The rest
        // are not as important in terms of their ordering, since all
        // of them will require a StretchBlt to get into native
        // format. 
        // TODO: We no longer import to either of the 16 bit formats
        // because we really don't know which is right for the final
        // use of the surface.  We need to think about what the
        // correct source for our "Native" import format should be.
        // the screen depth is not the right answer.
        HDC dc = GetDC (NULL);    
        int bpp = GetDeviceCaps(dc, BITSPIXEL) * GetDeviceCaps(dc, PLANES);
        ReleaseDC (NULL, dc);
        
        TraceTag((tagImageDecode, "Display is %d bits", bpp));

        switch (bpp) {
          case 32:
            *pFormats++ = BFID_RGB_32;
            *pFormats++ = BFID_RGB_24;
            *pFormats++ = BFID_RGB_8;
            break;

          case 24:
            *pFormats++ = BFID_RGB_24;
            *pFormats++ = BFID_RGB_32;
            *pFormats++ = BFID_RGB_8;
            break;
            
          case 16:
            *pFormats++ = BFID_RGB_32;
            *pFormats++ = BFID_RGB_24;
            *pFormats++ = BFID_RGB_8;
            break;
            
          case 8:
            *pFormats++ = BFID_RGB_8;
            *pFormats++ = BFID_RGB_32;
            *pFormats++ = BFID_RGB_24;
            break;
        }
        
        *pnFormats = numberOfFormatsUsed;

        return S_OK;
    }
    
    STDMETHOD(OnBitsComplete)() {
        Assert(FALSE && "Shouldn't be here, not registered for this");
        return S_OK;
    }
    
    STDMETHOD(OnDecodeComplete)(HRESULT hrStatus) {
        // Don't do anything special here.
        return S_OK;
    }
    
    STDMETHOD(OnPalette)() {
        Assert(FALSE && "Shouldn't be here, not registered for this");
        return S_OK;
    }
    
    STDMETHOD(OnProgress)(RECT* pBounds, BOOL bFinal) {
        Assert(FALSE && "Shouldn't be here, not registered for this");
        return S_OK;
    }

    void GetSurfToDecodeTo(IDirectDrawSurface **pSurfToDecodeTo) {
        _surfToDecodeTo->AddRef();
        *pSurfToDecodeTo = _surfToDecodeTo;
    }
    
    ULONG                           _width;
    ULONG                           _height;
    bool                            _infoGatheringSucceeded;
    bool                            _usingProvidedSurface;
    
  protected:
    ULONG                           _nRefCount;
    RECT                            _rcProg;
    DWORD                           _dwLastTick;
    bool                            _actuallyDecode;
    DDSurfPtr<DDSurface>            _finalSurfToBeBlitTo;
    DirectDrawViewport             *_viewport;
    DAComPtr<IDirectDrawSurface>    _surfToDecodeTo;
};


HINSTANCE hInstImgUtil = NULL;
CritSect *plugImgCritSect = NULL;

HRESULT
MyDecodeImage(IStream *pStream,
              IMapMIMEToCLSID *pMap,
              IUnknown *pUnkOfEventSink)
{
    CritSectGrabber csg(*plugImgCritSect);
    
    typedef HRESULT (WINAPI *DecoderFuncType)(IStream *,
                                              IMapMIMEToCLSID *,
                                              IUnknown *);

    static DecoderFuncType myDecoder = NULL;
  
    if (!myDecoder) {
        hInstImgUtil = LoadLibrary("imgutil.dll");
        if (!hInstImgUtil) {
            Assert(FALSE && "LoadLibrary of imgutil.dll failed");
            return E_FAIL;
        }

        FARPROC fptr = GetProcAddress(hInstImgUtil, "DecodeImage");
        if (!fptr) {
            Assert(FALSE && "GetProcAddress in imgutil.dll failed");
            return E_FAIL;
        }

        myDecoder = (DecoderFuncType)(fptr);
    }

    return (*myDecoder)(pStream, pMap, pUnkOfEventSink);
}

// Lifted from Qa.cpp, in Ken Sykes' test code.  TODO: Make sure this
// is necessary with kgallo.
#define MAX_URL 2048
void
MyAnsiToUnicode(LPWSTR lpw, LPCSTR lpa)
{
    while (*lpa)
        *lpw++ = (WORD)*lpa++;
    *lpw = 0;
}

// When realDecode is true, the width, height, and bfid params are not filled
// in and the surface must be correctly set up.  When it is false, the
// surface is ignored and the dimensions and bfid are filled in.  In both
// cases, the function will throw an appropriate exception on failure.

bool
DecodeImageFromFilename(char *szFileName,
                        IStream *pStream,
                        bool realDecode,
                        DirectDrawViewport *viewport,
                        DDSurface *finalSurface,
                        IDirectDrawSurface **pSurfToDecodeInto,
                        LONG *outWidth,  
                        LONG *outHeight)
{
    HRESULT hr;

    LARGE_INTEGER startPos = { 0, 0 };

    CImageDecodeEventSink *eventSink =
        NEW CImageDecodeEventSink (realDecode,
                                   viewport,
                                   finalSurface);

    if (!eventSink) //if the NEW failed
    {
        RaiseException_OutOfMemory("Failed to allocate CImageDecodeEventSink in DecodeImageFromFilename", sizeof(CImageDecodeEventSink));
    }

    DAComPtr<IUnknown> pEventSinkUnk;

    CHECK_HR( eventSink->QueryInterface(IID_IUnknown,
                                       (void **)&pEventSinkUnk) );

    TraceTag((tagImageDecode, "Starting decode of %s", szFileName));
    
    Assert(pStream);
    if(pStream) {
        pStream->Seek (startPos, STREAM_SEEK_SET, NULL);
    }
    else
    {
        goto Error;
    }

    hr = MyDecodeImage(pStream, NULL, pEventSinkUnk);

    if (!realDecode) {
        
        if (!eventSink->_infoGatheringSucceeded) {
            RaiseException_UserError(E_FAIL, IDS_ERR_NO_DECODER, szFileName);
        }

        // Be sure we have valid dimensions.
        if (eventSink->_width == -1 || eventSink->_height == -1) {
            
            TraceTag((tagImageDecode, "Getting dimensions failed"));
            RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED, szFileName);
        }

        *outWidth = eventSink->_width;
        *outHeight = eventSink->_height;
        
        TraceTag((tagImageDecode,
                  "Getting dimensions succeeded: (%d, %d)",
                  *outWidth, *outHeight));
        
    } else {


        // If we're here and we fail, then something's weird.  We were
        // successfully able to instantiate the decoder enough to get
        // dimensions.  Going to consider this a User error, because
        // the decoder is outside of our control.
        Assert(!(FAILED(hr)));
        if (FAILED(hr)) {
            RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED, szFileName);
        }

        eventSink->GetSurfToDecodeTo(pSurfToDecodeInto);

        TraceTag((tagImageDecode, "Ending decode of %s", szFileName));
        
        // All done.  Surf is filled in, nothing more to do.
    }
    
    return eventSink->_usingProvidedSurface;

Error:
    TraceTag((tagImageDecode, "Decoding failed with hr of %d", hr));
    RaiseException_InternalError("Image Decoding Failed");
    return false;
}


//////////////// PluginDecoderImageClass //////////////////



class PluginDecoderImageClass : public DiscreteImage {
  public:
    PluginDecoderImageClass()
    : _heapCreatedOn(NULL), _imagestream(NULL),
      _filename(NULL), _urlPath(NULL) {}

    void Init(char *urlPath,
              char *cachePath,
              IStream *imagestream,
              COLORREF colorKey);
    
    ~PluginDecoderImageClass();
    
    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev);
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(PluginDecoderDiscreteImage @ " << (void *)this << ")";
    }   
#endif

    virtual VALTYPEID GetValTypeId() { return PLUGINDECODERIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == PluginDecoderImageClass::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }
    
    bool ValidColorKey(LPDDRAWSURFACE surface, DWORD *colorKey) {
        if(_colorKey != INVALID_COLORKEY) {
            *colorKey = DDColorMatch(surface, _colorKey);
            return true;
        } else {
            *colorKey = INVALID_COLORKEY;  // xxx: won't work for argb
            return false;
        }
    }

  protected:
    COLORREF          _colorKey;
    DynamicHeap      *_heapCreatedOn;
    DAComPtr<IStream> _imagestream;
    char             *_filename;
    char             *_urlPath;
};

void
PluginDecoderImageClass::Init(char *urlPath,
                              char *cachePath,
                              IStream *imagestream,
                              COLORREF colorKey)
{
    _membersReady = false;
    
    // When this image subtype is Decoded, we first do a fake
    // decoding of the image, just to get the height and width.  Only
    // when InitIntoDDSurface is called do we actually do another
    // decode to get the real bits.

    _heapCreatedOn = &GetHeapOnTopOfStack();
    _colorKey = colorKey;

    _filename = (char *)StoreAllocate(*_heapCreatedOn,
                                      (lstrlen(cachePath) + 1) *
                                      sizeof(char));
    lstrcpy(_filename, cachePath);

    _urlPath = (char *)StoreAllocate(*_heapCreatedOn,
                                      (lstrlen(urlPath) + 1) *
                                      sizeof(char));
    lstrcpy(_urlPath, urlPath);
    
    // Initi